Background activities on mobile devices can cause signii-cant battery drain with little visibility or recourse to the user.
ey can range from useful but sometimes overly aggressive tasks, such as polling for messages or updates from sensors and online services, to outright bugs that cause resources to be held unnecessarily.
In this paper we instrument the Android OS to characterize background activities that prevent the device from sleeping.
We present T, an OS mechanism that interposes on events and signals that cause task wakeups, and allows for their detailed monitoring , ltering, and rate-limiting.
We demonstrate how T can help reduce battery drain in scenarios involving popular Android apps with background tasks.
We also show how T can mitigate the eeects of well-known energy bugs while maintaining most of the apps' function-ality.
Finally, we elaborate on how developers and users can devise their own application-control policies for T to maximize battery lifetime.
e accelerated growth of sensing, computational, storage, and communication capabilities of mobile devices has enabled a rich application environment that rivals the performance of desktop computers.
Even so, battery technology has not followed the same advancement pace and there is little evidence that this situation will dramatically improve.
As a result, battery lifetime has become a major usability concern, with users willing to enjoy the latest apps on their smartphones and tablets, but, at the same time, worrying that their battery will not last long enough.Since the inception of mobile computing, both industry and academia have developed a slew of techniques to reduce power at the architecture [񮽙, 񮽙񮽙], OS [񮽙񮽙, 񮽙񮽙] and application levels [񮽙񮽙, 񮽙񮽙], and today's systems draw little power while idling.
Due to its user-centric and interactive nature, the eow of a mobile application is driven by events such as user actions, sensor I/O, and message exchanges.
Such event-driven paradigm lets the system idle until a new event arrives.
Mobile OSes, such as Android, iOS, and Windows Phone, take advantage of such idling opportunities to engage in opportunistic suspend.
Upon brief periods of idling, the handheld switches to the default suspend state.
Hardware blocks, including the CPU, GPU, GPS, and network modem, shii to low-power mode and soware state is kept in self-refreshing RAM.
e same blocks return from suspension upon interrupts emitted by hardware or soware indicating that they have pending requests.
With the rise of multitasking and the multiplication of background services and complex mobile applications, we expect this amount of interrupts to increase, forcing the system to spend more time active to attend requests.
Such active periods take a toll on battery lifetime.
A recent study by Google clearly shows this impact: each second of active use of a typical phone reduces the standby time by two minutes [񮽙񮽙].
is paper studies the problem of battery drain mostly due to app-originated background operations that wake up the mobile system.
We present T, an OS mechanism we built for Android that interposes on events and signals responsible for task wakeups -alarms, wakelocks, broadcast receivers, and service invocations.
Like a number of proling tools, T allows us to characterize the background behavior of diierent apps installed on a device.
In §񮽙, using T's instrumentation, we show how a set of installed applications can dramatically aect the battery lifetime of four diierent devices.
Unlike existing proling tools, however, T can also selectively block or ratelimit the handling of such events and signals following exible policies.
In this way, T can, for example, limit the frequency at which an application schedules alarms or receives notiications of speciied events, providing negrained control over the energy usage of apps that may be useful, but are irresponsible or ineecient with respect to their background activities.
In §񮽙.
.
we show via a few case studies how T can reduce the energy consumed by energy bugs [񮽙񮽙] in legitimate apps.
We summarize our contributions as follows:• We characterize how applications and core components of the Android OS use speciic features to enable background computing, and how this computing signiicantly aects energy use.
In special, we note that Google Mobile Services play a major role on battery drain while the device is dormant ( §񮽙).
• We introduce T, an OS mechanism to control the frequency at which background tasks are handled, thereby limiting their impact on energy consumption ( §񮽙).
T leverages code-injection technology and is applicable to any Java-based Android application.
• We demonstrate how T can successfully throttle the background behavior of popular applications, thus reducing their energy footprint ( §񮽙).
We show how diierent policies reduce power draw in exchange for little to no impact on functionality.
Despite being a powerful mechanism, T is only a step towards eeective control of background energy usage.
In particular, there are still challenges in helping users deene policies that are eeective, yet not disruptive to the user experience.
We discuss such challenges in §񮽙.
Smartphone and tablet users are used to being always connected, expecting immediate notiications of a new e-mail or application update.
Other common background operations include polling navigational sensors for location clues and turning on the network radio for incoming messages.
Especially in Android, where there is little restriction on what apps can do in the background and developer's discipline is the main factor preventing ineecient applications, apps can hog resources and waste energy.Traditionally there has been little visibility, both to app developers and to users, on the contribution of individual apps to energy use, especially while in the background.
It is even harder to know whether an app is actually running or idling.
Recent monitoring and proling tools have helped bridge this visibility gap [񮽙, 񮽙񮽙, 񮽙񮽙, 񮽙񮽙, 񮽙񮽙, 񮽙񮽙, 񮽙񮽙], as one cannot optimize what cannot be measured.Today's average handheld contains a large amount of third-party soware.
A survey shows a global average of apps installed on a mobile device [񮽙񮽙].
Even with the best currently available tools, the end user can do little to cope with ineecient apps.
Most of the tools above target developers and provide little help for the user.
Even the friendlier ones, such as eStar [񮽙񮽙] and Carat [񮽙񮽙], when highlighting energy-ineecient programs, can only oer to kill or uninstall the culprit app, perhaps suggesting replacements.
Unfortunately, this is too coarse-grained a solution and some apps with irreplaceable functionality become an inconvenience one has to live with.
T oers the possibility of much ner-grained control once an energy hog or bug is found.
It provides information on which tasks are expending the most energy and can rate-limit their execution.
T detects most causes of device wakeup that are visible at the framework level of Android, and can lter their continuation in real time.To demonstrate the signiicant diierence that a set of running tasks can make in a device's battery life, we measured the battery drop of four Android devices (two smartphones and two tablets, cf. Table 񮽙) running two diierent application sets, while idling and with the screen o. Conservatively, we consider three scenarios: the rst testing environment (Pure AOSP) consists of a stripped version of the Android Open Source Project (AOSP) OS containing a minimum number of services and apps; the second one adds Google Mobile Services (GMS) on top of Pure AOSP.
GMS consists of proprietary applications and services developed by Google, such as Calendar, Google+ (social media), Google Now (personal assistant), Hangouts (instant messaging), Maps, Photos, Play Service (integrating API), Play Store, and Search.
Due to their popularity and added value, GMS apps are included in most Android devices sold today.
For the third scenario, which we only ran on the Galaxy Nexus phone, we also installed the ten most popular free apps of Google's Play Store as of January y 񮽙 .
We based all environments on the KitKat ((.
.)
version of Android.
For the experiments, we lee each device unattended running with its connguration at default settings.
Other relevant settings include connection to a WiFi access point, enabled location-reporting, and background network synchronization.
We expect most of the battery drainage to stem from static-voltage leakage and eventual background processing.
Figure 񮽙 shows the time taken by each environmentdevice combination to deplete the battery.
For all devices, Pure AOSP took the longest to completely drain the battery.
In the case of tablets, this diierence spanned dozens of hours.
To investigate why this happened, we instrumented the Android soware stack to timestamp the occurrence of background events.
Additionally, we connected one of our devices (Galaxy Nexus) to a Monsoon power monitor [񮽙񮽙] and collected power traces from the battery.
Finally, we aligned and synchronized both the event and power timelines to understand their correlation.
Figure 񮽙 depicts a six-minute slice of this combination.
We observe that GMS triggers more events in the background and that they are correlated with the surge of power peaks.
We used this tracing knowledge to build a mechanism that counters the energy eeect due to excessive wakeups.
Because this mechanism relies on OS internals, we rst need to understand how an Android app functions while in the background.
is section provides a concise description of Android's power-management system followed by an overview of the components constituting a mobile app and how applications behave while running in the background.
Finally, we highlight the innuence of background execution on battery drain using four types of events: wakelocks, services, broadcast receivers, and alarms.
§񮽙 describes T, our control system that adjusts the frequency at which such events occur.
draining the battery.
To curb system suspension, Android uses Wakelocks to keep the system awake.
Wakelocks are reference-counted objects, similar to concurrency locks, that can be acquired/released by kernel and privileged userspace code.
A wakelock acquire expresses a process's need for the system to remain awake until run completion.
A wakelock acquire either holds a resource awake until a release call occurs or sets up a timer to relinquish the lock at a later time.Kernel drivers use wakelocks to block the suspension of diierent system components (e.g., CPU, network, screen), whereas the Android application framework leverages wakelocks for diierent levels of suspension, represented by groups of components (e.g., keep the network radio awake vs. keep the radio, screen, and CPU awake).
As an example of suspend-blocking by the OS, Android automatically acquires a wakelock as soon as it is notiied of an input event and only releases the wakelock once some application handles the event or there is a timeout.
Application developers can also directly instantiate and manipulate wakelocks using the Wakelock API.
A proper e-book reader app must acquire a wakelock to keep the screen awake so that the user can read her favorite novel without interruption.
Wakelocks play an important role in guaranteeing proper background task execution in face of default suspension, as we will see next.
Barring a few interface-less system processes, an Android application consists of a set of Activities that places the UI widgets on the screen.
An application starts with a single thread of execution attached to the foreground UI, which is mostly responsible for dispatching interface events.
To avoid app unresponsiveness and user frustration, a wise programmer would move other computations to concurrent worker threads while the UI responds to input events.
Support for concurrency comes in the form of a number of standard Java primitives, such as Threads and Futures, as well as Android's own navors: AsyncTasks and message Handlers.
However, such primitives only work when the application is in the active state.As the user navigates through, out of, and back to an application, its lifecycle transitions between diierent states according to activity visibility.
An application is active if one of its activities receives user focus in the foreground.
If the user switches to another app or decides to turn o the screen, the application is paused and moved to the background.
Because mobile apps are multitasked, developers must have a way to run code even when their app is not occupying the screen.
e small screen size of a smartphone or tablet prevents multiple applications from running simultaneously.
To conserve energy, apps are frozen and stop working once sent to the background, either due to the opening of another application or a screen timeout.
Context switching opens room for opportunistic suspend -by making apps invisible, the Android OS frees its own set of wakelocks, opening space for hardware throttling.Android oers application developers a small and welldeened interface for background-task ooading that takes care of scheduling latent tasks [񮽙].
is interface comprises a handful of components including services, broadcast receivers, and alarms.
e internal implementation of such components also leverages wakelocks to keep the device awake while executing tasks.Services are application components that run asynchronously on background threads or processes and do not directly interact with the user.
Instead, Activities dispatch services to perform long-duration operations or to access resources on behalf of users, such as downloading remote les or synchronizing data with a cloud-based storage.
An advantage of running services separately is that their running persists even aer closing the owner's interface.
Apps and widgets rely on services being operational without need of manual restart.BroadcastReceiver is a reactive mechanism that permits programs to asynchronously respond to speciied events.
An application registers a BroadcastReceiver along with an event-subscription list -the IntentFilter -that is used to determine if the application is eligible to respond to a given event.
Events can be predeened by the system (e.g., "battery fully charged") or developer-deened (e.g., "backup nished").
Receiver threads remain dormant until a matched event arrives and respond by running a callback function.
A le-hosting app could, for instance, register a receiver to display a notiication box once it discovers that a scheduled data synchronization has nished.Another common programming pattern is the ability to perform time-based operations outside the lifetime of an application.
For instance, checking for incoming e-mails every so oen is a recurrent user operation that could be automatized.
e Android SDK oers developers the AlarmManager mechanism to fullll the scheduling of periodic tasks at set points.
At each alarm trigger, the system wakes up and executes the scheduled callback function, whose contents can take various forms: a UI update, a service call, an I/O operation, scheduling a new alarm, etc.
Alarms are a good t for opportunistic suspend: apps are only activated when there is work to do.In summary, Android uses at least three types of asynchronous mechanisms to perform background tasking: services, broadcast receivers, and alarms.
Aligned with wakelocks, we have a powerful collection of events that can keep the system awake.
In the next section, we introduce T, a system that acts on this small and well-deened interface to throttle the rate at which background events are handled in exchange for energy savings.
Having seen that background events can noteworthily affect the sleeping pattern of mobile devices, we consider the possibility of regulating their frequency to improve battery life.
We introduce a connguration mechanism for declaring thresholds to the frequency of these events.
We model this regulation process using three sequential steps: (() observation; (() comparison; and (() action.Event-frequency regulation works based on the speciication of occurrence limits.
We establish a policy mechanism that lets users deene how oen the running system should permit a given background event to proceed.
A policy is a contract that declares the conditions for an event execution.
is contract speciies the event type as well as its identiier; an optional list of aected apps, in case we want to restrict such enforcement to a subset of event dispatchers or receivers; whether the policy enforcement also takes place when the event owner (app) is in the foreground; and the rate at which they are allowed to execute.
From this deenition, an energy-savvy user could program her smartphone to permit calls to WeatherUpdateService from a weather-forecast app at most once every six hours, whereas calls to LocationUpdateService from the same app would remain unlimited.To enforce user-deened policies, we outline a controller comprising three agents: observer, arbiter and actuator. 񮽙
e observer intercepts every event occurrence and bookkeeps its frequency.
e arbiter veriies whether the measured event rate is above the policy-deened threshold, if it exists, and notiies the actuator, which hijacks the event continuation to artiicially reduce its occurrence rate.
Figure : Sketch of our event-control system as a three-stage pipeline.ere are two ways to fullll event throttling: canceling or delaying.
An event cancel denies the continuation of its call, with an early return that prevents the payload or the event callback from running.
An event delay, on the other hand, postpones the continuation of the event call for a limited time.
In this work, we opt for canceling the event handling.
We discuss the pros and cons of each choice in §񮽙.
It is important to understand that an event cancel does not result in a crash.
Alarms, services and broadcast receivers all run asynchronously.
Wakelock requests, on the other hand, are synchronous and their denial will result in a sleeping system when a waiting task is expected to run.
Still, the task is never aborted, but runs in chunks when the system wakes up.
Our method prevents the triggering of unwanted events.
When it is not possible, we abort the event continuation at the earliest opportunity to reduce the energy cost of the event payload.To drive the implementation of our system, we establish a few requisites and considerations: Comprehensive support for events.
e control system should be inclusive.
While app-speciic solutions are eeective, they do not scale to other programs.
e stage pipeline should monitor and, if necessary, actuate on every event instance.
Particulars about a speciied event should be conned to its policy and not aect the controller.
It is the responsibility of the policy designer to deene a sane event frequency, considering, perhaps, the context and the impact of an event hijack.
To implement an all-encompassing monitor system, we target an OS-level solution.
Support for power-oblivious applications.
Users should not abstain from using their favorite apps even if they are power hogs.
Uninstalling or suggesting alternative apps for the same purpose should not be acceptable.
e system should cope with the existence of ill-behaved apps and act upon their misbehavior if directed by the policy designer.
Compatibility.
Many solutions that rely on deep system introspection require extensive rewrites of system components [񮽙񮽙, 񮽙񮽙, 񮽙] or even writing systems from scratch [񮽙񮽙].
Although tempting, straying from the mainline can severely limit the userbase, especially in the case of consumer-oriented OSes.
With that in mind, our solution should exhibit high compatibility and keep a minimum amount of changes to the underlying OS.
Eciency.
Mobile apps must cope with limited computational and energy resources.
e control system should avoid high computational overhead to prevent high battery drain and system slowdown.
To avoid reimplementing OS components to regulate event handling, T uses the Xposed framework [񮽙񮽙] to enable system modiications at runtime.While requiring the device to be rooted, Xposed enables deep system modiications with no need to decompile applications nor ash the device 񮽙 .
Xposed intercepts Java methods and temporarily diverts the execution ow to function-hook callbacks for inspection and modiication.
Developers deene these callbacks and compile them as separate modules.
Function-call hooking happens by matching the method's name and signature of the declared call-񮽙 For brevity reasons, we refer readers to [񮽙񮽙] for an explanation on how such thing is possible.
back with the running code.
Callbacks run on the context of the intercepted application.
Xposed allows for changing the parameters of a method call, modifying its return value or terminating it early.
We leverage the hooking mechanism to intercept function calls originating from or directed at our events of interest.
Finally, function hooks can be distributed as separate programs in self-contained APK les.
ey are not bound to a speciic Android version and work without changes on the majority of customized Android releases, including those from Samsung, HTC, Sony, LG, and the CyanogenMod open-source community [񮽙񮽙].
Figure 񮽙 shows how T relates to the Android OS.
T sits, along with Xposed, between user applications and the Java-based application framework, which serves as the foundation for the Android SDK.
Events have directions, which helps us deene how to write the interception payload.
While service and wakelock calls originate from apps and are forwarded to the framework, alarms and broadcast receivers work in the opposite direction.T consists of a series of function hooks that interpose on the background-processing interface and act as a controller mechanism to enforce user-deened policies.
To implement T's event-canceling mechanism, we leverage Xposed's introspection API to explore, monitor, intercept and modify public and private classes, methods and members of the framework (Table 񮽙).
We used our knowledge on the Android SDK aligned with the source code of Android's framework stack to decide where to place the instrumentation points that would constitute our controller.
We analyzed the source code stemming from each event call on the SDK's public interface.
Modeling the relationships between subroutines as a call graph, we considered each interface function as a leaf node.
In some occasions, we had to backtrack the call graph to nd a proper instrumentation point.
is was necessary for three reasons: (() the public interface did not oer enough context to feed our monitoring system (e.g., missing receiver name, unclear caller-callee relationship, etc.); (() in the case of receiving events, it was better to interpose on a call as early as possible to avoid unnecessary operations before a cancellation; () an event call may have more than one function signature, therefore we looked for a converging function node.
We found one exception to the last rule when handling broadcast receivers.
Applications can declare receivers in two ways: statically via a Manifest le or dynamically using the Android SDK API.
Since the Android framework keeps separate data structures for each case, we had to instrument them separately.
T's interception can suppress wakeups due to service invocations, wakelock acquires, and intent broadcasts.
Because of the way Android handles alarms, our implementation can only curtail the alarm's callback payload.
e system will still periodically wake up according to the alarm's schedule, but will immediately return to sleep.
Our Figure : T sits between apps and the framework stack and interposes on events between these two.
Lower system layers are oblivious to our system.
We evaluate T in four ways.
First, we revisit our motivating scenario ( §񮽙) and use T to extend the battery 񮽙 This limitation is due to Xposed's limited OS support.
Support for Android's latest release (Lollipop) is not stable enough to cover our needs.
life of the GMS-based installation.
We then investigate how T can eeectively mitigate energy bugs, a system behavior that causes unexpected heavy use of energy not intrinsic to the desired functionality of an application.
Next, we show how to use code injection to create specialized versions of controllers for situations that our four-event toolset cannot handle.
Last, we measure the overhead caused by T on performance and energy.
In §񮽙, we saw how the inclusion of GMS into the baseline AOSP signiicantly reduced the battery life of all tested devices.
Nonetheless, GMS adds a series of services and applications that truly enhance the user's mobile experience.
In fact, most users do not even have the option of uninstalling them, as GMS comes pre-installed as a system package in the majority of handhelds.
We show how T can reach a tradeo between GMS's functionality and battery savings.
We aim to keep the added value of GMS without the cost of a silent battery depletion.
Table : Top event occurrences for the Galaxy Nexus' battery drain due to GMS.
A handful of events are responsible for the major impact on the battery.
W signiies a wakelock event, whereas S stands for service invocation.
With the control mechanism established, our next step is to design a policy that reduces the battery impact of events originating from or destined to GMS.
Table 񮽙 ranks the top triggered events reported by T's monitoring module.
For wakelocks, we also report the time they were held.
We use event frequency as an heuristic to guide policy connguration.
We note that NlpCollectorWakelock was primarily responsible for keeping the system awake in the background.
Online reports [񮽙񮽙, 񮽙] indicate that NlpCollectorWakelock is related to Location Reporting, an Android feature to estimate and report the current location based on WiFi APs and cell-tower signals.
Apps that use this feature include Google Now and Google Maps, among others.
e other frequently reported events are also related to the same feature.
Disabling location reporting on the device's Settings menu would be a logic solution to increase sleep time, if dependent apps did not stop working.
e problem with NlpCollectorWakelock and associated events is the frequency they wake up the system and keep it awake, which sums to a substantial period of nonsleepiness.
During a discharge period of hours for the Galaxy Nexus smartphone, NlpWakelock was called once a minute on average, whereas NlpCollectorWakelock contributed to keeping the system awake for more than one hour.
Such a high battery impact coming from a single package does not justify the beneet of having GMS running as it is in the background.
For this reason, we devised two policies for GMS, targeting NlpCollectorWakelock and its associated events, to alleviate this wakeup burden.
For each wakelock and service in Table ??
, the erst policy (Tamer---) allows a single call every minutes.
e second policy (Tamer-) allows one call every minutes.
Deciding on an appropriate rate is a subjective matter.
Our setup tries to reach a balance between informing subordinate apps of location updates and increasing battery lifetime.
Figure 񮽙 shows that our policies substantially reduced the battery-drain rate of all tested devices.
An energy bug, or ebug, is a system error either in an application, OS, rmware or hardware that causes an unexpected amount of high energy consumption [񮽙񮽙].
Such errors occur due to a variety of reasons such as programming mistakes, faulty hardware, malicious intent, etc.
Because such errors may not result in a crash, users will only notice their eeect when it is too late: an early dead battery.Diierently from previous research which identiied and characterized energy bugs [񮽙񮽙, 񮽙񮽙], in our evaluation we focus on mitigating them at runtime.
T allows users to run the oending applications without the adverse effects of the bugs.
Finding ebugs is not trivial and the lack of a centralized repository of updated samples prevents us from testing our controller more extensively.
We successfully reproduced and circumvented three application ebugs described in [񮽙񮽙].
For the other described cases, we could not connrm the existence of bugs.
We assume these defects have been xed by developer updates.Next, we present two detailed case studies of new ebugs that we found.
To identify them, we used eStar [񮽙񮽙], a tool that ranks the contribution of apps to battery depletion.
We rst selected apps that display poor energy eeciency and ltered them based on high popularity at the Google Play Store (our two selections featured on the top--ranking of their respective categories: Games and Health & Fitness).
Although eStar ranks energy-ineecient apps, we still had to manually verify whether such ineeciency was due to foreground or background activity.
For each application, we simulated a user interaction consisting of a short-length active session followed by a long period in the background.
Bejeweled Blitz [񮽙񮽙] is an award-winning puzzle game with over million installs from Google Play Store.
Aer a -minute play session on the Galaxy SS smartphone, T reported that our game generated a single background event -the acquire of the AudioIn wakelock.
Because games are resource-hungry apps, this event call initially did not instigate any suspicion.
We discovered a red ag, though, aer switching Bejeweled to the background: AudioIn was not released aer the game suspension.
To mitigate this bug, we wrote a simple policy targeting Bejeweled Blitz that blocks the renewal of the culprit wakelock during background time.
Figure 񮽙 depicts the battery drop of a -hour session with Bejeweled loaded in the background before and aer applying our policy.
We see a × improvement on battery drain.
Figure 񮽙 connrms the eeect of releasing the ill-behaved wakelock: before being tamed, the smartphone spent approximately % of the time with an awake CPU.
With T's interposition, most of the residency ratio was converted to deep sleep.
Given that the GPS is an energy-hungry resource, we consider a throttling mechanism for its duty cycle.
Paek et al. [񮽙񮽙] successfully demonstrated the potential energy savings of duty cycling by creating a rate-adaptive positioning system that switches the GPS sensor on and o and uses alternative location sources based on position accuracy.
As a demonstration, we consider a simpler GPS-throttling implementation sans secondary sources.
An advantage of our approach is the dispensing of OS recompilation, keeping it compatible with the majority of Android devices.
e GPS sensor provides periodic position xes (every second) to the OS.
Some of these xes are not relayed by the Android framework to the navigation app as they are not signiicantly diierent.
We can reach a more energyeecient navigation by directing the GPS duty cycle.
We inject code into internal classes related to the framework's GPS provider and open a direct communication channel between the GPS device and our throttling mechanism.
is direct channel permits our controller to switch the GPS on and o. Table 񮽙 summarizes our instrumentation.
Evaluation.
We consider two location-based apps, Google Maps and Nike+ Running.
We ran these two applications separately on the Galaxy Nexus phone and applied three diierent throttling policies to the GPS duty cycle: location updates every one, ve and een seconds.
e rate choice depends on the user's purpose.
For pedestrian navigation, a slower update rate does not aect the estimated position as much as in the case of a highway car trip.
Paek et al.'s work includes a thorough tradeo analysis between position accuracy and energy savings.
We, on the other hand, only report the potential savings.
For each scenario, we programmed a pedestrian route lasting ten minutes.
We turned the screen o while running the application in the background.
Because of the small timespan, we compare the energy dispensed instead of battery-level drop.
We used the Monsoon monitor to measure the energy consumption.
Figure 񮽙񮽙 portrays the savings per application.
We observe an upper bound of .
% on savings for the Nike+ Running application when reducing the locationupdate rate to :::s. Although a lower update rate increases the energy savings, position accuracy is penalized.
Just like a network rewall, T intercepts every eventhappening, inspects it, evaluates the corresponding policy criterion, and nally actuates to fullll the policy's conditions.
Because T diverts the normal ow of applications, it should incur as little performance overhead and energy burden as possible.
We instrumented T to measure the time taken to hijack an event and perform its blockage.
For the longest diverted execution ow, T took, on average, µs to execute on the Galaxy Nexus device.
With regards to energy consumption, T is activated only when other applications generate events.
1s-rate Policy 5s-rate Policy 15s-rate Policy Figure : Total energy consumed by Google Maps and Nike+ Running aer applying three diierent duty-cycle policies to the GPS provider.
For both apps, the update rate is inversely proportional to energy savings.T does not acquire any wakelocks, but freeloads the system's active state from other wakeup sources.
We are not the erst to propose control of functionality in exchange for battery savings.
T builds upon a number of contributions to mobile power management.
Collateral Related Work.
EEcient power management in mobile platforms is a challenging research problem due to the multitude of hardware conngurations and power states.
To improve energy consumption, we need to understand how hardware components draw power on behalf of applications.
.
ere is a myriad of tools that help quantify a device's energy expenditure.
PowerScope [񮽙񮽙] is one of the erst works in the mobile domain to map energy to a program's structure.
PowerScope employs linear regression and statistical sampling to apportion energy to hardware and applications.
A series of recent prolers for smartphones complements PowerScope, including PowerTutor [񮽙񮽙], ARO [񮽙񮽙], AppScope [񮽙񮽙], WattsOn [񮽙񮽙] and eprof [񮽙񮽙].
Sesame [񮽙񮽙] and V-edge [񮽙񮽙] go a step further and propose self-calibrating models that dispense the use of external power monitors, relying instead on internal battery data to model energy expenditure.
Our analysis mainly adopts battery-drop rate as a proxy for energy consumption, but we expect such advanced contributions to be integrated by OEMs in future devices.
Saving Energy From Background Tasking.
Android task killers once were the solution for background power savings, but their eeectiveness is now a point of contention [񮽙񮽙].
Task killers force background applications to quit, assuming that their removal from memory will reduce the energy footprint of released resources.
Such assumption is incorrect as there is little correlation between memory and CPU usage in Android [񮽙].
Excessive task killing may lead to the opposite eeect: by discarding cached data, Android must reload apps from storage.
A killed app may restart itself immediately aer being killed, using up CPU time and draining even more battery.Rather than killing background tasks, popular apps like JuiceDefender [񮽙񮽙] and Easy Battery Saver [񮽙] can conngure the access to power-greedy components, such as the radio and GPS, on a schedule basis.
Although eeective in many cases, some apps do not behave properly when they cannot, for instance, connect to the Internet.
Some apps may even produce more energy overhead as they insist on accessing a resource made unavailable.
T circumvents such problems by mainly throttling asynchronous actions: the expecting app does not block while waiting for an event arrival or dispatch.
Greenify [񮽙񮽙] is an Android tool for hibernating apps, preventing the arrival or dispatch of events once an app switches to background.
e original functionality is only restored when the app returns to the foreground.
Greenify is eeective in blocking misbehaving and start-at-boot apps, but its treatment of background computing is coarse and not applicable to notiication-based apps that mostly run in the background (e.g., mail readers, instant messengers, calendars, etc.) T is applicable in such cases as it throttles, but does not completely eliminate, background functionality.Android also includes its own controls for backgroundtask management.
e AutoSync feature controls the automatic data synchronization between client apps and online accounts.
With a mere tap, users can choose between disabling the synchronization of a speciic feature of a selected account (e.g., photo uploads for Google+) or totally prevent any background synchronization for all registered accounts.
AutoSync is mostly applicable to apps adopting Google Cloud Messaging (GCM), an API piece from Google Mobile Services.
GCM provides a lightweight mechanism that third-party servers can use to notify mobile applications of available content to be fetched.
As long as the application is subscribed to receive GCM messages, the Android device does not need to run continuously.
Instant messengers, for instance, use GCM to receive notications of new incoming messages.
T complements this service by oering a similar control to applications that do not adopt the GCM approach.
Moreover, T allows for the management of a variety of background events, whereas AutoSync focuses mainly on networking.Partial inspiration for deep event monitoring stems from applications such as BetterBatteryStats [񮽙񮽙] and Wakelock Detector [񮽙񮽙].
Both apps report wakelock-usage statistics that developers can use to understand the root cause of battery drainage.
T complements such apps by empowering users to take action aer they pinpoint the origin of abnormal energy consumption.Carat [񮽙񮽙] and eStar [񮽙񮽙] use data collected from thousands of smartphone and tablet users to model the battery drainage of applications.
By combining rich context information of multiple devices with energy awareness, it is possible to determine whether the energy used by an application deviates from its expected consumption.
ese tools are conservative in controlling energy expenditure, with both systems suggesting users to kill or uninstall culprit apps.
eStar further recommends energy-eecient alternatives to power-hog apps, if they exist.
T let users keep their apps while modifying the culprit's behavior to reduce energy consumption.
As any prototype, T has limitations.
T's main utility comes from policy deenition, which, at its current state, will not appeal to the end user.
In the following, we elaborate on how to circumvent this usability issue.
We also suggest improvements that are lee as future work.
In §񮽙, we demonstrated how a wise policy selection can partially inhibit the surge of energy-hungry events.
Our experience deening policies arose from intuition, reading source code (when available) and, in some cases, multiple attempts.
At its current state, T would better serve as a backend for higher-level power management tools than as an end-user app.
With such limitations in mind, a user willing to run T as it is, would benet from the following guidelines to explore the event space and deene eeective policies.
Choosing events to control.
Handhelds may carry tens or even hundreds of applications that generate thousands of events.
We should not imply that policy deenition must consider all of them equally.
First, users prefer some apps over others.
Second, event triggering does not follow a uniform distribution.
As a rule of thumb, users should start with policies targeting the most frequent events.
T's monitoring module periodically outputs an event summary that can assist in such cases.
Cutting the red wire.
Even aer selecting the most prominent events for policy testing, there are no guarantees that the policy will work without side eeects.
Side eeects may include an increase in the frequency of correlated events, the rise of unexpected events, and abnormal application behavior.
Blocking alarm events recklessly could, for instance, totally defeat the purpose of a calendar app.
Because most apps are only available in binary form, understanding the purpose of an event is not always clear and neither is uncovering its dependencies.
Techniques used in black-box testing, such as cause-eeect graphs can help.
Events may also show a temporal correlation with others.
To uncover temporal dependency, we generated event timelines from T's monitoring output.
Use common sense.
e Android OS deenes two categories of applications: system and user.
e former includes programs that are deemed critical, are deeply integrated into the OS, and cannot be uninstalled.
Exam-ples include the dialer, browser, and network manager, to name a few.
Users apps are replaceable programs that can be freely removed and installed from the app store.
As part of T's design, we adopted the support of generic events.
Consequently, system-and user-app events are treated equally.
Policies that alter the frequency of system events may result in unwanted or abnormal behavior.
Users should be mindful when deening policies involving critical events to avoid such situations.
Removing support for system events would prevent such unfortunate occasions, but the deenition of a system app is blurry.
GMS, for example, comes pre-installed as a system package on many devices.
Carriers also sell devices with bloatware installed as system apps.
As demonstrated, systems apps present great opportunities for energy savings.
Event batching over cancellation.
Our current implementation dismisses event continuation if there is a need for throttling.
Alternatively, we could reschedule the asynchronous delivery of such events to coalesce multiple wakeups into one, saving even more energy.
Although promising, event coalescing may lead to unexpected results that require deeper investigation.
Some apps assume a xed frequency of events.
A pedometer may use the time diierence between position xes to estimate speed.
Batching multiple xes into one delivery may create havoc if the tracker does not discard outdated values.
Nevertheless, coalescing has found its way in other domains.
e Linux tickless kernel [񮽙񮽙] reduced the precision of soware timers to allow the synchronization of process wakeups, minimizing the number of CPU power-state transitions.
From its Lollipop release, Android started to batch alarms that occur at reasonably similar times, turning them inexact.
Xu et al.'s recent work on coalescing events to save energy in the context of email synchronization [񮽙񮽙] is another successful example of careful event-handling for mobile devices.
As long as developers do not assume guarantees on event delivery and commutativity, we believe coalescing should supersede cancellation as an energy-saving feature.
Native code support.
T controls applications by wrapping function calls from the Android Java API.
Applications that make heavy use of native code, like games, multimedia apps and ELF libraries, could acquire wakelocks, spawn threads and perform background tasks using C/C++ code, thus bypassing our control system.
Extending support to native code would require a similar eeort on analyzing and instrumenting libc function calls.
Support for other mobile OSes.
Background processing is not exclusive to Android, although handled diierently by other mobile OSes.
Apple's iOS + regards background processing as a privilege [񮽙].
Other than network transfers, common background tasks have limited time to completion and must respect the device's will to sleep, doing their processing in chunks aer the device wakes up to handle phone calls, notiications and other interruptions.
Windows Phone enforces background tasks to be lightweight by applying quotas to resources like CPU, memory, and network usage while apps are running behind the scenes [񮽙񮽙].
Event-frequency control may not produce the same gains on Apple's and Microso's mobile devices given their stricter stance on deploying background tasks (mainly in the name of battery savings).
Feedback control.
T works as an open-loop controller, not using feedback to gauge whether the system needs more adjustments.
During the design stage of this project, we discarded the closed-loop approach as it would require knowledge of application semantics as well as user perception of performance degradation.
Modeling these two elements are hard problems beyond our scope.
is paper presented T, an OS mechanism that interposes on task wakeups in Android and allows event handling to be monitored, ltered, and rate-limited.
We demonstrated that T substantially reduces the background energy use in popular Android applications.
With T, a device spends more time in low-power mode, which increases the battery lifetime signiicantly.While this work shows T's eeectiveness as a mechanism, future work is needed to understand how to best construct policies that improve battery life while preserving application functionality.
In future work, we will investigate techniques for determining if functionality is negatively impacted when exploring user visible elements (e.g., UI diierences) between runs of an application with diierent policies.
We will also explore which policies are most likely to have substantial battery savings in practice.
With the combination of such techniques, we will strive to devise policies that improve battery life while retaining normal application functionality.
We thank Tim Nelson, Hammurabi Mendes, the anonymous reviewers, and our shepherd, Lin Zhong, for their feedback.
Marcelo was funded in part by a generous gii from Intel Corporation.
sT can block events at their imminent arrival or dispatch, thus saving energy that would be consumed by their continuation.
One can say that T focuses on the effect of an event.
Still, there are situations in which the energy cost of its cause is signiicant.
A user could write a policy targeting an instant messenger's broadcast receiver to throttle the eeect of a message arrival -a notiication in the form of sound or vibration.
However, she cannot block the message arrival itself, the major contributor to energy consumption in this case, as the remote sender is not covered by T.Acting on the cause of an event is complicated because its originator, when known, can take various shapes, like a disk or network I/O operation.
Consequently, nding a converging instrument point in the source code that encompasses all such shapes is complex.
In parallel, we should avoid point solutions that only yt one app.
Between these two extremes, we can reach a balance by instrumenting code that abstracts common functionality and generates events used by a subset of applications.
We consider the case of navigation apps to illustrate such scenario.
rottling Localization.
Android applications that rely on the GPS sensor follow a basic model: (() they register a position listener and (() they periodically receive location updates from a provider proxy, the only interface to the localization system [񮽙].
A provider proxy serves as an interface to various location sources, including the GPS sensor, WiFi APs, and cell towers.
T can block events at their imminent arrival or dispatch, thus saving energy that would be consumed by their continuation.
One can say that T focuses on the effect of an event.
Still, there are situations in which the energy cost of its cause is signiicant.
A user could write a policy targeting an instant messenger's broadcast receiver to throttle the eeect of a message arrival -a notiication in the form of sound or vibration.
However, she cannot block the message arrival itself, the major contributor to energy consumption in this case, as the remote sender is not covered by T.Acting on the cause of an event is complicated because its originator, when known, can take various shapes, like a disk or network I/O operation.
Consequently, nding a converging instrument point in the source code that encompasses all such shapes is complex.
In parallel, we should avoid point solutions that only yt one app.
Between these two extremes, we can reach a balance by instrumenting code that abstracts common functionality and generates events used by a subset of applications.
We consider the case of navigation apps to illustrate such scenario.
rottling Localization.
Android applications that rely on the GPS sensor follow a basic model: (() they register a position listener and (() they periodically receive location updates from a provider proxy, the only interface to the localization system [񮽙].
A provider proxy serves as an interface to various location sources, including the GPS sensor, WiFi APs, and cell towers.
