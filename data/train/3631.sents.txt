Large-scale graph-structured computation is central to tasks ranging from targeted advertising to natural language processing and has led to the development of several graph-parallel abstractions including Pregel and GraphLab.
However, the natural graphs commonly found in the real-world have highly skewed power-law degree distributions, which challenge the assumptions made by these abstractions, limiting performance and scalability.
In this paper, we characterize the challenges of computation on natural graphs in the context of existing graph-parallel abstractions.
We then introduce the PowerGraph abstraction which exploits the internal structure of graph programs to address these challenges.
Leveraging the PowerGraph abstraction we introduce a new approach to distributed graph placement and representation that exploits the structure of power-law graphs.
We provide a detailed analysis and experimental evaluation comparing PowerGraph to two popular graph-parallel systems.
Finally, we describe three different implementation strategies for PowerGraph and discuss their relative merits with empirical evaluations on large-scale real-world problems demonstrating order of magnitude gains.
The increasing need to reason about large-scale graphstructured data in machine learning and data mining (MLDM) presents a critical challenge.
As the sizes of datasets grow, statistical theory suggests that we should apply richer models to eliminate the unwanted bias of simpler models, and extract stronger signals from data.
At the same time, the computational and storage complexity of richer models coupled with rapidly growing datasets have exhausted the limits of single machine computation.The resulting demand has driven the development of new graph-parallel abstractions such as Pregel [30] and GraphLab [29] that encode computation as vertexprograms which run in parallel and interact along edges in the graph.
Graph-parallel abstractions rely on each vertex having a small neighborhood to maximize parallelism and effective partitioning to minimize communication.
However, graphs derived from real-world phenomena, like social networks and the web, typically have powerlaw degree distributions, which implies that a small subset of the vertices connects to a large fraction of the graph.
Furthermore, power-law graphs are difficult to partition [1,28] and represent in a distributed environment.To address the challenges of power-law graph computation, we introduce the PowerGraph abstraction which exploits the structure of vertex-programs and explicitly factors computation over edges instead of vertices.
As a consequence, PowerGraph exposes substantially greater parallelism, reduces network communication and storage costs, and provides a new highly effective approach to distributed graph placement.
We describe the design of our distributed implementation of PowerGraph and evaluate it on a large EC2 deployment using real-world applications.
In particular our key contributions are:1.
An analysis of the challenges of power-law graphs in distributed graph computation and the limitations of existing graph parallel abstractions (Sec. 2 and 3).2.
The PowerGraph abstraction (Sec. 4) which factors individual vertex-programs.3.
A delta caching procedure which allows computation state to be dynamically maintained (Sec. 4.2).4.
A new fast approach to data layout for power-law graphs in distributed environments (Sec. 5).5.
An theoretical characterization of network and storage (Theorem 5.2, Theorem 5.3).6.
A high-performance open-source implementation of the PowerGraph abstraction (Sec. 7).7.
A comprehensive evaluation of three implementations of PowerGraph on a large EC2 deployment using real-world MLDM applications (Sec. 6 and 7).
GraphLab [29] is an asynchronous distributed sharedmemory abstraction in which vertex-programs have shared access to a distributed graph with data stored on every vertex and edge.
Each vertex-program may directly access information on the current vertex, adjacent edges, and adjacent vertices irrespective of edge direction.
Vertexprograms can schedule neighboring vertex-programs to be executed in the future.
GraphLab ensures serializability by preventing neighboring program instances from running simultaneously.
The following is an example of the PageRank vertex-program implemented in GraphLab.
The GraphLab vertex-program directly reads neighboring vertex values to compute the sum.
By eliminating messages, GraphLab isolates the user defined algorithm from the movement of data, allowing the system to choose when and how to move program state.
By allowing mutable data to be associated with both vertices and edges GraphLab allows the algorithm designer to more precisely distinguish between data shared with all neighbors (vertex data) and data shared with a particular neighbor (edge data).
While the implementation of MLDM vertex-programs in GraphLab and Pregel differ in how they collect and disseminate information, they share a common overall structure.
To characterize this common structure and differentiate between vertex and edge specific computation we introduce the GAS model of graph computation.The GAS model represents three conceptual phases of a vertex-program: Gather, Apply, and Scatter.
In the gather phase, information about adjacent vertices and edges is collected through a generalized sum over the neighborhood of the vertex u on which Q(u) is run:Σ ← 񮽙 v∈Nbr[u] g 񮽙 D u , D (u,v) , D v 񮽙 .
(2.1)where D u , D v , and D (u,v) are the values (program state and meta-data) for vertices u and v and edge (u, v).
The user defined sum ⊕ operation must be commutative and associative and can range from a numerical sum to the union of the data on all neighboring vertices and edges.The resulting value Σ is used in the apply phase to update the value of the central vertex:D new u ← a (D u , Σ) .
(2.2)Finally the scatter phase uses the new value of the central vertex to update the data on adjacent edges:∀v ∈ Nbr[u] : 񮽙 D (u,v) 񮽙 ← s 񮽙 D new u , D (u,v) , D v 񮽙 .
(2.3)The fan-in and fan-out of a vertex-program is determined by the corresponding gather and scatter phases.
For instance, in PageRank, the gather phase only operates on in-edges and the scatter phase only operates on out-edges.
However, for many MLDM algorithms the graph edges encode ostensibly symmetric relationships, like friendship, in which both the gather and scatter phases touch all edges.
In this case the fan-in and fan-out are equal.
As we will show in Sec. 3, the ability for graph parallel abstractions to support both high fan-in and fan-out computation is critical for efficient computation on natural graphs.
(a) Twitter In-Degree (b) Twitter Out-Degree Figure 1: The in and out degree distributions of the Twitter follower network plotted in log-log scale.GraphLab and Pregel express GAS programs in very different ways.
In the Pregel abstraction the gather phase is implemented using message combiners and the apply and scatter phases are expressed in the vertex program.
Conversely, GraphLab exposes the entire neighborhood to the vertex-program and allows the user to define the gather and apply phases within their program.
The GraphLab abstraction implicitly defines the communication aspects of the gather/scatter phases by ensuring that changes made to the vertex or edge data are automatically visible to adjacent vertices.
It is also important to note that GraphLab does not differentiate between edge directions.
The sparsity structure of natural graphs presents a unique challenge to efficient distributed graph-parallel computation.
One of the hallmark properties of natural graphs is their skewed power-law degree distribution [16]: most vertices have relatively few neighbors while a few have many neighbors (e.g., celebrities in a social network).
Under a power-law degree distribution the probability that a vertex has degree d is given by:P (d) ∝ d −α , (3.1)where the exponent α is a positive constant that controls the "skewness" of the degree distribution.
Higher α implies that the graph has lower density (ratio of edges to vertices), and that the vast majority of vertices are low degree.
As α decreases, the graph density and number of high degree vertices increases.
Most natural graphs typically have a power-law constant around α ≈ 2.
For example, Faloutsos et al. [16] estimated that the interdomain graph of the Internet has a power-law constant α ≈ 2.2.
One can visualize the skewed power-law degree distribution by plotting the number of vertices with a given degree in log-log scale.
In Fig. 1, we plot the in and out degree distributions of the Twitter follower network demonstrating the characteristic linear power-law form.
While power-law degree distributions are empirically observable, they do not fully characterize the properties of natural graphs.
While there has been substantial work (see [27]) in more sophisticated natural graph models, the techniques in this paper focus only on the degree distribution and do not require any other modeling assumptions.The skewed degree distribution implies that a small fraction of the vertices are adjacent to a large fraction of the edges.
For example, one percent of the vertices in the Twitter web-graph are adjacent to nearly half of the edges.
This concentration of edges results in a starlike motif which presents challenges for existing graphparallel abstractions:Work Balance: The power-law degree distribution can lead to substantial work imbalance in graph parallel abstractions that treat vertices symmetrically.
Since the storage, communication, and computation complexity of the Gather and Scatter phases is linear in the degree, the running time of vertex-programs can vary widely [36].
Partitioning: Natural graphs are difficult to partition [26,28].
Both GraphLab and Pregel depend on graph partitioning to minimize communication and ensure work balance.
However, in the case of natural graphs both are forced to resort to hash-based (random) partitioning which has extremely poor locality (Sec. 5).
Communication: The skewed degree distribution of natural-graphs leads to communication asymmetry and consequently bottlenecks.
In addition, high-degree vertices can force messaging abstractions, such as Pregel, to generate and send many identical messages.Storage: Since graph parallel abstractions must locally store the adjacency information for each vertex, each vertex requires memory linear in its degree.
Consequently, high-degree vertices can exceed the memory capacity of a single machine.Computation: While multiple vertex-programs may execute in parallel, existing graph-parallel abstractions do not parallelize within individual vertex-programs, limiting their scalability on high-degree vertices.
To address the challenges of computation on power-law graphs, we introduce PowerGraph, a new graph-parallel abstraction that eliminates the degree dependence of the vertex-program by directly exploiting the GAS decomposition to factor vertex-programs over edges.
By lifting the Gather and Scatter phases into the abstraction, PowerGraph is able to retain the natural "think-like-a-vertex" philosophy [30] while distributing the computation of a single vertex-program over the entire cluster.PowerGraph combines the best features from both Pregel and GraphLab.
From GraphLab, PowerGraph borrows the data-graph and shared-memory view of computation eliminating the need for users to architect the movement of information.
From Pregel, PowerGraph borrows the commutative, associative gather concept.
PowerGraphinterface GASVertexProgram(u) { // Run on gather_nbrs(u) gather(D u , D (u,v) , D v ) → Accum sum(Accum left, Accum right) → Accum apply(D u ,Accum) → D new u // Run on scatter_nbrs(u) scatter(D new u ,D (u,v) ,D v ) → (D new (u,v), Accum) } Figure 2: All PowerGraph programs must implement the stateless gather, sum, apply, and scatter functions.
Input: Center vertex u if cached accumulator a u is empty then foreach neighbor v in gather nbrs(u) doa u ← sum(a u , gather(D u , D (u,v) , D v )) end end D u ← apply(D u , a u ) foreach neighbor v scatter nbrs(u) do (D (u,v) , ∆a) ← scatter(D u , D (u,v) , D v )if a v and ∆a are not Empty then a v ← sum(a v , ∆a) else a v ← Empty end supports both the highly-parallel bulk-synchronous Pregel model of computation as well as the computationally efficient asynchronous GraphLab model of computation.Like GraphLab, the state of a PowerGraph program factors according to a data-graph with user defined vertex data D v and edge data D (u,v) .
The data stored in the data-graph includes both meta-data (e.g., urls and edge weights) as well as computation state (e.g., the PageRank of vertices).
In Sec. 5 we introduce vertex-cuts which allow PowerGraph to efficiently represent and store powerlaw graphs in a distributed environment.
We now describe the PowerGraph abstraction and how it can be used to naturally decompose vertex-programs.
Then in Sec. 5 through Sec. 7 we discuss how to implement the PowerGraph abstraction in a distributed environment.
Computation in the PowerGraph abstraction is encoded as a state-less vertex-program which implements the GASVertexProgram interface (Fig. 2) and therefore explicitly factors into the gather, sum, apply, and scatter functions.
Each function is invoked in stages by the PowerGraph engine following the semantics in Alg.
1.
By factoring the vertex-program, the PowerGraph execution engine can distribute a single vertex-program over multiple machines and move computation to the data.During the gather phase the gather and sum functions are used as a map and reduce to collect information about the neighborhood of the vertex.
The gather function is invoked in parallel on the edges adjacent to u.
The particular set of edges is determined by gather nbrs which can be none, in, out, or all.
The gather function is passed the data on the adjacent vertex and edge and returns a temporary accumulator (a user defined type).
The result is combined using the commutative and associative sum operation.
The final result a u of the gather phase is passed to the apply phase and cached by PowerGraph.After the gather phase has completed, the apply function takes the final accumulator and computes a new vertex value D u which is atomically written back to the graph.
The size of the accumulator a u and complexity of the apply function play a central role in determining the network and storage efficiency of the PowerGraph abstraction and should be sub-linear and ideally constant in the degree.During the scatter phase, the scatter function is invoked in parallel on the edges adjacent to u producing new edge values D (u,v) which are written back to the datagraph.
As with the gather phase, the scatter nbrs determines the particular set of edges on which scatter is invoked.
The scatter function returns an optional value ∆a which is used to dynamically update the cached accumulator a v for the adjacent vertex (see Sec. 4.2).
In Fig. 3 we implement the PageRank, greedy graph coloring, and single source shortest path algorithms using the PowerGraph abstraction.
In PageRank the gather and sum functions collect the total value of the adjacent vertices, the apply function computes the new PageRank, and the scatter function is used to activate adjacent vertexprograms if necessary.
In graph coloring the gather and sum functions collect the set of colors on adjacent vertices, the apply function computes a new color, and the scatter function activates adjacent vertices if they violate the coloring constraint.
Finally in single source shortest path (SSSP), the gather and sum functions compute the shortest path through each of the neighbors, the apply function returns the new distance, and the scatter function activates affected neighbors.
In many cases a vertex-program will be triggered in response to a change in a few of its neighbors.
The gather operation is then repeatedly invoked on all neighbors, many of which remain unchanged, thereby wasting computation cycles.
For many algorithms [2] it is possible to dynamically maintain the result of the gather phase a u and skip the gather on subsequent iterations.The PowerGraph engine maintains a cache of the accumulator a u from the previous gather phase for each vertex.
The scatter function can optionally return an additional ∆a which is atomically added to the cached accumulator a v of the neighboring vertex v using the sum function.
If ∆a is not returned, then the neighbor's cached a v is cleared, Intuitively, ∆a acts as an additive correction on-top of the previous gather for that edge.
More formally, if the accumulator type forms an abelian group: has a commutative and associative sum (+) and an inverse (−) operation, then we can define (shortening gather to g):PageRank // gather_nbrs: IN_NBRS gather(D u , D (u,v) , D v ): return D v .
rank / #outNbrs(v) sum(a, b): return a + b apply(D u , acc): rnew = 0.15 + 0.85 * acc D u .
delta = (rnew -D u .
rank)/ #outNbrs(u) D u .
rank = rnew // scatter_nbrs: OUT_NBRS scatter(D u ,D (u,v) ,D v ): if(|D u .
delta|>ε) Activate(v) return delta Greedy Graph Coloring // gather_nbrs: ALL_NBRS gather(D u , D (u,v) , D v ): return set(D v ) sum(a, b): return union(a, b) apply(D u , S): D u = min c where c / ∈ S // scatter_nbrs: ALL_NBRS scatter(D u ,D (u,v) ,D v ): // Nbr changed since gather if(D u == D v ) Activate(v) // Invalidate cached accum return NULL Single Source Shortest Path (SSSP) // gather_nbrs: ALL_NBRS gather(D u , D (u,v) , D v ): return D v + D (v,u) sum(a, b): return min(a, b) apply(D u , new_dist): D u = new_dist // scatter_nbrs: ALL_NBRS scatter(D u ,D (u,v) ,D v ): // If changed activate neighbor if(changed(D u )) Activate(v) if(increased(D u )) return NULL else return D u + D (u,v)∆a = g(D u , D new (u,v) , D new v ) − g(D u , D (u,v) , D v ).
(4.1)In the PageRank example ( Fig. 3) we take advantage of the abelian nature of the PageRank sum operation.
For graph coloring the set union operation is not abelian and so we invalidate the accumulator.
The PowerGraph engine maintains a set of active vertices on which to eventually execute the vertex-program.
The user initiates computation by calling Activate(v) or Activate all().
The PowerGraph engine then proceeds to execute the vertex-program on the active vertices until none remain.
Once a vertex-program completes the scatter phase it becomes inactive until it is reactivated.
Vertices can activate themselves and neighboring vertices.
Each function in a vertex-program can only activate vertices visible in the arguments to that function.
For example the scatter function invoked on the edge (u, v) can only activate the vertices u and v.
This restriction is essential to ensure that activation events are generated on machines on which they can be efficiently processed.The order in which activated vertices are executed is up to the PowerGraph execution engine.
The only guarantee is that all activated vertices are eventually executed.
This flexibility in scheduling enables PowerGraph programs to be executed both synchronously and asynchronously, leading to different tradeoffs in algorithm performance, system performance, and determinism.
When run synchronously, the PowerGraph engine executes the gather, apply, and scatter phases in order.
Each phase, called a minor-step, is run synchronously on all active vertices with a barrier at the end.
We define a superstep as a complete series of GAS minor-steps.
Changes made to the vertex data and edge data are committed at the end of each minor-step and are visible in the subsequent minor-step.
Vertices activated in each super-step are executed in the subsequent super-step.
The synchronous execution model ensures a deterministic execution regardless of the number of machines and closely resembles Pregel.
However, the frequent barriers and inability to operate on the most recent data can lead to an inefficient distributed execution and slow algorithm convergence.
To address these limitations PowerGraph also supports asynchronous execution.
When run asynchronously, the PowerGraph engine executes active vertices as processor and network resources become available.
Changes made to the vertex and edge data during the apply and scatter functions are immediately committed to the graph and visible to subsequent computation on neighboring vertices.By using processor and network resources as they become available and making any changes to the datagraph immediately visible to future computation, an asynchronous execution can more effectively utilize resources and accelerate the convergence of the underlying algorithm.
For example, the greedy graph-coloring algorithm in Fig. 3 will not converge when executed synchronously but converges quickly when executed asynchronously.
The merits of asynchronous computation have been studied extensively in the context of numerical algorithms [4].
In [18,19,29] we demonstrated that asynchronous computation can lead to both theoretical and empirical gains in algorithm and system performance for a range of important MLDM applications.Unfortunately, the behavior of the asynchronous execution depends on the number machines and availability of network resources leading to non-determinism that can complicate algorithm design and debugging.
Furthermore, for some algorithms, like statistical simulation, the resulting non-determinism, if not carefully controlled, can lead to instability or even divergence [17].
To address these challenges, GraphLab automatically enforces serializability: every parallel execution of vertex-programs has a corresponding sequential execution.
In [29] it was shown that serializability is sufficient to support a wide range of MLDM algorithms.
To achieve serializability, GraphLab prevents adjacent vertex-programs from running concurrently using a fine-grained locking protocol which requires sequentially grabbing locks on all neighboring vertices.
Furthermore, the locking scheme used by GraphLab is unfair to high degree vertices.PowerGraph retains the strong serializability guarantees of GraphLab while addressing its limitations.
We address the problem of sequential locking by introducing a new parallel locking protocol (described in Sec. 7.4) which is fair to high degree vertices.
In addition, the PowerGraph abstraction exposes substantially more fined grained (edge-level) parallelism allowing the entire cluster to support the execution of individual vertex programs.
Surprisingly, despite the strong constraints imposed by the PowerGraph abstraction, it is possible to emulate both GraphLab and Pregel vertex-programs in PowerGraph.
To emulate a GraphLab vertex-program, we use the gather and sum functions to concatenate all the data on adjacent vertices and edges and then run the GraphLab program within the apply function.
Similarly, to express a Pregel vertex-program, we use the gather and sum functions to combine the inbound messages (stored as edge data) and concatenate the list of neighbors needed to compute the outbound messages.
The Pregel vertex-program then runs within the apply function generating the set of messages which are passed as vertex data to the scatter function where they are written back to the edges.In order to address the challenges of natural graphs, the PowerGraph abstraction requires the size of the accumulator and the complexity of the apply function to be sub-linear in the degree.
However, directly executing GraphLab and Pregel vertex-programs within the apply function leads the size of the accumulator and the complexity of the apply function to be linear in the degree eliminating many of the benefits on natural graphs.
The PowerGraph abstraction relies on the distributed datagraph to store the computation state and encode the interaction between vertex-programs.
The placement of the data-graph structure and data plays a central role in minimizing communication and ensuring work balance.
A common approach to placing a graph on a cluster of p machines is to construct a balanced p-way edge-cut (e.g., Fig. 4a) in which vertices are evenly assigned to machines and the number of edges spanning machines is minimized.
Unfortunately, the tools [23,31] for constructing balanced edge-cuts perform poorly [1,28,26] on power-law graphs.
When the graph is difficult to partition, both GraphLab and Pregel resort to hashed (random) vertex placement.
While fast and easy to implement, hashed vertex placement cuts most of the edges:Theorem 5.1.
If vertices are randomly assigned to p machines then the expected fraction of edges cut is:E 񮽙 |Edges Cut| |E| 񮽙 = 1 − 1 p .
(5.1)For a power-law graph with exponent α, the expected number of edges cut per-vertex is:E 񮽙 |Edges Cut| |V | 񮽙 = 񮽙 1 − 1 p 񮽙 E [D[v]] = 񮽙 1 − 1 p 񮽙 h |V | (α − 1) h |V | (α) , (5.2)where the h |V | (α) = ∑ |V |−1 d=1 d −α is the normalizing constant of the power-law Zipf distribution.Proof.
An edge is cut if both vertices are randomly assigned to different machines.
The probability that both vertices are assigned to different machines is 1 − 1/p.
Every cut edge contributes to storage and network overhead since both machines maintain a copy of the adjacency information and in some cases [20], a ghost (local copy) of the vertex and edge data.
For example in Fig. 4a we construct a three-way edge-cut of a four vertex graph resulting in five ghost vertices and all edge data being replicated.
Any changes to vertex and edge data associated with a cut edge must be synchronized across the network.
For example, using just two machines, a random cut will cut roughly half the edges, requiring |E| /2 communication.
straction when using a vertex-cut.
Gather function runs locally on each machine and then one accumulators is sent from each mirror to the master.
The master runs the apply function and then sends the updated vertex data to all mirrors.
Finally the scatter phase is run in parallel on mirrors.
By factoring the vertex program along the edges in the graph, The PowerGraph abstraction allows a single vertexprogram to span multiple machines.
In Fig. 5 a single high degree vertex program has been split across two machines with the gather and scatter functions running in parallel on each machine and accumulator and vertex data being exchanged across the network.Because the PowerGraph abstraction allows a single vertex-program to span multiple machines, we can improve work balance and reduce communication and storage overhead by evenly assigning edges to machines and allowing vertices to span machines.
Each machine only stores the edge information for the edges assigned to that machine, evenly distributing the massive amounts of edge data.
Since each edge is stored exactly once, changes to edge data do not need to be communicated.
However, changes to vertex must be copied to all the machines it spans, thus the storage and network overhead depend on the number of machines spanned by each vertex.We minimize storage and network overhead by limiting the number of machines spanned by each vertex.
A balanced p-way vertex-cut formalizes this objective by assigning each edge e ∈ E to a machine A(e) ∈ {1,.
.
.
, p}.
Each vertex then spans the set of machines A(v) ⊆ {1,.
.
.
, p} that contain its adjacent edges.
We define the balanced vertex-cut objective:min A 1 |V | ∑ v∈V |A(v)| (5.3) s.t. max m |{e ∈ E | A(e) = m}| ,< λ |E| p (5.4)where the imbalance factor λ ≥ 1 is a small constant.
We use the term replicas of a vertex v to denote the |A(v)| copies of the vertex v: each machine in A(v) has a replica of v. Because changes to vertex data are communicated to all replicas, the communication overhead is also given by |A(v)|.
The objective (Eq.
5.3) therefore minimizes the average number of replicas in the graph and as a consequence the total storage and communication requirements of the PowerGraph engine.
For each vertex v with multiple replicas, one of the replicas is randomly nominated as the master which maintains the master version of the vertex data.
All remaining replicas of v are then mirrors and maintain a local cached read only copy of the vertex data.
(e.g., Fig. 4b).
For instance, in Fig. 4b we construct a three-way vertex-cut of a graph yielding only 2 mirrors.
Any changes to the vertex data (e.g., the Apply function) must be made to the master which is then immediately replicated to all mirrors.Vertex-cuts address the major issues associated with edge-cuts in power-law graphs.
Percolation theory [3] suggests that power-law graphs have good vertex-cuts.
Intuitively, by cutting a small fraction of the very high degree vertices we can quickly shatter a graph.
Furthermore, because the balance constraint (Eq.
5.4) ensures that edges are uniformly distributed over machines, we naturally achieve improved work balance even in the presence of very high-degree vertices.The simplest method to construct a vertex cut is to randomly assign edges to machines.
Random (hashed) edge placement is fully data-parallel, achieves nearly perfect balance on large graphs, and can be applied in the streaming setting.
In the following theorem, we relate the expected normalized replication factor (Eq.
5.3) to the number of machines and the power-law constant α.
E 񮽙 1 |V | ∑ v∈V |A(v)| 񮽙 = p |V | ∑ v∈V 񮽙 1 − 񮽙 1 − 1 p 񮽙 D[v] 񮽙 .
(5.5)where D [v] denotes the degree of vertex v. For a powerlaw graph the expected replication (Fig. 6a) is determined entirely by the power-law constant α: Proof.
By linearity of expectation: The expected replication factor for vertex v is then:E 񮽙 1 |V | ∑ v∈V |A(v)| 񮽙 = p − p h |V | (α) |V |−1 ∑ d=1 񮽙 p − 1 p 񮽙 d d −α ,(5.
E 񮽙 1 |V | ∑ v∈V |A(v)| 񮽙 = 1 |V | ∑ v∈V E [|A(v)|] ,(5.
= 1 − 񮽙 1 − 1 p 񮽙 D[v] ,(5.
E [|A(v)|] = p ∑ i=1 E [X i ] = p 񮽙 1 − 񮽙 1 − 1 p 񮽙 D[v] 񮽙 .
(5.10) Treating D[v]as a Zipf random variable:E 񮽙 1 |V | ∑ v∈V |A(v)| 񮽙 = p |V | ∑ v∈V 񮽙 1 − E 񮽙 񮽙 p − 1 p 񮽙 D[v] 񮽙񮽙 ,(5.11)and taking the expectation underP (d) = d −α / h |V | (α): E 񮽙 񮽙 1 − 1 p 񮽙 D[v] 񮽙 = 1 h |V | (α) |V |−1 ∑ d=1 񮽙 1 − 1 p 񮽙 d d −α .
(5.12)While lower α values (more high-degree vertices) imply a higher replication factor (Fig. 6a) the effective gains of vertex-cuts relative to edge cuts (Fig. 6b) actually increase with lower α.
In Fig. 6b we plot the ratio of the expected costs (comm.
and storage) of random edge-cuts (Eq.
5.2) to the expected costs of random vertex-cuts (Eq.
5.6) demonstrating order of magnitude gains.Finally, the vertex cut model is also highly effective for regular graphs since in the event that a good edge-cut can be found it can be converted to a better vertex cut:Theorem 5.3.
For a given an edge-cut with g ghosts, any vertex cut along the same partition boundary has strictly fewer than g mirrors.Proof of Theorem 5.3.
Consider the two-way edge cut which cuts the set of edges E ′ ∈ E and let V ′ be the set of vertices in E ′ .
The total number of ghosts induced by this edge partition is therefore |V ′ |.
If we then select and delete arbitrary vertices from V ′ along with their adjacent edges until no edges remain, then the set of deleted vertices corresponds to a vertex-cut in the original graph.
Since at most |V ′ | − 1 vertices may be deleted, there can be at most |V ′ | − 1 mirrors.
|V | |E| Twitter [24] 41M 1.4B UK [7] 132.8M 5.5B Amazon [6,5] 0.7M 5.2M LiveJournal [12] 5.4M 79M Hollywood [6,5] 2 We can improve upon the randomly constructed vertexcut by de-randomizing the edge-placement process.
The resulting algorithm is a sequential greedy heuristic which places the next edge on the machine that minimizes the conditional expected replication factor.
To construct the de-randomization we consider the task of placing the i + 1 edge after having placed the previous i edges.
Using the conditional expectation we define the objective:arg min k E 񮽙 ∑ v∈V |A(v)| 񮽙 񮽙 񮽙 񮽙 񮽙 A i , A(e i+1 ) = k 񮽙 , (5.13)where A i is the assignment for the previous i edges.
Using Theorem 5.2 to evaluate Eq.
5.13 we obtain the following edge placement rules for the edge (u, v):Case 1: If A(u) and A(v) intersect, then the edge should be assigned to a machine in the intersection.Case 2: If A(u) and A(v) are not empty and do not intersect, then the edge should be assigned to one of the machines from the vertex with the most unassigned edges.Case 3: If only one of the two vertices has been assigned, then choose a machine from the assigned vertex.Case 4: If neither vertex has been assigned, then assign the edge to the least loaded machine.Because the greedy-heuristic is a de-randomization it is guaranteed to obtain an expected replication factor that is no worse than random placement and in practice can be much better.
Unlike the randomized algorithm, which is embarrassingly parallel and easily distributed, the greedy algorithm requires coordination between machines.
We consider two distributed implementations: The effect of partitioning on runtime.
In Fig. 8a, we compare the replication factor of both heuristics against random vertex cuts on the Twitter follower network.
We plot the replication factor as a function of the number of machines (EC2 instances described in Sec. 7) and find that random vertex cuts match the predicted replication given in Theorem 5.2.
Furthermore, the greedy heuristics substantially improve upon random placement with an order of magnitude reduction in the replication factor, and therefore communication and storage costs.
For a fixed number of machines (p = 32), we evaluated (Fig. 7a) the replication factor of the two heuristics on five real-world graphs (Tab.
1a).
In all cases the greedy heuristics out-perform random placement, while doubling the load time (Fig. 8b).
The Oblivious heuristic achieves compromise by obtaining a relatively low replication factor while only slightly increasing runtime.Coordinated In this section, we experimentally characterize the dependence on α and the relationship between fan-in and fan-out by using the Pregel, GraphLab, and PowerGraph abstractions to run PageRank on five synthetically constructed power-law graphs.
Each graph has ten-million vertices and an α ranging from 1.8 to 2.2.
The graphs were constructed by randomly sampling the out-degree of each vertex from a Zipf distribution and then adding out-edges such that the in-degree of each vertex is nearly identical.
We then inverted each graph to obtain the corresponding power-law fan-in graph.
The density of each power-law graph is determined by α and therefore each graph has a different number of edges (see Tab.
1b).
We used the GraphLab v1 C++ implementation from [29] and added instrumentation to track network usage.
As of the writing of this paper, public implementations of Pregel (e.g., Giraph) were unable to handle even our smaller synthetic problems due to memory limitations.
Consequently, we used Piccolo [32] as a proxy implementation of Pregel since Piccolo naturally expresses the Pregel abstraction and provides an efficient C++ implementation with dynamic load-balancing.
Finally, we used our implementation of PowerGraph described in Sec. 7.
All experiments in this section are evaluated on an eight node Linux cluster.
Each node consists of two quad-core Intel Xeon E5620 processors with 32 GB of RAM and is connected via 1-GigE Ethernet.
All systems were compiled with GCC 4.4.
GraphLab and Piccolo used random edge-cuts while PowerGraph used random vertex-cuts.
.
Results are averaged over 20 iterations.
The sequential component of the PageRank vertexprogram is proportional to out-degree in the Pregel abstraction and in-degree in the GraphLab abstraction.
Alternatively, PowerGraph eliminates this sequential dependence by distributing the computation of individual vertex-programs over multiple machines.
Therefore we expect, highly-skewed (low α) power-law graphs to increase work imbalance under the Pregel (fan-in) and GraphLab (fan-out) abstractions but not under the PowerGraph abstraction, which evenly distributed high-degree vertex-programs.
To evaluate this hypothesis we ran eight "workers" per system (64 total workers) and recorded the vertex-program time on each worker.In Fig. 9a and Fig. 9b we plot the standard deviation of worker per-iteration runtimes, a measure of work imbalance, for power-law fan-in and fan-out graphs respectively.
Higher standard deviation implies greater imbalance.
While lower α increases work imbalance for GraphLab (on fan-in) and Pregel (on fan-out), the PowerGraph abstraction is unaffected in either edge direction.
Because GraphLab and Pregel use edge-cuts, their communication volume is proportional to the number of ghosts: the replicated vertex and edge data along the partition boundary.
If one message is sent per edge, Pregel's combiners ensure that exactly one network message is transmitted for each ghost.
Similarly, at the end of each iteration GraphLab synchronizes each ghost and thus the communication volume is also proportional to the number of ghosts.
PowerGraph on the other hand uses vertex-cuts and only synchronizes mirrors after each iteration.
The communication volume of a complete iteration is therefore proportional to the number of mirrors induced by the vertex-cut.
As a consequence we expect that PowerGraph will reduce communication volume.
In Fig. 9c and Fig. 9d we plot the bytes communicated per iteration for all three systems under power-law fan-in and fan-out graphs.
Because Pregel only sends messages along out-edges, Pregel communicates more on powerlaw fan-out graphs than on power-law fan-in graphs.On the other hand, GraphLab and PowerGraph's communication volume is invariant to power-law fan-in and fan-out since neither considers edge direction during datasynchronization.
However, PowerGraph communicates significantly less than GraphLab which is a direct result of the efficacy of vertex cuts.
Finally, PowerGraph's total communication increases only marginally on the denser graphs and is the lowest overall.
PowerGraph significantly out-performs GraphLab and Pregel on low α graphs.
In Fig. 10a and Fig. 10b we plot the per iteration runtime for each abstraction.
In both cases the overall runtime performance closely matches the communication overhead ( Fig. 9c and Fig. 9d) while the computation imbalance (Fig. 9a and Fig. 9b) appears to have little effect.
The limited effect of imbalance is due to the relatively lightweight nature of the PageRank computation and we expect more complex algorithms (e.g., statistical inference) to be more susceptible to imbalance.
However, when greedy (coordinated) partitioning is used we see an additional 25% to 50% improvement in runtime.
In this section, we describe and evaluate our implementation of the PowerGraph system.
All experiments are performed on a 64 node cluster of Amazon EC2 cc1.4xlarge Linux instances.
Each instance has two quad core Intel Xeon X5570 processors with 23GB of RAM, and is connected via 10 GigE Ethernet.
PowerGraph was written in C++ and compiled with GCC 4.5.
We implemented three variations of the PowerGraph abstraction.
To demonstrate their relative implementation complexity, we provide the line counts, excluding common support code: Asynchronous Serializable (Async+S): An asynchronous implementation of PowerGraph which guarantees serializability of all vertex-programs (equivalent to "edge consistency" in GraphLab).
[1600 lines] In all cases the system is entirely symmetric with no single coordinating instance or scheduler.
Each instances is given the list of other machines and start by reading a unique subset of the graph data files from HDFS.
TCP connections are opened with other machines as needed to build the distributed graph and run the engine.
The graph structure and data are loaded from a collection of text files stored in a distributed file-system (HDFS) by all instances in parallel.
Each machine loads a separate subset of files (determined by hashing) and applies one of the three distributed graph partitioning algorithms to place the data as it is loaded.
As a consequence partitioning is accomplished in parallel and data is immediately placed in its final location.
Unless specified, all experiments were performed using the oblivious algorithm.
Once computation is complete, the final vertex and edge data are saved back to the distributed file-system in parallel.In Fig. 7b, we evaluate the performance of a collection of algorithms varying the partitioning procedure.
Our simple partitioning heuristics are able to improve performance significantly across all algorithms, decreasing runtime and memory utilization.
Furthermore, the runtime scales linearly with the replication factor: halving the replication factor approximately halves runtime.
Our synchronous implementation closely follows the description in Sec. 4.3.1.
Each machine runs a single multithreaded instance to maximally utilize the multi-core architecture.
We rely on background communication to achieve computation/communication interleaving.
The synchronous engine's fully deterministic execution makes it easy to reason about programmatically and minimizes effort needed for tuning and performance optimizations.In Fig. 11a and Fig. 11b we plot the runtime and total communication of one iteration of PageRank on the Twitter follower network for each partitioning method.
To provide a point of comparison (Tab.
2), the Spark [37] framework computes one iteration of PageRank on the same graph in 97.4s on a 50 node-100 core cluster [35].
PowerGraph is therefore between 3-8x faster than Spark on a comparable number of cores.
On the full cluster of 512 cores, we can compute one iteration in 3.6s.The greedy partitioning heuristics improves both performance and scalability of the engine at the cost of increased load-time.
The load time for random, oblivious, and coordinated placement were 59, 105, and 239 seconds respectively.
While greedy partitioning heuristics increased load-time by up to a factor of four, they still improve overall runtime if more than 20 iterations of PageRank are performed.
In Fig. 11c we plot the runtime of each iteration of PageRank on the Twitter follower network.
Delta caching improves performance by avoiding unnecessary gather computation, decreasing total runtime by 45%.
Finally, in Fig. 11d we evaluate weak-scaling: ability to scale while keeping the problem size per processor constant.
We run SSSP (Fig. 3) on synthetic power-law graphs (α = 2), with ten-million vertices per machine.
Our implementation demonstrates nearly optimal weakscaling and requires only 65s to solve a 6.4B edge graph.
We implemented the asynchronous PowerGraph execution model (Sec. 4.3.2) using a simple state machine for each vertex which can be either: INACTIVE, GATHER, APPLY or SCATTER.
Once activated, a vertex enters the gathering state and is placed in a local scheduler which assigns cores to active vertices allowing many vertexprograms to run simultaneously thereby hiding communication latency.
While arbitrary interleaving of vertex programs is permitted, we avoid data races by ensuring that individual gather, apply, and scatter calls have exclusive access to their arguments.We evaluate the performance of the Async engine by running PageRank on the Twitter follower network.
In Fig. 12a, we plot throughput (number of vertex-program operations per second) against the number of machines.
Throughput increases moderately with both the number of machines as well as improved partitioning.
We evaluate the gains associated with delta caching (Sec. 4.2) by measuring throughput as a function of time ( Fig. 12b) with caching enabled and with caching disabled.
Caching allows the algorithm to converge faster with fewer operations.
Surprisingly, when caching is disabled, the throughput increases over time.
Further analysis reveals that the computation gradually focuses on high-degree vertices, increasing the computation/communication ratio.We evaluate the graph coloring vertex-program ( Fig. 3) which cannot be run synchronously since all vertices would change to the same color on every iteration.
Graph coloring is a proxy for many MLDM algorithms [17].
In Fig. 12c we evaluate weak-scaling on synthetic power-law graphs (α = 2) with five-million vertices per machine and find that the Async engine performs nearly optimally.
The slight increase in runtime may be attributed to an increase in the number of colors due to increasing graph size.
The Async engine is useful for a broad range of tasks, providing high throughput and performance.
However, unlike the synchronous engine, the asynchronous engine is difficult to reason about programmatically.
We therefore extended the Async engine to enforce serializability.The Async+S engine ensures serializability by preventing adjacent vertex-programs from running simultaneously.
Ensuring serializability for graph-parallel computation is equivalent to solving the dining philosophers problem where each vertex is a philosopher, and each edge is a fork.
GraphLab [29] implements Dijkstra's solution [14] where forks are acquired sequentially according to a total ordering.
Instead, we implement the ChandyMisra solution [10] which acquires all forks simultaneously, permitting a high degree of parallelism.
We extend the Chandy-Misra solution to the vertex-cut setting by enabling each vertex replica to request only forks for local edges and using a simple consensus protocol to establish when all replicas have succeeded.We evaluate the scalability and computational efficiency of the Async+S engine on the graph coloring task.
We observe in Fig. 12c that the amount of achieved parallelism does not increase linearly with the number of vertices.
Because the density (i.e., contention) of powerlaw graphs increases super-linearly with the number of vertices, we do not expect the amount of serializable parallelism to increase linearly.
In Fig. 12d, we plot the proportion of edges that satisfy the coloring condition (both vertices have different colors) for both the Async and the Async+S engines.
While the Async engine quickly satisfies the coloring condition for most edges, the remaining 1% take 34% of the runtime.
We attribute this behavior to frequent races on tightly connected vertices.
Alternatively, the Async+S engine performs more uniformly.
If we examine the total number of user operations we find that the Async engine does more than twice the work of the Async+S engine.Finally, we evaluate the Async and the Async+S engines on a popular machine learning algorithm: Alternating Least Squares (ALS).
The ALS algorithm has a number of variations which allow it to be used in a wide range of applications including user personalization [38] and document semantic analysis [21].
We apply ALS to the Wikipedia term-document graph consisting of 11M vertices and 315M edges to extract a mixture of topics representation for each document and term.
The number of topics d is a free parameter that determines the computational complexity O 񮽙 d 3 񮽙 of each vertex-program.
In Fig. 13a, we plot the ALS throughput on the Async engine and the Async+S engine.
While the throughput of the Async engine is greater, the gap between engines shrinks as d increases and computation dominates the consistency overhead.
To demonstrate the importance of serializabil- ity, we plot in Fig. 13b the training error, a measure of solution quality, for both engines.
We observe that while the Async engine has greater throughput, the Async+S engine converges faster.The complexity of the Async+S engine is justified by the necessity for serializability in many applications (e.g., ALS).
Furthermore, serializability adds predictability to the nondeterministic asynchronous execution.
For example, even graph coloring may not terminate on dense graphs unless serializability is ensured.
Like GraphLab and Pregel, PowerGraph achieves faulttolerance by saving a snapshot of the data-graph.
The synchronous PowerGraph engine constructs the snapshot between super-steps and the asynchronous engine suspends Runtime |V | |E| System Hadoop [22] 198s -1.1B 50x8 Spark [37] 97.4s 40M 1.5B 50x2 Twister [15] 36s 50M 1.4B 64x4 PowerGraph (Sync) 3.6s 40M 1.5B 64x8 execution to construct the snapshot.
An asynchronous snapshot using GraphLab's snapshot algorithm [29] can also be implemented.
The checkpoint overhead, typically a few seconds for the largest graphs we considered, is small relative to the running time of each application.
In Tab.
2 we provide comparisons of the PowerGraph system with published results on similar data for PageRank, Triangle Counting [36], and collapsed Gibbs sampling for the LDA model [34].
The PowerGraph implementations of PageRank and Triangle counting are one to two orders of magnitude faster than published results.
For LDA, the state-of-the-art solution is a heavily optimized system designed for this specific task by Smola et al. [34].
In contrast, PowerGraph is able to achieve comparable performance using only 200 lines of user code.
The vertex-cut approach to distributed graph placement is related to work [9,13] in hypergraph partitioning.
In particular, a vertex-cut problem can be cast as a hypergraphcut problem by converting each edge to a vertex, and each vertex to a hyper-edge.
However, existing hypergraph partitioning can be very time intensive.
While our cut objective is similar to the "communication volume" objective, the streaming vertex cut setting described in this paper is novel.
Stanton et al, in [35] developed several heuristics for the streaming edge-cuts but do not consider the vertex-cut problem.
Several [8,22] have proposed generalized sparse matrix vector multiplication as a basis for graph-parallel computation.
These abstractions operate on commutative associative semi-rings and therefore also have generalized gather and sum operations.
However, they do not support the more general apply and scatter operations, as well as mutable edge-data and are based on a strictly synchronous model in which all computation is run in every iteration.While we discuss Pregel and GraphLab in detail, there are other similar graph-parallel abstractions.
Closely related to Pregel is BPGL [20] which implements a synchronous traveler model.
Alternatively, Kineograph [11] presents a graph-parallel framework for time-evolving graphs which mixes features from both GraphLab and Piccolo.
Pujol et al. [33] present a distributed graph database but do not explicitly consider the power-law structure.
Finally, [25] presents GraphChi: an efficient single-machine disk-based implementation of the GraphLab abstraction.
Impressively, it is able to significantly out-perform large Hadoop deployments on many graph problems while using only a single machine: performing one iteration of PageRank on the Twitter Graph in only 158s (PowerGraph: 3.6s).
The techniques described in GraphChi can be used to add out-of-core storage to PowerGraph.
The need to reason about large-scale graph-structured data has driven the development of new graph-parallel abstractions such as GraphLab and Pregel.
However graphs derived from real-world phenomena often exhibit power-law degree distributions, which are difficult to partition and can lead to work imbalance and substantially increased communication and storage.To address these challenges, we introduced the PowerGraph abstraction which exploits the Gather-ApplyScatter model of computation to factor vertex-programs over edges, splitting high-degree vertices and exposing greater parallelism in natural graphs.
We then introduced vertex-cuts and a collection of fast greedy heuristics to substantially reduce the storage and communication costs of large distributed power-law graphs.
We theoretically related the power-law constant to the communication and storage requirements of the PowerGraph system and empirically evaluate our analysis by comparing against GraphLab and Pregel.
Finally, we evaluate the PowerGraph system on several large-scale problems using a 64 node EC2 cluster and demonstrating the scalability and efficiency and in many cases order of magnitude gains over published results.We are actively using PowerGraph to explore new largescale machine learning algorithms.
We are beginning to study how vertex replication and data-dependencies can be used to support fault-tolerance without checkpointing.
In addition, we are exploring ways to support time-evolving graph structures.
Finally, we believe that many of the core ideas in the PowerGraph abstraction can have a significant impact in the design and implementation of graph-parallel systems beyond PowerGraph.
This work is supported by the ONR Young Investigator Program grant N00014-08-1-0752, the ARO under MURI W911NF0810242, the ONR PECASE-N00014-10-1-0672, the National Science Foundation grant IIS-0803333 as well as the Intel Science and Technology Center for Cloud Computing.
Joseph Gonzalez is supported by the Graduate Research Fellowship from the NSF.
We would like to thank Alex Smola, Aapo Kyrola, Lidong Zhou, and the reviewers for their insightful guidance.
