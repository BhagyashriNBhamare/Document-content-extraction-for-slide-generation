We present WiscKey, a persistent LSM-tree-based key-value store with a performance-oriented data layout that separates keys from values to minimize I/O amplification.
The design of WiscKey is highly SSD optimized, leveraging both the sequential and random performance characteristics of the device.
We demonstrate the advantages of WiscKey with both microbenchmarks and YCSB workloads.
Microbenchmark results show that WiscKey is 2.5×-111× faster than LevelDB for loading a database and 1.6×-14× faster for random lookups.
WiscKey is faster than both LevelDB and RocksDB in all six YCSB workloads.
Persistent key-value stores play a critical role in a variety of modern data-intensive applications, including web indexing [16,48], e-commerce [24], data deduplication [7,22], photo stores [12], cloud data [32], social networking [9,25,51], online gaming [23], messaging [1,29], software repository [2] and advertising [20].
By enabling efficient insertions, point lookups, and range queries, key-value stores serve as the foundation for this growing group of important applications.For write-intensive workloads, key-value stores based on Log-Structured Merge-Trees (LSM-trees) [43] have become the state of the art.
Various distributed and local stores built on LSM-trees are widely deployed in largescale production environments, such as BigTable [16] and LevelDB [48] at Google, Cassandra [33], HBase [29] and RocksDB [25] at Facebook, PNUTS [20] at Yahoo!, and Riak [4] at Basho.
The main advantage of LSMtrees over other indexing structures (such as B-trees) is that they maintain sequential access patterns for writes.
Small updates on B-trees may involve many random writes, and are hence not efficient on either solid-state storage devices or hard-disk drives.To deliver high write performance, LSM-trees batch key-value pairs and write them sequentially.
Subsequently, to enable efficient lookups (for both individual keys as well as range queries), LSM-trees continuously read, sort, and write key-value pairs in the background, thus maintaining keys and values in sorted order.
As a result, the same data is read and written multiple times throughout its lifetime; as we show later ( §2), this I/O amplification in typical LSM-trees can reach a factor of 50x or higher [39,54].
The success of LSM-based technology is tied closely to its usage upon classic hard-disk drives (HDDs).
In HDDs, random I/Os are over 100× slower than sequential ones [43]; thus, performing additional sequential reads and writes to continually sort keys and enable efficient lookups represents an excellent trade-off.
However, the storage landscape is quickly changing, and modern solid-state storage devices (SSDs) are supplanting HDDs in many important use cases.
As compared to HDDs, SSDs are fundamentally different in their performance and reliability characteristics; when considering key-value storage system design, we believe the following three differences are of paramount importance.
First, the difference between random and sequential performance is not nearly as large as with HDDs; thus, an LSM-tree that performs a large number of sequential I/Os to reduce later random I/Os may be wasting bandwidth needlessly.
Second, SSDs have a large degree of internal parallelism; an LSM built atop an SSD must be carefully designed to harness said parallelism [53].
Third, SSDs can wear out through repeated writes [34,40]; the high write amplification in LSMtrees can significantly reduce device lifetime.
As we will show in the paper ( §4), the combination of these factors greatly impacts LSM-tree performance on SSDs, reducing throughput by 90% and increasing write load by a factor over 10.
While replacing an HDD with an SSD underneath an LSM-tree does improve performance, with current LSM-tree technology, the SSD's true potential goes largely unrealized.In this paper, we present WiscKey, an SSD-conscious persistent key-value store derived from the popular LSMtree implementation, LevelDB.
The central idea behind WiscKey is the separation of keys and values [42]; only keys are kept sorted in the LSM-tree, while values are stored separately in a log.
In other words, we decouple key sorting and garbage collection in WiscKey while LevelDB bundles them together.
This simple technique can significantly reduce write amplification by avoiding the unnecessary movement of values while sorting.
Furthermore, the size of the LSM-tree is noticeably decreased, leading to fewer device reads and better caching In this section, we first describe the concept of a LogStructured Merge-tree (LSM-tree).
Then, we explain the design of LevelDB, a popular key-value store based on LSM-tree technology.
We investigate read and write amplification in LevelDB.
Finally, we describe the characteristics of modern storage hardware.
An LSM-tree is a persistent structure that provides efficient indexing for a key-value store with a high rate of For LevelDB, inserting a key-value pair goes through many steps: (1) the log file; (2) the memtable; (3) the immutable memtable; (4) a SSTable in L0; (5) compacted to further levels.
inserts and deletes [43].
It defers and batches data writes into large chunks to use the high sequential bandwidth of hard drives.
Since random writes are nearly two orders of magnitude slower than sequential writes on hard drives, LSM-trees provide better write performance than traditional B-trees, which require random accesses.An LSM-tree consists of a number of components of exponentially increasing sizes, C 0 to C k , as shown in Figure 1.
The C 0 component is a memory-resident update-in-place sorted tree, while the other components C 1 to C k are disk-resident append-only B-trees.
During an insert in an LSM-tree, the inserted keyvalue pair is appended to an on-disk sequential log file, so as to enable recovery in case of a crash.
Then, the key-value pair is added to the in-memory C 0 , which is sorted by keys; C 0 allows efficient lookups and scans on recently inserted key-value pairs.
Once C 0 reaches its size limit, it will be merged with the on-disk C 1 in an approach similar to merge sort; this process is known as compaction.
The newly merged tree will be written to disk sequentially, replacing the old version of C 1 .
Compaction (i.e., merge sorting) also happens for on-disk components, when each C i reaches its size limit.
Note that compactions are only performed between adjacent levels (C i and C i+1 ), and they can be executed asynchronously in the background.To serve a lookup operation, LSM-trees may need to search multiple components.
Note that C 0 contains the freshest data, followed by C 1 , and so on.
Therefore, to retrieve a key-value pair, the LSM-tree searches components starting from C 0 in a cascading fashion until it locates the desired data in the smallest component C i .
Compared with B-trees, LSM-trees may need multiple reads for a point lookup.
Hence, LSM-trees are most useful when inserts are more common than lookups [43].
LevelDB is a widely used key-value store based on LSMtrees that is inspired by BigTable [16,48].
LevelDB sup-ports range queries, snapshots, and other features that are useful in modern applications.
In this section, we briefly describe the core design of LevelDB.The overall architecture of LevelDB is shown in Fig- ure 1.
The main data structures in LevelDB are an ondisk log file, two in-memory sorted skiplists (memtable and immutable memtable), and seven levels (L 0 to L 6 ) of on-disk Sorted String Table (SSTable) files.
LevelDB initially stores inserted key-value pairs in a log file and the in-memory memtable.
Once the memtable is full, LevelDB switches to a new memtable and log file to handle further inserts from the user.
In the background, the previous memtable is converted into an immutable memtable, and a compaction thread then flushes it to the disk, generating a new SSTable file (about 2 MB usually) at level 0 (L 0 ); the previous log file is discarded.The size of all files in each level is limited, and increases by a factor of ten with the level number.
For example, the size limit of all files at L 1 is 10 MB, while the limit of L 2 is 100 MB.
To maintain the size limit, once the total size of a level L i exceeds its limit, the compaction thread will choose one file from L i , merge sort with all the overlapped files of L i+1 , and generate new L i+1 SSTable files.
The compaction thread continues until all levels are within their size limits.
Also, during compaction, LevelDB ensures that all files in a particular level, except L 0 , do not overlap in their keyranges; keys in files of L 0 can overlap with each other since they are directly flushed from memtable.To serve a lookup operation, LevelDB searches the memtable first, immutable memtable next, and then files L 0 to L 6 in order.
The number of file searches required to locate a random key is bounded by the maximum number of levels, since keys do not overlap between files within a single level, except in L 0 .
Since files in L 0 can contain overlapping keys, a lookup may search multiple files at L 0 .
To avoid a large lookup latency, LevelDB slows down the foreground write traffic if the number of files at L 0 is bigger than eight, in order to wait for the compaction thread to compact some files from L 0 to L 1 .
Write and read amplification are major problems in LSM-trees such as LevelDB.
Write (read) amplification is defined as the ratio between the amount of data written to (read from) the underlying storage device and the amount of data requested by the user.
In this section, we analyze the write and read amplification in LevelDB.To achieve mostly-sequential disk access, LevelDB writes more data than necessary (although still sequentially), i.e., LevelDB has high write amplification.
Since the size limit of L i is 10 times that of L i−1 , when merging a file from L i−1 to L i during compaction, LevelDB may read up to 10 files from L i in the worst case, and write back these files to L i after sorting.
Therefore, the write amplification of moving a file across two levels can be up to 10.
For a large dataset, since any newly generated table file can eventually migrate from L 0 to L 6 through a series of compaction steps, write amplification can be over 50 (10 for each gap between L 1 to L 6 ).
Read amplification has been a major problem for LSM-trees due to trade-offs made in the design.
There are two sources of read amplification in LevelDB.
First, to lookup a key-value pair, LevelDB may need to check multiple levels.
In the worst case, LevelDB needs to check eight files in L 0 , and one file for each of the remaining six levels: a total of 14 files.
Second, to find a key-value pair within a SSTable file, LevelDB needs to read multiple metadata blocks within the file.
Specifically, the amount of data actually read is given by (index block + bloom-filter blocks + data block).
For example, to lookup a 1-KB key-value pair, LevelDB needs to read a 16-KB index block, a 4-KB bloom-filter block, and a 4-KB data block; in total, 24 KB.
Therefore, considering the 14 SSTable files in the worst case, the read amplification of LevelDB is 24 × 14 = 336.
Smaller key-value pairs will lead to an even higher read amplification.To measure the amount of amplification seen in practice with LevelDB, we perform the following experiment.
We first load a database with 1-KB key-value pairs, and then lookup 100,000 entries from the database; we use two different database sizes for the initial load, and choose keys randomly from a uniform distribution.
Figure 2 shows write amplification during the load phase and read amplification during the lookup phase.
For a 1-GB database, write amplification is 3.1, while for a 100-GB database, write amplification increases to 14.
Read amplification follows the same trend: 8.2 for the 1-GB database and 327 for the 100-GB database.
The reason write amplification increases with database size is straightforward.
With more data inserted into a database, the key-value pairs will more likely travel further along the levels; in other words, LevelDB will write data many times when compacting from low levels to high levels.
However, write amplification does not reach the worstcase predicted previously, since the average number of files merged between levels is usually smaller than the worst case of 10.
Read amplification also increases with the dataset size, since for a small database, all the index blocks and bloom filters in SSTable files can be cached in memory.
However, for a large database, each lookup may touch a different SSTable file, paying the cost of reading index blocks and bloom filters each time.It should be noted that the high write and read amplifications are a justified tradeoff for hard drives.
As an example, for a given hard drive with a 10-ms seek latency and a 100-MB/s throughput, the approximate time required to access a random 1K of data is 10 ms, while that for the next sequential block is about 10 µs -the ratio between random and sequential latency is 1000:1.
Hence, compared to alternative data structures such as B-Trees that require random write accesses, a sequential-writeonly scheme with write amplification less than 1000 will be faster on a hard drive [43,49].
On the other hand, the read amplification for LSM-trees is still comparable to B-Trees.
For example, considering a B-Tree with a height of five and a block size of 4 KB, a random lookup for a 1-KB key-value pair would require accessing six blocks, resulting in a read amplification of 24.
Many modern servers adopt SSD devices to achieve high performance.
Similar to hard drives, random writes are considered harmful also in SSDs [10,31,34,40] due to their unique erase-write cycle and expensive garbage collection.
Although initial random-write performance for SSD devices is good, the performance can significantly drop after the reserved blocks are utilized.
The LSM-tree characteristic of avoiding random writes is hence a natural fit for SSDs; many SSD-optimized key-value stores are based on LSM-trees [25,50,53,54].
However, unlike hard-drives, the relative performance of random reads (compared to sequential reads) is significantly better on SSDs; furthermore, when random reads are issued concurrently in an SSD, the aggregate throughput can match sequential throughput for some workloads [17].
As an example, Figure 3 shows the sequential and random read performance of a 500-GB Samsung 840 EVO SSD, for various request sizes.
For random reads by a single thread, the throughput increases with the request size, reaching half the sequential throughput for 256 KB.
With concurrent random reads by 32 threads, the aggregate throughput matches sequential throughput when the size is larger than 16 KB.
For more high-end SSDs, the gap between concurrent random reads and sequential reads is much smaller [3,39].
As we showed in this section, LSM-trees have a high write and read amplification, which is acceptable for hard drives.
Using LSM-trees on a high-performance SSD may waste a large percentage of device bandwidth with excessive writing and reading.
In this paper, our goal is to improve the performance of LSM-trees on SSD devices to efficiently exploit device bandwidth.
The previous section explained how LSM-trees maintain sequential I/O access by increasing I/O amplification.
While this trade-off between sequential I/O access and I/O amplification is justified for traditional hard disks, they are not optimal for modern hardware utilizing SSDs.
In this section, we present the design of WiscKey, a keyvalue store that minimizes I/O amplification on SSDs.To realize an SSD-optimized key-value store, WiscKey includes four critical ideas.
First, WiscKey separates keys from values, keeping only keys in the LSM-tree and the values in a separate log file.
Second, to deal with unsorted values (which necessitate random access during range queries), WiscKey uses the parallel random-read characteristic of SSD devices.
Third, WiscKey utilizes unique crash-consistency and garbagecollection techniques to efficiently manage the value log.
Finally, WiscKey optimizes performance by removing the LSM-tree log without sacrificing consistency, thus reducing system-call overhead from small writes.
WiscKey is a single-machine persistent key-value store, derived from LevelDB.
It can be deployed as the storage engine for a relational database (e.g., MySQL) or a distributed key-value store (e.g., MongoDB).
It provides the same API as LevelDB, including Put(key, value), Get(key), Delete(key) and Scan(start, end).
The design of WiscKey follows these main goals.Low write amplification.
Write amplification introduces extra unnecessary writes.
Even though SSD devices have higher bandwidth compared to hard drives, large write amplification can consume most of the write bandwidth (over 90% is not uncommon) and decrease the SSD's lifetime due to limited erase cycles.
Therefore, it is important to minimize write amplification, so as to improve workload performance and SSD lifetime.
Low read amplification.
Large read amplification causes two problems.
First, the throughput of lookups is significantly reduced by issuing multiple reads for each lookup.
Second, the large amount of data loaded into memory decreases the efficiency of the cache.
WiscKey targets a small read amplification to speedup lookups.
SSD optimized.
WiscKey is optimized for SSD devices by matching its I/O patterns with the performance characteristics of SSD devices.
Specifically, sequential writes and parallel random reads are effectively utilized so that applications can fully utilize the device's bandwidth.
Feature-rich API.
WiscKey aims to support modern features that have made LSM-trees popular, such as range queries and snapshots.
Range queries allow scanning a contiguous sequence of key-value pairs.
Snapshots allow capturing the state of the database at a particular time and then performing lookups on the state.Realistic key-value sizes.
Keys are usually small in modern workloads (e.g., 16 B) [7,8,11,22,35], though value sizes can vary widely (e.g., 100 B to larger than 4 KB) [6,11,22,28,32,49].
WiscKey aims to provide high performance for this realistic set of key-value sizes.
The major performance cost of LSM-trees is the compaction process, which constantly sorts SSTable files.
During compaction, multiple files are read into memory, sorted, and written back, which could significantly affect the performance of foreground workloads.
However, sorting is required for efficient retrieval; with sorting, range queries (i.e., scan) will result mostly in sequential access to multiple files, while point queries would require accessing at most one file at each level.WiscKey is motivated by a simple revelation.
Compaction only needs to sort keys, while values can be managed separately [42].
Since keys are usually smaller than values, compacting only keys could significantly reduce the amount of data needed during the sorting.
In WiscKey, only the location of the value is stored in the LSM-tree with the key, while the actual values are stored elsewhere in an SSD-friendly fashion.
With this design, for a database with a given size, the size of the LSM-tree of WiscKey is much smaller than that of LevelDB.
The smaller LSM-tree can remarkably reduce the write amplification for modern workloads that have a moderately large value size.
For example, assuming a 16-B key, a 1- KB value, and a write amplification of 10 for keys (in the LSM-tree) and 1 for values, the effective write amplification of WiscKey is only (10 × 16 + 1024) / (16 + 1024) = 1.14.
In addition to improving the write performance of applications, the reduced write amplification also improves an SSD's lifetime by requiring fewer erase cycles.
WiscKey's smaller read amplification improves lookup performance.
During lookup, WiscKey first searches the LSM-tree for the key and the value's location; once found, another read is issued to retrieve the value.
Readers might assume that WiscKey will be slower than LevelDB for lookups, due to its extra I/O to retrieve the value.
However, since the LSM-tree of WiscKey is much smaller than LevelDB (for the same database size), a lookup may search fewer levels of table files in the LSM-tree and a significant portion of the LSM-tree can be easily cached in memory.
Hence, each lookup only requires a single random read (for retrieving the value) and thus achieves a lookup performance better than LevelDB.
For example, assuming 16-B keys and 1-KB values, if the size of the entire key-value dataset is 100 GB, then the size of the LSM-tree is only around 2 GB (assuming a 12-B cost for a value's location and size), which can be easily cached in modern servers which have over 100-GB of memory.WiscKey's architecture is shown in Figure 4.
Keys are stored in an LSM-tree while values are stored in a separate value-log file, the vLog.
The artificial value stored along with the key in the LSM-tree is the address of the actual value in the vLog.When the user inserts a key-value pair in WiscKey, the value is first appended to the vLog, and the key is then inserted into the LSM tree along with the value's address (<vLog-offset, value-size>).
Deleting a key simply deletes it from the LSM tree, without touching the vLog.
All valid values in the vLog have corresponding keys in the LSM-tree; the other values in the vLog are invalid and will be garbage collected later ( § 3.3.2).
When the user queries for a key, the key is first searched in the LSM-tree, and if found, the corresponding value's address is retrieved.
Then, WiscKey reads the value from the vLog.
Note that this process is applied to both point queries and range queries.Although the idea behind key-value separation is simple, it leads to many challenges and optimization opportunities described in the following subsections.
The separation of keys and values makes range queries require random I/O.
Furthermore, the separation makes both garbage collection and crash consistency challenging.
We now explain how we solve these challenges.
Range queries are an important feature of modern keyvalue stores, allowing users to scan a range of key-value pairs.
Relational databases [26], local file systems [30,46,50], and even distributed file systems [37] use keyvalue stores as their storage engines, and range queries are a core API requested in these environments.For range queries, LevelDB provides the user with an iterator-based interface with Seek(key), Next(), Prev(), Key() and Value() operations.
To scan a range of keyvalue pairs, users can first Seek() to the starting key, then call Next() or Prev() to search keys one by one.
To retrieve the key or the value of the current iterator position, users call Key() or Value(), respectively.In LevelDB, since keys and values are stored together and sorted, a range query can sequentially read key-value pairs from SSTable files.
However, since keys and values are stored separately in WiscKey, range queries require random reads, and are hence not efficient.
As we see in Figure 3, the random read performance of a single thread on SSD cannot match the sequential read performance.
However, parallel random reads with a fairly large request size can fully utilize the device's internal parallelism, getting performance similar to sequential reads.To make range queries efficient, WiscKey leverages the parallel I/O characteristic of SSD devices to prefetch values from the vLog during range queries.
The underlying idea is that, with SSDs, only keys require special attention for efficient retrieval.
So long as keys are retrieved efficiently, range queries can use parallel random reads for efficiently retrieving values.The prefetching framework can easily fit with the current range query interface.
In the current interface, if the user requests a range query, an iterator is returned to the user.
For each Next() or Prev() requested on the iterator, WiscKey tracks the access pattern of the range query.
Once a contiguous sequence of key-value pairs is requested, WiscKey starts reading a number of following keys from the LSM-tree sequentially.
The corresponding value addresses retrieved from the LSM-tree are inserted into a queue; multiple threads will fetch these addresses from the vLog concurrently in the background.
Key-value stores based on standard LSM-trees do not immediately reclaim free space when a key-value pair is deleted or overwritten.
Rather, during compaction, if data relating to a deleted or overwritten key-value pair is found, the data is discarded and space is reclaimed.
In WiscKey, only invalid keys are reclaimed by the LSMtree compaction.
Since WiscKey does not compact values, it needs a special garbage collector to reclaim free space in the vLog.Since we only store the values in the vLog file ( § 3.2), a naive way to reclaim free space from the vLog is to first scan the LSM-tree to get all the valid value addresses; then, all the values in the vLog without any valid reference from the LSM-tree can be viewed as invalid and reclaimed.
However, this method is too heavyweight and is only usable for offline garbage collection.WiscKey targets a lightweight and online garbage collector.
To make this possible, we introduce a small change to WiscKey's basic data layout: while storing values in the vLog, we also store the corresponding key along with the value.
The new data layout is shown in Figure 5: the tuple (key size, value size, key, value) is stored in the vLog.WiscKey's garbage collection aims to keep valid values (that do not correspond to deleted keys) in a contiguous range of the vLog, as shown in Figure 5.
One end of this range, the head, always corresponds to the end of the vLog where new values will be appended.
The other end of this range, known as the tail, is where garbage collection starts freeing space whenever it is triggered.
Only the part of the vLog between the head and the tail contains valid values and will be searched during lookups.During garbage collection, WiscKey first reads a chunk of key-value pairs (e.g., several MBs) from the tail of the vLog, then finds which of those values are valid (not yet overwritten or deleted) by querying the LSM-tree.
WiscKey then appends valid values back to the head of the vLog.
Finally, it frees the space occupied previously by the chunk, and updates the tail accordingly.To avoid losing any data if a crash happens during garbage collection, WiscKey has to make sure that the newly appended valid values and the new tail are persistent on the device before actually freeing space.
WiscKey achieves this using the following steps.
After appending the valid values to the vLog, the garbage collection calls a fsync() on the vLog.
Then, it adds these new value's addresses and current tail to the LSMtree in a synchronous manner; the tail is stored in the LSM-tree as <''tail'', tail-vLog-offset>.
Finally, the free space in the vLog is reclaimed.WiscKey can be configured to initiate and continue garbage collection periodically or until a particular threshold is reached.
The garbage collection can also run in offline mode for maintenance.
Garbage collection can be triggered rarely for workloads with few deletes and for environments with overprovisioned storage space.
On a system crash, LSM-tree implementations usually guarantee atomicity of inserted key-value pairs and inorder recovery of inserted pairs.
Since WiscKey's architecture stores values separately from the LSM-tree, obtaining the same crash guarantees can appear complicated.
However, WiscKey provides the same crash guarantees by using an interesting property of modern file systems (such as ext4, btrfs, and xfs).
Consider a file that contains the sequence of bytes �b 1 b 2 b 3 ...b n �, and the user appends the sequence �b n+1 b n+2 b n+3 ...b n+m � to it.
If a crash happens, after file-system recovery in modern file systems, the file will be observed to contain the sequence of bytes �b 1 b 2 b 3 ...b n b n+1 b n+2 b n+3 ...b n+x � ∃ x < m, i.e., only some prefix of the appended bytes will be added to the end of the file during file-system recovery [45].
It is not possible for random bytes or a non-prefix subset of the appended bytes to be added to the file.
Since values are appended sequentially to the end of the vLog file in WiscKey, the aforementioned property conveniently translates as follows: if a value X in the vLog is lost in a crash, all future values (inserted after X) are lost too.When the user queries a key-value pair, if WiscKey cannot find the key in the LSM-tree because the key had been lost during a system crash, WiscKey behaves exactly like traditional LSM-trees: even if the value had been written in vLog before the crash, it will be garbage collected later.
If the key could be found in the LSM tree, however, an additional step is required to maintain consistency.
In this case, WiscKey first verifies whether the value address retrieved from the LSM-tree falls within the current valid range of the vLog, and then whether the value found corresponds to the queried key.
If the verifications fail, WiscKey assumes that the value was lost during a system crash, deletes the key from the LSMtree, and informs the user that the key was not found.
Write Unit Size 64B 256B 1KB 4KB 16KB 64KB Figure 6: Impact of Write Unit Size.
This figure shows the total time to write a 10-GB file to an ext4 file system on an SSD device, followed by a fsync() at the end.
We vary the size of each write() system call.Since each value added to the vLog has a header including the corresponding key, verifying whether the key and the value match is straightforward; if necessary, a magic number or checksum can be easily added to the header.
LSM-tree implementations also guarantee the user durability of key value pairs after a system crash if the user specifically requests synchronous inserts.
WiscKey implements synchronous inserts by flushing the vLog before performing a synchronous insert into its LSM-tree.
Separating keys from values in WiscKey provides an opportunity to rethink how the value log is updated and the necessity of the LSM-tree log.
We now describe how these opportunities can lead to improved performance.
For each Put(), WiscKey needs to append the value to the vLog by using a write() system call.
However, for an insert-intensive workload, issuing a large number of small writes to a file system can introduce a noticeable overhead, especially on a fast storage device [15,44].
Figure 6 shows the total time to sequentially write a 10-GB file in ext4 (Linux 3.14).
For small writes, the overhead of each system call aggregates significantly, leading to a long run time.
With large writes (larger than 4 KB), the device throughput is fully utilized.To reduce overhead, WiscKey buffers values in a userspace buffer, and flushes the buffer only when the buffer size exceeds a threshold or when the user requests a synchronous insertion.
Thus, WiscKey only issues large writes and reduces the number of write() system calls.
For a lookup, WiscKey first searches the vLog buffer, and if not found there, actually reads from the vLog.
Obviously, this mechanism might result in some data (that is buffered) to be lost during a crash; the crashconsistency guarantee obtained is similar to LevelDB.
As shown in Figure 1, a log file is usually used in LSMtrees.
The LSM-tree tracks inserted key-value pairs in the log file so that, if the user requests synchronous inserts and there is a crash, the log can be scanned after reboot and the inserted key-value pairs recovered.In WiscKey, the LSM-tree is only used for keys and value addresses.
Moreover, the vLog also records inserted keys to support garbage collection as described in the previous section.
Hence, writes to the LSM-tree log file can be avoided without affecting correctness.If a crash happens before the keys are persistent in the LSM-tree, they can be recovered by scanning the vLog.
However, a naive algorithm would require scanning the entire vLog for recovery.
So as to require scanning only a small portion of the vLog, WiscKey records the head of the vLog periodically in the LSM-tree, as a key-value pair <''head'', head-vLog-offset>.
When a database is opened, WiscKey starts the vLog scan from the most recent head position stored in the LSM-tree, and continues scanning until the end of the vLog.
Since the head is stored in the LSM-tree, and the LSM-tree inherently guarantees that keys inserted into the LSM-tree will be recovered in the inserted order, this optimization is crash consistent.
Therefore, removing the LSM-tree log of WiscKey is a safe optimization, and improves performance especially when there are many small insertions.
WiscKey is based on LevelDB 1.18.
WiscKey creates a vLog when creating a new database, and manages the keys and value addresses in the LSM-tree.
The vLog is internally accessed by multiple components with different access patterns.
For example, a lookup is served by randomly reading the vLog, while the garbage collector sequentially reads from the tail and appends to the head of the vLog file.
We use posix fadvise() to predeclare access patterns for the vLog under different situations.For range queries, WiscKey maintains a background thread pool with 32 threads.
These threads sleep on a thread-safe queue, waiting for new value addresses to arrive.
When prefetching is triggered, WiscKey inserts a fixed number of value addresses to the worker queue, and then wakes up all the sleeping threads.
These threads will start reading values in parallel, caching them in the buffer cache automatically.To efficiently garbage collect the free space of the vLog, we use the hole-punching functionality of modern file systems (fallocate()).
Punching a hole in a file can free the physical space allocated, and allows WiscKey to elastically use the storage space.
The maximal file size on modern file systems is big enough for WiscKey to run a long time without wrapping back to the beginning of the file; for example, the maximal file size is 64 TB on ext4, 8 EB on xfs and 16 EB on btrfs.
The vLog can be trivially adapted into a circular log if necessary.
In this section, we present evaluation results that demonstrate the benefits of the design choices of WiscKey.All experiments are run on a testing machine with two Intel(R) Xeon(R) CPU E5-2667 v2 @ 3.30GHz processors and 64-GB of memory.
The operating system is 64-bit Linux 3.14, and the file system used is ext4.
The storage device used is a 500-GB Samsung 840 EVO SSD, which has 500 MB/s sequential-read and 400 MB/s sequential-write maximal performance.
Random read performance of the device is shown in Figure 3.
We use db bench (the default microbenchmarks in LevelDB) to evaluate LevelDB and WiscKey.
We always use a key size of 16 B, but perform experiments for different value sizes.
We disable data compression for easier understanding and analysis of performance.
We now describe the results for the sequential-load and random-load microbenchmarks.
The former benchmark constructs a 100-GB database by inserting keys in a sequential order, while the latter inserts keys in a uniformly distributed random order.
Note that the sequential-load benchmark does not cause compaction in either LevelDB or WiscKey, while the random-load does.
Figure 7 shows the sequential-load throughput of LevelDB and WiscKey for a wide range of value sizes: the throughput of both stores increases with the value size.
But, even for the largest value size considered (256 KB), LevelDB's throughput is far from the device bandwidth.
To analyze this further, Figure 8 shows the distribution of the time spent in different components during each run of the benchmark, for LevelDB; time is spent in three major parts: writing to the log file, inserting to the memtable, and waiting for the memtable to be flushed to the device.
For small key-value pairs, writing to the log file accounts for the most significant percentage of the total time, for the reasons explained in Figure 6.
For larger pairs, log writing and the memtable sorting are more efficient, while memtable flushes are the bottleneck.
Unlike LevelDB, WiscKey reaches the full device bandwidth for value sizes more than 4 KB.
Since it does not write to the LSM-tree log and buffers appends to the vLog, it is 3× faster even for small values.
Figure 9 shows the random-load throughput of LevelDB and WiscKey for different value sizes.
LevelDB's throughput ranges from only 2 MB/s (64-B value size) to 4.1 MB/s (256-KB value size), while WiscKey's throughput increases with the value size, reaching the peak device write throughput after the value size is bigger than 4 KB.
WiscKey's throughput is 46× and 111× of LevelDB for the 1-KB and 4-KB value size respectively.
LevelDB has low throughput because compaction both consumes a large percentage of the device bandwidth and also slows down foreground writes (to avoid overloading the L 0 of the LSM-tree, as described in Section 2.2).
In WiscKey, compaction only introduces a small overhead, leading to the full device bandwidth being effectively utilized.
To analyze this further, Fig- ure 10 shows the write amplification of LevelDB and WiscKey ˙ The write amplification of LevelDB is always more than 12, while that of WiscKey decreases quickly to nearly 1 when the value size reaches 1 KB, because the LSM-tree of WiscKey is significantly smaller.
We now compare the random lookup (point query) and range query performance of LevelDB and WiscKey.
Fig- ure 11 presents the random lookup results of 100,000 operations on a 100-GB random-loaded database.
Even though a random lookup in WiscKey needs to check both the LSM-tree and the vLog, the throughput of WiscKey is still much better than LevelDB: for 1-KB value size, WiscKey's throughput is 12× of that of LevelDB.
For large value sizes, the throughput of WiscKey is only limited by the random read throughput of the device, as shown in Figure 3.
LevelDB has low throughput because of the high read amplification mentioned in Section 2.3.
WiscKey performs significantly better because the read amplification is lower due to a smaller LSM-tree.
Another reason for WiscKey's better performance is that the compaction process in WiscKey is less intense, thus avoiding many background reads and writes.
Figure 12 shows the range query (scan) performance of LevelDB and WiscKey.
For a randomly-loaded database, LevelDB reads multiple files from different levels, while WiscKey requires random accesses to the vLog (but WiscKey leverages parallel random reads).
As can be seen from Figure 12, the throughput of LevelDB initially increases with the value size for both databases.
However, beyond a value size of 4 KB, since an SSTable file can store only a small number of key-value pairs, the overhead is dominated by opening many SSTable files and reading the index blocks and bloom filters in each file.
For larger key-value pairs, WiscKey can deliver the device's sequential bandwidth, up to 8.4× of LevelDB.
However, WiscKey performs 12× worse than LevelDB for 64-B key-value pairs due to the device's limited parallel random-read throughput for small request sizes; WiscKey's relative performance is better on high-end SSDs with higher parallel random-read throughput [3].
Furthermore, this workload represents a worst-case where the database is randomly-filled and the data is unsorted in the vLog.
Figure 12 also shows the performance of range queries when the data is sorted, which corresponds to a sequentially-loaded database; in this case, both LevelDB and WiscKey can sequentially scan through data.
Performance for sequentially-loaded databases follows the same trend as randomly-loaded databases; for 64-B pairs, WiscKey is 25% slower because WiscKey reads both the keys and the values from the vLog (thus wasting bandwidth), but WiscKey is 2.8× faster for large keyvalue pairs.
Thus, with small key-value pairs, log reorganization (sorting) for a random-loaded database can make WiscKey's range-query performance comparable to LevelDB's performance.
We now investigate WiscKey's performance while garbage collection is performed in the background.
The performance can potentially vary depending on the percentage of free space found during garbage collection, since this affects the amount of data written and the amount of space freed by the garbage collection thread.
We use random-load (the workload that is most affected by garbage collection) as the foreground workload, and study its performance for various percentages of free space.
Our experiment specifically involves three steps: we first create a database using random-load, then delete the required percentage of key-value pairs, and finally, we run the random-load workload and measure its throughput while garbage collection happens in the background.
We use a key-value size of 4 KB and vary the percentage of free space from 25% to 100%.
Figure 13 shows the results: if 100% of data read by the garbage collector is invalid, the throughput is only 10% lower.
Throughput is only marginally lower because garbage collection reads from the tail of the vLog and writes only valid key-value pairs to the head; if the data read is entirely invalid, no key-value pair needs to be written.
For other percentages of free space, throughput drops about 35% since the garbage collection thread performs additional writes.
Note that, in all cases, while garbage collection is happening, WiscKey is at least 70× faster than LevelDB.
Separating keys from values necessitates additional mechanisms to maintain crash consistency.
We verify the crash consistency mechanisms of WiscKey by using the ALICE tool [45]; the tool chooses and simulates a comprehensive set of system crashes that have a high probability of exposing inconsistency.
We use a test case which invokes a few asynchronous and synchronous Put() calls.
When configured to run tests for ext4, xfs, and btrfs, ALICE checks more than 3000 selectivelychosen system crashes, and does not report any consistency vulnerability introduced by WiscKey.The new consistency mechanism also affects WiscKey's recovery time after a crash, and we design an experiment to measure the worst-case recovery time of WiscKey and LevelDB.
LevelDB's recovery time is proportional to the size of its log file after the crash; the log file exists at its maximum size just before the memtable is written to disk.
WiscKey, during recovery, first retrieves the head pointer from the LSM-tree, and then scans the vLog file from the head pointer till the end of the file.
Since the updated head pointer is persisted on disk when the memtable is written, WiscKey's worst-case recovery time also corresponds to a crash happening just before then.
We measured the worst-case recovery time induced by the situation described so far; for 1-KB values, LevelDB takes 0.7 seconds to recover the database after the crash, while WiscKey takes 2.6 seconds.
Note that WiscKey can be configured to persist the head pointer more frequently if necessary.
When evaluating a key-value store, most previous work focused only on read and write amplification.
However, space amplification is important for flash devices because of their expensive price-per-GB compared with hard drives.
Space amplification is the ratio of the actual size of the database on disk to the logical size of the the database [5].
For example, if a 1-KB key-value pair takes 4 KB of space on disk, then the space amplification is 4.
Compression decreases space amplification while extra data (garbage, fragmentation, or metadata) increases space amplification.
Compression is disabled to make the discussion simple.
For a sequential-load workload, the space amplification can be near one, given that the extra metadata in LSM-trees is minimal.
For a random-load or overwrite workload, space amplification is usually more than one when invalid pairs are not garbage collected fast enough.
Figure 14 shows the database size of LevelDB and WiscKey after randomly loading a 100-GB dataset (the same workload as Figure 9).
The space overhead of LevelDB arises due to invalid key-value pairs that are not garbage collected when the workload is finished.
The space overhead of WiscKey includes the invalid keyvalue pairs and the extra metadata (pointers in the LSMtree and the tuple in the vLog as shown in Figure 5).
After garbage collection, the database size of WiscKey is close to the logical database size when the extra metadata is small compared to the value size.No key-value store can minimize read amplification, write amplification, and space amplification at the same time.
Tradeoffs among these three factors are balanced differently in various systems.
In LevelDB, the sorting and garbage collection are coupled together.
LevelDB trades higher write amplification for lower space amplification; however, the workload performance can be significantly affected.
WiscKey consumes more space to minimize I/O amplification when the workload is running; because sorting and garbage collection are decoupled in WiscKey, garbage collection can be done later, thus minimizing its impact on foreground performance.
We now investigate the CPU usage of LevelDB and WiscKey for various workloads shown in previous sections.
The CPU usage shown here includes both the application and operating system usage.As shown in Table 1, LevelDB has higher CPU usage for sequential-load workload.
As we explained in Fig- ure 8, LevelDB spends a large amount of time writing key-value pairs to the log file.
Writing to the log file involves encoding each key-value pair, which has high CPU cost.
Since WiscKey removes the log file as an optimization, WiscKey has lower CPU usage than LevelDB.
For the range query workload, WiscKey uses 32 background threads to do the prefetch; therefore, the CPU usage of WiscKey is much higher than LevelDB.We find that CPU is not a bottleneck for both LevelDB and WiscKey in our setup.
The architecture of LevelDB is based on single writer protocol.
The background compaction also only uses one thread.
Better concurrency design for multiple cores is explored in RocksDB [25].
The YCSB benchmark [21] provides a framework and a standard set of six workloads for evaluating the performance of key-value stores.
We use YCSB to compare LevelDB, RocksDB [25], and WiscKey, on a 100-GB database.
In addition to measuring the usual-case performance of WiscKey, we also run WiscKey with garbage collection always happening in the background so as to measure its worst-case performance.
RocksDB [25] is a SSD-optimized version of LevelDB with many optimizations, including multiple memtables and background threads for compaction.
We use RocksDB with the default configuration parameters.
We evaluated the keyvalue stores with two different value sizes, 1 KB and 16 KB (data compression is disabled).
WiscKey performs significantly better than LevelDB and RocksDB, as shown in Figure 15.
For example, during load, for 1-KB values, WiscKey performs at least 50× faster than the other databases in the usual case, and at least 45× faster in the worst case (with garbage collection); with 16-KB values, WiscKey performs 104× better, even under the worst case.For reads, the Zipf distribution used in most workloads allows popular items to be cached and retrieved without incurring disk access, thus reducing WiscKey's advantage over LevelDB and RocksDB.
Hence, WiscKey's relative performance (compared to the LevelDB and RocksDB) is better in Workload-A (50% reads) than in Workload-B (95% reads) and Workload-C (100% reads).
However, RocksDB and LevelDB still do not match WiscKey's performance in any of these workloads.The worst-case performance of WiscKey (with garbage collection switched on always, even for readonly workloads) is better than LevelDB and RocksDB.
However, the impact of garbage collection on performance is markedly different for 1-KB and 16-KB values.
Garbage collection repeatedly selects and cleans a 4-MB chunk of the vLog; with small values, the chunk will include many key-value pairs, and thus garbage collection spends more time accessing the LSM-tree to verify the validity of each pair.
For large values, garbage collection spends less time on the verification, and hence aggressively writes out the cleaned chunk, affecting foreground throughput more.
Note that, if necessary, garbage collection can be throttled to reduce its foreground impact.Unlike the microbenchmark considered previously, Workload-E has multiple small range queries, with each query retrieving between 1 and 100 key-value pairs.
Since the workload involves multiple range queries, accessing the first key in each range resolves to a random lookup -a situation favorable for WiscKey.
Hence, WiscKey performs better than RocksDB and LevelDB even for 1-KB values.
Various key-value stores based on hash tables have been proposed for SSD devices.
FAWN [8] keeps key-value pairs in a append-only log on the SSD, and uses an in-memory hash table index for fast lookups.
FlashStore [22] and SkimpyStash [23] follow the same design, but optimize the in-memory hash table; FlashStore uses cuckoo hashing and compact key signatures, while SkimpyStash moves a part of the table to the SSD using linear chaining.
BufferHash [7] uses multiple inmemory hash tables, with bloom filters to choose which hash table to use for a lookup.
SILT [35] is highly optimized for memory, and uses a combination of logstructure, hash-table, and sorted-table layouts.WiscKey shares the log-structure data layout with these key-value stores.
However, these stores use hash tables for indexing, and thus do not support modern features that have been built atop LSM-tree stores, such as range queries or snapshots.
WiscKey instead targets a feature-rich keyvalue store which can be used in various situations.Much work has gone into optimizing the original LSM-tree key-value store [43].
bLSM [49] presents a new merge scheduler to bound write latency, thus maintaining a steady write throughput, and also uses bloom filters to improve performance.
VT-tree [50] avoids sorting any previously sorted key-value pairs during compaction, by using a layer of indirection.
WiscKey instead directly separates values from keys, significantly reducing write amplification regardless of the key distribution in the workload.
LOCS [53] exposes internal flash channels to the LSM-tree key-value store, which can exploit the abundant parallelism for a more efficient compaction.
Atlas [32] is a distributed key-value store based on ARM processors and erasure coding, and stores keys and values on different hard drives.
WiscKey is a standalone key-value store, where the separation between keys and values is highly optimized for SSD devices to achieve significant performance gains.
LSM-trie [54] uses a trie structure to organize keys, and proposes a more efficient compaction based on the trie; however, this design sacrifices LSM-tree features such as efficient support for range queries.
RocksDB, described previously, still exhibits high write amplification due to its design being fundamentally similar to LevelDB; RocksDB's optimizations are orthogonal to WiscKey's design.Walnut [18] is a hybrid object store which stores small objects in a LSM-tree and writes large objects directly to the file system.
IndexFS [47] stores its metadata in a LSM-tree with the column-style schema to speed up the throughput of insertion.
Purity [19] also separates its index from data tuples by only sorting the index and storing tuples in time order.
All three systems use similar techniques as WiscKey.
However, we solve this problem in a more generic and complete manner, and optimize both load and lookup performance for SSD devices across a wide range of workloads.Key-value stores based on other data structures have also been proposed.
TokuDB [13,14] is based on fractaltree indexes, which buffer updates in internal nodes; the keys are not sorted, and a large index has to be maintained in memory for good performance.
ForestDB [6] uses a HB+-trie to efficiently index long keys, improving the performance and reducing the space overhead of internal nodes.
NVMKV [39] is a FTL-aware key-value store which uses native FTL capabilities, such as sparse addressing, and transactional supports.
Vector interfaces that group multiple requests into a single operation are also proposed for key-value stores [52].
Since these keyvalue stores are based on different data structures, they each have different trade-offs relating to performance; instead, WiscKey proposes improving the widely used LSM-tree structure.Many proposed techniques seek to overcome the scalability bottlenecks of in-memory key-value stores, such as Mastree [38], MemC3 [27], Memcache [41], MICA [36] and cLSM [28].
These techniques may be adapted for WiscKey to further improve its performance.
Key-value stores have become a fundamental building block in data-intensive applications.
In this paper, we propose WiscKey, a novel LSM-tree-based key-value store that separates keys and values to minimize write and read amplification.
The data layout and I/O patterns of WiscKey are highly optimized for SSD devices.
Our results show that WiscKey can significantly improve performance for most workloads.
Our hope is that key-value separation and various optimization techniques in WiscKey will inspire the future generation of high-performance key-value stores.
We thank the anonymous reviewers and Ethan Miller (our shepherd) for their feedback.
We thank the members of the ADSL research group, the RocksDB team (FaceBook), Yinan Li (Microsoft Research) and Bin Fan (Tachyon Nexus) for their suggestions and comments on this work at various stages.
This material was supported by funding from NSF grants CNS-1419199, CNS-1421033, CNS-1319405, and CNS-1218405 as well as generous donations from EMC, Facebook, Google, Huawei, Microsoft, NetApp, Seagate, Samsung, Veritas, and VMware.
Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and may not reflect the views of NSF or other institutions.
