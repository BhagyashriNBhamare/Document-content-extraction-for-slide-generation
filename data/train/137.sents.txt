We define a new type of policy, the knowledge gradient policy, in the context of an offline learning problem.
We show how to compute the knowledge gradient policy efficiently and demonstrate through Monte Carlo simulations that it performs as well or better than a number of existing learning policies.
We consider a problem in which we are presented with a finite set of alternatives, allowed to sample their values a fixed number of times, and then asked to choose one alternative from among the set.
We receive a reward equal to the value of the alternative chosen.
Our goal is to distribute the sample measurements to maximize the expected reward.Let (Ω, F, IP) be a probability space and let {1, . . . M} be the set of alternatives.
For each x ∈ {1, . . . M} define a random variable Y x to be the true value of alternative x.
We will be allotted exactly N measurements, and at each time n, 0 ≤ n < N, we choose an alternative x n to measure.
Definê y n+1 to be the measurement value observed, and define ε n+1 := ˆ y n+1 − Y x to be the error in this measurement.
We assume that the errors ε n+1 are unbiased and normally distributed with a known variance σ 2 that is the same across all alternatives.
We also assume that errors are independent of each other and of the random vector Y .
At time N , we choose an implementation decision x N based on the measurements recorded and we receive a rewardˆyrewardˆ rewardˆy N +1 .
We assume that the reward is unbiased, so thatˆythatˆ thatˆy N +1 satisfies IE 񮽙ˆy񮽙ˆ 񮽙ˆy N +1 |Y, x N 񮽙 = Y x N .
Define the filtration (F n ) n=N n=0 by letting F n be the sigma algebra generated by x 0 , ˆ y 1 , x 1 , . . . x n−1 , ˆ y. Measurement and implementation decisions x n are restricted to be F n measurable so that decisions may only depend on measurements observed in the past.We assume a Bayesian setting for the problem in which we have a prior distribution on the random vector Y .
Define μ 0 := IE [Y ] to be the mean and Σ 0 := Var [Y ] the covariance under this prior distribution.
We assume the prior is multivariate normal with independent components so that Y ∼ N (μ 0 , Σ 0 ) under IP with Σ 0 diagonal.
We will use Bayes' rule to form a sequence of posterior distributions from this prior and the successive measurements.
Define μ n := IE n [Y ] to be the mean vector and Σ n := Var n [Y ] the covariance matrix under the posterior after n measurements have been made.
Because the error terms ε n+1 are independent and normally distributed, Y will remain normally distributed with independent components, so that Y ∼ N (μ n , Σ n ) under IP conditioned on F n , with Σ n almost surely diagonal.Let us motivate this problem with an example.
Suppose we are designing software that will transfer large blocks of data across the internet, e.g. for video on demand.
The software system resides on the user's computer and the data to be transferred is mirrored at several different network locations.
When the user requests a particular block of data the software must decide from which mirror to obtain it.
Once the mirror is chosen, the path established through the network to the mirror is fixed for the duration of the transfer.
Our goal is to choose the mirror that will provide the fastest transfer.
The bandwidth to each mirror varies with network traffic intensity and cannot be forecast perfectly, but the software can estimate this bandwidth using historical data and geographic location, and can sample the current bandwidth by briefly transferring some data from the mirror before starting the full transfer.
We assume that the sample transfers must be performed sequentially to avoid measurement errors due to congestion on local network links, and the number of bandwidth measurements the software may perform is limited by a design requirement to begin the transfer without undue delay.
Our problem is to decide which mirrors the software should sample and which mirror it should choose afterward for the full transfer.
Similar problems have been investigated within the literature.
Design of experiments [1] addresses the general question of how one should make measurements.
Within this literature, algorithms from response surface methods [2] search for the maximum of some "response surface" using sequential experiments.
This work is similar to our own but differs in that it assumes a continuous domain and a convex or concave response surface, and it does not employ the Bayesian, decision theoretic approach employed here.Another area, ranking and selection, assumes as we do that the space of alternatives is discrete, and although the largest part of the ranking and selection literature focuses on non-sequential or partially sequential experimental designs [3], some investigations into fully sequential designs [5], [6] have also been made.
Ranking and selection differs from our own work, however, in that it adopts a classical rather than Bayesian approach.
It minimizes the number of measurements needed to guarantee that the probability of implementing a sub-optimal alternative is below some threshold, subject to the condition that the true values of the alternatives are not too close together.
Our desire to penalize a policy more for implementing an alternative whose true value is very far from the best true value led us to use a different objective function than that used by ranking and selection.The work within sequential design of experiments [7] adopts a Bayesian approach most similar to our own.
Within this literature, our problem is most similar to the multi-armed bandit problem [8], [9], with the main difference being that our problem has a finite horizon and is concerned with offline learning while the multi-armed bandit problem has an infinite horizon and is concerned with online learning (although see generalizations like the restless bandit [10]).
In offline learning there are distinct measurement and implementation phases, while in online learning, measurement and implementation occur simultaneously.
We discuss these important differences further in section III-C.
Applications of sequential design of experiments and multi-armed bandits to optimal learning, speed of convergence, and the issue of exploration vs. exploitation have also been discussed in the reinforcement learning [11], [16] and optimal control [12] literature.In this paper we formulate our problem as a dynamic program, and then define a knowledge gradient policy which is optimal in some special cases and computationally tractable in all cases.
We compare the knowledge gradient policy against existing policies with Monte Carlo simulation and demonstrate that the knowledge gradient policy performs as well or better than other policies across a broad class of problem settings.
We will analyze the problem using dynamic programming.
First we develop the transition function and an objective function which explicitly considers the choice of the implementation decision.
We show that the optimal implementation decision is one of pure exploitation, and once the implementation decision is fixed to the optimal one, the objective function can be simplified.
We formulate the problem as a dynamic program using this simplified objective function.
Our state space at time n is the space of all possible prior distributions for Y under IP conditioned on F n .
It can be shown by induction that all possible priors are multivariate normal, which allows us to parameterize the space by the mean vector μ n and covariance matrix Σ n .
Fix a time n.
We use Bayes' rule to update the prior, IP conditioned on F n , to reflect the observationˆyobservationˆ observationˆy n+1 = Y x + ε n+1 , obtaining a posterior which is IP conditioned on F n+1 .
Since ε n+1 is an independent normal random variable and the family of normal distributions is closed under sampling, the posterior distribution is also normal.
Thus writing our posterior distribution as a function of the prior and the observation reduces to writing μ n+1 and Σ n+1 as functions of μ n , Σ n andˆyandˆ andˆy n+1 .
Bayes' rule tells us these functions areμ n+1 = Σ n+1 񮽙 (Σ n ) −1 μ n + σ −2 ˆ y n+1 e x n 񮽙 Σ n+1 = ((Σ n ) −1 + σ −2 e x n e T x n ) −1 ,where e x is a column vector of zeros with a single 1 at index x.Since Σ 0 is assumed diagonal, it follows via induction that Σ n is diagonal for all n.
This implies that the random vector Y has independent components under the probability measure conditioned on the filtration at any time n, and it allows discarding all but the diagonal elements of Σ n from the state space.
It also simplifies the transition function toμ n+1 x = 񮽙 Σ n+1 xx 񮽙 (Σ n xx ) −1 μ n x + σ −2 ˆ y n+1 񮽙 if x n = x, μ n x otherwise,(1)Σ n+1 x = 񮽙 ((Σ n xx ) −1 + σ −2 ) −1 if x n = x, Σ n xx otherwise.
(2)Under IP conditioned on F n , ˆ y n+1 is a normal random variable with mean μ n x and variance σ 2 + Σ n xx .
Note that Σ n+1 is F n measurable rather than merely F n+1 measurable.When considered as a random variable conditioned on F n , μ n+1 is a multivariate normal random variable whose mean and variance we can compute.
First, we use the tower property of conditional expectation, and the definitions of μ n and μ n+1 as the conditional means of Y with respect to F n and F n+1 respectively, to writeIE n 񮽙 μ n+1 񮽙 = IE n [IE n+1 [Y ]] = IE n [Y ] = μ n .
Then, we compute the variance of μ n+1 componentwise.
For those alternatives x 񮽙 = x n which we do not measure at time n, our posterior is equal to our prior and μ n+1 = μ n .
This shows that Var n 񮽙 μ n+1x 񮽙 = 0 if x 񮽙 = x n .
Fixing x = x n momentarily, the variance of the component μ n+1x is computed using (1) asVar n 񮽙 μ n+1 x 񮽙 = Var n 񮽙 Σ n+1 xx 񮽙 (Σ n xx ) −1 μ n x + σ −2 ˆ y n+1 񮽙񮽙 = σ −4 (Σ n+1 xx ) 2 Var n 񮽙 Y x + ε n+1 񮽙 = σ −4 (Σ n+1 xx ) 2 񮽙 Σ n xx + σ 2 񮽙 = σ −4 񮽙 (Σ n xx ) −1 + σ −2 񮽙 −2 񮽙 Σ n xx + σ 2 񮽙 = 񮽙 σ 2 (Σ n xx ) −1 + 1 񮽙 −2 Σ n xx 񮽙 1 + σ 2 (Σ n xx ) −1 񮽙 = Σ n xx / 񮽙 1 + σ 2 (Σ n xx ) −1 񮽙 .
(3)Later, it will be more natural to parameterize the family of prior and posterior distributions by the mean and inverse variance of the distribution of Y under the current filtration, rather than by the mean and variance.
Under this transformation, our state space at time n is S := IR M × IRM + , where IR + = [0, ∞].
S is indexed by μ ∈ IR M and β ∈ IR M + , where β x = (Σ xx ) −1 .
We will often write S = (μ, β) for a generic state at any time, and S n = (μ n , β n ) for a state at time n.Using the inverse variance, and fixing x = x n , we define a functioñ σ : IR + → IR + that gives the standard deviation of μ n+1 x with respect to F n as a function of β n x .
We already calculated this quantity as a function of the variance in (3), so we simply rewrite it as a function of the inverse variance,˜ σ(b) := 񮽙 Var 񮽙 μ n+1 x | β n x = b 񮽙 = 񮽙 Var 񮽙 μ n+1 x | Σ n xx = 1/b 񮽙 = 񮽙 b −1 / (1 + bσ 2 ) = 1/ 񮽙 b(1 + bσ 2 ).
(4)We may also rewrite the state transition equations (1) and (2) in terms of the mean and inverse variance.
When we write these transformed state transition equations, we replace dependence onˆyonˆ onˆy n+1 with dependence on a standard normal random variable Z n+1 that is determined by y n+1 .
This makes the probability distribution of the state transition more apparent, and simplifies our calculations.Since μ n+1 is a normal random variable with respect to IP conditioned on F n with the parameters computed above, there exists a random variable Z n+1 that is standard normal, also with respect to IP conditioned on F n , such thatμ n+1 = μ n + ˜ σ(β n x n )Z n+1 e x n (5) β n+1 = β n + σ −2 e x n .
(6)We will also use the notation S M with S n+1 = S M (S n , x n , Z n+1 ) to denote the state transition function, or "model" equation.
This function S M is defined asS M ((μ, β), x, z) := (μ + ˜ σ(β x )ze x , β + σ −2 e x ).
(7) First we consider policies that include both measurement decisions and the single final implementation decision.
We call these "combined" policies.
Later we will specify the optimal implementation decision and restrict our focus from combined policies to measurement-only policies by specifying that, after all measurements have been made, the optimal implementation decision rule will be used.
Ultimately we will see that the optimal implementation decision is one of pure exploitation and the value of this exploitive implementation decision will determine the objective function for our measurement problem.Let the set of combined policies˜Πpolicies˜ policies˜Π be the class of policies˜π policies˜ policies˜π that specify decision functions X ˜ π,n : S n+1 → {1 . . . M} for n up to and including the terminal time N , as iñiñΠ := 񮽙˜π񮽙˜ 񮽙˜π = (X ˜ π,0 , . . . X ˜ π,N ) | X ˜ π,n : S n+1 → {1 . . . M} 񮽙 .
In this notation, x n = X ˜ π,n (S 0 , . . . S n ) under policy˜πpolicy˜ policy˜π and S n+1 is the cross-product of n+1 orthogonal state spaces, one for the state at each time from 0 up to and including n. Taking the domain of the decision function as this cross-product of state spaces allows for non-Markovian policies.Any policy˜πpolicy˜ policy˜π ∈ ˜ Π proceeds by making a measurement, receiving a measurement value, calculating the posterior distribution of Y using this measurement, making a new measurement, and repeating until all N measurements have been made.
After the final measurement, the policy˜πpolicy˜ policy˜π provides an implementation decision x N ∈ F N .
The alternative x N is chosen and the policy receives a terminal rewardˆyrewardˆ rewardˆy N +1 = Y x N + ε N +1 .
At this point we have the option of generalizing the problem by introducing a concave, increasing utility function and maximizing the expected value of the utility of the reward.
This would induce risk aversion in the optimal policy.
Instead, we simply seek to maximize over all policies the expected value of the reward itself.
Our problem can be written,sup˜π∈˜Π sup˜ sup˜π∈sup˜π∈˜ sup˜π∈˜Π IE˜πIE˜ IE˜π 񮽙ˆy񮽙ˆ 񮽙ˆy N +1 񮽙 ,(8)where the notation IE˜πIE˜ IE˜π means the expectation with the policy (8) can be rewritten asfixed tõ π.
The unbiasedness of ε N +1 implies IE˜πIE˜ IE˜π 񮽙ˆy񮽙ˆ 񮽙ˆy N +1 񮽙 = IE˜πIE˜ IE˜π 񮽙 Y x N + ε N +1 񮽙 = IE˜πIE˜ IE˜π [Y x N ], sosup˜π∈˜Π sup˜ sup˜π∈sup˜π∈˜ sup˜π∈˜Π IE˜πIE˜ IE˜π 񮽙ˆy񮽙ˆ 񮽙ˆy N +1 񮽙 = sup˜π∈˜Π sup˜ sup˜π∈sup˜π∈˜ sup˜π∈˜Π IE˜πIE˜ IE˜π [Y x N ] .
(9)Then, let us consider any combined policy˜πpolicy˜ policy˜π ∈ ˜ Π as the explicit combination of a measurement policy and an implementation decision.
Define the set of measurement policies Π as the set of policies that specify measurement decision functions X π,n : S n+1 → {1 . . . M} for 0 ≤ n < N but leave X N unspecified, as inΠ := 񮽙 π = (X π,0 , . . . X π,N −1 ) | X π,n : S n+1 → {1 . . . M} 񮽙 .
From this definition, we see that any combined policy˜πpolicy˜ policy˜π ∈ ˜ Π can be written as˜πas˜ as˜π = (π, X N ) = (X π,0 . . . X π,N −1 , X N ) for some π ∈ Π and some X N : S N +1 → {1 . . . M}.
Using this we rewrite (9) as sup˜π∈˜Π sup˜ sup˜π∈sup˜π∈˜ sup˜π∈˜ΠIE [Y x N ] = sup π∈Π sup X N IE π 񮽙 Y X N (S 0 ...S N ) 񮽙 = sup π∈Π sup X N IE π 񮽙 IE N 񮽙 Y X N (S 0 ...S N ) 񮽙񮽙 = sup π∈Π sup X N IE π 񮽙 μ N X N (S 0 ...S N ) 񮽙 , since Y x has mean μ N x given F N .
When the objective function is written in this way, we find the optimal choice for X N ,X * N (S 0 , . . . S N ) = arg max x∈{1...M } μ N x ,which constitutes a pure exploitation strategy at implementation time.
This reduces our problem to finding the optimal measurement policy π ∈ Π by solvingsup π∈Π IE π 񮽙 max x μ N x 񮽙 .
(10)Then, if we can find an optimal solution π * to the measurement problem (10), the combined policy˜πpolicy˜ policy˜π * = (π * , X N * ) is optimal for the combined problem (8).
As just shown, solving the simpler measurement-only problem (10) provides an immediate solution to the combined problem (8).
We therefore focus our effort on the measurementonly problem.
We apply a dynamic programming approach.
In this approach, the value function is defined as the value of the optimal policy given a particular state S n , and may also be determined recursively through Bellman's equation.
If the value function can be computed efficiently, the optimal policy may then also be computed from it.
Although in this problem the "curse of dimensionality" makes direct computation of the value function difficult even for M as small as 3, the dynamic programming principle still provides a valuable method for studying the problem.The terminal value function, V N : S → IR, is given by (10),V N (S N ) := max x∈{1...M } μ N x .
The dynamic programming principle tells us that the value function at any other time 0 ≤ n < N is given recursively byV n (S n ) := max x IE n 񮽙 V n+1 (S M (S n , x, Z n+1 )) 񮽙 .
We define the Q-factors, Q n : S × {1 . . . M} → IR, asQ n (S n , x) := IE n 񮽙 V n+1 (S M (S n , x, Z n+1 )) 񮽙 ,(11)and the dynamic programming principle tells us that the policy choosing its measurement decisions viaX * n (S n ) := arg max x∈{1...M } Q n (S n , x)(12)is optimal.
Finally, we define the value of a measurement policy π ∈ Π asV n,π (S n ) := IE π n 񮽙 V N (S N ) 񮽙 .
In the problem discussed so far, we supposed that the entire reward was received after the final measurement.
Instead, we may formulate an equivalent problem in which the reward is given in pieces over time.
We define the knowledge gradient policy as that policy which maximizes the single period reward under this alternate formulation.
The problem given by (10) has a terminal reward V N (S N ) := max x μ N x , but no rewards at any other times.
We restructure these rewards by writing V N (S N ) as a telescoping sequence,V N (S N ) = 񮽙 V N (S N ) − V N (S N −1 ) 񮽙 + . . . + 񮽙 V N (S n+1 ) − V N (S n ) 񮽙 + V N (S n ).
Thus the problem that provides single period reward V N (S k ) − V N (S k−1 )1 {k>n} at times k = n, n + 1, . . . N is equivalent to problem (10) because the total reward provided is the same.
The knowledge gradient policy π KG is defined as the policy that chooses its measurements to maximize the expectation of the single period reward provided under this restructured formulation.
The knowledge gradient policy has decision functionX KG,n (S n ) := arg max x∈{1...M } IE n 񮽙 V N (S M (S n , x, Z n+1 ) − V N (S n ) 񮽙 .
(13)Since V N (S n ) is measurable with respect to F n and does not depend on the quantity x which the arg max varies, the knowledge gradient policy's decision function may be rewritten asX KG,n (S n ) = arg max x∈{1...M } IE n 񮽙 V N (S M (S n , x, Z n+1 ) 񮽙 = arg max x∈{1...M } Q N −1 (S n , x).
(14)Note that the knowledge gradient policy is optimal when N = 1 by (12) and (14).
Only the decision function's argument, S n , depends on n while the decision function itself, arg max x Q N −1 (·, x), does not.
Thus the knowledge gradient policy is stationary in time, and we drop the time index n when we write X KG .
If we think of V N (S n ) as a measure of the amount of "knowledge" contained in the state S n , we see from (13) that the knowledge gradient policy chooses its decisions in the direction of steepest expected ascent of this metric.
This is the reason for the name knowledge gradient.
We can compute an analytical and computationally tractable expression for X KG .
For each x ∈ {1, . . . M} define a function ζ x : S → IR + by,ζ x (μ, β) := − 񮽙 񮽙 񮽙 񮽙 μ x − max x 񮽙 񮽙 =x μ x 񮽙˜σ 񮽙˜ 񮽙˜σ(β x ) 񮽙 񮽙 񮽙 񮽙 ,(15)and define ζ n x := ζ x (S n ).
Except for the sign, ζ n x is the variance adjusted minimum distance that a measurement of alternative x must alter μ n+1 x from its pre-measurement value of μ n x to make arg max x 񮽙 μ n+1x 񮽙 񮽙 = arg max x 񮽙 μ n x 񮽙 -that is, to make IP conditioned on F n disagree with IP conditioned on F n+1 about which alternative has the largest expected value.
Theorem:X KG (S n ) = arg max x∈{1,...M } ˜ σ(β n x ) [ζ n x Φ(ζ n x ) + ϕ(ζ n x )] ,(16)where Φ is the normal cdf and ϕ is the normal pdf.
Proof: From (14) we see that we may compute X KG (S n ) by computing the Q-factors Q N −1 (S n , x) for each action x. Using the definition of the Q-factors (11), we have for a fixed state S and a generic standard normal random variable Z,Q N −1 (S, x) := IE 񮽙 V N (S M (S, x, Z) 񮽙 = IE 񮽙 (μ x + ˜ σ(β x )Z) ∨ max x 񮽙 񮽙 =x μ x 񮽙 񮽙 .
(17)This expectation is the expectation of the maximum of a constant and a normal random variable.
Let a ∈ IR be an arbitrary constant and W ∼ N(b, c 2 ) an arbitrary normal random variable.
Then, [13] tells usIE [W ∨ a] = aΦ 񮽙 a − b c 񮽙 + bΦ 񮽙 b − a c 񮽙 + cϕ 񮽙 a − b c 񮽙 .
(18)Fix x and consider two cases.
First, consider the case that μ x > max x 񮽙 μ x 񮽙 .
This is the case in which we measure the alternative that is uniquely best according to the prior.
We rewrite (18) asIE [W ∨ a] = aΦ 񮽙 a − b c 񮽙 + b 񮽙 1 − Φ 񮽙 a − b c 񮽙񮽙 + cϕ 񮽙 a − b c 񮽙 = b + (a − b)Φ 񮽙 a − b c 񮽙 + cϕ 񮽙 a − b c 񮽙 = b + c 񮽙񮽙 a − b c 񮽙 Φ 񮽙 a − b c 񮽙 + ϕ 񮽙 a − b c 񮽙񮽙 .
In the case we are considering,μ x − max x 񮽙 񮽙 =x μ x 񮽙 is positive and (max x 񮽙 񮽙 =x −μ x )/˜ σ(β x ) = ζ x .
Compare this expression with (a − b)/c and write (17) asQ N −1 (S, x) = μ x + ˜ σ(β x ) [ζ x Φ(ζ x ) + ϕ(ζ x )] ,which can be rewritten in this case using μ x = max x 񮽙 μ x 񮽙 asQ N −1 (S, x) = max x 񮽙 μ x 񮽙 + ˜ σ(β x ) [ζ x Φ(ζ x ) + ϕ(ζ x )] .
Now consider the case that μ x ≤ max x 񮽙 μ x 񮽙 .
We rewrite (18) again using the substitution Φ(−z) = 1 − Φ(z), and also using the symmetric property of the normal pdf, ϕ(−z) = ϕ(z), asIE [W ∨ a] = a + c 񮽙񮽙 b − a c 񮽙 Φ 񮽙 b − a c 񮽙 + ϕ 񮽙 b − a c 񮽙񮽙 .
In the case we are considering, μ x − max x 񮽙 񮽙 =x μ x 񮽙 ≤ 0 and(μ x − max x 񮽙 񮽙 =x )/˜ σ(β x ) = ζ x .
Compare this expression with (b − a)/c and write (17) asQ N −1 (S, x) = max x 񮽙 񮽙 =x μ x 񮽙 + ˜ σ(β x ) [ζ x Φ(ζ x ) + ϕ(ζ x )] ,which can be rewritten in our case using maxx 񮽙 񮽙 =x μ x 񮽙 = max x 񮽙 μ x 񮽙 as Q N −1 (S, x) = max x 񮽙 μ x 񮽙 + ˜ σ(β x ) [ζ x Φ(ζ x ) + ϕ(ζ x )] .
In both cases the expression for Q N −1 (S, x) is the same, and we rewrite (14) asX KG (S n ) = arg max x∈{1,...M } max x 񮽙 μ n x 񮽙 + ˜ σ(β n x ) [ζ n x Φ(ζ n x ) + ϕ(ζ n x )] = arg max x∈{1,...M } ˜ σ(β n x ) [ζ n x Φ(ζ n x ) + ϕ(ζ n x )] ,since max x 񮽙 μ n x 񮽙 does not depend on x. Computation of the knowledge gradient policy via (16) scales linearly with the number of alternatives M .
This compares well with other offline learning policies.
To compute the knowledge gradient policy's decision at time n, we must first find the largest and second largest μ n x across all alternatives x, which will be used to compute ζ n x .
This may be implemented either by an initial pass through the alternatives at each time period, or by storing and updating the two values across time periods.
Once we have the largest and second largest μ n x , we iterate through the alternatives, calculating˜σcalculating˜ calculating˜σ(β n x ) [ζ n x Φ(ζ n x ) + ϕ(ζ n x )] for each one, and return the alternative with the largest value for this expression.
This iteration may be streamlined by recomputing the expression only for those alternatives that changed ζ n x or β n x from the previous iteration.
The knowledge gradient policy balances two considerations when it chooses its measurement decisions.
First, it prefers to measure those alternatives about which comparatively little is known.
These alternatives are the ones with large variance Σ n xx or equivalently with small inverse variance β n x .
Second, the knowledge gradient policy prefers to measure alternatives x with |μ n x − max x 񮽙 񮽙 =x μ n x 񮽙 | close to 0.
We call −|μ n x − max x 񮽙 񮽙 =x μ n x 񮽙 | the influence of alternative x. Similarly, we call ζ n x the normalized influence of alternative x because it is the influence normalized by˜σby˜ by˜σ(β n x ).
Measurements of alternatives with large influence are more likely to cause a change in the optimal implementation decision; that is, to cause arg max x 񮽙 μ n x 񮽙 񮽙 = arg max x 񮽙 μ n+1 x 񮽙 .
We can explicitly see these effects by computing derivatives of the two terms in (16).
First consider the effect of increasing the influence, or, equivalently, decreasing |μ n x − max x 񮽙 񮽙 =x μ n x 񮽙 |.
This affects only the second term, ζ n x Φ(ζ n x ) + ϕ(ζ n x ).
By (15), ζ n x increases as we decrease |μ n x − max x 񮽙 񮽙 =x μ n x 񮽙 |, and as ζ n x increases so does the entire second term because,d dz [zΦ(z) + ϕ(z)] = Φ(z) + zϕ(z) − zϕ(z) = Φ(z) ≥ 0.
Now consider the effect of decreasing β n x .
The first term, ˜ σ(β x ), increases because, from (4),d dβ n x ˜ σ(β n x ) = − 1 2 (1 + 2β n x σ 2 ) 񮽙 β n x (1 + β n x σ 2 ) 񮽙 −3/2 ≤ 0.
Also, we see from (15) that as˜σas˜ as˜σ(β n x ) increases so does ζ n x , and we just saw that as ζ n x increases so does the entire second term.Compare the classic tradeoff of exploration against exploitation with the knowledge gradient policy's tradeoff of variance against influence.
The benefits of variance are exactly the benefits of exploration.
Exploration pushes us to learn about things which we do not already know; if we already know something perfectly, there is little point in measuring it further.The parallel between the exploitation strategy and the knowledge gradient policy's desire to measure influential alternatives is more subtle.
Often, considerations of exploitation and maximizing influence agree on which measurement is best.
For example, if alternative x is neither the best nor the second best alternative at time n, that is if there are two distinct alternatives i and j such that μ n x < μ n i and μ n x < μ n j , then increasing μ n x by a small amount while holding all other parameters constant increases the influence of alternative x but does not the change the influence of any other alternative.
Thus increasing μ n x makes the knowledge gradient policy more willing to measure alternative x.
This is the same behavior advocated by the exploitation strategy.
However, if μ n x = max x 񮽙 μ n x 񮽙 , then increasing μ n x decreases the influence of all alternatives, which, depending on the relative values of the inverse variances, may make the knowledge gradient policy less likely to measure alternative x.The difference between exploitation and influence maximization stems from the different problem settings.
Exploitation is appropriate for online learning while influence maximization is appropriate for offline learning.
In online learning, a policy is given an immediate reward at each stage based on the true value of the alternative chosen.
This explicitly discourages the policy from choosing poor alternatives.
In offline learning, the only reward is at the end, so there is no explicit penalty for measuring poor alternatives.
Instead, choosing poor alternatives is discouraged by an opportunity cost.
If an alternative's estimated value is so poor that its true value is almost certainly suboptimal, then there is little value in measuring it.
If we know that we will not be implementing a particular alternative, then we already know everything we need to know about it.
Offline learning only has value if it can change the implementation decision.
It can be shown that the knowledge gradient policy is optimal in the following special cases [14].
First, the knowledge gradient policy is optimal by construction when we only have one measurement to make, i.e. when N = 1.
Second, the knowledge gradient policy is asymptotically optimal in the limit as the number of measurements N becomes arbitrarily large.
This property is due to the fact that, as N goes to infinity, the knowledge gradient policy samples every alternative infinitely often.
Third, the knowledge gradient policy is optimal when there are only two alternatives to measure, i.e. when M = 2.
Fourth, the knowledge gradient policy is optimal when the measurements are free from noise and the components of the time 0 prior are ordered by μ 01 ≥ μ 0 2 ≥ . . . μ 0 M and Σ 0 11 ≥ Σ 0 22 ≥ . . . Σ 0 MM .
A knowledge gradient policy is also optimal in other offline learning problems.
For example, the game of twenty questions may be formulated as an offline learning problem [15] in which the terminal payoff is 1 if the final guess is correct and 0 otherwise.
In this game we assume that the answers to our questions are correct (i.e. no measurement noise), and that the prior distribution over the space of objects to be guessed is uniform.
The optimal policy is bisection, in which each question eliminates half of the possible objects.
This bisection policy is also the knowledge gradient policy according to a reformulation using a telescoping sequence similar to the one we use in section III-A.
These theoretical results demonstrate that the knowledge gradient policy performs well in at least some problem settings, and they lead us to hypothesize that the knowledge gradient policy may perform well across a broader range of problem settings than just those for which optimality may be proven theoretically.
We compare the knowledge gradient policy using Monte Carlo simulation against the following policies:Interval Estimation: Interval estimation [16] chooses its measurements by computing for each x the upper bound of a symmetric confidence interval for the true value of alternative x.
It then measures the alternative with the largest upper bound according to X(S n ) = arg max x μ n x + (β n x ) −1/2 z α/2 , where z α/2 is the solution to Φ(z) = α/2.
Interval estimation is parameterized by the confidence level α, or equivalently by z α/2 .
Boltzmann Exploration: Under Boltzmann exploration, the probability of measuring an alternative x is proportional to a function of the expected value of alternative x and the current "temperature", IP n {X(S n ) = x} ∝ exp (μ n x /T n ), where the policy is parameterized by the choice of a decreasing sequence of temperatures, T = (T n ) N −1 n=0 .
Gittins Index: The Gittins index policy chooses decisions byX(S n ) = arg max x μ n x + (β n x ) −1/2 ν(0, σ 2 β n x , 1, α), where values for ν may be found in [9].
This policy is provably optimal for an online discounted infinite horizon version of our problem with discount factor α.
In the online problem, the discount factor α is specified by the objective function, but in our offline undiscounted problem α is a free parameter of the policy.
Pure Exploration: The pure exploration strategy chooses its measurement randomly among the alternatives according to a uniform distribution: IP n {X(S n ) = x} = 1/M .
Pure Exploitation: The pure exploitation strategy always chooses the alternative with the largest expected value: X(S n ) = arg max x μ n x .
Simulations were performed in which true function values were generated according to the prior, a policy was simulated, and the contribution achieved by the policy was collected.
The policy in question determined the measurement decisions, but the optimal implementation decision was always used at the final time.
Many samples were collected and averaged to estimate the value of the policy in each problem setting.
In each sample simulation, the same true function values were used to simulate each policy to reduce variance.
Sample variances were estimated for each data point and used to estimate the standard deviation of our estimate of the expected value of the policy.
These standard deviations are pictured as error bars.The space of problem settings has many dimensions: Number of measurements N ; number of alternatives M ; initial mean μ 0 ∈ IR M ; initial inverse variance β 0 ∈ IR M + ; and measurement noise σ 2 ∈ IR + .
This space is too large to allow numerical investigation of every scenario, so we restrict our investigations by focusing on the following scenarios: fixing N constant while varying M (figure 1); fixing M constant while varying N ( figure 2); and holding the ratio of N/M In the third case, the prior is nonhomogenous with μ 0 1 somewhat larger than μ 0 x and β 0 1 much larger than β 0x for x 񮽙 = 1.
This nonhomegenous prior corresponds to a case in which we have one existing alternative which has been tried often and found to perform well, and several untried alternatives of which none are expected to perform as well.Interval estimation, Boltzmann exploration, and Gittins index all have tuneable parameters.
No single parameter was best across all problem settings sampled, but a few parameter choices were consistently better than others.
For each policy with a parameter to tune, we simulated a representative set of problems with several parameter choices and chose the parameter that performed the best across this set of problems.
We subsequently used this parameter whenever simulating the policy.
We ultimately chose a constant temperature of 1 for Boltzmann exploration, a discount factor of 0.7 for the Gittins index policy, and z α/2 = 2.5 for interval estimation.
This choice of z α/2 is consistent with [16], which ran a different set of calibrating experiments and found that "the interval estimation algorithm performs best in all of these problems with a z α/2 value between 2 and 3".
Although we only picture each policy with one choice of parameter, and in some cases another parameter choice made a policy perform better in that problem setting, in no case did any policy with any choice of parameter outperform the knowledge gradient policy.In the experiment pictured in figure 1 we hold N constant at 20 while varying M from 2 to 20.
Knowledge gradient and interval estimation perform best, and identically so, followed by Boltzmann exploration and uniform exploration.
Uniform exploration performs as well as it does because in the early iterations the homogeneous prior does not distinguish between alternatives.
In later iterations, however, some alternatives do distinguish themselves as better, reducing the effectiveness of uniform exploration.
The Gittins index policy performs poorly because it places too large an emphasis on exploitation.Note that once the number of alternatives M grows larger than the number of measurements N , the values of the knowledge gradient, interval estimation, and Gittins index policies remain constant due to the homogeneous prior.
No matter how a policy distributes the N measurements, the at least N − M alternatives that remain unmeasured at implementation time will retain their initial priors.
Under the homogenous prior, these are all normal with mean 0 and variance 1 so that μ N x = 0 for all x ∈ U , where U is this set of unmeasured alternatives, and the terminal value function may be written asV N (μ N , β N ) = max x μ N x = 񮽙 max x∈U μ N x 񮽙 ∨ 񮽙 max x񮽙 ∈U μ N x 񮽙 = 0 ∨ max x񮽙 ∈U μ N x, which is distributed identically for all M > N under these policies.
The value of the Boltzmann exploration and pure exploration policies will change, however, because they will be less likely to sample an alternative twice.In the experiment pictured in figure 2 we hold M constant at 10 while varying N .
We see a similar situation to figure 1, in which the knowledge gradient policy and interval estimation perform best, followed by Boltzmann exploration, with uniform exploration again performing better than expected due to the homogeneous prior.As N grows much larger than M , all policies that do at least some exploration, including the knowledge gradient, Boltzmann exploration, and pure exploration policies but excluding pure exploitation and interval estimation, will sample every alternative often enough to obtain accurate estimates of their true values.
The value of any such policy grows toward the value of learning the value of every alternative exactly before making an implementation decision.
That is for any policy π sampling every alternative infinitely often, lim N →∞ V 0,π (μ 0 , β 0 ) = IE [max x Y x ], where Y x ∼ N (μ 0 x , (β 0 x ) −1 ).
In the experiment pictured in figure 3, we vary both N and M while holding their ratio constant.
In addition, the true value of alternative 1 is known almost exactly by the prior, and this true value is larger than the expected value under the prior of Fig. 3.
Varying both M and N with a constant ratio between them, and with a non-homegenous prior.each of the other alternatives.
This special case illustrates one important aspect of the comparison between the knowledge gradient and interval estimation policies.
The knowledge gradient policy measures every alternative infinitely often given enough measurements [14] while interval estimation may become stuck measuring one alternative repeatedly.
In this experiment, interval estimation chooses to measure alternative 1 initially because its mean under the prior is large enough to offset its low variance.
Almost no additional information is gained by this measurement because the variance of alternative 1 was so initially so low, and the posterior is nearly identical to the prior.
Thus, on subsequent measurements the interval estimation algorithm will continue measuring alternative 1, and as a result learns very little.
In contrast, the knowledge gradient policy penalizes low variance more heavily and it chooses not to measure alternative 1, measuring another alternative with larger variance instead.
Frequently, because the mean of alternative 1 is largest under the prior, the measurement reveals that the other alternative is worse than alternative 1, and nothing is gained from its measurement.
On occasion, however, the measurement reveals that another alternative has larger true value, and the knowledge gradient realizes this additional reward.
Indeed, if the prior is fixed to μ 0 = 񮽙 z α/2 , 0, . . . 0 񮽙 , β 0 = [∞, 1, . . . 1], the additional value that the knowledge gradient policy achieves over the interval estimation policy becomes arbitrarily large in the limit as both N and M become large.
We formulated an offline learning problem and defined a new type of policy for this problem, the knowledge gradient policy.
We showed how to compute the knowledge gradient policy efficiently and compared its decision making process to the classic exploration vs. exploitation tradeoff.
Using Monte Carlo simulation we compared the knowledge gradient policy to interval estimation, Boltzmann exploration, Gittins index, pure exploration and pure exploitation policies.
The knowledge gradient policy performed as well or better than these other policies in all problem situations simulated, and it should be considered for use in offline learning applications because of its ease of use and rapid learning rate.
