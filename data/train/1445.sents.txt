System administrators have utilized log analysis for decades to monitor and automate their environments.
As compute environments grow, and the scope and volume of the logs increase, it becomes more difficult to get timely, useful data and appropriate triggers for enabling automation using traditional tools like Swatch.
Cloud computing is intensifying this problem as the number of systems in datacenters increases dramatically.
To address these problems at AMD, we developed a tool we call the Variable Temporal Event Correlator, or VTEC.
VTEC has unique design features, such as inherent multi-threaded/multi-process design, a flexible and extensible programming interface, built-in job queuing, and a novel method for storing and describing temporal information about events, that well suit it for quickly and efficiently handling a broad range of event correlation tasks in real-time.
These features also enable VTEC to scale to tens of gigabytes of log data processed per day.
This paper describes the architecture, use, and efficacy of this tool, which has been in production at AMD for more than four years.
Log analysis is a critical component for effective automation of large cloud computing environments.
As clouds grow, day-to-day operational tasks such as failing hardware become an increasing burden for datacenter operational staff.
In addition, emergent behavior in large clouds causes unusual problems that often are difficult to diagnose.
These issues require more complex automation techniques in system maintenance and service operation.
Modern solutions such as SEC [1,2] and Splunk [3] have done a great job at scaling to large log volumes and making complex correlations feasible, but they have drawbacks.
This paper presents an alternative solution we developed at AMD called the Variable Temporal Event Correlator, or VTEC.AMD designed VTEC with multi-core and multisystem scalability in mind.
Virtually every component is multi-process and/or multi-threaded to take advantage of every available CPU cycle on the system.
If needed, each component can be isolated on its own machine to distribute load.
VTEC also introduces a novel method for representing temporal event data; these constructs are called temporal variables.
Temporal variables are constructed to represent temporal data about events, such as frequency and rate of change, in a way that is immediately useful when building event-correlation rules.
These rules can make use of the temporal data without the need for extra processing in the rule itself.Finally, VTEC includes a built-in job scheduler that allows for categorization, scheduling, and prioritization of actions generated in response to events.
This gives the user finer control over the sequencing and priorities of actions generated by log analysis than available before.This paper is organized as follows: Section 2 describes the computing environment and log analysis needs that drove the creation of VTEC.
Section 3 describes the internal architecture of VTEC.
Section 4 details several example "rule engines" that demonstrate how VTEC can be used to correlate various kinds of events in a computing environment.
Section 5 briefly describes some of the useful rule engines implemented at AMD.
Section 6 discusses designing for performance and scaling as log traffic increases.
Section 7 describes the challenges currently faced using VTEC, and areas for improvement.
As compute environments continue to grow in size, it becomes increasingly challenging to keep track of the various events happening in the grid.
How does a systems team note and track the failure of a hard disk or memory?
Or when one of thousands of compute nodes suffers a kernel panic?
An even more complex task is to deal with the inevitable emergent behavior of a massive network of computers.
Seemingly innocuous changes to systems (e.g., adding a simple cronjob to grid nodes), can have unexpected consequences (e.g., overloading NIS/LDAP servers).
In this large, ever-changing, and complex computing environment, many organizations (including AMD) have turned to the practice of autonomic computing [4] to reduce the effort that sysadmins must exert to keep the environment stable.
There is a system and OS configuration aspect to this, in which tools such as Cfengine [5] can enable autonomic behavior.
There is still a gap, however, when it comes to detecting anomalous or interesting events, correlating them, and taking automatic action to alert people or correct the problem.In the context of large Linux/UNIX compute grids, raw event data is generally available via syslog.
Standard syslog daemons, as well as more advanced ones such as syslog-ng [6], are able to send log data to a central server.
Thus, collecting enough raw data to analyze is rarely difficult.
However, the volume of this data is often a problem: so much data is collected that it becomes difficult to parse and extract useful information from it.During the past several years, a number of log parsing and event correlation tools have been developed.
Some Linux distributions, such as Fedora, ship with the Logwatch [8] utility installed.
Logwatch parses system log files regularly and provides useful, human-readable reports via e-mail.
When using Logwatch, however, sysadmins are required to wade through e-mails and make event correlations manually, so it does not scale beyond a handful of servers.One of the first automated log analysis tools used at AMD was Swatch [7].
Swatch is very much a reactionary log analysis system.
Events matching a particular regular expression can trigger events, such as an e-mail to an administrator.
At AMD, rudimentary flood prevention routines often caused important events to be missed while a rule was stalled waiting for a flood timer to expire.
In addition, Swatch is single-threaded, and so was unable to scale to AMD's ever-increasing log volume (about 10GB/day at a typical site).
Around 2006, as AMD's compute grids were growing at a rapid rate, the company determined the aging Swatch installation was no longer effective and chartered a project to implement a replacement log monitoring and analysis system.
The parameters for the project were:Scale to tens of gigabytes of log data per day Take advantage of multiple processors (AMD's strategy is to embrace multi-core computing) Be able to correlate events across thousands of systems in real-time (no batch processing) Be able to prioritize and queue system repair jobs and e-mail alerts Prevent floods of alerts without missing important events Correlate events on arbitrary log streams (e.g. FlexLM license daemon logs) Ensure correlation rules are easy to read, modify, and create At the time, SEC [1] and Splunk [3] were popular choices as core components to achieve the goals.
AMD tested both thoroughly, and ultimately decided a homegrown system would be best.
SEC was (and still is) a very powerful and flexible tool, but the learning curve for writing rules its rules is quite steep.
This was demonstrated by [1], which was actually supposed to "demystify" SEC.
However, even moderately complex SEC rules were deemed unintelligible by sysadmins unfamiliar with its use.Splunk did not have an indexing system robust enough to handle the volume of log traffic we expected to run through it.
After routing just a few hundred megabytes of syslog data through Splunk, the indexer would stop working properly despite several weeks of tuning with the help of Splunk's developers.
Finally, the event correlation features were limited to Swatch-like functionality (this was in 2006: Splunk v1.0).
With its seven design goals in mind, AMD created VTEC from scratch.
In the process, we evolved a novel set of data types and data handling methods that have since greatly simplified event correlation and log analysis at AMD.
The VTEC system consists of five modules (Figure 1).
Each module has a specific, well-defined task to perform, and communicates with the other modules in a well-defined language over TCP sockets.
Splitting the system into multiple components generates a number of benefits:Bugs/errors in one rule engine generally do not affect the others Multiple processes can leverage CPU capacity in multi-core systems Standard interfaces between modules simplify the task of tuning modules to optimize performance or add features Streamer -Log data enters VTEC via syslog.
The streamer component can tail log files or send arbitrary data from STDOUT of a process to VTEC.
Its most useful feature is the ability to insert "heartbeat" messages into the log stream so the absence of event data can trigger actions [10].
Use of the streamer component is optional; most systems at AMD simply route their log data directly to the syslog-ng component without going through a streamer.Syslog-ng -VTEC uses the powerful syslog-ng system logger [6] as the log router; it is the only non-Perl component.
Its purpose is to accept log streams from syslog, TCP/UDP sockets, and streamers.
It reformats messages, filters data, and routes messages to the appropriate rule engines and/or archival log files.
Control of the filtering is accomplished by including filtering metadata within each rule engine, dictating what log data that rule engine wishes to receive.
The VTEC installer then injects this metadata into the syslog-ng.
conf file, ensuring that each rule engine is tasked with parsing only the log data that is relevant to it.
The static parts of the syslog-ng.
conf file allow for searchable log archives to be created.
For example, all log messages could go to /var/log/YYYY/MM/DD/hostname-msgs.
log.Rule engines -These are composed of any executable code that accepts filtered and reformatted log data on STDIN.
In practice, these are Perl scripts, created from a template, that include reusable interface modules to both the action server and the temporal variable server (which communicate over a standard TCP protocol).
The rule engines are where the event correlation tasks occur.
Since the rule engines are open-ended editable custom scripts, a rule engine can do anything your language of choice can do.Temporal variable server -VTEC hosts all the temporal variables in a separate server daemon.
This frees the rule engines from the drudgery of maintaining state across reboots/restarts.
It also allows rule engines to share data easily, since the variable server presents a shared namespace to the rule engines; one rule engine can set a temporal variable, and another rule engine can query for it by using the same variable name.The temporal variable server can also inject special messages into the log stream when certain threshold conditions are met.
Rule engines can watch for these threshold messages and take appropriate action without being burdened with having to constantly query the state of variables.A Perl object interface to the temporal variable server is provided for use in rule engines.
Additionally, in cases in which the temporal variable server's features are more than are required, the temporal variable data types are available as Perl objects, meaning that rule engines can instantiate them locally without having to contact the temporal variable server at all.Action server -When rule engines need to take some sort of action, they have the option of running that task locally (which is not advisable, since this can block the rule engine from processing incoming data) or queuing a job in the action server.
Jobs are implemented in a Perl module as subroutines; queuing a job really means sending the name of a subroutine, its parameters, when to run it, and a queue name to the action server over a standard TCP socket interface.
A Perl object interface to the action server is provided for use in rule engines.The action server has a number of job queues with varying priorities.
Users can schedule jobs to run immediately or at a specific time (e.g., alert a sysadmin about this event, but not until 10 a.m., when they are awake).
The action server processes queues with higher priority first, allowing an emergency page to go out immediately despite a backlog of less urgent repair jobs in lowerpriority queues.The actions that can be queued on the action server are defined in a Perl module as functions.
This allows actions to be developed that can be shared by rule engines.
Since the actions are implemented in Perl, they can do virtually anything to the environment.
They can also communicate with the variable server if needed to get information about how to execute.
Some basic actions implemented on AMD's action server are:run_cmd -executes a command on a remote machine send_mail -sends an e-mail hopenclose -instructs AMD's batch scheduling system to open or close a host to jobs inject_log -injects a syslog message into the log stream (for signaling rule engines about job status)In addition to the actions themselves, an arbitrary number of queues that can be defined in the action server, with varying levels of priority.
The queues are defined in a configuration file.
In practice, only three queues are needed: crisis -when any jobs are placed in this queue, all other queues are halted until this queue is empty (good for hotpage events or status checks that are time-sensitive) normal -normal jobs, such as rebooting or reinstalling a server, or running a script email -most e-mail jobs get queued here, so that they get processed in parallel with other jobs (e.g. a run_cmd job in the normal queue won't have to wait for a flood of 500 e-mails to get sent before executing) The most interesting and novel aspect of VTEC is the temporal variable server and the temporal variables it hosts.
There are three data types in the temporal variable server: Scalar -A scalar consists of two pieces of information: a piece of scalar data (such as a string or a number) and a timeout.
The timeout is set when the scalar is created, and defines the length of time the data is valid.
When the scalar is queried, the timeout is checked.
If the current time has not exceeded the timeout, the data value is returned.
Otherwise, a zero is returned.
Scalars are useful for setting alarms, preventing e-mail floods, and storing temporary data.Incrementer -The incrementer data type builds on the scalar.
It is an organized collection of scalars, each with a data value of 1.
When an incrementer is instantiated, it is given a timeout value.
Every time the incrementer is set (called a hit in VTEC), a new scalar is added to the collection with the predetermined timeout and a data value of 1.
When queried, the incrementer returns the sum of the values of its constituent scalars.
Incrementers are useful for calculating and observing the rate of events over time.
Figure 2 demonstrates how the value of an incrementer changes over time as it is repeatedly hit by a rule engine.
When read at time=4 sec, the reported value of "4" indicates that the current rate of hits is 4 per 7 seconds, or 34.29 per minute.
List -A list is a collection of incrementers that are each referenced by a key -in short, a Perl hash of incrementer objects.
Lists have the unique property that they can be queried in three different ways:1.
The value of a particular key (the current value of that incrementer); 2.
The sum of the current values of all keys; or, 3.
The number of non-zero keys.Lists are useful because they can aggregate event rate data and organize it (e.g., by hostname), then present immediately useful data about that collection of rate data (e.g., the current number of hosts reporting an event, or the total number of those events across the entire environment).
In all of the following code examples, a substantial part of the actual Perl script has been removed for clarity.
All Perl-based VTEC rule engines have three major sections:1.
syslog-ng metadata.
This information is stored in comments at the top of the rule engine.
The VTEC installer parses this metadata and builds syslog-ng filter rules to ensure the desired log messages are passed into the rule engine.2.
Initialization code.
This is boilerplate Perl code that includes the appropriate VTEC support modules, instantiates the $variable_server and $action_server objects, and sets up any thresholds needed by the rule engine in the variable server.
This code is not shown in the examples in this paper, for brevity.
3.
Log processing.
This takes place in the while(<STDIN>) {} loop, and is generally the only part of the code that the sysadmin has to actually modify from the template.While most of a rule engine's code is boilerplate, it was decided to leave it available for modification to ensure that the rule engines would never be limited by any sort of hard-coded framework.
Plenty of comments are provided in the template to guide the rule engine author.
While most event correlation cases can be covered with a few slight modifications of the template, more complex cases might occasionally require inclusion of extra Perl modules or other initialization code that might be complicated by unnecessary abstraction of the code.In Code Example 1, the most basic type of rule engine is demonstrated; compare it to "Repeat Elimination and Compression" in [1].
The syslog-ng metadata ensures the only log data being passed into the rule engine on STDIN are messages from host amdftp, where the message portion matches the regular expression disk full error.
By performing initial filtering in syslogng before the messages even reach the rule engine, the filtering process is only done once, rather than all rule engines having to parse through all the messages looking for matches.When these messages arrive, the variable server is queried to see if a scalar by the name of ftp_disk_full is set.
If not, an outgoing e-mail is queued on the action server, and the ftp_disk_full scalar is set, with a one-hour timeout, to prevent a flood of e-mail from being sent.Notice that the job submission hash includes a start parameter.
This parameter can be set to a delay (e.g. +600 means "10 minutes from now") or to an absolute time by using localtime() to generate an epoch time.Thus with very little added effort, a non-critical alert could be queued and delivered during business hours.In Code Example 2, a more complex event correlation is demonstrated.
Following [1], this code example demonstrates the functionality in both "Report on Analysis of Event Contents" and "Detect Identical Events Occurring Across Multiple Hosts".
In this example, VTEC is configured to watch for "NFS server not responding" messages from all hosts, and will alert if the number of unique systems reporting this message for a particular file server exceeds 50 in a given five-minute period.First, notice the syslog-ng metadata is a bit more involved this time.
We are filtering three types of messages into the rule engine: server XXX not responding, server XXX OK, and threshold messages.
The threshold messages are important: when the rule engine runs the set_list_threshold method when it starts up, the variable server sets up a watch for that particular list.
In this case, we're telling it to watch two lists, filer_down and filer_up, and to send an alert if the value of a single key in either of them exceeds 50.
The rule engine can then capture that alert and take action.Following the code, as log messages flow in from STDIN, they are checked to see if they are one of the three types we are filtering for.
In the basic filer down/up case, the variable server is told to update the appropriate list variable, using the affected file server's name as the key.
The timeout for each hit is set to five minutes.
Conceptually, this means we'll have two groups of incrementers, indexed by the name of the file server.
The value of each incrementer tells us roughly how many hosts are simultaneously reporting the given state for that server (we assume each host only reports the "not responding" or "OK" message once every five or more minutes).
If the message is a threshold message, all we need to do is take action -in this case, send an e-mail about the affected filer.The important thing to grasp with this example is the relative simplicity with which this correlation was achieved, especially compared to the same example in Figure 9 of [1].
While the overall functionality is effec- # syslog-ng metadata # filter: host("amdftp") and match("disk full error");while(<STDIN>) { if($variable_server->get_scalar("ftp_disk_full") == 0) { my %job = ( start => time(), queue => "email", action => send_mail, parameters => [ $address, $subject, $msg, $name ] ); if($action_server->add(%job)) { # scalars can be set to arbitrary values (second parameter), but # always return 0 when they have timed out.
$variable_server->set_scalar("ftp_disk_full", 1, "+3600"); } } } tively the same, any sysadmin able to read basic Perl should be able to interpret, modify, and use the VTEC rule engine; the same functionality in SEC is much more difficult to grasp, even for a seasoned programmer.
# syslog-ng metadata # filter: match(".
*server.
*not responding.
*") or \ # match(".
*server.
*OK.
*") or \ # filter(f_thresholds);# Set up a threshold when we start up.
Thresholds are purged after 48 hours of inactivity.
# VTEC restarts all rule engines nightly (during log rotation) to ensure needed thresholds # are kept fresh, and retired ones are purged from the variable server.
$variable_server->set_list_threshold("ONE", "filer_down", ">", "50"); $variable_server->set_list_threshold("ONE", "filer_up", ">", "50"); With a few minor modifications, the code in Example 2 could be updated to assist in security monitoring.
If you wanted to check for usernames that are making repeated unsuccessful attempts to login to a machine (brute-force attack), a number of list variables could be created and monitored with thresholds:A list using usernames as the key, hit each time a message about an unsuccessful login attempt is seen for that username.
Using a LIST ONE threshold would alert when any given username has repeated failed logins (whether on a single host or distributed among many hosts).
A list using source IPs as the key, hit each time a message about an unsuccessful login attempt is seen for that IP.
Using a LIST KEYS threshold would alert when the number of source IPs attempting to connect in a short period of time increases beyond a threshold (e.g. a denial of service attack, or possibly a distributed brute force attack).
Using a LIST ONE threshold would alert when a given source IP is making repeated login attempts (e.g. brute force attack).
In Code Example 3, the ability to check for the absence of a log message is demonstrated.
This functionality is achieved by using an alarm, which is a function provided by the temporal variable server and is implemented using what amounts to an anonymous scalar variable with a threshold attached.Much like the previous example, the code flows in a way that an average sysadmin with some Perl experience would be able to comprehend.
We filter for three types of messages: the job start message, the job finished message, and messages generated by the variable server when thresholds/alarms are generated.If the message is a job start, the job number is fetched from the message, an alarm is set, and a pair of Perl hashes is used to create a mapping between the job number and the alarm name.
If the job finished message arrives before the alarm goes off, the alarm is cleared and no further action is taken.
If the alarm message arrives, we use the mapping to see which job is late, and send an appropriate alert.
Further, if the late job actually ends up finishing, we can detect that too by noticing there is no alarm set for that particular job.In Code Example 3, the alert portion has been shortened into a pseudo-function called queue_alert().
In a real VTEC rule engine, the rule engine author would write a function that makes a call to the action server and have it queue an e-mail (or some sort of corrective action).
With a few modifications, this code could have the rule engine comprehend multi-line log messages.
For example, ECC errors on Linux systems often appear on multiple lines: By utilizing short alarms and a rudimentary state machine in the rule engine, a robust method for capturing multi-line messages like this can be built, which will function even if the log message is incomplete or missing lines.
In fact, at AMD we have implemented just such a rule engine that aggregates machine check errors like these and injects new single-line messages into the log stream so yet another rule engine can look for systems with unusually high rates of ECC errors, and close them for repair.
In some cases it can even detect which DIMM has failed (by analyzing the syndrome codes) and add that information to the system log in the asset database.Code Example 4 demonstrates the ability to "chain" rule engines.
In this example, we have two low-level rule engines, each checking for a different kind of hardware problem on systems.
These rule engines use list variables and thresholds to take action when the rate of each type of hardware error exceeds an acceptable threshold.
The action taken in these cases is to inject a log message into the log stream that a third, "master" rule engine intercepts.
This third rule engine utilizes the key-counting functionality of lists to determine quickly how many kinds of hardware problems a given system has.
In the example, a pseudo-action "A" is taken if a system has only one type of hardware problem, while pseudo-action "B" is taken if a system has both.The net result is that a fairly daunting correlation task is reduced into its three core correlations.
These correlations are easily made individually by utilizing temporal variable constructs in the temporal variable server, making the rule engines easy to write and maintain.Note the example has been distilled to its core functionality, so is rather simplistic; the same functionality could be achieved in a single rule engine that simply parses more data.
However, consider the question of ongoing support and updates.
By separating the complex correlation into multiple rule engines, the whole system becomes far easier to maintain over time than with a single, monolithic rule engine.
What if you want to start checking for a new class of hardware failure?
Rather than modify (and potentially break) a single rule engine, a new (simple) rule engine is created that looks for this new type of failure that injects information about its findings into the log stream.
The master rule engine then only needs a minor modification (or, perhaps, none at all) to take advantage of the new data.
#### Rule engine 1: Watches for hosts with bad RAM #### # filter: match("ECC Error") or filter(f_thresholds); # list threshold will alert when the value of a key exceeds 100.
$variable_server->set_list_threshold("ONE", "ecc_errors", ">=", 100); while(<STDIN>) { my %message = parse($_); # an ECC error, hit the appropriate incrementer in the ecc_errors list if($message{message} =~ /ECC Error/) { # We use a 60-second timeout on the hit, which makes the list threshold # above alert at an ECC error rate of >= 100 per minute.
$variable_server->set_list("ecc_errors", $message{from_host}, "+60");} if($message{message} =~ /THRESHOLD EXCEEDED.
*ecc_errors.
*\[(\w+)\].
*\((\d+)\)/) {# We have found a bad host.
Generate a log message that Rule engine 3 will # pick up that indicates just how bad things are.
my ($bad_host, $count) = ($1, $2); # pseudo-function for brevity; in reality this would queue an inject_msg action # that injects a message into the log stream at the given facility and priority.
queue_alert("daemon", "info", "ALERT: $bad_host with $count ECC errors per minute"); } } #### Rule engine 2: Watches for hosts with bad DISKS #### # filter: match("EXT3 Error") or filter(f_thresholds); # list threshold will alert when the value of a key exceeds 20.
$variable_server->set_list_threshold("ONE", "ext3_errors", ">=", 20); while(<STDIN>) { my %message = parse($_); # an EXT3 error, hit the appropriate incrementer in the ext3_errors list if($message{message} =~ /EXT3 Error/) { # We use a 3600-second timeout on the hit, which makes the list threshold # above alert at an EXT3 error rate of >= 20 per hour.
$variable_server->set_list("ext3_errors", $message{from_host}, "+3600"); } if($message{message} =~ /THRESHOLD EXCEEDED.
*ext3_errors.
*\[(\w+)\].
*\((\d+)\)/) { # We have found a bad host.
Generate a log message that Rule engine 3 will # pick up that indicates just how bad things are.
my ($bad_host, $count) = ($1, $2); # pseudo-function for brevity; in reality this would queue an inject_msg action # that injects a message into the log stream at the given facility and priority.
queue_alert("daemon", "info", "ALERT: $bad_host with $count EXT3 errors per hour"); } } #### Rule engine 3: Watches for hosts with bad hardware #### # filter: facility(daemon) and priority(info) and match("ALERT:"); while(<STDIN>) { my %message = parse($_); if($message{message} =~ /ALERT: (\w+) with (\d+) (EXT3|ECC) errors per (minute|hour)/) { my ($bad_host, $count, $type, $base) = ($1, $2, $3, $4); # Use a list variable to keep track of the various types of problems a system has.
$variable_server->set_list("multi_problem_$bad_host", $type, "+3600"); # If the system has only one thing wrong with it, we take action A, but if there are # two things wrong with it we take action B. if($variable_server->get_list_keys("multi_problem_$bad_host") >= 2) { queue_action("B"); } elsif($variable_server->get_list_keys("multi_problem_$bad_host") >= 1) { queue_action("A"); } } } This ability to chain rule engines means that extraordinarily complex correlations can be achieved by reducing them to their constituent parts, then chaining rule engines together to track progress through the correlation.
Combine this functionality with the fact that rule engines can share temporal variable information through the variable server, and you have an extremely flexible and powerful system for correlating events and taking appropriate actions that is much easier to create, modify, and troubleshoot than other event correlation tools.
Since VTEC has been in production at AMD for more than four years, we have amassed a significant number of rule engines that perform useful event correlation and self-healing tasks in our computing environment.
One of the earliest uses for VTEC at AMD was to look for systems with bad hardware.
We found most healthy systems would occasionally report ECC and EXT3 errors, but systems with truly bad hardware would send these errors at a noticeably higher rate.
We implemented a rule engine that checks for these messages (the ECC error check uses a chained rule engine that aggregates the multi-line machine check errors that the Linux kernel reports) and then closes bad machines to new compute jobs.
Systems in such bad shape that they are streaming error messages into the logs exceed an "emergency" threshold and a signal is sent to immediately power down the affected machine.
As summarized and simplified in Code Example 2, we have a rule engine that monitors client systems for "NFS server not responding" messages and alerts the storage and networking teams when the rate of messages exceeds a certain threshold.
We have all of our servers at AMD configured to send a syslog message when they have finished booting up.
A VTEC rule engine watches for these messages and alerts operational staff if a machine is rebooting more than five times in a 90-minute period.
These reboot loops can indicate a multi-bit ECC error, kernel panic, or other system configuration problem that requires the attention of a sysadmin.
At AMD we have several interactive login servers that are used by our design engineers as gateways into remote datacenters.
Some engineers, instead of using our batch scheduling system, will run their jobs directly on the interactive login server, causing performance problems and occasionally even crashing the systems.
We have implemented a cronjob that checks for processes that violate our interactive server usage policy, that sends out syslog messages when it detects a process that violates policy.
A VTEC rule engine collects these messages, collates them, and generates a daily report for each engineer that is violating the policy with a summary of all of their processes at each site that are in violation of the policy.
Additionally, the whole list of users and processes is sent in a daily digest to our interactive server support team, which can determine if it is appropriate to forcibly kill ill-behaved processes.
A common problem in AMD's compute grids is out-ofmemory conditions.
Leaky jobs, or jobs that simply need more memory than is installed on the machine, will cause the system to run out of memory; the kernel then invokes the out-of-memory killer (OOM killer).
The syslog message that the OOM killer generates has very little useful data: just a PID and a process name.
To identify the owner of the job that caused the OOM condition, we run a cron job every five minutes on our systems that caches the contents of /proc/<pid>/stat into a directory under /var/spool.
When a rule engine sees the OOM killer event, it queues a job ten minutes into the future (to give the server time to recover from the OOM condition) that logs into the machine and fetches the /var/spool/proc/<pid>/stat file that was referenced by the OOM killer message.
This file tells us not only who was running the errant job, but also how large it was when it was killed.
This information is used to craft an e-mail alert to the user asking them to check the status of their batch job submissions to prevent more problems on other compute nodes.
When bringing new systems online in our compute grid, it is important to stress-test them before allowing engineer's jobs on them.
We accomplish this at AMD by using a rule engine that watches for syslog messages indicating that a system has completed its automated installation sequence.
It then closes the machine to the batch submission system, kicks off the stress test, and sets an alarm for 12 hours in the future.
If the alarm goes off, the stress test must have locked up the system; an operational staff member is alerted to check the system.
If the stress test completes (notifying of its status via syslog, of course) the system is either opened for jobs (test was successful) or is left closed (test failed).
Sometimes a machine will be so thoroughly broken that it is impossible to shut down the machine, and it just sits there spewing error messages into the syslog stream.
This can hamper the VTEC server not only because it can cause it to run out of disk space, but also because it forces syslog-ng to process a flood of irrelevant data.
We have implemented a rule engine that watches for hosts sending an excessive volume of log data to the system, and automatically updates the syslog-ng.
conf file with a filter that drops all of the messages from that host for 24 hours.
Once the 24-hour alarm expires, the filter is removed; if the system is still spewing messages, it will be re-ignored within a few minutes, preventing the log flood from adversely affecting performance or data space on the VTEC server.
The performance characteristics of VTEC can be best described by analyzing the potential bottlenecks of each component, since the slowest single component will likely represent the limiting factor for the overall system.
However, due to the multi-core design of VTEC, even if one of the components (usually the variable server) maxes out a CPU, the other components can continue functioning without any degradation on other CPUs.
Methods for tuning the performance of syslog-ng are fairly sparsely documented in the reference manual [9].
In the context of VTEC, we are most concerned with the performance of the filtering functions, especially since syslog-ng is a single-threaded process.
If syslogng spends too much time on the CPU trying to parse through log filters, it could begin dropping log messages.We have found after much experimentation that syslogng's match() filter function is much slower than the other message filtering functions.
When rule engines are configured with nothing but a match() rule, the syslog-ng process spends all of its time on the CPU, even with a fairly modest (1-2GB/day) rate of traffic.
Simply adding one of the "fast" functions in addition to the match() function returns performance to acceptable levels, presumably by short-circuiting the match() function in many irrelevant cases.In general, this means that a filter rule like this:match(".
*some message.
*")can be written better as: facility("daemon") and priority("info") and match(".
*some message.
*")to get acceptable performance from syslog-ng.
A typical VTEC server at AMD runs on a four-vCPU virtual machine with 2.9GHz AMD Opteron TM processors under the hypervisor.
The syslog-ng instance filters data into 21 rule engines and four local disk logs.
The incoming data rate is about 1,000 messages/sec and 10GB/day.
With that level of load, the syslog-ng process consumes about 30% of one CPU core, with occasional spikes to above 50% of one CPU core.
As demonstrated in the examples, the temporal variable server is a critical part of the speed path as log messages route their way through the system.
Since virtually every log message that makes its way to a rule engine results in at least one (and many times multiple) requests to the variable server, it is important that it be able to respond quickly.The variable server is implemented using Perl threads.
This allows for simple sharing of the internal database of temporal variables (a hash for each data type).
Six threads run in parallel, using a collection of locks to ensure atomic write access to the internal data structures:A server thread that listens for connections (and spawns threads that handle those connections) A backup thread that wakes up every ten seconds and backs up the internal state to disk Three monitoring threads that wake up every 60 seconds to purge stale data from the internal data structures A thresholds thread that wakes up every 60 seconds to scan for variables that have exceeded thresholds.The persistent threads do not pose any real performance issues; they wake up infrequently, and spend only a few milliseconds to complete their duties before going back to sleep.The threads that get spawned to service incoming requests are the potential bottleneck.
Testing has revealed that for basic requests (e.g. fetch the value of a scalar), performance scales very well.
However, as the data structures being queried get more complex (e.g. fetch the value of an incrementer that has 1,000 active scalars in it), performance begins to degrade.
Figure 3 shows the transactional performance of the variable server as the size of an incrementer being queried grows in size.The routine that calculates the value of an incrementer is O(n) with the number of active scalars it contains.An updated routine that is O(log n) is being tested and shows promising results, but requires significant code changes and so has not been deployed into production yet.
Obviously the rule engines, since they can have arbitrary code in them, can be a bottleneck.
But the idea behind VTEC is for the rule engines to take advantage of the action server, precisely so they don't have to block for long-running tasks.
If the rule engines are coded such that they do not block, they do not represent a bottleneck.
As flexible and effective as VTEC currently is, there is always room for improvement.
We currently face two issues with VTEC.
As described in Section 6, the variable server is the major bottleneck.
Since virtually all rule engines depend on incrementers and lists (which are collections of incrementers), the fact that the incrementer data type scales so poorly is a significant hindrance.
However, there is new code in the works for the incrementer that should greatly improve its scalability and performance.
The action server is currently a "fire and forget" system.
When jobs are queued, the rule engine can get a job ID for tracking, but there is currently nothing useful that can be done with it.
There is no way to query the status of job, or to collect the output of a job, from within a rule engine.
Jobs have the option to use logger or some other means to inject syslog messages and "phone home" to their parent rule engine, but this process is awkward and is not used in practice.A major improvement in this area would be to have the action server cache job status information and output for some period of time after the job completes, so rule engines can query for it.
Having the action server automatically inject messages into the log stream when jobs complete would also help, because it would give rule engines a trigger to work with to keep up with the jobs they've queued.
AMD has used VTEC since 2006 to monitor and automate maintenance activities on its large compute grids.
Log volumes range up to 10 GB/day with VTEC running smoothly on modest two-to four-core virtual and physical machines.
VTEC tracks hardware problems such as disk, CPU, and RAM failures and takes appropriate actions (e.g., shut down/close the broken system and create a ticket).
VTEC can monitor the environment for trends that indicate events (e.g., n systems are unable to contact m NFS filers, so there must be a network problem).
Most importantly, VTEC enables autonomic computing by allowing intelligent dispatch of repair jobs in response to detected problems.
If these repair jobs fail to work, VTEC can notify humans to take over.In summary, VTEC is a powerful tool for automating log analysis and event correlation.
While there are many other tools that perform similar tasks, VTEC's approach to the problem presents a complete, scalable, and intuitive solution that is able to grow and adjust to virtually any workload.
Paul Krizak is currently a member of the technical staff at AMD and has been a professional systems engineer for more than seven years.
His duties at AMD have generally surrounded infrastructure support of the large engineering research and development grids, most commonly in support of the autonomic Linux OS provisioning and configuration infrastructure.
He graduated with a bachelor's degree in computer science from Texas A&M University in 2005.
