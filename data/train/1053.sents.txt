Recent research efforts to design better Internet transport protocols combined with scalable Active Queue Management (AQM) have led to significant advances in congestion control.
One of the hottest topics in this area is the design of discrete congestion control algorithms that are asymptot-ically stable under heterogeneous feedback delay and whose control equations do not explicitly depend on the RTTs of end-flows.
In this paper, we show that max-min fair congestion control methods with a stable symmetric Jacobian remain stable under arbitrary feedback delay (including heterogeneous directional delays) and that the stability condition of such methods does not involve any of the delays.
To demonstrate the practicality of the obtained result, we change the original controller in Kelly's work [14] to become robust under random feedback delay and fixed constants of the control equation.
We call the resulting framework Max-min Kelly Control (M K C) and show that it offers smooth sending rate, exponential convergence to efficiency, and fast convergence to fairness, all of which make it appealing for future high-speed networks.
Over the last fifteen years, Internet congestion control has evolved from binary-feedback methods of AIMD/TCP [2], [29] to the more exciting developments based on optimization theory [22], [23], game theory [10], [18], and control theory [9], [10], [24], [25].
It is widely recognized that TCP's congestion control in its current shape is inadequate for very high-speed networks and fluctuation-sensitive real-time multimedia.
Thus, a significant research effort is currently under way (e.g., [5], [6], [8], [11], [14], [15], [18], [27]) to better understand the desirable properties of congestion control and develop new algorithms that can be deployed in future AQM (Active Queue Management) networks.One of the most important factors in the design of congestion control is its asymptotic stability, which is the capacity of the protocol to avoid oscillations in the steady-state and properly respond to external perturbations caused by the arrival/departure of flows, variation in feedback, and other transient effects.
Stability proofs for distributed congestion control become progressively more complicated as feedback delays are taken into account, which is especially true for the case of heterogeneous delays where each user i receives its network feedback delayed by a random amount of time Di.
Many existing papers (e.g., [4], [9], [10], [11], [16], [17], [18], [23]) model all users with homogeneous delay Di = D and do not take into account the fact that end-users in real networks are rarely (if ever) synchronized.
Several recent studies [19], [24], [26] successfully deal with heterogeneous delays; however, they model Di as a deterministic metric and require that end-flows (and sometimes routers) dynamically adapt their equations based on feedback delays, which leads to RTT-unfairness, increased overhead, and other sideeffects (such as probabilistic stability).
In this paper, we set our goal to build a discrete congestion control system that maintains both stability and fairness under heterogeneously delayed feedback, allows users to use fixed parameters of the control equation, and admits a low-overhead implementation inside routers.
We solve this problem by showing that any max-min fair system with a stable symmetric Jacobian remains asymptotically stable under arbitrary directional delays and apply this result to the original controller proposed by Kelly et al. [14].
We call the result of these efforts Max-min Kelly Control ( M K C ) and demonstrate that its stability and fairness do not depend on any parameters of the network (such as delay, path length, or the routing matrix of end-users).
We also show that with a proper choice of AQM feedback, M K C converges to efficiency exponentially fast, exhibits stability and fairness under random delays, converges to fairness almost as quickly as AIMD, and does not require routers to estimate any parameters of individual flows.By isolating bottlenecks along each path and responding only to the most-congested resource, the M K C framework allows for very simple stability proofs, which we hope will lead to a better understanding of Kelly's framework in the systems community and eventually result in an actual implementation of these methods in real networks.
Our initial thrust in this direction includes ns2 simulations of M K C , which show that finite time-averaging of flow rates inside each router coupled with a naive implementation of end-user functions leads to undesirable transient oscillations, which become more pronounced when directional delays D → i and D ← i to/from each router increase.
We overcome this drawback with simple changes at each end-user and confirm that the theoretically predicted monotonic convergence of M K C is achievable in real networks, even when the routers do not know the exact combined rate of end-flows at any time instant n.
We also show that our algorithms inside the router incur low overhead (which is less than that in XCP [11] or RED [7]) and require only one addition per arriving packet and two variables per router queue.The rest of this paper is organized as follows.
In Section 2, we review related work.
In Section 3, we study delayed stability and steady-state resource allocation of the classic Kelly controls.
In Section 4, we present M K C and prove its delay-independent stability.
In Section 5, we evaluate convergence properties and packet loss of M K C .
In Section 6, we implement M K C in ns2 and simulate its performance under heterogeneous delays.
In Section 7, we conclude our work and suggest directions for future research.
A large amount of theoretical and experimental work is being conducted to design stable congestion controls for high-speed networks.
Such examples include FAST TCP [8], HSTCP [5], Scalable TCP [15], BIC-TCP [28], and XCP [11], all of which aim to achieve quick convergence to efficiency, stable rate trajectories, fair bandwidth sharing, and low packet loss.
An entirely different direction in congestion control is to model the network from an optimization or game-theoretic point of view [10], [16], [17], [18], [23].
The original work by Kelly et al. [13], [14] offers an economic interpretation of the resource-user model, in which the entire system achieves its optimal performance by maximizing the individual utility of each end-user.
To implement this model in a decentralized network, Kelly et al. describe two algorithms (primal and dual ) and prove their global stability in the absence of feedback delay.
However, if feedback delay is present in the control loop, stability analysis of Kelly controls is non-trivial and currently forms an active research area [4], [9], [19], [24], [26], [27].
Recall that in Kelly's framework [14], [24], each user i ∈ [1, N ] is given a unique route ri that consists of one or more network resources (routers).
Feedback delays in the network are heterogeneous and directional.
The forward and backward delays between user i and resource j are denoted by D → ij and D ← ij , respectively.
Thus, the round-trip delay of user i is the summation of its forward and backward delays with respect to any router j ∈ ri:Di = D → ij + D ← ij .
Under this framework, Johari et al. discretize Kelly's primal algorithm as follows [9]:xi(n) = xi(n−1)+κi ωi −xi(n−Di) ¡ j∈r i µj(n−D ← ij )¢, (1)where κi is a strictly positive gain parameter, ωi can be interpreted as the willingness of user i to pay the price for using the network, and µj(n) is the congestion indication function of resource j:µj(n) = pj ¡ u∈s j xu(n − D → uj )¢,(2)where sj denotes the set of users sharing resource j and pj(·) is the price charged by resource j. Note that we use a notation in which Di = 1 means immediate (i.e., most recent) feedback and Di ≥ 2 implies delayed feedback.
Next, recall that for a homogeneous delay D, system (1)-(2) is locally stable if [9]:κi ¡ j∈r i (pj + p j ¡ u∈s j xu) £ £ £ x * u ¢ < 2 sin ¤ π 2(2D − 1) ¥ , (3)where x * u is the stationary point of user u and pj(·) is assumed to be differentiable at x * u .
For heterogeneous delays, a combination of conjectures made by Johari et al. [9], derivations in Massoulié [24], and the proofs of Vinnicombe [26] suggest that delay D in (3) can be simply replaced with individual delays Di to form a system of N stability equations; however, the proof exists only for the continuous version of (1) and leads to the following necessary stability equation [26]:κi ¡ j∈r i (pj + p j ¡ u∈s j xu) £ £ £ x * u ¢ < π 2Di .
(4)We should also note that Ying et al. [30] recently established delay-independent stability conditions for a family of utility functions and a generalized controller (1).
Their work is similar in spirit to ours; however, the analysis and proposed methods are different.
In this section, we first discuss intuitive examples that explain the cryptic formulas in the previous section and demonstrate in simulation how delays affect stability of Kelly controls (1)-(2).
We then show that Kelly's proportional fairness [14], or any mechanism that relies on the sum of feedback functions from individual routers, always exhibits linear convergence to efficiency.
Note that due to limited space, we omit certain proofs and refer the reader to the technical report [31] for more information.
The following example illustrates stability problems of (1) when feedback delays are large.
We assume a single-source, single-link configuration and utilize a standard congestion indication function, which computes the estimated packet loss using instantaneous arrival rates:p(n) = x(n) − C x(n) ,(5)where C is the link capacity and x(n) is the flow rate at discrete step n.
We remark that under AQM feedback assumed throughout the paper, we allow negative packet loss in (5), which signals the flows to increase their sending rates when x(n) < C.
In section 5.1, we show that the negative component of packet-loss (5) improves convergence to efficiency from linear to exponential.
Applying (5) to Kelly control (1) yields a linear end-flow equation:x(n) = x(n − 1) + κω − κ ¦ x (n − D) − C § .
(6)Next, assume a particular set of parameters: κ = 1/2, ω = 10 mb/s, and C = 1, 000 mb/s.
Solving the condition in (3), we have that the system is stable if and only if delay D is less than four time units.
As illustrated in Figure 1(a), delay D = 1 keeps the system stable and monotonically convergent to its stationary point.
Under larger delays D = 2 and D = 3 in Figures 1(b) and (c), the flow exhibits progressively increasing oscillations before entering the steady state.
Eventually, as soon as D becomes equal to four time units, the system diverges as shown in Figure 1(d).
Using the same parameter κ and reducing ω to 20 kb/s, we examine (6) via ns2 simulations, in which a single flow passes through a link of capacity 50 mb/s.
We run the flow in two network configurations with the round-trip delay equal to 90 ms and 120 ms, respectively.
As seen in Figure 2, the first flow reaches its steady state after decaying oscillations, while the second flow exhibits no convergence and periodically overshoots capacity C by 200%.
Since Kelly controls are unstable unless condition (3) is satisfied [9], a natural strategy to maintain stability is for each end-user i to adaptively adjusts its gain parameter κi ∼ 1/Di such that (3) is not violated.
However, this method depends on reliable estimation of round-trip delays Di and leads to unfairness between the flows with different RTTs.
In this section, we examine how packet-loss function (5) affects the resource allocation of Kelly's proportional fairness (1).
Consider a network of M resources and N ho- mogeneous users (i.e., with the same parameters κ and ω).
Further assume that resource j has capacity Cj, user i utilizes route ri of length Mi (i.e., Mi = |ri|), and packet-loss ηi(n) fed back to user i is the aggregate feedback from all resources in path ri.
We further assume that there is no redundancy in the network (i.e., each user sends its packets through at least one resource and all resources are utilized by at least one user).
Thus, we can define utilization matrix AN×M such that Aij = 1 if user i passes through resource j (i.e., j ∈ ri) and Aij = 0 otherwise.
Further denote the j-th column of A by vector Vj.
Clearly, Vj identifies the set sj of flows passing through router j.Letxj(n) = x1(n − D → 1j ), x2(n − D → 2j ), · · · , xN (n − D → N j )be the vector of sending rates of individual users observed at router j at time instant n.
In the spirit of (5), the packet loss of resource j at instant n can be expressed as:pj(n) = xj(n) · Vj − Cj xj(n) · Vj ,(7)where the dot operator represents vector multiplication.
Accordingly, the end-to-end feedback ηi(n) of user i is:ηi(n) = ¡ j∈r i pj(n − D ← ij ),(8)and the control equation assumes the following shape:xi(n) = xi(n − 1) + κi ωi − xi(n − Di)ηi(n)¢.
(9)Then, we have the following result.Lemma 1.
Let x * = x * 1 , x * 2 , · · · , x *N be the stationary rate allocation of Kelly control (9) with packet-loss function (7)-(8).
Then x * satisfies:N ¡ i=1 Mix * i = M ¡ j=1 Cj + N ω.
(10)Lemma 1 provides a connection between the stationary resource allocation and the path length of each flow.
Note that according to (10), the stationary rates x * i are constrained by the capacity of all resources instead of by that of individual bottlenecks.
In fact, this observation shows an important difference between the real network paths, which are limited by the slowest resource, and the model of proportional fairness, which takes into account the capacity of all resources in the network.
This difference leads to severe under/over-utilization of individual routers as illustrated in the following simulation.
Figure 3(a) shows the topology of the simulation, in which there are two flows, x1 and x2, and four resources, C1-C4.
Notice that resource C2 = 20 mb/s is the bottleneck of x1 and C4 = 15 mb/s is the bottleneck of x2.
The path lengths of the two flows are, respectively, M1 = 2 and M2 = 3.
Setting ω = 5 mb/s and κ = 0.1, let x * 1 , x * 2 be the stationary rate allocation of the system, which according to (10) must satisfy:2x * 1 + 3x * 2 = 4 ¡ j=1 Ci + 2 × 5 = 95.
(11)Simulation results for this setup are depicted in Figure 3(b).
As seen in the figure, the steady-state rate assignment is 23.436, 16.042 mb/s, which indeed satisfies prediction (11); however, notice that the combined stationary rate of both flows is 39.5 mb/s, which exceeds C2 by 97%.
As a result, the users overshoot network capacity in the steady state and persistently suffer from significant packet loss.This problem is easy to understand.
Observe that uncongested routers C1 and C3 encourage end-flows to increase their rates through negative feedback, while congested resources C2 and C4 signal the opposite and encourage the flows to reduce their rates.
Combining this conflicting feedback into summation (8), each user settles in some middle ground that keeps neither their slowest, nor their fastest resources in ri fully "satisfied."
Even for a network with a single flow, (11) shows that the stationary rate of the flow is simply the average capacity of all resources on its path:x * = (¨ M j=1 Cj + ω)/M .
For the example in Figure 3, x1 would converge to 27.5 mb/s, which is well in excess of its bottleneck capacity C2.In general, for proportional fairness (8) and similar methods that rely on the combined pricing function of all resources to remain viable, no price should be charged at routers that are not suffering any packet loss.
Under these circumstances, notice in (1) that the flows increase their rates by κiωi at each discrete time-step before they reach full link utilization at the slowest router.
This results in linear AIMD-like probing for new bandwidth, which is generally considered "too slow" for high-speed networks.In the next section, we overcome both drawbacks of controller (1) (i.e., instability under delay and undesirable link utilization) by abandoning proportional fairness and focusing on its max-min counterpart.
In this section, we propose a new version of discrete Kelly controls, which allows negative packet-loss feedback and maintains stability under heterogeneous delays.
We start our discussion with the following observations.
First, we notice that in the classic Kelly control (1), the enduser decides its current rate xi(n) based on the most recent rate xi(n − 1) and delayed feedback µj(n − D ← ij ).
Since the latter carries information about xi(n − Di), which was in effect RTT time units earlier, the controller in (1) has no reason to involve xi(n − 1) in its control loop.
Thus, the sender quickly becomes unstable as the discrepancy between xi(n − 1) and xi(n − Di) increases.
One natural remedy to this problem is to retard the reference rate to become xi(n − Di) instead of xi(n − 1) and allow the feedback to accurately reflect network conditions with respect to the first term of (1).
Second, to avoid unfairness 1 between flows, one must fix the control parameters of all end-users and establish a uniform set of equations that govern the system.
Thus, we create a new notation in which κiωi = α, κi = β and discretize the Kelly control as following:xi(n) = xi(n − Di) + α − βηi(n)xi(n − Di),(12)where ηi(n) is the congestion indication function of user i. Next, to overcome the problems of proportional fairness demonstrated in the previous section and utilize negative network feedback, we combine (12) with max-min fairness (this idea is not new [11]), under which the routers only feed back the packet loss of the most-congested resource instead of the combined packet loss (8):ηi(n) = max j∈r i pj(n − D ← ij ),(13)where pj(·) is the congestion indication function of individual routers that depends only on the aggregate arrival rates of end-users:pj(n) = pj ¡ u∈s j xu(n − D → uj )¢.
(14)We call the resulting controller (12)-(14) Max-min Kelly Control ( M K C ) and emphasize that the flows congested by the same bottleneck receive the same feedback and behave independently of the flows congested by the other links.
Therefore, in the rest of this paper, we study the singlebottleneck case since each M K C flow is always congested by only one router.
Implementation details of how routers should feed back function (13) and how end-flows track the changes in the most-congested resource are presented in the simulation section.
Before restricting our analysis to M K C , we examine a wide class of delayed control systems, whose stability directly follows from that of the corresponding undelayed systems.
We subsequently show that M K C belongs to this category and obtain a very simple proof of its stability.
First consider the following theorem.
Theorem 1.
Assume an undelayed linear system L with N flows:xi(n) = N ¡ j=1 aijxj(n − 1).
(15)If coefficient matrix A = (aij) is real-valued and symmetric, then system LD with arbitrary directional delays:xi(n) = N ¡ j=1 aijxj(n − D → j − D ← i ),(16)is asymptotically stable if and only if L is stable.Proof.
We first show the sufficient condition.
Assume that L is asymptotically stable.
Applying the z-transform to system (16), we obtain:H(z) = Z1AZ2H(z),(17)whereZ1 = diag(z −D ← i ) and Z2 = diag(z −D → i )are the diagonal matrices of directional delays, and H(z) is the vector of z-transforms of each flow rate xi:H(z) = © H1(z), H2(z), · · · , HN (z) T .
(18)Notice that linear system (16) is stable if and only if all poles of its z-transform H(z) are within the unit circle in the z-plane [12].
To examine this condition, re-organize the terms in (17):(Z1AZ2 − I) H(z) = 0.
(19)Next notice that the poles of H(z) are simply the roots of:det(Z1AZ2 − I) = 0.
(20)Thus, ensuring that all roots of (20) are inside the unit circle will be both sufficient and necessary for LD to be stable.
Rewriting (20):det(Z1AZ2 − I) = det(Z1[A − Z −1 1 IZ −1 2 ]Z2) (21) = det(Z1)det(A − Z −1 1 Z −1 2 )det(Z2).
Since det(Z1) and det(Z2) are strictly non-zero for nontrivial z, (20) reduces to:det(A − Z −1 1 Z −1 2 ) = det ¦ A + B(z) § = 0,(22)whereB(z) = −Z −1 1 · Z −1 2 = −diag(z D i )is the diagonal matrix of round-trip delays.
Thus, it remains to examine whether the roots of (22) are inside the unit circle.To bound the roots of (22), we first need the following theorem from [20].
Theorem 2 (Li-Mathias [20]).
Given N -dimensional square matrices Q1 and Q2, whose singular values are α1 ≥ α2 ≥ · · · ≥ αN and β1 ≥ β2 ≥ · · · ≥ βN , respectively, the following holds:|det(Q1 + Q2)| ≥ 0 if [αN , α1] ∩ [βN , β1] 񮽙 = ∅ £ £ £ N j=1 (αj − βN−j+1) £ £ £ otherwise .
(23)We next apply the lower bounds given in the above theorem to (22).
Recall that singular values of a square matrix X are the non-negative square roots of the eigenvalues of the product of X and its adjoint (or equivalently, conjugate transpose) matrix X * [1].
In (22) both matrices A and B(z) are symmetric and real-valued, which means that their singular values are the absolute values of their eigenvalues.
Let {λi} be the eigenvalues of A.
Then the singular values of A are {αi|αi = |λi|}.
Similarly, we get that the singular values of a diagonal matrix B(z) are {βi|βi = |z D i |}.
Without loss of generality, we assume that {αi} and {βi} are ordered by their magnitude, i.e., α1 ≥ α2 ≥ · · · ≥ αN and β1 ≥ β2 ≥ · · · ≥ βN .
Let z0 be a root of (22).
Then there are two possibilities:1) The intervals defined by {αi} and {βi} intersect, i.e.,[αN , α1] ∩ [βN , β1] 񮽙 = ∅.
This means that there must exist at least one singular value βj such that βj ∈ [αN , α1].
According to the assumption that undelayed system L in (15) is stable, each eigenvalue λi of matrix A must satisfy |λi| = αi < 1, which leads to 0 ≤ βj < 1.
This translates into |z D j 0 | < 1, for some j, and directly leads to |z0| < 1 since all delays Dj are discrete and no less than 1.2) The two segments do not overlap, i.e., [αN , α1] (22) and (23), we have:∩[βN , β1] = ∅.
Then, combining|det ¦ A + B(z0) §| = 0 ≥ £ £ £ N j=1 (αj − βN−j+1) £ £ £ ,(24)which implies that the product in (24) must equal zero:£ £ £ N j=1 (αj − βN−j+1) £ £ £ = 0.
(25)This means that there exists an index k (1 ≤ k ≤ N ) such that α k − β N −k+1 = 0, which contradicts the assumption that intervals [αN , α1] and [βN , β1] are disjoint.Repeating steps 1) and 2) for all roots {zi} of (22), we obtain that they all must lie within the unit circle, which leads to the asymptotic stability of LD in (16).
Since L is a special case of LD (i.e., all delays are 1 time unit), stability of the latter implies that of the former and leads to the necessary condition of the theorem.Theorem 1 opens an avenue for inferring stability of delayed linear systems based on the coefficient matrices of the corresponding undelayed systems.
Moreover, it is easy to see that Theorem 1 applies to nonlinear systems as stated in the following corollary.
Corollary 1.
Assume an undelayed N -dimensional nonlinear system N :xi(n) = fi ¦ x 1(n − 1), x2(n − 1), · · · , xN (n − 1) §,(26)where {fi|fi : R N → R} is the set of nonlinear functions defining the system.
If the Jacobian matrix J of this system is symmetric and real-valued, system ND with arbitrary delay:xi(n) = fi ¦ x 1(n − D → 1 − D ← i ), x2(n − D → 2 − D ← i ), · · · , xN (n − D → N − D ← i ) § (27)is locally asymptotically stable in the stationary point x * if and only if N is stable in x * .
Based on the above principles, we next prove local stability of M K C under heterogeneous feedback delays.
We first consider an M K C system with a generic feedback function ηi(n) in the form of (13), which we assume is differentiable in the stationary point and has the same first-order partial derivative for all end-users.
Our goal is to derive sufficient and necessary conditions for the stability of (12)- (13) under arbitrarily delayed feedback.We approach this problem by partitioning all users into non-overlapping sets based on their corresponding bottleneck routers.
We assume that each set of users S is fairly stable and that the bottlenecks do not change for the duration of this analysis.
Suppose that S contains users {x1, . . . , xN } and that the corresponding delays to/from their bottleneck router are given by D → i and D ← i .
Then, we can simplify (12)- (13) by dropping index j of the bottleneck resource and expanding ηi(n) in (12):xi(n) = xi(n − Di) + α − βp(n − D ← i )xi(n − Di),(28)wherep(n) = p N ¡ u=1 xu(n − D → u )¢(29)is the packet-loss function of the bottleneck router for set S. Notice that xi(n − Di) in (28) can be represented asxi(n−D → i −D ← i )and that controller (28)- (29) has the same shape as that in (27).
To invoke Theorem 1, our first step is to show stability of the following undelayed version of (28)- (29):xi(n) = ¦ 1 − βp(n − 1) §xi(n − 1) + α p(n) = p ¨ N u=1 xu(n)¢ .
(30)Theorem 3.
Undelayed N -dimensional system (30) with feedback p(n) that is common to all users has a symmetric Jacobian and is locally asymptotically stable if and only if:0 < βp * < 2,(31)0 < βp * + βN x * ∂p ∂xi £ £ £ £ x * < 2,(32)where x * is the fixed point of each individual user, vector x * = x * , x * , · · · , x * is the fixed point of the entire system, and p * is the steady-state packet loss.Proof.
We first derive the stationary point x * of each individual user.
Since all end-users receive the same feedback and activate the same response to it, all flows share the bottleneck resource fairly in the steady state, i.e., xi(n) = x * for all i. Using simple manipulations in (30), we get the stationary individual rate x * as following:x * = α βp * .
(33)Linearizing the system in x * :∂fi ∂xi £ £ £ £ x * = ¤ 1 − βp − βxi ∂p ∂xi ¥ £ £ £ £ x * ,(34)∂fi ∂x k £ £ £ £ x * = ¤ −βxi ∂p ∂x k ¥ £ £ £ £ x * , k 񮽙 = i,(35)where fi(x) = (1 − βp(x))xi + α.
Since packet loss depends on the aggregate rate of all users, p(n) has the same first partial derivative evaluated in the fixed point for all users, which implies that for any users i and k, we have:∂p ∂xi £ £ £ £ x * = ∂p ∂x k £ £ £ £ x * .
(36)This observation leads to a simple Jacobian matrix for M K C :J = a b · · · b b a · · · b . . . . . . . . . . . .
b b · · · a !
!
! "
,(37)where:a = 1 − βp * − βx * ∂p ∂xi £ £ £ £ x * , b = −βx * ∂p ∂xi £ £ £ £ x * .
(38)Clearly Jacobian matrix J is circulant 2 and thus its k-th eigenvalue λ k is given by [1]:λ k = a + b(ζ k + ζ 2 k + ζ 3 k + · · · + ζ N −1 k ),(39)where ζ k = e i2πk/N (k = 0, 1, . . . , N − 1) is one of the N -th roots of unity.
We only consider the case of N ≥ 2, otherwise the only eigenvalue is simply a. Then, it is not difficult to get the following result:λ k = a + (N − 1)b ζ k = 1 a + b ζ k − ζ N k 1 − ζ k = a − b ζ k 񮽙 = 1 ,(40)where the last transition holds since ζ N k = 1 for all k. Next, recall that nonlinear system (30) is locally stable if and only if all eigenvalues of its Jacobian matrix J are within the unit circle [12].
Therefore, we get the following necessary and sufficient local stability conditions:|a − b| < 1 |a + (N − 1)b| < 1 .
(41)To ensure that each λi lies in the unit circle, we examine the two conditions in (41) separately.
First, notice that |a − b| = |1 − βp * |, which immediately leads to the following:0 < βp * < 2.
(42)Applying the same substitution to the second inequality in (41), we obtain:0 < βp * + βN x * ∂p ∂xi £ £ £ £ x * < 2.
(43)Thus, system (30) is locally stable if and only if both (42) and (43) are satisfied.According to the proof of Theorem 3, Jacobian J of the undelayed system (30) is real-valued and symmetric.
Combining this property with Corollary 1, we obtain the following result.Corollary 2.
Heterogeneously delayed M K C (28)- (29) is locally asymptotically stable if and only if (31)-(32) are satisfied.Corollary 2 is a generic result that is applicable to M K C (12) with a wide class of congestion-indicator functions ηi(n).
Further note that for a given bottleneck resource with pricing function p(n) and its set of users S, conditions (31)-(32) are easy to verify and do not depend on feedback delays, the number of hops in each path, or the routing matrix of all users.
This is in contrast to many current studies [9], [24], [26], [27], whose results are dependent on individual feedback delays Di and the topology of the network.
To understand the practical implications of the derivations above, consider a particular packet-loss function p(n) in (29):p(n) = ¨ N u=1 xu(n − D → u ) − C ¨ N u=1 xu(n − D → u ) ,(44)where we again assume a set S of N users congested by a common router of capacity C.
This is a rather standard packet-loss function with the exception that we allow it to become negative when the link is under-utilized.
As we show in the next section, (44) achieves exponential convergence to efficiency, which explains why we call the combination of (28),(44) Exponential M K C (E M K C ).
Theorem 4.
Heterogeneously delayed E M K C (28),(44) is locally asymptotically stable if and only if 0 < β < 2.
Proof.
We first derive the fixed point of E M K C .
Notice that in the proof of Theorem 3, we established the existence of a unique stationary point x * i = x * for each flow.
Then assuming E M K C packet-loss function (44), we have:p * = N x * − C N x * .
(45)Combining (45) and (33), we get the stationary point x * of each end-user:x * = C N + α β .
(46)Denoting by X(n) = ¨ N i=1 xi(n) the combined rate of all N end-users at time n, the corresponding combined stationary rate X * is:X * = N x * = C + N α β .
(47)Next, recall from Theorem 3 that stability conditions (31)-(32) must hold for the delayed system to be stable.
Consequently, we substitute pricing function (44) into (32) and obtain with the help of (47):βp * + βN x * ∂p(n) ∂x(n) £ £ £ £ x * = βp * + βN x * C N 2 x * 2 = β.
(48)Thus, condition (32) becomes:0 < β < 2.
(49)Notice that in the steady state, packet loss probability p * is no larger than one.
Thus, condition (49) is more conservative than (31), which allows us to conclude that when (28), (44) is also locally asymptotically stable if and only if 0 < β < 2.
To better understand the implication of this result, consider an illustration in Figure 4, in which two E M K C flows (α = 200 mb/s and β = 0.5) share a bottleneck link of capacity 10 gb/s.
Recall that for the same setup (β = 0.5), Kelly controls are unstable for any delay D ≥ 4 time units (see Figure 1).
In both cases shown in Figure 4, E M K C flows approach full link utilization without oscillations and eventually share the resource fairly.
These simulation results support our earlier conclusion that M K C is a stable and fair controller under random delays, which is a requirement for any practical method in the current Internet.
In this section, we show that E M K C converges to efficiency exponentially fast.Lemma 2.
For 0 < β < 2 and constant delay D, the combined rate X(n) of E M K C is globally asymptotically stable and converges to X * = C + N α/β at an exponential rate.Proof.
Since delays do not affect stability of E M K C , assume a constant feedback delay D and re-write (28):xi(n) = (1 − βp(n − D))xi(n − D) + α,(50)where p(n) is the undelayed version of (44).
Taking the summation of (50) for all N flows, we get that E M K C 's combined rate X(n) = ¨ N i=1 xi(n) forms a linear system:X(n) = ¤ 1 − β X(n − D) − C X(n − D) ¥ X(n − D) + N α = (1 − β)X(n − D) + βC + N α.
(51)It is clear that the above linear system is stable if and only if 0 < β < 2.
Since convergence of linear systems implies global asymptotic stability, we conclude that X(n) is globally stable regardless of individual flow trajectories xi(n).
We next show the convergence speed of X(n).
Recursively expanding the last equation, we have:X(n) = (1 − β) n D (X0 − X * ) + X * ,(52)where X0 is the initial combined rate of all flows and X * = C + N α/β is the combined stationary rate.
Notice that for 0 < β < 2, the first term in (52) approaches zero exponentially fast and X(n) indeed converges to X * .
This result is illustrated in Figure 5(a) for β = 0.5 and α = 10 kb/s, where E M K C saturates a 1 gb/s link in only 16 steps.
In Figure 5(b), we show the convergence rate of Scalable TCP [15], which is a recent method proposed for high-speed networks.
Although Scalable TCP also claims bandwidth exponentially fast, its increase rate 1.01 n is much slower than that of E M K C .
This is illustrated in the figure where it takes Scalable TCP approximately 1,200 steps to reach full link capacity from the same initial rate.Additionally notice how the value of β affects the behavior of E M K C .
For 0 < β ≤ 1, the system monotonically converges to the stationary point; however, for 1 < β < 2, the system experiences decaying oscillations before reaching the stationary point, which are caused by the oscillating term (1 − β) n/D in (52).
This phenomenon is illustrated in Figure 6 for two values of β.
Thus, in practical settings, β should be chosen in the interval (0,1], where values closer to 1 result in faster convergence to efficiency.
We next investigate the convergence rate of E M K C to fairness.
To better understand how many steps E M K C requires to reach a certain level of max-min fairness, we utilize a simple metric that we call ε-fairness.
For a given small positive constant ε, a rate allocation x1, x2, · · · , xN is ε-fair, if:f = min N i=1 xi max N j=1 xj ≥ 1 − ε.
(53)Generally speaking, ε-fairness assesses max-min fairness by measuring the worst-case ratio between the rates of any pair of flows.
Given the definition in (53), we have the following result.
Theorem 5.
Consider an E M K C network with N users and a bottleneck link of capacity C. Assuming that the system is started in the maximally unfair state, ε-fairness is reached in θM steps, where:θM = (C + N α β ) ¦ l og N − log ε § N α + Θ N α C ¢ .
(54)A comparison of model (54) to simulation results is shown in Figure 7(a) (note that in the figure, the model is drawn as a solid line and simulation results are plotted as isolated triangles).
In this example, we use a bottleneck link of capacity C = 1 mb/s shared by two E M K C flows, which are initially separated by the maximum distance, i.e., x1(0) = 0, x2(0) = C.
As seen from the figure, the number of steps predicted by (54) agrees with simulation results for a wide range of ε.As noted in the previous section, parameter β is responsible for the convergence speed to efficiency; however, as seen in (54), it has little effect on the convergence rate to fairness (since typically N α C).
In contrast, parameter α has no effect on convergence to efficiency in (52), but instead determines the convergence rate to fairness in the denominator of (54).
Also observe the following interesting fact about (54) and the suitability of E M K C for high-speed networks.
As C increases, the behavior of θM changes depending on whether N remains fixed or not.
For a constant N , (54) scales linearly with C; however, if the network provider increases the number of flows as a function of C and keeps N = Θ(C), ε-fairness is reached in Θ(log C) steps.
This implies exponential convergence to fairness and very good scaling properties of E M K C in future high-speed networks.
Both types of convergence are demonstrated in Figure 7(b) for constant N = 2 and variable N = C/500 (for the latter case, C is taken to be in kb/s).
As the figure shows, both linear and logarithmic models obtained from (54) match simulations well.We next compare E M K C 's convergence speed to that of rate-based AIMD.
Recall that rate-based AIMD(α, β) adjusts its sending rate according to the following rules assuming α > 0 and 0 < β < 1: Theorem 6.
Under the assumptions of Theorem 5, ratebased AIMD reaches ε-fairness in θA steps, where:x(t) = x(t − RT T ) + α per RTT (1 − β)x(t − RT T ) per loss .
(55)θA = (C + N α β ) ¦ l og N − log ε § −N α log(1 − β)/β + Θ N α C ¢ .
(56)Figure 8(a) verifies that model (56) is also very accurate for a range of different ε.
Notice from (54) and (56) that the speed of convergence to fairness between AIMD and E M K C differs by a certain constant coefficient.
The following corollary formalizes this observation.Corollary 3.
For the same parameters N , α, β such that N α C, AIMD reaches ε-fairness θM /θA = − log(1 − β)/β times faster than E M K C .
For TCP and β = 0.5, this difference is by a factor of 2 log 2 ≈ 1.39, which holds regardless of whether N is fixed or not as demonstrated in Figure 8(b).
We should finally note that as term Θ(N α/C) becomes large, M K C 's performance improves and converges to that of AIMD.
As seen in previous sections, E M K C converges to the combined stationary point X * = C + N α/β, which is above capacity C.
This leads to constant (albeit usually small) packet loss in the steady state.
However, the advantage of this framework is that E M K C does not oscillate or react to individual packet losses, but instead adjusts its rate in response to a gradual increase in p(n).
Thus, a small amount of FEC can provide a smooth channel to fluctuationsensitive applications such as video telephony and various types of real-time streaming.
Besides being a stable framework, E M K C is also expected to work well in wireless networks where congestion-unrelated losses will not cause sudden reductions in the rates of end-flows.
Also notice that E M K C 's steady-state packet loss p * = N α/(Cβ + N α) increases linearly with the number of competing flows, which causes problems in scalability to a large number of flows.
However, it still outperforms AIMD, whose increase in packet loss is quadratic as a function of N [21].
Furthermore, if the network provider keeps N = Θ(C), E M K C achieves constant packet loss in addition to exponential convergence to fairness.
Finally, observe that if the router is able to count the number of flows, zero packet loss can be obtained by adding a constant ∆ = N α/(βC) to the congestion indication function [3].
However, this method is impractical, since it needs non-scalable estimation of the number of flows N inside each router.
Hence, it is desirable for the router to adaptively tune p(n) so that the system is free from packet loss.
One such method is AVQ (Adaptive Virtual Queue) proposed in [16], [19].
We leave the analysis of this approach under heterogeneous delays and further improvements of E M K C for future work.
We next examine how to implement scalable AQM functions inside routers to provide proper feedback to M K C flows.
This is a non-trivial design issue since the ideal packet loss in (44) relies on the sum of instantaneous rates xi(n), which are never known to the router.
In such cases, a common approach is to approximate model (44) with some timeaverage function computed inside the router.
However, as mentioned in the introduction, this does not directly lead to an oscillation-free framework since directional delays of real networks introduce various inconsistencies in the feedback loop and mislead the router to produce incorrect estimates ofX(n) = ¨ i xi(n).
In what follows in this section, we provide a detailed description of various AQM implementation issues and simulate E M K C in ns2 under heterogeneous feedback delays.
As shown in Figure 9, the M K C packet header consists of two parts -a 16-byte router header and a 4-byte user header.
The router header encapsulates information that is necessary for the router to generate precise AQM feedback and subsequently for the end-user to adjust its sending rate.
The rid field is a unique label that identifies the router that generated the feedback (e.g., its IP address).
This field is used by the flows to detect changes in bottlenecks, in which case they wait for an extra RTT before responding to congestion signals of the new router.
The seq field is a local variable incremented by the router each time it produces a new value of packet loss p (see below for more).
Finally, the ∆ field carries the length of the averaging interval used by the router in its computation of feedback.
Router header : router ID (4) : router sequence number (4) 񮽙 : packet loss (4) 񮽙 : interval length (4) User header The user header is necessary for the end-flows to determine the rate xi(n − Di) that was in effect RTT time units earlier.
The simplest way to implement this functionality is to inject the value of xi(n) into each outgoing packet and then ask the receiver to return this field in its acknowledgments.
A slightly more sophisticated usage of this field is discussed later in this section.
where C is the capacity of the outgoing link known to the router (these functions are performed on a per-queue basis).
After computing˜pcomputing˜ computing˜p, the router increments its packet-loss sequence number (i.e., seq = seq + 1) and resets variable S to zero.
Newly computed values seq and˜pand˜ and˜p are then inserted into qualified packets arriving during the next interval ∆ and are subsequently fed back by the receiver to the sender.
The latter adjusts its sending rate as we discuss in the next section.
M K C employs the primal algorithm (12)- (13) at the endusers who adjust their sending rates based on the packet loss generated by the most congested resources of their paths.
However, to properly implement M K C , we need to address the following issues.First, notice that ACKs carrying feedback information continuously arrive at the end-user and for the most part contain duplicate feedback (assuming ∆ is sufficiently large).
To prevent the user from responding to redundant or sometimes obsolete feedback caused by reordering, each packet carries a sequence number seq, which is modified by the bottleneck router and is echoed by the receiver to the sender.
At the same time, each end-user i maintains a local variable seqi, which records the largest value of seq observed by the user so far.
Thus, for each incoming ACK with sequence seq, the user responds to it if and only if seq > seqi.
This allows M K C senders to pace their control actions such that their rate adjustments and the router's feedback occur on the same timescale.Second, recall from (12)-(13) that M K C requires both the delayed feedback ηi(n) and the delayed reference rate xi(n− Di) when deciding the next sending rate.
Thus, the next problem to address is how to correctly implement the control equation (12).
We develop two strategies for this problem below.
One straightforward option is to directly follow (12) based on the rate that was in effect exactly Di time units earlier.
Since round-trip delays fluctuate, the most reliable way to determine xi(n − Di) is to carry this information in the usr field of each packet (see Figure 9).
When the receiver echoes the router field to the sender, it also copies the user field into the acknowledgment.
We show the performance of this strategy via ns2 simulations in Figure 10(a), in which a single M K C flow passes through a bottleneck link of capacity 10 mb/s.
We set α to 100 kb/s, β to 0.9, packet size to 200 bytes, and router sampling interval ∆ to 50 ms. As seen from Figure 10(a), the sending rate converges to its stationary point in less than 2 seconds and does not exhibit oscillations in the steady state; however, the flow exhibits transient oscillations and overshoots C by over 200% in the first quarter of a second.
Although this transient behavior does not affect stability of the system, it is greatly undesirable from the practical standpoint.
To remove the transient oscillations, we first need to understand how they are created.
Notice from (57)-(58) that since the router calculates the packet loss based on the average incoming rate over interval ∆, it is possible that packets of different sending rates xi(n1) and xi(n2) arrive to the router during the same interval ∆.
Denote by Ti(n) the time when user i receives the n-th non-duplicate feedback p(n).
Since the user responds to each feedback only once, it computes new sending rates xi(n) at time instances Ti(n).
To better understand the dynamics of a typical AQM control loop, consider the illustration in Figure 10(b).
In the figure, the router generates feedback p(n − 1) and p(n) exactly ∆ units apart.
This feedback is randomly delayed by D ← i time units and arrives to the user at instances Ti(n − 1) and Ti(n), respectively.
In response to the first feedback, the user changes its rate from xi(n−2) to xi(n−1); however, the router observes the second rate only at time Ti(n − 1) + D → i .
At the end of the n-th interval ∆, the router averages both rates xi(n − 2) and xi(n − 1) to produce its feedback p(n) as shown in the figure.When the control loop is completed, the user is misled to believe that feedback p(n) refers to a single rate x(n−1) and is forced to incorrectly compute x(n).
This inconsistency is especially pronounced in the first few control steps during which the flows increase their rates exponentially and the amount of error between the actual rate and the reference rate is large.Instead of changing the router, we modify the end-users to become more sophisticated in their processing of network feedback.
The key is to allow end-users to accurately estimate their own contribution tõ X and determine their average rates seen by the router during interval ∆.
For each outgoing packet k, M K C sender i places the packet's sequence number k in the usr field and records in local memory the size of the packet si(k) and its sequence number k. Upon arrival of the n-th non-duplicate feedback at time Ti(n), the end-flow extracts the usr field from the acknowledgment and records its value in variable zi(n), which is the sequence number of the packet that generated feedback p(n).
To compute the new rate xi(n), the user calculates the amount of data that it has transmitted between packets zi(n − 1) and zi(n) − 1 and normalizes the sum by ∆, which is exactly the average rate used by the router in generation of p(n).
To visualize this description, consider Figure 11(a), in which the end-flow is about to decide its sending rate xi(n) at time Ti(n).
Notice in the figure that feedback p(n) is based on all packets of flow i with sequence numbers between zi(n − 1) and zi(n) − 1.
Through the use of zi(n), we obtain a projection of the time-interval used by the router in its computation of p(n) onto the sequence-number axis of the end user.
4 Given the above discussion, the user computes its average rate as:¯ xi(n) = 1 ∆ z i (n)−1 ¡ k=z i (n−1) si(k),(59)and utilizes it in its control equation:xi(n) = ¯ xi(n) + α − βηi(n)¯ xi(n).
(60)Next, we turn our attention to the ns2 simulation in Fig- ure 11(b) and examine the performance of this strategy with a single flow.
The figure shows that (59)-(60) successfully eliminates transient oscillations and offers fast, monotonic convergence to the steady state.
Our next example shows the performance of the new method (59)-(60) with multiple flows.
The simulation topology of this example is illustrated in Figure 12(a): four E M K C flows identical to that in Figure 10(a) share the same bottleneck link of capacity 10 mb/s.
The round trip delays of the four flows are 50 ms, 60 ms, 70 ms, and 80 ms, respectively, and the sampling intervals ∆ of routers C1-C5 are 120 ms, 140 ms, 160 ms, 180 ms, and 100 ms, respectively.
At time 0, the first flow starts at 125 kb/s and monotonically converges to bottleneck capacity in less than 0.4 seconds as seen in Figure 12(b).
Five seconds later, the second flow joins at initial rate 150 kb/s.
The figure shows that the system is immediately re-stabilized in the new stationary point and the individual flows quickly converge to fairness without oscillations.
This behavior is repeated when the other two flows join the network and the system regains stability and fairness with ideal performance (i.e., monotonically).
This paper investigated the properties of Internet congestion controls under non-negligible directional feedback delays.
We focused on the class of control methods with symmetric Jacobians and showed that all such systems are stable under heterogeneous delays.
To construct a practical congestion control system with a symmetric Jacobian, we made two changes to the classic discrete Kelly control and created a max-min version we call M K C .
Combining the latter with a negative packet-loss feedback, we developed a new controller E M K C and showed in theory and simulations that it offers smooth sending rate and fast convergence to efficiency.
Furthermore, we demonstrated that E M K C 's convergence rate to fairness is exponential when the network provider scales the number of flows N as Θ(C) and linear otherwise.
From the implementation standpoint, E M K C places very little burden on routers, requires only two local variables per queue and one addition per arriving packet, and allows for an easy implementation both in end-to-end environments and under AQM support.
Our future work involves improvement of the convergence speed to fairness and design of pricing schemes for E M K C to achieve loss-free performance regardless of the number of flows N .
rRecall that M K C decouples the operations of users and routers, allowing for a scalable decentralized implementation.
The major task of the router is to generate its AQM feedback and insert it in the headers of all passing packets.
However, notice that the router never knows the exact combined rate of incoming flows.
Thus, to approximate the ideal computation of packet loss, the router conducts its calculation of p(n) on a discrete time scale of ∆ time units.
For each packet arriving within the current interval ∆, the router inserts in the packet header the feedback information computed during the previous interval ∆.
As a consequence, the feedback is retarded by ∆ time units inside the router in addition to any backward directional delays D ← i .
Since M K C is robust to feedback delay, this extra ∆ time units does not affect stability of the system.
We provide more implementation details below.During interval ∆, the router keeps a local variable S, which tracks the total amount of data that has arrived into the queue (counting any dropped packets as well) since the beginning of the interval.
Specifically, for each incoming packet k from flow i, the router increments S by the size of the packet: S = S + si(k).
In addition, the router examines whether its locally recorded estimate˜pestimate˜ estimate˜p of packet loss (which was calculated in the previous interval ∆) is larger than the one carried in the packet.
If so, the router overrides the corresponding entries in the packet and places its own router ID, packet loss, and sequence number into the header.
In this manner, after traversing the whole path, each packet records information from the most congested link.
3 At the end of interval ∆, the router approximates the combined arriving rateby averaging S over time ∆:Based on this information, the router computes an estimate of packet loss p(n) as following: Recall that M K C decouples the operations of users and routers, allowing for a scalable decentralized implementation.
The major task of the router is to generate its AQM feedback and insert it in the headers of all passing packets.
However, notice that the router never knows the exact combined rate of incoming flows.
Thus, to approximate the ideal computation of packet loss, the router conducts its calculation of p(n) on a discrete time scale of ∆ time units.
For each packet arriving within the current interval ∆, the router inserts in the packet header the feedback information computed during the previous interval ∆.
As a consequence, the feedback is retarded by ∆ time units inside the router in addition to any backward directional delays D ← i .
Since M K C is robust to feedback delay, this extra ∆ time units does not affect stability of the system.
We provide more implementation details below.During interval ∆, the router keeps a local variable S, which tracks the total amount of data that has arrived into the queue (counting any dropped packets as well) since the beginning of the interval.
Specifically, for each incoming packet k from flow i, the router increments S by the size of the packet: S = S + si(k).
In addition, the router examines whether its locally recorded estimate˜pestimate˜ estimate˜p of packet loss (which was calculated in the previous interval ∆) is larger than the one carried in the packet.
If so, the router overrides the corresponding entries in the packet and places its own router ID, packet loss, and sequence number into the header.
In this manner, after traversing the whole path, each packet records information from the most congested link.
3 At the end of interval ∆, the router approximates the combined arriving rateby averaging S over time ∆:Based on this information, the router computes an estimate of packet loss p(n) as following:
