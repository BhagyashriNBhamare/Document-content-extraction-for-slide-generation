A policy describes the conditions under which an action is permitted or forbidden.
We show that a fragment of (multi-sorted) first-order logic can be used to represent and reason about policies.
Because we use first-order logic, policies have a clear syntax and semantics.
We show that further restricting the fragment results in a language that is still quite expressive yet is also tractable.
More precisely, questions about entailment, such as 'May Alice access the file?'
, can be answered in time that is a low-order polynomial (indeed, almost linear in some cases), as can questions about the consistency of policy sets.
We also give a brief overview of a prototype that we have built whose reasoning engine is based on the logic and whose interface is designed for non-logicians, allowing them to enter both policies and background information, such as 'Alice is a student', and to ask questions about the policies.
A policy describes the conditions under which an action, such as reading a file, is permitted or forbidden.
Digital content providers have a rough idea of what their policies should be.
Unfortunately, policies are typically described informally.
As a result, their meaning and consequences are not always clear.To better understand the problem, consider the statement 'only librarians may edit the on-line catalog'.
We can view this statement as a policy, because it governs who may edit the catalog, based on whether or not the editor is a librarian.
It is not clear if this policy permits librarians to make changes to the catalog or only forbids anyone who is not a librarian from doing so.
The policy could be rewritten ¡ Authors supported in part by NSF under grant CTC-0208535, by ONR under grants N00014-00-1-03-41 and N00014-01-10-511, by the DoD Multidisciplinary University Research Initiative (MURI) program administered by the ONR under grant N00014-01-1-0795, and by AFOSR under grant F49620-02-1-0101.
to remove this particular ambiguity, but others are likely to exist if policies are written in a natural language.
Policy languages such as the Extensible rights Markup Language (XrML) [10] and Open Digital Rights Language (ODRL) [21] have the potential to be more formal (partly because their syntax is more restricted).
Currently, however, the only semantics for these languages seems to be an English description of what the syntax means; thus, they also suffer from significant ambiguity.
Our goal in this paper is to provide a logic with a clear syntax and semantics that can be used to represent and reason about policies.
In addition, we want the logic to be well-suited to the needs of digital content providers.
To achieve our objectives, we use a fragment of first-order logic.
This automatically gives us a clear syntax and semantics; thus, it remains to argue that the logic is well-suited to the needs of digital content providers.To be of practical use, a logic must satisfy (at least) the following three desiderata.1.
It must be expressive enough to capture in an easy and natural way the policies that people want to discuss.2.
It must be tractable enough to allow interesting queries about policies to be answered efficiently.3.
It must be usable by non-logicians, because we cannot expect policy makers and administrators to be wellversed in logic.Of course, whether a logic is sufficiently expressive to meet our first objective depends very much on the application.
To evaluate our approach, we gathered a large collection of policies from various libraries, including on-line collections, local and university libraries, the Library of Congress, and Cornell's Digital Library Research Group.
We have written these policies in our language.
In addition, we have begun to encode government policies in our language, including those that determine a person's eligibility for Social Security.
Finally, we have created a translation from most of the XrML Core and all of the XrML Content Extension to our language.
Details of the translation and a more complete discussion of the collected policies are given in a companion paper [19].
For the second desideratum, we focus on two key queries: ¢ Given a set of policies and an environment that provides all relevant facts (e.g., 'Alice is a librarian', 'Anyone who is a librarian for less than a year is a novice', etc.), does it follow that a particular action, such as Alice editing the on-line catalog, is permitted or forbidden?
¢ Is a set of policies consistent?
In other words, are there no actions that are both permitted and forbidden by the policies in the set?
This question is particularly interesting for collaboration.
For example, suppose that Alice is writing the policies for her university's new outreach program.
If the union of her policies and the university policies is consistent, then she knows that her policies do not contradict those of the university.The answers to these questions could be used by enforcement mechanisms and individuals who want to do regulated activities.
More importantly, we believe that the answers provide a reasonably good understanding of the policies, increasing our confidence that the formal statements capture the informal rules and the informal rules capture the policy creator's intent.To address our third goal, the usability requirement, we developed, and are currently refining and extending, a prototype that allows users to enter policies, as well as facts about their environment, and to ask questions about them.
This software will be tested by University of Virginia librarians as part of the Mellon-Fedora project [32] to verify that the language can be used by people who have not been trained in logic.There have been a number of attempts to give formal semantics to policies, some of which involve first-order logic.
Most of the first-order approaches are based on some variant of Datalog [16].
By beginning with Datalog, these solutions start with a language that is tractable, but not sufficiently expressive.
They then extend the language to better meet the needs of applications.
In particular, they find extensions that permit a limited use of negation and functions.
The restrictions that we make are quite different from those made previously.
We believe (and will argue throughout this paper) that the resulting language is especially well-suited for many applications, and has a number of advantages over variants of Datalog.The rest of this paper is organized as follows.
In the next section, we formally define our notions of a policy and an environment.
We also give examples that illustrate how policies can be represented in an appropriate fragment of first-order logic.
In Section 3 we show that, in general, the questions we want to ask about policies are hard to answer.In Section 4 we present some restrictions under which these questions are tractable.
We give a brief overview of the prototype that we are building in Section 5.
We discuss the Datalog approaches, as well as other related work, in Section 6.
The paper concludes in Section 7 with plans for future research.
Detailed proofs are left to the full paper.
For the rest of the paper, we assume knowledge of manysorted first-order logic at the level of Enderton [14].
More specifically, we assume the reader is familiar with the syntax of first-order logic, including constants, variables, predicate symbols, function symbols, and quantification, with the semantics of first-order logic, including relational models and valuations, and with the notions of satisfiability and validity of first-order formulas.We use many-sorted first-order logic with equality over some vocabulary .
In practice, it may be useful to add additional arguments to Permitted, such as when the action is permitted and who is authorizing the granting or revoking of the permission.
We have not included these here to simplify the exposition; including them would not change our results.
The constant now denotes the current time.
In practice, a global clock would determine the interpretation of now.A policy is a closed first-order formula of the form Permitted indicates that the Permitted predicate may or may not be negated.
Defining the policy in this way provides a structure that matches our intuition, namely, that a policy is a set of conditions under which an action is or is not permitted.P ) Q S R U T F T 8 T G P ) Q W V © Y X a ` b © Y c Permitted© 1 D F E G DH I ETo illustrate how policies can be expressed in first-order logic, consider the following examples.
To determine the consequences of a policy, we need to know what facts are true in the context in which the policies are applied.
For example, to decide if the policies in Example 2.1 permit Alice to edit the catalog, we must know if Alice is a librarian.
In other words, we must know if the statement Librarian(Alice) is true.
This fact, along with all the others that are needed to analyze a set of policies, are contained in the environment.
The environment may include very simple statements such as 'The Cat in the Hat is a children's book' or 'Sally has a junior library card'.
More complex statements may also be included, such as the conditions under which a customer is considered to be in good standing and 'at all times, there is a senior staff member who is on call'.
All the examples we have considered so far confirm our belief that first-order logic is sufficiently expressive to capture most environments that are likely to arise in practice.
Thus, we formally define an environment to be a closed first-order formula that does not contain the Permitted predicate.
The requirement that the environment not contain Permitted encourages the intuitive separation between the environment, which is a description of reality, and the policies, which are the rules governing that reality.The two types of queries discussed in the introduction can now be formalized.
is quantifier-free [7].
This means that we cannot determine if a single policy implies a permission when the conditions under which the policy applies must be written in first-order logic as a formula of the form Q    P 5  X ) H where X ) Hhas a binary predicate other than Permitted.We can get the same result even without assuming that £ has a binary predicate other than Permitted.
This is summarized in the following theorem.
It follows from Theorem 3.1 that we cannot determine if a set of policies imply a permission in an environment when the environment is empty, the policy set has only one policy, and that policy has a single alternation of quantifiers and no function symbols.
Not surprisingly, similar undecidability results hold if we allow formulas in the environment to involve nontrivial quantification (provided that there is a binary predicate in the language other than Permitted, since we do not allow Permitted in the environment).
Given Theorem 3.1, it seems that our only hope is to forbid any alternation of quantifiers.How much quantification do we really need?
A quantifier-free environment suffices to capture simple databases.
However, we want to allow at least universal formulas in the environment so that we can state general properties, such as 'all freshman are students'.
Universal quantification is even more critical in policies.
If we do not allow a policy to have any quantification (i.e., define a policy to have the form is quantifier-free), then each policy must govern a specific individual and action.
For example, we can say 'If Alice is good, she may play outside', but we cannot say 'All good children may play outside'.
Because policies typically permit an individual to do an action based on the attributes of that individual and action, we must allow policies to be universally quantified.Policies with universal quantification (and a quantifierfree antecedent) are sufficiently expressive to capture the policies that we have collected from libraries and government databases.
Although some of the collected policies appear to need existential quantification, they can be converted to formulas with universal quantification.
Consider the policy 'anyone who is accompanied by a librarian may enter the stacks'.
A natural way to state this in first-order logic is e nter(stacks) I E which uses only universal quantification.Note that enter is a function in Example 3.2.
Unfortunately, it is well known that the validity problem for existential formulas with functions is undecidable [7].
The following result is almost immediate: by co-NEXPTIME (co-nondeterministic exponential time) in parts (a) and (b) [7].
Theorems 3.1, 3.3, and 3.4 seem to suggest that the questions we are interested in are hopelessly intractable.
Fortunately, things are not nearly as bad as they seem.
The work on Datalog and its variants mentioned in the introduction demonstrates that there are useful, tractable fragments of first-order logic.
In this section we identify a different set of restrictions than those considered by the Datalog community, show that they lead to tractability, and argue that they are particularly well-suited to reasoning about policies.
Define a standard policy to be a policy of the formP ) Q R T F T 8 T G P ) Q  © I © w m R n p T F T 8 Tp m o ` p © Y cD are terms of the appropriate sort.
A basic environment is an environment that is a conjunction of ground literals.
Basic environments are sufficiently expressive to capture the information in databases and certificates.
While this is adequate for many applications, basic environments cannot represent general properties, such as 'all freshmen are students'.
To handle these, we define a standard environment to be an environment that is a conjunction of quantifier-free formulas and universal formulas of the formP ) Q  R W T F T F T I P ) Q  © w m R p T F T 8 T p m o ` m o 3 q R, wherem R E T F T F T E G m o 3 q Rare literals.
As argued in Section 3, standard policies seem sufficiently expressive to capture most (if not all) policies of interest.
Basic environments suffice for many applications of interest; standard environments suffice for all the applications we have considered.As a first step towards tractability, we consider only basic environments and make what may seem to be rather arbitrary restrictions on policies.
(Later in this section we justify the restrictions and discuss standard environments.)
One of the restrictions relies on a notion called bipolarity, which in turn relies on a well-known technique from theorem proving called unification [30].
Two We can determine the validity of formulas in¤ k x in time z © I © Y { |  w { d } ~ { | v  {   |  "  { |  w {, where{ |   {denotes the length of  , when viewed as a string of symbols.
1 We say that a first-order formula is in CNF if it has the form    ' )  Y  I     Y  d      d   I  Y  I  5  W   , where each  U is a (quantifier-free) disjunction of literals and k  k  u  9  $  G    for  5  s   I  Y  f  Y  1  and    s   I  Y  f  Y  1 .
Each  U is called a clause.
We sometimes identify a universal formula in CNF with its set of clauses.Note that the language ¤ ¦ x includes formulas such asStudent© Alice U p Good© Alice I p P d Q © S tudent© Q ` Permitted© Q E w ork f Y p P d Q © S tudent© Q U p Good© Q ` Permitted© Q E p lay f T('Alice is a student, Alice is good, all students may work and all good students may play').
Unlike Theorem 3.4(c), function symbols are allowed in Theorem 4.1.
Moreover, there is no assumption that the arity of predicates and functions in £ is bounded.
The price we pay for this added generality and for cutting the complexity to linear in the number of policies (which could well be large) and not much more than linear in the size of the database (which we expect to be relatively small, particularly in certificate-passing systems) is the four restrictions.
Before describing the proof of Theorem 4.1, we argue that the restrictions are often met in practice and show how the restrictions can be relaxed so that the result is even more applicable.As we have already said, basic environments are sufficiently expressive to capture the facts stored in databases and certificates.
This is not always enough.
For example, the documents that describe who may collect Social Security define an aged person to be anyone 65 years old or older, who is a resident of the U.S., and is either a citizen or an alien residing in the U.S. both legally and permanently.
A basic environment cannot capture what it means to be aged, according to Social Security policies.
Nevertheless, basic environments seem perfectly adequate for certificate-based permissions in the spirit of SPKI/SDSI [12,13] and for licenses as described by XrML [10], which assumes a minimal environment containing facts such as the current time and the time of the most recent revocation polling.The second restriction, that equality is not used, is a serious restriction.
Without equality, we cannot express threshold policies ('if at least three different people vouch for Alice, then she can enter the club') nor can we express the identity of two individuals ('Miss Alice Smith = Mrs. Alice Jones').
Nevertheless, there are large classes of policies that do not require equality at all.
(This includes the policies in the Social Security database and the library policies that we have considered.)
The third restriction, that every variable appearing in a policy  also appears as an argument to Permitted in  , is met if an individual is granted or denied permission based solely on her attributes and the attributes of the regulated action.
Notice that the policies in Examples 2.1 and 2.3 have this form, but the policies in Examples 2.
2 ), and policies do not have Permitted in their antecedents.
To see why, recall that a permitting policy says 'if the following conditions hold, then a particular action is permitted'.
These conditions typically include requirements that someone possess one or more credentials, such as a library card or a driver's license.
It is fairly rare that not having a credential, such as not having a driver's license, increases an individual's rights.
Therefore, we do not expect credentials to correspond to bipolars.
Similar arguments may be made for other types of information.If the policy set includes a mix of permitting and denying policies, even if Permitted does not appear in the antecedent of policies, then it seems less likely that the bipolar restriction will hold.
For example, consider the policy set In this subsection, we discuss the consequences of relaxing some of the conditions in Theorem 4.1.
In particular, we consider the effect of allowing standard environments, as opposed to basic ones, allowing a limited use of equality, allowing variables to appear in policies (and the standard environment) without also appearing as arguments to Permitted, and allowing each policy (and each environment fact) to have one bipolar.
The bipolar restriction is further relaxed in Section 4.3.
We first consider the equality restriction.
It turns out that we can allow equality in the quantifier-free portion of the environment.
As a result, we can write statements such as 'Miss Alice Smith = Mrs. Alice Jones' and 'hearing £ s listening'.
However, if we allow equality to be used in this way, then we need to generalize the definitions of unification and bipolarity.
We We also can support equality in the antecedents of policies, but we cannot support inequalities.
For example, we can handle the policyP ) Q RP ) Q y  © f © Q R s Spouse© Q   I ` Permitted© Q R E S peakFor© Q   I f Ebut we cannot handle the policyP ) Q RP ) Q y  © f © Q R £ s Spouse© Q   I ` b c Permitted© Q R E S peakFor© Q   I f T (The first policy says 'an individual may speak for her spouse'.
The second says 'an individual may not speak for someone who is not her spouse'.)
We now consider the variable restriction; first we relax it and then we remove it entirely.
Suppose that every literal in every policy has at most one variable that doesn't appear in Permitted (which is the case in Examples 2.2 and 3.2) and there are § constants that appear in the environment.
Then the increase in complexity is onlyz © w § ¨ { © v  {  |  "  { |  w {, and the time needed to answer our queries isz © f © Y { |  w {  } v § ¨ { © v  {   w    { |  w {.
Therefore, our language will not become intractable if we allow any number of variables to violate our original restriction, provided that each literal has only one such variable.The NP-hardness result of Theorem 3.4(b) suggests that it will not be possible to get such low complexity in general.
We can show that if there are at most ª variables in any policy that do not appear as arguments to Permitted, then the queries in which we are interested can be answered in timez © I © Y { |  w { ) } ¤ § o { © v  {   w    { |  w {.
This result is not simply a generalization of the previous one.
Our earlier result might apply to a policy set for which ª is greater than one.
Consider the policy P ) Q RP ) Q y  F P ) Q j P d Q l © G « R © Q R E Q l  p «  © Q y  E Q l  p « ¦ j n © Q j " E Q l ` Permitted© Q l E F h I .
z © I © I { ©  w { ¯ } ° § o { © v  {   w    { |  w { .
z © I © Y { |  w { ± } § v { | v  { ²  |  "  { ©  C { .
Note that Theorem 4.2 allows equality in the environment  .
Also, note that all of the examples in this paper, including Examples 2.2 and 3.2, meet the condition that every literal in every policy has at most one variable that does not appear in Permitted.
Thus, we can answer our queries about these policies in time We can determine the validity of is a variable that does not appear as an argument to Permitted.z © f © Y { |  w { n } A § ¨ { © v  {   w    { |  wX in time z © Y { |  R p v  {  w    { |  R p v  { W } ´ ¦ F { | µ S ¶  {  } ¸ · ,© Y { |  S  { n } § B © Y { |  R p v  { } ¸ ¦ 8 { © µ S ¶ G { I   w    { ©  S  n { .
Otherwise, · is © Y { |  S  n { ¯ } k § o © I { ©  R p v  { ¯ } ¦ 8 { © µ S ¶ 9 { f   w    { |  S  n { ,For the rest of this subsection, we discuss why Theorems 4.1, 4.2, and 4.3 are true, and the role of the restrictions on bipolarity and equality.These theorems are best understood in the context of the resolution procedure from theorem proving [30] can add bipolars to the formula and we need to restrict bipolars for tractability, our theorems must refer to the number of bipolars after the substitutions have been made.
This is why the theorems refer to the number of bipolars relative to a set of equality statements (if the environment has equality).
We remark that, in general, dealing with equality in the context of resolution is nontrivial; it requires techniques such as paramodulation [8].
Our restrictions guarantee that these additional procedures are unnecessary.The problem with applying resolution is that, in general, the number of clauses in Thus, if the hypotheses of Proposition 4.5(c)(i) hold, then, after making the all the required substitutions, each literal has at most one variable that has not yet been assigned a value.
It is not hard to show that, in this case variable can be considered independently of the others.
Therefore, we can try all possible assignments in time «  © G X H s Ë ¡ Ì µ R E T F T F T E F µ  ¢ , then «  © G X p X H s Í «  © G X W Î © Â 9 Ï  «  © G µ Â p X f .
(c)z © f © Y { | X W { 9 }  § ¨ { © µ  {   w    { © X W { .
As we have already observed, the bipolar restriction in Theorems 4.1, 4.2, and 4.3 might not hold in practice.
In this section, we discuss two situations in which the restriction is unlikely to hold, and what can be done about it.
The first is when policies use predicates that are, intuitively, defined in the environment.
The second is when the policy set includes both permitting and denying policies (that is, the set has policies with Permitted in the conclusion and policies with c Permitted in the conclusion).
To understand the role of definitions, consider the policy 'any minor who is intoxicated may go to jail'.
Now, suppose that an individual is a minor in New York if she is under twenty-one and she is a minor in Alaska, if she is under eighteen.
Also, an individual is intoxicated if she fails a breathalyzer test, can't touch her nose, or can't walk straight.
Formally, is the first-order part of the environment.
Is this so bad?
Examples in the social security database suggest that § is typically less than 3.
In most cases, a bipolar is defined by only one clause.
Thus, replacement does not typically increase the number of policies, although the individual policies are longer.
These examples suggest that, in practice, definitions will not significantly reduce the efficiency of these procedures.We next provide a condition that allows us to support policy sets that have both permitting and denying policies.
This task would be easy if we could consider only the permitting policies (ignoring the denying policies) when determining if an action is permitted.
Unfortunately, if we do this, then we might not answer queries correctly.To see why, consider an environment together imply that no student is a faculty member.
(Intuitively, students cannot be faculty members, because no one can be both permitted and not permitted to chair committees.)
Because students are not faculty members, Alice, being a student, is not a faculty member and, by  j , may take a nap.
We cannot determine that Alice may nap if we consider only the permitting policies, because to derive the permission we need the environment fact that is implied by R  p  .
If each fact implied by a permitting and denying policy together were derivable from either the environment or a single policy, then we could separate the permitting policies from the denying policies.
Intuitively, this is because the interaction would not provide any information that wasn't already known.
To formalize this intuition, note that each implied fact corresponds to a resolvent of a permitting and denying policy.
In the previous example, the implied fact that students are not faculty members corresponds to the resolvent of .
Therefore, if every resolvent of a permitting and denying policy is already implied by the environment or a single policy, then we can separate the policies.
Continuing our example, we could separate the policies if the environment said that students were not faculty members.
A closer analysis shows that, because we are determining permissions and prohibitions, we need to consider only those resolvents that are created by resolving on a literal that involves Permitted.We formalize all of this in the following theorem.
But to do so, we need to discuss permitting and denying policies in a bit more detail.
Note that a policy such asP ) Q © P ermitted© AliceE F h ` Permitted© BobE F h Iis logically equivalent to both a permitting policy and a denying policy.
(The denying policy isP d Q © Y c Permitted© BobE 8 h ` c Permitted© AliceE F h f T )We say that a policy is pure if it is not logically equivalent to both a permitting and a denying policy.
Note that policies that do not mention Permitted in the antecedent (which is the case for almost all the policies we have collected) are guaranteed to be pure.
Of course, a similar result holds for prohibitions.
 p  R p T 8 T F T p   p Ü R p T 8 T F T p Ü V ` Permitted© w D F E G DH is valid iff  p  R p T F T F T p   ` Permitted© 1 D F E GGiven an environment and a set of policies, we can always add clauses to obtain an equivalent environment and policy set that meets the theorem's conditions.
Therefore, the question isn't 'how likely are these conditions to be met in practice', but 'how many clauses are we going to have to add so that these conditions are met'.
Example 4.4 shows that we may need to add an infinite number of policies to the set.
However, for policy sets where Permitted appears only in the conclusions of policies, it is easy to see that every resolvent is an environment fact and there is, at most, one resolvent per pair of permitting and denying policies.So, if the policy set consists of Á policies, then we can satisfy the antecedent of Theorem 4.6 by adding at most Á  clauses to the environment.
Instead of adding these clauses to the environment automatically, it may be better to verify the changes with the policy maker.
To see why, recall the two policies 'faculty members may chair committees' and 'students may not chair committees'.
We could satisfy the antecedent of Theorem 4.6 by adding the fact 'no student is a faculty member' to the environment.
But suppose that there is (or could one day be) a student who is also a faculty member.
Then the policy maker may want to revise the policies to take this into account, rather than allowing the environment to (possibly) become inconsistent.
In general, we expect that the additional facts needed to satisfy the antecedent of Theorem 4.6 will be ones that either the user would agree should have been there all along or are ones that should not be there and in fact suggest that the policies should be rewritten.
By querying policy makers, we help them to write better policies.Another advantage of querying the policy maker is that the implied facts may remind her of a general fact that should be added to the environment.
For example, the policies 'men under 65 may apply for health plan A', 'men who do not smoke may apply for health plan A', and 'women may not apply for health plan A' imply the facts 'men under 65 are not women' and 'men who do not smoke are not women'.
Rather than adding both facts to the environment, the policy maker may prefer to add the fact 'men are not women' and in this way simplify the environment.
In this section, we consider the problem of checking consistency.
(Recall that an × á s Ó ¡  R E T F T 8 T E  )  E F Ü R E T F T 8 T E F Ü V ¢is a set of policies such that the antecedent of Theorem 4.6 holds.
Then p  R ± p T F T 8 T p  )  p Ü R  p T F T 8 T p Ü V is satisfiable iff  is satisfiable.Thus, in addition to making it feasible to check the consequences of policies, our conditions essentially prevent users from writing inconsistent policies.
This is a major benefit of adhering to these restrictions!
We have presented an expressive, tractable logic for reasoning about policies.
But how can policy writers and administrators (users), who are not logicians, benefit from such a logic?
We believe that an appropriate interface would allow users to state their policies and the relevant facts, as well as to make queries, without writing formulas.
Their input could be translated into our fragment of first-order logic and then answers to their queries could be translated back into natural language to produce reasonable answers to the original (pre-translated) questions.
We are in the process of building a prototype that allows users to enter information by filling in blanks in English sentences.
Although many of the details are still being refined, we have completed a basic interface and a translation from the interface to firstorder logic.
Due to space constraints, we do not give a complete description of the interface, nor do we provide a formal translation from the fields entered by users to first-order formulas.
We are preparing a paper that will discuss this in detail.
Here we just present the highlights of our approach.A user creates policies and states environment facts by filling in blanks in English sentences.
For example, the user could record the fact that Alice Smith paid her dues to Bob Jones at 10 AM on May 1, 2002, by selecting the appropriate environment form and filling in the white boxes as shown in Figure 1.
When designing the prototype, we need to decide which English sentences should be supported, where the blanks should go, and what symbols may go in each blank.
The first two questions can be answered by analyzing the structure of the policies that we collected and the environment facts on which they rely.
Addressing the last question is more interesting.
Based on the structure of the sentences, it is easy to decide which blanks should take terms and which should take predicate symbols, but it is less clear what those symbols should be.
This choice depends on the application, and for any particular application the appropriate choice may change over time.
For example, a library may want a constant symbol for each patron.
The set of library patrons, however, is not fixed.
To handle this, we allow users to create symbols on the fly, while filling in the sentences.
We can, for the most part, infer what type of symbol it is (Subject, predicate, etc.) from its use.
The only exception is that the user must help us distinguish constants from variables.A drawback to having a nonfixed language is that a user may have difficulty remembering precisely which terms have been defined.
For example, a policy maker may wonder if a predecessor used the term 'graduate student', 'grads', 'gradStudent', or something else to refer to the graduate population.
To minimize this confusion, we provide a directory system for the various sorts (e.g., the subject 'grad' may be in the directory 'subjects/university/students').
When a new symbol is defined, the policy maker puts the symbol in the appropriate directory where appropriateness, like the directories themselves, are determined by the users.
When searching for the forgotten symbol, the user can consult these directories, which are accessible from the main menu and by clicking on the buttons beside the blanks in the English sentences.The interface to the system has been designed to support standard environments and policies.
In other words, the user cannot fill in the English sentences in such a way that our translation creates either a nonstandard environment or a nonstandard policy.
The user, however, can enter a permitting policy and a denying policy that together imply a fact that is not in the environment or a policy that is not implied by one already in the set.
Therefore, the antecedent of Theorem 4.6 may not hold.
If we are not certain that it holds, then we ask the user if a conflict could occur and, if so, how it should be handled.
We then either extend the environment to include the missing fact or we modify the policies to reflect the policy maker's actual intent.
Our work has been heavily influenced by the work of Halpern, van der Meyden, and Schneider [18].
Their paper discusses key issues that must be addressed when designing a policy language, evaluates various solutions that have been proposed in the literature, and recommends directions for future research.
Our design incorporates three of their suggestions.
First, Halpern et al. seem to favor first-order logic for handling policies.
Second, they advocate defining sorts for principals, actions, and time, which is common in the literature.
Third, they suggest having a Permitted predicate that takes an individual and an action argument (and perhaps others).
(This usage of Permitted is much in the spirit of how it is used in modal deontic logic [28,29].)
In essence, we have tailored a logic that was based on their recommendations to serve the expressive and tractability needs of applications.Many people in the trust management and access control communities have defined tractable policy languages using a fragment of first-order logic.
The standard approach (see, for example, Delegation Logic [25], the RT (Role-based Trust-management) framework [27], Binder [11], SD3 [24], and FAF (Flexible Authorization Framework) [23]) is to describe policies in such a way that they can be analyzed using a variant of Datalog, typically either safe stratified Datalog [16] or Datalog with constraints [31,33].
Datalog is an efficient well-understood reasoning engine that was originally designed for function-free negation-free Horn clauses.
The variants allow some use of functions and negation, while preserving tractability.There are relatively few policy languages that support functions, but those that do (e.g. [2,26]) seem to favor a variant of Datalog called Datalog with constraints.
By using this variant, many structured resources, such as directories and even time, can be expressed using functions.
However, function symbols may not appear in intentional predicates (predicates whose relations are computed by applying Datalog rules, as opposed to being stored in a database).
Also, for tractability, additional restrictions are often made.
For example, Li and Mitchell [26] do not allow formulas in constraints to have more than one variable.There are a number of policy languages that support negation.
This is typically done using safe, stratified Datalog (e.g. [25], [27], [11], and [24]).
Safe, stratified Datalog allows some use of negation in the body of rules.
The relaxation is not sufficient for all permitting policies of interest.
For example, the policyP ) Q © Y c BadCredit© Q ` Permitted© Q Ea pply for loan f (anyone without bad credit may apply for a loan) is not supported.
More importantly, denying policies cannot be written in safe, stratified Datalog, because the language does not allow negation in the conclusion of rules.
This limitation may not seem to be particularly troublesome.
After all, the standard approach, used in relational databases [17], as well as by UNIX [35], SPKI/SDSI [34,13,12], KeyNote [4], and almost all of the Datalogbased approaches, is to assume that everything that is not explicitly permitted is prohibited.
However, it is difficult to believe that most policy makers really want to forbid every action that they do not explicitly permit.
Thus, the assumption may be acceptable in various instances, but it does not capture the policy maker's actual intent.
This becomes a problem when different policy makers want to combine their policies.
For example, consider a group of libraries that want to merge their policies so that patrons are effected by the same regulations, regardless of which library they visit.
When merging the policy sets, we clearly want to detect conflicts (e.g. one library lets minors check-out adult books and another does not).
Unfortunately, if a language can state only what is permitted, then this will be impossible.
If we put the permitting policies from each library into one large set, then that set will be consistent (it is satisfied in the model that permits everything), regardless of which policies are in the set.
Alternatively, we could require that no library permits an action that another forbids (which is what we want to do) under the assumption that every unregulated action is forbidden.
It is not hard to see that this approach will always detect a conflict between sets of library policies, unless the policies are essentially identical.
For example, if one library allows patrons to access the coat room and another library's policies don't mention a coat room (perhaps because that library doesn't have one) then the policy sets would be flagged as inconsistent, since one allows access and the other forbids it by not explicitly permitting.
The bottom line is that it seems unlikely that a policy language will be able to support mergers, unless the language supports both permitting and denying policies.
We believe that the issue of merging policies has by and large been ignored, but is an increasingly significant one.Although we do not know of a Datalog variant that allows negation in the conclusions of rules, there is an extension that allows unrestricted use of negation in the body of rules.
Jajodia et al. [23] show that in certain settings this extension, called Datalog with negation, can capture negated conclusions.
But this approach to adding negation to Datalog, although it does support both permitting and denying policies, has its own problems.
Datalog with negation is tractable because it makes the closed world assumption.
According to this assumption, if we cannot prove that a positive literal is true, we assume it is false.
Unfortunately, the closed world assumption can lead to unintuitive (and probably unintended) results.
For example, consider the single policy 'If Alice is not a student, then she may play' and suppose that the reasoning engine can recognize a student only when she presents her ID.
If Alice is a student who does not present her ID and the reasoning engine makes the closed world assumption, then the reasoning engine will incorrectly assume that Alice is not a student and, thus, permit her to play.If a policy language can capture both permitting and denying policies, then conflicts can be detected and resolved in some prescribed way.
For example, FAF [23] expects the user to create an overriding policy such as 'if an action is both permitted and forbidden, then it is forbidden'.
However, as we have already seen, there are problems with the FAF approach to dealing with conflicts.
Similar approaches are taken in [9,22].
In our language, as long as all pairs of permitting and denying policies satisfy the antecedent of Theorem 4.6, policies cannot be inconsistent, so we do not need overriding policies.One way in which it may seem that our language is restricted is that we we do not provide explicit support for groups and roles.
Many policy languages talk about groups, where a group is a set of subjects such that if a group has a property, then every member of the group has the property (cf. [1,23]).
In role-based access control models [27,36,15,20], roles are an intermediary between individuals and rights.
More specifically, an individual obtains a right by assuming a role that is associated with that right.
For example, Alice may need to assume the role of Department Chair in order to obtain the budget.We do not need to support groups and roles explicitly because we can easily capture both in first-order logic using appropriate predicates.
For example, if we want to say that Alice is a member of the faculty and any faculty member may chair committees, then we can represent the group using the predicate Faculty.
The environment fact is encoded as Faculty(Alice); the policy is then would be added to the environment when Alice assumes the role and would be removed when she relinquishes it.
Alternatively, we could add a sort Roles to our logic along with the predicate As (as suggested in [1] .
Continuing our example, 'Alice, acting as the Department Chair, may sign the budget' could be written in the logic as As(Alice, Dept. Chair) ` Permitted© Alice, sign the budget .
The second encoding for roles may be more in keeping with the spirit of the rolebased model, but we believe that both approaches are reasonable (and our results apply to both choices).
Finally, we should note that the KeyNote system [3] (formerly called PolicyMaker [4]) is more flexible than our approach in that the application can write its policies in a number of different languages.
More specifically, the application gives to Keynote programs (which can be written in a variety of programming languages) that determine if a policy applies to a request and a requestor.
Because KeyNote essentially views these programs as black boxes, it is quite limited in its ability to reason about policies.
As discussed in [5], the system needs to put restrictions on the programs to ensure correct analysis.
This is in fact done in [6], but at the price of a substantial reduction in the expressive power of the language.
We have considered a fragment of first logic that, based on the policies we collected, is likely to be sufficiently expressive for many applications.
We proved that, for typical policies, we could efficiently determine if actions are permitted or prohibited by the policies.
Finally, we briefly discussed a prototype that allows non-logicians to benefit from our logic (see [19] for details).
As we said earlier, all approaches using first-order logic restrict it in some way to get tractability.
The examples that we have been collecting suggest that our language is expressive enough to capture the policies that people want to write.
Moreover, we believe that our approach has significant advantages over approaches that cannot express prohibitions, such as approaches based on Datalog, when it comes to merging policy sets.In terms of future research, we are in the process of using our logic to give semantics to the popular, though ambiguous, XrML rights language [10].
As we said, we are also investigating online databases of policies to check if our language is expressive enough to capture everything that policy writers want to say.
This investigation has already led to improvements in our language.
For example, it showed us that we need to support definitions.
We expect that it will prove useful to find extensions of our logic that remain tractable.
One avenue to explore is to consider a hybrid of our approach and Datalog.
We plan to pursue this in future work.
We would like to thank Carl Lagoze for his advice on the policy needs of digital libraries, Riccardo Pucella for numerous discussions on the material presented here, Thomas Bruce for pointing us to the documents on Social Security, and Moshe Vardi for discussions about the complexity of fragments of first-order logic.
