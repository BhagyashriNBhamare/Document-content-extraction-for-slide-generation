We analyze the complexity of computing pure strategy Nash equi-libria (PSNE) in symmetric games with a fixed number of actions.
We restrict ourselves to "compact" representations, meaning that the number of players can be exponential in the representation size.
We show that in the general case, where utility functions are represented as arbitrary circuits, the problem of deciding the existence of PSNE is NP-complete.
For the special case of games with two actions, we show that there always exists a PSNE and give a polynomial-time algorithm for finding one.
We then focus on a specific compact representation: piecewise-linear utility functions.
We give polynomial-time algorithms for finding a sample PSNE, counting the number of PSNEs, and also provide an FPTAS for finding social-welfare-maximizing equilibria.
We extend our piecewise-linear representation to achieve what we believe to be the first compact representation for parameterized families of (symmet-ric) games.
We provide methods for answering questions about a parameterized family without needing to solve each game from the family separately.
In the last decade, there has been much research at the interface of computer science and game theory (see e.g. [26,31]).
One fundamental class of computational problems in game theory is the computation of solution concepts of finite games.
Much recent effort in the literature has concerned the complexity of computing mixed-strategy Nash [7,9,10,12] and correlated equilibria [19,27].
In this paper we focus on the problem of computing pure strategy Nash equilibria (PSNE) [6,11,[16][17][18].
Unlike mixed-strategy Nash equilibria, which are guaranteed to exist for finite games [25], in general PSNE are not guaranteed to exist.
Nevertheless, in many ways PSNE is a more attractive solution concept than mixed-strategy Nash equilibrium.
First, PSNE can be easier to justify because it does not require players to randomize.
Second, it can be easier to analyze because of its discrete nature (see, e.g., [6]).
There are several versions of the problem of computing PSNEs: deciding if a PSNE exists, finding one, counting the number of PSNEs, enumerating them, and finding the optimal equilibrium according to some objective (e.g., social welfare).
The latter problems are game-theoretically more useful, but often computationally harder.The complexity of each of these problems very much depends on the representation used.
Normal form is the traditional choice.
In this representation, each player's utilities are specified explicitly for each pure strategy profile.
Questions about PSNE can be answered in time polynomial in the input size, by checking every pure strategy profile.
However, the size of the normal form representation grows exponentially in the number of players.
This is problematic in practice, especially since many games of interest involve large numbers of players.Fortunately, most large games of practical interest have highlystructured payoff functions, and thus it is possible to represent them compactly.
A line of research thus exists looking for compact game representations that are able to succinctly describe structured games, and efficient algorithms for finding equilibria that run in time polynomial in the size of the representation.
The problem of computing PSNE of compactly-represented games is hard in the most general case, when utility functions are arbitrary efficientlycomputable functions represented as Turing Machines [1] or circuits [30].
Researchers have also studied compact game representations that exploit various types of structure in utility functions.
These include graphical games [20], congestion games [28] and actiongraph games [5].
Computing PSNE for each of these representations is hard in general, but polynomial time for certain subclasses of games [11,13,[16][17][18].
One important type of structure is symmetry.
A game is symmetric when all players are identical and interchangeable.
Symmetric games have been studied since the beginning of noncooperative game theory.
For example, Nash proved that symmetric games always have a symmetric mixed Nash equilibrium [25].
In a symmetric game, a player's utility depends only on the player's chosen action and the configuration, which is the vector of integers specifying the number of players choosing each of the actions.
As a result, symmetric games can be represented more compactly than games in normal form: we only need to specify a utility value for each action and each configuration.
For a symmetric game with n players and m actions per player, the number of configurations is`n+m is`is`n+m−1 m−1 .
With fixed m, this grows like n m−1 , and Θ(n m−1 ) numbers are required to specify the game.
Questions about PSNE can be answered straightforwardly by checking all configurations, which requires polynomial time in the size of the representation, and polynomial time in n when m is fixed.
Indeed, Brandt et al. [6] proved that the existence problem for PSNE of symmetric games with constant number of actions is in AC 0 .
Existing work on symmetry in games focuses on utility functions that explicitly enumerate utility values for each configuration.
However, more concise representations are possible when utility functions have additional structure.
In symmetric games, the set of players can be specified implicitly by the integer n, requiring only log n bits to represent.
If utility functions can be represented in size polynomial in the number of bits needed to represent the configuration vector, the game can be represented in size polynomial in log n. Thus, such a "compact" representation is able to specify games with a number of players exponential in the input size.In this paper, we consider the complexity of computing PSNE for symmetric games with compactly-represented utility functions.
We first look at the most general setting, where the utility functions are represented as circuits whose inputs are binary representations of the configuration vector.
We show that even with a fixed number of actions, the problem of deciding the existence of PSNE is NPcomplete.
The only exception is the case of two actions, for which we show that there always exists a PSNE and present an algorithm that identifies such an equilibrium in polynomial time.Our main positive result is the identification of a compact representation of utility with nice computational properties-piecewise linear functions of the configuration vector.
Piecewise linear functions are a natural and convenient way of representing utilities.
For this setting, we present novel algorithms for finding a sample PSNE and for counting the number of PSNEs.
When the number of actions is fixed, these algorithms run in polynomial time.
In particular, if the total number of pieces is bounded by a polynomial of log n, then we achieve an exponential improvement over the algorithm of Brandt et al. [6], which scales polynomially with n.
Our techniques also yield a polynomial-space, polynomial-delay output-sensitive algorithm for enumerating the set of PSNE, and an FPTAS for finding social-welfare maximizing equilibria.Furthermore, we are able to extend this piecewise-linear representation to model parameterized families of symmetric games.
While existing literature on equilibrium computation focused on finding equilibria in a single game, in many practical applications of game-theoretic analysis we are interested in questions about Nash equilibria of a family of games.
For example, in mechanism design, the designer may want to choose from a family of games so that an equilibrium of the chosen game maximizes a given objective.
As another example, an econometrician may be given data about agents' observed behavior and wants to estimate parameters of the underlying game.
To address such problems, existing equilibrium computation approaches would be forced to solve many individual games from the family, which can be very costly.
Our parameterized symmetric games are to our knowledge the first compact representation of parameterized families of games.
Leveraging this representation, we provide a methodology for solving optimization problems over PSNE of a family of symmetric games, without having to solve each individual game in the family.
These include the problem of finding parameters that ensure equilibria that are close to some observed configuration, and the problem of finding parameters that maximize the equilibrium payoff for the worst-off player.The main challenge in constructing such polynomial-time algorithms is that the set of configurations (and, indeed, the set of PSNEs) can be exponential in the input size.
Thus, approaches based on enumerating all configurations require exponential time.
Furthermore, the constraints defining PSNE are not generally convex, so the problem cannot be formulated as an integer linear program in fixed dimension.
Instead, our approach encodes the set of PSNEs in a compact form that has appealing computational properties.
Specifically, we make use of the rational generating function method for representing and computing with sets of lattice points, due to Barvinok and Woods [4].
We model configurations as integer lattice points, and formulate the set of equilibrium configurations via operations on sets of lattice points in polyhedra; the resulting set of points can be encoded as a rational generating function of polynomial size.The current paper relates to recent work coauthored by one of us [21].
This previous work introduced rational generating function methods to the algorithmic study of games, showing that they can be used to compute pure-strategy Nash equilibria of games in which the actions are lattice points in fixed-dimensional polyhedra and the utilities are given by piecewise linear functions.
These results assumed a fixed number of players and made strong restrictions on the piecewise linear functions used to represent utilities.
The key conceptual difference between the current paper and [21] is that lattice points are used to represent different things.
In [21] lattice points directly represent actions, making the result more direct but the model more restrictive (actions scale in a restricted way and players are fixed).
In the current paper's setting of symmetric games, lattice points arise more naturally as configurations, and the number of players scales freely and instead we fix the number of actions.
The difference in setting from [21] gives rise to novel technical challenges, requiring different proof techniques based on disjoint set decompositions rather than [21]'s approach using integer projections.
Furthermore, computing social welfare maximizing PSNEs (Section 4) presents a novel difficulty because in our setting social welfare becomes a non-linear function.
We overcome this difficulty by adapting an FPTAS result of [14].
A strategic game is defined by the tuple (n, {Ai} 1≤i≤n , {Ui} 1≤i≤n ) where n is the number of players, and for each player i, Ai is her set of actions and Ui : Q j Aj → Z is her utility function.
Throughout the paper we assume that utilities are integer-valued.
1 Symmetric games are a class of strategic games in which each player has an identical set of actions A and for all permutation of players π : {1, . . . , n} → {1, . . . , n},Ui(a1, . . . , an) = U π(i) (a π(1) , . . . , a π(n) ).
We consider n-player symmetric games in which the number of actions m is a fixed constant.The outcomes of the game are sufficiently described by configurations of players; that is, a count of how many players take each action.
A configuration is an m-dimensional vector x = (xa : a ∈ A), where xa is the number of players taking action a. Let D denote the set of configurations:D = ( x ∈ Z m : X a∈A xa = n, xa ≥ 0 for all a ∈ A ) .
(1)The utility of a given player in a symmetric game depends only on the action played and the overall configuration.
For each action a ∈ A, we have a function ua defined over configurations in which at least one player takes action a.
In particular, ua(x) is the utility of playing action a in configuration x (provided xa ≥ 1).
The set of functions ua for all a ∈ A is sufficient for specifying the utilities of the game.
For the rest of the paper we call these ua the utility functions and will not refer to the functions Ui.A configuration x ∈ D is a pure strategy Nash equilibrium configuration (or simply a PSNE) if for all actions a and a either no player takes action a or the utility of a player playing action a is no less than the utility he would receive from unilaterally deviating to action a .
Symbolically, let N denote the set of PSNE in a symmetric game.
Then x is an element of N if for all a ∈ A either xa = 0 or for all a ∈ A, ua(x) ≥ u a (x+e a −ea), where ea is the ath unit vector with components eaa = 1 and e aa = 0 for a = a. Note that x + e a − ea is the same configuration as x except that one player has deviated from playing action a to action a .
Similarly, for an integer ≥ 0, a configuration x is an -PSNE if for all a ∈ A either xa = 0 or for all a ∈ A, ua(x) + ≥ u a (x + e a − ea).
In other words, each player in an -PSNE can gain at most by deviating from her current strategy.
We want the utility functions to be compactly represented and efficiently computable.
One approach is to model utility functions as circuits, as was done in previous work for general games [30].
In this subsection, we consider circuit symmetric games, a representation in which each utility function ua is represented as a circuit whose input is a binary representation of the configuration vector x and output is a binary representation of the corresponding integer utility value.
Since circuits can represent arbitrary integer functions of the inputs, this can represent all symmetric games with integer utilities.
When utility functions can be specified as circuits with small numbers of gates, the representation size can be as small as O(log n).
We first consider the case with two actions, A = {1, 2}.
In this case the game always has a PSNE.
This follows from the fact that such a game can be formulated as a congestion game, which implies the existence of a PSNE [28].
(To see this, observe that u1(x) = u1(x1, n−x1) is a function of only x1; similarly u2(x) = u2(n − x2, x2) is a function of only x2.)
The claim was also proven from first principles by [8].
However, even when a PSNE provably exists (or when a game is a congestion game), PSNEs can still be difficulty to find.
We give an alternative proof of the existence of PSNE for these games that illustrates the structure of the strategy space, and then show how this structure can be exploited for efficient computation.
LEMMA 1.
Any symmetric game with two actions has a PSNE.PROOF.
Given such a symmetric game, we construct the deviation graph, whose vertices are the configurations x ∈ D.
There is a directed edge from x to x if and only if a deviation by a single player from x results in x .
Since each x = (x1, n − x1), where x1 is the number of agents playing action 1, we can identify each configuration by its first component.
Under this mapping, the set of configurations corresponds to the set of integers {0, . . . , n}.
It is straightforward to see that the only edges in the deviation graph are between adjacent integers: i, j ∈ {0, . . . , n} such that |i − j| = 1.
We then consider the profitable deviation graph (PDG), whose vertices are the same configurations and directed edges represent strictly profitable deviations.
For example, if a deviation by one player in configuration x from action a to action 3 − a results in configuration x , and furthermore if u3−a(x ) > ua(x), then the PDG has an edge from x to x .
Observe that the PDG is a subgraph of the deviation graph, and that if there is an edge from x to x in the PDG, then there cannot be an edge from x to x.A sink of the PDG has no profitable deviations, which means that it is a PSNE.
We claim that the PDG must have a sink.
To see this, we can start at vertex 0 and follow the directed edges.
Because the PDG is a subgraph of the deviation graph, each edge on this path must increase the vertex's index (in fact, by exactly one).
Thus, the path must eventually stop at a sink.This proof suggests a straightforward algorithm for finding a PSNE: start at configuration 0 and follow the edges in the PDG.
In fact by a similar argument any starting configuration would lead to a sink.
Unfortunately this approach can take Ω(n) steps before reaching a sink, which can be exponential in the representation size.
Instead, we present a divide-and-conquer approach that exploits the structure of the PDG.
THEOREM 2.
For circuit symmetric games with two actions, a PSNE can be found in polynomial time.PROOF.
Given such a game with n players, consider the configurations n 2 and n 2 + 1.
There are three cases:1.
If there is an edge from n 2 to n 2 + 1 in the PDG, then there must exist a PSNE in the subset {{ n 2 + 1, . . . , n}.
This is because a path from n 2 + 1 must be increasing and eventually stop at a sink.2.
Likewise, if there is an edge from n 2 + 1 to n 2 , there must exist a PSNE in the subset {0, . . . , n 2 }, since a path from n 2 must be decreasing and stop at a sink.3.
If there is no edge between the two configurations, then there must exist a PSNE in each of the subsets {0, . . . , n 2 } and {{ n 2 + 1, . . . , n}).
Our algorithm picks a subset that contains a PSNE, and then recursively bisects that subset.
This process terminates at a PSNE after O(log n) iterations.
For each iteration, checking the existence of edges between two configurations requires evaluation of utility at the two configurations, which can be done in linear time for utility functions represented as circuits.
Therefore the running time of this algorithm is O(|Γ| log n), where |Γ| is the size of the circuits.Our next result shows that the problem of finding a PSNE in a circuit symmetric game becomes intractable once we go beyond two actions.
THEOREM 3.
For circuit symmetric games in which the number of actions is a fixed constant of at least three, the problem of determining the existence of PSNE is NP-complete.
The proof follows from a reduction from CIRCUITSAT, and is given in Appendix A.
The hardness result of Theorem 3 suggests that the circuit symmetric game representation is too general to be computationally useful in the worst case: it is powerful enough to encode NP-hard problems.
Thus, computation of PSNE is intractable even if the representation is compact.In this subsection and the rest of the paper, we consider utility functions represented as piecewise-linear functions.
Piecewiselinear functions have been widely used as an approximation of arbitrary continuous functions.
A recent example of their use in an economic context is [15], which considered piecewise-linear utilities in the computation of market equilibria in the Arrow-Debreu model, and presented a polynomial-time algorithm when utilities are piecewise-linear concave functions and the number of goods is constant.Piecewise linear functions are normally defined over continuous domains, in which case it is sufficient to specify a polytopal subdivision of the domain and an affine function for each cell.
The domain for our utility functions is the set of configurations D, a discrete set.
Nevertheless we observe that D is the set of integer points in a polytope.
Thus the definition of piecewise linear functions can be naturally extended to this setting.
In particular, we specify a set of polytopes that induces a partition of the integer points D, and an affine function for each cell.Formally, for each action a ∈ A, the piecewise linear utility function ua(x) is given as follows.
There is a finite set of polytopes {Paj}j∈J a with index set Ja where the set of configurations D is partitioned by the integer points in these polytopes.
In other words,D = ] j∈Ja (Paj ∩ Z m ) ,where the notation U signifies disjoint union.
Each polytope Paj = {x ∈ R m : Majx ≤ baj} is given by an integer matrix Maj and integer right-hand side vector baj.
Over each cell Paj ∩ Z m there is an affine function faj(x) = αaj · x + βaj with αaj ∈ Z m and βaj ∈ Z, such thatua(x) = faj(x) for x ∈ Paj ∩ Z m .
(2)Thus, the piecewise linear utility function ua(x) is input as the binary encoding of Maj, baj, αaj and βaj for each j ∈ Ja.We observe that a piecewise linear utility function can be represented as a circuit.
2 Also, given an arbitrary utility function, it can be described exactly by a piecewise linear function, although the number of pieces required may be Θ(n m ) in general, in which case it is no longer compact in the sense we defined at the beginning of the paper.Even if the utility functions cannot be exactly represented as piecewise-linear functions with a small number of pieces, piecewiselinear functions can still be useful as approximations of such utility functions.
If for all configurations x and all actions a the difference between ua(x) and its approximationûaapproximationˆapproximationûa(x) is at most , then by a standard argument any Nash equilibrium of the approximate game is a 2-Nash equilibrium of the original game.
(ii) a polynomial-time algorithm to find a sample pure strategy Nash equilibrium, when at least one exists; and (iii) a polynomial-space, polynomial-delay enumeration algorithm to enumerate all the pure Nash equilibrium configurations of the game.
The proof of this theorem draws on the theory of rational generating functions for encoding lattice points sets in polyhedra.
Below we state the results upon which our proof depends, but offer minimal motivation.
3 Rational generating functions are a method for compactly representing exponential-cardinality sets of integer points (in our case, configurations), for refining them (to yield only equilibrium configurations) and for efficiently supporting the computational operations of counting and enumerating set members.Consider the generating function of the lattice point set P ∩ Z m , which is defined asg(P ∩ Z m ; ξ) = X x∈P ∩Z m ξ x = X x∈P ∩Z m ξ x 1 1 · · · ξ xm n .
(3)Note that each lattice point x in P is mapped to the exponent of a monomial ξ x in g(P ∩ Z m ; ξ).
LEMMA 5 (BARVINOK'S THEOREM [3]).
Let P be a polytope in R m and S = P ∩ Z m with generating function g(S, ξ) given by (3) which encodes the lattice points inside P .
Then, there exists an algorithm which computes an equivalent representation of the formg(S; ξ) = X i∈I γi ξ c i Q m k=1 (1 − ξ d ik ) ,(4)where I is a polynomial-size index set and all data are integer.
A formula of this type is called a short rational generating function.
The algorithm runs in polynomial time when the dimension m is fixed.Note that the number of binomial terms in the denominator of each rational term in (4) is m and thus fixed when the dimension is fixed.
When a lattice point set S is expressed in the form (4) we refer to g(S; ξ) as its Barvinok encoding.A Boolean combination of the sets S1, . . . , S k is any combination of unions, intersections and set differences of those sets.
For instance, (S1 ∩ S2) \ S3 is a Boolean combination of the sets S1, S2 and S3.
Given fixed integers k and there exists a constant s and a polynomialtime algorithm for the following problem.
Given as input, in binary encoding, (I1) the dimension m and (I2) Barvinok encodings of k finite sets Sp ⊆ Z m , g(Sp; ξ) such that for each rational term the number of binomials in the denominator is at most , output, in binary encoding,(O1) rational numbers γi, integer vectors ci, dij for i ∈ I, j = 1, . . . , si, where si ≤ s, such thatg(S; ξ) = X i∈I γi ξ c i (1 − ξ d i1 ) . . . (1 − ξ d is i )is a rational generating function of the finite set S that is the Boolean combination of the sets S1, . . . , S k , and where each rational term in the expression has at most s terms in its denominator and where I is a polynomial-sized index set.Note that if the input sets Sp ⊆ Z m are integer points inside polyhedra whose Barvinok encodings g(S; ξ) arise from applying Lemma 5) then the condition that the number of binomials in the denominators are fixed follows under the assumption that the dimension m is fixed.Disjoint unions are a special case of combining sets.
To compute disjoint unions of sets we do not appeal to the Boolean Operations Lemma, and thus the number of sets k in the union may be polynomial in the input size instead of constant.LEMMA 7 (DISJOINT UNIONS).
If two lattice point sets S and T are disjoint then the generating function for S ∪ T is the sum of generating functions for S and T .
More generally, for disjoint lattice point sets S1, . . . , S k :g k ] i=1Si, ξ!
= k X i=1 g(Si, ξ),where U denotes disjoint union.Once a rational generating function of a set S has been computed, various information can be extracted about S, including cardinality and enumeration.LEMMA 8 (COUNTING LEMMA [3]).
Let the dimension m be a fixed constant.
Given a lattice point set S ∈ Z m input as its Barvinok encoding g(S, ξ), there exists a polynomial-time algorithm for computing |S|.
LEMMA 9 (ENUMERATION LEMMA).
Let the dimension m and the maximum number of binomials in the denominators be fixed.
Then there exists a polynomial-space, polynomial-delay enumeration algorithm for the following enumeration problem.
Given as input, in binary encoding, a bound M and the Barvinok encoding g(S, ξ) of a lattice point set S ∈ [−M, M ] m ∩ Z n , output, in binary encoding, all points in S in lexicographic order.
We now state our main theorem formally and prove it.
THEOREM 4.
Consider a symmetric game with piecewise linear utilities given by the following input: (I1) the binary encoding of the number n of players; (I2) for each a ∈ A, the utility function ua(x) represented as the binary encoding of Maj, baj, αaj and βaj for each j ∈ Ja.Then, when the number of actions m is fixed, there exists (i) a polynomial-time algorithm to compute the number of pure Nash equilibrium configurations;(ii) a polynomial-time algorithm to find a sample pure strategy Nash equilibrium, when at least one exists; and (iii) a polynomial-space, polynomial-delay enumeration algorithm to enumerate all the pure Nash equilibrium configurations of the game.
PROOF.
We first show that N , the set of PSNE, can be encoded as a short rational generating function.
Let N denote the set of PSNE.
A difficulty in applying generating functions to encoding N is the nonlinearity of the objectives ua.
However, since these objectives are piecewise linear, we simply consider the partitions of D into regions in which the objectives are linear.
We use these partitions of D (and hence of N ) to express N as a Boolean combination of polytopal lattice point sets, and thus will ultimately be able to apply Lemma 6.
The overall idea is to define subsets of configurations that have strictly profitable deviations, then remove these subsets from D, leaving only the set of PSNE.Define the deviation set Dev(a, a , j, j ) as the set of configurations x in which a player currently playing action a lying in region Paj has a strictly profitable deviation to playing action a , thereby yielding a new configuration x ∈ P a j .
Such a profitable deviation will exist whenever faj(x) < f a j (x ).
Since the affine functions have integer coefficients, we can rewrite this condition as faj(x) ≤ f a j (x ) − 1 and thereby avoid strict inequalities.
Putting this together, we define the deviation set asDev(a, a , j, j ) = 8 < : x ∈ D : xa ≥ 1, x ∈ Paj, x = x + e a − ea ∈ P a j faj(x) ≤ f a j (x ) − 1} 9 = ;.
(5) Now we can use (5) to describe N .
We obtainN = D \ [ a,a ] j ] j Dev(a, a , j, j ),(6)where the first union is over all a, a ∈ A, the second union is over j ∈ Ja, and the third union is over j ∈ J a .
This identity (ignoring for now our claim that the second two unions are disjoint) can be verified as follows.
Suppose configuration x ∈ D is not an element of the right-hand side of (6).
This implies that x lies in some deviation set D(a, a , j, j ) for some a, a ∈ A and (j, j ) ∈ Ja × J a and hence there is a profitable unilateral deviation away from x, implying that x is not in N .
Conversely, suppose x ∈ D is not in N .
This implies that there exists a profitable unilateral deviation, say from playing action a to a .
This implies ua(x) < u a (x + e a − ea).
Now, x and x + e a − ea lie in cells Paj for some j ∈ Ja and P a j for some j ∈ J a respectively.
The condition on the utilities then implies that faj(x) ≤ f a j (x ) − 1.
It follows that x is in the deviation set Dev(a, a , j, j ) and thus not contained in the righthand side of (6).
Now we substantiate our claims that the second two unions are disjoint.
The union indexed by j is disjoint because the sets {Paj}j∈J a form a partition of D, and Dev(a, a , j, j ) ⊆ Paj.
To see that the union indexed by j is disjoint, consider an arbitrary element x of Dev(a, a , j, j ).
This implies that x = x + e a − ea ∈ P a j .
Because {P a j } j ∈J a are disjoint sets, for all j ∈ J a \ {j} we have x ∈ P a j and thus x ∈ Dev(a, a , j, j ).
Therefore Dev(a, a , j, j ) is disjoint from Dev(a, a , j, j ) for any j , j ∈ J a , j = j .
We took particular care in describing which unions in our expression for N are disjoint and which are not.
This is because the second and third unions are not of fixed length as would be required for the application of Lemma 6.
However, since the unions are disjoint we can use simple addition of generating functions to handle this part of the overall expression of N .
To make this precise, note that each of the Dev(a, a , j, j ) terms are polytopal lattice point sets and thus admit Barvinok encodings g (Dev(a, a , j, j ), ξ) that can be computed in polynomial time by Lemma 5.
For each a, a ∈ A defineDev(a, a ) = ] j ] jDev(a, a , j, j ).
Dev(a, a ) is a disjoint union, and so by Lemma 7 also admits a Barvinok encodingg(Dev(a, a ), ξ) = X j X j g(Dev(a, a , j, j ), ξ).
We can use (7) to rewrite (6) as N = D \ S a,a ∈A Dev(a, a ).
Since D and each of the sets Dev(a, a ) have Barvinok encodings, Lemma 6 tells us that we can also derive such an encoding for N .
This Boolean combination of sets describing N is of constant length since m is fixed.Now that we have shown that N can be encoded as a short rational generating function, our PSNE computation results follow by applying Lemmas 8 and 9.
Given that we can compute g(N, ξ) in polynomial time, we can compute its cardinality in polynomial time by applying Lemma 8.
This establishes (i).
Applying Lemma 9 (noting the bound N ⊆ [0, n] m ) we need only wait polynomial time to output the first element of N , establishing (ii).
The enumeration scheme (iii) derives from Lemma 9 directly.
When there are many equilibrium configurations in a symmetric game, one may ask which equilibrium is "best" according to some objective function.
By applying Lemma 6 and a binary-search argument, we can optimize in polynomial time any linear objective over a set of lattice points in Barvinok encoding, and thus over the set of PSNE.
This can be extended to piecewise-linear objectives by dealing with each piece separately.
Such objective functions include for example the utility ua(x) of playing some action a.A more interesting and natural objective function is the social welfare, which is the sum of all players' utilities.
We are thus interested in finding an optimal solution to the optimization problem:max ( X a∈A xaua(x) : x ∈ N ).
Denote by w(x) the objective function of this problem and let w * denote its optimal value.
Note that w(x) is not piecewise-linear, but is instead piecewise polynomial.
The main result of this section is an FPTAS for this optimization problem.
The result relies on the following lemma from [14] regarding optimizing polynomials over sets encoded as rational generating functions.LEMMA 10 ( [14]).
There exists a algorithm for the following problem.
Given as input an (I1) two vectors xL, xU ∈ Z k , (I2) a Barvinok encoding of a finite set S ⊆ Z k of lattice points that is contained in the box { x : xL ≤ x ≤ xU }, (I3) a list of coefficients fi ∈ Q, encoded in binary encoding, and exponent vectors αi ∈ Z+, encoded in unary 4 encoding, representing a polynomialf = X i fix α i 4In this section we only consider polynomial functions of degree 2 and thus the unary encodings of the exponents are of constant size.that is non-negative on S, (I4) a positive rational number 1// encoded in unary encoding, output, in binary encoding,(O1) a point x ∈ S that satisfies f (x) ≥ (1 − )f * where f * = max x∈S f (x).
This algorithm runs in polynomial time when the dimension n and the maximum number of binomials in the denominator of the Barvinok encoding of S are fixed.We now state the main theorem of this subsection.THEOREM 11.
Consider a symmetric game with the same input as in Theorem 4, and in addition a positive rational number 1 given in unary encoding.
Then, for a fixed number of actions m there exists a polynomial-time algorithm to output, in binary encoding, a configuration x ∈ D that satisfies w(x) ≥ (1 − )w * where w(x) = P a∈A xaua(x) and w * = maxx∈N w(x).
PROOF.
Partition the feasible region N into subregions where ua(x) is linear simultaneously for all a ∈ A.
This is achieved by considering the problem separately within each cell of the the common refinement of each partition {Paj}j∈J a of D. Let J = Q a∈A Ja.
This yields the following fine partition of: D = S j∈J P j where j = (ja)a∈A ∈ J and P j = T a∈A Paj a .
Note that this is also a partition of N .
It is then clear that for x ∈ P j each action's utility is ua(x) = faj a (x) and thus,w * = max ( X a∈A xaua(x) : x ∈ N ) = max j∈J max ( X a∈A xafaj a (x) : x ∈ N ∩ P j ).
Our approach will be to find an -optimal solution x * j for each inner optimization problemmax ( X a∈A xafaj a (x) : x ∈ N ∩ P j ).
There are |J| = Q a∈A |Ja| such subproblems and note that |J| is polynomially bounded in the input size.
An overall -optimal solution x * is simply the x * j which maximizes P a∈A xaua(x * j ) amongst all j ∈ J. To find an -optimal solution to inner optimization problem (9) we apply Lemma 10 with the following input:1.
two vectors xL = (0, 0, . . . , 0) and xU = (n, . . . , n);2.
The data describing the Barvinok encoding of N ∩ P j given by the encoding of N from Lemma 4 and the Lemma 6;3.
The polynomial objective P a∈A xafaj a (x), where the coefficients are all 1 and either or quadratic exponents; and 4.
1 The result then follows.Using a similar argument, we can generalize Theorem 10 to construct an FPTAS for maximizing non-negative piecewise-polynomial functions.
Such an FPTAS will be useful in Section 5.
In this section we extend our approach to model families of symmetric games parameterized by integer parameters, and answer interesting questions about a family of games without having to solve each individual game in the family.
Many problems in mechanism design have such a flavor; e.g. designing a game (i.e., setting the parameters) such that the resulting equilibria satisfy certain properties or optimize a certain objective.We allow a fixed number of integer parameters that additively influence each piece of the utility functions, and furthermore allow the number of players to be considered as a parameter.
The set of actions remains fixed in each member of the parametric family.Our overall approach is to use rational generating functions as before, except that we augment the configuration vector with the vector of integer parameters.
The resulting set we encode as a generating function is the graph of the parameters-equilibria correspondence.
Since we are considering parametric families of games in which the number of players is a changing parameter, we define our piecewise linear utilities over configurations of different numbers of players.
That is, we define the utilities over the set of feasible configurationsF = {x ∈ Z m : 0 ≤ X a∈A xa ≤ B, xa ≥ 0, ∀a ∈ A},where B is a bound on the total number of players.
In other words, the number of players in the game can be between 0 and B.
The utilities are specified by a polyhedral subdivision {Paj}j∈J a of F for each action a, and affine functions faj defined over the cells Paj as in Section 2 except that now the division is over F .
We also introduce a fixed number of parameters that control the additive constants in the affine functions faj.
We constrain these parameters to be the lattice points inside a polytope of fixed dimension R ∈ R d .
Formally, let p be a d-dimensional integer vector inside of Q = R ∩ Z d and for each a ∈ A and j ∈ Ja, definefaj(x, p) = αaj · x + βaj · p,(10)where now ua(x, p) = faj(x, p) for p ∈ Q and x ∈ Paj.We are interested in encoding the set of parameterized PSNE defined as N = {(x, n, p) : p ∈ Q, n ∈ {0 . . . B}, x ∈ N (n, p)} , (12) where N (n, p) is the set of PSNE in the symmetric game with n players, feasible configurations Dn = {x ∈ F : P a∈A xa = n} and utilities defined as in (11) for the given parameter p.The approach we use to encode N is similar to that of Section 3 in that we describe N as a Boolean combination of sets of lattice points contained in polyhedra that in part derive from a partitioning of N into cells of the form N ∩ P j using the same notation as in the proof of Theorem 11.
The expression of N as a Boolean combination of sets isN = H \ [ a,a ] j ] j Dev(a, a , j, j ),(13)where H = {(x, n, p) : x ∈ Dn, n ∈ {0, . . . , B}, p ∈ Q} is the overall feasible set, and the first union is over all a, a ∈ A, the second union is disjoint over j ∈ Ja, the third union is disjoint over j ∈ J a and Dev(a, a , j, j ) is the set8 > > < > > :(x, n, p) :p ∈ Q, 0 ≤ n ≤ B, n ∈ Z x ∈ Dn ∩ Paj x = x + e a − ea ∈ P a j faj(x) ≤ f a j (x ) − 1} 9 > > = > > ;.
It is clear that H and each Dev(a, a , j, j ) is a polytopal lattice point set in (x, n, p) and thus a Barvinok encoding of N obtains by applying similar reasoning to that found in Theorem 4.
We have thus established the following.THEOREM 12.
Consider a parametric family of symmetric games with m actions and n players with utility functions parameterized by p ∈ Q as found in (11) given by the following input in binary encoding:(I1) an integer bound B on the number of players; (I2) an inequality description of a rational polytope R contained in R d ;(I3) for each a ∈ A, a nonnegative integer |Ja| and each j ∈ Ja = {1, . . . , |Ja|} an inequality description of the polytope Paj and integer vectors αaj ∈ Z m , and integers βaj defining the affine functions faj(x) = αaj · x + βaj · p.Then, the set N of parameterized PSNE defined in (12) has a Barvinok encoding, which can be computed in polynomial time when the number of actions m and the dimension of the parameter space d is fixed.
Once we have a Barvinok encoding of the set N of parameterized PSNE, we can use it to answer questions about game-theoretic properties of the parameterized family.
For example, if we are interested in finding a value for the parameter such that a PSNE exists, it is just a matter of enumerating from the set N .
Similarly we can optimize linear and polynomial objective functions of the parameters, subject to the constraint that a PSNE exists, by optimizing the objective function over the set N .
A more interesting case is when we want to find optimal parameters under some objective function that depends on the PSNE configuration as well as on the parameters themselves.
Since each game in the family can have multiple PSNEs, the problem is not well defined until we specify how PSNEs are selected.
Depending on the application domain, we might consider selecting the best-case PSNE for each game, or selecting the worst-case PSNE.
For example in mechanism design problems, best-case analysis (e.g. recent work on the price of stability [2]) is useful for getting bounds on what we could achieve under equilibrium behavior; while worst-case analysis (e.g. recent work on the price of anarchy [22,29]) is useful for designing mechanisms with guaranteed performance.Depending on whether we want to select (e.g.) best-case PSNE or worst-case PSNE, different types of optimization problems arise.
For example, if we want to minimize the function f (x, n, p), selecting the best-case PSNE yields the problem min{f (x, n, p) : (x, n, p) ∈ N }.
(15)Using similar arguments as in Section 4, we have the following result:THEOREM 13.
When f is piecewise linear or piecewise polynomial, problem (15) can be solved in polynomial time or approximated in polynomial time, respectively.We now turn to a trickier problem than (15), selecting the worstcase PSNE.
This yields the problemmin n,p max x:(x,n,p)∈N f (x, n, p).
(16)We propose a branch-and-bound approach for solving the minmax optimization (16).
Branch and bound is a general optimization method for nonconvex optimization problems, applicable to discrete domains as well as continuous domains [23,24].
At a high level, the algorithm partitions the space of candidate solutions into regions and iteratively refines the partitioning by bisecting a region along one of its dimensions.
The algorithm can prune off regions using bounds on the objective value for each of the regions.For our problem, a "region" corresponds to the set of integer points in a polytope.
The branch-and-bound approach requires that the bounds on the objective value can be efficiently computed for each region.
For each region L, we can compute a lower bound on the value of any candidate solution n, p from the region by solving min{f (x, n, p) : (x, n, p) ∈ N, (n, p) ∈ L}.
We can compute an upper bound by picking somê n, ˆ p in L and solving the optimization max x:(x,ˆ n,ˆ p)∈N f (x, ˆ n, ˆ p).
Finally, there is a wide choice on the order in which the regions are explored.
For discrete domains, a simple and memory-efficient approach is to explore the regions in a depth-first order.
The algorithm is outlined as follows.1.
Set of regions L is initialized with one region {(n, p) : 0 ≤ n ≤ B, p ∈ R} ∩ Z d+1 .2.
Global upper bound U B is initialized to ∞.
(a) Take the next region L from L in depth-first order.
The worse-case running times for branch-and-bound algorithms are exponential in general.
Nevertheless, when the algorithm can prune off large regions, it can be much faster than the brute-force approach of trying every parameter instantiation.
For branch-and-bound to be effective, upper-and lower-bounds for each region need to be computed in polynomial time.
As discussed above, this is the case if f is piecewise linear.
(b) If L contains only one integer point (ˆ n, ˆ p), solvê f = max x:(x,ˆ n,ˆ p)∈N f (x, n, p).
Update U B ifˆfifˆ ifˆf > U B.THEOREM 14.
For piecewise-linear f , the branch-and-bound algorithm finds the optimum of (16) in finite time; furthermore, steps 3b and 3c of the algorithm can be computed in polynomial time.
We now consider a problem from econometrics: determining parameters of a utility model that would give rise to observed equilibrium behavior.
In particular, we show how to fit an undetermined parameter p to an observed configuratioñ x in a game with n players.Suppose we are analyzing a system modeled as an n-player symmetric game where certain aspects of the game's utility functions are unknown, and furthermore the set of candidate utility functions belongs to the set of parametric (in p) piecewise-linear utilities of the form of (11).
We are given the players' observed behavior in the game as some configuratioñx.
Assuming the players are behaving rationally, we would like to know the game's true utility functions, i.e., to estimate the parameter p. Note that we are not parameterizing the number of players n, since given any observed configuratioñconfiguratioñ x we automatically determine the number of players n as P a∈A˜xaa∈A˜ a∈A˜xa.
Thus, for simplicity we use the notation N (p) instead of N (n, p) to denote the set of PSNEs with parameter p.Assuming the players play a PSNE if one exists, we would like to find a p ∈ Q such that˜xthat˜ that˜x is a PSNE of the game with parameter p. Formally, the set of such p is N˜xN˜x = {p : p ∈ Q, (˜ x, p) ∈ N }.
A Barvinok encoding of N˜xN˜x can be computed efficiently using a similar construction as in Section 5.1.
However, there might not be such a p, i.e., the set N˜xN˜x might be empty.
In this case we would like to find p such that˜xthat˜ that˜x is close to being an equilibrium.
One measure of closeness to being an equilibrium is -equilibrium.
Define˜NDefine˜ Define˜N to be the set of (x, p, ) such that x is an -equilibrium of the game with parameter p.
We can straightforwardly compute a Barvinok encoding of˜Nof˜ of˜N using a similar construction as in Section 5.1, with as an additional parameter.
Then finding the best parameter p amounts to solving the optimizationmin s. t. (x, p, ) ∈ ˜ N , x = ˜ x.From our discussion at the outset of Section 4 regarding optimizing linear functions over sets with Barvinok encodings, we observe that this can be solved in polynomial time (with a fixed number of actions) since the objective function is linear.
Instead of using -equilibria, we could try to minimize the distance betweeñ x and the set N (p) of PSNE given p, which is defined as the infimum of distances betweeñ x and points in the set N (p).
This yields the optimization problemmin d(x, ˜ x) s. t. (x, p) ∈ N,where d is the distance metric.
De Loera et al. [14] analyzed optimization problems of this form.
Here we derive some basic results.
If d is the 1 distance, i.e., d(x, ˜ x) = P a |xa − ˜ xa|, the problem can be formulated asmin X a da s. t. (x, p) ∈ N, xa − ˜ xa ≤ da, ∀a ∈ A, ˜ xa − xa ≤ da, ∀a ∈ A,which has a linear objective.
Since a Barvinok encoding of the feasible set of the above problem can be computed in polynomial time using a similar construction as in Section 5.1, the problem can be solved in polynomial time.
A similar argument shows that the version of the problem with the ∞ distance can be solved in polynomial time.
If d is the q distance for 1 < q < ∞, the problem can be formulated as one with a polynomial objective using similar techniques as above, and thus can be approximated in polynomial time using Theorem 10.
See [14] for a more detailed discussion which identifies a more general class of computationfriendly distance metrics.Another scenario is when the set N˜xN˜x has multiple points, and we would like to find the parameter p with the "best fit".
The distance betweeñx and N (p) is 0 for p ∈ N˜xN˜x , and is thus not useful here.
One approach is to find p such that˜xthat˜ that˜x is close to all points in N (p).
In other words, we choose the parameter p ∈ N˜xN˜x that minimizes the largest distance from˜xfrom˜ from˜x to any equilibrium in x ∈ N (p).
Formally, we need to solve This is an instance of the min-max optimization problem (16).
When d is the 1 distance or the ∞ distance, d(x, ˜ x) is piecewise linear in x, in which case the problem (17) can be solved using the branchand-bound algorithm as discussed in Section 5.2.
To avoid having to partition the set N˜xN˜x (which can have a complex shape), we can instead let p range from Q, and modify Step 3c of the algorithm so that whenever we have a region L ⊂ Q such that L ∩ N˜xN˜x = ∅, we set the lower bound for L to be ∞.
A common goal in mechanism design is to set the parameters of the game so as to achieve some desired properties in the resulting equilibria.
Here we consider a mechanism designer choosing the parameters n and p such that the resulting symmetric game has equilibria with good payoffs.
There are several ways to measure the "goodness" of an equilibrium.
Suppose the objective we are interested in is the payoff of the worst-off player given an equilibrium x, i.e., mina:x a >0 ua(x, p).
As discussed in Section 5.2, we need to specify how PSNE are selected for each game.
If we pick the best-case PSNE, this yields the optimization problem max THEOREM 15.
The optimization problem (18) can be solved in polynomial time.PROOF.
The problem can be rewritten as max w s. t. (x, n, p, w) ∈ S where S is the set  (x, n, p, w) : (x, n, p) ∈ N, umin ≤ w ≤ umax ∀a ∈ A : w ≤ ua(x, p) OR xa = 0 ff .
umin and umax are the minimum and maximum utilities possible in the game (they can be computed in polynomial time in fixed dimension).
We use a similar technique as in Section 5.1 to construct a Barvinok encoding of S in polynomial time.
Therefore, problem (18) can be solved in polynomial time.If we instead pick the worst-case PSNE, we have the optimization problem ua(x, p).
This is an instance of the problem (16), and we can apply the branchand-bound algorithm as discussed in Section 5.2.
THEOREM 16.
Problem (19) can be solved by the branch-andbound algorithm in worst-case exponential time.
Furthermore, steps 3b and 3c of the algorithm (the computation of bounds) require polynomial time.
for each subregion L of {(n, p) : 0 ≤ n ≤ B, n ∈ Z, p ∈ Q}, and step 3b corresponds to the subproblem ua(x, ˜ p)for any giveñ n and˜pand˜ and˜p.
(20) has a similar form as the best-case problem (18) and can be solved using the same approach as above in polynomial time.
To solve (21), we break the feasible set into regions: for each subset T of A, we have one region D(T ) = {x ∈ Dñ : xa > 0 for all a ∈ T, xa = 0 for all a ∈ T }.
There is a constant number of these regions and we solve the problem separately on each region.
Formally, we rewrite the problem as The innermost minimization can be solved in polynomial time since ua(x, ˜ p) is piecewise-linear.
Since the other minimizations are over sets of fixed size, this can be solved in polynomial time.
XA.
PROOF OF THEOREM 3 THEOREM 3.
For circuit symmetric games in which the number of actions is a fixed constant of at least three, the problem of determining the existence of PSNE is NP-complete.
PROOF.
The problem is in NP because to determine whether a configuration x is a PSNE, there are only O(m 2 ) possible deviations to check.We show NP hardness by reduction from CIRCUITSAT.
Given a CIRUITSAT problem instance C(y1, . . . , ym), we construct a circuit symmetric game with n = 2 m − 1 players and 3 actions {1, 2, 3} such that the game has a PSNE if and only if there exists an satisfying assignment of y1, . . . , ym.Given a configuration x = (x1, x2, x3), the utility functions u1(x),u2(x) and u3(x) are defined as follows:1.
If the binary representation of x1 correspond to a satisfying assignment for C, i.e.,2.
Otherwise:e) if xa = n for some action a, i.e., all players are playing a, then ua(x) = 0.
If there exists a satisfying assignment for C, then any configuration with the corresponding x1 is a PSNE because each player receives the maximum utility of the game.
If there does not exist a satisfying assignment, then the game's utilities are defined by condition 2.
We claim that this subgame under condition 2 does not have a PSNE.
Intuitively, the game can be thought of as a generalization of the 2-player Rock-Paper-Scissors game.
Formally, given a configuration of case 2a, a deviation from action 3 (with utility -2) to 1 or 2 is profitable.
Given a configuration of case 2b, a profitable deviation is from action 1 (utility -1) to 2 (utility 1 if the resulting configuration is of case 2b, utility 0 if the resulting configuration is of case 2e).
Similarly, given a configuration of case 2c, a profitable deviation is from action 2 to 3; and given a configuration of case 2d, a profitable deviation is from action 3 to 1.
Given a configuration of case 2e with e.g. x1 = n, a profitable deviation is to action 2, resulting in a configuration of case 2b.
Therefore all configurations have profitable deviations, thus the subgame does not have a PSNE.Finally, we observe that the utility functions described above can be formulated as circuits of the binary representation of x.
The size of the circuit symmetric game is linear in the size of the given CIRCUITSAT problem instance, and these utility functions can be constructed in polynomial time.
This concludes the reduction proof.
A. PROOF OF THEOREM 3 THEOREM 3.
For circuit symmetric games in which the number of actions is a fixed constant of at least three, the problem of determining the existence of PSNE is NP-complete.
PROOF.
The problem is in NP because to determine whether a configuration x is a PSNE, there are only O(m 2 ) possible deviations to check.We show NP hardness by reduction from CIRCUITSAT.
Given a CIRUITSAT problem instance C(y1, . . . , ym), we construct a circuit symmetric game with n = 2 m − 1 players and 3 actions {1, 2, 3} such that the game has a PSNE if and only if there exists an satisfying assignment of y1, . . . , ym.Given a configuration x = (x1, x2, x3), the utility functions u1(x),u2(x) and u3(x) are defined as follows:1.
If the binary representation of x1 correspond to a satisfying assignment for C, i.e.,2.
Otherwise:e) if xa = n for some action a, i.e., all players are playing a, then ua(x) = 0.
If there exists a satisfying assignment for C, then any configuration with the corresponding x1 is a PSNE because each player receives the maximum utility of the game.
If there does not exist a satisfying assignment, then the game's utilities are defined by condition 2.
We claim that this subgame under condition 2 does not have a PSNE.
Intuitively, the game can be thought of as a generalization of the 2-player Rock-Paper-Scissors game.
Formally, given a configuration of case 2a, a deviation from action 3 (with utility -2) to 1 or 2 is profitable.
Given a configuration of case 2b, a profitable deviation is from action 1 (utility -1) to 2 (utility 1 if the resulting configuration is of case 2b, utility 0 if the resulting configuration is of case 2e).
Similarly, given a configuration of case 2c, a profitable deviation is from action 2 to 3; and given a configuration of case 2d, a profitable deviation is from action 3 to 1.
Given a configuration of case 2e with e.g. x1 = n, a profitable deviation is to action 2, resulting in a configuration of case 2b.
Therefore all configurations have profitable deviations, thus the subgame does not have a PSNE.Finally, we observe that the utility functions described above can be formulated as circuits of the binary representation of x.
The size of the circuit symmetric game is linear in the size of the given CIRCUITSAT problem instance, and these utility functions can be constructed in polynomial time.
This concludes the reduction proof.
