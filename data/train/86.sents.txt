We give a general technique to obtain approximation mechanisms that are truthful in expectation.
We show that for packing domains, any α-approximation algorithm that also bounds the integrality gap of the LP relaxation of the problem by α can be used to construct an α-approximation mechanism that is truthful in expectation.
This immediately yields a variety of new and significantly improved results for various problem domains and furthermore, yields truthful (in expectation) mechanisms with guarantees that match the best known approximation guarantees when truthfulness is not required.
In particular, we obtain the first truthful mechanisms with approximation guarantees for a variety of multi-parameter domains.
We obtain truthful (in expectation) mechanisms achieving approximation guarantees of O(√ m) for combinatorial auctions (CAs), (1 +) for multi-unit CAs with B = Ω(log m) copies of each item, and 2 for multi-parameter knapsack problems (multi-unit auctions).
Our construction is based on considering an LP relaxation of the problem and using the classic VCG [33, 9, 18] mechanism to obtain a truthful mechanism in this fractional domain.
We argue that the (fractional) optimal solution scaled down by α, where α is the integrality gap of the problem, can be represented as a convex combination of integer solutions, and by viewing this convex combination as specifying a probability distribution over integer solutions, we get a randomized, truthful in expectation mechanism.
Our construction can be seen as a way of exploiting VCG in a computational tractable way even when the underlying social-welfare maximization problem is NP-hard.
Mechanism design studies algorithmic constructions under the presence of "selfish players" who hold the inputs to the algorithm.
The players are selfish in that they are interested in maximizing their own utility, and instead of revealing the true input, they may declare any false input that will increase their utilities.
The goal is to design algorithms that work well with respect to the true input, although this information is not publicly known.
Mechanism design approaches this goal by specifying along with the algorithm a pricing scheme that can be used to incentivize the players to reveal their true inputs.
A mechanism consists of an algorithm along with a pricing scheme, whose output specifies both an algorithmic outcome and prices to be charged to the players; the utility that a player derives is the difference between his value for the algorithmic outcome and the price that he is charged.
A mechanism is said to be truthful if a player always maximizes his utility by declaring his true input, regardless of what the other players declare.
Algorithmic mechanism design [29] deals with the study of efficiently computable truthful mechanisms.
The hope is that by obtaining a truthful mechanism, one can focus on the algorithmic question and set aside the strategic issue, however unfortunately not all algorithms lead to truthful mechanisms.
This is best exemplified when the underlying algorithmic problem is NP-hard.
Over the past several years, approximation algorithms have emerged as an effective algorithmic tool to deal with such computational intractability.
However these algorithms have found only limited applicability in the design of truthful mechanisms, especially in "multi-parameter domains", since many approximation algorithms and techniques do not guarantee certain properties of the algorithm that are required to ensure truthfulness.Our results.
In this paper we give a general technique to convert approximation algorithms into truthful mechanisms.
One of the most widely used and remarkably successful techniques in the design of approximation algorithms, is that of expressing a relaxation of the problem as a linear program (LP), and using this to design the approximation algorithm, either via LP rounding or via a primal-dual approach.
We show that for a variety of domains, any approximation algorithm for the algorithmic problem, that also bounds the integrality gap of the underlying LP relaxation, can be used to obtain a randomized mechanism for the corresponding mechanism design problem (i.e., where the inputs are held by selfish agents), that is truthful in expectation, and has performance guarantee matching that of the approximation algorithm.
Truthfulness in expectation means that a player always maximizes his expected utility by revealing his true input [1].
Our main result can be informally stated as follows.Informal Main Theorem For packing domains, given any α-approximation algorithm that proves an integrality gap of at most α for the "natural" LP relaxation, one can construct a randomized α-approximation mechanism that is truthful in expectation.A key feature of this result is its generality.
As mentioned earlier, there are a number of problem domains for which good approximation algorithms are known for the algorithmic problem, but in the mechanism design setting there are no known truthful and approximation mechanisms for the corresponding problem.
A common problem encountered is the fact that many commonly used approximation algorithms and techniques violate certain monotonicity properties which are required for truthfulness.
In cases where truthful and approximation mechanisms are known, the construction often involves clever ways of modifying or designing the approximation algorithm so as to satisfy these properties.
As a consequence, in various settings, the approximation guarantees provided by truthful mechanisms fall short of the known guarantees for the algorithmic problem when one does not require truthfulness.Our theorem not only yields new and improved results for large problem classes such as, (multi-unit) combinatorial auctions, graph routing problems, multi-unit auctions, but in doing so, it bridges the gap between known approximation results and the guarantees obtained by truthful mechanisms.
Moreover, it shows that one does not need to specifically tailor the algorithm to ensure truthfulness, and allows one to focus on the algorithmic part of the problem.We now consider the implications of our theorem, by concentrating on the multi-unit combinatorial auction (MUCA) problem, which has been widely studied [27,2,4,23,6,14].
In an MUCA, m items are to be allocated among n players and each player i has a true value v i (S) for every subset S of items.
The value functions are assumed to be non-decreasing, that is, v i (S) ≤ v i (T ) when S ⊆ T , and normalized, that is, v i (∅) = 0.
There are B ≥ 1 copies of each item.
An allocation is valid if every item is allocated to at most B players.
The goal is to find an allocation S 1 , . . . , S n of the items to the players that maximizes the sum i v i (S i ), called the social welfare.
When B = 1, the problem is called the combinatorial auction (CA) problem.The problem is computationally hard even when B = 1, and the valuations are "short", i.e., succinctly described.
The approximability threshold of this problem is known to be O(m 1 B+1 ) [4]; it is hard to approximate any better even when the players are single minded, that is, each player wants a single set S, so v i (T ) = v i (S) for T ⊇ S and 0 otherwise.
On the positive side various O(m 1 B+1 )-approximation algorithms exist [32,21,6], and these algorithms also prove a corresponding integrality gap result.
An interesting case is when B = Ω(log m) for which the integrality gap becomes (1 + ) where > 0 (more precisely B ≥ c()·log m where c(.)
is an increasing function of 1 ; we denote this simply as B = Ω(log m) in the sequel).
However truthfulness results are mostly known in restricted cases, and are worse.
The only result for general valuations is a truthful O(B · m 1 B−2 )-approximation mechanism due to Bartal et al. [4] when B ≥ 3.
More results are known for special cases: for single-minded players, a truthful O( √ m)-approximation is known when B = 1 [27], and Briest et al. [6] recently gave a truthful O(m 1 B )-approximation for B ≥ 1 (this does not give a (1 + )-guarantee when B = Ω(log m)).
Archer et al. [2] gave a randomized (1 + )-approximation mechanism for the "known" single-minded case when B = Ω(log m).
Babaioff et al. [3] consider the "single-value" case and (among other results) give an O(log 2 v max · √ m)-guarantee; Dobzinski et al. [14] obtain an O( √ m)-approximation for subadditive valuations.
In particular, the picture is very partial for non-single-minded players: no truthful approximation mechanism is known for general combinatorial auctions (B = 1), and the factors for large B are much worse than the approximation results.
1 Using our construction, and any of the known approximation algorithms, we obtain randomized, truthful in expectation mechanisms for all values of B, where the guarantees match the approximability threshold.
We summarize our results below for "short" valuations, where the valuations are succinctly describable and the underlying packing LP can be solved efficiently.
An important such class is k-minded players: a player desires one of k sets and specifies the value of each; both the sets and the values are private.
Section 4.1 gives other examples.
We use "truthful" below to denote "truthful in expectation".
Combinatorial auctions (B = 1) We give the first truthful mechanism for non-single-minded valuations, and get a O( √ m) guarantee.Multi-unit combinatorial auctions We get an O(m 1 B+1 )-approximation, truthful mechanism.
This improves upon the ratio of [4].
When B = Ω(log m) we get a (1 + )-guarantee for valuations more general than the "known" single-minded case, answering an open question in [2].
Multi unit auctions Here the m items are identical, and the valuation specifies a value for each quantity of goods received.
This generalizes Knapsack, which is the case when all players have a step function (i.e., are single minded), for which a truthful FPTAS was given by Briest et al. [6].
We give a truthful 2-approximation mechanism for multi-unit auctions, which is the first truthful, approximation mechanism for the multi-parameter case.Graph routing problems These include (see Section 4.3), for example, the edge-disjoint paths problem, where we have an underlying graph and each player desires a path between his source and target nodes.
This is a special case of MUCA and the previous guarantees hold.With arbitrary valuations, the input itself may have exponential length (in m) which therefore renders direct revelation mechanisms infeasible.
The problem remains "hard" even when one ignores computational issues: Nisan [28] shows that no algorithm with polynomial communication (in m, n) can attain an approximation ratio of m 1 2 − for any > 0 even when B = 1.
Blumrosen and Nisan [5] introduce the notion of a demand oracle, and show that this can be used to solve the associated LP using polynomial queries.
With such an oracle, our construction still works and yields iterative randomized, strategic mechanisms.
However, the iterative structure of the mechanism changes the solution concept to an ex-post Nash equilibrium, a well-documented phenomenon in the economics literature (see e.g., [10]).
So we now get truthfulness in expectation as an ex-post Nash equilibrium which roughly means the following: regardless of the other players' valuations, if they all answer truthfully, then my best response is to answer truthfully.
We get the same guarantees as before, using ex-post Nash equilibrium as the solution concept.Our construction.
At a high level, our construction is quite intuitive and easy to describe.
Our starting point is the classic VCG result [33,9,18], which provides a truthful mechanism for the underlying algorithmic problem of maximizing the social welfare, provided that the algorithmic problem can be solved exactly.
However, in our case and in many others, this problem is NP-hard, and approximation algorithms need not give truthfulness.
Our first step towards handling this problem is to move to a fractional domain, and to consider a fractional mechanism that is allowed to return a fractional feasible solution to the LP relaxation of the problem.
In this new domain, since one can solve the LP in polynomial time, we can use VCG to obtain a truthful fractional mechanism.
Moreover, since we are in a fractional domain, we can always scale down both the optimal LP solution and the VCG prices by α, and this clearly does not affect truthfulness.
Let x * be an optimal LP solution.
Suppose that the integrality gap of the LP relaxation is α ≥ 1 and we have an algorithm that "verifies" this gap.
At the heart of our construction is a procedure that takes such an α-approximation algorithm and returns in polynomial time a convex decomposition of x * α into polynomially many integer solutions, that is, it returns λ l values such that x * α = l∈I λ l x l , where {x l } l∈I is the set of all integer solutions, λ l ≥ 0, λ l = 1 (with only polynomially many positive λ l ).
We show this by strengthening the decomposition technique of Carr and Vempala [7].
Now one can view this convex combination as specifying a probability distribution over the integer solutions, where exactly one solution x l is selected with probability equal to λ l .
A simple but powerful observation, is that the randomized mechanism which returns an integer solution according to this distribution, and sets prices in such a way that the expected prices are the VCG prices scaled down by α, is truthful in expectation.
Furthermore, the expected social welfare of the solution returned is exactly the value of the LP-optimum scaled by α; thus we get an α-approximation guarantee.
The crucial step here is the decomposition procedure which allows us to move from the truthful VCG fractional mechanism to a randomized, truthful in expectation mechanism.A notable feature is the generality and simplicity of the construction.
In essence, we give a way to leverage VCG in a computationally effective manner using approximation algorithms, while maintaining truthfulness.
Thus we reap the benefits of both: we get the versatility of the VCG as a mechanism design tool for devising truthful mechanisms, and the computational tractability of approximation algorithms.
As mentioned earlier, many previous results specifically tailor the algorithm to obtain truthfulness.
For example, Archer et al. [2] consider an LP-relaxation of MUCA with Ω(log m) copies and designed a randomized rounding procedure to obtain a (1 + )-approximation mechanism that is truthful in expectation and also with high probability.
Briest et al. [6] showed how to convert certain FPTAS's into truthful ones, and also gave primal-dual algorithms for some CAs; both results involve tailoring the algorithm so as to ensure truthfulness, but yield deterministic mechanisms.
Our construction shows that if one allows randomization, then such "algorithmic artistry" is not required to ensure truthfulness, and allows the algorithm design to concentrate on the approximation component of the problem.Organization of the paper.
We begin in Section 2 by describing the mechanism-design setup, and collecting some basic definitions and facts.
Section 3 describes our general method of designing a truthful mechanism based on the LP relaxation of the problem, and Section 4 applies our technique to a variety of problems.
We conclude in Section 5 with a brief discussion of some recent results, and a discussion of how our ideas can be adapted to yield (partial) results also for covering problems.
In the basic mechanism design setup, we have n players, and a set A of possible outcomes.
Each player has a type given by a valuation function v i : A → R ≥0 , where v i ∈ V i and V i is the set of all valid types of player i. Let V = V 1 × · · · × V n denote the space of all players' valid types.
For example, in combinatorial auctions we have m items; A is the set of all allocations (S 1 , . . . , S n ) of items to players with S i ∩ S j = ∅ (assuming a single copy of each item), and v i : A → R is a function that (a) assigns the same value to any two outcomes that allocate the same subset to player i, so one can view v i as specifying a value for each set S of items, (b) satisfies v i (∅) = 0, and (c) is monotone, i.e., v i (S) ≤ v i (T ) whenever S ⊆ T .
We use v to denote the tuple (v 1 , . . . , v n ), and v −i to denote the tuple (v 1 , . . . , v i−1 , v i+1 , . . . , v n ) that excludes i's valuation.
Similarly V −i = j =i V j .
A (direct revelation) mechanism consists of an allocation rule (that is, an algorithm) f : V → A, and a pricing scheme p i : V → R for each player i. Each player i reports a type v i (possibly deviating from his true type), and the mechanism computes the outcome f (v) and charges price p i (v) to player i. Throughout we use v i to denote the true type of player i.
The utility that the player i derives by declaring type v i isv i (f (v i , v −i )) − p i (v i , v −i ), and each player aims to maximize his own utility.
A desirable property for a mechanism to satisfy is truthfulness, wherein each player maximizes his utility by reporting his true type.Definition 2.1 (Truthfulness) A deterministic mechanism (f, p) is truthful if for any player i, any v −i ∈ V −i , and anyv i , v i ∈ V i we have v i (f (v i , v −i )) − p i (v i , v −i ) ≥ v i (f (v i , v −i )) − p i (v i , v −i ).
A mechanism could be randomized, that is, it could flip coins to determine f (v) and p i (v), in which case f (v) and p i (v) are random variables, and a player's utility is also a random variable.
For randomized mechanisms, we can consider the notion of truthfulness in expectation [1].
v i , v i ∈ V i , E v i (f (v i , v −i )) − p i (v i , v −i ) ≥ E v i (f (v i , v −i )) − p i (v i , v −i ) .
Thus, if a mechanism is truthful in expectation then the expected utility of a player is maximized when he declares his true type v i (regardless of what others declare).
A randomized algorithm is often viewed as specifying a probability distribution over deterministic algorithms.
It will be useful to view a randomized mechanism in a similar way.
For an outcome set A, define the unit simplex ∆ A = {λ ∈ R |A| :a∈A λ a = 1 and λ a ≥ 0 for all a}.
Given any randomized mechanism M R = (f R , p R ) with outcome set A, we can define a deterministic mechanism M D with outcome set ∆ A , which outputs the probability distribution of M R , and charges prices that are the expected prices of M R .
To define M D precisely, we need to extend the domain V i to include values for outcomes in ∆ A .
We do this in the obvious way: for anyv i ∈ V i , define v i ({λ a } a∈A ) = a∈A λ a v i (a).
We abuse notation and use v i to denote both a valuation in V i and its corresponding extension.
Now we can define M D as follows:1.
Allocation rule: Define the function f D by f D (v) = {λ a } a∈A where λ a = Pr[f R (v) = a],2.
Pricing scheme: For each player i, and valuation vector v, setp D i (v) = E p R i (v) .
We call M D the deterministic support mechanism of M R .
Observe that the criterion for truthfulness of M D is exactly the criterion for the truthfulness in expectation of M R .
Claim 2.3 A randomized mechanism M R is truthful in expectation iff its support mechanism M D is truthful.The above claim gives a characterization of randomized mechanisms that are truthful in expectation which we use to argue the truthfulness in expectation of the randomized mechanisms we construct.Converting a support mechanism to a randomized mechanism.
Our algorithms will actually construct a deterministic support mechanism.
We show how to construct, from a (deterministic) support mechanism M D , a corresponding randomized mechanism M R (whose support mechanism is M D ) that preserves various properties of M D .
Let M D have outcome set ∆ A , so M R will have outcome set A.
The allocation rule is easy to specify: v)) for any player i, any true type v i ∈ V i and any v ∈ V .
Since the prices p R i (v) will be set so thatf R (v) ∈ A is a random variable with distribution f D (v), i.e., we output f R (v) = a with probability λ a where f D (v) = {λ a } a∈A .
So E v i (f R (v)) = v i (f D (E p R i (v) = p D i (v) (because M D hasto be the support mechanism of M R ), the expected utility of player i is also preserved in going from M D to M R .
One obvious way to set the prices is to deterministically set p R i (v) = p D i (v) for every v, but the resulting randomized mechanism could violate individual rationality.
Individual rationality requires that for every player i, i's utility be non-negative when he declares his true type, regardless of the other players' declarations.
A randomized mechanism, satisfies individual rationality if for every coin toss, the utility of every player i is non-negative when he declares his true type.
Setting p R i (v) = p D i (v) may violate individual rationality even if M D is individually rational, since there could be coin tosses where a player receives nothing but pays a positive amount.
Perhaps the easiest way to maintain individual rationality is to set pricep R i (v) = v i (a) · p D i (v) v i (f D (v)) if v i (f D (v)) > 0 and outcome a results (i.e., f R (v) = a), and setp R i (v) = 0 if v i (f D (v)) = 0 (= p D i (v)).
Observe that p R i (v i , v −i ) ≤ v i (f R (v i , v −i )) for any coin toss since p D i (v i , v −i ) ≤ v i (f D (v i , v −i )), and clearly E p R i (v) = p D i (v).
We will be interested in approximating the (optimum) social welfare with respect to the players' true types, which is defined as max a∈A i v i (a).
The above construction of M R from M D preserves truthfulness (in expectation) by Claim 2.3, individual rationality, and the expected value received by a player.
Thus we get the following theorem.Theorem 2.4 Given an individually rational, truthful, deterministic support mechanism that computes an α-approximation to the social welfare and has only polynomially many λ a s that are positive, one can obtain in polynomial time an individually rational randomized mechanism that is truthful in expectation, and computes an α-approximation to the social welfare in expectation.Given the above theorem, we now focus on the design of a deterministic support mechanism that outputs a probability distribution and prices, with the desired properties.
In this section we describe a general technique to obtain randomized mechanisms that are truthful in expectation, and achieve approximation guarantees for the social welfare that, in several cases, match the guarantees that are achieved without worrying about truthfulness.
To make our results concrete, we describe our technique for the specific setting of combinatorial auctions (CAs), although our results also hold for other packing problems when the polytope is public knowledge and the objective function is linear.
In Section 4, we consider a variety of applications and use our methods to obtain truthful (in expectation) mechanisms that approximate the social welfare.We can formulate the combinatorial auction problem as an integer program (IP) where we have a variable x i,S ∈ {0, 1} for each player i and set S = ∅ that indicates if i receives set S. Relaxing the integrality constraints to x i,S ≥ 0 gives the following LP relaxation.max i,S =∅ v i (S)x i,S (CA-P) subject to S =∅ x i,S ≤ 1 for each player i (1) i S:j∈S x i,S ≤ 1 for each item j (2) x i,S ≥ 0 for each i, S.Here v i is i's reported valuation which satisfies v i (S) ≤ v i (T ) whenever S ⊆ T (and implicitly v i (∅) = 0).
Constraints (1) state that each player is assigned at most one set, and (2) ensures that each item j is given to at most one player.
Our approximation guarantee will depend on the integrality gap of (CA-P), that is, the ratio between the values of the optimal fractional and integer solutions.
Our main theorem is the following.Theorem 3.1 Given an α-approximation algorithm, that also proves an integrality gap of at most α for (CA-P), one can construct a randomized, individually rational, α-approximation mechanism that is truthful in expectation.We first give an overview of the construction.
A classic result in mechanism design is the VCG family of mechanisms [33,9,18], which shows that if the underlying algorithmic problem of maximizing the social welfare, given the players' reported types, called the winner determination problem (WDP) for CAs, can be solved exactly, then one can construct a truthful mechanism that optimizes the social welfare (with respect to the true types).
However this algorithmic problem is often NP-hard, and it is known that an approximation algorithm for this problem need not necessarily give a truthful mechanism.We move to a fractional domain and consider a fractional mechanism that is allowed to return a fractional feasible solution to (CA-P).
With this outcome set, one can solve WDP exactly in polynomial time since one can solve (CA-P) (see Section 4.1), and therefore use VCG to obtain a truthful fractional mechanism M F which returns allocation x * , the optimal solution to (CA-P), and prices p F .
Since we are in a fractional domain, we can scale down both the allocation and prices by some α ≥ 1 without affecting truthfulness.
We give a procedure which takes an α-approximation algorithm that proves an integrality gap of α for (CA-P), and returns in polynomial time a convex decomposition of x * α into polynomially many integer solutions, i.e., λ l values such that x * α = l∈I λ l x l , where {x l } l∈I is the set of all integer solutions to (CA-P), λ l ≥ 0, λ l = 1 (with only polynomially many λ l > 0).
This is obtained by strengthening the decomposition technique of Carr and Vempala [7].
This is the crucial step, using which we convert the truthful fractional mechanism M F to a truthful deterministic support mechanism M D that outputs {λ l } l∈I as the allocation and p F α as the prices, while losing a factor of α in the social welfare (and maintaining individual rationality).
Now we use Theorem 2.4 to obtain a randomized, truthful in expectation mechanism that achieves an α-approximation to the social welfare.
We summarize the construction below.The truthful α-approximation support mechanism.
Given valuations v 1 , . . . , v n ; an α-approximation algorithm A for WDP that shows an integrality gap of α for (CA-P).1.
Use VCG to get a truthful fractional mechanism M F that outputs allocation f F (v) = x * (v), the optimal solution to (CA-P), and prices p F (v).2.
Use A to obtain the convex decomposition x * α = l∈I λ l x l with only polynomially many positive λ l .
M D = (f D , p D ) with f D (v) = {λ l } l∈I and p D (v) = p F (v)α (and use Theorem 2.4 to get the desired randomized mechanism).
Thus we show that any approximation algorithm for maximizing social welfare, that also shows an integrality gap guarantee, can be plugged in to get a randomized truthful mechanism with the same approximation guarantee.
Thus, we are able to combine the versatility of VCG as a mechanism design tool for devising truthful mechanisms, and the computational tractability of approximation algorithms.Details of the construction We now describe the construction in detail.
Let P denote the feasible region of (CA-P), and Z(P) ⊆ P be the set of integer solutions of (CA-P).
The integrality gap of P is defined asIG P = sup v=(v 1 ,...,vn) max x∈P i,S v i (S)x i,S max x∈Z(P) i,S v i (S)x i,Swhere the v i s are valuations with v i (∅) = 0, v i (S) ≤ v i (T ) for S ⊆ T .
Our mechanisms require an approximation algorithm that "verifies" an integrality gap of (at most) α, by which we mean that for any valuation vector v the algorithm produces an integer solution of value at least 1 α times the LP-optimum.
We emphasize that the supremum is taken over all valuations v in evaluating the integrality gap, and an algorithm that verifies this gap must consequently work for all valuations.
To clarify this further, whereas we may sometimes consider (designing mechanisms for) a structured class of valuations V , the integrality gap IG P is determined only by the polytope P, and to exploit the structure of V we need to be able to encode this structure into the polytope P.
In particular, an approximation algorithm that specifically proves a guarantee for class V using the optimum of (CA-P) as an upper bound (e.g., the 2-approximation algorithm for submodular valuations in [26]) does not suffice to bound or verify the integrality gap IG P .
The fractional mechanism defined will have outcome set P.
We extend the domain V i to assign values to fractional solutions x ∈ P: for any v i ∈ V i , we define v i (x) = S v i (S)x i,S .
We again abuse notation and use v i to denote both the original valuation and its extension.
We now define precisely the fractional VCG mechanism which is simply VCG in this fractional domain.The fractional VCG mechanism M F = (f F , p F ) is defined as follows: the allocation rule is given by f F (v) = x * (v) where x * (v) is an optimal solution to (CA-P) for valuation v = (v 1 , . . . , v n ); the prices arep F i (v) = − i =i v i (S)x * i ,S + h i (v −i ), where h i (v −i ) is any function that does not depend on v i .
As usual with VCG mechanisms, one can set h i (v −i ) = i =i v i (S)y * i ,S above, where y * is the optimal fractional solution when we constrain x i,S = 0 for all S, so as to ensure that that players have non-negative utility (individual rationality), and players always have a non-negative payment (they never receive money).
We will assume these prices from now on.
It is a classic result that the VCG mechanism (family) is truthful, i.e., satisfies the criterion in Definition 2.1.
For any α ≥ 1, we can define an α-scaled fractional VCG mechanism that outputs the outcome f F (v)α and prices p F (v) α .
For any v ∈ V and v i ∈ V i , since v i f F (v) α = v i (f F (v)) α (because v i (x)is linear in x), the α-scaled fractional VCG mechanism is also clearly truthful.
Suppose that we can express x * (v) α as a convex combination l∈I λ l (v)x l of integral solutions whereλ l (v) ≥ 0, l λ l (v) = 1.
(Observe that α must be at least IG P since such a decomposition of x * (v) α implies that there exists an integer solution x l of value at least 1 α · i v i (x * (v)).)
One then obtains a deterministic support mechanism M D with allocation rule f D (v) = {λ l (v)} l∈I and pricesp D i (v) = p F i (v)α .
Before detailing the decomposition procedure, we show that M D is a truthful, α-approximation mechanism.Lemma 3.2 Mechanism M D is truthful and computes an α-approximation to the social welfare.Proof : Essentially, we show that M D is equivalent to the α-scaled fractional VCG mechanism and retains all its properties.
For any declared valuation v = (v 1 , . . . , v n ), the value player i gets inM D is exactly v i (f F (v)) α since v i (f D (v)) = l∈I λ l (v)v i (x l ) by definition, which is equal to v i ( l∈I λ l (v)x l ) = v i x * (v) α = v i (x * (v)) α .
Since the prices are also scaled by α, truthfulness follows from the truthfulness of M F .
Truthfulness also then implies the approximation guarantee since i v i (x * (v)) is an upper bound on the optimum.
Note that M D satisfies individual rationality and no player is paid by the mechanism.Using Theorem 2.4 we can move from M D to a randomized mechanism, while maintaining truthfulness, the approximation ratio, and individual rationality.
Thus we obtain Theorem 3.1.
The crucial property that we require here is that for any v i ∈ V i , and any v ∈ V ,l∈I λ l (v)v i (x l ) = v i (x * (v)) α .
A sufficient condition for this is that v i (x) be a linear function of x and that x * (v) α be decomposable as l∈I λ l (v)x l , which is what we use in our construction.
We now prove the main decomposition lemma: we show that an α-approximation algorithm A that proves an integrality gap of α for (CA-P) can be used to express any fractional solution to (CA-P), scaled down by α, as a convex combination of integer solutions.
The proof is based on the method outlined in [7] where it is shown that for minimization problems, if the integrality gap is β ≥ 1, then for any fractional solution, one can obtain a convex combination of integer solutions such that β times the fractional solution dominates (i.e., is component-wise greater than) the convex combination.
We need to modify their argument so as to ensure that we get an exact decomposition (for our maximization problem), which is crucial for our truthfulness argument to hold.
For general maximization LPs, one cannot necessarily get such an exact decomposition of the scaled fractional solution, but only one that dominates the scaled solution.
We leverage the packing structure of the problem to get an exact decomposition.
Recall that P denotes the feasible region of (CA-P) and Z(P) = {x l } l∈I is the set of all integer solutions to (CA-P) where I is an index set for the integer solutions.
We exploit the following property, which we call the "packing property": if x ∈ Z(P) and y ≤ x is integral then y ∈ Z(P).
Fix any x * ∈ P such that E = {(i, S) : x * i,S > 0} has size polynomial in m, n. Any basic solution to (CA-P) satisfies this since by standard polyhedral theory such a solution has at most m + n non-zero entries.
We solve the linear program (P) given below to obtain the convex decomposition.min l∈I λ l (P) s.t. l λ l x l i,S = x * i,S α for all (i, S) ∈ E (3) l λ l ≥ 1(4)λ l ≥ 0 for all l ∈ I. max 1 α · (i,S)∈E x * i,S w i,S + z (D) s.t. (i,S)∈E x l i,S w i,S + z ≤ 1 for all l ∈ I (5) z ≥ 0 w i,S unconstrained for all (i, S) ∈ E.The primal (P) has an exponential number of variables, so we consider its dual (D).
The dual has an exponential number of constraints and a variable w i,S for each constraint (3), and one can view w as a valuation.
We show that a separation oracle for the dual can be obtained by using algorithm A with valuation w, so the ellipsoid method can be used to solve (D) and hence (P) (we also show that the optimal value is 1).
One potential problem encountered is that the w i,S values could be negative, whereas A is only designed to handle non-negative valuations.
However it is easy to argue that one can instead use A with the non-negative valuation w + given by w + i,S = max(w i,S , 0), and this yields a separation oracle.
(Alternatively, one could first compute λ l values such that l∈I λ l x l ≥ x * α , so the dual variables w i,S are now non-negative, and then use the packing property to modify these λ l values and get an exact decomposition.)
Claim 3.3 Let w = {w i,S } (i,S)∈E be any weight vector.
Define w + by w + i,S = max(w i,S , 0).
Given any integer solutionˆxsolutionˆ solutionˆx ∈ Z(P), one can obtain x l ∈ Z(P) such that (i,S)∈E x l i,S w i,S = (i,S)∈Eˆx∈Eˆ ∈Eˆx i,S w + i,S .
Proof : Set x l i,S = ˆ x i,S if w i,S ≥ 0 and 0 otherwise.
Clearly,(i,S)∈E x l i,S w i,S = (i,S)∈Eˆx∈Eˆ ∈Eˆx i,S w + i,S .
Since x l ≤ ˆx is integral, by the packing property x l ∈ Z(P).
Claim 3.4 For any weight vector w = {w i,S } (i,S)∈E , one can compute in polynomial time x l ∈ Z(P) such that (i,S)∈E x l i,S w i,S ≥ 1 α · max x∈P (i,S)∈E x i,S w i,S .
Proof : Let O * = max x∈P (i,S)∈E x i,S w i,S .
Let w + be as defined in Claim 3.3.
Clearly w + is component-wise greater than w and i,S x i,S w + i,S = (i,S)∈E x i,S w + i,S for any x.
If A only expects a non-negative valuation as input, then we can simply run A on w + to get an integer solutionˆxsolutionˆ solutionˆx such that (i,S)∈Eˆx∈Eˆ ∈Eˆx i,S w + i,S ≥ O * α .
But in our case A requires a valuation that satisfies monotonicity, so we cannot directly feed it w + .
However one can simply "monotonize" w + : for each i define valuatioñ v i by˜v by˜ by˜v i (S) = max T ⊆S:(i,T )∈E w + i,T where the maximum is 0 if there is no T ⊆ S such that (i, T ) ∈ E.
We use A on valuatioñ v to compute an α-approximate integer solutioñx, so i,S ˜ x i,S ˜ v i,S ≥ O * α since˜vsince˜ since˜v i,S ≥ w + i,Sfor every (i, S).
It is easy to transform˜xtransform˜ transform˜x tô x so that Proof : We first show that the optimal value of (D), and hence of (P) by strong duality, is exactly 1.
So an optimal solution to (P) yields the convex decomposition.
Setting z = 1, w i,S = 0 for all (i, S) ∈ E gives a feasible solution with value 1.
We claim that any feasible solution (w, z) has value at most 1.
Suppose 1 α · (i,S)∈E x * i,S w i,S + z > 1.
Using Claim 3.4 one can find an integer solution x l such that (i,S)∈E x l i,S w i,S ≥ 1 α · (i,S)∈E x * i,S w i,S > 1 − z, contradicting the feasibility of (w, z).
The above argument shows that we can add the inequality 1 α · (i,S)∈E x * i,S w i,S + z ≥ 1 to the dual program (D) without altering anything.
We will run the ellipsoid method on (D) to identify a dual program with a polynomial-size set of inequalities (5), that is equivalent to (D).
These inequalities will be the violated inequalities returned by the separation oracle during the execution of the ellipsoid method, that are used to cut the ellipsoid.
Taking the dual of this compact program gives a primal program with a polynomial number of variables and constraints which we can solve to get λ l values that sum to 1; this gives the desired decomposition.
The separation oracle that we use is as follows: at a point (w, z), if 1 α · (i,S)∈E x * i,S w i,S + z > 1, then we can find an x l and a corresponding violated constraint using Claim 3.4; otherwise we use the half space 1 α (i,S)∈E x * i,S w i,S + z ≥ 1 to cut the current ellipsoid.
(i,S)∈Eˆx∈Eˆ ∈Eˆx i,S w + i,S = i,S ˜ x i,S ˜ v i,S .
We setˆxsetˆ setˆx i,S = ˜ x i,S if (i, S) ∈ E or˜x In multi-unit combinatorial auctions (MUCAs) we have m items with B copies of each item, and n players, and each player desires at most one copy of an item.
With B = 1 we get the regular combinatorial auction.
The LP relaxation for MUCA is similar to (CA-P), but the RHS of constraints (2) changes to B.
The integrality gap of this relaxation is a function of B: (i) the integrality gap is O(m 1 B+1 ) for any B ≥ 1; (ii) the integrality gap is (1 + ) when B = Ω(log m) (more precisely B ≥ c() · log m where c(.)
increases with 1 ) for any > 0.
Moreover there are algorithms that "verify" this gap, e.g., the derandomization of "standard" randomized rounding [32], the rounding approach of [21], or the recent primal-dual algorithm of [6].
We can use the above approximation algorithms to construct randomized, strategic, approximation mechanisms for CAs and MUCAs, with arbitrary valuation functions.
There are two (linked) issues here: (1) the representation of the input, and (2) the computational effort needed to solve (CA-P).
With general valuations, representation becomes an issue since the length of the valuation can be exponential in m, which therefore also renders direct revelation mechanisms intractable.
Two ways to address this have been considered: (a) assuming that we have "short" valuations that can be succinctly described (with a suitable bidding language), thus allowing for direct revelation mechanisms; (b) assuming that we have some oracle access to the valuation, so the mechanism now needs to be an iterative mechanism.
It is well known in the economics literature that the issue of "one-shot" vs. iterative mechanisms also affects truthfulness properties.
To specify our results precisely and address (1) and (2), we consider these two settings separately.Short valuations.
We first consider the case when the valuations are succinctly describable.
An important such valuation class is that of single-minded bidders where each player wants just one set (or any superset) and specifies that set along with its value.
More generally players could specify k ≥ 1 subset-value pairs (S 1 , w 1 ), . . . (S k , w k ), which yields two well-studied classes of valuations; (a) an XOR valuation where the player desires one of these k subsets (the "k-minded case"), so v(T ) = max i:S i ⊆T w i ; (b) an OR valuation where the player is willing to receive any collection of disjoint sets from S 1 , . . . S k and the values add up, so v(T ) = max disjoint setsS i 1 , . . . , S i ⊆ T v(S i 1 ) + · · · + v(S i ).
It is easy to see that for both these classes of valuations, one can devise a demand oracle for the valuation from the above description with running time polynomial in k for an XOR valuation, and exponential in k for an OR valuation.
Hence, one can solve the LP (CA-P) in polynomial time [5] (see also "General valuations" below) in the following two cases: (a) XOR valuations, when k = poly(m, n); and (b) OR valuations, when k = O log(m + n) .
We use "short" valuations below to encode both, succinctness of descriptions, and the requirement that (CA-P) can be solved in time polynomial in m and n. Theorem 4.1 For MUCAs with "short" valuations and B copies of each item, we obtain randomized, truthful in expectation mechanisms with the following approximation factors: (i) a factor of O(m 1 B+1 ) for any B ≥ 1; and (ii) a (1 + )-guarantee for any > 0 when B = Ω(log m).
We obtain the first truthful mechanisms with non-trivial approximation guarantees for all values of B, and with short valuations, improve upon the deterministic O(B · m 1 B−2 )-approximation ratio of Bartal et al. [4] for general valuations.
In particular, when B = Ω(log m) we get the first truthful (in expectation) (1 + )-approximation mechanism for short multi-parameter valuations, answering an open question in [2] about devising mechanisms for valuations more general than the "known" single-minded case (i.e., the sets are public).
More work has been directed toward the single-minded case defined in [27] who gave a deterministic mechanism with an O( √ m) guarantee when B = 1.
Archer et al.[2] obtained a (1 + )-approximation mechanism when B = Ω(log m), for the "known" single-minded case that is truthful both in expectation and with high probability.
Recently, Briest et al. [6] gave a deterministic O m 1 B -approximation mechanism for the unknown single-minded case.
We give a unified way to obtain randomized, truthful in expectation mechanisms and get approximation guarantees that match the known inapproximability results [4].
General valuations.
We now consider the setting with general valuations with an oracle access to the valuations.
Two kinds of oracle access were considered by [30,5]: value queries, where the query asks for the value of a set S, and demand queries, where the query specifies item prices p 1 , . . . , p m , and asks a player i to return a subset S that maximizes v i (S) − j∈S p j .
Demand queries are very natural from an economic perspective and are known to be strictly more powerful than value queries [30,5].
Blumrosen and Nisan [5] show that LP (CA-P) can be solved with a polynomial number of demand queries using the ellipsoid method, since they yield a separation oracle for the dual of (CA-P).
This addresses issue (2).
As mentioned previously, direct revelation mechanisms become ineffective with general valuations.
Using Theorem 3.1 we can construct strategic, iterative mechanisms for general valuations using demand queries.
It is well known in the economics literature (see e.g., [10]) that moving from direct-revelation to iterative mechanisms often leads to a weakening of the solution concept, from dominant strategies to ex-post Nash equilibrium.
Our mechanisms yield truthfulness in expectation as an ex-post Nash equilibrium, which means the following: for any player i, and any type profile v −i ∈ V −i of the other players, if the other players act according to their types in this profile in the iterative mechanism, then i's best response (for maximizing expected utility) is to be truthful.
In particular, this means that truthful revelation is a Nash equilibrium with no ex-post regret, that is, even if a player were told beforehand the types that the other players would use to act in the iterative mechanism, he would have no incentive to deviate from his truth-telling strategy.
As an example, consider the regular second-price auction with two players with the following iterative flavor: player X bids first and then player Y states his bid; the player with highest bid wins and pays the second highest bid value.
Truthfulness fails to be a dominant strategy.
Suppose Y chooses the strategy "if X bids above 5, then I will say 20, otherwise I will say 2", then, if X's true value is higher than 5, his best response is to declare 5.
However truthfulness is still an ex-post Nash equilibrium: if Y fixes any private value and bids that, then regardless of Y 's private value X's best response is to tell the truth.
Very little is known about truthful and approximation mechanisms with general valuations.
For B ≤ 2 and general valuations, no strategic mechanisms were known previously.
Bartal et al. [4] gave a deterministic, truthful O(B · m 1 B−2 )-approximation for general valuations using demand oracles, and Dobzinski et al. [14] gave a deterministic, truthful O( √ m)-approximation for B = 1 and subadditive valuations using value oracles.
We improve upon the performance guarantee of [4] for all B, and get the same guarantee as [14] for general valuations but using demand oracles, randomization, and a different solution concept.
In a multi-unit auction, there are m identical items.
and each player i has a value v i (j) for getting j items, 1 ≤ j ≤ m, where the v i (.)
s are non-decreasing functions.
The goal is to distribute the m items, allocating x i items to player i, so as to maximize i v i (x i ).
This problem is solvable in time polynomial in m, so if each v i (j) is explicitly specified then one can implement VCG.
We will consider valuations that are specified more succinctly, e.g., step functions, piecewise linear functions with a "small" number of pieces, XOR, OR valuations or their combinations etc., or valuations given via an oracle access.
We want mechanisms that run in time polynomial in n and the size of the specification.If all value functions are step functions (single-minded players), then this is exactly the knapsack problem, for which Briest et al. [6] gave a truthful FPTAS.
Kothari et al. [22] gave an "approximately truthful" FPTAS for the special case of "marginal decreasing valuations".
We obtain the first truthful, approximation mechanisms for general multi-unit auctions (i.e., multi-parameter knapsack problems).
We consider the following natural LP relaxation for this problem:max i,j v i (j)x ij subject to j x ij ≤ 1 for all i; i,j j · x ij ≤ m; x ij ≥ 0 ∀i, j .
(KN-P)Here variable x ij indicates if player i gets j items.
When the v i (.)
s are step functions this LP reduces to the standard LP relaxation for Knapsack, for which a simple greedy algorithm proves an integrality gap of at most 2 (see, e.g., [20]).
We give a greedy algorithm that generalizes this algorithm and bounds the integrality gap of (KN-P) by 2.
Using this, we obtain the first truthful, approximation mechanisms for non-single-minded players and get a guarantee of 2.
Lavi et al. [23] showed that with two players, if all items must always be allocated, then with OR valuations, no deterministic truthful mechanism can obtain an approximation ratio better than 2.
As in Section 4.1, "short" valuations will mean that the valuation is given succinctly and we can solve the LP in polynomial time.
Since items are identical, a demand oracle here fixes a price p ≥ 0 and asks player i to return a quantity j that maximizes v i (j) − p · j.Theorem 4.3 There is a randomized, 2-approximation mechanism for multi-unit auctions, which (i) is truthful in expectation for "short" valuations; and (ii) has truthfulness in expectation as an ex-post Nash equilibrium for general valuations with demand oracles.We now give the greedy algorithm which proves an integrality gap of 2 for (KN-P).
Let OPT be the value of the LP-optimum.
Define the marginal value function of i given quantity j, v i (·|j), as follows: for anyx ≥ 0, v i (x|j) = v i (x + j) − v i (j).1.
Initialize M ← m. Each player i starts off with q i = 0 items.
While M > 0 we repeatedly do the following: (a) find i * , j * that maximizesv i (j|q i )/j; (b) if j * ≤ M , set q i * ← q i * + j * (i.e., allocate j * more items to i * ); (c) decrement M by j * .2.
Let Greedy = i v i (q i ) be the value of this allocation, and let Max = max i v i (m).
If Max > Greedy, allocate all items to the player with the maximum v i (m), otherwise return (q 1 , . . . q n ) as the allocation.
Proof : We will exhibit a feasible dual solution with value at most twice the value obtained by the algorithm, hence the claim will follow.
The dual program ismin i α i + m · β subject to α i ≥ v i (j) − j · β ∀i, j; β, α i ≥ 0 ∀i .
Suppose the algorithm stops at the end of iteration s + 1, that is, after M it is decremented in iteration s + 1, we have M ≤ 0.
Let (i l , j l ) be the (i * , j * ) pair in iteration l for l = 1, . . . , s + 1.
Recall that q i is the number of items allocated to player i. Let q i,k denote the quantity k l=1:i=i l j l , and letp i = q i,s .
So s+1 l=1 j l = i p i + j s+1 ≥ m.Note that p i ≤ q i , and it could be that p i < q i -this can happen only if s+1 l=1 j l = m and i = i s+1 , so q i = p i + j s+1 .
We will exhibit a feasible dual solution of value at most 2 max i v i (p i ), Max .
Define β = v i s+1 (j s+1 |q i s+1 )/j s+1 , and α i = v i (p i ) − p i · β for every i. Before verifying feasibility, we show that this proves the lemma:i α i + m · β ≤ i (α i + p i · β) + j s+1 · β = i v i (p i ) + v i s+1 (j s+1 |q i s+1 ) ≤ 2 max i v i (p i ), Max .
Consider any iteration l = 1, . . . , s. Let i = i l , q = q i,l−1 and i = i l+1 , q = q i ,l .
We claim that v i (j l |q)/j l ≥ v i (j l+1 |q )/j l+1 .
This is clear from the definition of (i * , j * ) if i = i , otherwise this follows since q = q + j l , andv i (j l |q)/j l ≥ v i (j l + j l+1 |q)/(j l + j l+1 ) = v i (j l |q) + v(j l+1 |q ) /(j l + j l+1 ).
Now fix any i. For j ≥ p i , by the definition of β we haveβ ≥ v i (j − p i |p i )/(j − p i ) or equivalently, α i ≥ v i (j) − j · β.Consider the piecewise-linear function f i passing through the points q i,l , v i (q i,l ) , l = 0, . . . , s (where q i,0 = 0).
By our earlier claim, f i (.)
is a concave (increasing) function, and each segment of f i (.)
has slope at least β.
These two facts imply that the line passing through p i , f i (p i ) with slope β lies above thef i (.)
curve in [0, p i ].
Also note that for any j ≤ p i , f i (j) ≥ v i (j) since if j ∈ [q i,l , q i,l+1 ] for some l, then f i (j) = v i (q i,l ) + (j − q i,l ) · v i (j l+1 |q i,l ) j l+1 ≥ v i (q i,l ) + (j − q i,l ) · v i (j−q i,l |q i,l ) j−q i,l = v i (j).
Combining these facts, we get that for any j ≤ p i ,f i (p i ) − (p i − j) · β ≥ f i (j) ≥ v i (j) which when rearranged gives α i ≥ v i (j) − j · β.
We now consider two closely related problems, edge-disjoint-paths (EDP) and all-or-nothing multi-commodity flow (ANF).
In both EDP and ANF we have a graph G = (V, E) with capacities u e ≥ 1 on the edges.
The players are (s i , t i ) source-sink pairs where s i , t i ∈ V .
Each player has a value w i .
Both (s i , t i ) and the value w i are private information; a special case is the "known" case where the (s i , t i ) pairs are public and only w i is private.
The social-welfare maximization problem is to select a maximum-weight routable set.
In EDP, a set is routable if each (s i , t i ) pair in the set can be assigned an s i -t i path and at most u e paths use edge e; in ANF, for each (s i , t i ) pair in the set we need to route one unit of flow from s i to t i respecting edge capacities, possibly splitting the flow across several paths.
For the mechanism-design problem, we define the outcome set carefully to ensure that only players' values for an outcome, and not the set itself, depends on his private information.
For EDP, an outcome is an allocation of edges (as paths) to players such that each edge e is used at most u e times (and player i receives value w i if he is allocated an s i -t i path); for ANF, an outcome is a flow-vector allocation to each player, such that the total flow through each edge e is at most u e (and player i receives value w i if his flow-vector sends one unit of flow from s i to t i ).
We apply our techniques to obtain two types of results for EDP and ANF.
Let B = min e u e .
First, we observe that Theorem 4.1 yields a truthful (in expectation) O(m 1 B+1 )-approximation mechanism for both problems.
Next, we show that for the known case, we can translate the improved guarantees of [8] for EDP and ANF on certain graph classes to the mechanism-design setting to obtain truthful mechanisms with matching approximation guarantees for EDP and ANF (on the appropriate graph classes).
Both EDP and ANF admit the following flow-path based LP relaxation.
We use P below to index the collection Path of all (simple) paths in G. Let Path i denote the collection of s i -t i paths.
Here f i,P denotes the amount of flow on path P , and v i (P ) = w i if P ∈ Path i , and is 0 otherwise.
It is easy to see that an integral solution corresponds to an EDP solution, and a solution where P f i,P is integral for each player i corresponds to an ANF solution.
Observe that EDP is a structured MUCA with short valuations (since one can construct a demand oracle for player i, given (s i , t i ; w i )), and (Route-P) is simply a specialization of (CA-P) (where items are edges, and a set S that does not contain an s i -t i path has v i (S) = 0).
Also, a solution to EDP is also clearly a solution to ANF.
Thus, Theorem 4.1 yields a randomized, truthful O(m Chekuri et al. [8] use the above LP to obtain approximation guarantees of (i) O(log m) for EDP on planar graphs when B ≥ 2; and (ii) O(log 2 m) for ANF on general graphs, and O(log m) for planar graphs.
(The guarantees are stated for w i = 1, but it is implicit that the algorithms generalize to arbitrary w i .)
Notice however that this does not imply analogous bounds on the integrality gap of (Route-P) for these graph classes since the valuation functions arising in EDP and ANF are structured valuations.
(In fact, it is not hard to cast MUCA as EDP, so the integrality gap of (Route-P) with u e = B for all e is Θ(m 1 B+1 ).)
However, we show that in the known case, our techniques can be used to obtain matching approximation guarantees in the mechanism-design setting.The key observation is that since each player i's (true) value depends (linearly) only on the amount of flow routed from s i to t i (which are publicly known) and not on the actual flow-paths that are chosen, it suffices to obtain a "partial" decomposition such that the (total flow routed for an (s i , t i ) pair by the convex combination) = (total flow routed for (s i , t i ) by the LP)/α.
To see this formally, recall that (see Lemma 3.2) to translate the fractional VCG mechanism to (a support mechanism, and hence) a truthful-inexpectation mechanism, we require a convex combination , and so a "partial" decomposition of f * (v) suffices to yield this property; but if (s i , t i ) is private information, then this is no longer true, and one needs to resort to a "complete" decomposition (which requires an integrality-gap-verifying algorithm for (Route-P)).
l∈I λ l (v)x l that satisfies l∈I λ l (v)v i (x l ) = v i (f * (v))/αWe now argue briefly that an α-approximation algorithm for EDP or ANF based on the LP (Route-P) can be used to obtain a partial decomposition (with the same α), enabling us to translate the approximation guarantees of [8] to the mechanism-design setting.
Similar results are known with demands d i when max d i ≤ B and these also transfer to the mechanisms.
For notational convenience, given a solution f to (Route-P), we introduce auxilliary variables x i := We have presented a general method for devising randomized, truthful-in-expectation mechanisms for packing problems that allows one to exploit approximation algorithms and obtain matching approximation guarantees for the mechanism-design problem.
Given an α-approximation algorithm that also bounds the integrality gap of the LP-relaxation of a packing problem by α, we show how to design a truthful mechanism with the same approximation ratio.
Our method proceeds by decomposing the optimal LP-solution scaled down by α into a convex combination of integer solutions, which can then be viewed as a probability distribution over integer solutions.
We show that the payments of the fractional VCG mechanism (whose outcome is the LP-optimum) can be modified and combined with the above randomized algorithm to yield a randomized mechanism that is truthful in expectation.
We demonstrate the usefulness of our technique on a variety of problem domains: combinatorial auctions, multi-unit auctions, multi-unit combinatorial auctions, and graph-routing problems (edge-disjoint-paths (EDP), all-or-nothing multicommodity flow (ANF)).
In many cases, the approximation guarantees we obtain are the best possible if one requires polynomial-time computation (unless P=NP).
It is instructive to note that our method can also be viewed as constructing a maximal-in-distributionalrange (MIDR) mechanism (see [12]).
That is, instead of presenting our method as one where we first obtain the fractional VCG mechanism and then translate this to a randomized mechanism, we can view our construction as one that uses an α-integrality-gap-verifying approximation algorithm to exactly optimize the social welfare over a subset of the convex hull of integer solutions, and hence, implement VCG over a suitable (fixed) outcome set.
To see this, let P I denote the convex hull of integer points in P (i.e., Z(P)), where P is the polytope of feasible solutions to the LP-relaxation of the packing problem.
Observe that the outcome of any randomized or support mechanism corresponds to a point in P I .
Our decomposition lemma (Lemma 3.5) shows that P/α ⊆ P I ; also, we can efficiently optimize over P/α since this is equivalent to optimizing over P. Thus, our randomized (or deterministic support) mechanism (which returns the optimum over P/α as its outcome) is essentially VCG over the outcome-set P/α.
(And the α-approximation ratio follows since the optimum value over P/α is within an α-factor of the optimum over P.)Subsequent to the publication of the conference version of this paper [24], various other solutions have been obtained for combinatorial auctions and multi-unit auctions.
For combinatorial auctions, [15,11] obtain the same approximation guarantees that we obtain but under the stronger solution concept of universal truthfulness.
For multi-unit auctions, [13] give a deterministic truthful 2-approximation, and [12] obtain an FPTAS that is truthful in expectation (also via an MIDR mechanism).
These mechanisms are however tailored to the specific problem considered; in contrast, our method is the only (currently known) general method to convert approximation algorithms to truthful mechanisms (with matching approximation guarantees) for multidimensional problem domains.
It is also worth noting that our mechanisms have remained the state-of-art for other problem domains, most notably, multi-unit combinatorial auctions, where no other truthful mechanism achieves similar approximation guarantees.One of the insights to emerge from our work is that fractional truthful mechanisms combined with a suitable rounding scheme can be an effective tool in truthful mechanism design even for multidimensional domains, The versatility and usefulness of this approach has been reinforced in various subsequent works, such as [25,17,16,19].
The latter three papers [17,16,19] all devise truthful-in-expectation mechanisms for their respective problems (stochastic market planning, generalized assignment problem, secondary spectrum auctions) by first devising a fractional truthful mechanism and then adapting our rounding ideas to convert this into the desired randomized mechanism.
Lavi and Swamy [25] consider a special case of the minimum-makespan scheduling problem on unrelated machines.
In their case, constructing a fractional truthful mechanism is non-trivial since makespan minimization is not a social-welfare-maximization problem, and the rounding scheme is tailored to the problem at hand and different from the one proposed here.
While we focus on packing problems, another broad class of optimization problems that has natural gametheoretic aspects is covering problems.
Our techniques can be adapted to yield some partial results for this class of problems.
As an illustrative example, consider the set cover problem, which can be used to abstract the following setting.
A buyer needs to compose a team of workers that together cover a set of capabilities.
Each worker offers some of these capabilities, and incurs a certain cost if hired as part of the team.
The optimization problem is to select a minimum-cost set of workers that cover the required capabilities.
In the mechanism-design setting (sometimes referred to as a procurement auction), the workers' costs and/or capabilities are private information, and one therefore seeks to construct a truthful mechanism that achieves a "good" approximation ratio.
(As in the case of graph routing problems, we need to define the outcome set carefully so that only players' values for an outcome and not the set itself depends on private information.)
If the integrality gap of the LP relaxation of the covering problem is α > 1 (as verified by an α-approximation algorithm), then it is not hard to see that (by dovetailing the arguments in Section 3.1), given an LP-solution x, one can decompose α·x into a convex combination of integer solutions where multiple copies of a worker may be purchased.
That is, these integer solutions (and hence, the random integer solution specified by the convex combination) are only feasible for the original problem provided a worker may be hired multiple times; in such cases our method yields an α-approximation, truthful (in expectation) mechanism.An example of such a setting is the multiset multicover problem with multiplicities, where each capability must be covered a certain number of times, each worker's private information is a vector specifying the amounts of the different capabilities he offers, and there is no limit on how many copies of a worker may be chosen.
Another example is the class of network design problems, where each worker owns edges of an underlying known graph: the identity of the edges owned and their costs are private, and the goal is to select a minimum-cost edge-set satisfying certain connectivity requirements, possibly with other side constraints such as degree bounds.
Such network design problems often come in two flavors, one where there is a bound on the number of times an edge may be selected, and one where there is no such bound.
Our technique yields truthful, approximation mechanisms for the latter class of problems with guarantees matching that of the best known LP-based (integrality-gap-verifying) approximation algorithm for the problem.We also remark that for single-dimensional covering problems-e.g., network design problems where each edge is a separate player and its cost is private information-we can adapt our proofs to show that one can decompose min{α · x, 1} into a convex combination of feasible integer solutions to the problem (that is, we no longer need to buy multiple copies).
(Here 1 denotes the all ones vector and min denotes componentwise minimum.)
The resulting randomized mechanism then satisfies value monotonicity, a necessary and sufficient condition for truthfulness, and we again get a general result: given an LP-based α-approximation for a covering problem, one can get an α-approximation truthful mechanism for the analogous singledimensional mechanism-design problem.
As an application, we mention that this immediately yields the first truthful, approximation mechanisms for the single-dimensional mechanism-design version of survivable network design (possibly with degree constraints) with approximation guarantees matching those of the algorithmic problem.A very interesting open problem is to design a truthful approximation mechanisms for multidimensional covering problems when such multiplicities are not allowed.
We thank Bruce Shepherd for very useful discussions about the results in [8].
