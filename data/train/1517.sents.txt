Writing and maintaining firewall configurations can be challenging, even for experienced system administrators.
Tools that uncover the consequences of configurations and edits to them can help sysadmins prevent subtle yet serious errors.
Our tool, Margrave, offers powerful features for firewall analysis, including enumerating consequences of configuration edits, detecting overlaps and conflicts among rules, tracing firewall behavior to specific rules, and verification against security goals.
Mar-grave differs from other firewall-analysis tools in supporting queries at multiple levels (rules, filters, firewalls, and networks of firewalls), comparing separate firewalls in a single query, supporting reflexive ACLs, and presenting exhaustive sets of concrete scenarios that embody queries.
Margrave supports real-world firewall-configuration languages, decomposing them into multiple policies that capture different aspects of firewall func-tionality.
We present evaluation on networking-forum posts and on an in-use enterprise firewall-configuration.
Writing a sensible firewall policy from scratch can be difficult; maintaining existing policies can be terrifying.
Oppenheimer, Ganapathi, and Patterson [31] have shown that operator errors, specifically configuration errors, are a major cause of online-service failure.
Configuration errors can result in lost revenue, breached security, and even physical danger to co-workers or customers.
The pressure on system administrators is increased by the frenetic nature of their work environment [6], the occasional need for urgent changes to network configurations, and the limited window in which maintenance can be performed on live systems.Many questions arise in checking a firewall's behavior: Does it permit or block certain traffic?
Does a collection of policies enforce security boundaries and goals?
Does a specific rule control decisions on certain traffic?
What prevents a particular rule from applying to a packet?
Will a policy edit permit or block more traffic than intended?
These questions demand flexibility from firewall-analysis tools: they cover various levels of granularity (from individual rules to networks of policies), as well as reasoning about multiple versions of policies (to check the impact of edits).
Margrave handles all these and more, offering more functionality than other published firewall tools.Margrave's flexibility comes from thinking about policy analysis from an end-user's perspective.
The questions that users wish to ask about policies obviously affect modeling decisions, but so does our form of answer.
Margrave's core paradigm is scenario finding: when a user poses a query, Margrave produces a (usually exhaustive) set of scenarios that witness the queried behavior.
Whether a user is interested in the impact of changes or how one rule can override another, scenarios concretize a policy's behavior.
Margrave also allows queries to be built incrementally, with new queries refining the results from previous ones.Margrave's power comes from choosing an appropriate model.
Embracing both scenario-finding and multilevel policy-reasoning leads us to model policies in firstorder logic.
While many firewall-analysis tools are grounded in logic, most use propositional models for which analysis questions are decidable and efficient.
In general, one cannot compute an exhaustive and finite set of scenarios witnessing first-order logic formulas.
Fortunately, the formulas corresponding to many common firewall-analysis problems do yield such sets.
Margrave identifies such cases automatically, thus providing exhaustive analysis for richer policies and queries than other tools.
Demonstrating that firewall analyzers can benefit from first-order logic without undue cost is a key contribution of this paper.Our other key contribution lies in how we decompose IOS configurations into policies for analysis.
Single fire- Margrave presents scenarios that satisfy user-specified queries about firewall behavior.
Queries state a behavior of interest and optional controls on which data to consider when computing scenarios.
Scenarios contain attributes of packet contents that make the query hold.
A separate command language controls how scenarios are displayed.
The extended example in this section highlights Margrave's features; Table 1 summarizes which of these features are supported by other available (either free or commercial) firewall analyzers.
The Margrave website [22] contains sources for all examples.In this paper, a firewall encompasses filtering (via access-lists), NAT transformation, and routing; we reserve the term router for the latter component.
The IOS configuration in Figure 1 defines a simple firewall with only filtering.
This firewall controls two interfaces (fe0 and vlan1).
Each has an IP address and an access-list to filter traffic as it enters the interface; in lines 3 and 7, the number (101 or 102) is a label that associates access rules (lines 9-16) with each interface, while the in keyword specifies that the rules should apply on entry.
Rules are checked in order from top to bottom; the first rule whose conditions apply determines the decision on a 1 interface fe0 2 ip address 10.
150 packet.
This firewall allows inbound web and mail traffic to the corresponding servers (the .10 and .11 hosts), but denies a certain blacklisted IP address (the 10.1.1.2 host).
All traffic arriving at the inside-facing interface vlan1 is allowed.
As this filter is only concerned with packets as they arrive at the firewall, our queries refer to the filter as InboundACL.Basic Queries: All firewall analyzers support basic queries about which packets traverse the firewall.
The following Margrave query asks for an inbound packet that InboundACL permits: EXPLORE clauses describe firewall behavior; here, the behavior is simply to permit packets.
<req> is shorthand for a sequence of variables denoting the components of a request (detailed in Section 4):ahostname, src-addr-in, src-port-in, protocol, ....Users can manually define this shorthand within Margrave; details and instructions for passing queries into Margrave are in the tool distribution [22].
SHOW ONE is an output-configuration command that instructs Margrave to display only a single scenario.
Table 1: Feature comparison between Margrave and other available firewall-analysis tools.
In each cell, denotes included features; nip denotes features reported by the authors in private communication but not described in published papers; − denotes included features with more limited scope than in Margrave; ∼ denotes features that can be simulated, but aren't directly supported; ?
denotes cases for which we aren't sure about support.
Section 7 describes nuances across shared features and discusses additional research for which tools are not currently available.This scenario shows a TCP packet (line 3) arriving on the fast-ethernet interface (line 7), bound for the web server (line 4, with line 11 of Figure 1) on port 80 (line 8).
The generic IPaddress in lines 2 and 11 should be read as "any IP address not mentioned explicitly in the policy"; lines 5 and 6 are similarly generic.
Section 5 explains the size=15 report on line 1.
A user can ask for additional scenarios that illustrate the previous query via the command SHOW NEXT: Once Margrave has displayed all unique scenarios, it responds to SHOW NEXT queries with no results.To check whether the filter accepts packets from the blacklisted server, we constrain src-addr-in to match the blacklisted IP address and examine only packets that arrive on the external interface.
Both src-addr-in and entry-interface are variable names in <req>.
The IS POSSIBLE?
command instructs Margrave to display false or true, rather than detailed scenarios.
In this case, Margrave returns false.
Had it returned true, the user could have inspected the scenarios by issuing a SHOW ONE or SHOW ALL command.Rule-level Reasoning: Tracing behavior back to the responsible rules in a firewall aids in both debugging and confirming that rules are fulfilling their intent.
To support reasoning about rule effects, Margrave automatically defines two formulas for every rule in a policy (where R is a unique name for the rule):• R matches(<req>) is true when <req> satisfies the rule's conditions, and • R applies(<req>) is true when the rule both matches <req> and determines the decision on <req> (as the first matching rule within the policy).
Distinguishing these supports fine-grained queries about rule behavior.
Margrave's IOS compiler constructs the R labels to uniquely reference rules across policies.
For instance, ACL rules that govern an interface have labels of the form hostname-interface-line#, where hostname and interface specify the names of the host and interface to which the rule is attached and # is the line number at which the rule appears in the firewall configuration file.The following query refines query 2 to ask for decision justification: the EXPLORE clause now asks for Deny packets, while the INCLUDE clause instructs Margrave to compute scenarios over the two Deny rules as well as the formulas in the EXPLORE clause: The SHOW REALIZED command asks Margrave to display the subset of listed facts that appear in some result-ing scenario.
The following results indicate that the rule at line 9 does (at least sometimes) apply.
More telling, however, the absence of the rule at line 14 (the catch-all deny) indicates that that rule never applies to any packet from the blacklisted address.
Accordingly, we conclude that line 9 processes all blacklisted packets.
The INCLUDE clause helps control Margrave's performance.
Large policies induce many rule-matching formulas; enabling these formulas only as needed trims the scenario space.
SHOW REALIZED (and its dual, SHOW UNREALIZED) controls the level of detail at which users view scenarios.
The lists of facts that do (or do not) appear in scenarios often raise red flags about firewall behavior (such as an unexpected port being involved in processing a packet).
Unlike many verification tools, Margrave does not expect users to have behavioral requirements or formal security goals on hand.
Lightweight summaries such as SHOW REALIZED try to provide information that suggests further queries.
Query 3 checks the relationship between two rules on particular packets.
A more general question asks which rules never apply to any packet; we call such rules superfluous.
The following query computes superfluous rules:EXPLORE true UNDER InboundACL INCLUDE InboundACL:router-fe0-line9_applies(<req>), InboundACL:router-fe0-line10_applies(<req>), InboundACL:router-fe0-line12_applies(<req>), InboundACL:router-fe0-line14_applies(<req>), InboundACL:router-vlan1-line16_applies(<req>) SHOW UNREALIZED InboundACL:router-fe0-line9_applies(<req>), InboundACL:router-fe0-line10_applies(<req>), InboundACL:router-fe0-line12_applies(<req>), InboundACL:router-fe0-line14_applies(<req>), InboundACL:router-vlan1-line16_applies(<req>) Query 4As this computation doesn't care about request contents, the EXPLORE clause is simply true.
The heart of this query lies in the INCLUDE clause and the SHOW UNREALIZED command: the first asks Margrave to consider all rules; the second asks for listed facts that are never true in any scenario.
UNDER clauses load policies referenced in INCLUDE but not EXPLORE clauses.
While the results tell us which rules never apply, they don't indicate which rules overshadow each unused rule.
Such information is useful, especially if an overshadowing rule ascribes the opposite decision.
Writing queries to determine justification for each superfluous rule, however, is tedious.
Margrave's query language is embedded in a host language (Racket [13], a descendent of Scheme) through which we can write scripts over query results.
In this case, our script uses a Margrave command to obtain lists of rules that yield each of Permit and Deny, then issues queries to isolate overshadowing rules for each superfluous rule.
These are similar to other queries in this section.
Scripts could also compute hotspot rules that overshadow a large percentage of other rules.Change-Impact: Sysadmins edit firewall configurations to provide new services and correct emergent problems.
Edits are risky because they can have unexpected consequences such as allowing or restricting traffic that the edit should not have affected.
Expecting sysadmins to have formal security requirements against which to test policy edits is unrealistic.
In the spirit of lightweight analyses that demand less of users, Margrave computes scenarios illustrating packets whose decision or applicable rule changes in the face of edits.For example, suppose we add the new boldface rule below to access-list 101 (the line numbers start with 14 to indicate that lines 1-13 are identical to those in Figure 1 If we call the modified filter InboundACL new, the following query asks whether the original and new InboundACLs ever disagree on Permit decisions: Margrave would return true on query 5.
The corresponding scenarios show packet headers that the two firewalls treat differently, such as the following: Figure 2 shows a small network with web server, mail server, and two firewalls to establish a DMZ.
The internal firewall performs both NAT and packet-filtering, while the external firewall only filters.
The firewall distinguishes machines for employees (192.168.3.
* ), contractors (192.168.4.
* ), and a manager (192.168.1.2).
This example captures the essence of a real problem posted to a networking help-forum.
Lines 15-17 in the internal firewall apply NAT to traffic from the corporate LAN.
1 Line 11 in the external firewall blacklists a specific external host (10.200.200.200).
*********Despite the explicit rule on lines 19-20 in the external firewall, the manager cannot access the web.
We have edited the configurations to show only those lines relevant to the manager and web traffic.
Lines 12-16 capture both network topology and the effects of NAT.The internal-result and passes-firewall formulas capture routing in the face of NAT and passing through the complete firewall (including routing, NAT and ACLs) whose hostname appears in the request, respectively; Section 4 describes them in detail.
The variables sent to the two passes-firewall formulas through <reqpol-1> and <reqpol-2> encode the topology: for example, these shorthands use the same variable name for dest-addr-out in the internal firewall and src-addr-in in the external firewall.
The fw1-entry-interface and fw2-entry-interface variables (bound to specific interfaces in lines 3-4) appear as the entry interfaces in <reqpol-1> and <reqpol-2>, respectively.A SHOW REALIZED command over the INCLUDE terms (as in query 3) indicates that line 21 of the external firewall configuration is denying the manager's connection.
Asking Margrave for a scenario for the query (using the SHOW ONE command) reveals that the internal firewall's NAT is changing the packet's source address: 1 ... The external firewall rule (supposedly) allowing the manager to access the Internet (line 19) uses the internal pre-NAT source address; it never matches the post-NAT packet.
Na¨ıvelyNa¨ıvely editing the NAT policy, however, can leak privileges to contractors and employees.
Changeimpact queries are extremely useful for confirming that the manager, and only the manager, gain new privileges from an edit.
An extended version of this example with multiple fixes and the change-impact queries, is provided in the Margrave distribution.Summary: These examples illustrate Margrave's ability to reason about both combinations of policies and policies at multiple granularities.
The supported query types include asking which packets satisfy a condition (query 1), verification (query 2), rule responsibility (query 3), rule relationships (query 4) and change-impact (query 5).
A formal summary of the query language and its semantics is provided with the Margrave distribution.
Margrave views a policy as a mapping from requests to decisions.
In a firewall, requests contain packet data and some routing data, while decisions include Permit and Deny (for ACLs), Drop (for routing), and a few others.
Policies often refer to relationships between objects, such as "permit access by machines on the same subnet".
Queries over policies often require quantification: "Every host on the local subnet can access some gateway router".
First-order logic extends propositional logic with relational formulas (such as SameSubnet(121.34.42.133,121.34.42.166)) and quantifiers (∀ and ∃).
For firewall policies, the available relations include the decisions, R matches and R applies (as shown in Section 2) and unary relations capturing sets of IP addresses, ports, and protocols.Margrave maps both policies and queries into firstorder logic formulas.
To answer a query, Margrave first conjoins the query formula with the formulas for all policies referenced in the query, then computes solutions to the combined formula.
A solution to a first-order formula contains a set of elements to quantify over (the universe) and two mappings under which the formula is true: one maps each relation to a set of tuples over the universe, and another maps each unquantified variable in the query to an element of the universe.
2 For example, the formula∀x host(x) =⇒ ∃y (router(y) ∧ C anAccess(x, y))says that "every host can access some router".
One solution has a universe of {h1, r1, r2} and relation tuples host(h1), router(r1), router(r2), and CanAccess(h1,r2) (the formula has no unquantified variables).
Other solutions could include more hosts and routers, with more access connections between them.
Solutions may map multiple variables to the same universe element.
This is extremely useful for detecting corner cases in policy analysis; while humans often assume that different variables refer to different objects, many policy errors lurk in overlaps (such as a host being used a both web server and mail server).
Scenarios are simply solutions to the formula formed of a query and the policies it references.In general, checking whether a first-order formula has a solution (much less computing them all) is undecidable.
Intuitively, the problem lies in determining a sufficient universe size that covers all possible solutions.
This problem is disconcerting for policy analysis: we would like to show users an exhaustive set of scenarios to help them ensure that their policies are behaving as intended in all cases.
Fortunately, Margrave can address this problem in most cases; Section 5 presents the details.
specifies the decision and states a sequence of variable names corresponding to a request.
The :-symbol separates the decision from the conditions of the rule.
Formula (prot-tcp protocol), for example, captures that TCP is the expected protocol for this rule.
Margrave represents constants (such as decisions, IP addresses, and protocols) as elements of singleton unary relations.
A scenario that satisfies this rule will map the protocol variable to some element of the universe that populates the prot-tcp relation.
The other conditions of the original rule are captured similarly.
The (RComb FAC) at the end of the policy tells Margrave to check the policy rules in order (FAC stands for "first applicable").
The first line of the policy ascribes the name InboundACL.Decomposing IOS into policies: Figure 4 shows our high-level model of IOS configurations.
Firewalls perform packet filtering, packet transformation, and internal routing; the first two may occur at both entry to and exit from the firewall.
Specifically, packets pass through the inbound ACL filter, inside NAT transformation, internal routing, outside NAT transformation, and finally the outbound ACL filter on their way through the firewall.
The intermediate stages define additional information about a packet (as shown under the stage names): inside NAT may yield new address and port values; internal routing determines the next-hop and exit interface; outside NAT may yield further address and port values.Internal routing involves five substages, as shown in Figure 6.
Margrave creates policies (` a la Figure 3) for each of the five substages.
The -Switching policies determine whether a destination is directly connected to the firewall; the -Routing policies bind the next-hop IP address for routing.
In addition, Margrave generates four policies called InboundACL, OutboundACL, InsideNAT, and OutsideNat.
The two -ACL policies contain filtering rules for all interfaces.Requests and Decisions: Margrave automatically defines a relation for each decision rendered by each of the 9 subpolicies (e.g., InboundACL:Permit in query 1).
Each relation is defined over requests, which contain packet headers, packet attributes, and values generated in the intermediate stages; the boxes in Figure 4 collectively list the request contents.
As Margrave is not stateful, it cannot update packet headers with data from intermediate stages.
The contents of a request reflect the intermediate stages' actions: for example, if the values of src-addr and src-addr-out are equal, then OutsideNAT did not transform the request's packet.
Currently, Margrave shares the same request shape across all 9 subpolicies (even though InboundACL, for example, only examines the packet header portion).
Flows between subpolicies: Margrave encodes flows among the 9 subpolicies through three relations (over requests) that capture the subflows marked in Figure 4.
• Internal routing either assigns an exit interface and a next-hop to a packet or drops the packet internally.Margrave uses a special exit-interface value to mark dropped packets; the int-dropped relation contains requests with this special exit-interface value.
Any request that is not in int-dropped successfully passes through internal routing.
• Unlike internal routing, NAT never drops packets.
At most, it transforms source and destination ports and addresses.
Put differently, NAT is a function on packets.
internal-result captures this function: it contains all requests whose next-hop, exit-interface, and OutsideNAT components are consistent with the packet header and InsideNAT components (as if the latter were inputs to a NAT function).
• ACLs permit or deny packets.
The relation passes-firewall contains requests that the two ACLs permit, are in internal-result (i.e., are consistent with NAT), and are not in int-dropped (i.e., are not dropped in internal routing).
Our IOS compiler automatically defines each of these relations as a query in terms of the 9 IOS subpolicies (capturing topology as in query 6).
Margrave provides a RENAME command that saves query results under a userspecific name for use in later queries.
Users can name any set of resulting scenarios in this manner.
Margrave puts domainknowledge common to multiple policies in a vocabulary specification; the first line of a policy specification references its vocabulary through the uses keyword.
Figure 5 shows a fragment of the vocabulary for IOS policies: it defines datatypes (such as Protocol) and their elements (correspondingly, prot-ICMP, prot-TCP, prot-UDP).
Vocabularies also capture domain constraints such as "all protocols are distinct" or "there must be at least one port" (both shown in Figure 5).
While these constraints may seem odd, they support Margrave's scenario-finding model.
Some potential "solutions" (as described in Section 3) are nonsensical, such as one which assigns two distinct numbers to the same physical port.
Domain constraints rule out nonsensical scenarios.
The policy-and vocabulary-specifications in Figures 3 and 5 show how to map specific domains into Margrave.
Datatypes, constraints, and rules capture many other kinds of policies, including access-control policies, hypervisor configurations, and product-line specifications.
Indeed, this general-purpose infrastructure is another advantage of Margrave over other firewall-analysis tools: Margrave can reason about interactions between policies from multiple languages for different configuration concerns.
For example, if data security depends on a particular interaction between a firewall and an accesscontrol policy, both policies and their interaction can be explored using Margrave.
We expect this feature to become increasingly important as enterprise applications move onto the cloud and are protected through the interplay of multiple policies from different sources.
Margrave consists of a frontend read-eval-print loop (REPL) written in Racket [13] and a backend written in Java.
The frontend handles parsing (of queries, commands, policies, and vocabularies) and output presentation.
The actual analysis and scenario generation occurs in the backend.
Margrave's backend must produce sets of solutions to first-order logic formulas.
We currently use a tool called Kodkod [32] that produces solutions to first-order formulas using SAT solving.
3 SAT solvers handle propositional formulas.
Kodkod bridges the gap from firstorder to propositional formulas by asking users for a finite universe-size; under a finite universe-size, first-order formulas translate easily to propositional ones.
Figure 7 shows an example of the rewriting process.
Every solution produced using a bounded size is legitimate (in logical terms, our analysis is sound).
However, analysis will miss solutions that require a universe larger than the given size (in logical terms, it is not complete).
Fortunately, most firewall queries (including those in this paper) correspond to formulas with no universal (∀) quantifiers.
For such formulas, the number of existentially-quantified variables provides a sufficient universe size to represent all solutions.
Margrave automatically supplies Kodkod with the universe bound for such formulas.
For queries that do not have this form, such as "can every host reach some other machine on the network", either Margrave or the user must supply a universe size for the analysis.
The query language has an optional CEILING clause whose single argument is the desired universe size.
If CEILING is omitted, Margrave uses a default of 6.
Experience with Kodkod in other domains suggests that small universe sizes can yield useful scenarios [15].
If Margrave can compute a sufficient bound but the user provides a lower CEILING, Margrave will only check up to the CEILING value.
Whenever Margrave cannot guarantee that scenario analysis is complete, it issues a warning to the user.
The size=15 statement in the first line of scenarios shown in Section 2 report the universe-size under which Margrave generated the scenario.CEILING settings may impact the results of commands.
Margrave includes a SHOW UNREALIZED command that reports relations that are not used in any resulting scenario.
However, a relation T might be unpopulated at one CEILING value yet populated at a higher value.
For example, in the formula ∃x¬T (x), T is never used at CEILING 1, but can be realized at CEILING 2.
Margrave users should only supply CEILING values if they appreciate such consequences.Overall, we believe sacrificing exhaustiveness for the expressive power of first-order logic in policies and queries is worthwhile, especially given the large number of practical queries that can be checked exhaustively.
Under large universe sizes, both the time to compute scenarios and the number of resulting scenarios increase.
The latter puts a particular burden on the end-user who has to work through the scenarios.
Query language constructs like SHOW REALIZED summarize details about the scenarios in an attempt to prevent the exhaustive from becoming exhausting.
However, query optimizations that reduce universe sizes have more potential to target the core problem.Most firewall queries have the form ∃ req α, where α typically lacks quantifiers.
Requests have 16 or 20 components (as shown in Figure 4), depending on whether they reference internal-result.
Margrave therefore analyzes all-existential queries under a universe size of 16 or 20.
However, these queries effectively reference a single request with attributes as detailed in α.
This suggests that we could rewrite this query with a single quantified variable for a request and additional relations that encode the attributes.
For example:∃ pt in ∃ pt out : route(pt in, pt out) becomes ∃ pkt : is ptIn(pkt, i) ∧ is ptOut(pkt, o) ∧ route(i, o)Effectively, these new relations lift attributes from the individual packet fields to the packet as a whole.Formulas rewritten in this way require a universe size of only 1, for which scenario generation stands to be much faster and to yield fewer solutions.
The tradeoff, however, lies in the extra relations that Margrave introduces to lift attributes to the packet level.
Additional relations increase the time and yield of scenario computations, so the rewriting is not guaranteed to be a net win.
Replace each remaining formula with a propositional variable (e.g., router(A) becomes p2):p1 =⇒ (p2 ∧ p3) ∨ (p4 ∧ p5) ∧ p6 =⇒ (p2 ∧ p7) ∨ (p4 ∧ p8)Figure 7: Converting a first-order formula to a propositional one at a bounded universe size Table 2 presents experimental results on original versus rewritten queries.
In practice, we find performance improves when the query is unsatisfiable or the smallest model is large.
A user who expects either of these conditions to hold can enable the rewriting through a querylanguage flag called TUPLING.
All performance figures in this paper were computed using TUPLING.
We have two main goals in evaluating Margrave.
First, we want to confirm that our query language and its results support debugging real firewall configurationproblems; in particular, the scenarios should accurately point to root causes of problems.
We assume a user who knows enough firewall basics to ask the questions underlying a debugging process (Margrave does not, for example, pre-emptively try queries to automatically isolate a problem).
Second, we want to check that Margrave has reasonable performance on large policies, given that we have traded efficient propositional models for richer first-order ones.We targeted the first goal by applying Margrave to problems posted to network-configuration help-forums (Sections 6.1 and 6.2).
Specifically, we phrased the Rules # Vars Min Size Not Tupled Tupled 100 3 3 694ms 244ms 1000 14 6 7633ms 1221ms 1000 14 10 17659ms 1219ms 1000 14 14 32116ms 1205ms We targeted the second goal by applying Margrave to an in-use enterprise firewall-configuration containing several rule sets and over 1000 total rules (Section 6.3).
Margrave revealed some surprising facts about redundancy in the configuration's behavior.
Individual queries uniformly execute in seconds.Notes on Benchmarking Our figures report Margrave's steady-state performance; they omit JVM warmup time.
Policy-load times are measured by loading different copies of the policy to avoid caching bias.
All performance tests were run on an Intel Core Duo E7200 at 2.53 Ghz with 2 GB of RAM, running Windows XP Home.
Performance times are the mean over at least 100 individual runs; all reported times are ±200ms at the 95-percent confidence level.
Memory figures report private (i.e., not including shared) consumption.
"My servers cannot get access into the internet, even though I will be able to access the website, or even FTP... I don't really know what's wrong.
Can you please help?
Here is my current configuration..."In our first forum example [4], the poster is having trouble connecting to the Internet from his server.
He believes that NAT is responsible, and has identified the router as the source of the problem.
The configuration included with the post appears in Figure 8 (with a slight semantics-preserving modification 4 ).
A query (not shown) confirms that the firewall is blocking the connection.
Our knowledge of firewalls indicates that packets are rejected either enroute to, or on return from, the webserver.
Queries for these two cases are similar; the one checking for response packets is: Margrave reports that packets to the webserver are permitted, but responses are dropped.
The resulting scenarios all involve source ports 20, 21, 23, and 80 (easily confirmed by re-running the query with a SHOW REALIZED command asking for only the port numbers).
This is meaningful to a sysadmin: an outgoing web request is always made from an ephemeral port, which is never less than 1024.
This points to the problem: the router is rejecting all returning packets.
ACL 102 (Figure 8, lines 25-29) ensures that the server sees only incoming HTTP, FTP, and TELNET traffic, at the expense of rejecting the return traffic for any connections that the server initiates.EXPLOREEnabling the server to access other webservers involves allowing packets coming from the proper destination ports.
Methods for achieving this include:1.
Permit TCP traffic from port 80, via the edit: 2.
Allow packets whose ack flags are set via the established keyword (or, in more recent versions, the match-all +ack option).
This suggestion guards against spoofing a packet's source port field and allows servers to listen on unusual ports.Follow-up posts in the forum suggested options 1 and 3.
Margrave can capture the first two options and the reflexive access-list approach in the third (it does not currently support inspect commands).
For each of these, we can perform verification queries to establish that the InboundACL no longer blocks return packets, and we can determine the extent of the change through a changeimpact query.Space precludes showing the reflexive ACL query in detail.
Reflexive ACLs allow return traffic from hosts to which prior packets were permitted.
Margrave encodes prior traffic through a series of connection-relations over requests.
Intuitively, a request is in a connectionrelation only if the same request with the source-and destination-details reversed would pass through the firewall.
Although the connection state is dynamic in practice, its stateless definition enables Margrave to handle it naturally through first-order relations.Performance: Loading each version of the configuration took between 3 and 4 seconds.
The final changeimpact query took under 1 second.
After loading, running the full suite of queries (including those not shown) required 2751ms.
The memory footprint of the Java engine (including all component subpolicies) was 50 MB (19 MB JVM heap, 20 MB JVM non-heap).
"there should be a way to let the network 10.232.104.0/22 access the internet, kindly advise a solution for this..."In our second example [29], the poster is trying to create two logical networks: one "primary" (consisting of 10 By the topology in Figure 9, packets reach the TAS router first.
We check whether packets pass through TAS by manually restricting query 8 to TAS (by removing lines 2, 5, 7, 14, and 15); Margrave still returns false.
Firewall knowledge suggests three possible problems with the TAS configuration: (1) internal routing could be sending the packets to an incorrect interface, (2) internal routing could be dropping the packets, or (3) the ACLs could be filtering out the packets.
Margrave's formulas for reasoning about internal firewall behavior help eliminate these cases: by negating passed-firewall on line 6, we determine that the packet does pass through the firewall, so the problem lies in the interface or nexthop assigned during routing.
This example highlights the utility of not only having access to these formulas, but also having the ability to negate (or otherwise manipulate) them as any other subformula in a query.To determine which interfaces the packets are sent on, we relax the query once again to remove the remaining reference to Serial0/3/0:0 (on line 12) and execute the following SHOW REALIZED command:SHOW REALIZED GigabitEthernet0/0 = exit-interface, "Serial0/3/0:0" = exit-interface, GigabitEthernet0/1 = exit-interface Query 9The output contains only one interface name: The next-hop address is clearly wrong for the given destination address.
To determine the extent of the problem, we'd like to know whether all packets from the given source address are similarly misdirected.
That question is too strong, however, as LocalSwitching may (rightfully) handle some packets.
To ask Margrave for next-hops targeted by some source packet that LocalSwitching ignores, we replace line 7 in query 10 with:{ GigabitEthernet0/0[exit-interface] } ResultNOT LocalSwitching:Forward(<routingpol-tas>) Query 11This once again highlights the value of exposing LocalSwitching as a separate relation.
The revised query yields the same next-hop, indicating that all nonlocal packets are routing to 10.232.0.15, despite the local routing policies.
A simple change fixes the problem: insert the keyword default into the routing policy:route-map internet permit 10 match ip address 10 set ip default next-hop 10.232.0.15This change ensures that packets are routed to the Internet only as a last resort (i.e., when static destinationbased routing fails).
Running the original queries against the new specification confirms that the primary subnets now have connectivity to each other.
Another query checks that this change does not suddenly enable the primary sub-network 10 Now we turn to the poster's second problem: the secondary network 10.232.4.0/22 still cannot access the Internet.
As before, we confirm this then compute the next-hop and exit interface that TAS assigns to traffic from the secondary network with an outside destination.
The following query (with SHOW REALIZED over interfaces and potential next-hops) achieves this: The next-hop for the secondary network's Internet gateway is as expected, but the exit-interface is unexpectedly GigabitEthernet0/0 (instead of GigabitEthernet0/1).
In light of this scenario, the network diagram reveals a fundamental problem: the gateway 10.232.4.10 should be "on" the same network as the GigabitEthernet0/1 interface (address 10.232.8.1/22); otherwise LocalSwitching will send the packet to the wrong exit interface.This problem can be resolved by changing the address of either the GigabitEthernet0 Re-running the queries in this new configuration confirms that both goals are now satisfied.
For the change-impact query, we switched the decision from deny to permit on one nonsuperfluous rule.
The overshadowing-rules computation asked only for overshadows with the opposite decision.ms.
After loading, running the full suite of queries (including those not shown) finished in 8725ms.
The memory footprint of the Java engine (including all component subpolicies) was 74 MB (49 MB JVM heap, 21 MB JVM non-heap).
Our largest test case to date is an in-use enterprise iptables configuration.
In order to stress-test our IOS compiler, we manually converted this configuration to IOS.
The resulting configuration contains ACLs for 6 interfaces with a total of 1108 InboundACL rules (not counting routing subpolicies).
The routing component of this firewall was fairly simple; we therefore focus our performance evaluation on InboundACL.From a performance perspective, this paper has illustrated three fundamentally different types of queries: (1) computing over a single policy or network with just the default relations (which-packets and verification queries), (2) computing over a single policy or network while including additional relations (rule-responsibility and rule-relationship queries), and (3) computing over multiple, independent policies or networks (changeimpact queries).
The third type introduces more variables than the first two (to represent requests through multiple firewalls); it also introduces additional relations to capture the policies of multiple firewalls.
The second type has the same number of variables, but more relations, than the first type.
We therefore expect the best performance on the first type, even under TUPLING.
Table 3 reports run-time performance on each type of query over the enterprise firewall-configuration.
Loading the policy's InboundACL component required 10694ms and consumed 51 MB of memory.
Of that, 40 MB was JVM heap and 7 MB was JVM non-heap.
Section 2 described how we compute superfluous rules through scripting.
For this example, these queries yielded surprising results: 900 of the 1108 rules in InboundACL were superfluous.
Even more, 270 of the superfluous rules were (at least partially) overshadowed by a rule with a different decision.
The sysadmins who provided the configuration found these figures shocking and subsequently expressed interest in Margrave.
Studies of firewall-configuration errors point to the need for analysis tools.
Oppenheimer, et al. [31] survey failures in three Internet services over a period of several months.
For two of these services, operator error-predominately during configuration editswas the leading cause of failure.
Furthermore, conventional testing fails to detect many configuration problems.
Wool [35] studies the prevalence of 12 common firewall-configuration errors.
Larger rule-sets yield a much higher ratio of errors to rules than smaller ones; Wool concludes that complex rule sets are too difficult for a human administrator to manage unaided.Mayer, Wool and Ziskind [26,27] and Wool [34] describe a tool called Fang that has evolved into a commercial product called the AlgoSec Firewall Analyzer [3].
AlgoSec supports most of the same analyses as Margrave, covering NAT and routing, but it does not support first-order queries or integration with a programming language.
AlgoSec captures packets that satisfy queries through sub-queries, which are a form of abstract scenarios.Marmorstein and Kearns' [23,24] ITVal tool uses Multi-way Decision Diagrams (MDDs) to execute SQLlike queries on firewall policies.
ITVal supports NAT, routing, and chains of firewall policies.
Later work [25] supports a useful query-free analysis: it generates an equivalence relation that relates two hosts if identical packets (modulo source address) from both are treated identically by the firewall.
This can detect policy anomalies and help administrators understand their policies.
Additional debugging aids in later work includes tracing decisions to rules and showing examples similar to scenarios.
Margrave is richer in its support for changeimpact and first-order queries.Al-Shaer et al.'s ConfigChecker [1,2] is a BDD-based tool that analyses networks of firewalls using CTL (temporal logic) queries.
Rules responsible for decisions can be isolated manually through queries over sample packets.
For performance reasons, the tool operates at the level of policies, rather than individual rules (other of the group's papers do consider rule-level reasoning); Margrave, in contrast, handles both levels.Bhatt et al.'s Vantage tool [5,9,10] supports changeimpact on rule-sets and other user-defined queries over combinations of ACLs and routing; it does not support NAT.
Some of their evaluations [9] exploit changeimpact to isolate configuration errors.
This work also supports generating ACLs from specifications, which is not common in firewall-analysis tools.Liu and Gouda [20,21] Gupta, LeFevre and Prakash [14] give a framework for the analysis of heterogeneous policies that is similar to ours.
While both works provide a general policyanalysis language inspired by SQL, there are distinct differences.
Their tool, SPAN, does not allow queries to directly reference rule applicability and the work does not discuss request-transformations such as NAT.
However, SPAN provides tabular output that can potentially be more concise than Margrave's scenario-based output.
SPAN is currently under development.Lee, Wong, and Kim's NetPiler tool [18,19] analyzes the flow graph of routing policies.
It can be used to both simplify and detect potential errors in a network's routing configurations.
The authors have primarily applied NetPiler to BGP configurations, which address the propaga-tion of routes rather than the passage of packets.
However, their methods could also be applied to firewall policies.
Margrave does not currently support BGP, though its core engine is general enough to support them.Jeffrey and Samak [16] present a formal model and algorithms for analyzing rule-reachability and cyclicity in iptables firewalls.
This work does not address NAT or more general queries about firewall behavior.Eronen and Zitting [11] perform policy analysis on Cisco router ACLs using a Prolog-based Constraint Logic Programming framework.
Users are allowed to define their own custom predicates (as in Prolog), which enables analysis to incorporate expert knowledge.
The Prolog queries are also first-order.
This work is similar to ours in spirit, but is limited to ACLs and does not support NAT or routing information.Youssef et al. [7] verify firewall configurations against security goals, checking both for configurations that violate goals and goals that configurations fail to cover.
The work does not handle NAT or routing.Margrave as described in this paper extends an earlier tool of the same name [12] developed by Tschantz, Meyerovich, Fisler and Krishnamurthi.
The original Margrave targeted simple access-control policies, encoding them as propositional formulas that we analyzed using BDDs.
Attempts to model enterprise access-control policies inspired the shift to first-order models embodied in the present tool.
Not surprisingly, there is an extensive literature on logic-based tools for access-control policies; our other papers [12,28] survey this literature.
Margrave is a general-purpose policy analyzer.
Its most distinctive features lie in and arise from embracing scenario finding over first-order models.
First-order languages provide the expressive power of quantifiers and relations for capturing both policies and queries.
Expressive power generally induces performance cost.
By automatically computing universe bounds for key queries, however, Margrave gets the best of both worlds: firstorder logic's expressiveness with propositional logic's efficient analysis.
Effectively, Margrave distinguishes between propositional models and propositional implementations.
Most logic-based firewall-analysis tools conflate these choices.First-order modeling lets Margrave uniformly capture information about policies at various levels of granularity.
This paper has illustrated relations capturing policy decisions, individual rule behavior, and the effects of NAT and internal routing.
The real power of our first-order modeling, however, lies in building new relations from existing ones.
Each of the relations capturing behavior internal to a firewall (passes-firewall, internal-routing, and int-dropped) is defined within Margrave's query language and exported to the user through standard Margrave commands.
While our firewall compilers provide these three automatically, users can add their own relations in a similar manner.
Technically, Margrave allows users to define their own named views (in a database sense) on collections of policies.
Thus, Margrave embraces policy-analysis in the semantic spirit of databases, rather than just the syntactic level of SQL-style queries.Useful views build on fine-grained atomic information about policies.
Margrave's unique decomposition of IOS configurations into subpolicies for nine distinct firewall functions provides that foundation.
Our pre-defined firewall views would have been prohibitively hard to write without a clean way to refer to components of firewall functionality.
Margrave's intermediate languages for policies and vocabularies, in turn, were instrumental in developing the subpolicies.
Both languages use general relational terms, rather than domain-specific ones.
Vocabularies allow authors to specify decisions beyond those typically associated with policies (such as Permit and Deny).
Our IOS compiler defines separate decisions for the different types of flows out of internal routing, such as whether packets are forwarded internally or translated to another interface.
The routing views are defined in terms of formulas capturing these decisions.
The policy language defines the formulas through rules that yield each decision (our rule language is effectively stratified Datalog).
Had we defined Margrave as a firewallspecific analyzer, rather than a general-purpose one, we likely would have hardwired domain-specific concepts that did not inherently support this decomposition.User-defined decisions and views support extending Margrave from within.
Integrating Margrave into a programming language supports external extension via scripting over the results of commands.
Margrave produces scenarios as structured (XML) objects that can be traversed and used to build further queries.
SHOW REALIZED produces lists of results over which programs (such as superfluous rule detection in Section 2) can iterate to generate additional queries.
Extending our integration with iterators over scenarios would yield a more policy-specific scripting environment.In separate projects, we have applied Margrave to other kinds of policies, including access-control, simple hypervisors, and product-line configuration.
Margrave's general-purpose flexibility supports reasoning about interactions between firewalls and other types of policies (increasingly relevant in cloud deployments).
This is another exciting avenue for future work.Margrave's performance is reasonable, but slower than other firewall analyzers.
This likely stems partly from additional variables introduced during the encoding into propositional logic.
In particular, we expect Margrave will scale poorly to large networks of firewalls, as our formulas grow linearly with the number of firewalls.
Our use of SAT-solving instead of BDDs may be another factor, though Jeffrey and Samak's comparisons between these for firewall analysis [16] are inconclusive.
Exploring alternative backends-whether based on BDDs or other first-order logic solvers-is one area for future work.
However, we believe the more immediate questions lie at the modeling level.
For example:• Firewall languages include stateful constructs such as inspect.
Existing firewall analysis tools, including Margrave, largely ignore state (we are limited to reflexive ACLs).
How do we effectively model and reason about state without sacrificing performance?
• Modeling IP addresses efficiently is challenging.
Many tools use one propositional variable per bit; Margrave instead uses one per IP address.
This makes it harder to model arithmetic relationships on IP addresses (i.e., subranges), though it provides finer-grained control over which IP addresses are considered during analysis.
Where is the sweet-spot in IP-address handling?Margrave is in active development.
We are extending our firewall compilers to support VPN and BGP.
We would like to automatically generate queries for many common problems (such as overshadowing rule detection and change-impact).
Section 2 also hinted at a problem with reusing queries in the face of policy edits: the compiler names rules by line-numbers, so edits may invalidate existing queries.
We need to provide better support for policy-management including regression testing.
Support for this research came from several National Science Foundation grants.
Cisco supported an early phase of this project.
We thank John Basik, Jeff Coady, Mark Dieterich, Jason Montville and Richard Silverman for sysadmins' perspectives on this project.
Craig Wills explained how to report performance data.
Our LISA shepherd, Matt Disney, provided useful suggestions.
In compiling our related work, we contacted many authors with questions about their projects.
We thank them for their prompt and cheerful responses and hope we have represented their work accurately; any errors are our own.
