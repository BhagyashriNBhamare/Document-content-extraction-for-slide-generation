The Bluetooth Low Energy (BLE) is a promising short-range communication technology for Internet-of-Things (IoT) with reduced energy consumption.
Vendors implement BLE protocols in their manufactured devices compliant to Bluetooth Core Specification.
Recently, several vulnerabilities were discovered in the BLE protocol implementations of a few specific products via a manual approach.
Considering the diversity and usage of BLE devices as well as the complexity of BLE protocols , we have developed a systematic and comprehensive testing framework, which, as an automated and general-purpose approach, can effectively fuzz any BLE protocol implementation.
Our framework runs in a central device and tests a BLE device when the latter gets connected to the central as a peripheral.
Our framework incorporates a state machine model of the suite of BLE protocols and monitors the periph-eral's state through its responses.
With the state machine and current state of the central, our framework either sends mal-formed packets or normal packets at a wrong time, or both, to the peripheral and awaits an expected response.
Anomalous behaviours of the peripheral, e.g., a non-compliant response or unresponsiveness, indicate potential vulnerabilities in its BLE protocol implementation.
To maximally expose such anomalies for a BLE device, our framework employs an optimization function to direct the fuzzing process.
As of today, we have tested 12 devices from eight vendors and four IoT products, with a total of 11 new vulnerabilities discovered and 13 new Common Vulnerability Exposure (CVE) IDs assigned.
We call such a bunch of vulnerabilities as SWEYNTOOTH, which highlights the efficacy of our framework.
The Bluetooth Low Energy (BLE) is one of the key wireless communication technologies behind the massive progress of internet-of-things (IoT).
Hence, vulnerabilities in the BLE * This work was partly done when C. Wang worked at SUTD.
protocol implementation may lead to concrete and serious aftermath.
For instance, through reverse engineering on Broadcom's BLE System-on-Chip (SoC) devices, Mantz et al. [24] performed remote code execution in the device's functions with a malformed over-the-air packet.
Similarly, BleedingBit [15], discovered in Texas Instruments BLE SoCs, allows adversaries to install a shellcode, which thereafter permits remote execution and authentication bypass upon receiving specific sequences of manipulated advertisement packets.The preceding examples indicate that faulty BLE protocol implementations may exist in various IoT devices and potentially bring about chaotic consequences.
In this paper, we propose a systematic and automated fuzzing framework that is able to discover vulnerabilities in the BLE protocol implementation of any device.
Our framework neither requires access to the source code of an implementation nor changes a single line of code in a device's OS or firmware.
In a nutshell, it runs in the user space of a customized BLE dongle (i.e., central) to test a BLE device (i.e., peripheral) during the process of establishing a connection between the two.The essence of our framework is a fuzzer that systematically subjects the BLE implementation to adversarial conditions.
However, it is non-trivial to develop a fuzzer to generate such adversarial conditions.
Firstly, we construct a BLE state machine model from the Bluetooth Core Specification [36][37][38] to make valid BLE packets.
This is essential, as a randomly generated, meaningless packet is likely to be rejected by any BLE implementation.
Secondly, testing a BLE implementation with valid BLE packets is improbable to reveal flaws, because such compliant cases should have been covered in manufacturing tests [22,41] as well as in Bluetooth stack certification [39].
Thus, our framework either sends malformed packets based on mutation, or normal packets at a wrong time or inappropriate state, or both, to a BLE peripheral.
Through manipulating packets, our framework intends to bring on adverse corner cases.
Thirdly, the complex structure of BLE packets (cf. Figure 1) and the versatile communication regulations necessitate a comprehensive and directed strategy for generating test cases of packets and their timings.
This aims to drive and stress non-compliant behaviours at the peripheral.
To this end, our fuzzer mutates fields of a layer in the BLE stack and employs a particle swarm optimization (PSO) to heuristically refine the mutation probability distribution at both dimensions of each protocol's layers and each layer's fields.
Finally, our framework validates any response from a peripheral on-the-fly according to a set of expected packets in each protocol state.
This enables it to detect security issues beyond crashes, e.g., security bypass.Our framework distinguishes itself from existing works [6,15,24] in view of being automated and comprehensive.
Existing works require manual and tedious efforts, such as reverse engineering and attentive inspection of source code, to discover potential security flaws in the BLE implementation of specific devices [34].
By contrast, our framework is fully automated and embraces the capability to uncover more security issues than a manual approach.
Concurrently, although a few scattered approaches have been presented in fuzzing Bluetooth devices [3,9,11,18], they only cover a fraction of the Bluetooth stack.
To the best of our knowledge, we compose the first comprehensive approach for BLE fuzzing that is not limited to one or several particular layers, e.g., L2CAP or ATT [3,11], but fully controls the communication at the Link Layer (LL) as well as the interaction with the Secure Manager Protocol (SMP) for encrypted message exchanging.
This, in turn, establishes the efficacy and viability of our framework in fuzzing arbitrary BLE protocol implementations.The remainder of this paper is organized as follows.
In particular, we present the following contributions.
• We present our fuzzing framework to discover implementation flaws for BLE protocols (Section 2).
• We present the optimization process embodied in our fuzzing framework to discover critical security vulnerabilities.
We also discuss the systematic process of validating responses from BLE peripheral (Section 3).
• We discuss the implementation specific challenges in our approach and evaluate our fuzzing framework on several commodity BLE SoCs, including SoCs from NXP, Dialog, Texas Instruments, Microchip, ST Microelectronics and Cypress, among others.
Our evaluation has revealed 11 unknown security vulnerabilities (nicknamed SWEYN-TOOTH) and seven non-compliant behaviours.
13 new common vulnerability exposure (CVE) IDs are assigned and they potentially affect a few hundred types of IoT products.
As all the vulnerable SoCs have passed the Bluetooth stack certification, our evaluation also clearly highlights the incompleteness of the certification process (Section 4).
• We evaluate the impact of new vulnerabilities, as discovered by our framework, on four IoT products (Section 4).
• We compare our framework with three other fuzzers and show that our framework is significantly more effective, in terms of finding security vulnerabilities in BLE implementations (Section 4).
After discussing related work (Section 5), we conclude the paper and provide future directions (Section 6).
BLE is the successor of Bluetooth Classic to build a shortrange wireless network with reduced energy consumption and improved usage capability.
In this section, we first describe the BLE model used in our fuzzing and illustrate the challenges in developing a systematic fuzzing framework for BLE protocols with an example.
Then we present an overview of our framework with its main components and workflow.
We aim to detect implementation flaws in BLE protocols defined in the Bluetooth Core Specification [36][37][38].
Particularly, we study the interactions on Attribute Protocol (ATT), Logical Link Control and Adaptation Protocol (L2CAP), Secure Manager Protocol (SMP), and Link Layer (LL), as shown in Figure 1.
L2CAP and ATT are common to both Bluetooth Classic and BLE, while LL and SMP are exclusive to BLE.
Figure 2 illustrates the process of establishing the BLE connection between a central and a peripheral.
Our fuzzer works during this process and it is guided by a BLE protocol model we have developed.
A simplified representation of the model is presented in Figure 3.
Initially, the peripheral periodically broadcasts advertisements to nearby devices and the central starts in the scanning state.
The central scans for such advertisements and gets further information from the peripheral such as its name by sending a scan request ( 1 in Figure 2).
After receiving a scan response ( 2 in Fig- ure 2) from the peripheral, the central can choose to start a connection by sending a connection request ( 3 in Fig- ure 2) and proceeds to the connection state.
On receiving an acknowledgment from the peripheral ( 4 in Figure 2), the central proceeds to the initial_setup state (see Fig- ure 3).
As the connection request contains connection parameters relevant to the synchronization and communication timing between central and peripheral, after transiting to initial_setup state, the central requests information from the peripheral by sending version request, feature request, length request and MTU length request ( 5 to 8 in Figure 2) with the intention to know the peripheral's supported LL features and capabilities such as the maximum length of the packet it can send or receive.
Likewise, the peripheral also gets the central's LL information during the same exchanges.
Note that the preceding messages are not necessarily sequentially exchanged, because vendors are free to implement how the peripheral handles such messages.
For instance, a peripheral may reply to version before feature.
Similarly, the peripheral may choose to directly read some ATT atributes from the central and go to the gatt_server state or skip the state length before proceeding.
To ensure compatibility with different implementations, we employ several transitions in the state initial_setup for the flexible message ordering, as shown at the upper-left of Figure 3.
After the initial setup is done, the central proceeds to the list_pri_services state.
Here it scans for peripheral's main services via the Generic Attribute Profile (GATT) Service Discovery procedure and stores their attributes in a local array.
The central then proceeds to the state pairing_req and starts to establish an encrypted communication with the peripheral.
The central sends a pairing request packet to the peripheral ( 9 in Figure 2), indicating the preferred pairing mode to be used in the next state.
If the peripheral accepts the pairing mode proposed by the central, it replies to the central and both proceed to the smp_pairing state.
As there are two pairing modes for them to choose, i.e., the Legacy pairing or Secure Connection (SC) pairing via SMP exchanges, they go through the pairing procedure from either the legacy_pairing or sc_pairing state, as shown at the middle-right of Figure 3.
Once the pairing procedure is successful, the central derives a sessionKey from a Short Term Key (STK) received from smp_pairing, transits to the ll_encryption state and starts the challenge with the peripheral by sending an encryption_req ( 10 in Figure 2).
With the peripheral's response, the central sends an encrypted encryption_res packet by using the obtained sessionKey.
If the peripheral is able to correctly authenticate and decrypt the encryption_res from the central, it sends another encrypted encryption_res to the central, indicating that the connection is successfully encrypted.
If legacy_pairing is used, the central and peripheral may optionally go through the keys distribution procedure ( 12 in Figure 2) to exchange a long term key (LTK).
Otherwise, in sc_pairing, the LTK is the STK instead.
The LTK can then be used by the central to avoid repeating the pairing process in subsequent connections and directly go to the step 11 in Figure 2.
In the following stages, the central and peripheral exchange an LTK based on what has been negotiated in pairing_req and the central reads more services from the peripheral at the state list_sec_services.
After LL connection and pairing, the central discovers all the peripheral's available attributes (i.e., information) by performing the GATT Primary Service Discovery.
This consists of sending and receiving a number of ATT requests and ATT responses ( 13 in Figure 2).
so as to fetch predefined ATT attributes.
In the next state gatt_read/write, we capture the read and write of locally stored ATT attributes at the list_pri_services and list_sec_services states.
This step is to emulate writing malformed ATT attributes via our fuzzing methodology.
Thus, the state gatt_read/write at the bottom of Figure 3 is not part of the BLE protocol specification.
However, it is required to check the behaviour of a peripheral in the presence of malformed ATT attributes.
In this paper, we consider developing a systematic fuzzing framework that is 1) comprehensive with respect to all BLE stack layers, 2) directed as being with an optimization mechanism to maximally expose anomalies in BLE protocol implementations, and 3) applicable to fuzzing any product embracing BLE SoCs for wireless connectivity.
Anomalous behaviours capture non-compliance against the Bluetooth Core Specification.
To guarantee the comprehensiveness of cov- CVE-2019-19196) ering all protocol layers, we attentively study the Bluetooth Core Specification and incorporate an all-inclusive state machine model as presented in Section 2.1 at the central side.Thus, at the current state of the central, we monitor responses from the peripheral to check whether they are aligned with the Bluetooth Core Specification or not.
Technical Challenges: Section 2.1 indicates that devising a comprehensive state machine model itself is the first challenge due to the complexity of BLE connections.
As shown in Figure 1, each of the BLE layers contains multiple fields that might be an exploitable factor.
Furthermore, compared to Wi-Fi, BLE allows move-back and move-forward state transitions if a timeout event occurs and an expected response arrives, respectively.
This also introduces the second challenge, i.e., the timing-critical constraints that must be accounted for fuzzing BLE SoCs.
Thirdly, an online validation of peripheral responses is non-trivial at the central side.
According to the Bluetooth Core Specification, at a given state, the central waits for two types of responses, i.e., normal responses and failure responses.
The latter is a valid response, as a wellformed peripheral has the right-of-way to deny any illegal or unaligned request.
Such a feature, again, does not exist in Wi-Fi protocols.
Consequently, special care is demanded to distinguish expected and anomalous packets in the context of BLE communications.
Last but not the least, uncovering vulnerabilities in BLE implementations requires systematically directing the fuzzing framework.
In the following, we take an example vulnerability, i.e., Key Size Overflow (CVE- 2019-19196) discovered by our framework, to illustrate how we resolve the aforementioned challenges.Discovering Key Size Overflow Vulnerability: The Key Size Overflow vulnerability is caused only if the three following conditions are jointly satisfied: 1) key_size field of SMP pairing request is fuzzed, 2) the peripheral receives a certain packet in an inappropriate state, and 3) the peripheral may send a connection failure packet depending on the received fuzzed packet.
The vulnerability is illustrated in Figure 4.
In brief, as a fuzzer, our framework mutates protocol layers and each layer's fields in a packet sent from the central to the peripheral under test.
The mutation is based on probabilities assigned at both dimensions of layers and fields.
It refines such probabilities via a cost function with a return value, say, the count of discovered anomalies, to direct the fuzzing process.Our framework identifies an anomaly by validating received responses.
It discovers Key Size Overflow as follows.
Initially, there is no information about the vulnerabilities.
Therefore, the mutation probabilities are randomly assigned.
Eventually, at the paring_req state, the fuzzer sends a paring_request, yet with fields other than key_size mutated.
The peripheral sends a response SM failure, which is still deemed to be normal by the online validation of our fuzzer.
Next, the fuzzer sends a malformed packet with mutated key_size.
Caveat Lector: the peripheral of Telink Semiconductor unexpectedly replies with a valid paring_response for such a fuzzed, invalid request.
Our framework legitimately catches this response as an anomaly.
As a result, the mutation probability to fuzz the field key_size is increased.
Thus, more malformed pairing_request packets with mutated key_size are sent to the peripheral.
We note that our fuzzer also sends valid packets, but at an inappropriate state of the client.
Eventually, the fuzzer sends an encryption_request to the peripheral immediately after the malformed pairing_request packets with mutated key_size.
This crashes the peripheral, as detected due to the lack of any response from it.
To sum up, the Key Size Overflow presents an anomaly and a crash for BLE SoCs manufactured by Telink.
During the fuzzing process, the scenario to send a malformed paring_request (with mutated key_size) followed by an encryption_request increases.
This is because the response to these malformed packets are anomalous and such anomalous responses increase the value of the cost function (i.e., anomaly count).
This, in turn, further increases the probability to fuzz key_size and indirectly, the likelihood of discovering the scenario causing the vulnerability.
System Architecture: Figure 5 illustrates the architecture of our fuzzer, which is composed of four main modules organized around the BLE model M BLE : (i) the module of packet manipulation that mutates a packet, (ii) the module of packet Algorithm 1 Main Steps of our fuzzer 1: i ← 0 i captures fuzzing iteration 2: generate BLE protocol model (cf. Figure 3) 3: M BLE ← Generate_Protocol_Model() 4: wait to receive mutation probabilities from PSO 5: X i Particle_Swarm_Opt() 6: initialize history of sent packets and redundant packets 7:P hist ← / 0, P ← / 0, P dup ← / 0, P h dup ← / 0, S 0 ← / 0 8: repeat 9:Set central to be in scanning state 10: assign expected layers 11:For each S ∈ M BLE , assign {expected(S), rejection(S)} 12:repeat 13:Wait for peripheral's packet 14: Let the central receives packet P r from the peripheral 15: monitor states and checks anomalies 16: (θ anom , P r ) ← Run_Validation S, P , P h dup , P r 17:S 0 ← S; S ← Get_Current_State(M BLE , P r ) 18:exit the iteration on anomalies and no transition 19: if θ anom is false or S 0 = S then 20:goto line 37 21: end if generate a valid packet from the model 23:P ← Get_Packet_from_Model(M BLE , S) 24:generate fuzzed packets from P via mutation 25:P ← Mutate_Packet(P, X i ) 26:Send fuzzed packets P to the peripheral 27:P h dup ← P dup 28:Choose a packetP dup ∈ P hist ∪ { / 0} s.t. P dup = P 29:Send redundant packet P dup to the peripheral 30: switch expected layers after fuzzing 31: if P = P then 32:expected(S) ← rejection(S) wait to receive new mutation probabilities from PSO 41:X i+1 Particle_Swarm_Opt() i ← i + 1 43: until timeout redundancy that sends arbitrary packets of M BLE to the peripheral at unaligned states (i.e., out of order) with the intention to trigger anomalies on the peripheral's protocol state machine, (iii) the module of packet validation that is responsible for checking the responses from the peripheral and detecting anomalies based on the current state of M BLE , and (iv) the module of fuzzing & optimization that can direct the mutation of packets based on a cost function.As shown by the arrows in Figure 5, the four modules of our fuzzer interact and collaborate with each other to attain the aim of discovering potential vulnerabilities in a peripheral device.
Algorithm 1 illustrates the workflow of it.
Initialization: The fuzzer relies on the protocol model M BLE to generate valid packets and a set of mutation probabilities X i to probabilistically mutate such valid packets.
At the initialization stage (Lines 3 to 5 in Algorithm 1), the fuzzer first loads the model M BLE and receives initial mutation probabilities X i from the optimization module (iv in Figure 5) by calling the Particle_Swarm_Opt function (Line 5).
Next, the central is set to the scanning state and proceeds to wait for the peripheral's advertisement (Lines 9, 13 to 14).
Once the central receives a packet P r from the peripheral, the validation module (iii in Figure 5) checks whether P r is expected or not via the Run_Validation function (Line 16).
In short, the validation module decides the correctness of P r based on a set of expected layers expected(S) or rejection layers rejection(S), which are generated for every state S ∈ M BLE (Line 11) at startup.
The validation is detailed in Section 3.2.
Fuzzing Iteration: If the validation does not detect any anomaly, P r is fed to trigger the state transition in the model M BLE by calling the Get_Current_State function (Line 17).
Get_Current_State strictly follows the protocol model described in Section 2.1 and returns the new state S of M BLE .
Then at the state S, our framework generates a valid packet P (Line 23), which serves as an input to the manipulation and redundancy modules (i and ii in Figure 5).
Starting with the packet manipulation via the Mutate_Packet function (Line 25), the contents of P are mutated according to the mutation probabilities X i associated with the state S, resulting in a mutated packet P (see Section 3 for details of mutation).
Due to the probabilistic nature of X i , the mutation yields either an incorrect packet such that P = P (i.e., malformed) or a mutated packet which doesn't differ from the original packet (i.e., P = P).
If a malformed packet P is sent to the peripheral, the Bluetooth Core Specification allows the peripheral to respond with a packet that rejects P , i.e., one with a layer in the rejection(S).
Thus, the fuzzer perceives an anomaly if the response for a malformed P is other than a legitimate packet with one of its layers in rejection(S).
To this end, the expected set of layers (expected(S)) for state S is set to the rejection layers for state S (rejection(S)) (Line 32).
The redundancy module (iii in Figure 5) keeps a history P hist (initialized as / 0 at Line 7) of all the packets P generated by the model M BLE (Line 34) and sends a redundant packet P dup ∈ P hist to the peripheral at random chance (Lines 28 to 29).
The intention of this logic is to send out-of-order packets that may cause crash or anomalous behaviour onto the peripheral.
However, using redundancy may trigger some ambiguous behaviour which is not necessarily an anomaly.
For example, some BLE packets are not only tied to one single state and responses to them at a different state should not be flagged anomalous by the fuzzer.
In Section 3.2, we present how the validation module resolves such challenges and avoids reporting false positives.The fuzzing iteration finishes in one of three circum- Figure 3) and goes back to scanning state, 2) an anomaly is detected (Line 20), or 3) the fuzzer times out due to a crash in the peripheral (Line 13).
Optimization: Once a fuzzing iteration finishes, the mutation probabilities X i are refined by the optimization module (iv in Figure 5) via particle swarm optimization (Lines 37 to 41).
The optimization uses the value of cost function CF i obtained at the end of every fuzzing iteration (Measure_Cost_Function).
The rationale of optimization is to guide the mutation probabilities X i in such a fashion that the value of cost function CF i is maximized.
Specifically, the value of CF i represents a metric that can direct X i to fuzz packets that are more likely to optimize CF i (e.g., the number of anomalies).
Moreover, the refined mutation probabilities X i+1 are computed iteratively via Particle_Swarm_Opt and carried over to the next iteration (Line 41).
This approach allows our fuzzer to be directed and facilitates the search for anomalies in the peripheral's protocol implementation.
The fuzzing effectiveness critically depends on the generation of malformed packets based on mutation.
In the following, we discuss how such mutations are performed in detail.
Mutation: On receiving a generated packet from the protocol model, the fuzzing module evaluates it according to the set of mutation probabilities X i .
X i represents the probabilities to mutate a packet along two dimensions: 1) the layers, which correspond to different protocols or packet types of a packet, and 2) the fields, each belonging to a layer in the packet.
Figure 6 exemplifies the assignment of X i over the layers and fields of a BLE packet.
For instance, consider the Public Key layer to illustrate the use of X i in generating a packet.
The fields of Key_X and Key_Y can be mutated in an iteration only if the manipulation module randomly hits the layer probability chance (70%).
Once a hit happens, the fuzzer needs to decide the set of fields in the layer to be mutated.
To this end, the fuzzer iterates over each field within the layer and uses the individual mutation probability (50%) to mutate such fields.
We note that all the fields of one layer shares the same mutation probability.
This is to reduce the number of parameters during the iterative optimization (cf. Line 39 in Algorithm 1) without losing the efficacy significantly.
When the mutation indeed occurs onto a field, the field value is changed via a randomly-chosen Mutation Operator.Mutation Operators: The fuzzing module offers three Mutation Operators: 1) Random bytes that mutates the value of a packet's fields with random bytes, 2) Zero filling that clears the field value to zero, and 3) Bit setting that sets the most significant bit of a single-byte field value.
The rationale of choosing such operators is to accelerate the search process for an anomaly.
In practicality, Zero filling and Bit setting correlate to setting lower or higher values of a field value to manifest corner cases.
These, in turn, are probable to trigger a buffer overflow or underflow in a peripheral's implementation that lacks comprehensive bound checks.Optimizing Mutation Probabilities: In order to effectively discover anomalies (e.g., crashes or non-compliant behaviours against the Bluetooth Core Specification), our fuzzer employs a cost function to systematically guide the optimization process.
The rationale behind such an approach is to measure a cost function value CF i that informs how well a certain set of mutation probabilities X i perform with respect to finding new anomalies.
Therefore, the goal of the fuzzer is to maximize the discovery of potential anomalies by also maximizing the value of such a cost function.
We use the number of unique anomalies discovered throughout the fuzzing session as the cost function.
This is measured for each individual set of mutation probabilities X i (cf. Line 37 in Algorithm 1).
The set of mutation probabilities X i are refined while maximizing the cost function value on each fuzzing iteration by an optimization algorithm (cf. Line 41 in Algorithm 1).
For the optimization, we apply the particle swarm optimization (PSO) due to its superior performance in the light of non-linear and stochastic behaviour shown in the protocol model [32].
Moreover, PSO has been successfully applied in a state-of-the-art software fuzzer [23].
The goal of PSO is to optimize the value of a chosen cost function via regulating the position of the swarm of particles (i.e., the population).
In the context of our framework, the position is a probability value and each particle within the swarm of particles represents a different set of mutation probabilities X i .
The validation module detects responses that deviate from the Bluetooth Core Specification.
It emphasizes on the correctness of a response in its internal packet structure, i.e., layers of the response, and the correct reception order, i.e., the response's arriving state.
In particular, given a response packet received at state S, the validation module checks it among Expected layers or Rejection layers that are dedicated to state S in accordance with the protocol model M BLE .
Validation Exemplified: Figure 7 shows three different cases where a packet from the peripheral arrives in response to a packet sent to the peripheral at state S = pairing_request.
The packet sent to the peripheral can either be a valid packet P or a mutated packet P .
In case (A), on receiving the ATT Response due to a valid P, the validation module flags it as anomaly as none of the layers in the response is found in the Expected layers of state S.
In case (B), the response packet is deemed to be valid (i.e., pairing_response) since its layer is found in the Expected layers.
On the other hand, after sending a malformed packet to the peripheral, our fuzzer only expects Rejection layers (Line 32 in Algorithm 1).
In this sense, in case (C), our fuzzer sends a mutated packet P to the peripheral, and the response with SMP Failure is valid as a rejection of P , as SMP Failure ∈ rejection(S).
Validation Procedure: More involved cases beyond Figure 7 exist.
The validation module must correctly handle responses received due to legitimate, mutated, and/or redundant requests sent at both proper and improper states.Algorithm 2 illustrates the function Run_Validation called in Algorithm 1.
It validates if a response P r is anomalous or not.
The response P r , received at state S, might be due to possible P and P dup sent in an arbitrary fuzzing iteration (Lines 1 to 5).
At start, the validation module prepares the Expected layers in ε to be searched for P r , as P r might be a response to a non-empty P dup (Line 6 to 10).
We first compute the flag Ψ for state S. Ψ holds if the expected layers at S overlap with the expected layers of some other state S in the protocol model M BLE (Line 7).
The flag Ψ does not hold for security-related states such as states involved in SMP pairing and Link Layer encryption, e.g., smp_pairing and ll_encryption.
Specifically, these states (with Ψ false) do not accept any response except those aligned to their respective Expected layers.
We then check whether a non-empty P dup has been sent at any state M is a subset of all BLE states (M BLE ).
Specifically, response to a packet sent at a state S ∈ M p BLE is allowed to be received at any state where Ψ holds (i.e., states other than securityrelated ones).
Thus, given a non-empty P dup sent at a state of M p BLE , the validation module needs to extend ε if Ψ holds.
This is accomplished by joining ε with Expected layers of the state P dup belongs to (Lines 8 to 10).
With the updated ε, the validation module sets a validity flag based on whether the layers of P r are expected or not (Lines 11 to 12).
1: Input: Current state S of BLE protocol model (cf. Figure 3) 2: Input: Packet P sent from the current state S 3: Input: Packet P dup sent at the immediately preceding state of S 4: Input: Packet P r sent from BLE peripheral 5: Output: Absence of anomaly (true or false) 6: ε ← expected(S)7: Ψ ← ∃S ∈ M BLE \ {S}.
(ε ∩ expected(S )) = / 0 8: if P dup = / 0 ∧ Ψ ∧ state_of (P dup ) ∈ M p BLE then 9:ε ← ε ∪ expected(state_of (P dup )) 10 Wait for peripheral's response packet P r Run_Validation(S, P , / 0, P r ) 21: end if 22: return (is_valid, P r )The validation performs further acts before returning to Algorithm 1.
Firstly, in M p BLE there is a subset, i.e., M o BLE .
The response to the request sent at a state of M o BLE is allowed to be received in other states, but only once.
One such state is the Version state.
A normal peripheral responds to the version request only once irrespective of how many version requests it receives.
Hence, if P dup or P belongs to some state S ∈ M o BLE , then S is removed from M p BLE .
This ensures that future responses to P dup , which belongs to state S , are classified as anomalies (Lines 13 to 16).
Secondly, P dup and P may have the same response.
In this case, we do not trigger a state transition until a response to P is received (if any before the fuzzer times out).
Specifically, after handling the response for P dup , the validation module is recursively called with an empty P dup (Lines 17 to 21).
In the end, the anomaly flag and P r are returned (Line 22).
Crash detection: There are two options to detect a crash or unresponsiveness of the peripheral.
The intrusive option is applicable to BLE development boards that expose serial debug ports of their respective SoCs.
We can use the debug information to detect a crash.
For BLE products without such debug ports, we use a global timer and clear it on every packet response.
If no response is received from the peripheral, the timer eventually overflows and a crash is signalized.
Manipulation of the Link Layer is essential for fuzzing.
However, the Core Specifications [37] undermines Link Layer (LL) manipulation from the host.
Firstly, LL packets are heavily timing critical due to BLE frequency-hopping.
The host cannot send a packet in a precise time due to the high time variability of the OS scheduler.
Secondly, the LL stack runs on a separate and closed source Bluetooth chipset, i.e. the controller.
The chipset normally communicates with the host via the Host Controller Interface (HCI) protocol, which does not expose manual control over the LL stack.To overcome the aforementioned challenges with a practical and low cost solution, we design a non-compliant BLE controller firmware that ignores standardised conventions such as HCI and abstracts away the timing and retransmission requirement between the central and the peripheral.
This abstraction simplifies the BLE state machine and allows the host to manipulate all fields of the Link Layer packets.
Figure 5).
The controller reads packets from the host and transmits according to their radio channel type, which is inferred from the access address of the packet header.
Data channel packets are buffered in the Data Packet Buffer and released for transmission after a time period defined by the connection interval.
Concurrently, an advertisement packet is only transmitted to the peripheral after the controller receives an advertisement packet from the peripheral first.
Upon reception, the Packet Filter checks the packet for the peripheral address and upon a match, the advertisement packet stored in the Adv. Address Matching is released and transmitted to the peripheral after the inter-frame spacing ∆ IF = 150us.
Other procedures such as CRC calculation, whitening/dewhitening and encoding/decoding are only necessary to ensure the correct encoding of the packet during over-the-air transmission and as such, do not expose fields for host side fuzzing.
Implementation: Our implementation efforts have been mainly spent on two parts: 1) the fuzzer, including the modules of fuzzing, validation and optimization, and 2) the noncompliant BLE controller that enables the over-the-air fuzzing.
The fuzzer is written in Python 2.7 and C++ with a total number of 2,836 lines of code (LOC).
In brief, our fuzzer extends the Scapy v2.4.3 [33] to recognize packet types, parse and validate a response from the peripheral.
It also uses the BLESuite library [31] to handle the GATT Service Discovery.
As to the Table 1 shows the peripheral devices that we have tested.
In each of these devices, the CPU is a microcontroller (SoC) that runs an undisclosed BLE stack implementation.
IoT products using these devices only have access to interfaces for BLE communications provided by respective manufacturer-provided libraries.
As a result, the device's BLE implementation runs alongside the product's main code, and a BLE implementation vulnerability may lead to catastrophic failure and insecurities into the product's functionalities.
In other words, once BLE devices are found vulnerable, so are the IoT products relying on them.We need to install a firmware in each brand new device to enable BLE connectivity.
This is accomplished by compiling and programming a sample code provided by the device's corresponding SDK.
Once a programmed device advertises itself as BLE peripheral, we can start our fuzzer to test it.We answer the following research questions (RQs) through the evaluation of our fuzzer.
RQ1: How effective is our fuzzer in terms of generating error-prone inputs?A summary of testing results is depicted by Table 2.
The prefix V means a vulnerability while the prefix A means some anomalous behaviour that deviates from the legitimate behaviour defined by the Bluetooth Core Specification but is not a vulnerability.
Overall, our fuzzer has discovered 11 new vulnerabilities and seven anomalous behaviours over all tested devices.
The SoCs of particular vendors, e.g., Texas Instruments, NXP, Cypress and Dialog, have been used in many IoT products for Smart Home, wearables and gadget tracking.
These vulnerabilities expose their respective SoCs to crashes, deadlocks or even a complete or partial bypass of pairing procedure.
Hence the impact is significant.
It's important to emphasize that all vulnerabilities have been automatically discovered by our fuzzer during the packet exchange, except for vulnerabilities classified as Security Bypass.
After a Security Bypass is detected and classified as an anomaly by our fuzzer, a manual check is required to classify it as a security issue.
We note that twelve CVEs have been assigned, but at the time of writing this paper, the details of vulnerabilities V1-V11 were publicly undisclosed for confidentiality.
Moreover, we followed responsible disclosures and notified all vendors 90 days in advance for them to provide corresponding patches.
At the time of writing, all vendors except STMicroelectronics and Microchip have released their patches.
Table 3 highlights the SoCs and the SDK versions where these vulnerabilities were first discovered.
For each anomaly, Table 2 also outlines the specific section of the Bluetooth Core Specification being violated.
To summarize, the results signalize that the current status of BLE security demands more attention not only onto the design of protocols, but also onto the implementation phases.
Specifically, the two critical security bypass vulnerabilities (V6 and V11) are caused due to the lack of handling corner cases in the Bluetooth Core Specification, causing misinterpretations and implementation flaws.
A detailed description of the vulnerabilities is shown in the supplemental material.
When our fuzzer exchanges packets with the peripheral, the efficiency in finding anomalies mainly depends on two factors, i.e., the connection interval and the peripheral's capabilities.
While the first factor can be initiated by the central, the peripheral decides whether to accept the value of the connection interval proposed by the central.
The connection interval is the time between consecutive messages and thus controls the frequency of messages exchanged between central and peripheral.
It is negotiated at the connection state.
A short connection interval naturally leads to an efficient fuzzing process.
During the fuzzing process, the connection interval is fixed to a value that is acceptable to all tested devices.
Table 4 shows the overall time taken by our fuzzer to complete 1,000 iterations with a connection interval of 20ms.
Due to the diverse capabilities of devices, the message-processing time varies significantly even with the same connection interval.For instance, the CY5677 device is much slower in the pairing procedure, resulting in the longest evaluation time.The time required to find the first vulnerability in a peripheral's implementation depends on its features.
As shown by the rightmost two columns of Table 4, most of the first crash or other anomaly have been discovered within 10 minutes.
As a result, our fuzzer is opportune to ascertain a vulnerable implementation of BLE device.Finally, the last column of Table 4 holds the number of different valid transitions traversed in our BLE state machine (cf. Figure 3) after 1000 iterations.
Specifically, the BLE model employs a total of 54 valid transitions.
Overall, each peripheral traverses the model differently and does not trigger all possible valid transitions in our BLE model.
This is because states initial_setup, list_pri_services and list_sec_services allow multiple transitions and peripheral implementations differ in terms of the exact packet sequence accepted in such states.
This results in peripherals missing some transitions employed in the BLE model.
As per coverage efficiency, the fuzzer takes more time to fully explore unstable peripherals.
This is the case for peripherals impacted by vulnerabilities triggered in states with multiple transitions (V1, V2 and V8).
For example, peripherals from Cypress, NXP and STMicroelectronics exhibit a slightly lower coverage value for 1000 iterations.
RQ3: How do the different design choices contribute to the effectiveness of our fuzzer?To answer this question, we disable two components of our fuzzer to make two variants, respectively.
Firstly, we only keep the redundancy module active without packet mutation or optimization.
This means packets are sent at a wrong state to the peripheral.
Secondly, our fuzzer solely relies on the mutation module without optimization.
In this sense, we mutate valid packets from the protocol model M BLE according to a random set of mutation probabilities X i that is not refined after each iteration.
The two variants are referred to as "Redundancy" and "Mutation", respectively.
Figure 9 illustrates the number of anomalies with respect to fuzzing iteration for each relevant BLE SoC.
The "Evolution" represents the results achieved by our fuzzer with the optimization, which serves as a reference to compare against the two variants.
In all cases, "Evolution" results in finding all anomalies due to the collaborative contributions among all fuzzing components, while the two variants miss some anomalies (cf. Figure 9).
This is expected and shows that certain vulnerabilities can only be triggered by either redundancy, mutation or a combination thereof.
For example, the vulnerability Key Size Overflow (V10, cf. Section 2) associated with Telink TLSR8258, requires that the mutation and redundancy complement during the fuzzing process to trigger it.
That explains the superior effectiveness of "Evolution" in Figure 9(b).
Also in Figure 9, "Mutation" cannot achieve as many anomalies as "Redundancy".
This is because many anomalies indicated for "Redundancy" are due to the fact that A3 to A5 are triggered upon the peripheral receiving redun- dant packets in the BLE connection, but not by "Mutation" through sending malformed packets.
RQ4: How effective is our fuzzer compared to existing BLE fuzzing tools?We compare the competitiveness of our fuzzer by evaluating it against publicly available tools, including Stack Smasher, BLEFuzz, and bfuzz that most closely match the objective of our fuzzer.
We note that handcrafted efforts were required to apply these tools.
Firstly, bfuzz and Stack Smasher demand modifications so that they can send malformed packets through our BLE controller.
Secondly, both bfuzz and Stack Smasher were primarily developed for Bluetooth Classic implementations supporting only a few protocols like L2CAP and ATT.
Therefore, they also require adjustments for fuzzing L2CAP and ATT layers in BLE implementations.
Finally, BLEFuzz is the only tool that supports fuzzing BLE implementations.
Table 5 summarizes the comparison between our fuzzer and the three chosen competitors.For a fair comparison, we run our fuzzer and all the competitors for the same duration (≈ three hours).
As shown in Table 5, WB55 and BlueNRG-2 are the only two SoCs for which the competitors discover crashes (third column in Table 5).
Specifically, BLEFuzz and bfuzz discovered only V8.
For all other SoCs (cf. the "Others" column in Table 5), none of the competitors found either vulnerabilities or other anomalies.
In a nutshell, our fuzzer significantly outperforms all competitors, as exemplified in Table 5.
The reason is twofold.
Firstly, our fuzzer comprehensively models the BLE stack, e.g., it includes modeling and fuzzing SMP and LL protocols, which are not handled by other fuzzers.
Secondly, none of the competitors employ an optimization to refine mutation probabilities or send redundant packets.
As shown by Figure 9, these features are critical for fuzzing effectiveness.It is worthwhile to mention that a comparison with the aforementioned tools requires the usage of our non-compliant BLE controller (cf. Section 3.3).
This approach is justifiable, as currently there is no accessible BLE fuzzing alternative with the same level of control and flexibility as provided by our non-compliant BLE controller.
Finally, our comparison did not include traditional fuzzers such as AFL [44] due to their reliance in code coverage.
Such a metric is often difficult to obtain in the context of over-the-air-fuzzing, as commercial BLE stacks are undisclosed.
Furthermore, traditional fuzzers (e.g. AFL) lack the capability to generate a specific sequence of messages with strict timing constraints.
To extend traditional fuzzers with such capabilities requires significant changes to the underlying fuzzing engine.
Nevertheless, we Table 2, offers dangerous attack vectors against many IoT products.
An investigation of certified products on the Bluetooth Listing site [40] reveals that SWEYNTOOTH is likely to affect ≈480 IoT products using the vulnerable SoCs from Table 3.
These products are mainly applied in Smart Home, Fitness, Entertainment and Consumer Electronics.
To raise awareness of the threats and risks of potentially vulnerable products available on the market, we performed attacks on some representative IoT products that use the affected SoCs and recorded our observations.
Some salient features of these products are outlined in Table 6.
In Table 6, we also indicate the BLE SoC used by each product and the vulnerabilities discovered in these SoCs by our fuzzer.
We choose these products for their prevalence in the relevant application domains, e.g., Smart Home.
To exploit SWEYNTOOTH on an IoT product, we launch an attack code that captures the exact sequence of packet exchanges in the respective SWEYNTOOTH vulnerability.
One such example is an attack code for vulnerability V5 (found in CC2640R2) on CubiTag.
Next, we describe, for each chosen IoT product, the impact of the launched attack code.When attacking Fitbit Inspire, the smartwatch freezes its screen and immediately restarts when the Link Layer Overflow (V1) is attempted.
By contrast, LLID Deadlock stops Fitbit advertisements for several seconds before the smartwatch abruptly restarts.
Similarly, when Silent Buffer Overflow is exploited on both Eve Energy and August Smart Lock, users can immediately experience their smart things being restarted (e.g., via a beep sound in the smart lock and switching off the light attached to the Eve Energy plug).
This is especially crucial for Eve System products, as the company relies almost entirely on the vulnerable DA14680.
As for CubiTag, the attack exploiting Public Key Crash (V5) immediately stops the tracker to advertise and puts it in deadlock.
Only a manual restart by opening CubiTag (e.g., via a screwdriver) and re-attaching its battery brings CubiTag back to a working state.
Finally, when the Invalid connection request (V7) is exploited on eGeeTouch TSA Lock, it hangs and the user needs to manually press the power on button for further interaction.
Security is critical for IoT devices [7].
Existing Bluetooth vulnerabilities, such as Blueborne [34], BleedingBit [15] and KNOB [1], allow unauthorized remote access or remote code execution.
They mostly require tedious manual effort (e.g., reverse engineering and inspecting code) and careful inspection of the protocol standard.
By contrast, we provide a systematic and automated approach to discover BLE implementation flaws in any BLE device.Existing works based on static analysis or verification technologies [14,25,27,42] either suffer from false positives or are incapable to generate concrete packet sequences to trigger communication in real devices.
An existing test generation approach targeting network protocol implementations [30] require access to the implementation code.
Although a recent work packetdrill [5] provides a testing framework of the entire TCP/UDP/IP network stack, it lacks support for automated test packet generation.
Similarly, Jero et al. [16] devised a technique to search a reduced state-space for suitable attack injection in stateful protocol implementations, but does not employ a comprehensive and directed approach for fuzzing packets.
Furthermore, our validation strategy, being employed directly at the central, differs from passive wireless validation [35] that requires a sniffer.
Finally, none of the aforementioned works set foot in Bluetooth.Directed fuzzing is a prevalent software testing strategy [4,17,19,21,29,43], yet faces significant challenges in the context of over-the-air fuzzing.
Firstly, vulnerabilities in wireless protocol implementation often appear with a sequence of packets being injected even with strict time constraints.
Traditional stateless fuzzers such as AFL [44] are mostly suitable for single input leading to vulnerabilities.
Secondly, most of the commercial wireless protocol stacks are undisclosed.
Thus, it is often not possible to have a greybox (e.g. based on code coverage) or whitebox approach (e.g. based on symbolic execution) for wireless security testing.
Thirdly, wireless protocols often exhibit stochastic behaviour, packet drops and packet retransmissions due to the inherent nature of the wireless medium.
This introduces additional complexity in security testing, especially in terms of distinguishing normal and abnormal behaviour.
Fourthly, wireless protocol stacks often impose isolation between link layer and host layer protocols.
A comprehensive security testing should break such isolation to find zero day vulnerabilities.
Finally, detecting critical security issues in a wireless implementation, such as security bypass, requires significant changes to the underlying vulnerability detection logic of traditional fuzzers.Emulation-based fuzzing [13] can obtain coverage information directly from the firmware and is faster than over-the-air fuzzing [26].
Nonetheless, such approaches require extensive reverse engineering of the firmware (if accessible at all) for a substantial number of wireless devices.
For example, Frankenstein [20] is an emulation-based fuzzing approach that works with only specific Cypress/Broadcom firmware and demands significant engineering effort to handle other devices.Previous works in Bluetooth fuzzing [3,9,18] support only L2CAP and ATT layers and do not employ test optimization for fuzzing effectiveness.
InternalBlue [24] investigates the lower level of Bluetooth implementation and allows BLE packet sniffing and injection.
However, InternalBlue can work only after the peripheral is connected and the number of accessible fields in a packet is limited.
Our fuzzing framework, by contrast, allows packets injection, fuzzing and sniffing directly from the host and during the BLE connection process.Our work is orthogonal to several works on network protocol testing [2,12,28] that target text structured protocols e.g. ftp and http, yet they ignore wireless protocols including BLE.
A recent work [8] targets the discovery of memory corruptions in IoT devices by fuzzing the mobile app through which the device is accessible.
Our work neither intends to fuzz the application layer nor relies on the availability of a mobile app.
Moreover, by design of our validation component, our fuzzer can discover security vulnerabilities beyond memory corruptions e.g. security bypass.In summary, our work is the first comprehensive approach to systematically and automatically fuzz arbitrary BLE protocol implementations.
Also, this is accomplished without changing anything in the OS/firmware of tested device.
This paper presents a systematic and automated framework for fuzzing arbitrary BLE implementations.
This is engineered with the aim to discover implementation behaviours that deviate from Bluetooth Core Specification.
The efficacy of this framework is exemplified via the discovery of 11 new security vulnerabilities, named SWEYNTOOTH, across seven BLE SoCs.
Moreover, we exploit several SWEYNTOOTH vulnerabilities on popular IoT products used as wearable, smart home products and logistic tracking, among others.
This further shows the danger and criticality of SWEYNTOOTH vulnerabilities, potentially affecting a few hundred types of IoT products.
Our fuzzer shares the limitation of any framework based on testing.
This means, our fuzzer does not guarantee the security of a BLE device even if it fails to discover any anomalous behaviour.SWEYNTOOTH highlights concrete flaws in the BLE stack certification process.
We hope that our work provides an opportunity for further research in the area and initiates technologies to harden and secure current and next-generation wireless protocol implementations.
For reproducibility and research, the fuzzer source code is available upon request to sweyntooth@gmail.com.
All exploits are publicly available in the following URL:https://github.com/Matheus-Garbelini/sweyntooth_ bluetooth_low_energy_attacks
