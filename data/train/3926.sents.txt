Side channels remain a challenge to information flow control and security in modern computing platforms.
Resource partitioning techniques that minimise the number of shared resources among processes are often used to address this challenge.
In this work, we focus on multi-core platforms and we demonstrate that even seemingly strong isolation techniques based on dedicated cores can be circumvented through the use of thermal channels.
Specifically, we show that the processor core temperature can be used both as a side channel as well as a covert communication channel even when the system implements strong spatial and temporal partitioning.
Our experiments on an Intel Xeon server platform demonstrate covert thermal channels that achieve up to 12.5 bps and weak thermal side channels that can detect processes executed on neighbouring cores.
This work therefore shows a limitation in the isolation that can be achieved on existing multi-core systems.
Covert and side channels have for a long time remained an open threat to information flow control and isolation techniques in a variety of contexts including cloud and mobile computing [50,71,76].
Such channels can be used for data exfiltration from a victim [17] and be exploited by colluding applications to covertly exchange information [46].
A common technique to mitigate covert and side channel attacks that leverage co-location is to dedicate resources (e.g. processor cores, memory) to individual processes for the duration of their execution.
Although seemingly inefficient, such a technique is becoming viable with the appearance of multi and many-core systems which contain hundreds of cores [12].
However, it has already been shown that, due to their architecture and use, multi-core systems do not trivially protect against all types of information leakage -covert channels have been demonstrated by exploiting shared caches [35], memory bus [34], network stacks [54], virtual memory [72], I/O devices [64], etc.
These covert channels, however, still exploit the resources that particular multi-core platforms, for performance and other reasons, share among the processes.
The threats arising from covert and side channel attacks led to the development of mitigation techniques such as partitioning of the shared resources when possible, for example, partitioning caches [68] and bus bandwidth [31].
In this paper, we show that even strong isolation techniques based on dedicated cores and memory can be circumvented in multi-core systems through the use of a thermal channel.
For this, we leverage the temperature information that is exposed to processes for performance reasons on multi-core platforms and two aspects of the thermal behaviour of these systems.
First, the thermal capacitance and resistance of computing platforms result in remnant heat from computations, i.e. the heat is observable even after that computation has stopped.
As a result, information about one process may leak to another that follows it in the execution schedule.
Second, the effects of heat resulting from processes running on one core can be observed on other cores across the chip.
This leaks information about a process to its peers running on other cores in a processor chip.
We demonstrate our attacks on commodity multi-core systems.
So far, thermal (heat) channels have not been studied on these systems.
There is a trend towards exposing thermal data to users and allowing them to make thermal management decisions based on it [21].
For example, temperature information is accessible from user-space on modern Linux systems [1].
This paper highlights the tension between building thermally-efficient systems which requires exposing high-quality temperature data to applications and securing them.In summary, we make the following contributions: (i) We demonstrate the feasibility of using thermal covert channels for communication between colluding applications.
We measure the throughput of such a channel on an Intel Xeon server with two processors containing 8 cores each.
The challenges in building such a channel include the system's thermal capacitance, effect of cooling on multi-core systems and resolution limitations of the thermal sensors available on these platforms.
Although thermal covert channels have a low throughput, sensitive data such as credit-cards (16 digits) can be transmitted within 5 seconds to 4 minutes even on systems that use resource partitioning.
(ii) We explore the factors that influence the throughput of this covert channel -processor frequency and relative locations of the colluding applications (processes) and show the throughput varies between 0.33 bps and 12.5 bps.
(iii) We demonstrate the existence of limited thermal side channel leakage from processes running on adjacent cores that allow identification of applications based on their thermal traces.
On existing systems, heat-based leakage is non-trivial to avoid without a performance penalty; we discuss possible countermeasures to eliminate or limit the impact of such attacks.The rest of this paper is organised as follows.
In Section 2, we discuss the background and motivation for our work.
Section 3 discusses the thermal behaviour of x86 platforms and Section 4 describes how these properties can be exploited to create thermal channels.
In Section 5, we demonstrate the feasibility of using thermal channels for covert communication even in systems with isolation based on resource partitioning.
Section 6 demonstrates that limited side channel leakage can occur through thermal channels which can be exploited for unauthorised application profiling.
Section 7 and Section 8 summarise countermeasures against thermal channels and related work respectively.
Finally, we conclude in Section 9.
In this section, we summarise the use of thermal information in modern processors and resource partitioningbased isolation techniques, as well as provide a motivation for our study.
Thermal management is key to the safe and reliable operation of modern computing systems.
Today, thermal sensors are incorporated into a number of system components including hard-drives, DRAM, GPU, motherboards and the processor chip itself [9].
In this work, we focus on the information available from thermal sensors that are embedded in processor chips.Ensuring the thermal stability of a processor is becoming increasingly challenging given the rising powerdensity in modern processor chips.
As a result, major processor vendors (e.g. Intel, AMD, VIA) incorporate thermal sensors to enable real-time monitoring of processor temperature.
ARM-based processors also include thermal sensors inside the system-on-chip for power and temperature management.Initially, thermal management was done statically in hardware and included mechanisms to power-off the processor to prevent melt-downs.
This later evolved to more sophisticated dynamic frequency and voltage scaling techniques that change processor frequency to lower its temperature [13,39].
Hybrid software-and hardwareapproaches to thermal monitoring have become popular over time; operating systems today poll temperature sensors and use this to manage cooling mechanisms such as processor frequency-scaling and fan-speed [2].
More recently, there is a trend towards user-centric thermal management that exposes thermal data to users and allows them to implement customised thermal management policies.
For example, Linux-based systems today enable users to configure thermal policies [14,21].
The number and topology of thermal sensors depend on the processor vendor and family.
For example, while Intel and VIA processors expose temperature data for individual cores using on-die sensors, some AMD (e.g. Opteron K10 series) processors only allow monitoring the overall temperature of the entire chip using a sensor in the processor socket [1].
Optimising the number and placement of thermal sensors on processors is an active research topic [47,53,55].
Isolation techniques for multi-core platforms that are based on resource partitioning offer a number of benefits.
First, resource management approaches that rely on partitioning reduce the size of the software Trusted Computing Base (TCB).
In fact, resource partitioning is gaining popularity as a means to create multiple, isolated execution environments without the need for a software TCB in servers [6] and networked embedded systems [57].
Second, the simplicity of partitioning-based resource management eases formal verification and this is leveraged by separation kernels like Muen [23].
Third, modern processors rely on partitioning techniques to build Trusted Execution Environments (TEEs).
TEE technologies such as Intel Trusted Execution Technology (TXT) [40], Intel Software Guard Extensions (SGX) [52] and ARM TrustZone [15] protect the execution of security-sensitive software from a compromised operating system.
Intel TXT relies on temporal partitioning of resources such as CPU and memory between trusted and untrusted software.
Intel SGX and ARM TrustZone use temporal partitioning only for the CPU and implement spatial partitioning for memory resources in the system.Resource partitioning has already been proposed as a countermeasure against covert channels [30] and side channels [68].
This is because most covert and side channels exploit shared resources.
For example, a process can modify shared resources (e.g. cache, file) to communicate covertly with another colluding process.
An attacker can also exfiltrate sensitive information from a victim process by tracking the state of a shared resource such as cache.
Therefore, there have been proposals for minimising shared resources to reduce the number and effectiveness of covert and side channels.
Examples include partitioning of caches [68] and bus-bandwidth [31].
The main motivation behind this work is our observation that despite its security advantages, resource partitioning on multi-core systems might not be able to completely eliminate some types of inference or communication across partitions.
More specifically, we want to investigate if the exposure of core temperature information could be used to build both side channels and covert communication channels between processes that execute on different cores within a multi-core system.
Our goal is to study these channels primarily in terms of their feasibility and throughput.Thermal channels are particularly interesting in the context of multi-core systems for two main reasons: (i) today, these platforms expose the information from thermal sensors to users and (ii) thermal channels can be tested for their effectiveness under the resource partitioning-based isolation mechanisms that multi-core systems can support.
To build thermal channels, it is necessary to understand the type and quality of temperature data available on systems today.
One must also account for the nature of temperature variations on such systems and the factors that affect them.
We focus on Intel x86 platforms for our study given their wide spread use.
In this section, we present theoretical and empirical aspects of the thermal behaviour of x86 systems.
More specifically, we first discuss recent attempts to analyse, model, and simulate the thermal behaviour of the stateof-the-art processors.
Then, we discuss the on-die thermal sensors available on Intel processors and the thermal behaviour of these platforms under a CPU-intensive load.
The most common abstraction of the thermal behaviour of processors is the resistor-capacitor mesh network model.
This model is based on the well-known duality between thermal and electrical phenomenon [36].
Each physical layer of the processor is modelled separately as a resistor-capacitor mesh.
The heat flow between the layers itself and eventually to the environment is represented by connecting the various meshes using additional resistors and capacitors.
Such an approach [28] assumes that it is possible to approximate the thermal properties of a processor using a linear model.
It also captures factors such as high thermal resistivity of silicon, heat-sinks and fan cooling that affect overall processor temperature.Alternative empirical approaches that approximate thermal behaviour using measurements from on-die thermal sensors and machine learning techniques have also been explored (e.g. [60]).
The advantage of such an approach over using traditional models is that it does not need information such as detailed design parameters (e.g. floorplan of the processor) which are usually not readily available.Given the complexity of modern commodity processors and the lack of public information required to accurately model them, in this paper, we focus on a more empirical approach.
We use measurements from the ondie thermal sensors to understand the thermal behaviour of commodity systems.
Intel labels each of its processors with a maximum junction temperature which is the highest temperature that is safe for the processor's operation.
If the processor's temperature exceeds this level, permanent silicon damage may occur.
To avoid such processor melt-down, Intel facilitates processor temperature monitoring by incorporating one digital thermal sensor (DTS) into each of the cores in a processor.
The layout of the cores within a processor chip can be identified using lstopo [7] on a Linux machine.
For example, on the Xeon server used in our experiments, the cores are arranged along a line (as shown in Section 5.1).
Each DTS reports the difference between the core's current temperature and the maximum junction temperature [3].
The accuracy of the DTS varies across different generations of Intel processors.
They typically have a resolution of ±1 • C.The absolute value of a core's temperature in • C is computed in software by subtracting the thermal sensor reading from the maximum junction temperature.
Thermal data from a sensor can be obtained using special CPU registers of the corresponding core.
The data from all sensors is exposed using the coretemp kernel module [1] on Linux systems.
This information is accessible from user space through the sysfs filesystem which is refreshed every 2 ms. To illustrate how computations affect the temperature of a core, we ran a CPU intensive application -more specifically, one that does an RSA decryption continuously in a loop.
We ran the application on core 3 of an octa-core processor (for setup details, refer to Section 5.1).
Fig- ure 1 shows the recorded temperature trace of core 3 during the execution of the application for 100 s (between the dotted red lines) on it and for about 50 s thereafter when the core cools.
We observe that 25 ms after the application begins execution, the temperature rises by 5 • C from approximately 35 • C to 40 • C. Following this rapid rise, the temperature increases very slowly and saturates at 43 • C.
As soon as the application stops executing, the temperature falls rapidly to 38 • C in about 25 ms and takes an additional 11 s to reach 35 • C.The exponential nature of the temperature rise and fall is a result of the system's thermal capacitance and resistance.
The temperature fall curve shows that the temperature changes caused by such an application's execution can be observed for sometime after it has stopped.
Figure 2: Effect of Processor Frequency on Thermal Behaviour.
Temperature profiles produced by running a CPU intensive application on a core at different processor frequencies for 100 s.
The major factors affecting the temperature at a particular core are the fan speed, processor frequency and heat propagation from neighbouring cores.
Since, in our experiments, we do not control the server fan speed (see Section 5.1), we only discuss the effect of the processor frequency and heat propagation on a specific core's temperature below.CPU Frequency.
Most Intel processors are designed to run at a set of discrete frequencies for optimising power consumption.
For example, in our setup (Section 5.1), the Xeon server can run at frequencies between 1.2 GHz and 2.9 GHz.
All cores within a single processor chip run at the same frequency.
Changes in frequency at a given core are reflected across all the other cores.
The actual frequency can be controlled either by the user or by the kernel; for example, Ubuntu systems allow users to control this using the sysctl interface.
Figure 2 shows how the processor frequency affects temperature when a CPU-intensive application runs for 100 s.
We can observe that higher frequencies result in more heat and higher saturation temperatures.
This is because processor operation at a higher frequency results in a larger power density and therefore, more heat.Heat Propagation From a Neighbour.
The heat resulting from computations on one core will propagate to neighbouring cores.
As a result, the temperature at a certain core depends not only on that core's workload (type of computation and schedule) but also those of its neighbours.
Effect of running a CPU-intensive application on core 3 of an octa-core processor for 100 s on the temperature sensors of its adjacent cores.
Figure 3 shows the effects of a CPU-intensive application executing on a central core (core 3) of an octa-core processor for 100 s.
We notice that the computation on core 3 affects the temperature sensors of its neighbouring cores which remain idle all through.
Additionally, we observe that the saturation temperature of a neighbouring core decreases with increasing distance from core 3.
This effect is not symmetric as one would expect on either side of core 3.
We suspect that this is due to an asymmetrically located processor hotspot or asymmetrically positioned thermal sensor.
In this section, we present the intuition underlying the construction of thermal channels on multi-core systems.
Isolation techniques that rely on resource partitioning are becoming increasingly popular and there have been a number of proposals for using such partitioning to prevent covert and side channels [31,68].
In our work, we consider two most common types of process isolation and partitioning techniques: Spatial and Temporal as shown in Figure 4.
In spatially partitioned systems, processes are isolated by being assigned exclusive computation resources, i.e. no two processes share cores or memory.
Such an approach prevents certain types of side channels between processes that execute concurrently.
For example, cache-partitioning prevents any information leakage that may occur based on the state of the cache-lines in a processor (e.g. how many cache-lines are full).
In such systems, processes do not share any processor temperature sensors because they do not use any common CPU resources.
In temporally partitioned systems, the processes share the same resources but run in a time-multiplexed manner.
For example, this technique is used by TEEs like Intel TXT in which only one of two partitions (trusted or untrusted) are active at a time but have access to common cores and memory.
In systems that employ temporal partitioning, processes that share one or more cores have access to the corresponding temperature sensor(s) during their execution time-slice.
Thermal channels that leverage system thermal behaviour can be used to circumvent both these types of isolation techniques as we describe below.SOURCE SINK PROCESSOR ...........
C 1 C 2 C 3 C n C n-1 CORE S 1 S 2 S 3 S n-1 S n THERMAL SENSOR TIME ON OFF TIME TEMPThe sink uses its recorded temperature trace to decode the information sent by the source On core C, the source executes a heatintensive task (ON) to send bit '1' or remains idle (OFF) to send bit '0'....... : Covert communication using Thermal Channels.
We demonstrate that the temperature sensors on commodity multi-core platforms can be misused for covert communication by two colluding processes in spatially and temporally isolated systems.
Based on our discussion in Section 3, we make two observations that can be used to construct thermal channels.Remnant Heat.
Since temperature variations that result from a computation can be observed even after it stops, these variations leak information regarding the computation to the process that follows it in the execution schedule especially if they share the same core.
This remnant heat can be exploited as a thermal side channel and may allow a process to exfiltrate sensitive information from its predecessor thereby violating temporal partitioning.
Furthermore, it can also be used for communication between two colluding processes that time-share a core.
Note that while it is possible to reset most resources (e.g. CPU registers, caches) to prevent other types of channels before switching between applications, the remnant heat from a computation (and hence, a thermal channel) is hard to eliminate.Heat Propagation to a Neighbouring Core.
The thermal conductivity of the processor results in heat propagation between cores, i.e, the heat that results from a computation not only affects its underlying core's temperature but also its neighbouring cores.
This heat flow can be exploited as a thermal channel by an attacker to make inferences about a potentially sensitive computation at a neighbouring core.
Colluding processes can also use the heat flow to communicate covertly.
Since it is hard to eliminate heat flows within processors, thermal channels are a viable threat even in spatially partitioned systems.
There are several challenges involved in the construction of thermal channels.
First, the nature of temperature changes makes it hard to control the effect that an application's execution will have on the temperature of its own core and its neighbours.
Second, the limited resolution of the temperature sensors available on current x86 platforms prevents fine-grained temperature monitoring.
Finally, fan-based cooling mechanisms affect the rate and extent of temperature variations.
In this section, we present the feasibility and throughput of communication using thermal covert channels in spatially and temporally partitioned multi-core systems.We first describe our experimental setup that implements such isolation mechanisms.
Throughout, we refer to the data sender as the source and the recipient as the sink.
Our setup is based on an Intel server containing two octacore Xeon processor chips and running an Open SUSE installation ( Figure 5).
We use cpusets [4] to implement spatial and temporal partitioning.
Using cpusets, we restrict the OS to one of the processor chips (Processor 2) and isolate it from the rest of the system.
We achieve spatial partitioning by running the source and the sink on Figure 5: Our Experimental Setup.
Our framework consists of an Intel Xeon-based server platform running Suse Linux.
We use cpusets to achieve spatially or temporally isolated source and sink applications.
We wrote a custom source application that uses RSA decryption operations to generate heat and a sink application that records its own core's temperature continuously.separate cores on the Processor 1 with minimal interference from the OS.
To realise temporal partitioning, our system incorporates a scheduler that controls the duration and cores on which the source and sink execute.We wrote a custom application that performs an RSA decryption (using PolarSSL [10]) continuously in a loop and we use it as the source application of the covert channel.
We chose a compute intense benchmark like RSA because thermal sensors are typically located in the processor's region which is most likely to experience very high temperatures, such as the ALU [53].
Hence, this benchmark can quickly increase CPU temperature.
This choice of benchmark also complies with popular thermal benchmarks (e.g. CStress [5], mprime [8]), that contain applications which extensively use the CPU register file and ALU.We rely on the server fan for cooling the cores.
Our server allows the fan-speed to be configured only through the BIOS.
We set the fan-speed to the maximum allowed value (15000 rpm) for our entire study.
We chose this setting because it is the most likely setting for servers which run computationally intensive tasks.
Our server is currently in a room whose ambient temperature is around 22 • C.
We also implemented a custom sink application that records the temperature of the core on which it executes continuously.Our experimental framework is implemented using C.
It allows configuration of run-time parameters like the processor frequency, set of applications to run, their schedule and mapping to cores.
Initialisation and tear down of the measurement framework is performed using a set of Perl and Bash scripts.
Our setup allows us to achieve spatial and temporal isolation; this makes it an ideal platform for our investigation of thermal channels.
This section addresses the construction of thermal channels in the scenario where the source and sink applications run on dedicated cores and execute concurrently.
The sink has access only to its own core's temperature sensor and not that of the source as described in the upper part of Figure 4.
To communicate covertly in such a scenario, the source exploits the heat propagation from its own core to the sink that runs on a neighbouring core.
In this section, we demonstrate the feasibility of achieving this on a commodity multi-core platform and evaluate the throughput of such a communication channel.
Below, we first present the encoding scheme that we use for data transmission and then describe the experiments that realise covert communication using the thermal channel.Encoding and Decoding.
The source and sink use OnOff Keying for their communication.
To send bit '1', the source application runs RSA decryption operations to generate heat and to transmit bit '0', it remains idle.
It is important that the source application runs long enough to affect the sink's temperature sensor on a neighbouring core to send bit '1', i.e. it must generate enough heat to raise the temperature of the sink's core above the ambient temperature.
We denote the minimum duration for which the source application needs to execute to transmit a '1' bit to the neighbouring cores as T b .
The source remains idle for the same duration to send a '0' bit.
We assume that the source and sink a priori agree on T b and a fixed preamble to mark the start of the data.
The sink that records the temperature of its own core continuously does the following to decode the data.
It first searches the recorded temperature trace for a fixed preamble.
We choose a preamble starting with bit '1' because it can clearly be identified by the sink.
To detect the start of the preamble, the sink searches for a '1' bit by detecting the first rising edge, i.e. a temperature increment ≥ 2 • C given its ambient temperature.
We use this threshold because the resolution of the sensors on the platform is ±1 • C.
It then tries to decode the bits following this to see if they match the preamble.
The source repeats this until it recovers the preamble from the temperature trace.
It then decodes the remaining bits using a simple edge detection mechanism in which a rising edge indicates bit '1', a falling edge indicates bit '0' and a no-change implies that the value is the same as the previous bit.
Temperature Drift due to the Sink's Execution.
The sink relies on the source to affect its core's temperature sensor for communication.
However, to do this, it is necessary to isolate any temperature drifts that may be caused by the sink's execution itself on its own temperature sensor.To understand these drifts better, we run the sink for a long time and observe its temperature.
Figure 6 shows the temperature trace of core 3 when the sink is running on it for 400 s and the other cores are idle.
The core's temperature remains stable at around 33 • C for 200 s and later drifts slowly towards 34 • C. Therefore, we conclude that the temperature changes caused by the execution of the sink process itself is negligible over a long duration of time (e.g., 200 s).
Calibration of T b .
Before the actual transmission of data, we have to determine the optimal value of T b , i.e. the duration for which the source executes or remains idle to send bit '1' and bit '0' respectively.
Note that the actual value of T b depends on the relative locations of the source and the sink.
This is because the effect of the source's execution affects the cores farther away from it to a lesser extent (see Section 3).
For our first experiments, we fix the source to execute on a core 3 because it is a central core and the sink to execute on core 2.
We later describe the effects of increasing the distance between the source and the sink on T b .
To estimate T b , we first set it to a value between 50 ms and 1500 ms. We then attempt to send 100 data bits from the source on core 3 to the sink on core 2 and observe the resulting temperature traces on core 2.
We do this by configuring the source application to be active and Table 1: Calibration of T b in Spatially Partitioned Systems.
We send a block of 100 bits consisting of alternating ones and zeroes using different T b values from the source (core 3) to the sink that runs at one and two hop distances from it.
The processor frequency was set to 2.9 GHz and this table shows the resulting bit-error rates ('-' indicates that the data could not be decoded).
We observe when T b ≥ 500 ms, we can decode data with less than 15% error at one hop but this does not improve much by increasing T b to 1500 ms. We also notice that the required T b increases with greater distance from the source.
At a one hop distance, setting T b = 750 ms and using Hamming(7,4) error correction code results in a channel throughput of up to 0.33 bps.idle for T b alternately.
Our data consist of 50 alternating ones and zeros.
We choose this data sequence because it is important to ensure that the chosen T b consistently results in the desired temperature increment on core 2.
We were unable to decode data when T b was smaller than 250 ms. We observe that data transmission using T b ≥ 500 ms results in about 10% bit errors (Table 1).
Furthermore, we notice that the bit error rate does not improve much by increasing T b from 500 ms to 1500 ms. Figure 7 shows the temperature traces of the two cores during the data exchange using a T b = 750 ms. The data shown here has been post-processed to remove noise using a smoothing function.
We observe that the temperatures of core 3 and core 2 are well-correlated (correlation co-efficient 񮽙 0.55, p-value = 0).
Error Rate.
To understand the nature of errors in thermal channels, we send a pseudorandom sequence of a 1000 bits in 100-bit blocks.
Each block begins with a preamble to enable the sink to detect the start of data transmission.From our initial experiments, we observe that the temperature traces of core 2 and core 3 are well-correlated in time over a sequence of alternating ones and zeros (Figure 7).
Therefore, we choose a preamble of five alternating ones and zeroes (10 bits in total).
The source and sink synchronise in 9 out of 10 tests and the average error rate is 13.22 % (± 5.19) for a T b value of 500 ms. On increasing T b to 750 ms and 1000 ms, the source and sink synchronise over all 10 tests and the average error rate is 11.3% (± 2.83) and 11% (± 3.83) respectively.Varying the Sink's Location.
We repeat similar experiments by running the sink on core 1 and core 0 which are two and three hops away from the core 3 to see how the error rate varies with increasing distance from the source.
At a two hop distance, we observe that for a given T b , the error rate is higher than in the case of the one hop (Table 1).
At a three hop distance, we were unable to decode data at 1500 ms. However, increasing the value of T b sufficiently will allow data transmission at a 3-hop distance.
For example, Figure 3(c) shows an extreme case in which T b is set to 200 s to transmit bit '1'.
The increased error rate and deterioration in the ability to decode data is expected.
This is because heat resulting from computations at a given core affects the cores closer to it more than the cores farther away.
We repeated the experiments to estimate the error rate from the source (core 3) to a sink running on core 1 at a two hop distance.
We observe that the source and sink synchronise successfully in 9 out of 10 tests.
We can transmit data at the rate of 1 bit in 1.5 s (T b = 1500 s) with an error rate of 18.33% (±4.21).
Effect of Frequency on T b .
To understand the effect of processor frequency on T b , we repeated our experiments for 1-hop communication at lower frequencies, namely, 2.4 GHz and 1.9 GHz.
As shown in Table 2, for a given T b , the error rate increases at lower processor frequencies.
When the processor frequency is set to 1.9 GHz, we could not decode data even at 1500 ms. We note that using a larger value for T b would solve this problem and can be done using the same methodology we used for We send a block of 100 bits consisting of alternating ones and zeroes using different T b values from the source (core 3) to the sink (core 2).
The table shows the resulting bit-error rates at different processor frequencies ('-' indicates that the data could not be decoded).
We observe that when the processor runs at lower frequencies, T b has to be increased to achieve lower bit-error rates.our experiments.
This deterioration in error rates and the ability to decode data itself is expected because lower frequencies result in lesser heat generation from a given computation.
Therefore, the rise in temperature may not be significant enough to detect a bit '1' .
We repeated the data transmission experiments when the processor frequency is set to 2.4 GHz.
We transmit a pseudo-random sequence of 1000 bits in 100-bit blocks.
Each block is preceded by a preamble and is sent from the source (core 3) to the sink (core 2) using T b = 1250 ms and 1500 ms. In both cases, the source and sink synchronise in all 10 tests.
The observed error rates in both cases is similar, i.e. 14.9% (± 3.9) and 15.9% (± 6.08) for T b = 1250 ms and T b = 1500 ms respectively.Throughput Estimation.
From the above discussion, we conclude that the throughput of thermal covert channels in spatially partitioned systems depends on number of factors.
This includes the time required to transmit one bit of information (T b ) and error rates.
Both these parameters in turn depend on the processor frequency and the distance between the colluding processes.At 1-hop distances, given a T b of 750 ms, the throughput would be 1.33 bps in the ideal case without any errors.
However, due to the 11% errors that we observe in the experiments, actual communication would require error correction to be implemented.
When we analysed the nature of the errors, we found that for every four bits, with a probability of over 0.9, there was one or no errors.
Therefore, we could use a Hamming (7,4) errorcorrection code to correct for these errors.
This would result in 75% overhead and hence, an effective throughput of 0.33 bps.
When the frequency is changed to 2.4 GHz, the throughput is about 0.2 bps using a Hamming (7,4) error correction code.
A similar trend was observed on increasing the distance between the source and sink.
Although the thermal channel's throughput is low, it still allows the transfer of sensitive data like credit-card information (16 digit) in a few minutes.
We discuss other factors that affect the thermal channel's throughput in Section 5.4.
Temporal partitioning schemes securely multiplex the same resources (e.g. cores, memory) between several applications.
Systems that use this technique mitigate information leakage through side channels by clearing caches, registers, etc. while switching between processes.
However, the thermal footprint of an application (the source) remains intact for observation by the other application that executes after it on the same core (the sink).
This is a result of the thermal capacitance and resistance of processors and can be exploited to communicate covertly as our experiments demonstrate.Scheduling, Encoding and Decoding Schemes.
In temporally partitioned systems, a scheduler determines the order in which different partitions execute on a core.
Therefore, we implement a scheduler ( Figure 5) that realises this functionality.
Since the sink and source share the same core, they run in an interleaved manner and the sink has access to the temperature sensors only during its execution time-slice (t s ).
Note that t s is controlled by the system's scheduler while T b is controlled Calibration of T b .
We consider the scenario in which the sink and the source share a core and run in a roundrobin fashion.
The source heats up the processor (bit '1') or stays idle (bit '0') to send one bit of information to the sink application that runs immediately after.
In order to understand how fast one can transmit bits over such a channel, we do the following.
We try to send an alternating sequence of 50 ones and 50 zeroes from the source to the sink.
We vary T b between 10 ms which is the minimum value that our framework allows and 30 ms. The source and sink run on core 3 in our experiments.
Figure 8 shows an example temperature trace that the sink records during its execution.
Note that the sink has access to the shared core's temperature sensor only during its own time-slice.
We observed no errors in the data that the sink decodes for T b ≥ 10 ms and therefore, use this value for further experiments.
We also repeated the experiment on the cores at the corners (core 0 and core 7) and noticed similar results.Error Rate.
To understand the nature of errors in this channel, we send a pseudorandom stream of 1000 bits in 100-bit blocks using T b = 10 ms. We send 10 bits for synchronisation at the beginning of every block similar to the experiments in Section 5.2.
The synchronisation using the preamble was successful in all cases and the data transmission resulted in error rates of 7.6% (± 1.9), 9.5% (± 4.86) and 7.1% (± 2.23) for experiments on cores 0, core 3 and core 7 respectively.Effect of processor frequency on T b .
We repeated our experiments at two lower processor frequencies to understand how it may affect the required T b for reliable communication.
In the T b calibration experiments, the error rates remain low despite the decrease in frequency (Table 3).
In the actual data transmission tests (of 1000 bits in 100 bit blocks) at 2.4 GHz, the source and the sink successfully synchronise in all 10 tests and the error rate is about 6.5% (±3.58).
At 1.9 GHz however, the synchronisation succeeds only 5 out of 10 times and the error rate is 9.5% (±2.55).
This indicates that a higher T b value is required for more reliable communication at this lower processor frequency.Throughput Estimation.
The throughput of the thermal channel in temporally partitioned systems depends on the execution schedule of the applications and the time required to send one bit of information (T b = t s ).
We note that typical Linux systems have a time-slice of about 100 ms which is 10 times bigger than the one we need for implementing thermal covert channels.When T b is 10 ms, we would expect the throughput of the thermal channel would be 50 bps.
However, since the communication is error prone and results in up to 10% error, the encoding scheme would have to incorporate error correction codes.
On analysing the nature of the errors during the transmission of a 1000 bits, we see that with a probability of over 0.9, there is 1 or no errors in every four data bits.
Therefore, we can use a Hamming(7,4) code to overcome these errors and this results in an effective throughput of about 12.5 bps.
This throughput is independent of which particular core the source and sink share (core 0/3/7).
A T b of 10 ms results in low error rates even at a processor frequency of 2.4 GHz and hence, the throughput is roughly 12.5 bps.
We note that this data rate would allow the transmission of sensitive information such as credit-card details (16 digits) in about 5 s.
We have explored how factors like processor frequency and relative locations of the source and sink affect the throughput of the thermal covert channel.
Below we discuss additional parameters that affect the throughput.
An exhaustive evaluation of these factors is beyond the scope of the paper and is intended as part of future work.Noise from Other Workloads.
On a given system, the throughput of a thermal communication channel will depend on the actual workloads running on that platform.
In the case of thermal channels in spatially partitioned systems, the exact effect of a concurrent workload on the throughput will likely depend on the nature of the workload and its relative distance from the sink's core.
On the one hand, a workload that saturates its own core's temperature is only likely to increase the sink's temperature by a constant amount without disturbing the actual communication patterns.
On the other hand, a workload that runs in the opposite schedule as the source (i.e. it is active whenever the source is idle and vice-versa) is likely to result in increased errors at the sink's core.
Analogous discussions hold in the case of temporal channels.
Finally, if the attacker controls more than one core on the platform, then he could potentially generate more heat and build faster channels but this requires further exploration.Other Encoding and Error-Correction Schemes.
In our experiments, we used the On-Off keying technique to transmit data.
Instead, to improve throughput, one could borrow techniques from signal processing and telecommunications such as multi-level encoding.
One could alternatively use bi-phase encoding schemes such as Manchester-coding that would lower the data rate (e.g. by half) but also result in fewer errors.
Furthermore, in order to detect and correct more than singlebit errors, one could implement alternative error correction schemes such as Reed-Solomon [62] or BCH [18].
For example, a Reed-Solomon RS (32,28) code encodes a 28-word data into a 32-word codeword and is capable of correcting errors up to 2-words in length.We note that our experiments were performed in conditions that minimise any noise that may arise from other concurrent workloads such as the OS.
Given this and the low resolution of the thermal sensors (±1 • C), we believe that an order of magnitude improvement in the throughput is unlikely.
In this section, we present a preliminary study of how thermal side channels enable unauthorised thermal profiling of processes even in systems that implement strong isolation mechanisms like spatial resource partitioning.
In contrast to thermal covert channels in which the source and the sink collude to exchange data, thermal side channels allow an attacker to exfiltrate information from a victim without requiring any cooperation from the victim.
The heat generated from an application (which we refer to as the victim) can be observed from its neighbours.
This may leak information regarding the nature of its computation to processes at other cores.
More specifically, if the attacker has reference thermal traces for victim applications, he can recognise if and when such an application executes on a neighbouring partition.
For example, identifying that a sensitive or potentially vulnerable application is running on a neighbouring core may aid an attacker in preparing or launching an attack.
Application identification based on temperature traces has not been addressed previously in literature.Below we present a first study that tries to understand its effectiveness as an attack vector.Goal and Intuition of the Attack.
We assume that an attacker has access to a reference thermal trace of the victim application (say RSA decryption).
Such a trace can be obtained by the attacker if he has access to a similar platform as the one he is attacking.
The attacker's goal is to verify if the temperature trace of his core is a result of the victim application's execution on a neighbouring core.
Note that the attacker does not have access to the temperature trace of its neighbouring core(s) but only to that of his own core.
For simplicity, we assume that only the attacker and the victim are active during the attack and that they are collocated on adjacent cores.
The attacker continuously monitors his own core's temperature and then, correlates it with a reference trace of the victim application.
A strong correlation indicates that the attacker's temperature trace was a result of the execution of the victim application with high probability.Experiments and Analysis.
We chose a set of five CPUintensive applications including RSA decryption and four applications from a benchmark suite, MiBench [32] (ADPCM, Quick Sort, BitCount, BasicMath) and use them as the universal set of applications that a victim core (core 3) executes.
We intentionally chose similar applications all of which stress the ALU and register file region of the core.
This choice makes our task harder than distinguishing between applications with very distinct thermal behaviour, for example, an idle application vs. a thermal benchmark.
A deeper exploration of the thermal behaviour of different classes of applications (memory intensive, I/O intensive, etc.) and their distinguishability is out of the scope of this work.To understand the feasibility of identifying these applications, we ran each of them for 200 s on core 3 of our setup (Section 5.1) and collected the temperature traces [32].
We ran each application for 200 s separately and recorded the resulting temperature traces on a neighbouring core.of a neighbouring core (core 2).
We repeated this five times for each of the applications and Figure 9 shows one such trace for each of them.
We observe that the saturation temperature for the RSA decryption application is higher than the rest.We use simple correlation as a metric to measure similarity/differences between pairs of applications.
We first correlated the traces from the RSA application.
Since there are 5 runs, we have 10 pairs to correlate.
We observe that the correlation is higher than 85% in seven out of ten occasions.
Using this same correlation threshold of 85% also results in 28% false positives when the RSA application is correlated with the others from the benchmark suite.
In general, traces belonging to the same application have high correlation values (≥ 80%).
However, traces belonging to different applications also show high correlation because they are all CPU intensive and stress similar parts of the CPU (≥ 75%).
Therefore, we conclude that using a simple correlation metric would only allow distinguishing applications that behave very differently.
More sensitive metrics (such as thermal models [60] or machine-learning based classifiers) are required for better accuracy in other cases.Finally, more fine-grained data exfiltration such as deducing AES or RSA keys on commodity x86-systems using the thermal side channel is an open, unexplored problem.
A key challenge is the limited resolution of the temperature sensors which is ±1 • C and the rate at which the sensors are refreshed (currently, once every 2 ms).
In this section, we present possible countermeasures against thermal channels and discuss their limitations.
We also discuss a potential security application for thermal channels.Countermeasures.
Since we leveraged the temperature information exposed to software to construct thermal channels, a natural solution to this problem would be to restrict access to temperature sensors on the system.
However, such information cannot always remain hidden.
For example, centralised control and monitoring of thermal states does not scale well with the advent of many-core processors [41].
Such processors contain hundreds of cores and host a large number of autonomous processes on separate cores.
In fact, research prototypes like Intel's SCC platform [41] already allow subsets of cores to administer their frequency and voltage independently for power-efficiency; temperature information is a vital input to this decision process.
The software at each core should track thermal information to schedule intelligently and to detect if any of its threads are misbehaving.
Therefore, there is a tension between securing platforms and improving their energy-efficiency by exposing thermal data to software applications.Even if one restricts access to the temperature sensors, related parameters may still leak information about the system's thermal state.
Examples of such parameters are clock skew, fan speed and even processor frequency in systems that allow dynamic frequency scaling.
Since all these parameters are usually common across cores or subsets of cores within a processor chip, they can still provide a signalling mechanism.
Finally, while it may be possible to separate processes temporally and spatially to limit the effectiveness of thermal channels, such resource allocation strategies are wasteful and result in low resource utilisation.Thermal Fingerprinting For Security.
So far we discussed only how thermal behaviour of systems can be exploited by attackers.
The same properties could be used for achieving better security.
Since temperature changes resulting from computations are difficult to avoid, we hypothesise that thermal profiling techniques can also be used to detect any anomalous behaviour in the execution of an application.
More specifically, it is highly likely that run-time compromise of an application results in a temperature trace that does not match its original thermal fingerprint.
It has been shown to be possible to extract thermal models by monitoring the application under controlled conditions [60,61].
By comparing the actual execution trace to the expected trace, it may be possible to detect run-time compromise of software applications.More generally, understanding the capacity of thermal channels using information theory will help assess the throughput of covert communication.
Similarly, a theoretical estimation of the entropy of such channels will help bound fingerprint accuracy and hence, side channel leakage.
A more detailed study along these lines is an interesting direction for future work.
We review previous work on covert and side channels on x86 systems and on thermal channels in general.
We also provide examples of existing literature on optimising computing systems for thermal efficiency because it highlights the advantages of exposing thermal data as opposed to the other work that misuses this data to undermine security.Thermal Channels and Attacks.
There is no previous work that demonstrates the feasibility of thermal covert and side channels on commodity multi-core systems as we do in this paper.
Previously, two works discussed and one implemented thermal covert channels on FPGA boards [19,38,51].
There have also been attempts to transmit data between two processes by changing fanspeed [20].
The ability to remotely monitor a system's clock-skew (influenced by the changes in the system temperature) has also been exploited in the past for exposing anonymous servers [56,75] and covert communication with a remote entity [74].
We note that although some of these works [20,74] use the term thermal channel, none of them use the thermal information available on modern systems to covertly communicate between processes on the same host as we do in this paper.More recently, it has been shown that it is possible to use temperature variations to induce processor faults [59] which can in turn be also be used to extract sensitive information like RSA keys [37].
Thermal information can also be used for coarse-grained data-exfiltration.
For example, since temperature directly reflects the intensity of computation, it can be used to estimate the load or resource utilisation of a machine.
This was illustrated by Liu et al. who computed the resource utilisation of servers in Amazon's EC2 using the temperature data that is exposed to virtual machines [49].
Previous research has identified other security risks that arise from hardware and software thermal management techniques on modern systems.
For example, malicious processes may cause a denial-of-service by slowing down the processor [33] or permanently damaging hardware by causing thermal hotspots [27].
Such processes could exploit the fact that certain architecture components (e.g. instruction cache) are ignored by thermal optimisation approaches on processors [45].
Covert and Side Channels on x86-Systems.
Originally defined by Lampson as part of the confinement problem [46], today, several covert channels have been identified and explored in the context of x86 systems.
Covert channels can be classified either as timing or storage channels.
Timing covert channels transmit information in terms of the timing of certain events.
Examples of timing covert channels include cache-based and memory bus-based channels both of which were first demonstrated by Hu [34,35].
Wang et al. identify more timing channels that arise out of processor extensions such as multi-threading and speculative execution [68].
Wu et al. achieve improved data rates on bus-based channels [71].
Covert timing channels that use other types of shared resources like virtual memory deduplication [72] and input devices such as keyboards [64] have also been studied.In contrast to timing channels, storage channels rely on the source writing the data (indirectly) into a shared resource which the sink reads at a later point in time.
Lampson's file system based covert channel [46] and covert channels that exploit CPU registers (e.g. FPU registers that signal exceptions) [65] are examples of such channels.
Interestingly, certain types of covert channels such as those based on the hard-disk [70] and processor cache [22,35] can be used to realise timing and storage channels.
We could classify the thermal covert channels as storage channels because they use the CPU registers to (indirectly) exchange information.While covert channels rely on two colluding entities for data exfiltration, side channels can be used to extract information from a unsuspecting victim without any co-operation from it.
Side channels can be classified as access-driven channels, trace-driven channels and timing-driven channels.
Access-driven side channels rely on a victim's modifications to a shared resource (e.g. cache) to extract sensitive information (e.g. AES keys [76]).
Trace-driven channels require measuring a certain aspect of the system such as power (e.g. [43]) or electromagnetic emanations (e.g. [29]) continuously as the victim executes.
Finally, timing-based side channels measure the time consumed by sensitive operations (e.g. cryptographic functions) to extract information (e.g. such as AES keys [17]).
In general, side channels are used for cryptanalysis.
Example attacks include extraction of AES keys [11,17,42,76], DES keys [58] and RSA keys [22,43,44].
They can also be used to extract more coarse-grained information such as coresidency [63], existence of files [67], etc.
The thermal side channel can be viewed as a trace-driven side channel that continuously tracks temperature to identify the computation at a neighbouring core.One way to mitigate timing channels (both covert and side channels) in general is to expose less accurate timing information [34].
This technique is unlikely to be effective against thermal channels because they do not exploit timing information.
Another general approach against side and covert channels is to partition system resources.
This is for example used to mitigate cache-based channels [68] and bus-based channels [31].
However, such partitioning techniques will not eliminate temperature-based channels completely as demonstrated in this paper.Thermal Monitoring of Processors.
Temperature management of computing systems has gained importance over the last few years due to the increasing on-chip temperatures of modern processors.
This has resulted in efforts to design and implement better thermal management techniques for processors.
Examples include optimisation of sensor placement (e.g. [53,55]), improving algorithms for dynamic temperature management (e.g. [73]) and cooling techniques [25].
There are also ongoing efforts to develop frameworks to thermally profile applications [61], build temperature-aware schedulers [24,26] and micro-architectures [48,66].
Thermal profiling can further be used to detect compromised process in embedded systems [69] and design schedulers such that they do not leak information through thermal fingerprints of applications [16].
In this paper, we demonstrated the feasibility and potential of thermal channels on commodity multi-core systems.
We showed that such channels can be built by exploiting the thermal behaviour of current platforms.
Thermal channels can be used to circumvent strong isolation guarantees provided by temporal and spatial partitioning techniques.
Our experiments indicate that it is possible to use them for covert communication between processes and achieve a throughput of up to 12.5 bps.
We also demonstrated that thermal channels can be exploited to profile applications running on a neighbouring core.
Our work points to a limitation in the isolation guarantees that resource partitioning techniques can provide.Attacks based on thermal channels are further facilitated by the increasing trend towards exposing system temperature information to users.
This would enable users to make thermal management decisions for efficient system operation.
This paper highlights the tension between designing systems to support user-centric thermal management for efficiency and security.
This work was carried out as a part of the SAFURE project, funded by the European Union's Horizon 2020 research and innovation program under grant agreement number 644080.
This work was partially supported by the Zurich Information Security and Privacy Center.
It represents the views of the authors.
