XrML is becoming a popular language in industry for writing software licenses.
The semantics for XrML is implicitly given by an algorithm that determines if a permission follows from a set of licenses.
We focus on a representative fragment of the language and use it to highlight some problematic aspects of the algorithm.
We then correct the problems, introduce formal semantics, and show that our semantics matches the (corrected) algorithm.
Finally , we consider the complexity of determining if a permission is implied by a set of XrML licenses.
We show that the general problem is NP-hard, but it is polynomial-time computable for an expressive fragment of the language.
The eXtensible rights Markup Language (XrML) is becoming an increasingly popular language in which to write software licenses.
When first released in 2000, XrML received the support of many technology providers, content owners, distributors, and retailers, including Adobe Systems, Hewlett-Packard Laboratories, Microsoft, Xerox Corp., Barnesandnoble.com, and Time Warner Trade Publishing.
Companies including Microsoft, OverDrive, and DMDsecure have publicly announced their agreement to build products and/or services that are XrML compliant.
Currently, XrML is being used by international standard committees as the basis for application-specific languages that are designed for use across entire industries.
For example, the Moving Picture Experts Group (MPEG) has selected XrML as the foundation for their MPEG-21 Rights Expression Language (MPEG-21 REL).
(See http://www.xrml.org for more information.)
It is clear that a number of industries are each moving towards a standard language for writing licenses, and that many of these standard languages are likely to be based on XrML.
To understand the new standards, we need to understand XrML.XrML does not have formal semantics.
Instead, the XrML specification [3] presents the semantics in two ways.
First is an English description of the language.
Second is an English description of an algorithm that determines if a permission follows from a set of licenses.
Unfortunately, the two versions of the semantics do not agree.
To make matters worse, the algorithm has unintuitive consequences that do not seem to reflect the language writers' intent.As a first step towards addressing these issues, we provide a formal semantics for XrML.
To the best of our knowledge, we are the first to do this.
We give the language formal semantics by providing a translation from XrML licenses to formulas in modal first-order logic.
We verify the translation by proving that the algorithm included in the XrML document, slightly modified to correct the unintuitive behavior, matches our semantics.
More precisely, the algorithm says that a permission follows from a set of licenses iff the translated permission is a logical consequence of the translated licenses.
We then consider the complexity of determining if a permission is implied by a set of licenses.
We show that the general problem is NP-hard, but, for an expressive fragment of the language, it is polynomial-time computable.The rest of the paper is organized as follows.
In the next section we present a fragment of XrML that suffices to illustrate the key issues.
In Section 3 we review XrML's algorithm for determining what is permitted given a set of licenses.
After considering some examples in which the algorithm's behavior is unintuitive and almost certainly unintended, we propose a revised algorithm that we believe captures the designers' intent.
Formal semantics for XrML are given in Section 4, and the revised algorithm is shown to be sound and complete with respect to the semantics.
In Section 5 we show that the problem of determining if a permission follows from a set of licenses is NP-hard.
We also discuss a fragment of the language that is both tractable and relatively expressive.
In Section 6 we outline how our results can be modified to apply to the entire language, including extensions that are within the XrML framework.
We conclude in Section 7.
Proofs for all of the theorems can be found at www.cs.cornell.edu/home/halpern/papers/xrml.pdf.
Before we can begin our analysis of XrML, we need to choose a version of the language.
ContentGuard froze the language in November 2001 [1] with the intention that standard committees would extend the language to suit the needs of their particular constituents.
However, the standard committees are currently modifying the language, as opposed to simply extending it.
In particular, the MPEG committee published their version of the language [4] a few weeks before the final submission of this paper.
Although we have not studied that release carefully, we have examined their March 2003 Specification [3], which is the version before the current one.
In this paper we discuss the March 2003 Specification; in the full paper we discuss the current version.In this section we present a syntax for a representative fragment of XrML.
(The rest of the language is discussed in Section 6.)
Although XrML is an XML-based language, our syntax does not follow the XML conventions.
Instead, we have chosen a syntax that we believe is more intuitive.
There are other differences between the two approaches; these are discussed at the end of the section.At the heart of XrML is the notion of a license.
A license is a (grant; principal) pair, where the license (g, p) means p issues (i.e., says) g. For example, the license (Bob is smart, Alice) means "Alice says 'Bob is smart' ".
A grant has the form '∀x 1 , . . . , ∀x n (condition → conclusion)', which intuitively means that the condition implies the conclusion under all appropriate substitutions.
Conditions and conclusions are defined as follows.
• A condition has the form Said(p 1 , e 1 ) ∧ . . . ∧ Said(p n , e n ), where p i is a principal and e i is a conclusion.
We represent the empty conjunction (when n = 0) by true.
Roughly speaking, Said(p i , e i ) holds if the grants issued by the principal p i , along with the set of licenses, imply e i .
• A conclusion has either the form Perm(p, r, s) or the form Pr (p) where Pr is a property, p is a principal, r is a right (i.e., an action), and s is a resource.
The conclusion Perm(p, r, s) means p may exercise r over s.For example, Perm(Bob, edit , budget report ) means Bob may edit the budget report.
The conclusion Pr (p) means p has the property Pr .
For example, the conclusion Attractive(Bob) means Bob is attractive.We abbreviate the grant ∀x 1 , . . . , ∀x n (true → e) as ∀x 1 , . . . , ∀x n e. Also, we try to consistently use d, possibly subscripted, to denote generic conditions and e, possibly subscripted, to denote generic conclusions.
Consider the following example.
Suppose that Alice issues the grant 'Bob is smart' and Amy issues the grant 'if Alice says that Bob is smart, then he is attractive'.
We can write the first license in our syntax as (g 1 , Alice), where g 1 = Smart(Bob) (recall that this is an abbreviation for true → Smart(Bob)), and we can write the second as (g 2 , Amy), where g 2 = Said(Alice, Smart(Bob)) → Attractive(Bob).
Because (g 1 , Alice) means 'Alice says Bob is smart' and g 2 means 'if Alice says Bob is smart, then he is attractive', the licenses together with the grants issued by Amy imply that Bob is attractive.
Thus, the condition Said(Amy, Attractive(Bob)) holds.The sets of principals, properties, rights, and resources depend on the particular application.
For example, a multimedia application might have a principal for each employee and each customer; properties such as 'hearing impaired' and 'manager'; rights such as 'edit' and 'download'; and a resource for each object such as a movie.
We assume the application gives us a finite set primitivePrin of principals and a finite set primitiveProp of properties.
We then define the components in our language as follows.
• The set of principals is the result of closing primitivePrin under union.
(Here and elsewhere we identify a principal p ∈ primitivePrin with the singleton {p}.)
Thus, every principal has the form {p 1 , . . . , p n }, where each p i is a primitive principal.
The interpretation of a principal {p 1 , . . . , p n } depends on context (i.e., depends on whether the principal appears as the first argument in a Said condition, as the first argument in a conclusion, or as the second argument in a license).
We discuss this later in the paper (primarily in Section 5).
• The only properties considered by XrML are those in primitiveProp.
Following XrML, we consider only properties that take a single principal as an argument.
For example, primitiveProp can include the property Employee, where Employee(x) means principal x is an employee, but it cannot include the property MotherOf, where MotherOf (x, y) means x is the mother of y, nor can it include the property Vehicle, where Vehicle(x) means resource x is a vehicle (e.g., a motorcycle, car, or truck).
All of the results of this paper would continue to hold if we extend the fragment to include properties that take multiple arguments of various sorts (i.e., principals, rights, and resources).
We remark that in XrML the set of properties is not closed under conjunction or negation.
It is easy to show that closing the set under conjunction adds no expressive power to the language.
Closing under negation does add expressive power; we return to this issue in Section 7.
• The only right is issue and the only resources are grants.
Intuitively, if a principal p has the right to issue a grant g, and p does issue g, then g is a true statement.We remark that, although the grants ∀xPr (x) and ∀yPr (y) have the same semantic interpretation (all principles have property Pr ), XrML treats them as distinct grants syntactically.
For example, according to the XrML algorithm, if Alice is permitted to issue the grant ∀xPr (x), then she is not necessarily permitted to issue ∀yPr (y).
We formally define the language's syntax according to the following grammar.
where Pr is a generic element of primitiveProp, p is a generic element of primitivePrin, and prinVar and rsrcVar are variables ranging over primitive principles and resources, respectively.
For the remainder of this paper we assume that the second argument in a license is a singleton.
Because the XrML document treats the license (g, {p 1 , . . . , p n }) as an abbreviation for the set of licenses {(g, p) | p ∈ {p 1 , . . . , p n }}, it is easy to modify our discussion to support all of the licenses included in the grammar.
We further restrict the language so that all grants are closed, that is, for each grant∀x 1 . . . ∀x n (d → e), the set of free variables in d → e is contained in {x 1 , . . . , x n }.
We discuss some of the consequences of this restriction in Section 4, and remove it in the full paper.
As mentioned at the beginning of this section, the grammar presented here is not identical to that described in the XrML document.
The differences are listed below.
• Instead of assuming that the application provides a set of primitive principals, XrML assumes that the application provides a set K of cryptographic keys; the set of primitive principals is {KeyHolder(k) | k ∈ K}.
We could take primitivePrin to be this set; however, our more general approach leads to a simpler discussion.
Moreover, our results do not change if we restrict primitive principals to those of the form KeyHolder(k).
• XrML does not have conditions of the form Said(p, e).
To capture Said conditions, XrML uses PrerequisiteRight conditions of the form (G, e), where G is a set of grants and e is a conclusion.
A condition Said({p 1 , . . . , p n }, e) in our syntax (where each p i is a primitive principal or a variable of sort Principal ) corresponds to the PrerequisiteRight condition ({g 1 , . . . , g n }, e) in XrML, where each g i is ∀xPerm(p i , issue, x) and x is a variable of sort Resource.
• XrML does not have conclusions of the form Pr (p).
To capture properties, XrML uses a right called PossessProperty, and considers the properties given by the application to be resources.
The conclusion Pr (p) in our grammar corresponds to the conclusion Perm(p, PossessProperty, Pr ) in XrML.We have two types of conclusions because we believe the grammar should help distinguish the conceptually different notions of permissions and properties, rather than confounding them.
• Instead of writing allConds(c 1 , . . . , c n ), allConds(), and AllPrincipals(p 1 , . . . , p n ), we use the more standard notations c 1 ∧ . . . ∧ c n , true, and p 1 ∪ . . . ∪ p n , respectively.
• XrML abbreviates a set of licenses {(g i , p j ) | i ≤ n, j ≤ m} as the single license ({g 1 , . . . , g n }, {p 1 , . . . , p m }).
For ease of exposition, we do not do this.
Our discussion can be easily extended to take the abbreviation into account.
The XrML document includes a procedure that we call Query to determine if a conclusion follows from a set of licenses (and some additional input that is discussed below).
In this section we present and analyze the parts of the algorithm that pertain to our fragment.Before describing the algorithm, we note that some aspects of Query are inefficient.
This is acknowledged in the XrML document, which explains that Query was designed with clarity as the primary goal; it is the responsibility of the language implementors to create efficient algorithms with the same input/output behavior as Query.
(In Section 5, we show that it is highly unlikely that such an efficient algorithm exists.)
The input to Query is a closed conclusion e (i.e., a conclusion with no free variables), a set L of licenses (g, p) such that p is variable-free, and a set R of grants; Query returns true if e is implied by L and R. To explain the intuition behind L and R, we first note that the procedure treats a predefined set of principals as trusted.
If the grant g is issued by a trusted principal, then g is in R and it is assumed to be true.
If the license (g, p) is in L, then g is issued by p (i.e., p says g) and p is not an implicitly trusted principal.
To clarify the inferences that are drawn from R and L, suppose that the grant g is QueenOfSiam(Alice), which means Alice is Queen of Siam, and the grant g is Perm(Alice, issue, g), which means Alice may issue g.
If g ∈ R, then we assume that Alice really is queen.
If (g, Alice) is in L, then Alice says that she is the queen, but we cannot conclude that she is royalty from this statement alone.
If (g, Alice) is in L and g is in R, then we assume that Alice has the authority to declare herself queen, because g ∈ R; we assume that she exercises that authority, because (g, Alice) ∈ L; and we conclude that Alice is queen, because this follows from the two assumptions.Query begins by calling the Auth algorithm.
Auth takes e, L, and R as input; it returns a set D of closed conditions (i.e., conditions with no free variables).
Roughly speaking, a closed condition d is in D if d, L, and R together imply e. To determine if a condition in D holds, Query relies on the Holds algorithm.
The input to Holds is a closed condition d and a set L of licenses; Holds(d, L) returns true only if the licenses in L imply d. (Notice that Holds does not take R as input.
We examine the consequences of this omission in Section 3.2.)
If Holds(d, L) returns true for some d in D, then Query returns true, indicating that L and R imply e. Query is summarized in Figure 1.
let D = Auth(e, L, R) for each d ∈ D if Holds(d, L) returns true then Return true Return false We now discuss Auth and Holds in some detail.
To define Auth, we first consider the case where L = ∅ and every grant in R has the form d g → e g .
In this case Auth(e, ∅, R) returns the set D of closed conditions such that each condition, together with R, implies e.
More precisely, a con-dition d is in D if there is a grant g = d → e g in R such that e g implies e.In determining whether or not the implication holds, Auth makes the subset assumption.
The subset assumption says that any property or permission attributed to a principal p is attributed to every principal that includes p.
In other words, if p ⊆ p , then Pr (p) implies Pr (p ) and Perm(p, r, s) implies Perm(p , r, s).
Thus,Auth(Pr (p), ∅, R) returns {d | d → Pr (p g ) ∈ R and p g ⊆ p}and Auth(Perm(p, r, s), ∅, R) returns{d | d → Perm(p g , r, s) ∈ R and p g ⊆ p}.
Suppose that there is at least one grant∀x 1 . . . ∀x n (d g → e g ) in R such that d g → e g is open (i.e., has free variables).
Then we reduce this case to the previous one by considering all the substitution instances of grants in R. Define a closed substitution to be a mapping from variables to closed expressions of the appropriate type.
Given a closed substitution σ and an expression t, let tσ be the expression that arises after all free variables x in t are replaced by σ(x).
Let R Σ = {d g σ → e g σ | ∀x 1 . . . ∀x n (d g → e g ) ∈ R, σ is a closed substitution}.
We then define Query(e, ∅, R) to be Query(e, ∅, R Σ ).
As we show in Section 3.2, R Σ may be infinite, in which case Query is not well-defined.
For ease of exposition, we assume that R Σ is finite for the rest of this section.
In Section 3.3 we propose a restriction on the language that guarantees that R Σ is finite.Finally, suppose that L is not necessarily ∅.
Then we reduce this case to the previous one by taking Auth(e, L, R) = Auth(e, ∅, R ), whereR = R ∪ R R = {g | for some principal p and condition d, (g, p) ∈ L, d ∈ Auth(Perm(p, issue, g), L − {(g, p)}, R),and Holds(d, L) returns true}.
R consists of the grants in R and the grants that are issued by someone who has the authority to do so.
Intuitively, R is the set of grants that hold, since the grants in R implicitly hold and, as discussed in Section 2, a grant g holds if it is issued by a principal p and p is permitted (i.e., has authority) to issue g. To determine if a principal p is permitted to issue a grant g we should be able to call Query(Perm(p, issue, g), L, R), which returns true if Holds(d, L) returns true for some d in the set returned by Auth(Perm(p, issue, g), L, R).
This is indeed how we determine if g ∈ R , with one minor change: the second argument to Auth is L − {(g, p)} rather than L.
We discuss the consequences of this choice in Section 3.2.
(As an aside, we suspect that the design decision was made because it is easy to see that the algorithm will not terminate if we replace L − {(g, p)} by L.) Pseudocode for Auth is given in Figure 2.
Auth(e, L, R):let D = ∅ if L = ∅ then % Find D, the conditions under which R implies e for each grant ∀x 1 . . . ∀x n (d g → e g ) ∈ Rand each closed substitution σ if e = Pr (p) and e g σ = Pr (p g ) or e = Perm(p, r, s) and e g σ = Perm(p g , r, s),and p g ⊆ p then let D = D ∪ {d g σ} else % Find R let R = R for each (g, p) ∈ L let L = L − {(g, p)} let D = Auth(Perm(p, issue, g), L , R) for each d ∈ D if Holds(d, L) returns true then let R = R ∪ {g} % Find D, the conditions under which R implies e let D = Auth(e, ∅, R ) Return D We define Holds(d, L) by induction on the structure of d.If d is true, then Holds(d, L) returns true.
If d = d 1 ∧ d 2 , then Holds(d, L) returns true iff both Holds(d 1 , L) and Holds(d 2 , L) return true.
If d = Said(p, e), then Holds sets R p to the grants issued by a principal who has the authority to do so, under the assumption that p may issue any grant.
That is,R p = {g | for some license (g, p ) ∈ L and condition d ∈ Auth(Perm(p , issue, g), L − (g, p ), R p ) such that Holds(d, L) returns true}, where R p = {∀xPerm(p , issue, x) | p ∈ p}.
Holds(Said(p, e), L) returns true if there is a grant g in R p and a condition d such that g and d together imply e (without making use of the subset assumption).
Pseudocode for Holds is given in Figure 3.
Example 3.1: In Section 2, we argued informally that Amy says Bob is attractive, if the set of licenses is L = {(g 1 , Alice), (g 2 , Amy)}, where g 1 = Smart(Bob) andg 2 = Said(Alice, Smart(Bob)) → Attractive(Bob).
The formal algorithm confirms this conclusion, since Holds(Said(Amy, Attractive(Bob)), L)Holds(d, L): if d = true then Return true if d = d 1 ∧ d 2 then Return Holds(d 1 , L) ∧ Holds(d 2 , L) if d = Said(p, e) then % Find R p let R p = ∅ let R p = {∀xPerm(p , issue, x) | p ∈ p} for each (g, p ) ∈ L let L = L − {(g, p )} let D = Auth(Perm(p , issue, g), L , R p ) for each d ∈ D if Holds(d , L) returns true then let R p = R p ∪ {g} % Return true if R p implies e for each grant ∀x 1 . . . ∀x n (d g → e g ) ∈ R p and closed substitution σ such that e g σ = e if Holds(d g σ, L) returns trueReturn true Return false first determines R Amy , which is {g 2 }.
Intuitively, this indicates that g 2 holds, if we assume that the grants issued by Amy hold.
The algorithm then calls Holds(Said(Alice, Smart(Bob)), L) to determine if the condition Said(Alice; Smart(Bob)) holds.
Intuitively, this is done because g 2 and Said(Alice, Smart(Bob)) together imply Said(Amy, Attractive(Bob)).
Holds(Said(Alice, Smart(Bob)), L) first calculates R Alice to be {g 1 } and then calls Holds(true, L), because g 1 holds if we assume that the grants issued by Alice hold and that g 1 and true together imply Smart(Bob).
Holds(true, L) returns true, so Holds(Said(Alice, Smart(Bob)), L) returns true, and then Holds(Said(Amy, Attractive(Bob)), L) does as well.Suppose that a trusted principal says that Amy has the authority to issue g 2 (i.e., if Amy says g 2 , then g 2 holds).
Then we can conclude that Bob really is attractive, because Query(Attractive(Bob), L, R) returns true, where R = {Perm(Amy, issue, g 2 )}.
Specifically, Query begins by calling Auth(Attractive(Bob), L, R).
Auth(Attractive(Bob), L, R), in turn, callsAuth(Attractive(Bob), ∅, R ), where R = {g 2 , Perm(Amy, issue, g 2 )}.
returns {Said(Alice; Smart(Bob))}.
So, Bob is attractive if the condition Said(Alice; Smart(Bob)) holds.
To determine if the condition holds, Query calls Holds(Said(Alice; Smart(Bob)), L).
As observed above, Holds(Said(Alice; Smart(Bob)), L) returns true, so Query(Attractive(Bob), L, R) does as well.
In this section we present seven examples in which Query gives unexpected results.
Example 3.2 reveals a mismatch between Query and the informal language description; the discrepancy exists because Auth makes the subset assumption and the informal language description does not.
Examples 3.3 and 3.4 illustrate the consequences of not including assumptions in the input to Holds; in Example 3.3 the grants issued by implicitly trusted principals (i.e., those in R) are disregarded, and in Example 3.4 the assumption that p may issue any grant is disregarded when evaluating Said(p, e).
Examples 3.5 and 3.6 show that Query does not terminate on all inputs, for two quite different reasons: Example 3.5 shows that on certain input Auth returns an infinite set, and Example 3.6 shows that on certain input Holds makes infinitely many recursive calls.
Example 3.7 demonstrates that a license (g, p) should not be removed from the set of licenses when determining if p is permitted to issue g. Finally, Example 3.8 uncovers a minor discrepancy between the description of R and its use in Query.
Suppose that Alice is quietly walking beside her two giggling daughters, Betty and Bonnie.
Are the three of them a quiet group?
Intuitively, the answer is no, since Betty and Bonnie are giggling.
According to Query, however, the answer is yes.
Because Alice is quiet and Auth makes the subset assumption, Query concludes that the principal {Alice, Betty, Bonnie} is quiet.
That is, Query(Quiet({Alice, Betty, Bonnie}), ∅, {Quiet(Alice)}) returns true, indicating that the group is quiet.
Suppose that Alice may issue a grant g and, if it follows from Bob's statements that Alice may issue g, then Charlie may issue g. May Charlie issue g?
The answer should be yes.
If Alice may issue g, then this right follows from any statement (or no statement at all).
However, according to the XrML algorithm, Charlie may not issue g. To see why, let g 1 = Perm(Alice, issue, g), g 2 = d → Perm(Charlie, issue, g), and d = Said(Bob, Perm(Alice, issue, g)).
We are interested in Query(Perm(Charlie , issue, g), ∅, {g 1 , g 2 }).
Auth(Perm(Charlie , issue, g), ∅, {g 1 , g 2 }), which returns {d}.
Intuitively, Charlie may issue g if the condition d holds.
The algorithm then executes Holds(d,∅) (since the set of licenses is ∅), and this call returns false.
Roughly speaking, Holds(d, ∅) returns false because d does not follow from the (empty) set of licenses.
To get the intuitively correct answer that d holds, Holds would need to take R into account.
But it cannot possibly do this, since R is not part of Holds's input.
Because none of the conditions returned by Auth are met according to Holds, Query returns false and we (wrongly) conclude that Charlie does not have permission to issue g. Said({Alice, Amy}, Perm(Alice, issue, Smart(Alice))).
Intuitively, d holds, because Alice is permitted to issue the grant Smart(Alice), given that Amy and Alice are permitted to issue every grant.
However, Holds(d, ∅) returns false, because R p includes only grants that are mentioned in L, which is ∅ in this case.Suppose that instead of being ∅, L = {(g 1 , Alice), (g 2 , Amy)}, where g 1 = Smart(Alice) and g 2 = Said(Bob, Smart(Alice)) → Perm(Alice, issue, Smart(Alice)).
Now, Holds(d, L) should return true for a reason quite different from that above.
To see this, notice that if Alice and Amy may issue any grant, then g 1 and g 2 hold.
Therefore, Alice is smart and, as in Example 3.3, it follows that Said(Bob, Smart(Alice)) holds (since Alice is smart, this fact follows from Bob's statements).
Because the condition in g 2 holds and g 2 holds, the conclusion of g 2 holds and, thus, Alice may issue the grant Smart(Alice).
Unfortunately, Holds(d, L) still returns false.
Specifically, Holds(d, L) sets R p = {g 1 , g 2 }.
It then calls Holds(Said(Bob, Smart(Alice)), L).
This call returns false, because it is not passed the assumption that Alice's statement holds.
which returns D = {Said(Amy, Perm(Alice, issue, g)) | g is a grant}.
Query then calls Holds(d , L) for each d ∈ D. However, the language includes infinitely-many grants, even if there is only one property Pr and one principal p in the language.
To see this, define grants g n , n ≥ 1, inductively by taking g 1 = true → Pr (p) and g n+1 = Said(p, Perm(p, issue, g n )) → Pr (p) for all n > 0.
Clearly each of these grants is distinct.
Since D is an infinite set, Query does not terminate.
Example 3.6: Suppose that Alice and Amy may issue any grant, Alice says that Bob is trustworthy if Amy says that he is, and Amy says that Bob is trustworthy if Alice says that he is.
Should we conclude that Bob is trustworthy?
The intuitive answer is no, since neither Alice nor Amy says that he is.To answer this query using Query, let e = Trustworthy(Bob), L = {(g 1 , Alice), (g 2 , Amy)}, g 1 = Said(Amy, e) → e, g 2 = Said(Alice, e) → e, and R = {∀xPerm(Alice, issue, x), ∀xPerm(Amy, issue, x)}, where x is a variable of sort Resource.
We are interested in Query(e, L, R).
Query(e, L, R) begins by calling Auth(e, L, R), which returns the set D = {Said(Amy, e), Said(Alice, e)}.
Query then calls Holds on each of the conditions in D.
During the execution of Holds(Said(Amy, e), L), Holds sets R Amy = {g 2 }, and then calls Holds(Said(Alice, e), L).
Holds(Said(Alice, e), L) sets R Alice = {g 1 }, and then calls Holds(Said(Amy, e), L).
Notice that this is just the original call.
It is not hard to see that an infinite number of calls to Holds(Said(Amy, e), L) will be made during the execution of Holds(Said(Amy, e), L) and, thus, the algorithm does not terminate.It is tempting to conclude that a conclusion e follows from a set L of licenses and a set R of grants only if Query(e, L, R) terminates and returns true.
Unfortunately, this might not lead to the intuitively correct answer.
To see why, consider a slight modification of our previous example where we add {Trustworthy(Bob)} to the grant set R. Intuitively, this means that an implicitly trusted principal says that Bob is trustworthy.
It now seems reasonable to expect Query(e, L, R ) to return true, where R = R ∪ {e}, and e, L, and R are as defined in the original example.
Surely the issued grants imply that Bob is trustworthy, since a grant issued by a trusted principal says just that!
However, the execution of Query(e, L, R ) does not terminate for the same reason that Query(e, L, R) does not terminate.
Example 3.7: Suppose that Alice says that she is smart, and if Alice says that she is smart, then she is permitted to say that she is smart.
Is Alice smart?
Intuitively, the answer is yes, because Alice is permitted to say that she is smart and she does so.
But consider Query(Smart(Alice), L, R), where L = {(g, Alice)}, R = {Said(Alice, Smart(Alice)) → Perm(Alice, issue, g)}, and g = Smart(Alice).
begins by calling Auth(Smart(Alice), L, R).
This algorithm checks whether or not Alice is permitted to issue g.
It determines that Alice may not issue g, because the permission does not follow from R and L − {(g, Alice)}.
Since Alice is not permitted to issue g, Auth sets R = R and returns ∅.
Because Auth returns ∅, Query returns false.
Example 3.8: Suppose that a trusted principal issues the grant g 1 , where g 1 says 'if Amy says that some principal may issue g 2 , then Alice may issue it'.
May Alice issue g 2 ?
At first glance, the answer should be no.
Alice may issue g 2 only if Amy says that some principal may issue g 2 ; we cannot conclude this from g 1 alone.
However, g 1 was issued by a trusted principal, who we will call p t , p t may issue any grant, and, thus, p t 's right to issue g 2 follows from Amy's statements, because it is true.
So, the condition in g 1 is met and Alice may issue g 2 .
Unfortunately, Query(Perm(Alice, issue, g 2 ), ∅, R) returns false, where R = {∀x(Said(Amy, Perm(x, issue, g 2 )) → Perm(Alice, issue, g 2 ))}.
Thus, Query does not always treat the grants in R as having been issued by a trusted principal (who may issue every grant).
Perhaps a better interpretation is that Query treats the grants in R as being those that are accepted, without assuming that they have been issued by some trusted principal.
While this is a perfectly reasonable interpretation, it is not consistent with the discussion in the XrML document.
In this section we revise Query and the informal language description to avoid the problems observed in Section 3.2.
Three of the corrections are fairly straightforward.
• We resolve the mismatch illustrated in Example 3.2 by removing the subset assumption from Auth.
We note that the language is sufficiently expressive to force the subset assumption, if desired, by including the following grants in R:g = ∀x 1 . . . ∀x 3 (Perm(x 1 , issue, x 2 ) → Perm(x 1 ∪ x 3 , issue, x 2 )) g i = ∀x 1 ∀x 2 (Pr i (x 1 ) → Pr 1 (x 1 ∪ x 2 )), for i = 1, . . . , n,where x 1 , . . . , x 3 are variables of the appropriate sorts and Pr 1 , . . . , Pr n are the properties in the language.
• We address the problem exhibited in Example 3.3 by modifying Query so that R (the set of grants issued by a trusted principal) is passed to and used appropriately by Holds.
In addition, we add R p to R during the evaluation of Said(p, e).
This solves the problems highlighted in Example 3.4.
• We do not revise Query in any way to respond to the discussion in Example 3.8.
Instead, we change the intuitive meaning of R; we assume R is the set of grants that implicitly hold, although they are not necessarily issued by a principal (trusted or otherwise).
We remark that we could force the algorithm to treat a principal p as trusted by including the grant ∀xPerm(p, issue, x) in R, where x is a variable of the sort Resource.There are three remaining issues, corresponding to Examples 3.5, 3.6, and 3.7.
We consider each of these in turn.We restrict the language to avoid the type of nontermination that occurs in Example 3.5.
There are various restrictions that could accomplish this.
To understand ours, recall that Auth(e, L, R) first extends R to R by adding all the grants that are issued by someone who has the authority to do so.
Since all the grants in R − R are in L, the set R must be finite.
Then, Auth creates the possibly-infinite set R Σ consisting of all substitution instances of grants in R , and returns {d | d → e ∈ R Σ }.
(For simplicity here, we are assuming that Auth does not use the subset assumption; this assumption does not affect our discussion.)
Since Auth considers only the grants in R Σ whose conclusion matches the first input to Auth, we could certainly replace R Σ by R Σ , whereR Σ = {d g σ → e | ∀x 1 . . . ∀x n (d g → e g ) ∈ R ,σ is a closed substitution, and e g σ = e}.
Because e is closed, R Σ is finite if for every grant g in R , if g's condition mentions a free variable x, then either x ranges over a finite set or x appears in g's conclusion.
Our solution is simply to restrict the language so that every grant has this property.
Since, in our fragment, there are infinitely-many resources (grants), and only finitely many principles, this amounts to restricting the language so that if ∀x 1 . . . ∀x n (d g → e g ) is a grant, then every free variable of sort Resource that appears in d g also appears in e g .
We call a grant acceptable if it has this property; we call a license (g, p) acceptable if g is acceptable.Thus, for example, ∀x∀y(Said(∅, Perm(x, issue, y)) → Perm(Alice, issue, y)) is acceptable, but∀y∀z(Said(∅, Perm(Alice, issue, y)) → Perm(Alice, issue, z))is not.
It is not hard to see that if a grantg = ∀x 1 . . . ∀x n (d g → e g) is acceptable, then for any closed conclusion e, there are at most 2 |g||primitivePrin| grants of the form d g σ → e g σ such that σ is a closed substitution and e g σ = e. Thus, by restricting to acceptable grants and licenses, we solve the problem raised in Example 3.5.
Note that, this restriction is, in a sense, necessary to deal with the problem: If g is not acceptable, then there is a variable of sort Resource in d g , say x, that does not appear in e.
If we can find a substitution σ such that e g σ = e, then there must be infinitely many distinct grants d g σ → e g σ where e g σ = e, since there are infinitely many distinct substitutions possible for x. For example, if e = Perm(Alice, issue, g), where g is a closed grant, then the set of substitutions σ such that Perm(Alice, issue, z)σ = Perm(Alice, issue, g) and Said(∅, Perm(Alice, issue, y))σ is closed is the infinite set{[y/t z/g] | tis a closed term of sort Resource}.
We now consider the type of nontermination exhibited in Example 3.6.
This behavior occurs because Query tries to verify that a Said condition d holds by checking if d holds.
We see this in Example 3.6 when the algorithm tries to verify that the condition Holds(Said(Amy, e), L) holds by repeatedly calling Holds(Said(Amy, e), L).
To correct the problem, we modify Holds so that no call is evaluated twice.
Specifically, the revised Holds takes a fourth argument S that is the set of Said conditions that have been the first argument to a previous call; Holds(d, L, R, S) returns false if d ∈ S.
In addition, Holds sets S to ∅ if grants are added to R, because no condition has been evaluated under the new set of assumptions.
Because Holds2 calls the other algorithms, they also take the additional argument.Finally, we resolve the problem illustrated in Example 3.7.
As we hinted in Section 3.1, the problem lies in the definition of R .
Recall that we define Auth(e, L, R) = Auth(e, ∅, R ).
Roughly speaking, R should consist of the set of grants in R together with those issued by someone who has the authority to do so.
In other words, R should be R ∪ {g | for a principal p , (g, p) ∈ L and Query (Perm(p, issue, g), L, R) returns true}.
However, when computing Query (Perm(p, issue, g), L, R), Auth is given the argument L − {(g, p)} rather than L.
Our solution is to do the "right" thing here, and compute Query (Perm(p, issue, g), L, R).
But now we have to deal with the problem of termination, since a consequence of our change is that Query(e, L, R) terminates only if the set L = ∅.
To ensure termination, we modify Auth so that it does not call itself to evaluate a conclusion that has already been considered.
We remark that this is essentially the same approach that we take to ensuring that Holds terminates.Pseudocode for the modified Query2 is given in Fig- ure 4.
Query2 calls Auth2 and Holds2, which are the modified versions of Auth and Holds, respectively.
Pseudocode for Auth2 is given in Figure 5 and pseudocode for Holds2 is given in Figure 6.
To summarize, the main differences between Query2, Auth2, and Holds2 and their analogues as defined in the XrML document are:• Auth2 does not make use of the subset assumption.
• Holds2's output depends on R, which is the set of grants that implicitly hold.
• Holds2 (Said(p, e), L, R, S, E) returns true if e follows from L, R, and R p , which says that every principal in p may issue every grant.
• For any Said condition d, Holds2(d, L, R, S, E) returns false if d ∈ S.• Auth2 does not remove (g, p) from the set of licenses when determining if p may issue g.• For any conclusion e, Auth2(e, L, R, S, E) returnsfalse if e ∈ E.Query2(e, L, R, S, E): Figure 5.
The Auth2 Algorithm Holds2(d, L, R, S, E):let D = Auth2(e, L, R, S, E) for each d ∈ D if Holds2(d, L, R, S, E) returns true then Return true Return falseif e ∈ E then Return ∅ else let E = E ∪ {e} let R = R for each (g, p) ∈ L if Query2(Perm(p, issue, g), L, R, S, E ) returns true then let R = R ∪ {g} let D = ∅ for each grant ∀x 1 . . . ∀x n (d g → e g ) ∈ R and closed substitution σ such that e g σ = e let D = D ∪ {d g σ} Return Dif d = true then Return true if d = d 1 ∧ d 2 then Return i=1,2 Holds2(d i , L, R, S, E) if d = Said(p, e) then if d ∈ S then return false else let S = S ∪ {d} let R = R ∪ {∀xPerm(p , issue, x) | p ∈ p} if R = R return Query2(e, L, R, S , E) else% Reset S and E; they might follow from R .
return Query2(e, L, R , ∅, ∅) We observe that Query2 terminates on all input that is in our restricted language.
Recall that a grantg = ∀x 1 . . . ∀x n (d g → e g) is acceptable if every free variable of sort Resource that is mentioned in d g is also mentioned in e g ; the license (g, p) is acceptable if g is acceptable.
Suppose that e is a closed conclusion, L is a set of acceptable licenses, R is a set of acceptable grants, S is a set of Said conditions, and E is a set of conclusions.
Then Query2(e, L, R, S, E) terminates.Query2 has the intuitively correct input/output behavior for the examples in Section 3.2.
In Example 3.2, Query2(Quiet(p ), ∅, Quiet(p), ∅, ∅) returns false, when p = {Alice, Betty, Bonnie} and p = Alice, because Auth2 does not rely on the subset assumption.
In Example 3.3, Query2(Perm(Charlie, issue, g), ∅, {g 1 , g 2 }, ∅, ∅) returns true, because Holds2 correctly handles the set R of grants that implicitly hold.
In Example 3.4, Holds2(d, ∅, ∅, ∅, ∅) and Holds2(d, L, ∅, ∅, ∅) both return the intuitively correct answer true.
We avoid the problem in Example 3.5, since the grant ∀x(Said(Amy, Perm(Alice, issue, x)) → Trusted(Alice)) is not acceptable.
In Example 3.6, Query2(Trustworthy(Bob), L, R, ∅, ∅) returns false and Query2(Trustworthy(Bob), L, R , ∅, ∅) returns true, as it should.
In Example 3.7, Auth2(Smart(Alice), L, R, ∅, ∅) returns the intuitively correct answer, namely true, because Alice's issuance of g is taken into account when determining if Alice may issue g. Finally, in Example 3.8, Query2(Perm(Alice, issue, g 2 ), ∅, R, ∅, ∅) returns false, where R = {∀x(Said(Amy, Perm(x, issue, g 2 )) → Perm(Alice, issue, g 2 ))}.
This is the intuitively correct answer, because we no longer assume that some principals are implicitly trusted.We have discussed the examples in Section 3.2 with members of the MPEG-21 working group that are developing XrML.
They agreed with our observations and have apparently dealt with many of them in the final version of the specification.
Based on these discussions, we believe that the technical results in the rest of the paper should apply with very little change to the final XrML specification.
In this section we provide a formal semantics for the XrML fragment described in the previous section, by translating licenses in the grammar to formulas in a modal manysorted first-order logic.
The logic has three sorts: Principal , Right, and Resource.
The vocabulary includes the following symbols:• a constant p of sort Principal for every principal p ∈ primitivePrin;• a constant issue of sort Right;• a ternary predicate Perm that takes arguments of sort Principal , Right , and Resource;• a unary predicate Pr that takes an argument of sort Principal for each property Pr ∈ primitiveProp;• a function ∪ : Principal × Principal −→ Principal ;• a constant c g of sort Resource for each grant g in the language.
• a modal operator Val that takes a formula as an argument.Intuitively, Pr (p) means principal p has property Pr , and Val(ϕ) means formula ϕ is valid.
Notice that every principal in the grammar corresponds to a term in the language, because ∪ is a function symbol.
The semantics of our language is just the standard semantics for first-order logic, extended to deal with Val.
We restrict attention to models for which ∪ satisfies the following properties:U1.
∀x((x ∪ x) = x) U2.
∀x 1 ∀x 2 ((x 1 ∪ x 2 ) = (x 2 ∪ x 1 )) U3.
∀x 1 ∀x 2 ∀x 3 (x 1 ∪ (x 2 ∪ x 3 )) = ((x 1 ∪ x 2 ) ∪ x 3 )) U4.
∀x((x ∪ ∅) = x)In addition, we are interested only in Herbrand models, where the only elements of sort Principal , Right , and Resource are interpretations of syntatic terms.
We call such models acceptable models.
Val(ϕ) is true in an acceptable model m if ϕ is true in all acceptable models.
If a formula ϕ is true in all acceptable models, then we say ϕ is valid and write |= ϕ.
Thus, Val(ϕ) is true in an acceptable model iff |= ϕ.The translation takes a set L of licenses, a set R of grants, and a set S of Said conditions as parameters.
Intuitively, L is the set of licenses that have been issued, R is the set of grants that are assumed to be true, and S is the set of Said conditions that have been considered when determining if a condition holds.
(The role of S should become clearer in the course of defining the translation.)
Finally, we assume that if (g, p) ∈ L then p is variable-free.
(We do this because the assumption is built into Query.)
The translation is defined below, where t L,R,S is the translation of the string t given input L, R, and S.•If (g, p) ∈ L, (g, p) L,R,S = Perm(p, issue, c g ) ⇒ g L,R,S .
• If (g, p) ∈ L, (g, p) L,R,S = true.
•∀x 1 . . . ∀x n (d → e) L,R,S = ∀x 1 . . . ∀x n (d L,R,S ⇒ e L,R,S ).
• true L,R,S = true.
• If Said(p, e) ∈ S, then Said(p, e) L,R,S = false.
•If Said(p, e) ∈ S, then Said(p, e) L,R,S = Val( ∈L L,R ,S ∧ g∈R g L,R ,S ⇒ e L,R ,S ),where S = S ∪ {Said(p, e)} and R = R ∪ {∀xPerm(p , issue, x) | p ∈ p and x is a variable of sort Resource}.
•(d 1 ∧ d 2 ) L,R,S = d L,R,S 1 ∧ d L,R,S 2 .
• Perm(p, r, s) L,R,S = Perm(p, r, s * ), where s * = s if s is a variable of sort Resource and s * = c s if s is a grant.
• Pr (p) L,R,S = Pr (p).
The following theorem shows that our semantics match the procedure given in the XrML document (corrected as described in Section 3).
Theorem 4.1: For every closed conclusion e, set L of acceptable licenses, and set R of acceptable grants, Query2(e, L, R, ∅, ∅) returns true iff |=∈L L,R,∅ ∧ g∈R g L,R,∅ ⇒ e L,R,∅ .
Before leaving this section, we remark that, in the translation of Perm(p, issue, g), we can replace g by the constant c g because of our assumption that g is closed.
If we had allowed g to be open (i.e., to include free variables), then we would need to translate every conclusion Perm(p, issue, g) as Perm(p, issue, f g (x 1 , . . . , x n )), where f g is a function symbol and x 1 , . . . , x n are the free variables in g. Although this extension is straightforward, it might have a substantial impact on tractability; see Section 6.
In this section, we examine the complexity of deciding if the revised Query2 returns true on a given input.
As we now show, the problem is NP hard.
The real problem turns out to be that, if there are n primitive principals, we can construct 2 n principals using the ∪ operator.Theorem 5.1: Deciding if Query2(e, L, R, ∅, ∅) returns true, where e is a closed conclusion, L is a set of acceptable licenses, and R is a set of acceptable grants, is NP-hard.
Proof: (Sketch:) We show that we can reduce the Hamiltonian path problem to the problem of determining whether Query2(e, L, R, ∅, ∅) returns true.
Given a graph G(V, E), where V = {v 1 , . . . , v n }, we take v 1 , . . . , v n to be primitive principles.
We also assume that the language has primitive properties Node, Edge, and Path.
For each node v ∈ V , we consider a grant g v = Node(v) (recall that this is an abbreviation for true → Node(v)); for each edge e = (v, v ) ∈ E, we consider the grant g (v,v ) = Edge({v, v }).
(We are taking advantage of the fact here that {v, v } is a principal if v and v are primitive principals.)
Finally, let g be the grant∀x 1 . . . ∀x n (d 1 ∧ d 2 → Path({x 1 , . . . , x n })), whered 1 = 1≤i≤n Said(Alice, Node(x i )) and d 2 = 1≤i≤n−1 Said(Alice, Edge({x i , x i+1 })).
Let R = {g v | v ∈ V } ∪ {g e | e ∈ E} ∪ {g}.
It is not hard to show that Query2(Path({v 1 , . . . , v n }), ∅, R, ∅, ∅) returns true iff G has a Hamiltonian path.
To see this, observe that Auth2(Path({v 1 , . . . , v n }), ∅, R, ∅, ∅)returns {d 1 σ ∧ d 2 σ | σ(x i ) = v π (i), i = 1, .
.
.
, n, where π is some permutation of {1, . . . , n}}.
The condition d 2 σ holds iff there is a path x 1 σ, . . . , x n σ.
Thus, Query2 (Path({v 1 , . . . , v n }), ∅, R, ∅, ∅) returns true iff there is a Hamiltonian path in G.Theorem 5.1 shows that deciding the consequences of even simple grants can be hard.
The real culprit here, as we hinted before, is the ability to form more complex principals from primitive principals by taking union.
If we prohibit the use of the union operator (so that the only principals that can appear in grants are primitive principals, and variables of sort Principal are taken to range over primitive principals), then the problem becomes tractable.
The key insight is that, without union, the fragment is quite similar to function-free negation-free Horn clauses.
(The only difference is that our translation includes the Val operator, which does not affect the complexity.)
Determining if a literal follows from a set of function-free negation-free Horn clauses is a well-known polynomial time problem [5].
Using the same techniques, we can answer our queries in polynomial time.
Query2(e, L, R, ∅, ∅) returns true, where e is a closed conclusion, L is a set of acceptable licenses, and R is a set of acceptable grants, and ∪ does not appear in e, L, or R, is in polynomial time.How serious a restriction is it to disallow the ∪ operator?
Principals appear as the second argument in a license, the first argument in a Said condition, and the first argument in a conclusion.
• According to the XrML documentation, the license (g, {p 1 , . . . , p n }) is an abbreviation for the set of licenses {(g, p) | p ∈ {p 1 , . . . , p n }}.
It follows that we can restrict the second argument of licenses to primitive principals and variables without sacrificing any expressive power.
(In fact, we can restrict the second argument of licenses to only primitive principals, because Query assumes that if (g, p) is a license in L, then p is variable-free.)
• As for the Said condition, if we disallow ∪, then we do lose some expressive power.
However, the loss is not as serious as it may appear.
We can replace all grants of the form Said({p1, . . . , p n }, e), where p 1 , . . . , p n are primitive principals, by a grant Said({p 1 , . . . , p n } * , e), where {p 1 , . . . , p n } * is a new primitive principal, and then expand the set L of issued licenses by adding a new license (g, {p 1 , . . . , p n } * ) for every license (g, p) already in L, where p ∈ {p 1 , . . . , p n }.
It is not hard to show that this results in at most a quadratic increase in the number of grants.
Thus, as long as the first argument to Said is variable-free, we can express it without using ∪.
However, it seems that we do lose some expressive power in not being able to express Said conditions where the first argument is a set that involves a variable.
• To understand the impact of our restriction on conclusions, we need to consider the meaning of statements such as Trust({Alice, Bob}) and Perm({Alice, Bob}, issue, g).
According to the XrML document,Trust({Alice, Bob}) means Alice and Bob together (i.e., when viewed as a single entity) is trusted; Perm({Alice, Bob}, issue, g) means Alice and Bob is permitted to issue g. However, the XrML document does not explain precisely what it means for Alice and Bob to be viewed as a single entity Indeed, it seems to treat this notion somewhat inconsistently (recall the inconsistent use of the subset assumption).
There are other difficulties with sets.
Notice that if {Alice, Bob} is permitted to issue a grant, then presumably g holds if {Alice, Bob} issues g. However, according to the XrML documentation, the license (g, {Alice, Bob}) is simply an abbreviation for the set of licenses {(g, {Alice}), (g, {Bob})}.
So, it is unclear whether a principal that is not a singleton can issue a license.
Furthermore, if principals that are not singletons can issue grants and {Alice, Bob} is permitted to issue a grant g, then it seems reasonable to conclude that g holds if g is issued by both Alice and Bob, but it is not clear whether or not g holds if it is issued by only Alice (or by only Bob).
There may well be applications where there is an obvious and clear semantics for these notions.
But we suspect that, in these applications, there are typically only relatively few groups of interest.
In that case, it may be possible to simply take these groups to be new primitive principals, and express the relationship between the group and its elements in the language.
(This approach has the added advantage of forcing license writers to be clear about the semantics of groups.)
In short, we are optimistic that many applications do not need the union function.
XrML has several components that are not in our fragment.
Most have been excluded simply for ease of exposition.
In this section we list the main omissions, briefly discussing each one.
• XrML supports patterns, where a pattern restricts the terms over which a variable ranges.
For example, if the variable x is restricted to the pattern 'ends in Simpson', then x ranges over the terms that meet this syntactic constraint (e.g., x ranges over {HomerSimpson, M argeSimpson, . . .}).
Patterns in XrML correspond to properties in our fragment.
We could represent the example in our fragment by having the property Simpson in the language and having the set of grants determine which terms have the property.
XrML also allows a pattern to be a set of patterns.
We can express a set of patterns as a conjunction of patterns.
Since we can express conjunctions of properties in our fragment, we can also capture sets of patterns.
• XrML supports delegable grants.
A delegable grant g can be viewed as a conjunction of a grant g in our fragment and a set G of grants that, essentially, allow other principals to issue g .
For example, the delegable grant 'Doctor Alice may view Charlie's medical file and she may also give the right to view the file to her colleague, Doctor Bob' can be viewed as the conjunction of the grant 'Doctor Alice may view Charlie's medical file' and the grant 'Alice is permitted to issue the grant 'Doctor Bob may view Charlie's medical file".
Thus, we can express delegable grants in our framework.
• XrML supports grantGroups, where a grantGroup is a set of grants.
We can extend our syntax to support grantGroups by closing the set of grants (as currently defined) under the union operator.
Note that our proposed treatment of grantGroups is quite similar to our current treatment of principals.
• XrML supports additional types of rights, resources, and conditions, beyond what we have in our fragment.
There seems to be no difficulty in extending our translation to handle these new features, and proving an analogue of Theorem 4.1.
However, full XrML allows resource terms to be formed by applying functions other than ∪.
For example, the Standard Extension [3] 1 refers to a container resource that is a sequence of resources.
This naturally translates to a function container:Resource × Resource −→ Resource, so that the container s 1 , s 2 , s 3 is translated as container(s 1 , container(s 2 , s 3 )).
Allowing such functions makes the problem of deciding if a conclusion follows from a set of XrML licenses and grants undecidable, for much the same reason that the validity problem for negation-free Datalog with function symbols is undecidable [5].
• XrML allows an application to define additional principals, rights, resources, and conditions within the XrML framework.
Obviously, we cannot analyze terms that have yet to be defined; however, we do not anticipate any difficulty in extending the translation to deal with these terms and getting an analogue of Theorem 4.1.
• XrML allows a grant g to include free variables if g appears in the scope of a closed grant.
As we mention in Section 4, there is no problem dealing with this extra expressive power semantically; we simply replace each constant c g by a function f g .
However, there might be a problem with the extended language's tractability.
As we have just shown, adding function symbols in general leads to undecidability.
We are currently investigating whether adding the symbols in this particular way has similar consequences.
• XrML allows licenses to be encrypted and supports abbreviations via the Inventory component.
However, the XrML procedure for determining if a permission follows from a set of licenses assumes that all licenses are unencrypted and all abbreviations have been replaced by the statements for which they stood.
In other words, these features are engineering conveniences that are not part of understanding or reasoning about licenses.
We have examined XrML carefully, showing that the XrML algorithm does not seem to capture the designers' intentions in a number of ways.
Since no formal semantics for XrML is given in the XrML documentation, we cannot argue that the XrML algorithm is incorrect, although its behavior does not always seem reasonable.
To address the problem, we provided formal semantics for XrML in a way that we believe captures the designers' intent, modified the algorithm, and showed that the modified algorithm corresponds to our semantics in a precise sense.
Our work emphasizes the need for license languages to have formal semantics.
Without formal semantics, even carefully crafted languages are prone to ambiguities and inconsistencies.We have examined only a fragment of XrML.
A key reason for XrML's popularity is that the framework is extensible; applications can define new components (i.e., principals, rights, resources, and conditions) to suit their needs.
We do not believe there should be any difficulty in giving semantics to the extended language.
The real question of interest though is whether we can find useful tractable extensions.
As we have already seen, although functions pose no semantic difficulties, adding them makes determining what follows from XrML licenses and grants undecidable.
Another obvious and desirable feature to add is negation.
Currently, XrML does not support negation in either the condition or conclusion of grants.
This is a significant expressive weakness.
Without negation, policy makers cannot distinguish actions they would like to forbid from the actions that they do not care to regulate.
This makes merging two sets of policies essentially impossible; the merger will be inconsistent unless the polices are identical.While it is easy to extend XrML to support negation, doing so without placing further restrictions on the language quickly leads to intractability.
We believe that, using ideas from our earlier work [2], we will be able to identify useful tractable fragments of XrML extended with negation.
However, we leave this to future work.
Many thanks to Xin Wang (an editor for the XrML document), who answered our questions about the intended meaning of various XrML components.
