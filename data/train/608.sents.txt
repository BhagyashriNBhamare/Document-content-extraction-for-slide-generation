Epidemic protocols assume that information of a random set of nodes is provided at each protocol round.
By definition, the random set needs to be chosen uniformly and randomly from the entire set to gossip with.
Consequently, a node observes a different set of randomly chosen nodes at each different protocol round.
Several proposals have addressed the issue of providing a different random set of nodes at each different round.
In general, for large systems, this is done by creating a partial view of the entire membership at each node and exchanging part of the partial view among nodes.
While many interesting properties of this approach have been found, investigation is needed to study the performance of this approach with practically high network churn.
Without an action specifically designed for churn, shuffling would produce many dangling pointers in the partial view which point to an already left node.
This in turn would significantly degrade the quality of epidemic protocols.
The reason for the poor quality of the partial view is that the procedures of leave and join can take too long time to handle churn efficiently.
To address this issue, an additional action of reinforcement and a new join procedure are proposed and evaluated in this paper.
The reinforcement detects and removes dangling pointers at each shuffle more effectively, and the new join procedure accommodates a newly joining node remarkably fast.
The subsequent simulations show that these ideas enhance the shuffling mechanism such that the system processes network churn much faster and the quality of the node degrees is significantly enhanced.
Epidemic algorithms function by randomly disseminating information throughout the network in a manner similar to the spread of a disease [9], [10], [11], [12].
In each round, any given node randomly selects a set of peers from the entire network to communicate the given message to and continues to do so in subsequent rounds for the determined lifetime of the message.
Each subsequent recipient then also gossips received messages in a similar manner for the remainder of the message lifetime.
This paradigm of communication has been proven to reliably deliver the message to all nodes in the network [13] while reducing communication overhead and increasing scalability with respect to traditional broadcast schemes [22], [26].
Due to these advantages, epidemic protocols have been utilized to ensure the mutual anonymity of nodes [4] and also This work has been supported in part by Korea Electronics Technology Institute and the State of Michigan via Research Excellence Fund (REF) at Michigan Tech.to manage databases [9], routing tables in large peer-to-peer (P2P) overlay networks [28], and the location of resources [29].
Another advantage of epidemic protocols is that their parameters have been rigorously studied [5].
In order for the studied properties to be valid, each node running the epidemic protocol must randomly select log(N ) nodes to communicate a given message to, where N is the size of the entire network.
In order to achieve this, nodes must therefore (1) have a method of choosing a random set of nodes and (2) must know the size of the network.
Both of these goals can be achieved if the membership of the network is contained either at each individual node or at some centralized node.
However, as the network size increases, the maintenance of the membership view becomes cumbersome on individual nodes and in the case of the centralized approach, causes both a single point of failure and a communication bottleneck.As a result of these observations, several groups have studied ways of maintaining smaller local membership views which still maintain the necessary global randomness required for epidemic protocols to function.
One of the prominent method of achieving this goal is through the use of protocols in which nodes exchange portions of their local views with each other, essentially "shuffling" the views [15], [27].
In this paper, we are particularly interested in the work of CYCLON [27] as it showed promising results for achieving the desired randomness.
Therefore CYCLON is extended as a portion of this work.As was studied in CYCLON by simulation, shuffling views provides not only global randomness, but also remarkable recovery capability from large-scale node failures.
With a local view of a few tens of entries, it is practically impossible to partition the network even with a high percentage of node failures.
This indicates that this scheme has a high potential to work well in a highly dynamic system such as P2P networks.
Several issues remain to be addressed, however, to use shuffling in a realistic P2P system.
Among these, we consider problems of estimating the network size dynamically and of handling churn to be the two issues of primary concern.
Because the epidemic protocol parameters are dependent on the network size, and eventually both the shuffle length and the local view size will be dependent on the network size, knowing a relatively accurate network size will be an important factor in designing an epidemic protocol.
An interesting work of investigating two generic techniques to estimate the network size can be found in [20].
The other issue of handling churn is equally important because the impact of network churn on shuffling is not fully investigated in CYCLON.In the context of these churn issues, we focus on the key factor of time delay that occurs in join and leave procedures.
In this work, time delay refers to the characteristic that the entire network needs some non-negligible time to recognize a newly joined node, and by the same argument, it also needs some non-negligible time to "forget" about a node that has just left.
While the delay potentially has a minor negative effect when the churn rate is low, according to our findings, it creates a significant problem when the rate is relatively high.
Thus, unless the protocol is designed to handle churn quickly, the entire system will collect a large amount of invalid member information, which will significantly degrade the quality of the membership service.In this paper, we address the problems caused by high churn and inherent time delays by proposing DynamIc Membership ProtocoL for Epidemics (DIMPLE), which improves the speed of joining and leaving node recognition.
DIMPLE extends the work of CYCLON by modifying the shuffling mechanism and creating new join and leave procedures.
DIMPLE takes much less time than that of CYCLON to recognize a new node and takes statistically much less time than that of CYCLON to discern that a node has left.
In addition, simulation results show that the global randomness is well maintained even in the presence of high network churn.The remainder of the paper is organized as follows.
Section 2 details the related work within the field of membership.
Section 3 next describes the work of CYCLON to provide the background for the current work.
Section 4 provides the system model of DIMPLE while the main ideas of this paper are presented in Section 5.
After that, section 6 evaluates the main ideas by simulation and comparison between DIMPLE and CYCLON.
Lastly, Section 7 concludes the paper with a summary of the results and also describes avenues of possible future research.
Within the area of membership, a network can have centralized information, fully distribute the information amongst its nodes, or use some sort of middle-ground.
A group of work ( [1], [6], [8]) takes the centralized approach.
In this research, the membership information is all handled at a centralized server or set of servers.
Upon entering, each node must communicate with the server and upon leaving must do likewise (or the server must perform routine checks for connectivity).
As a result, the centralized server always has a consistent view of the membership of the system.
Utilizing this information, the server can then assign a random set of nodes for each of the members to communicate with.
The drawback to these schemes is that they leave themselves vulnerable to a single or fixed number of points of failure (i.e. the server(s)).
In addition, performance bottlenecks are created at the servers and communication overhead is increased due to the necessity of informing the server.
As a result, others have chosen to distribute the membership information at the individual nodes, giving each of them either full or partial views.The first approach would be to fully replicate the membership information at each node, making the choosing of a random set of nodes to communicate with trivial.
However, in large-scale networks, this approach is not possible due to the memory resources it would occupy (e.g. [7] has this constraint).
Partial views, however, can reside at individual nodes since they take up significantly less space.
The goals then become ensuring that by using these partial views, an overall randomness is still guaranteed.It is important to note that there exist many algorithms that deal with the membership of other types of networks with dynamic properties.
One such example is a Mobile Ad-hoc Network (MANET), in which nodes are free to come and go as they like.
Although such networks share the problem of frequent join and leaves, they are generally more concerned with connectivity, throughput, and delays and not the randomness of the topology [18].
Similarly, protocols that run over P2P overlay networks that do not use gossip are generally not interested in the randomness of the underlying topology either.
Such research includes [3], [17], [21], [30], [31] while other research does not achieve the randomness that is required for epidemics [24].
As a result, this paper will focus on related work that does address this randomness issue.One avenue that does attempt to alleviate the problem of providing randomness for overlay networks is the concept of Newscast Networks [16].
In these networks, the focus is on "macro behavior"-a term used to define overall functions of a network regardless of whether individual functions perform correctly (from biological inspirations such as ant colonies).
In simulations, it is shown that the path length and clustering of the randomly-generated networks provide a reasonable amount of randomness.
The protocol makes use of exchanging parts of local views of the current membership in order to attempt to achieve a random subset of the global membership at each node.
Another closely related method randomizes the partial views by probabilistically keeping or forwarding subscription messages from joining or leaving nodes [12].
Another approach to provide random partial views is through the use of a shuffling mechanism.
Such mechanisms are necessitated by the fact that left on their own, P2P networks do not form random graphs, but rather power law graphs [19].
Within the area of shuffling, the Peer Sampling Service considered three dimensions making the tuple (peer selection, view selection, view propagation) [15].
The options for these are shown in the following brackets: {random, head, tail} for peer selection, {random, head, tail} for view selection, and {push, pull, push-pull} for view propagation.
Within these options, head and tail correspond to the most recently added (to the view) and least recently added nodes, respectively.
Push, pull, and push-pull depict whether the initiating node sends its view, receives the view of the other node, or both.
Within this taxonomy, the previously described Newscast Networks and the shuffling mechanism of CYCLON would both correspond to a (random or tail, head, push-pull).
For the 27 possible combinations of the classifications, the Peer Sampling Service measured partitioning, path length, clustering coefficient, and the degree distribution of nodes throughout the network.While the work mentioned above focuses on the detailed algorithms of shuffling, the work of Allavena et.
al [2] provides an interesting theory predicting the network partition probability of the general idea of shuffling.
As one can imagine, with a reasonably large size of local views and an appropriate shuffle length, the probability of creating a network partition is extremely small.
We consider that this work [2] generalizes the resilience of the shuffling mechanism demonstrated by simulation in CYCLON [27].
Epidemic Protocols: An epidemic protocol delivers a message from a sender to all members in log(N ) rounds of forwarding, where N is the number of peers in a P2P system.
In the first round, a sender transmits a copy of the message to log(N ) randomly chosen peers.
After that, each peer that received a copy of a message repeats the same job, i.e. it forwards a copy of the message to another log(N ) randomly chosen peers.
The message lifetime is represented as a number of protocol rounds and is decremented by one at each intermediate forwarding.
A copy of a given message is held at a node until its lifetime is exhausted.
Hence, a copy of the message is gossiped (randomly forwarded) as many times as its current lifetime and then is discarded.
The time interval between two consecutive protocol rounds can be set arbitrarily.
As a result, all peers are highly likely to receive a copy of the original message in log(N ) rounds of cascaded forwarding.CYCLON Shuffle: The shuffling mechanism of CYCLON is shown in Algorithm 1.
Each node initiates CYCLON Shuffle exactly once in each cycle.
Nodes are not synchronized to perform shuffling in the same order at each cycle.
Different orders can be seen in different cycles.
Thus, a node, which shuffles at ith in a cycle, can do shuffle at jth in the next cycle (i = j).
In effect, each node shuffles views probabilistically twice in each single cycle; once initiated by itself and another initiated by another random node.Data structure: Each node maintains a local view which consists of c number of entries (The method of determining the value of c is outside the scope of this work).
Each entry contains the information of a node address (ID) and an associated age.
Hence, each entry is in effect a pointer to another node.
When a node P has a pointer to another node Q, P can initiate communication with Q.
As a result, a node pointer represents connectivity and when all pointers are viewed, the connectivity of the entire system is revealed.
If the system is randomly connected, the map will show the same properties of a random network.
In this paper, a node pointer that points to a node that has already left the system and thus is not available anymore (dead) is called a dangling pointer.
The essence of the CYCLON shuffling mechanism is the exchange of a portion of each individual local view between nodes.
Upon receiving a shuffle request from a node P , a node Q selects a subset of the same size l out of its own local view, and then sends this subset to the shuffle requester P .
By repeating the shuffle operation at every cycle, the system automatically converges to a steady state where both the average shortest path length between any pair of nodes and the clustering coefficient remain comparable to those of a random network.
A random network is typically defined as one that has the same number of nodes and the same number of edges, and is connected randomly.
While this convergence is desirable and is a fundamental characteristic of the shuffling operation, the convergence speed and the difference in the two metrics from those of a random network were concerns of CYCLON.In order to address this issue, CYCLON adds two additional steps to the basic shuffling mechanism in [25]; Step 1 and Step 2.
The basic shuffling mechanism chooses a shuffle partner node Q randomly out of the local view while CYCLON selects the oldest node Q to shuffle with by introducing age to each node pointer.
The age starts from 0 (zero) when a node pointer is first created in a local view, and increases by one at each subsequent cycle thereafter.
Furthermore, the age is transferable such that whenever a node pointer is shuffled to another local view, it preserves the age.
As a result, a node pointer is chosen as a shuffle partner by the time the age reaches c.
This means that a node pointer's life time has a maximum value of c.
As seen in Algorithm 1, once a pointer is chosen as a shuffle partner, the age of the pointer is reset to 0 (zero).
This small addition changes the performance of the basic .
Send this subset to peer Q. 5.
Receive from Q a subset of no more than l of Q's neighbors.
6.
Discard entries pointing to P , and entries that are already in the P 's local view.
7.
Update P 's local view to include all remaining entries, by firstly using empty local view slots (if any), and secondly by replacing entries among the ones originally sent to Q.shuffling mechanism significantly.
The in-degree 1 distribution of CYCLON Shuffle has much less variance than that of the basic shuffling mechanism because a dangling pointer can be detected in c number of cycles at worst.
A dangling pointer is detected when the target node is selected as the shuffle partner.
For example, if there is no response from the shuffle partner Q, P removes the pointer assuming that Q has already left the system.
Basic shuffling takes a much longer time because it chooses a shuffle partner randomly regardless how long a node has been in the system.
This addition makes the system converge significantly faster than the basic shuffling approach.
Furthermore, even a large percentage of node failures is not likely to partition the network with a reasonable value of c, such as 20 or 50.
forwards the join request to a node I randomly chosen out of its own local cache.
4.
At node R, where the TTL is decremented to 0 (zero), a randomly chosen entry is replaced with P 's address and age 0.
R sends the replaced entry to P .
5.
P collects all the replaced entries and starts using these entries as its own local view.CYCLON Join: Adding a new node to a randomized system should not disrupt the randomness.
To address this issue, CYCLON provides an interesting join procedure in Algorithm 2.
As can be seen, each random walk collects one random entry which is at least the average shortest path length away from the newly joining node P .
All the selected entries are then replaced with P and age 0.
As claimed in CYCLON, it would be hard to distinguish P from the rest of the nodes.Our concern with this algorithm is with the timeout value.
Because the algorithm involves several hops of forwarding and each hop counts at the application level, P may need to use a large value to timeout a random walk.
Further complicating the matter, part of the local view at any node can contain dangling pointers once the system is under high churn as we found in our experiments.CYCLON Leave: CYCLON suggests a timeout event to detect a dead node (one that has left the system).
Each node initiates the shuffling mechanism exactly once in each cycle.
Therefore, regardless of the in-degree of a dead node, the system requires at worst c number of cycles to purge the dangling pointer, where c is the size of the local view.
Nodes can join and leave the system at anytime, which creates high network churn.
When a node joins the system, it contacts an existing node chosen randomly from the system, which we call an introducer.
A mechanism is assumed to be in place which automatically chooses one member uniformly at random for a new node to contact and join the system.The parameters of epidemic protocols are dependent on the system size.
In this work we assume that the system size is always known.
In addition, DIMPLE does not distinguish a node fault from a node leave.
Any node which does not respond to a protocol activity is considered dead.
Intermittent faults are not considered in this work.The time interval of the cycle of the shuffling mechanism is theoretically independent of that of the the protocol round for epidemic protocols.
In static systems, where the number of nodes is relatively constant, once the network is randomized (i.e. the entire membership information is randomly and uniformly distributed over the local views), the shuffle cycle does not affect the quality of epidemic protocols.
This is because the local view remains random and uniform regardless of the cycle.
In dynamic systems, however, because the membership frequently changes, larger cycles will not be able to provide the same quality of random and uniform distribution of the entire membership to the local views.
In this work, it is assumed that the cycle of the shuffling and the round of epidemic protocols are the same.
It would be interesting to investigate the impact to the quality of epidemic protocols caused by the difference between the shuffle cycle and the epidemic round when the former is larger than the latter.
DIMPLE has three components; shuffle, join, and leave.
Shuffling is initiated by each node at every epidemic protocol round.
In effect, each node performs the shuffling mechanism twice; once initiated by itself and another initiated by another random node.
Nodes are not synchronized to perform a shuffle.
The order of shuffles can be different in different rounds.
In CYCLON, each entry of a local view consists of two pieces of information-the address and the age of the node.
In this work we extend the information of the entry to have information on "visited" nodes, where a "visited" node refers to a list of nodes in whose local views a node P has resided.
The size of the "visited" list is determined dynamically by the average shortest path length of the system.
The average shortest path length is that of the corresponding random network.
As a result, an entry of the local cache has the node address (ID), age, and a "visited" list.
In terms of memory overhead, DIMPLE requires k times larger space than CYCLON, where k is determined by the average shortest path length.
Because the size of local views is O(log(N )), however, this linear increase of space overhead should not cause concern.
DIMPLE Shuffle is shown in Algorithm 3.
There are two differences between this shuffling mechanism and that of CYCLON.
One is the way to determine the shuffle length (in Step 2) and the other is to introduce the reinforcement (Step 8 and Algorithm 4).
A node P initiates DIMPLE Shuffle at each epidemic protocol round, and the reinforcement occurs at the end of DIMPLE Shuffle.
The last step is so-named because it reinforces the quality of the out-degree.
Ideally each entry of the out-degree 2 should point to a node that is functional and still connected.
While this is true for a static system, this claim is not valid when network churn is introduced.
In our experiments, CYCLON produces a relatively poor quality of out-degrees with churn in that a large portion of the out-degree is actually pointing to dead nodes (which have left the system already but have not been detected yet as such).
In an extreme case with high churn, there was a node whose out-degree did not point to any live (still existing) node in CYCLON.
While a small number of dead node pointers in the local view may not degrade the quality of epidemic protocols significantly, we found in our experiments that the number of dead node pointers becomes larger with increasing churn rates.
By executing "Reinforcement" either a node Q will have an opportunity to fill an empty slot in the view (which may have been caused by either detecting a dead node or a large variance of the in-degree distribution) or a node P will challenge a random node to see if the node is alive.In fact, Reinforcement (Algorithms 4 and 5) not only reinforces the quality of the out-degree but so for the indegree also.
Because the out-degree is a collection of pointers, reinforcing the pointers will result in a smaller variance of the in-degree by filling empty slots in the view and by removing dangling pointers.
A large variance of the in-degree will degrade the quality of epidemic protocols because en epidemic protocol requires a local view which is uniformly random.
As seen in the evaluation section, Reinforcement indeed contributes to reinforcing the quality of both in and out-degrees.
One concern with Reinforcement is the overhead of executing it.
DIMPLE Shuffle essentially requires additional time to perform Reinforcement, which will be about the same amount needed for the CYCLON shuffling mechanism.
If there are time constraints on the length of the epidemic protocol round, this may cause implementation problems.
For cases where the protocol round is in the range of seconds, however, this will not be a concern.
For this work, we conjecture that this additional time will not be a significant problem for membership management purposes.
Investigation on the practical time interval of the protocol round for the same purpose is left as future work.In response to an action of Reinforcement Initiate, a node Q executes Reinforcement Response (shown in Algorithm 5).
2 The out-degree of node A is the number of pointers held by node A, pointing to other nodes.
1.
Increase the age of all nodes in the local view by one.
2.
Select a random subset of l neighbors from P 's own local view according to the steps below.
The shuffle length l is determined by log(N ), where N is the system size.
The subset has a node Q with the highest age in the local view, and l − 1 other random nodes.
3.
Replace Q's entry in the subset with a new entry of age 0 and with P 's address.
4.
Send this subset to peer Q. 5.
Receive from Q a subset of no more than l of Q's neighbors.
6.
Discard entries pointing to P , and entries that are already in P 's local view.
7.
Update P 's local view to include all remaining entries, by firstly using empty local view slots (if any), and secondly replacing entries among the ones originally sent to Q. 8.
Repeat Algorithm "Reinforcement Initiate"(Algorithm 4) l times in parallel.Algorithm 4: Reinforcement Initiate 1.
Select the oldest node Q in P 's local view in terms of the age.
2.
Send P 's address to Q. 3.
If P receives a NULL from Q, P does nothing.
4.
If P receives a valid response, P adds the node information to an empty slot if there is one or replaces the entry of Q with the received information of another node.
The DIMPLE Join mechanism is shown in Algorithm 6.
Compared to the corresponding mechanism in CYCLON, DIMPLE Join is significantly simpler.
A new node P requires only one message exchange with another node Q and reinforcement to create its own new local view.
This simple procedure eliminates or substantially shortens the time delay required in CYCLON Join, where a number of parallel random walks are launched to create a new local view for P to use.
This dramatic reduction of the time delay is achieved by extending the information of each entry of a local view.
Two questions may arise with this procedure.
One is whether a global randomness is preserved by creating a new local view out of an introducer's local view.
The other is whether the newly created local view contains sufficiently recent (fresh) and few or no dangling pointers.
As can be seen in the evaluation section, however, the global randomness of the system before and after this operation is still the same.
Intuitively, this procedure almost has the same effectiveness of the random walks of CYCLON Join.
The difference is when the random walk takes place.
In DIMPLE Join it happens k cycles before the join event while it takes the action k cycles after the join Algorithm 5: Reinforcement Response 1.
Q adds P 's information to Q's local view with age 0 if there is an empty slot.
Q then returns NULL to P .
2.
If Q's local view is full, Q randomly selects a node and replaces it with P 's information.
Q then returns the replaced node information to P .
event in CYCLON Join, where k is the average path length.
There is a chance that the newly created local view may have some dangling pointers, but this probability is quite small.
DIMPLE uses a timeout event to detect a dead node.
Essentially it is the same method as used in CYCLON.
The difference, however, is in how frequently the system tries to detect a dead node.
In CYCLON each node initiates the shuffling mechanism exactly once in each cycle.
Therefore, regardless of the in-degree of a dead node, the system requires at worst c number of cycles to purge the dangling pointer, where c is the size of the local view.
In DIMPLE, the worst case detection time is bounded by half of the cache size because the Reinforcement Algorithm is repeated for half of the cache size at the end of DIMPLE Shuffle.
In this section, we evaluate the performance of DIMPLE by simulation.
As can be seen in the following figures, DIMPLE converges to a steady state significantly faster than CYCLON does due to the use of reinforcement and the visited list under reasonably high network churn.
In addition, the resultant network (when in a steady state after the churn subsides) shows an even lower average shortest path length and a slightly higher clustering coefficient.
Overall, DIMPLE embraces network churn smoothly and enhances the global randomness achieved by CYCLON.Metrics: Two groups of metrics are used in this paper: one is to evaluate how fast DIMPLE handles join and leave events, and the other measures the positive/negative impact that DIMPLE has on the global randomness already achieved by CYCLON.
Two systems are used for the performance study: one system uses DIMPLE to provide dynamic membership service for a P2P system while the other uses CYCLON.
Some rates of network churn are used to measure the time required for the two systems to converge to a steady state.
The two properties of a random network, i.e. the average shortest path length and the clustering coefficient, are used to measure the impact on the global randomness achieved by CYCLON.
In addition, the quality of the in-and out-degrees of the two systems is studied.
The quality of the node degree is in fact the crucial factor determining the quality of epidemic protocols.Simulation Setting: Throughout the simulation, we use our own cycle-based simulator written in C++ [14].
Variable network sizes up to 100,000 nodes are used to measure the metrics.
In one simulation run, however, the network size does not change in order to decouple the network size impact from the final results.
This means that whenever a node leaves the system another node with another globally unique ID is added to the system to maintain the same network size.
When a new node is added it contacts an introducer, i.e. a randomly chosen node from the entire system.
The network churn is implemented as an exponential distribution of the node lifetime with an average value in cycles.
Whenever a new node is added, the new node is given a lifetime (in number of cycles).
The lifetime of each node is decremented by one at each cycle.
For example, when the shuffle cycle is 1 second and the average lifetime is 180 cycles, the time of the average lifetime would be about three minutes.
The selection of this lifetime is based on previous work [23] (see Table I).
From this it can be seen that the average lifetime of three minutes is comparable to that of the two real systems-FastTrack and KaZaA.
Gnutella, Napster 50% ≤ 60min Chu Gnutella, Napster When the lifetime reaches 0 (zero) the node silently leaves the system without generating any notification.
During its lifetime a node always conforms to DIMPLE and never fails.
A dead node is detected when another node tries to contact it to shuffle or reinforce with.
The timer resolution to detect a dead node may be large in this simulation because the timeout value is given in the number of cycles.
Although this resolution would not be realistic for systems where a fine resolution (e.g. a few milliseconds) is required, it is still fair to compare the two systems in a highly dynamic situation.
Initially, the two systems are completely randomized, after which the network churn begins.
The simulation was run on a set of different desk top computers using Linux OS.
The final results are represented independently of the wall clock time.31% ≤ 10min Sen FastTrack 50% ≤ 1min Bhagwan Overnet 50% ≤ 60min Gummadi KaZaA 50% ≤ 2.4min Churn Processing Time: In order to demonstrate the improvement on the dynamic membership made by DIMPLE, the churn processing time of the two systems is compared here.
The churn processing time has two components: one is the time required for the system to recognize a newly added node, and the other is the time to purge a dangling pointer out of the local view.
In this section, two metrics are introduced for the comparison study: join time and leave time.
The former is defined as the time elapsed from when a new node contacts an introducer to the time when the new node creates a complete local view of its own.
The latter is defined as the time elapsed between when a node leaves the system and when the system completely purges the dangling pointer from all local views in the system.A comparison of the two join times is trivial.
Just one cycle is enough for the join time of DIMPLE.
This is obvious due to the DIMPLE Join (Algorithm 6) procedure in the previous section.
The CYCLON system requires as many as the average path length hops of message forwarding.
Although the exact amount of time for the CYCLON join depends on each node's workload at runtime, the join time of the CYCLON system can be equated to the number of forwards required in the join procedure.
Hence, the CYCLON system requires at least as many as the number of forwards times larger than that of the DIMPLE system.
The join time of CYCLON becomes even longer when a timeout due to a dangling pointer at an intermediate node is taken into account.The leave time measurements are shown in Figure 1.
In this experiment, an increasing system size from 1,000 to 100,000 nodes was utilized.
The average node lifetime was 180 cycles and the local view size was 2 × log(N ) for both systems.
While it was expected that the DIMPLE system removes the dangling pointers sooner than the CYCLON system, it is interesting to note that the leave time of the CYCLON increases at a much higher rate than that of DIMPLE, i.e. the speed gain becomes larger as the network size increases.
The reason for why it looks like a step function is that the local view size increases step-wise due to 2 × log(N ), where N is the network size.
This increase results in more cycles to purge dangling pointers.
This comparison clearly demonstrates the effectiveness of Reinforcement.Convergence under Churn: The convergence of the CY-CLON system is well studied [27].
According to the work, the CYCLON system converges to a steady state where the system shows the same properties as the corresponding random network even after a high percentage of node failures.
In this section, both systems are investigated to see if they converge under network churn.
In this experiment, the average node lifetime was 180 cycles, and the network size was 2,000.
Both systems were run for 20,000 cycles to give enough time to observe convergent behavior.
The metric used to measure this behavior was the standard deviation of the average shortest path length.
The average path length itself is shown in the next subsection.
Figure 3 show the standard deviation of the inand out-degrees of both systems respectively.
As can be seen, both systems converge to a steady state with the churn rate that was used throughout the experiments.
Secondly, the DIMPLE system shows lower values.
While it is very likely that lower values will support higher quality of epidemic protocols, further research is required to accurately measure the resultant quality of information dissemination and is beyond the scope of this paper.
Unless otherwise mentioned, the rest of the figures in this paper show data obtained from a converged state.
Degree Distribution: The quality of node degree distributions is critical to epidemic protocols because they determine the overall quality the information dissemination.
First, in dynamic systems, a local view can have dangling pointers at any moment which degrade the quality of epidemic protocols eventually.
The second issue is load balancing among nodes.
Ideally, each node should have the same in-degrees over time because the critical parameter of epidemic protocols log(N ) assumes a random selection.
Different in-degrees would bias the selection process of log(N ) in an undesirable way.
The quality of the node degree distribution, therefore, is measured by the two metrics in this section: uniformness and freshness.
Uniformness refers to the distribution of the in-degree sizes considering only the live nodes.
Freshness meanwhile refers to the distribution of out-degree sizes, again considering only the live nodes.
Effectively, the two metrics are concerned about the same quality-i.e. node degree distribution.
However, given that the size of the in-degree is not fixed at each node, measuring the number of pointers from live nodes is an effective measurement of the corresponding quality.
On the other hand, because the size of the out-degree is uniformly fixed to some value at each node, measuring the percentage of dangling pointers is the preferred metric for observing the quality of the out-degrees.
Figure 4 shows the in-degree distribution of the two systems from an experiment where both systems had 100,000 nodes with an average lifetime of 180 cycles.
The local view size was fixed to 2 × log(N ), and the shuffle length was log(N ) for both systems.
As can be seen, the CYCLON system has a wider distribution than DIMPLE.
Accordingly, the peak value of CYCLON is lower.
Interestingly, the average values of the two systems are different.
This is because CYCLON has a larger number of pointers from dead nodes than DIMPLE.
Consequently, the average value of CYCLON is shifted down from the value of 2 × log(N ), which is 24 in this particular case.
On the other hand, DIMPLE maintains an average value very close to log(N ) because it can detect a dangling pointer much quicker.
Overall, this figure clearly demonstrates that DIMPLE maintains a higher quality of in-degrees under high churn.
Figure 5 shows the out-degree distributions of the two systems respectively from the same experiment.
Although the size of the out-degree is uniformly fixed to 2 × log(N ) at each node, CYCLON shows a severe distortion of the nominal size when pointers are measured only from live nodes.
This is, again, because the local views of nodes in the CYCLON system have a higher percentage of dangling pointers at runtime under churn.
DIMPLE also contains dangling pointers, but due to the reinforcement procedure, the dangling pointers Average Path Length: Figure 6 shows the average path length of the two systems.
In this experiment, the average lifetime was 180 cycles, and the network size varied from 1,000 to 10,000 nodes on a log scale.
The average path length was then measured by computing the averaged path length between every possible pair nodes of the system (in number of hops).
It is important to note that dangling pointers are not considered here.
In this metric, lower values are desirable because they would result in faster information dissemination.
Because the size of the out-degree is uniformly fixed at each node, the average path length increases with increasing network size.
Although the difference of the average path length of the two systems is small, the DIMPLE system always has lower values than CYCLON.
The low population of the out-degrees of the CYCLON system seems to have contributed to the higher average path lengths.
This is because a larger outdegree for a given node increases the probability that it can find a shorter path.
Formal analysis of this result, however, is left as future work.
In this experiment, the largest network size was limited to 10,000 nodes.
This is because the computational time of the average path length takes a prohibitively long time with larger network sizes.
Heuristic algorithms to produce approximate values in a relatively shorter amount of time are currently under investigation.It is also important to note that the sampling points are not evenly distributed.
Two close points are sampled around the network size of 1096 and of 2981 where the local view size changes by two.
Because the local view size is determined by 2 × log(N ), and because an increase of the size causes an increase in the population of the out-degrees, the average path length becomes lower immediately after the change.
Overall, however, the average path length increases with the increasing network size.
In fact, the average path length of CYCLON is lower than that of the corresponding random network.
As previously stated, using the concept of age results in these lower values, and, as can be seen in the graph, DIMPLE improves it further.
Average Clustering Coefficient: Figure 7 shows the average clustering coefficient of the two systems.
The data is obtained from the same experiment used to create Figure 6.
The clustering coefficient is defined as the ratio of the existing links among a node's neighbors over the total number of possible links among them.
This metric is typically used to understand what percentage of the neighbors of a node are also neighbors among themselves.
The average clustering coefficient is then the averaged value taking all the nodes in the system into account.
In this experiment, lower values are desirable because higher values would result in both higher chances of network partitioning and poor information dissemination.
Similar to Figure 6, Figure 7 shows only a small difference between the two systems.
Interestingly, however, the DIMPLE system shows higher values.
This result might arise from the same reason, i.e. the low population of the local view of the CYCLON system.
By having a randomly chosen low population, a node has a lower chance of clustering.
This result is coherent with Figure 6 and also the analogous figures presented in the CYCLON work [27].
Due to the small magnitude of the difference in the two clustering coefficients, DIMPLE is not likely to significantly degrade the quality of the epidemic protocols.
By considering all the figures in this section, it is clear that DIMPLE improves CYCLON overall.
Specifically, DIMPLE enhances the global randomness achievable by CYCLON.
In this subsection, the standard deviation of the out-degrees is shown as a metric to show the performance difference with different churn rates.
Figures 8 shows the metric for the out-degrees given a system size of 5,000 nodes.
Intuitively, the performance difference between the two systems should increase with increasing churn rates and vice versa.
As can be seen for average node lifetimes of greater than 300 cycles, the out-degree of CYCLON is significantly affected by the network churn while that of DIMPLE is not.
A similar trend can be found in the in-degrees too (not shown in this paper due to space limitations).
Since an average lifetime of about 200 cycles is realistic, the performance gain that DIMPLE provides is justified in such situations with churn.
A new approach to enhance the idea of shuffling has been proposed and evaluated in this paper.
The proposed idea reinforces the quality of the node degrees after each shuffle.
As shown in the simulation, the proposal helps process frequent join and leave activities efficiently and effectively, thus enhancing the dynamic membership service for largescale systems.
Consequently, epidemic protocols will be able to maintain a high quality of information dissemination even with high network churn.The current proposal, however, assumes that the network size is known.
While this was necessary to decouple the effect of the network size from the effect of the reinforcement, the proposal needs to be combined with another mechanism which enables the system to estimate the network size dynamically at runtime.
Because the parameters of epidemic protocols are based on log(N ), a relatively accurate estimation of N would then complete the self-organizability of DIMPLE.
As a result, some heuristic estimation algorithms are currently under investigation.
The other direction for future work is to investigate the quality of information dissemination of epidemic protocols using DIMPLE.
Although many ideas have been proposed, the quality of epidemic protocols under high network churn with a specific membership service still requires additional research.
