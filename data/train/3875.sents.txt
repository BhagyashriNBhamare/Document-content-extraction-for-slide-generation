In a typical infrastructure-as-a-service cloud setting, different clients harness the cloud provider's services by executing virtual machines (VM).
However, recent studies have shown that the cryptographic keys, the most crucial component in many of our daily used cryptographic protocols (e.g., SSL/TLS), can be extracted using cross-VM side-channel attacks.
To defeat such a threat, this paper introduces HERMES, a new system that aims to protect the cryptographic keys in the cloud against any kind of cross-VM side-channel attacks by simply partitioning the cryptographic keys into random shares, and storing each share in a different VM.
Moreover, it also periodically re-shares the cryptographic keys, thereby invalidating the potentially extracted partial ones.
We have implemented HERMES as a library extension that is transparent to the application software, and performed deep case studies with a web and a mail server on Amazon EC2 cloud.
Our experimental results show that the runtime overhead of the proposed system can be as low as 1%.
Recent advances in cloud computing enable customers to outsource their computing tasks to the cloud service providers (CSPs).
Typically, CSPs manage extensive amount of computational resources, and provide services, such as Infrastructure-as-a-service (IaaS) [40], Platform-as-a-service (PaaS) [31], Software-as-a-service (SaaS) [44].
By outsourcing core computing to the cloud, customers can mitigate the burden of resource management, and concentrate more on the core business tasks.
A recent study on the cloud usage [3] reported that nearly 30% of enterprise IT organizations use public IaaS, such as Microsoft's Azure Service [12], Amazon's Elastic Compute Cloud (EC2) [4], or Google's Compute Engine [9].
Despite its numerous advantages, cloud computing also introduces new challenges and concerns, primarily the security and privacy risks [48].
The concerns simply stem from outsourcing critical data (e.g., health records, social security numbers, or even cryptographic keys) and/or computing capabilities to a distant computing environment, where the resources are shared with other potentially untrusted customers.In particular, to increase efficiency and reduce costs, a CSP may place multiple virtual machines (VMs), belonging to different customers, to the same physical machine.
In such an execution platform, VMs should be logically isolated from each other to protect the privacy of each client.
The CSPs use virtual machine monitors (VMM) to realize logical isolation among VMs running on the same physical machine.
However, recent studies show that a clever adversary can perform cross-VM sidechannel attacks (for brevity, cross-VM attack) to learn private information that resides in another VM, even under carefully enforced logical isolation in public cloud infrastructures.
More specifically, Ristenpart et al. [41] showed heuristics to improve an adversary's capabilities to place its VMs alongside the victim VMs, and learn crude information (e.g., aggregate cache usage).
Most recently, Zhang et al. [51] managed to extract ElGamal decryption keys by cross-VM attacks.
These studies have clearly demonstrated that logical isolation and trustworthy cloud provider are not necessarily enough to guarantee the security of sensitive information.It would be too optimistic to assume that an adversary is only limited to the two aforementioned attacks.
Unfortunately, there exists a wide variety of side-channel attacks, each with its own setup and methodology (e.g., [13-15, 19, 26, 28, 34, 43]).
Simply, the absence of such attacks on public cloud infrastructures does not necessarily mean that they are inapplicable.
In fact, there are side-channel attacks that target virtualized environments, and leverage timings of cryptographic operations or monitoring of common resource usage [39,47].
Those attacks may be just one step behind being directly applicable to the public cloud setting; which is why proposing prevention mechanisms is extremely vital for the security and privacy of the sensitive data in the VMs including the cryptographic keys.To this end, we present HERMES, a system that remedies the cryptographic key disclosure vulnerabilities of VMs in the public cloud by using well-established cryptographic tools such as Secret Sharing and Threshold Cryptography.
Specifically, the key technique in our system is to partition a cryptographic key into several pieces, which are computed using threshold cryptosystems, and to store each share on a different VM.
This makes it harder for an adversary to capture the complete cryptographic key itself, since it now has to extract shares from multiple VMs (note that there is no single key or a centralized key anymore in HERMES).
To further improve the resilience, the same cryptographic key is re-shared periodically, such that a share is meaningful in only one time period.
Consequently, we introduce two significant challenges against a successful attack: (i) multiple VMs should be attacked, and (ii) each attack should succeed within a certain time period.
As a proof-of-concept, we apply HERMES to protect the cryptographic keys of Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols.Contributions.
In short, this paper makes the following four contributions:1.
We present HERMES, a novel system to prevent the leakage of cryptographic keys in cloud VMs via mathematically proven techniques -Secret Sharing and Threshold Cryptography.
It is followed by the threat model in §3, and the full technical details of HERMES in §4.
Then, we evaluate HERMES regarding its efficiency in §5, and discuss its security in §6.
Finally, we review the related work in §7, and conclude in §8.
SSL and TLS are widely accepted communication protocols to establish a secure channel between two mutuallydistrusting parties, where two protocols contain only a few minor differences [16,25,29,37].
For brevity, we will refer the protocols as SSL; and any statement for SSL is also applicable to TLS.
The SSL protocol consists of a handshake and a record process, where the parties in the protocol are called the client and the server.
In the handshake process, they use public key cryptography (PKC) to authenticate each other and agree on the session keys.
The session keys are bound for only one session, and used for confidentiality and integrity.
To calculate session keys, parties need to share a master secret, which is derived from random data exchanged, and pre-master secret.
Fig. 1 shows an overview of the handshake process.
First, the client starts by sending client hello message (Step 1), which contains a set of supported cryptographic algorithms (cipher suites in SSL terms), and some random data to be used in key generation.
Then, the server sends its certificate, some random data, and the accepted cipher suite (Step 2a); and key exchange parameters if necessary (Step 2b).
Moreover, if the server wants to authenticate the client, it requests the client's certificate (Step 2c).
The server finishes by sending hello done message (Step 2d).
If requested, the client sends its certificate to the server, along with some random data signed by its private key (Step 3a).
Next, it creates a random pre-master secret, encrypts it with the server's public key, and sends to the server (Step 3b).
Now, both parties can calculate the master secret from the pre-master secret and random data using protocol specific combinations of pseudo-random functions.Based on the chosen cipher suite, the number and the content of the messages may vary.
For instance, when Diffie-Helman (DH) [22] is used for pre-master agree-ment, the parties sign their DH parameters with their private keys, and send them in Step 2b and Step 3b.
On the other hand, they may use RSA to agree on the pre-master secret, where the client encrypts the pre-master secret with the server's RSA public key, and the server decrypts it using its private key.
The following variants of the RSA algorithm alter the way that a message is exponentiated with the private key.
In both versions, the dealer holds a public-private RSA key pair, and wants to partition the private key over l non-colluding parties.Distributed RSA (D-RSA).
Given a private key d, D-RSA uses additive secret sharing, and partitions d intol random shares d 1 ,.
.
.
,d l , where d ≡ d 1 + .
.
.
+ d l mod φ (n), n is the modulus, and φ is Euler's totient function.
Given the public key (n, e) and a share, none of the parties can learn anything about d. Furthermore, an adversary should capture all l shares to learn d.To exponentiate a message M ∈ Z n with d, one of the parties acts as the combiner, whose job is to combine partial results from all parties.
Each party p i for 1 ≤ i ≤ l calculates M d i , and sends it to the combiner.
Then, the combiner simply multiplies each message and finalizes the operation.
At the end of the process, the combiner does not learn anything about the private key, but only the final result M d .
For a detailed security analysis, we refer to the original paper [24].
Threshold RSA (T-RSA).
In this variant, the given private key is partitioned using shamir secret sharing, in which only 1 < k ≤ l shares are needed to complete an exponentiation with d.
The key technique in T-RSA is to embed the private key into a degree (k − 1) polynomial, evaluate the polynomial on l different points, and share the results over the set of parties.
Once again, a party cannot learn the partitioned private key simply from the public key and its share.To exponentiate a message, k parties are chosen uniformly at random, where the combiner once again does not learn anything other than M d .
On the other hand, an adversary should capture k shares to learn the private key.
In App.
B, we present more details on private key partitioning and usage, while an intensive security analysis is performed in the original paper [42].
Entities.
The entities in our threat model are the Cloud Service Provider (CSP), the Defender, and the Adversary, where the last two are simply the clients of the first.
The CSP offers IaaS and PaaS, which the clients can benefit by initiating VMs.
The defender and the adversary use the same CSP, where the latter attacks the former to retrieve private information.
Although the CSP has a potential to violate its clients' privacy and integrity, we assume that the CSP is trusted.
This is a valid assumption, since (i) Service Level Agreements (SLA) provide a clear-cut distinction between what a CSP can and cannot perform on a client's data/VM, and (ii) disobeying a SLA may impose prohibiting punishment for the CSP.Logical isolation.
To improve utilization, the cloud provider may perform multiplexing.
Hence, multiple VMs may run on the same physical machine, which means a VM of the adversary may run on the same physical machine with a VM of the defender; and they may share the same physical resources (e.g., CPU, memory, hard-drives, cache).
On the other hand, we have no distinction on the VMM that the CSP uses, as long as it provides logical isolation between the VMs on the same physical machine.
We assume that the adversary knows the software running on the defender VMs, but cannot leverage the memory vulnerabilities of those software to compromise (i.e., to take full control of) the VMs.Adversary's goal.
The defender has multiple VMs in the cloud, and each one may contain a set of private cryptographic information.
This set of information includes temporary symmetric keys (e.g., AES key), or a share of a distributed private key (e.g., share of an RSA key) that is created by HERMES.
An adversary's aim is to capture PKC keys, since capturing a session key is useful for only one session, while acquiring PKC keys grants full access.
To fulfill its desire, the adversary is allowed to execute any cross-VM attack in its disposal to extract private information from each VM, where the attack itself is applicable to the cloud setup.
For instance, in access-driven attacks, the adversary may need to co-reside its VMs with the defender VMs.
In such a case, the adversary should achieve co-residency, and make the attack applicable in a typical cloud setup.
Moreover, the attacks on the defender VMs are not necessarily executed in serial manner.
Each separate adversary VM can employ the cross-VM attack in parallel, if the nature of the attack enables such setup.Finally, since the adversary uses the same cloud as the defender, we assume that all channels may be eavesdropped by the adversary, starting from right after the bootstrapping of HERMES.
Giving this capability to the adversary may seem like an overprovision.
However, we take precautions to handle even the worst case scenario, in which the adversary, somehow by-passing CSP's security mechanisms, listens to the conversations between the defender VMs.
Misc.
We do not consider the placement of the defender VMs, and its effects on the security of HERMES.
For instance, one platform (e.g., a region, a physical machine, etc.) may, somehow, be more susceptible to a certain range of cross-VM attacks; or one can claim that the more distributed the defender VMs, the better the security.
Zhang et al. aim to physically isolate a defender VM as much as possible [50], thus preventing only access-driven sidechannel attacks.
Such precautions will tighten the defense against access-driven attacks; however, it will fail to stop the adversary from executing different attacks.
On the other hand, HERMES aims to protect the cryptographic keys from all cross-VM attacks, no matter how the VMs are placed.
In SSL, a certificate may contain public parameters of different PKCs (e.g., RSA, DSA, ECC), which are employed to encrypt secret information, or to sign and show that certain temporary data is authentic.
In HERMES, we assume that the parties use RSA as the PKC; however, extension to other PKCs is trivial as long as a threshold cryptosystem for that new PKC is provided.Setup.
Figure 2 shows an overview of the entities in HER-MES: the defender, the adversary, l number of VMs that belong to the defender, and the clients who want to establish secure connection to the defender's VMs using SSL and benefit from the defender's web application.
The defender holds a set of private RSA keys, and partitions them over the set of defender's VMs.
Each VM holds one share for each partitioned private key, and they act together to exponentiate with it.
The VM that directly talks with the client is called the combiner, while the remaining VMs are called auxiliary VMs.
The adversary aims to learn at least one of the partitioned RSA private keys by (i) performing cross-VM attacks on each VM to capture its shares, and by (ii) listening each message flowing between the VMs.
To achieve secure communication, each channel is established using our enhanced SSL protocol.
More specifically, inter-VM channels are established with mutual verification (i.e., both end of the parties authenticate each other), while only the combiner VM is authenticated in a channel between that VM and a client/defender.
The defender re-shares the same private keys every τ seconds.
The time window between two consecutive re-sharing moments will be referred to as an epoch, while the shares of a private key in any two sessions are independent.Modes.
HERMES has two modes of operation, namely D-RSA and T-RSA modes, using the corresponding RSA variant (cf. §2.2).
When the system runs in D-RSA mode, the adversary has to capture all shares of a private key to learn the key itself; whereas in T-RSA mode, it has to capture at least k shares.
The benefits of the second mode are two-fold: (i) The system is more fault-tolerant to server failures, and (ii) the system can achieve better utilization by distributing work among different subsets of VMs, especially when k ≤ (l/2).
Stages.
The execution of HERMES is composed of several stages: (i) Partitioning a private key ( §4.2); (ii) Bootstrapping the system by handing in the initial set of shares, and establishing initial inter-VM SSL channels ( §4.3); (iii) Establishing connection between a defender VM and a client ( §4.4); (iv) Renegotiating an inter-VM SSL channel ( §4.5); and (v) Distributing new shares of the same private keys ( §4.6).
In SSL, the communicating parties may execute mutual verification or server-only verification.
In any case, the server uses its private key at two possible steps (cf. Fig. 1): (i) After Step 2a to sign temporary parameters; (ii) afterStep 3b to decrypt the pre-master secret.
On the other hand, the client uses its private key before Step 3a only in the mutual verification.
With respect to a regular SSL execution, we change the way that the server or client computes the modular exponentiation of a message with its RSA private key at those steps.
Fig. 3 shows the outline of our modifications in a serveronly verified SSL execution.
The client performs SSL handshake with the combiner, while the VMs communicate over already established secure channels.
After Step 2a, the combiner may create temporary key parameters and sign them in collaboration with the auxiliary VMs.
message content is simply the parameters to be signed (Step 2aa).
Each auxiliary VM in the computation calculates its partial result using its share of the private key and gives it to the combiner in the sign partial result message (Step 2ab).
On the other hand, if the combiner has to decrypt an incoming message from the client, it sends a help decrypt message to all auxiliary VMs in D-RSA mode (or up to k in T-RSA), containing the masked or plain version of the client's message (Step 3ba).
Then, each auxiliary VM sends the computed partial result with the dec partial result message to the combiner (Step 3bb).
Whether or not the content of the help decrypt message should be masked with a random number depends on the mode of operation.
Even in the worst case, where the adversary knows each message exchanged between VMs, the combiner does not have to mask the message in D-RSA.
The reason comes from the security of D-RSA.
Assume the client sends M e mod n to the combiner, where M is the pre-master secret, and (n, e) is the public key.
In order to learn M, the adversary needs each VM's partial result, just like the combiner does.
However, even if the adversary cracks down all secure channels and captures all messages, it can only learn l − 1 parties' partial results, since the combiner does not send its partial result to anyone.
Thus, the adversary cannot learn any useful information, and cannot compute M.
If T-RSA is employed, then the combiner selects k VMs, S = {i 1 ,.
.
.
,i k }, uniformly at random from the set of VMs and sends the message to them.
There are two cases to consider: (i) If the combiner is included in S, then the message does not need masking similar to D-RSA case.
The adversary needs k partial results, but can only capture k − 1.
(ii) Otherwise, the combiner masks the message with a random number; since the adversary may have captured k partial results sent from k different auxiliary VMs, and the other parameters in the calculation are public (e.g., ∆ = l!
, a and b can be calculated from gcd(e, 4∆ 2 )), the adversary can now calculate M.In addition to server-only verified SSL channels, HER-MES necessitates mutual verification, since any two defender VMs, V M i and V M j , may perform key renegotiation to refresh session keys.
Without loss of generality, assume that V M i is the client in SSL protocol, while V M j acts as the server.
Now, both parties should communicate with the auxiliary VMs to perform operation with their own private keys.
The server may need co-operation after steps 2a and 3b, while the client may need to sign random data with its private key before Step 3a.
The server acts as mentioned in server-only authenticated Enhanced SSL.
On the other hand, the client sends help sign message to auxiliary VMs before Step 3a, and combines the partial results.
By following those steps, two defender VMs can execute a successful handshaking process, using already established secure and authenticated SSL channels with the auxiliary VMs.
Given an RSA key pair (n, e, d) and the number of VMs l, the defender performs partitioning and calculates the shares of each defender's VM.
In case HERMES is running in T-RSA mode, the defender uses the third parameter k, minimum number of VMs needed to operate.In D-RSA, the share of the i th VM, denoted by sh i , is simply a uniformly randomly chosen value from the domain Z φ (n) , where sh 1 + .
.
.
+ sh l is equal to d. Hence, the defender chooses l − 1 random values, and calculates the final share assh l = d − (sh 1 + .
.
.
+ sh l−1 ) mod φ (n).
On the contrary, key partitioning process is a bit more complicated in T-RSA.
Algo.
1 shows an outline of preparations of each VM's share.
For each subset S α ⊆ {1,.
.
.
,l}, where |S α | = k, the defender calculates the interpolation constants λ S α 0, j , and exponents for each V M j ∈ S α (line 10-16).
Moreover, the defender stores the modulus values for a, b in V i 's share for d, since i (the function input) states that the given private key belongs to V M i (line 18-19).
The defender creates l VM instances on the CSP, and an RSA key pair (n i , e i , d i ) for each V M i , 1 ≤ i ≤ l. Next, she partitions each private key into shares and gives each VM a unique ID i ∈ [1, l], the shares that correspond to that ID, and the certificate for the i th RSA key pair.At this stage, the VMs need to establish initial authenticated and secure SSL channels using our Enhanced SSL.
However, as mentioned in §4.1, Enhanced SSL necessitates already established secure SSL channels to transfer messages between VMs.
We have to make an assumption here, which will allow us to bypass this requirement, andAlgorithm 1 Preparing shares for T-RSA 1: Input: RSA Parameters n, p = 2p 񮽙 + 1, q = 2q 񮽙 + 1, e, d 2: Input: T-RSA parameters l, k, i 3: for j ← 1 to l do 4: sh j ← / 0 5: end for 6: ∆ ← l!
7: Calculate S = {S 1 ,.
.
.
,S z }, where z = 񮽙 l k 񮽙 , ∀S j ∈ S, |S j | = k, S j ⊆ {1,...,l}, and each S j is distinct 8: m = φ (n)/49: Create f (X) = d + k−1 ∑ j=1 a j X j , where ∀a j R ← Z 10: for all S α ∈ S do 11:for all j ∈ S α do 12:Calculate λ S α 0, j 13:exp ← 4 · ∆ · f ( j) · λ S α 0, j mod m 14: sh j ← sh j ∪ (i, S α , exp) 15:end for 16: end for 17: (a, b) ← ecgd(e, 4∆ 2 ), where a4∆ 2 + be = 1 18: sh i ← sh i ∪ (a mod m, b mod m) 19: return sh 1 ,.
.
.
,sh l to establish initial inter-VM SSL channels.
We assume that the VMs, and the initial set of SSL channels are provisioned securely, i.e., no adversarial attack occurs until the initial set of SSL channels are established for inter-VM communications.
This is a reasonable assumption, since (i) locating defender VMs on the cloud takes time [41], and (ii) the whole process of bootstrapping takes short time, especially if key-partitioning is performed beforehand.
Once the initial inter-VM SSL channels are established, HERMES gets ready to serve the clients.
Note that a defender VM uses the same RSA key pair for inter-VM and client connections.Finally, in HERMES, we assume that the number of VMs is fixed throughout the entire life-time of execution.
However, to augment HERMES capabilities with dynamic expansion of the system, one should care about the bootstrapping of those new VMs in terms of planting the initial secrets and initiating secure channels.
As will be clear in §4.6, during the key re-sharing process, the defender may hand in secret shares to the newly added VMs.
Still, introducing dynamic expansion via new VMs may lead to security vulnerabilities that should be investigated thoroughly.
Once the bootstrapping stage is over, a client or the defender may request connection to a defender VM (i) to consume the services offered by the defender, or (ii) to distribute new shares for the private keys.
In any case, the connection is established using server-only verified Enhanced SSL, where the connected VM takes the role of the combiner VM.Assume the client wishes to connect to V M i using Enhanced SSL.
Throughout the handshaking process, V M i interacts with the auxiliary VMs (i.e., all VMs other than V M i ), and performs distributed signing or decryption procedures as described in §4.1.
The whole distributed operations are transparent to the client, while the combiner or any auxiliary VM learns nothing, but the result.
Over time, any two defender VMs may decide to end one SSL session, and renegotiate keys for the next one.
In such a case, those two VMs use their RSA key pairs, and perform a new handshaking process using our Enhanced SSL with mutual verification.
Assume V M i and V M j decides to perform renegotiation, where V M i and V M j act as the client and server, respectively.
Both VMs execute our Enhanced SSL handshaking process using already established SSL channels with the auxiliary VMs.
When V M i or V M j needs to perform exponentiation with its private key, it collaborates with the auxiliary VMs, and calculates the result.HERMES allows only one simultaneous key renegotiation at a given time, since an on-going process necessitates already established SSL channels.
When two defender VMs start the process, it issues a warning to all VMs, blocking any other attempt for key renegotiation.
Once the on-going procedure halts, HERMES removes the warning and allows the first renegotiation attempt.
At the end of each epoch, the defender creates new shares for the same private RSA keys that were partitioned and distributed in the bootstrapping stage.
In essence, it uses the key-partitioning algorithm discussed in §4.2 and generates shares that are independent from the previous ones.
Then, it simply connects to each defender VM with our Enhanced SSL, as in §4.4, and hands in the new shares for all partitioned private keys.The reason to adhere such a process is to mitigate the risk of private key disclosure, since the adversary may have already captured a set of shares for a partitioned private key.
It is obvious that partitioning the same key for the second time will result in a different set of shares, which are totally independent from the previous.
Hence, if the adversary did not capture enough shares to identify the exact key in one epoch, it will have to start from scratch, since those captured shares mean nothing in the next We have implemented a prototype of HERMES atop the most commonly used open source SSL library, OpenSSL [10] v1.0.1e, the latest version as of this writing.
Our implementation is a separate shared library compatible with the OpenSSL's Engine API.
Without changing the OpenSSL source, programmers can plug-in our implementation and vary the way that RSA computations are performed with the private key.
Meanwhile, we have also created multi-threaded applications (i) for the auxiliary VMs to establish SSL connections with the combiner VM, and to perform mathematical operations (e.g., exponentiation with the private key share); (ii) for the defender to partition the RSA private keys and hand in the shares to each defender VM.
In this section, we present our evaluation result.
Case Studies.
As it is challenging to exhaustively test HERMES with all the network benchmarks, we evaluated our system using a micro benchmark to profile the performance, and two representative case studies, in which SSL connection is necessary.
The micro benchmark experiments evaluate the performance under varying system setups to target possible bottlenecks.
Once the system dynamics are profiled, we execute two real-life case studies and check any efficiency deficits.
One may argue that testing the web and mail servers with such low-sized content is applicable to real-world case.
It is true that almost all web sites serve contents that may have much larger sizes.
However, the purpose of the experiments is to put as much pressure as possible to HERMES in the given web and mail server case studies.
As will be clear in the results, as the number of connections performed per unit time increases, HERMES acts more efficiently due to decreased network overhead.
Hence, increasing the content sizes would increase the amount of time the server spends on processing a query, and decrease the number of requests per unit time.
Instead, we used 1 and 2KB contents, and tried pushing HERMES as much as possible.Benchmarks.
To extract micro benchmark results, we developed applications that connect to the given defender VM, using given number of concurrent clients.
For the web server application, we used two different benchmarking tools: Apache HTTP server benchmarking tool [5] (AB) v2.4.4, which allows us to send HTTPS queries with a variety of execution options; and Apache JMeter [ Hardware.
For our experiments, we created 10 VM instances on Amazon EC2.
The VM that serves that is augmented with the web and mail server applications is of the type m1.xlarge with 4 virtual CPU and 15GB of RAM.
The remaining VMs are of the type m1.small with 1 virtual CPU, 1 virtual core, 1.7GB of RAM, and 64-bit Red Hat Enterprise Linux 6.4.
The reason that we don't perform experiments with more number of VMs is that our results for 10 VMs are enough to extrapolate relations between HERMES modes, parameters (e.g., l, k, τ), and the performance metrics (e.g., average latency, throughput).
All instances are created in the same EC2 region, US-West at Oregon.
The instances communicate with each other over Amazon's private network, while a client or the defender interacts with the VMs over the public network.
On the other hand, we used a single machine to send connection, web page, or mail check queries, where the machine is an IBM x3500m3 server with 16GB of RAM, and 4 quadcore CPUs at 2.4 GHz.
Our client machine is located in our university campus, and is connected to the defender VMs over the Internet.Parameters.
We vary the number of concurrent clients from 1 to 1000 exponentially to observe the effects of increasing load on HERMES.
We believe that the number 1000 is enough, since the number of web page views for most popular web sites goes up to 37 billion per year, which is approximately 1100 per second [1,2].
Each experiment ran for 5 minutes, and the average value of 5 runs is shown as the final result.
As will be shown in the following subsection, we observe that a key re-sharing process takes approximately 50 msec.
Combined with the observation that the average time to process a query may go up to 2 sec, we vary τ (i.e., the key re-sharing period) from 5 to 125 seconds.We perform experiments using 10 VMs, and represent the setup as (l, k), where l is the number of active VMs, and k is the number of shares needed to calculate the RSA result.
When l is equal to k, the system runs with D-RSA mode of operation using l VMs.
Furthermore, (1, 1) represents the single VM setup, where the default SSL (i.e., the one without our modification and there is only one key) is used.
Also, as l must be greater than or equal to k, it is important to note that we do not have any experiment set up of (l, k) where l < k. Micro Benchmarking.
In this set of experiments, we aimed to observe the sole effects of HERMES on the performance, where the client simply connects to the combiner VM, and immediately closes the SSL channel, without sending any additional query.
Naturally, we expected to observe a massive load on the combiner VM, since all it does is to establish SSL channel with the client using our enhanced SSL, and nothing else.
Thus, the number of requests per unit time will be high, which will introduce an increased network overhead.
tleneck for D-RSA in high load, in case the combiner VM closes the connection right after a successful connection.In the results for our case studies, we observe that if the combiner has to process a request (e.g., prepare a web page, or check a mailbox) after a successful SSL connection, the network overhead decreases, which results in less average latency.As previously mentioned, we introduce T-RSA mode to reduce the overhead by simply distributing work amongst different sets of VMs.
Given the performance of 10 VMs in D-RSA mode, we check if the performance can be improved in T-RSA mode by reducing k (i.e., the number of needed VMs).
Table 2 shows the results for a fixed l = 10 and varying number of k values.
Furthermore, we perform experiments to observe the effect of increasing number of VMs for a fixed k = 2, and show the results in Table 3.
The performance metrics and the client parameters are the same as in Table 1.
It is observed that for a fixed l value, the average latency to complete an enhanced SSL connection drops down as k gets smaller, especially when k ≤ (l/2).
The reason is that different sets of auxiliary VMs are consulted to complete a single SSL connection each time, which results in less network connection overhead.
Hence, per each inter-VM connection, we observe less load, resulting up to 3 times better performance than D-RSA mode with same l value (e.g., between (10, 10) and (10, 2)).
On the other hand, it is still reasonable to pass to T-RSA, even if k > (l/2), since decreasing k has, definitely, positive effects on the performance.
For a fixed k value, increasing l by introducing new defender VMs has positive effects on the average time to complete an enhanced SSL connection, by simply reducing the inter-VM communication overhead.
of those experiments to App.
A, from which the same observations can be easily made.
We, further, measured the average time of completion for a single key re-sharing process for varying number of defender VMs.
Since, the number of connections that the defender has to do in the re-sharing process depends on l, but not on k, we performed the experiments in D-RSA mode with l number of VMs.
Table 4 shows the results, where the defender re-shares the same partitioned keys every 5 seconds, and no other client attempts to connect to the VMs.
The experiments ran for 5 minutes, and the average time to complete a single key re-sharing is calculated.
We observe that the average time increases with the number of VMs, since the defender has to connect each VM separately, incurring additional inter-VM communication overhead.
We see that the values in Table 4 coincides with the values in Table 1.
When l is equal to 10, the defender has to make 10 simultaneous connections to HERMES, resulting a similar result as 10 clients D-RSA for the setup (10,10).
In case of high load (e.g., 1000 clients), the key re-sharing process would, definitely, take longer time.
Thus, the optimal τ value for the key re-sharing epoch should be chosen while considering the server load, and the number of defender VMs.Web Server.
In our first case study, our aim is to show that the performance improves as the combiner executes a CPU intensive operation (e.g., prepare a web page) once connected to the client.
The experimental setup is the same as the micro benchmarking setup, except now the combiner VM is a web server.
When a client employs SSL to connect to the combiner VM and retrieve a web page, the combiner VM collaborates with the auxiliary VMs, and executes our enhanced SSL.
Fig. 4a and 4d show the results for HERMES in D-RSA mode, where the number of VMs changes from 1 to 10, and the number of concurrent clients changes between 1 to 1000 for τ of 125 sec.
We use AB and AJ benchmarking tools, run the experiments for 5 minutes, and report the average time needed to execute a web page retrieval request, and the number of requests per second.
We observe similar performance patterns for both of our metrics (e.g., performance decrease when l is increased) in compare to the micro benchmarks.
However, the performance difference between the two end points (i.e., between (1, 1) and (10,10)) is narrower, due to more CPUintensive processing done by the combiner.
For 1000 concurrent clients, average latency and throughput in (1, 1) is 740 msec and 255 req/sec, respectively.
On the other hand, the (10, 10) setup results in nearly 2 sec average latency, and 120 req/sec throughput.
Compared to nearly 10 times increase in the micro benchmarking results, we see that the more CPU-intensive job the server does, the closer the gap between the (1, 1) and (10, 10) setups is.Once again, we check if the performance can be boosted by passing to T-RSA mode, with decreased number of needed VMs.
Fig. 4b and 4e show the results for fixed l = 10 and τ = 125 sec.
We observe that especially when k ≤ (l/2), the overhead reduces down to nearly 10% with respect to (1, 1) setup.
For instance, in the (10, 5) setup, the average latency is 1088 ms, while the throughput is 220 req/sec.
Even better, the throughput increases to 248 in (10, 3) setup, and to 250 in (10, 2) setup, which is just 2% less than (1, 1).
The reason stems from distributing workload to more VMs by keeping seperate parts of the network busy at the same time, which reduces the inter-VM communication overhead.We remark that the results are gathered using the second slowest VM instances in Amazon EC2.
The defender can instantiate stronger VM instances, with faster network, which will definitely improve the performance, since the network latency turns out to be the bottleneck.
Furthermore, the defender can distribute the combiner role to multiple VMs to achieve further workload distribution.The next results for the web server case study are given in Fig. 4c and 4f, where we measure the performance for varying l parameter and a fixed k = 2.
We observe that having l > 2k boosts the performance.
Even in the (4, 2) setup, we measure that the average latency and throughput is 909 msec and 236 req/sec, respectively, which means less than 10% overhead for the second metric.
When the number of VMs is more than 3k, HERMES performs nearly the same as the (1, 1) setup.To show that our choice of τ = 125 sec does not have major effects on the overall performance, we vary the length of an epoch exponentially from 5 to 125 sec for different number of VMs, and fixed number of concurrent clients of 1000.
We chose to execute epoch experiments for the fastest HERMES setup, namely fixed k with high l values, and to check if performance degradation occurs for decreased key re-sharing period.
Fig. 5 shows the results for fixed k = 2 and 1000 concurrent clients, and varying τ values.
We observe that even when τ = 5 sec, the performance metrics behave similar to τ = 125 sec case.
This stems from the server being already loaded with enough concurrent clients, so that the seldom requests to re-share keys are only minor issues that does not take too much time to process.Mail Server.
Mail Server is our second case study, where the clients establish connection using SSL via IMAPS protocol, and check a mailbox that contains a single mail.
The default setting with regular SSL (i.e., (1, 1) setup) already results in an average 5758 ms latency, and 49.5 req/sec for 1000 concurrent clients.
Hence, the combiner has to do more CPU-intensive operation for each client request.
We claim that the margin between (1, 1) and (10, 10) setups will be less, since the network will be less occupied at a given time; thus, it will result in less inter-VM communication overhead.
Fig. 6 shows the results for the mail server case study, where the clients vary from 1 to 1000, and re-sharing period is 125 sec.
First of all, we observe that the performance of each setup looks very similar, with nearly at most 8% overhead with respect to (1,1 Once more, we observe that increasing the number of VMs for D-RSA mode has negative effects on the performance metrics, as shown in Fig. 6a and 6d.
On the contrary, increasing l for fixed k value in T-RSA mode enhances the overall performance, due to better distribution of the defender VMs, as seen in Fig. 6c and 6f.
The theoretical security of HERMES is based on the formally proven security of D-RSA and T-RSA, as discussed in §2.2.
Combined with key re-sharing, the adversary should successfully capture at least l shares in D-RSA or k in T-RSA to calculate the shared cryptographic key.
On the other hand, in practice, HERMES should give guarantees on the probability of a successful attack based on some assumptions on the nature of the attack and the system parameters (e.g., τ, l, k).
The defender may have limited budget, or have certain performance requirements.
In any case, HERMES must minimize any security risk by choosing l, k, and τ optimally.
In this section, we first formalize the problem of finding such optimal values for those parameters, and then apply the optimization technique to a sample configuration: the micro benchmarking scenario discussed in §5.
Our choice to apply optimization to only one configuration is due to space constraints; however, our approach is modular, and is easily applicable to any other cases.
In our formalization, we consider three main aspects: security, cost, and performance.
Security aspect allows us to provide an upper bound on the possibility of a successful key extraction attack on HERMES for the given k, l, and τ values.
Theoretically, increasing k and l, or decreasing τ will make it harder for the adversary to achieve its goal.
However, increasing l implies more defender VMs running on the cloud, which increases the total cost.
Moreover, our experiments showed that the performance degrades as l and k increase together.
Hence, the optimal values should be assigned to k, l, τ for the given constraints (e.g., budget, performance limit).
Security Aspect.
To quantify the probability of a successful attack in an epoch, we assume that the adversary has to start from scratch in each epoch, which implies that it loses all its previously acquired information.
This is a valid assumption, since shares for each epoch are independent from one another, and a captured share does not contribute any information to the next epoch.
The inability of conducting acquired information to the following epochs makes it convincing to model the probability of a successful attack as an exponentially distributed ran- (f) Avg.
Throughput for k = 2Figure 6: Mail Server results dom variable.
Given the success rate parameter θ , the probability distribution for the attack is:f (t) = 񮽙 1 θ e −t/θ if t > 0 0 otherwise (1)Since the exponential distribution is memoryless 1 and the cryptographic key is re-shared in each epoch, we can simply assume that the input to f is the time difference from the last re-sharing moment.
Then, given the length of the epoch τ, the probability of a successful attack is:F(τ, θ ) = 񮽙 τ 0 f (t).
dt = 1 − e −τ/θ (2)Finally, assuming that the probability of capturing shares from a single VM is identical to and independent from all other VMs, the probability of capturing at least k shares from l defender VMs in an epoch is:Sec(l, k, τ, θ ) = l ∑ i=k 񮽙 l i 񮽙 (1 − e −τ/θ ) i (e −τ/θ ) l−i (3)Cost Aspect.
Modeling monetary cost in HERMES is rather simple compared to the other two aspects.
Assuming that the cloud provider does not charge money for the inter-VM communications, the total monetary cost is Cost(l) = l.β , where β is the unit cost of running a single VM on the cloud provider.
The cost of communication with the client is also neglected, since this is not an additional cost incurred by HERMES.Performance Aspect.
The method to formalize the expected performance depends heavily on the application that HERMES is running for, and the metrics that the defender considers.
For instance, one may value throughput more than the latency while running HERMES.
On the other hand, the effects of changing parameters (i.e., k, l) in the mail server case study is far different than changing the same parameters in the micro benchmarking experiments.
For brevity, we show the performance of HERMES for the given k and l as Per f (l, k), and leave it to the defender to define the characteristics of the function.Optimization Problem.
Given the success rate parameter θ , the unit cost of a VM β , the budget limit L cost , and the performance limit L per f , the aim of the optimization problem is to minimize the probability of a successful attack in an epoch while keeping the total monetary cost below L cost and the performance below L per f .
Formally, the optimization problem is:minimize: Sec(l, k, τ, θ ) subject to: Cost(l) ≤ L cost , Per f (l, k) ≤ L per f l ≥ k > 1, τ > 0 Modeling performance is highly dependent on the case study and the aimed configuration, thus it is challenging to apply the optimization to every single case.
Instead, we targeted to optimize HERMES for 100 concurrent clients Table 5: Optimal setup and resulting successful attack probabilities in an epoch for fixed expected latency limit L per f = 150 msec, and θ = {600, 3600}θ = 600 θ = 3600 L cost /yr Conf.
Sec() Conf.
Sec() $in the micro benchmarking scenario, since all experiment results for the chosen configuration are given in §5.2 and App.
B. For brevity, we make a further assignment of parameters by choosing re-sharing period as τ = 5 sec and success rate parameter as θ = 3600.
τ = 5 sec is the smallest value that we have tested, and is a valid value that allows HERMES to complete several computations in each epoch.
Furthermore, choosing small re-sharing period will tighten the overall security, since the adversary has to complete the attack in a very short period.
On the other hand, choosing θ as 3600 is due to the existing cross-VM attacks (i.e., [41,51]), which necessitates hours to capture the cryptographic key.
In an exponential distribution, expected waiting time to observe one success is θ .
Since, we expect the attack to succeed in an hour, we assign θ = 3600, representing the number of seconds in an hour.
In addition, we check θ = 600 to observe changes in optimal values.In this example, we picked latency as the target performance metric to consider, assuming that the defender aimed to serve 100 concurrent clients as fast as possible.
The important step to model performance is to figure out Per f (l, k).
To overcome this, we applied multiple linear regression on our experiment results, and came up with a formula that gives the expected latency value for the given l and k values.
As it is challenging to test every possible formula, and increasing the number of variables may over-fit the training data, we chose a simple poly [50,200].
Finally, assuming that the defender will use the second cheapest VM instance on Amazon EC2, she will pay $0.104/hour, which is approximately $910/yr.
We vary the monetary budget between $1820/yr and $14560/yr to check optimal values, which is simply l ∈ [2,16].
Table 5 shows the results of the optimization procedure for varying monetary budget, and fixed L per f = 150.
The results include the optimal HERMES setup and the probability of a successful attack in one epoch, for both θ = 3600 and 600.
We observe that as we increase the monetary budget, HERMES is allowed to run with more VMs, resulting in lower probabilities of success for the adversary.
For instance, when the budget is $7280/yr and θ = 3600, HERMES can be configured to run in (8, 5) setup, while the adversary has only 2.8 · 10 −13 chance to capture the partitioned cryptographic key.
Table 6 shows similar set of results, this time for fixed monetary budget of $14560/yr, but varying expected performance limit L per f .
We deduce that as HERMES is allowed to respond slower, it can be configured to run with increased k, which decreases the attack success probability.
For instance, increasing expected latency from 50 msec to 150 msec decreases the attack success probability nearly 8 and 11 fold, when θ is 600 and 3600, respectively.
- nomial Per f (l, k) = c 0 + c 1 .
l + c 2 .
k + c 3 .
(l/k) toθ = 600 θ = 3600 L perNote that the probabilities are calculated for a successful attack in one epoch, one would question if the adversary would accomplish its goal in a longer period, say a year.
For $7280/yr and an expected latency of 150 msec in our micro benchmarking case study, the probability of capturing the complete cryptographic key in one year is 1.8 · 10 −6 if the average time to capture a key is predicted as 3600 sec, which is a very small probability.
Attacks.
There exists a myriad of side-channel attacks with different assumptions and setups.
The adversary may leverage observations made on the shared hardware to execute access driven attacks (e.g., [13,14,28,43]); measure timings of certain cryptographic operations of the defender to perform time-driven attacks (e.g., [15,19,20,34,47]); or physically observe the defender machines and run trace driven attacks (e.g., [18,26,33]).
The specific type of attacks, which HERMES aims to mitigate, is cross-VM side-channel attacks, in which both the defender and the adversary are customers to a thirdparty cloud infrastructure.
Both entities initialize VMs in the cloud, where the victim's VMs are attacked by the adversary's VMs.
Ristenpart et al. [41] showed the first cross-VM side-channel, in which they first co-reside their VMs with the defender VMs, and execute an accessdriven attack to retrieve crude information (e.g., aggregate cache usage).
In another work, though not for adversarial purposes, Zhang et al. [50] present HomeAlone that performs a co-residency check between two VMs using classifiers on cache timing.
In another attack, Zhang et al. push it one step further, and extract an ElGamal private key using cross-VM attacks [51].
Those works showed that VMs in public cloud infrastructures are vulnerable to side-channel attacks, and protection mechanisms are needed to secure private information.Prevention.
Among the variety of side-channel prevention techniques, the most popular ones are randomizationbased approaches.
MIST is one of such examples, in which the square-and-multiply method is extended with an additional division by a randomly chosen number [38,45].
Other approaches include adding random noise between squaring and multiplying operations, or applying always-multiply techniques.
To countermeasure those side-channel prevention techniques, Karlof et al. promotes Hidden Markov Model based cryptanalysis as a powerful tool [30].
On the other hand, Witteman et al. shows a trace driven side-channel attack to break down always-multiply technique and message binding in RSA [49].
Although the latter is trace driven, those two works show that even randomization based side-channel prevention approaches could have vulnerabilities that can be used by different types of adversaries.There exist several works that aim to prevent sidechannel attacks in public clouds.
HomeAlone [50] uses co-residency checks to see if a VM is physically isolated from any other VM, and to achieve maximum physical isolation.
Our work aims to prevent the leakage of private keys even if the adversary co-resides with the defender, whereas they aim to prevent access-driven side-channel attacks by assuring physical isolation.
In HyperSafe, Wang and Jiang aim to provide hypervisor integrity throughout the execution [46].
We assume that the cloud provider and its infrastructure (including the hypervisor) are trusted.
Other prevention mechanisms include [17], which aims to prevent side-channel attacks that use communication traffic; StealthMem that hides memory access patterns to protect private information [32].
Compared to these works, HERMES is applicable to any type of cross-VM attacks against cryptographic keys.
In this paper, we present HERMES, a novel system to protect cryptographic keys in cloud VMs.
The key idea is to periodically partition a cryptographic key using additive or Shamir secret sharing.
With two different case studies, we show that the overhead can be as low as 1%.
With such small overhead in an average request, cryptographic keys become more leakage-resilient against any adversary.
Furthermore, we model the problem of finding optimal parameters for the given monetary and performance constraints, which minimizes the security risk.
Using our formal model, the defender can calculate the probability of a successful attack, and take precautions (e.g., increase the number of VMs, decrease epoch length).
As a proof-ofconcept, the current implementation of HERMES mainly focuses on the protection of the RSA private key, which is widely used in many daily web site and mail server communications.
However, there exists a myriad of works on threshold signature schemes for different cryptosystems, (e.g., [21,23,27,35,36]), which may be applicable to HERMES with slight modifications.
Tables 7 and 8 show the results for the micro benchmark.
Using the secret key: For a given message M ∈ Z * n , the chosen combiner selects a subset of the parties, S = {i 1 ,.
.
.
,i k } ⊆ {1,.
.
.
,l}, where |S| = k, and sends M to each party in S. Each selected party p i j performs the following set of operations: 1.
∆ = l!
2.
λ S 0,i j = ∆ ∏ ix∈S\{i j } −i x ∏ ix∈S\{i j } (i j −i x ) 3.
w i j = M 4∆s i j λ 0,i j λ S 0,i jis the polynomial interpolation constant for p i j in set S, where ∆ f (0) ≡ ∑ i j ∈S λ S 0,i j f (i j ) mod m.
Once the combiner gets a partial result, w i j , from each party in S, it computes w = ∏ i j ∈S w i j .
Then, it executes the extended Euclidean algorithm for e and e 񮽙 = 4∆ 2 , and gets integers a and b, where e 񮽙 a + eb = gcd(e 񮽙 , e) = 1.
The greatest common divisor of e and e 񮽙 is 1, since e is a prime number, and each factor of e 񮽙 is smaller than e. Finally, the combiner computes y = w a M b as the final result.The final value y is in fact M d mod n:w ≡ ∏ We thank the anonymous reviewers for their insightful comments.
This work was partially supported by Air Force Office of Scientific Research FA9550-12-1-0082 and FA9550-14-1-0119, National Institutes of Health Grants 1R0-1LM009989 and 1R01HG006844, National Science Foundation (NSF) Grants Career-CNS-0845803, CNS-0964350, CNS-1016343, CNS-1111529, CNS-1228198 and Army Research Office Grant W911NF-12-1-0558.
