Modern operating systems run multiple interpreters in the kernel, which enable user-space applications to add new functionality or specialize system policies.
The correct-ness of such interpreters is critical to the overall system security: bugs in interpreters could allow adversaries to compromise user-space applications and even the kernel.
Jitk is a new infrastructure for building in-kernel interpreters that guarantee functional correctness as they compile user-space policies down to native instructions for execution in the kernel.
To demonstrate Jitk, we implement two interpreters in the Linux kernel, BPF and INET-DIAG, which are used for network and system call filtering and socket monitoring, respectively.
To help application developers write correct filters, we introduce a high-level rule language, along with a proof that Jitk correctly translates high-level rules all the way to native machine code, and demonstrate that this language can be integrated into OpenSSH with tens of lines of code.
We built a prototype of Jitk on top of the CompCert verified compiler and integrated it into the Linux kernel.
Experimental results show that Jitk is practical, fast, and trustworthy.
Many operating systems allow user-space applications to customize and extend the kernel by downloading userspecified code into the kernel [1,24].
One well-known example is the BSD Packet Filter (BPF) architecture [48].
With BPF, applications specify which packets they are interested in by downloading a filter program into the kernel that decides whether a packet should be dropped or forwarded to the application.
For portability and safety, the kernel usually defines a simple, restricted language, and uses an interpreter to execute code written in that language (e.g., BPF), rather than directly downloading and executing machine code.
Other notable applications of in-kernel interpreters include socket monitoring [40], dynamic tracing [7], power management [32], and system call filtering [20].
Interpreters are also used outside of kernels, such as in Bitcoin's transaction scripting [2].
As an example, consider the Seccomp subsystem [20] in the Linux kernel, which adopts the BPF language to specify what system calls a process can make.
Seccomp's overall architecture is shown in Figure 1.
At start-up, an application such as OpenSSH submits a BPF filter into [20] in Linux.
Application developers specify their system call policy as a BPF filter (e.g., Figure 2), in bytecode form.
At start-up, the user-space application submits the filter to the kernel.
The kernel invokes a BPF interpreter to evaluate the program against each subsequent system call, and decides whether to allow or reject it based on the result from the interpreter.; load syscall number ld [0] ; deny open() with errno = EACCES jeq #SYS_open, L1, L2 L1: ret #RET_ERRNO|#EACCES ; allow getpid() L2: jeq #SYS_getpid, L3, L4 L3: ret #RET_ALLOW ; allow gettimeofday() L4: jeq #SYS_gettimeofday, L5, L6 L5: ret #RET_ALLOW L6: ...; default: kill current process ret #RET_KILL Figure 2: The system call filter used in OpenSSH, in the BSD Packet Filter (BPF) language [48].
It forces the open system call to fail with the errno code EACCES, allows system calls such as getpid and gettimeofday, and kills the current process if it invokes other system calls.
The ld instruction loads the current system call number into the accumulator register; jeq n, l t , l f is a conditional jump instruction that branches to l t if the accumulator register is n, and otherwise branches to l f ; and ret terminates the filter with a return value.the kernel.
The kernel invokes the BPF interpreter to run the filter code against every subsequent system call.
Based on the result from the interpreter, the kernel decides whether to reject or allow a system call, or kill the process altogether.
Figure 2 shows the system call filter used by OpenSSH, written in the BPF language [48].
Even if an adversary later compromises the OpenSSH process, she cannot perform damaging actions, such as modifying files, as the kernel would fail the corresponding system calls, which are disallowed by the installed filter.
Many other applications, such as QEMU, Chrome, Firefox, vsftpd, and Tor, secure themselves in a similar fashion.such as "allow the gettimeofday system call" or "reject the open system call with EACCES."
As an example, Fig- ure 3 shows the SCPL rules that capture the BPF filter used by OpenSSH shown in Figure 2.
The hope is that it is less likely for developers to make mistakes in SCPL rules than in manually written BPF filters.
Jitk implements a SCPL-to-BPF compiler and a functional correctness proof from these high-level policies to native code.
The code and proof of Jitk were developed using the Coq proof assistant on top of the CompCert framework [42].
We integrated Jitk with the Linux kernel, as a drop-in replacement of its existing Seccomp subsystem.
Applications like OpenSSH can run on our system without modifications, with the guarantee of the absence of interpreter bugs described in §3.
Overall, the contributions of this paper are as follows:• The Jitk infrastructure and approach for building verified in-kernel JIT interpreters.
• A case study of real-world vulnerabilities found in BPF interpreters in several operating systems.
• A formalization of correctness and safety goals for executing user-specified policies in the kernel.
• The Jitk/BPF and Jitk/INET-DIAG verified JITs along with the formal specifications of both languages.
• The SCPL high-level language for specifying system call policy rules, along with a proof of correctness for an SCPL-to-BPF compiler.
• An evaluation of how well Jitk's formal verification prevents the vulnerabilities that have been discovered in bytecode interpreters in real-world kernels.The rest of the paper is organized as follows.
§2 discusses previous related work.
§3 presents background information on the kinds of bugs that arise in in-kernel interpreters such as BPF.
§4 provides an overview of Jitk's architecture and goals.
§5 describes the design and proof.
§6 discusses the limitations of Jitk's approach.
§7 presents our prototype implementations of Jitk as applied in Seccomp and INET-DIAG in the Linux kernel.
§8 evaluates Jitk's security and performance.
§9 concludes.
Pioneering work such as seL4 [38,54], CompCert [42], MinVisor [49], VCC [41], and Myreen's x86 JIT compiler [50] showed the promise of formal verification for building trustworthy, critical software systems, including OS kernels, compilers, and hypervisors.
Jitk demonstrates how to apply formal techniques to building systems that download and execute untrusted code in a commodity kernel.
Jitk leverages CompCert's compiler infrastructure and machine code semantics; alternatively, Jitk could be built on the Bedrock library [12,13].
There is a rich literature of securing and isolating faulty kernel extension through OS design, such as microkernels [18,23,31,55] and exokernels [24,34]; through the use of type-safe languages, such as SPIN (Modula-3) [1], Singularity (C#) [33], and Mirage (OCaml) [45]; through software-based fault isolation [58], such as BGI [9], LXFI [46], XFI [25], VINO [53], and SVA [17]; and through proof-carrying code [52].
These techniques focus on memory safety and kernel integrity, by isolating user-specified code from the rest of the kernel, but cannot guarantee functional correctness of the downloaded code.Testing tools such as EXE [5], KLEE [6], and the Trinity syscall fuzzer [36] are useful for finding bugs in kernel code, and have even been applied to BPF interpreters, but they cannot guarantee bug-free code.
§3 extends Chen et al.'s earlier survey [10] with a case study of a wider range of in-kernel interpreter bugs, and the rest of the paper presents the design and implementation of Jitk that guarantees the absence of these bugs.Our experience with Jitk suggests that it is feasible to build formally verified JITs in the kernel, on the basis of CompCert.
Using a verified compiler like CompCert provides stronger assurance guarantees than some of the alternative proposals, such as integrating the LLVM infrastructure into the kernel [11].
Enforcing a policy in Seccomp, such as the one shown in Figure 2, involves several steps: programmers express the policy to a user-space application, which submits the policy to the kernel, which in turn relays it to an interpreter, which then either purely interprets it or compiles it to machine code for faster execution.
This section summarizes representative bugs at each of these steps, using BPF as an example, and discusses the challenges of achieving correctness in this chain.
Note that these bugs are general and not BPF-specific; they have appeared in other interpreters as well [10].
BPF is a general-purpose virtual machine, consisting of:• a 32-bit accumulator A,• a 32-bit index register X,• a scratch memory M for temporary storage (e.g., 64 bytes in the Linux kernel),• an input packet P (the data blob for inspection), and• an implicit program counter pc.
system call number architecture instruction pointer 1st system call argument ...Opcode Operands Description ld [k] A ← P[k, .
.
, k + 3] ja #k pc ← pc + k jeq #k, jt, jf pc ← pc + (A = k) ?
jt : jf div #k A← A / k ret #k return k Figure 6: Input to system call filters in the Linux kernel [20], a 64-byte (512-bit) packet.
It consists of the current system call number, the architecture, the instruction pointer, and up to six system call arguments.A BPF filter is a sequence of BPF instructions, each of which has a fixed length of 8 bytes, as shown in Figure 4.
It can read the input packet P, transfer data among the two registers (A and X) and the scratch memory M, perform arithmetic operations, and terminate with a 32-bit integer return value, which instructs the kernel to take further actions.
Figure 5 shows examples of BPF instructions used in this paper; see the original BPF paper for a more complete list [48].
The BPF virtual machine has been successfully applied in different contexts.
Its original purpose is to inspect network packets, with the return value indicating the number of bytes to accept.
Its applications have gone beyond that [3,16,20].
For example, the Seccomp system in the Linux kernel uses BPF for system call filtering: the kernel prepares a 64-byte input packet storing the current system call arguments, as shown in Figure 6, and the return value indicates whether the kernel should fail this system call.A well-defined BPF filter must end with a ret instruction; it can jump only forward; and it cannot perform illegal operations such as division by zero, out-of-bounds memory access, or jumping to non-existent instructions.
Bugs can arise if an interpreter fails to reject illegal BPF filters, as we will show next.
The complex logic for executing BPF filters happens in kernel-space, where bugs can be disastrous for security.
Figure 7 lists common errors that have appeared in existing BPF interpreters in Linux and BSD kernels, as detailed next.
Kernel: control-flow errors ( §3.
[19]: given a large k, pc + k will wrap around to a smaller value and bypass the check.
JIT interpreters need to correctly translate the control flow of a BPF filter to machine code, which is both delicate and intricate; even a tiny typo can open a new door for kernel exploits.
As an example, Figure 8 shows an offby-one bug in the x86 JIT in the Linux kernel: for a BPF conditional jump, the interpreter emits an x86 conditional jump instruction (for the true case), followed by an unconditional jmp rel32 (for the false case), which is 5 bytes; the interpreter mistakes it as 6 bytes, and increases the offset of the conditional jump instruction by that wrong value.
Consequently, the conditional jump instruction will go one byte past the target instruction, which can be an arbitrary payload controlled by an adversary [39].
[29].
The code uses the wrong mask 0x18, and thus fails to reject BPF code that performs division by zero, which may lead to a kernel crash.
/* A / k → reciprocal_divide(A, R) precompute R = ((1LL << 32) + (k -1)) / k */ u32 reciprocal_divide(u32 A, u32 R) {return (u32)(((u64)A * R) >> 32); } Figure 11: Incorrect reciprocal multiplication optimization [21].
With this optimization A/1 always produces zero, rather than A.
The Linux kernel later disabled this optimization for BPF.
Figure 9 shows another example from BSD kernels: the interpreter needs to limit the jump offset k within the filter code, by checking if pc + k exceeds the total length; otherwise an adversary can trick the kernel into executing illegal instructions.
However, the interpreter misses the case where a large jump offset overflows pc + k and bypasses the check.
One infamous type of arithmetic errors is division by zero, which can crash the kernel if the interpreter fails to reject it.
Figure 10 shows a bug where the interpreter tries to avoid that case, but performs the wrong check.
Particularly, for BPF instructions A/k and A/X, one can observe their encoding difference by masking the opcode with 0x08; the interpreter uses the wrong mask and fails to detect the case when k is zero.
/* BUG: k + sizeof(int32_t) can overflow */ if (k + sizeof(int32_t) > buflen) return 0; A = EXTRACT_LONG(&p[k]);Figure 12: Incorrect bounds check [51], which a large k can bypass since it overflows k + sizeof(int32_t) to a smaller value.
A correct check is k > buflen || sizeof(int32_t) > buflen -k.Optimizing arithmetic operations further complicates the situation.
Figure 11 shows a bug in Linux's BPF JIT, which tries to optimize a division by a constant into a multiplication and a shift.
This optimization, also used in the slab memory allocator, works well with input in that particular context (e.g., cache size as the divisor).
However, this optimization is incorrect in general; for example, 65536/65537 should produce zero, but with the optimization the result becomes one.
The Linux kernel has disabled this optimization for BPF [21].
An interpreter has access to two memory regions, the input packet P and the scratch memory M.
It needs to correctly check the offsets of load and store instructions for both regions and reject illegal ones, which would otherwise trick the kernel into reading from or writing to memory that is out of range.
The interpreter can easily miss such checks for some instructions [27], or more subtly, perform insufficient checks.
Figure 12 shows an incorrect bounds check for ld [k], where an adversary can use a large k to overflow and bypass the check, leading to illegal access beyond the input packet P.
Since each BPF filter returns a 32-bit integer to user space, an interpreter needs to ensure that the return value is derived only from the input packet.
In other words, it must not leak sensitive information from other processes nor the kernel.
Several interpreters, including those in iOS (CVE-2012-3729) and Linux (CVE-2010-4158), allowed BPF filters to access uninitialized scratch memory M [30] or registers A and X [56], which could hold sensitive values from previous use.
The interpreters fixed this vulnerability either by filling M, A, and X with zeros before execution, or by rejecting BPF filters that try to read these values before writing to them.
The logic at the kernel-user interface is straightforward: a user-space application encodes a BPF filter in bytecode format, as shown in Figure 4, and submits it to the kernel; the kernel decodes the bytecode and reconstructs the filter.
Interestingly, there is still a possibility for programming mistakes such as copy-paste bugs [44]: for example, the Linux kernel once confused BPF_W with BPF_B for BPF bytecode encoding [4].
It is tedious and error-prone to directly write BPF filters like Figure 2; for example, it requires programmers to correctly specify relative jump offsets.
Many programmers instead express their policies through domain-specific tools or libraries, which provide a high-level interface for constructing filters.
For example, invoking tcpdump with "tcp dst port 80" produces a 128-byte network filter for finding TCP packets sent to port 80.
Applications like QEMU use the libseccomp library [22] to simplify the task of generating system call filters.
These tools and libraries can submit incorrect filters to the kernel due to bugs in translating domain-specific policies into BPF filters [35], or when they try to optimize resulting filters [26].
Running user-specified code in the kernel offers flexibility and extensibility, at the price of a more vulnerable system.
Achieving correctness and safety in an in-kernel interpreter is challenging: programmers can easily miss validating input for certain corner cases, or generate wrong code that is hard to notice.
Many of these bugs have serious security impacts, as we have shown in Figure 7.
In the next section, we will describe how to apply formal verification techniques to building Jitk, which is safe, fast, and immune to these bugs.
This section provides an overview of Jitk and its goals of correctly translating high-level, human-comprehensible policies to low-level native code for safe in-kernel execution.
We describe Jitk in the context of the Seccomp system in Linux using the Jitk/BPF JIT, though the approach is general and not limited to BPF.
Figure 13 shows the architecture of Jitk/BPF.
In contrast with the current Seccomp subsystem shown in Figure 1, there are three important differences.
System Call Policy Language (SCPL).
Rather than manually writing BPF code, application developers can choose to specify system call policies using a high-level SCPL, which is more intuitive and helps programmers avoid mistakes in their policies.
In steps 1 and 2, invoking the SCPL compiler on a SCPL program produces a corresponding BPF filter.
As an example, Figure 3 shows the SCPL rules that capture the BPF filter used by OpenSSH shown in Figure 2, and our SCPL compiler will produce the latter from the former.
Note that these two steps are optional; applications can still directly submit BPF bytecode to the kernel.
JIT interpreter with a shared backend.
In Jitk when the kernel accepts BPF bytecode from user space, a JIT translates the BPF filter into native code (steps 3 and 4).
This native code is then executed for each system call to decide whether to allow that system call (steps 5 and 6).
This JIT approach helps avoid the overhead of invoking the interpreter on each system call invocation.
Jitk includes a compiler backend reused from CompCert, which is independent of BPF and can be shared among different interpreters.
Our prototype implementation runs part of the JIT as a trusted user-space process (see §7).
Formal verification.
The SCPL compiler and the BPF JIT are formally proven to be correct, as detailed next.
Jitk has two overall goals for enforcing user-specified policies in the kernel.
First, well-behaved applications should be able to properly execute their filters in the kernel.
That is, if an application developer writes down a set of SCPL rules, those rules should be correctly enforced by the kernel.
We will call this the correctness goal.
Second, it should be impossible for an adversary to misuse Jitk to "break" the kernel in any way.
We will call this the safety goal.
Jitk formalizes these goals in the form of a set of theorems and lemmas, as we will now discuss.
The overall correctness goal required by an application that uses system call filtering is captured by the following end-to-end theorem:Theorem 1 (End-to-end correctness).
For any system call policy p written in SCPL, if Jitk accepts it, the overall system enforces the semantics of p.To enforce a system call policy in the kernel, Jitk needs to translate SCPL rules into BPF instructions, transmit BPF instructions from user space to the kernel, and translate BPF instructions into native code for execution in the kernel.
To achieve Theorem 1, Jitk proves three lemmas that reflect this workflow.First, the SCPL compiler must preserve the semantics of SCPL rules when generating BPF instructions:Lemma 2 (SCPL-to-BPF semantic preservation).
Given a system call policy p written in SCPL, if the SCPL compiler translates it into a BPF filter f , f preserves the semantics of p:∀p : SCPLc(p) = OK f =⇒ p ≈ f.Here OK means the translation is successful; ≈ denotes semantic preservation.Second, a filter must be transmitted correctly from user space to the kernel.
To cross the user-kernel boundary, the filter is encoded from the in-memory representation into a byte-level representation as shown in Figure 4, submitted to the kernel through a system call (e.g., prctl in Linux [20]), and then decoded back into the in-memory representation by the kernel's BPF JIT.
The reconstructed filter in the kernel must be the same as its user-space counterpart:Lemma 3 (User-kernel representation equivalence).
If a BPF filter f is encoded into bytes in user space and the bytes are decoded back to a BPF filter in kernel space, f is preserved.
∀ f : encode( f ) = OK b =⇒ decode(b) = OK f.Finally, when the JIT translates BPF instructions into native code in the kernel, the native code must preserve the semantics of the BPF instructions:Lemma 4 (BPF-to-native semantic preservation).
Given a BPF filter f , if the JIT accepts it and generates native code n, n preserves the semantics of f .
∀ f : jit( f ) = OK n =⇒ f ≈ n.Jitk achieves this by first translating BPF to Cminor, an intermediate language in CompCert [42].
Jitk proves the correctness of the BPF-to-Cminor translation, and reuses Cminor-to-native from CompCert.
See §5.1.2 for details.Taken together, Lemmas 2 through 4 imply Theorem 1.
The safety concern is that an arbitrary user-space application should not be able to misuse Jitk to monopolize CPU time or to corrupt the kernel's memory.
Particularly, both native code generated by the BPF JIT and the JIT itself must be safe for in-kernel execution.
Although Theorem 1 (in particular Lemma 4) guarantees the correctness of native code with respect to given SCPL rules, it provides no guarantees that the generated native code will not cause an infinite loop or a stack overflow.
The safety goal is captured by the following two theorems, which describe the temporal and spatial requirements of in-kernel execution, respectively.Theorem 5 (Termination).
Given any BPF filter f , if the JIT accepts it and generates native code n, then n terminates.
∀ f : jit( f ) = OK n =⇒ terminate(n).
Theorem 5 says if the JIT accepts an input BPF filter, the resulting native code must terminate, that is, the native code must come to a halt within a finite number of steps.
We believe that termination is an appealing property for safety: it guarantees a bounded CPU time (i.e., no infinite loops), and no undefined behavior in the native code (e.g., no out-of-bounds memory access nor division by zero), with which the execution will get stuck.Let S be a predefined parameter of the JIT, which indicates the maximum number of bytes that native code generated by the JIT can safely allocate and consume from the kernel stack.Theorem 6 (Bounded stack usage).
Given any BPF filter f , if the JIT accepts it and generates native code n, n uses at most S bytes of stack.
∀ f : jit( f ) = OK n =⇒ any run of n uses at most S bytes of stack space.Theorem 6 says that if the JIT accepts an input BPF filter, the resulting native code must never overflow the kernel stack.The safety of the BPF JIT itself is guaranteed by Coq.
The JIT is written in Coq (see §4.3); all Coq programs are guaranteed to provide memory safety, and are guaranteed to terminate, as it is impossible to write infinite loops in Coq's Gallina language [14: §7].
To build a trustworthy in-kernel interpreter in Jitk, developers need to prove that an implementation satisfies the correctness and safety goals as formalized in §4.2.
The development workflow is shown in Figure 14.
In particular, the JIT, the encoder-decoder from user space to kernel, and the SCPL compiler are all written in Coq.
For each component, Jitk's Coq source code consists of three major parts: the specification, the implementation, and the proof that the implementation matches the specification.
This source code is used in two ways.
First, the Coq proof checker verifies that the proof is correct.
Second, Coq transforms the implementation into OCaml.
The generated OCaml code is compiled, together with a small I/O stub that performs I/O and invokes the generated code, into a native executable.
This section focuses on how the design and proofs help Jitk achieve its correctness and safety goals.
Figure 15 shows Jitk's detailed workflow and components, including the in-kernel JIT ( §5.1), the high-level SCPL in user space ( §5.2), the encoding-decoding across the two spaces ( §5.3), and the integration of Jitk with Linux ( §5.4).
For each component, we will describe the specification, the implementation, and the proof.
A correct BPF JIT implementation should satisfy BPFto-native semantic preservation (Lemma 4), termination (Theorem 5), and bounded stack usage (Theorem 6).
To achieve these goals, we will start with the formal semantics of BPF ( §5.1.1), and describe the design of the three key components: the translator ( §5.1.2), which is responsible for transforming a BPF filter into native code, the checker ( §5.1.3), which is responsible for making sure that all input filters are well-defined before being sent to the translator, and the validator ( §5.1.4), which is responsible for ensuring bounded stack usage for output assembly code.
The specification of BPF consists of the syntax of instructions, the states, and the semantics, which is a set of state transitions among the states.
The syntax mirrors the description in §3.1, which is omitted here.
During execution, a BPF filter is in one of the following three states:• initial state: a pair of current filter f and input packet P, denoted as (Initialstate f P); • running state: a 6-tuple of registers A and X, scratch memory M, program counter pc, as well as f and P, denoted as (State A X M pc f P); and• final state: a return value v, denoted as (Finalstate v).
A well-defined filter starts from the initial state, transitions through a set of running states, and halts in the final state.
The first state transition is:(Initialstate f P) → (State 0 0 (list_repeat N 0) f f P) (5.1)This says that at start-up, A and X are set to zero, M is initialized as N zeros, and pc is set to the start of the filter f .
The core part of the semantics is transitions between two running states after executing an instruction other than ret.
For example, the BPF instruction "add k" increases the value of register A by k, and the corresponding transition is:(State A X M (add k :: pc ′ ) f P) → (State (Int.add A k) X M pc ′ f P)Here add k :: pc ′ means that the current instruction to be executed is add k and the next program counter is pc ′ ; Int.add is a 32-bit integer addition from CompCert.
The specification says that after executing add k, the program transitions to a state with updated values of A and pc.A more interesting example is a transition with a precondition.
Below is the transition for BPF's unconditional jump instruction ja k:k < length pc ′ =⇒ (State A X M (ja k :: pc ′ ) f P) → (State A X M (skipn k pc ′ ) f P)Here length returns the number of instructions remaining and skipn drops a given number of instructions.
The specification says if k is less than the number of instructions remaining, then ja skips k instructions.
Note that the specification says nothing about a too-large k with which ja could jump past the end of the filter.
Therefore, such a filter is undefined, which a safe implementation like Jitk must reject.The last state transition is to enter the final state with the return value k after executing ret k:(State A X M (ret k :: pc ′ ) f P) → (Finalstate k) The translator compiles a well-defined BPF filter (which passed the checker, as we will describe in §5.1.3) into native code.
Our goal is to have an implementation with its correctness proof, as stated in Lemma 4.
The key challenge of designing the translator is to choose an appropriate target language, which strikes a balance between the complexity of the implementation and the proof.One approach is to directly produce low-level code such as x86 instructions from BPF, just like the existing JIT implementations in Linux and BSD kernels.
The main downside of this approach, which we initially adopted, is that the big semantic gap between BPF and x86 makes it difficult to reason about the correspondence and prove properties about the target code.
For example, consider translating BPF's unconditional jump ja k into x86's jmp n, where k and n are jump offsets in the corresponding languages.
It is tricky to compute n (see §3.2.1); meanwhile, it is difficult to prove why n is the correct value that corresponds to k.Jitk's translator targets Cminor, one of CompCert's intermediate languages [42].
Cminor can be considered as an architecture-independent, simple C variant: it has only primitive types such as n-bit integers, and no pointer or struct types.
The main advantage of targeting Cminor is that it retains high-level constructs, which simplifies the proof.
For example, Cminor has labels and variables, with which one does not have to reason about low-level details such as jump offsets or the stack pointer.To prove correctness of the translator, we prove that it satisfies the following property:Lemma 7 (BPF-to-Cminor semantic preservation).
If the JIT translator generates Cminor code c from a BPF filter f , c preserves the semantics of f .
∀ f : jit translator ( f ) = OK c =⇒ f ≈ c.The main technique for proving Lemma 7 is by simulation [43], as used throughout CompCert.
Specifically, it suffices to show that each state transition in the BPF specification shown in §5.1.1 corresponds to some state transitions in the Cminor specification during translation.
We omit the details.A second advantage of targeting Cminor is that Jitk can reuse CompCert to transform Cminor code into native assembly.
CompCert currently has support for x86, ARM, and PowerPC, for which it comes with its own semantic preservation theorem:Lemma 8 (Cminor-to-native semantic preservation).
If CompCert generates native code n from a Cminor program c, n preserves the semantics of c.∀c : compcert(c) = OK n =⇒ c ≈ n.Together, Lemmas 7 and 8 imply our correctness goal, Lemma 4.
Finally, in order to transform the assembly code into native binary code, Jitk invokes a traditional assembler; CompCert does not include a provably correct assembler.
Recall that Lemma 4 guarantees BPF-to-native semantic preservation: if an input filter terminates, the resulting native code produced by the translator also terminates.
Therefore, to achieve the termination goal as stated in Theorem 5, it suffices to implement a checker that rejects all undefined input and ensures that any surviving filter terminates.For BPF, this amounts to the following requirements: that all jump targets are forward (i.e., no loops), that all jump targets are in-bounds (i.e., not pointing past the end of the program), that all memory accesses are inbounds (i.e., not reading or writing past the end of the input packet and the scratch memory), and that the input ends in a ret instruction.
The combination of these rules ensures that every program that passes the checker will be well-defined, and will terminate with some return value according to BPF semantics.We prove that the implementation of the checker satisfies the following property:Lemma 9 (BPF termination).
If the JIT checker accepts a BPF filter f , then f terminates.
∀ f : jit checker ( f ) = OK f =⇒ terminate( f ).
Combining this with Lemma 4 gives our safety goal of termination, Theorem 5.
Note that it is impossible to miss any undefined cases in the implementation of the checker, otherwise the proof of Lemma 9 would not succeed.
CompCert does not provide facilities for reasoning about stack bounds across transformations.
In order to prove Theorem 6, one option is to extend CompCert with proposed support for tracking stack bounds [8], which would allow Jitk to prove a theorem about it.Jitk adopts a simpler approach using the validator.
As for BPF, there is only one function with a fixed number of variables and a fixed-size object (scratch memory) on the stack.
The validator inspects the size in the stack frame allocation instruction at function entry in the resulting assembly code, and fails the JIT if the size is larger than a predefined S .
It is then easy to prove Theorem 6, as any generated assembly code that passes the validator uses at most S bytes from the stack space.
The design of our SCPL is inspired by the libseccomp API [22]; the key difference is that the SCPL compiler is provably correct.
As shown in Figure 3, developers specify rules for matching different system calls (and optionally system call arguments), along with actions to take when those rules match (e.g., allow the system call, or reject it with a particular errno value).
There is also a default action, if none of the rules match.
The formal specification of SCPL is similar to BPF described in §5.1.1: the syntax, the states, and the state transitions.
The proof of SCPL-to-BPF correctness is also similar to BPF-to-Cminor.
We omit the details here.
To ensure that BPF programs are faithfully encoded and decoded when transmitted across the user-kernel space boundary, Jitk implements an encoder and decoder, which transforms an in-memory representation of a BPF program into BPF bytecode, and back into an in-memory representation.One option for proving the correctness of the BPF encoder and decoder would be to define semantics for BPF bytecode, as defined by byte-level sequences, and to prove equivalence between the in-memory representation (under the semantics of in-memory BPF programs) and the bytelevel representation (under the semantics of byte-level encodings).
However, this approach is quite cumbersome, owing to the complexity of defining the semantics of BPF programs at the low level of byte encodings.Instead, Jitk takes a pragmatic alternative: it proves that the decoder is the inverse of the encoder (Lemma 3).
When used in combination with SCPL, this guarantees that SCPL-generated BPF bytecode will necessarily be decoded correctly by the Jitk/BPF JIT in the kernel.
It does not guarantee that the encoder and decoder implemented by Jitk are compatible with any other encoding (e.g., the encoding produced by libseccomp).
In practice, we believe this is not a significant problem, because the specification of the correct encoding and decoding would be of similar complexity to our current Coq encoder/decoder implementation, and our theorem (Lemma 3) provides a strong sanity check on the internal consistency of our encoder and decoder.
The Linux kernel interacts with Jitk in two ways.
The first is when an application submits a BPF filter to Seccomp through the prctl system call [20]: we modified the kernel to invoke Jitk's BPF JIT.
The JIT translates the filter into native code; if the translation fails, indicating that the BPF filter code was not well-formed, the prctl system call returns an error.The second is when an application makes a subsequent system call: we modified the kernel to check if there is already a JIT-compiled filter associated with the process; if so, the kernel treats the filter as a function pointer, invoking it with a single argument (the structure containing the system call number and arguments, shown in Figure 6).
1 The return value determines the resulting action for this system call, much as with the existing Seccomp design.
There are some mistakes that Jitk's theorems cannot prevent.
First, if the specifications of BPF and SCPL are buggy, then Jitk's JIT implementations can have bugs.Another example is an overly strict checker, such as NetBSD #37663 [28], which rejected any BPF program that used the multiply instruction.
Such an implementation does not violate either correctness or safety goals, since all of our theorems are conditional on our system accepting a given program.
It would be possible to prove an additional theorem that required Jitk/BPF to accept certain programs; one good candidate would be a requirement that Jitk/BPF accept all BPF programs generated by the SCPL compiler.Jitk's theorems also cannot prevent the use of Jitk's JIT for JIT spraying [47], which can make it easier to exploit memory corruption vulnerabilities in the rest of the Linux kernel.
Given a formal set of requirements for a JIT to mitigate the effects of JIT spraying (e.g., ensuring that a constant in the input bytecode does not appear in the output code), it may be possible to prove that Jitk correctly implements such mitigation techniques.Jitk's encoder/decoder can have self-consistent mistakes, in that the encoder and decoder are consistent with each other (satisfying Lemma 3), but do not match the encoding used by others for the same bytecode.
We believe it is unlikely for the reasons discussed in §5.3.
Finally, Jitk assumes several additional parts are correct without a formal proof.
First, the Coq proof checker is assumed to be correct.
While bugs have been found in Coq, we believe Coq provides a strong degree of assurance that Jitk is trustworthy.
The Coq extraction system and the OCaml compiler and runtime are also assumed to be correct.
We believe this is reasonable because Coq itself is written in OCaml.
That said, bugs in Coq's extraction system have been found in the past [57,59].
Jitk's OCaml I/O stub has no proof of correctness.
It is about 70 lines of code, and performs simple operations: taking input from stdin, passing it into the Coq-extracted code, and printing the results to stdout.The rest of the kernel code, including the wrapper that invokes the Jitk JIT and that invokes the filter code produced by the JIT, is assumed to be correct.
Particularly, Jitk assumes that the kernel does not trample on the JIT itself, that the kernel correctly interprets the results from the JIT and the filter, and that the kernel synthesizes an correct input packet to the filter, namely, a single pointer argument pointing to a valid memory region whose size matches the structure shown in Figure 6.
Jitk also assumes that the kernel invokes the JITcompiled code with an appropriate calling convention.
For example, on x86 the JIT-compiled code assumes that the input argument is passed on the stack, as CompCert's x86 backend uses the cdecl calling convention; however, the Linux kernel uses fastcall by default (e.g., with gcc's -mregparm=3), which passes the input argument in the EAX register.
We bridged the gap using a function wrapper.Finally, Jitk assumes that CompCert generates correct assembly code for the filter, which is a single-argument function.
One technical complication is that CompCert's semantics are defined only for complete programs that take no arguments.
This precludes even well-formed C programs with a main function that takes two arguments, argc and argv, for which theoretically CompCert provides no guarantees.
We believe this is not a likely source of bugs in practice.
We have implemented a fully functional prototype of Jitk for Linux's BPF-based Seccomp system.
The breakdown of our Jitk/BPF prototype (excluding the components borrowed from CompCert) in terms of lines of code is shown in Figure 16.
As mentioned in §4.3, the BPF JIT is written in Coq.
We extracted the Coq implementation into OCaml code, and linked it into an executable, together with the I/O stub and the OCaml runtime.
In order to run this executable for translating BPF bytecode into native binary code, we chose to put it in user space and modified the kernel to perform an upcall, using Linux's call_usermodehelper interface.
Putting the executable with the OCaml runtime into the kernel would be doable, as demonstrated by the Mirage unikernel [45], but would unnecessarily complicate our implementation.
Trusting a user-mode process running as root to produce native binary code for running in the kernel seems reasonable, given that root processes can also load arbitrary kernel modules.Jitk supports generating x86, ARM, and PowerPC code, as CompCert provides the corresponding backends.
Jitk does not support architectures that CompCert lacks, such as x86-64.
Like CompCert, Jitk relies on a conventional (not proven correct) assembler to convert textual assembly code into a native binary.
Jitk uses the GNU assembler as for this purpose, and disables assembler-level optimizations (using the -n option) out of precaution.
In our evaluation, we aim to answer five questions:• How much effort does it take to build Jitk?
( §8.1)• Does formal verification prevent the kinds of bugs that arise in practice?
( §8.2)• Does Jitk's JIT produce efficient filter code?
( §8.3)• How much effort is required to use SCPL?
( §8.4)• What is the end-to-end performance of Jitk?
( §8.5) The total effort to build Jitk for Seccomp was shown in Figure 16.
Much of the effort went into constructing proofs.
The 2,300 lines of Coq proof code consist of 650 lines of general helpers (the crush tactic from CPDT [14] and miscellaneous lemmas about linked lists and arithmetic), 950 lines of refinement proof (that the BPF JIT preserves semantics), 350 lines of termination proof (that programs that pass the checker are well-defined), 150 lines of encoding proof (that decoding is the inverse of encoding), and 250 lines of proof for the SCPL compiler.To determine if this approach can be applied to another bytecode language, we implemented a JIT for the INET-DIAG interpreter from the Linux kernel.
INET-DIAG has a simpler bytecode language, and the code and proof sizes were correspondingly smaller, totaling 1,590 lines of code.
Overall, we believe this indicates Jitk is a practical approach for building trustworthy in-kernel interpreters.
To evaluate whether Jitk's formal verification does a good job of preventing bugs that arise in practice, we perform an analysis of the bugs that have been found in interpreters so far (Figure 7), and manually determine whether such a bug could have been present in an implementation that provably satisfies Jitk's theorems.
Our results show that Jitk is effective at preventing these bugs.Control-flow errors.
The control flow errors described in §3.2.1, such as misaligned jump targets and overflow in computing the jump offset, cannot occur in Jitk, since Lemma 4 guarantees that all jumps in native code preserve the semantics.
It is also impossible to "run off the end" of generated native code, since Theorem 5 guarantees that every BPF program that passes the checker must terminate.
We found and fixed several off-by-one jump errors in our implementation while proving Lemma 7.
Arithmetic errors.
If the JIT forgets to check for division by zero, the proof of Lemma 7 cannot succeed: in Cminor, division by zero is undefined, and it would be impossible to prove that the generated Cminor code refines the semantics of the BPF program.
Similarly, if the JIT has an incorrect optimization, such as reciprocal_divide, the proof of Lemma 7 cannot proceed, either.
We initially forgot to check for division by zero, and had to address it in order to complete the proof.Memory errors.
If the memory index in a BPF instruction is in-bounds, the generated Cminor instruction must access the same memory index; otherwise the proof of Lemma 7 cannot proceed.
This eliminates incorrect memory indices.
On the other hand, if the memory index in a BPF instruction is out-of-bounds, the BPF program is undefined, and the termination proof ensures that the checker must reject all such programs.
Thus, out-of-bounds memory accesses are avoided.Information leak.
The initial state transition (5.1) specifies that the initial state of a BPF program contain zeroes in all registers and scratch memory locations.
The proof of Lemma 4 guarantees that no generated native code can produce results inconsistent with zeroed initial memory.
Note that the lemma leaves open the option of not initializing these memory locations, as long as they are not actually read by the BPF program.
In fact, the CompCert compiler's optimization passes will eliminate initialization of unused memory locations in a provably correct way.Encoding and decoding bugs.
Lemma 3 guarantees that the decoder is the inverse of the encoder.
This lemma's proof cannot go through if one of the encoder or decoder has a bug, as was the case in a recent Linux issue [4].
Bugs in BPF generation tools.
If developers write SCPL rules and invoke the SCPL compiler to generate BPF filters, Lemma 2 guarantees the absence of incorrect filters, unlike with tcpdump or libseccomp.
To understand the quality of native code generated by Jitk, we collect BPF filters used by popular applications shipped in Ubuntu 14.04.
To extract these filters, we use LD_PRELOAD to intercept the prctl system call, used to submit system call filters to the kernel.
We then compare the sizes of resulting native code produced by Jitk/BPF and by two widely used in-kernel BPF JITs, Linux and FreeBSD, as shown in Figure 17 (though Linux does not use the BPF JIT for Seccomp).
For ARM and PowerPC, we compare Jitk with Linux's BPF JIT (FreeBSD's does not support the two architectures).
For x86, we compare Jitk with FreeBSD's BPF JIT (Linux's does not support x86).
Also, the current Linux JIT (both ARM and PowerPC) failed on one special BPF instruction used by Seccomp; we patched it for this comparison.
The results show that in addition to the correctness and safety guarantees, the quality of the native code produced by Jitk is comparable to that from existing in-kernel JITs.
Particularly, Jitk generates substantially smaller code than existing in-kernel JITs on x86 and PowerPC.
After inspecting the resulting assembly code, we believe the reason is that Jitk is built on top of CompCert, which performs more comprehensive and effective optimizations (e.g., common-code elimination).
To evaluate the usability of SCPL, we translated the Seccomp policy used by OpenSSH from raw BPF operations specified by the developer into an SCPL policy.
The resulting SCPL policy was 40 lines of code, parts of which were shown in Figure 3.
Integrating the SCPL policy into OpenSSH required changing an additional 20 lines of OpenSSH source code, to load the BPF filter produced by the SCPL compiler, instead of using the manually written BPF filter.
Overall, we believe this suggests that SCPL is easy to use in real applications.
To evaluate the performance of Seccomp with Jitk, we measured the performance of OpenSSH running on an i386 Linux system.
We measured two OpenSSH configurations: one with the hand-written BPF filter, and one with the SCPL-generated filter (as described above).
We also considered two kernel configurations: one using the stock Linux kernel, with its unverified BPF interpreter, and one using our modified Linux kernel that uses Jitk's BPF JIT.
Since the Seccomp policy in OpenSSH applies to the process that performs user authentication, we measured the time it takes to log in via SSH and then immediately disconnect, from the same machine (i.e., measuring the time for ssh localhost exit), using RSA key authentication.
Figure 18 shows the results on a single-core 2.8 GHz Intel Xeon CPU with 3 GB DRAM running a 32-bit Linux 3.15-rc1 kernel.
As can be seen, SCPL-generated filters perform just as well as the hand-written BPF filter in OpenSSH.
Jitk's BPF JIT introduces about 20 msec of additional latency; this is due to the overhead of invoking a new process for the OCaml runtime and the assembler.
We measured the time taken just to install the OpenSSH Figure 18: Time taken to login and disconnect from an OpenSSH server in different configurations; using SCPL gives the same performance as hand-written BPF filters.BPF filter as a Seccomp policy in Linux, using the prctl system call; the time with the stock Linux kernel was 1 msec, and the time with Jitk's BPF JIT was 21 msec; the time to just run the BPF JIT's OCaml binary on that BPF filter is 14 msec.
We believe this can be reduced further by using a persistent user-space helper process instead of spawning a new process for every BPF filter.
One benefit of Jitk's BPF JIT over a traditional interpreter is that once the BPF filter has been translated into native code, subsequent system calls can execute with lower overhead.
To measure this, we used the BPF filter from OpenSSH, and measured the time to both install the BPF filter, and to perform 1,000,000 gettimeofday system calls (we moved gettimeofday to be the last system call allowed by the BPF filter).
With the stock Linux BPF interpreter, this took 771 msec; with Jitk's BPF JIT, this took 691 msec; without any filter, this took 460 msec.
Jitk is a new approach for building in-kernel JIT interpreters that guarantee functional correctness using formal verification techniques.
Jitk guarantees correctness through high-level policy rules in user-space applications, to lower-level BPF, across the user-kernel space boundary, and to native code in-kernel.
It also guarantees termination and bounded stack usage for native code executed in-kernel.
An analysis of known interpreter vulnerabilities demonstrates that Jitk prevents all classes of security vulnerabilities discovered in existing kernel interpreters.
An experimental evaluation shows that Jitk's SCPL rules are easy to integrate into existing applications, and that Jitk achieves good end-to-end performance.
We believe that this is a promising direction since it achieves flexibility, safety, and good performance.
All of Jitk's source code is publicly available at http://css.csail.mit.edu/jitk/.
We thank the anonymous reviewers and our shepherd, Gernot Heiser, for their feedback.
This research was partially supported by the DARPA Clean-slate design of Resilient, Adaptive, Secure Hosts (CRASH) program under contract #N66001-10-2-4089, and by NSF award CNS-1053143.
