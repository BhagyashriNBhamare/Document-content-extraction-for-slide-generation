In the Internet today, traffic management spans congestion control (at end hosts), routing protocols (on routers), and traffic engineering (by network operators).
Historically, this division of functionality evolved organically.
In this paper, we perform a top-down redesign of traffic management using recent innovations in optimization theory.
First, we propose an objective function that captures the goals of end users and network operators.
Using all known optimization decomposition techniques, we generate four distributed algorithms that divide traffic over multiple paths based on feedback from the network links.
Combining the best features of the algorithms, we construct TRUMP: a traffic management protocol that is distributed, adaptive, robust, flexible and easy to manage.
Further, TRUMP can operate based on implicit feedback about packet loss and delay.
We show that using optimization decompositions as a foundation, simulations as a building block, and human intuition as a guide can be a principled approach to protocol design.
Traffic management is the adaptation of source rates and routing to efficiently use network resources.
Traffic management has three players: users, routers, and operators.
In today's Internet, users run congestion control to adapt their sending rates at the edge of the network.
Inside a single Autonomous System (AS), routers run shortest-path routing based on link weights.
Operators tune link weights to minimize a cost function [1].
The current division of labor between the three players slowly evolved over time without any conscious design, resulting in a few shortcomings.
First, operators tune link weights assuming that the traffic is inelastic and Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.CoNEXT' 07, December 10-13, 2007, New York, NY, U.S.A. end hosts adapt their sending rates assuming routing is fixed.
Second, tuning link weights is an indirect way to control traffic flow through a network; further, the linkweight setting problem is NP-hard, forcing operators to resort to heuristics that can lead to highly suboptimal solutions.
Finally, since this offline optimization occurs at the timescale of hours, it does not adapt to changes in the offered traffic.In this paper, we rethink Internet traffic management using optimization theory as a foundation.
Optimization decomposition is the process of decomposing a single optimization problem into many sub-problems, each of which is solved locally.
While decomposition is a useful tool for deriving distributed algorithms, it has rarely been used to design a practical protocol, with FAST TCP [2] as a notable exception.
The barriers are twofold.
First, any mathematical modeling makes simplifying assumptions.
Second, while multiple decomposition methods exist, it is unclear how to compare them.
To the best of our knowledge, this is the first work that compares multiple decomposition solutions, then builds a practical protocol that combines best features from each one.In our top-down redesign of traffic management, we start by selecting an intuitive and practical objective function in Section 2 .
In Section 3, we derive four distributed solutions where sources adapt their sending rates along multiple paths, based on different kinds of feedback from the links, using optimization decomposition techniques discussed in [3].
Optimization theory guarantees that these algorithms converge to a stable and optimal point, while simulations allow us to compare rate of convergence and robustness to tunable parameters in Section 4.
We combine the best features of each algorithm to construct a simple traffic management protocol in Section 5.
Our contributions are:• Protocol Design using Decompositions: We demonstrate how to create a practical network protocol by deriving multiple distributed algorithms, comparing their practical properties, and synthesizing their best features into a practical protocol.
• Redesigned Traffic Management: We introduce TRUMP, a TRaffic-management Using Multipath Protocol to replace congestion control and traffic engineering.
TRUMP is easy to manage and robust to small-timescale traffic shifts.TRUMP converges faster than the four algorithms presented in Section 3, and has the fewest tunable parameters.
As with any mathematical modeling, the TRUMP algorithm leaves many protocol details unspecified.
We use out intuition to address these details.
In Section 6, the TRUMP protocol is evaluated using packet-level simulations with realistic topologies and traffic patterns.
The protocol still leaves room for interpretation regarding the division of functionality.
We defer the discussions on deployment issues until Section 7.
Finally, we discuss related work in Section 8 and conclude in Section 9.
Every optimization problem consists of an objective function, constraint set and variables.
For traffic management, by having both routing and source rate as optimization variables, we have the most flexibility in resource allocation.
In our problem, the constraint is that link load does not exceed capacity.
The objective function remains to be designed.
In this section, we start with an objective of maximizing aggregate user utility, but simulations reveal its solution converges slowly and is sensitive to step size.
In addition, maximizing utility leads to bottlenecks in the network, making the network fragile to traffic bursts.
To address practical challenges, we select an objective which balances maximizing user utility with minimizing operator's cost function.
One natural objective for the traffic management system is to maximize aggregate user utility, where utility U i (x i ) is a measure of "happiness" of source-destination pair i (referred to as source i in this paper) as a function of the total transmission rate x i .
U is a concave, non-negative, increasing and twice-differentiable function, e.g. log(x i ), that can also represent the elasticity of the traffic or determine fairness of resource allocation.
This is the objective implicitly achieved by TCP congestion control today [4,5].
We represent the routing by matrix R li that captures the fraction of source i's flow that traverses link l, and we let c l denote the capacity of link l.
As proposed in [6,7], the resulting optimization problem is:maximize i U i (x i ) subject to Rx c, x 0(1)where both R and x are variables.
A distributed solution to (1) can be derived through dual decomposition if (1) is a convex optimization problem.
In its current form, (1) has a non-convex constraint set, which can be transformed into a convex set if the routing is allowed to be multipath.
To capture multipath routing, we introduce z i j to represent the sending rate of source i on its jth path.
We also represent available paths by a matrix H where H does not necessarily present all possible paths in the physical topology, but a subset of paths chosen by operators or the routing protocol.
Then we can rewrite (1) as:maximize i U i ( j z i j ) subject to i j H i lj z i j ≤ c l , ∀l.(2)In this form, (2) is a convex optimization problem.
A distributed solution to (2) can be derived using dual decomposition [6], where a dual variable is introduced to relax the capacity constraint.
The resulting Dual-based Utility Maximizing Protocol (DUMP) involving sources and links is summarized in Figure 1.
Similar to the reverse engineering of the congestion-control protocol in [5], s can be interpreted as link prices.Feedback price update at link l:s l (t+1) =   s l (t) − β s (t)   c l (t) − i j H i lj z i j (t)     + ,where β s is the feedback price step size.Path rate update at source i, path j: Here t represents the iteration number and each iteration is at the same timescale as the longest Round Trip Time (RTT) of the network.
At each link, s l is updated based on the difference between the link load i j H i lj z i j and the link capacity.
As indicated by [] + , s l is only positive when the link load exceeds the link capacity, i.e. when the network is congested.
Each source updates z i j based on explicit feedback from the links, in the form of feedback prices s l .
In particular, each source maximizes its own utility, while balancing the price of using path j.
The path price is the product of the source rate with the price per load for path j (computed by summing s l over the links in the path).
z i j (t+1) = maximize z i j   U i   j z i j   − z iDUMP is similar to the TCP dual algorithm in [5] except the local maximization is conducted over a vector z i , as opposed to only a scalar x i , to capture the multipath nature of DUMP.From optimization theory, certain choices of step sizes, such as β s (t) = β/t where β > 0 is a constant, guarantee that DUMP will converge to the joint optimum as t → ∞ [8].
However, such diminishing step size is difficult to implement in practice as it requires synchronization of time across the nodes, and particularly difficult to do with dynamic arrivals of new flows.
Even under the simplest of topologies and assuming greedy flows, DUMP has poor convergence behavior [6,9].
We observe that, when the step size is too large, DUMP will constantly overshoot or undershoot, never reaching the ideal utility.
On the other hand, when the step size is too small, DUMP converges very slowly.
Even at the optimal stepsize, DUMP only converges after about 100 iterations.
This highlights that choosing an appropriate step size for DUMP is challenging.
Let us reflect for a moment on why DUMP has poor convergence behavior.
If we look at the form for feedback price, we see it is only nonzero when links are overloaded, therefore, the feedback from the links is not fine-grained.
This corresponds to the current congestion control mechanism where sources only reduce their sending rates once packets are already lost, causing the sawtooth behavior.
In fact, the feedback price in DUMP has the same formulation as the congestion price in [5].
In addition, utility is only based on throughput, while having low delay is also important to traffic management.
In addition, the authors of [10] suggest the network would be driven to a solution where some links are operating near capacity if only utility is maximized.
This is an undesirable operating point which is very fragile to traffic bursts.
This indicates that maximizing the aggregate utility enhances performance of the individual users, but leaves the network as a whole fragile.To avoid the poor convergence properties of DUMP, we look for an alternative problem formulation which also takes into account the operator's objective.
Today, traffic engineering solves the following optimization problem with only R as a variable (and x constant):minimize l f ( i R li x i /c l ).
(3)f is a convex, non-decreasing, and twice-differentiable function that gives increasingly heavier penalty as link load increases, e.g. eP i R li x i /c l .
The intuition behind choosing this f is two-fold.
First, f can be selected to model M/M/1 queuing delay.
Second, network operators want to penalize solutions with many links at or near capacity and do not care too much whether a link is 20% loaded or 40% loaded [1].
If we solve (3) with both x and R as variables, then the solution would end up with zero throughput, which is also undesirable.A better traffic management objective could be to combine performance metrics (users' objective) with network robustness (operator's objective), leading to the following formulation as a joint optimization over (x, R):maximize i U i (x i ) − w l f ( i R li x i /c l ) subject to Rx c, x 0.
(4)This objective favors a solution that strikes a trade-off between high aggregate utility and a low overall network congestion, to satisfy the need for performance and robustness.
Similar problem formulations were proposed in [10,11], though without w.
Here w is a tuning parameter which adjusts the balance between the utility function and the cost function.
When w is small, (4) is very close to (1) since the utility term dominates.
When w is large, the solution is more conservative in avoiding solutions which are close to capacity.
Today, operators tune link weights today depending on the given traffic, in this case, they can tune w depending on the given traffic.
Fairness is another important consideration.
From a theoretical perspective, the solution to (4) is α-fair as w → 0, where α-fairness is defined in [12].
While this does not hold for general values of w, our experimental results in Section 6.4 are encouraging.Before generating distributed solutions in Section 3, we first transform (4) to a convex optimization problem:maximize i U i ( j z i j ) − w l f (y l /c l ) subject to y c, y l = i j H i lj z i j , ∀l.(5)Note that to decouple the objective which contains U (a per-source function) and f (a per-link function), we introduce an extra variable y l to provide feedback before link load exceeds actual capacity.
In this section, we describe the distributed algorithms generated from optimization decompositions of (4) (the decomposition techniques are surveyed in [3,4]).
In all four resulting algorithms, the solutions update their path rates based on feedback prices from links.
Optimization decomposition leads us to three useful notions: effective capacity, consistency price and direct path-rate update.
Practically, there are several other similarities between the four algorithms.
They only impose a small amount of overhead on the links including measuring the link load.
They also incur the same amount of message passing overhead, i.e., passing one link price to the sources.
While computations can involve solving a local optimization problem and taking derivatives, U and f are twice differentiable, therefore closed-form solutions are available and they are just simple function evaluations.
The computational complexity for all four algorithms are constant per link and linear per source.
The main difference is the number of tunable parameters of each algorithm, which varies from one to three.
The first three algorithms prevent link loads from reaching link capacity by providing feedback based on effective capacity rather than actual capacity.
In the resulting algorithms, the sources update the path rates based on feedback price just as in Figure 1.
The feedback price is similar to that in Figure 1, except based on effective capacity y l :s l (t + 1) = s l (t) − β s   y l (t) − i j H i lj z i j (t)   .
(6)As in Section 2.1, we consider constant stepsize for practical reasons, thus we remove the t argument from all the step sizes.
The derivation process for the partial-dual algorithm is identical to Section 2.1 except with effective capacity y as an additional primal variable.
The constraint y c is enforced, resulting in the following equation for updating effective capacity:y l (t + 1) = minimize (y l ≤c l ) wf (y l /c l ) − s l (t)y l .
(7)In (7), y l is updated by solving a local optimization using information from feedback price and the cost function f .
An economic interpretation is that the effective capacity balances the cost of using a link (represented by f ) and revenue from traffic transmission (represented by the product of feedback price with the effective capacity).
There is an explicit solution to (7).
Note that the effect of the cost function is proportional to w.
The primal-dual decomposition first decomposes (5) into two subproblems, one responsible for each primal variable.
The master problem solves for y assuming a given x * , while the subproblem solves for x assuming a fixed y.
The master problem is as follows:maximize i U i (x * ) − w l f (y l /c l ) subject to y c.(8)where x * is a solution to the following subproblem:maximize i U i (x i ) subject to Rx y.(9)Note that (9) is identical to (2) except the constraint is on y rather than c.
The solution to the subproblem is then identical to that presented in Figure 1 except for the feedback price update uses the effective capacity y rather than actual capacity c.The master problem can be solved through an iterative update on effective capacity : (10) where β y is the effective capacity step size.
Taking a closer look at (10), the minimization ensures effective capacity stays below the actual capacity.
The parameter k is an integer greater than 1 since (8) is updated less frequently than (9).
The subgradient update itself consists of balancing the price the link can charge (s l ), and the cost that link must pay (f l (y l )).
In a nutshell, the primal-dual decomposition is identical to the partial-dual decomposition in Section 3.1.1 except that the effective capacity is updated iteratively through (10) rather than by solving a local minimization problem.y l (t + k) = min(c l , y l (t) + β y (s l (t) − wf (y l (t)))), The full-dual decomposition is quite similar to the partial-dual decomposition in Section 3.1.1, but a second dual variable p is introduced to relax the constraint y c.
This dual variable can be interpreted as consistency price as it ensures consistency between effective capacity and the capacity constraint at the equilibrium point.
As with the feedback price, the consistency price is updated over time using a subgradient method:p l (t + 1) = [p l (t) − β p (c l − y l (t))] + ,where β p is the step size for consistency price.
Consistency price only comes into play when the capacity constraint is violated, therefore, it is mapped to a nonnegative value.
The effective capacity update is based on both link prices:y l (t + 1) = minimize y l wf (y l /c l ) − (s l (t) + p l (t))y l .
The path rate update and feedback price update are identical to that of the previous two algorithms.
The full-dual algorithm closely resembles an algorithm presented in [10], though our objective contains w as a weighing factor.
Appendix 2 of [10] also shows a complete derivation of the full-dual algorithm.
In all the previous algorithms, auxiliary dual variables were introduced to relax the constraints.
In this primal decomposition, we find a direct solution by introducing a penalty function, as in appendix of [13].
Let the penalty function g l ( i j H i lj z i j ) replace the capacity constraint Hz c.
The penalty function is a continuous, increasing, differentiable and convex function that is sufficiently steep such that link loads will not overshoot capacity.
If it is also sufficiently close to zero for values less than capacity, it will not affect the optimal point [14].
If we add g and the cost function f to get a penalty-cost function P l (i j H i lj z i j ), then (5) can be transformed into the following:maximize i U i ( j z i j )−w l P l ( i j H i lj z i j ).
(11)The derivative of (11) is:dz i dt = β z ∂U i ∂z i j (x i (t)) − w l P l ( i j H i lj z i j (t)),(12)where β z is the stepsize for path rate.
Converting (12) into a subgradient update form and separating link information from source information, we obtain the algorithm in Figure 2.
Path rate update:z i j (t + 1) = z i j (t) + β z z i j (t)( ∂U i ∂z i j (x i (t)) − l H i lj s l (t))Feedback price update: The path rates are iteratively updated based on the difference between the rate of change of the utility function and the associated path feedback price.
The feedback price here directly represents how quickly the penalty function is changing at a given link load.
The primal algorithm in Figure 2 differs significantly from the first three decompositions in two ways.
First, it uses direct subgradient update on the path rates.
Second, it does not use the concept of effective capacity.s l (t + 1) = wP l ( i j H i lj z i j (t)), In this section, we study convergence properties of the four algorithms, and make three observations which will guide our design of a new protocol in Section 5.
First, we find that there is a trade-off between the speed of convergence and the achievable aggregate utility.
Second, we find algorithms which use local minimizations instead of iterative updates converge faster.
Third, we find consistency price can aid convergence for small w. Due to the multitude of tuning parameters, finding the optimal values requires fine-grained sweeping of the parameter space.
Thus we use MATLAB simulations along with simple topologies and simple traffic patterns to identify the key properties that improve convergence.
For all algorithms, we update the source and link variables at each iteration based on link load from the previous iteration.
For the utility function U , we use a logarithmic function commonly associated with proportional fairness and TCP Reno today [12].
For the costfunction f , we use an exponential function, which is the continuous version of the function used in various studies of traffic engineering [1].
We study two realistic topologies as shown in Fig- ure 3.
On the left is a tree-mesh topology, which is representative of a common access-core network structure.
On the right is the Abilene backbone network [15].
We select six source-destination pairs for access core and four pairs for Abilene.
For each source-destination pair, we choose three minimum-hop paths as possible paths for access-core and four minimum-hop paths as possible paths for Abilene.
The simulations assume the link capacities follow a truncated (to avoid negative values) Gaussian distribution, with an average of 100 and a standard deviation of 10.
For this set of experiments, we define convergence as reaching 99.9% of the optimal aggregate utility of (4).
We found the convergence rates to be independent of initial routing conditions.
Due to space constraints, we omit extra graphs when the same trends are observed across algorithms, topologies and values of w, more graphs can be found in [9].
In this section, we illustrate a trade-off between aggregate utility and convergence time.
In Figure 4, we plot the number of iterations before convergence against step-size for three values of w for the partial-dual algorithm from Section 3.1.1.
For each step-size, 10 random capacity distributions are chosen and the average number of iterations before convergence is highlighted in a solid line.
Comparing across Figure 4 from left to right, we see that as w shrinks, the convergence time at the optimal step size grows and the range of step sizes with a good convergence time shrinks.
This helps understand why DUMP (w = 0) is hard to tune.In Figure 5, we plot the aggregate utility achieved by solving (4) as a percentage of maximal aggregate utility achieved by solving (1), for a range of w values.
From the graph, we observe that there is a knee region for both topologies.
For the access-core topology, this knee region is w = [1/4, 1/6]; for the Abilene topology, this knee region is w = [1/6, 1/10].
Below this knee region, the algorithm achieves near maximal aggregate utility, since the cost function f is weighed sufficiently lightly to not change the solution.
Above this knee region, the aggregate utility achieved decreases, as the cost function f becomes a significant part of the objective.
Looking at Figure 4 and 5 together, one can observe there are some values of w that have faster convergence and less sensitivity to step size without much sacrifice in utility.
Below the knee region of Figure 5, the gains in aggregate utility do not offset the gain in convergence time.
Otherwise, there is a trade-off between aggregate utility and convergence time.
Depending on the conditions of their network, operators can choose their desired operation point.
In this subsection, we do a series of comparisons between convergence time and step-size sensitivity of the four algorithms, and find partial-dual in Figure 4 is the best overall, with a good convergence profile and fewest tunable parameters.
Due to space constraints, we summarize our observations in Table 1, but more details can be found in [9].
Comparing the primal-dual algorithm in Section 3.1.2 to the partial-dual algorithm, we find the two extra tunable parameters do not improve the convergence properties.
The convergence times of primal-dual and partialdual algorithms are almost identical for well-chosen β y and k. For other values of β y , however, we find the primal-dual algorithm converges more slowly than the partial-dual algorithm.Comparing the full-dual algorithm in Section 3.2 to the partial-dual algorithm, we find consistency price may improve convergence properties.
From Table 1, we note that β p has no effect on the convergence time when w = 1.
This is because the effective capacity stays far below actual capacity when w is high, so consistency price p l stays at 0 and its step size plays no role.
For w = 1/6 (which is the edge of the knee region seen in Figure 5), we find that the full-dual algorithm can converge faster than the partial-dual algorithm.
This is because if we allow the capacity constraint to be vio- lated during transient periods, the algorithm can take more aggressive steps and potentially converge faster.Algorithm Partial-Dual Primal-Dual Full-Dual Primal w = 1,Comparing the primal algorithm in Section 3.3 to the partial-dual algorithm, we find local minimization update has better convergence properties than subgradient update.
This is intuitive as the subgradient update with a constant step-size is constrained to react with the same strength each time, while local minimization can react more flexibly.
From Table 1, the primal algorithm takes longer to converge at the optimal step size (25 iterations versus 15 iterations).
In addition, the primal algorithm also requires operators to tune a second parameter g.
While the algorithms introduced in Section 3 converge faster than DUMP, we seek an algorithm with even better convergence properties.
In this section, we introduce Traffic-management Using Multipath Protocol (TRUMP) with only one easy to tune parameter.
Our simulations in the previous section suggest that simpler algorithms with fewer tunable parameters converged faster, although having a second link price can help for small w. Using those observations, we combine the best parts of all four algorithms to construct the TRUMP algorithm described in Figure 6.
In TRUMP, the feedback price has two components as in the fulldual algorithm: p l and q l .
Since we observed that local optimization worked better than subgradient update, we use the feedback price update from primal algorithm in Figure 2 as our q l .
This has the additional benefit of removing one tuning parameter from the protocol since the update of q l involves no step size.By a similar argument, we use a local optimization for the path rate update as in the dual-based algorithms.
The w-value is only known at the sources where the z's are computed, and there is only a single value for the network.
The exact value is a judgment call based on an understanding (from measurements) of how stochastic the traffic is.
Simulations such as those performed in Section 6.2 could reveal the right trade-off between the level of stochasticity and the value of w.Through simulations, we find that TRUMP indeed Feedback price update:s l (t + 1) = p l (t + 1) + q l (t + 1),Loss price update:p l (t + 1) = [p l (t) − β p (c l − i j H i lj z i j (t))] + ,Delay price update:q l (t + 1) = wf   i j H i lj z i j (t)/c l   ,Path-rate update: Figure 6: The TRUMP algorithm.z i j (t + 1) = maximize z i j U i   j z i j   − l s l (t) j H i lj z i jconverges to the optimum of (4) for both topologies and a range of w values.
When we plot its achieved aggregate utility at equilibrium versus w, we obtain a plot identical to Figure 5.
In Figure 7, we plot convergence time versus step-size for TRUMP.
When the network is reacting quite strongly to delay price q (w = 1 and the traffic engineering part is dominating), the loss price p is unnecessary as observed in Figure 7a.
In the region where the network is being less conservative (w = 1/6), loss price p is a more definitive indicator of performance than delay price q, and can be helpful for guiding source reactions.
Comparing Figure 7 to Fig- ure 4, we see that TRUMP has nicer convergence properties than the partial-dual algorithm, while requiring fewer parameters.
Unlike the algorithms from Section 3, TRUMP is a heuristic and does not correspond to a known decomposition.
Consequently, the convergence and optimality is not automatically guaranteed by optimization theory.
We were able to prove the convergence of TRUMP when the network is lightly loaded, see Appendix A of [9].
We consider the region where w is sufficiently large for p = 0 (as seen in Figure 7a), and find a contraction mapping on z. Overall, TRUMP is simpler than any of the al- gorithms presented in Section 3, with only one tunable parameter that only needs to be tuned for small w.
The transition from a mathematical algorithm to a network protocol requires relaxation of several simplifying assumptions.
First, the algorithm in Figure 6 ignores feedback delay.
Second, the algorithm assumes traffic flows fluidly, while real traffic consists of packets.
Third, a specific U and f must be selected.
We address these differences in the TRUMP protocol.Each iteration of the TRUMP algorithm is dependent on RTT i j , the time it takes for source i to receive feedback along all the links of path j. To transition to a packet-based protocol, the link prices are calculated based on the estimated local link load: N T the number of bits which arrived in period (t, t + T ) divided by length of the period.
Choosing f as an exponential function, each link updates its prices as:p l (t + T ) = [p l (t) − β p (c l − N T T c l )] + , q l (t + T ) = w c l * exp N T T c l , s l (t + T ) = p l (t + T ) + q l (t + T ).
Choosing a logarithmic function for U and solving the local minimization, we obtain the following source rate update:z i j (t + T i j ) = z i j (t) − γ j z i j (t) + γ l H i lj s l (t).
(13) At time 0, the prices are initialized to a constant before real prices are available after one RTT.
New flows after time 0 are set at the calculated path rates according to the latest (delayed) price, collected by a probe before the flow starts.
To control the rate of convergence for flows with varying RTTs, as commonly done in congestion control mechanisms, e.g. [2], we introduce a parameter 0 < γ < 1.
In general, path rates are updated every γRTT i j , but the path rate is recalculated at most once for any given price update.
Thus the path rate adaptation will happen every T i j = max(T, γRTT i j ).
Note that the extra parameters γ and T are necessary for any packet-level protocol.
In our MATLAB simulations, we had implicitly assumed flows are greedy and persistent.
Moving to packetlevel simulations, we study how the TRUMP protocol performs under feedback delay, link failures and traffic shifts.
In addition, we examine whether TRUMP shares bottleneck links fairly.
We implement the TRUMP protocol in NS-2 as described in Section 5.2.
In particular, the link prices are updated every 5ms and feedback from the links to the sources is piggy-backed on acknowledgment packets.
The path rates are updated with γ = 0.1.
Most of the experiments are performed with w = 1, where there is no packet loss.
The calculated source rates are compared to the ideal rates, which are determined using MOSEK optimization software.Our simulations use both synthetic and realistic topologies, which are summarized in Tables 2 and 3 respectively.
For the topologies used in our MATLAB experiments (Figure 3), we use the same paths with link capacities of 100Mb/s.
Link delays on the Abilene topology were selected to approximate the realistic values.
Links in Access-Core topology have a one-way propagation delay of 50 ms, a value chosen to test TRUMP under long feedback delay.
Specific paths and link delays are selected in the Share topology (Figure 11a) to test the fairness of TRUMP.
Links have a capacity of 200Mb/s, except for the bottleneck link from node 7 to node 8, which has a capacity of 100Mb/s.
Since TRUMP with explicit feedback is most easily deployed inside a single AS, we obtained intra-AS topologies, along with link delays from the Rocketfuel topology mapping engine [16,17].
The link capacities are 100Mb/s if neither endpoint has degree larger than 7, and 52Mb/s otherwise.
As summarized in Table 3, between 10 and 50 flows were randomly selected.
For each source-destination pair, multiple paths were computed by first selecting a third transit node, then computing the shortest path containing all the three nodes, and finally removing cycles in the path.
The RTTs on the paths range from 1 to 400 ms. Genuity ( We confirm our MATLAB results from Section 5.1: TRUMP's converges quickly for w = 1, under heterogeneous feedback delay.
In Figure 8, we plot the ideal and actual aggregate throughput in the Sprint network with 50 greedy flows.
Ideal throughput is the sum of the rates that optimizes (4), and actual throughput is the sum of the rates that our implementation of TRUMP achieved.
The paths chosen had RTTs ranging from 3ms to 327ms, with an average of 127ms and a standard deviation of 76ms.
Similar to the MATLAB experiments, when w = 1/3, the actual throughput of TRUMP and partial-dual oscillates.
The reason the ideal-valued throughput is not reachable is the same thing we observed in DUMP.
The theory says it works with diminishing step-size, but there's no guarantee for constant step-size.
When w = 1, the TRUMP aggregate rates increase from 0 at time 0s (when the flows are established), to close to the target value within 500ms -about 4 times the average RTT.
The partial-dual oscillates slightly around the equilibrium point.
The same convergence properties are observed across both synthetic and realistic topologies.
Therefore, the TRUMP protocol is stable under realistic feedback delay for sufficiently large w. First we consider the impact of a link failure in the Sprint Network.
Path failures and recoveries are detected through active probing.
All 50 greedy flows are established at 0 sec.
At 5 sec the link between Pennsauken, NJ and Roachdale, IN fails, and it recovers at 10 sec.
Flows 20 and 39 contain the affected link in at least one of their paths.
In Figure 9, we plot the path rates of the flow 20.
We observe that immediately after the failure, traffic is assigned to an alternate path unaffected by the failure.
After the link is repaired at time 10 sec, traffic returns to the original path quickly.
Similar behavior is observed for flow 39.
We study the performance of TRUMP under realistic traffic loads by using 10 stochastic ON-OFF flows in the Abovenet network.
As suggested by [18], the OFF periods are Pareto with shape 2.0 and average of 0.2s.
We consider three file size distributions: exponential, Pareto with shape 1.2 and Pareto with shape 1.8.
In Figure 10, we plot the average file size against the efficiency: fraction of the actual throughput over the ideal throughput for a 10s period.
First, TRUMP's behavior is independent of the variance of the file-size distribution, since all three curves overlap.
For all three distributions, TRUMP is more efficient for larger files as it takes a few RTTs to converge to the ideal throughput.On the surface, TRUMP performs poorly for small files, only achieving 50% of the ideal rate.
However, given those files are transmitted within a single RTT, achieving 50% of the ideal rate is much better than TCP today.
In addition, TRUMP is optimized for logarithmic utility, for example log(20, 000)/ log(40, 000) = 0.93.
This means TRUMP achieves close to ideal utility even for small flows.
As mentioned in Section 2.2, TRUMP is α-fair as w → 0, but its fairness for general w values is unknown.
For w = 1, we construct a simple topology (Figure 11a) to illustrate whether the bottleneck link is shared fairly.
In Figure 11b, we plot throughput of two pairs of flows which differ in RTT or hop-count.
All flows have a shared destination (node 9), and the sources are nodes 1, 2 and 3 respectively.
We observe that flows 1 and 2, which have very different RTT (30ms and 100ms) but the same number of hops on their paths, share bandwidth fairly.
Unlike most congestion control proposals, TRUMP does not discriminate against long RTTs since (4) has no dependency on RTT.
While RTTs does indeed affect the transient behavior as indicated in the distributed algorithm of (13), fairness is an equilibrium property.
On the other hand, flow 3 with twice as many hops receives roughly half the bandwidth of flow 1.
This is inline with network operators goals to penalize against longer-hop paths since that would require more usage of network resources.
If the unshared links are lightly loaded, the bandwidth sharing would be less unfair since the amount of penalty depends on link load.
It is also possible to change the source rate adaptation for TRUMP to react to path prices normalized by hop length of that path, to ensure fair bandwidth sharing for diverse hops.
The TRUMP protocol still leaves many questions unanswered such as: which network elements correspond to the sources, and how the multiple paths are determined.
TRUMP being under-specified enables flexible integration with the network architecture.
In this section, we explore several deployment options.Are the "sources" end hosts or edge routers?
The mathematics does not specify whether the sources refer to the end hosts or the edge routers.
The interpretation of the sources depends on two factors: whether the end host has control over and access to the multiple paths and whether the network can trust the end hosts to send at the prescribed rate.
If end hosts are unaware of the multiple paths, then edge routers rate limit the end hosts, and split traffic amongst the multiple paths.
Even if the end hosts are aware of the multiple paths, they might send too aggressively.
In this case, edge routers should perform the same calculations and perform policing or shaping to enforce the path rates by dropping excess packets.How is H determined?
In the TRUMP protocol, there is no hint as to how a source can access multiple paths.
Luckily, many options exist.
Inside a single AS, routers can compute K-shortest paths, or a management system can set-up multiple tunnels.
Across ASes, TRUMP is easily deployed at multihomed stub networks which can already access multiple paths to each destination.
Another possibility is in the context of Content Distribution Networks, where a customer can download content from multiple servers.
There are also incrementally deployable ways of accessing end-to-end multiple paths [19].
Is the feedback explicit or implicit?
The TRUMP protocol described in Section 5.2 uses explicit feedback.
There are several implementation options: the feedback from links to sources could be piggy-backed on acknowledgment packets.
Regardless of the method, explicit feedback requires cooperation between sources and intermediate nodes, knowledge of the end-to-end multiple paths and imposes message-passing overhead.
All these disadvantages can be avoided by protocol based on implicit feedback, i.e., locally observable qualities.
Fortunately, the link prices p l and q l correspond loosely to packet loss and queuing delay, which a source can easily estimate 1 , though all edge routers (or sources) may still need to agree on the same w. Combining implicit feedback with flexible multipath routing for TRUMP is an exciting avenue for future research.
Optimization theory is used in traffic management research in areas such as reverse engineering of existing protocols [4,5], tuning configuration parameters of existing protocols [1], and guiding the design of new protocols [2] (for more references see [20]).
In turn, such a broad use has encouraged innovations in optimization theory, for example, [3] introduced multiple decomposition methods.
Our paper takes advantage of the recent advancements and applies multiple decompositions to design traffic management protocols.Most of the proposed traffic management protocols consider congestion control or traffic engineering alone.
Several proposed dynamic traffic engineering protocols also load balance over multiple paths based on feedback from links [21,22,23], but they do not adapt the source rates.
From the methodology perspective, our 1 p l is loosely related to packet loss on link l: max(0, P i P j H i lj z i j (t) − c l ) corresponds to packet loss on link l, and βp moderates how much to react to packet loss.
Thus, the sum of p l along the path can be approximated as end-to-end packet loss.
If we interpret f as approximating M/M/1 queuing delay at a link, then q l can be interpreted as being proportional to queuing delay.
Thus, the sum of q l along the path can be viewed as an approximation of the end-to-end average queuing delay.work bears the most resemblance to FAST TCP [2].
Other congestion control protocols that use control theory to prove stability include [24,25,26].
According to recent research, congestion-control and traffic-engineering practices may not interact well [27,10,28].
In response, many new designs are proposed.
Some of them start with a different objective, and find poor convergence properties [7,6].
Algorithms similar to two of the decomposition solutions (Section 3) are described briefly in [10] and Appendix of [29], though neither consider possible design alternatives, nor bridge the gap between a mathematical algorithm and a practical protocol.
Others analyze stability of joint congestion control and routing algorithms using theory, while we use optimization decomposition to guide the design of a practical protocol [11,30,31].
Some of our evaluation is inspired by [31,11], which proves that multipath congestion control can be stable under heterogeneous feedback delay.
In particular, [11] shares a similar problem formulation and analyze an algorithm similar to the primal-driven algorithm presented in Section 3.3, TRUMP offers extra flexibility through the tuning parameter w and faster convergence through an additional loss price.
In [32], the value of coordinated path selection (over random path selection) in the context of multipath congestion control is studied, while in this paper we consider the combination of traffic engineering and congestion control.
In this paper, we searched for a traffic-management protocol which is distributed, adaptive, robust, flexible and easy to manage.
We followed a top-down design process starting with an objective which balances the goals of users and operators.
We generated four provably optimal distributed solutions using known decomposition techniques.
Using insight from simulations comparing the four algorithms, we combined the best parts of each algorithm to construct TRUMP: a simpler traffic management protocol.
TRUMP is easy to manage, with just one optional tunable parameter.
Our packet-level evaluations confirmed TRUMP is effective in reacting to topology changes and traffic shifts on a small timescale, even with realistic feedback delay.
We also found TRUMP's performance is only weakly dependent on the properties of file size distribution.
In addition, our preliminary experiments show TRUMP can achieve fair bandwidth sharing for paths of diverse RTTs, but not for diverse hop count.
This paper started from an abstract model, and ended with a practical traffic management protocol based on feedback from the links along each path.
In our ongoing work, we are exploring a version of TRUMP where the sources adapt the path rates based on observations of end-to-end delay and loss.
We show that using optimization decompositions as a foundation, simulations as a building block, and human intuition as a guide can be a principled approach to protocol design.
We would like to thank Renata Teixeria, Wenjie Jiang, Changhoon Kim, Yaping Zhu and Dahai Xu for their feedback on earlier drafts of this paper.
We also appreciate Jim Kurose, Dani Palomar and the anonymous reviewers for their insightful comments.
This work has been supported in part by NSF grants CNS-0519880 and CCF-0448012, Cisco grant GH072605, and DARPA seedling W911NF-07-1-0057.
