We introduce a theoretical framework for discovering relationships between two database instances over distinct and unknown schemata.
This framework is grounded in the context of data exchange.
We formalize the problem of understanding the relationship between two instances as that of obtaining a schema mapping so that a minimum repair of this mapping provides a perfect description of the target instance given the source instance.
We show that this definition yields "in-tuitive" results when applied on database instances derived from each other by basic operations.
We study the complexity of decision problems related to this optimality notion in the context of different logical languages and show that, even in very restricted cases, the problem is of high complexity.
We assume some countably infinite sets C of constants (denoted a, b, 0, 1, etc.) and V of variables (denoted x, y, z, etc.).
We use the notation x to represent a vector of variables x1 . . . xn.
Constants appearing in formulas are here identified, as usual, with the domain elements they are interpreted by.A (relational) schema is a finite set of pairs (R, n) where R is a relation name and n 1 the arity of the relation.
An instance I of a relational schema S consists, for every (R, n) ∈ S, of a finite relation over C n .
We occasionally denote R I the interpretation of the relation name R in the instance I (if |S| = 1, we shall make the confusion R I =I).
In the following, we assume that the schemata are implicitly given whenever we are given an instance.A language L is a subset of the set of formulas of firstorder logic with equality and constants, and without function symbols (with its usual semantics).
Given a language L, a schema mapping in L is a finite set of formulas in L.
We are particularly interested in the following languages, given instances I, J with schemata S, T:Relational calculus.
Lrc is the set of first-order formulas without constants, with relations symbols in S ∪ T.Source-to-target tuple-generating dependencies.
L tgd ⊂ Lrc is the set of formulas of the form∀x ϕ(x) → ∃y ψ(x, y)where: (i) ϕ(x) is a (possibly empty) conjunction of positive relation atoms, with relation symbols in S;(ii) ψ(x, y) is a conjunction of positive relation atoms, with relation symbols in T; (iii) all variables of x appear in ϕ(x).
Acyclic tgds.
Lacyc ⊂ L tgd is the set of tgds such that the hypergraph of the relations on the left hand-side is acyclic [2], as well as the hypergraph of the relations on the right hand-side, considering only existentially quantified variables.
More precisely, let ∀x ϕ(x) → ∃y ψ(x, y) be a tgd, and let (N, E) (respectively, (N , E )) be the hypergraph whose vertices are the variables of x (respectively, y) and whose edges are the relation atoms of ϕ(x) (respectively, the relation atoms of ψ(x, y) where at least one variable of y appears).
The tgd is said to be acyclic 3 if there are two forests F and F (called the join forests) with each hyperedge of E (respectively, of E ) a node of F (respectively, of F ), such that for all nodes n ∈ N (respectively, n ∈ N ), the subgraph of F (respectively, of F ) induced by the edges of E (respectively, of E ) that contain n is connected.
Other equivalent definitions of acyclic hypergraphs are given in [2].
Full tgds.
L full ⊂ L tgd is the set of tgds without an existential qualifier on the right-hand side, that is, of the form∀x ϕ(x) → ψ(x).
Acyclic full tgds.
L facyc = Lacyc ∩ L full is the set of full tgds such that the hypergraph of the relations on the left hand-side is acyclic.We focus here on source-to-target tuple-generating dependencies (either arbitrary or with one of the restrictions mentioned above).
Arbitrary tgds (and, in a lesser way, full tgds) have been at the basis of most works 4 in the data exchange setting [7,15].
As we shall see in Section 5, acyclic full tgds have nice complexity results.
We show in Section 6 how this work can be extended to arbitrary formulas of the relational calculus.
We first introduce the two basic notions of validity and explanation that are at the basis of our framework.
Definition 1.
A schema mapping Σ is valid with respect to a pair of instances (I, J) if (I, J) |= Σ.
Definition 2.
A (ground) fact in a schema S is a tuple R(c1 . . . cn) where c1 . . . cn ∈ C and R is a relation of S with arity n.A schema mapping Σ explains a ground fact f in the target schema with respect to a source instance I if, for all instances K of the target schema such that (I, K) |= Σ, f ∈ K.A schema mapping fully explains a target instance J with respect to a source instance I if it explains all facts of J with respect to I.We have quite an asymmetric point of view about the pair of instances here; we do not require a full explanation of I by the facts of J, for instance.
This asymmetry is quite common in the context of data exchange.
For source-to-target tgds, note that Σ fully explains J with respect to I if and only if J is included in the result of the chase [7] of I by Σ.Example 3.
Let us consider the following database instances I and J, on schemata {(R, 1)} and {(R , 2)}.
3 Note that this notion of acyclicity is not related to the notion of weakly acyclic set of tgds that has been much studied in the context of data exchange [7,15].
4 The other important class of dependencies, namely equality generating dependencies, is less appropriate to this context.R R a b c d a a b b c a d d g hWe can imagine a number of schema mappings that more or less express the relation between I and J:Σ0 = ∅ Σ1 = ˘ ∀x R(x) → R (x, x) ¯ Σ2 = ˘ ∀x R(x) → ∃y R (x, y) ¯ Σ3 = ˘ ∀x∀y R(x) ∧ R(y) → R (x, y) ¯ Σ4 = ˘ ∃x∃y R (x, y) ¯Actually, any combination of these schema mappings may also be of interest.
Σ0 and Σ4 seem pretty poor, here, as they fail to explain any facts of J, while there seems to be a definite relation (albeit with some noise) between I and J. Σ3 explains most of the facts of J, but is far from being valid, since it also explains a large number of incorrect facts such as R (a, b) or R (b, d).
Σ1 and Σ2 are more interesting.
Σ1 explains 3 facts of J, but also incorrectly predicts R (c, c).
Σ2 fails to explain any facts of J, but explain most of them at least partially, in the sense that they are explained by a fact with an existentially quantified variable (a skolem); in addition, it is valid with respect to (I, J).
Neither Σ1 or Σ2 explains the last fact of J.As there seems to be some noise in the operation that produced J from I, it is hard to say with certainty which schema mapping is optimal here, in the sense that it reflects most closely the relation between I and J.
At any rate, however, Σ1 and Σ2 seem far better candidates than the other ones.To define in a formal way our notion of optimality of a schema mapping, the basic idea is to get the simultaneous optimal for all three factors of interest (validity, explanation of the target instance, conciseness) by minimizing the size of: the original formula, plus all the local corrections that have to be done for the formula to be valid and to fully explain the target instance.
This is close in spirit to the notion of Kolmogorov complexity and Kolmogorov optimal [19] (though we do not consider a Turing-complete language for expressing either the formula or the corrections, but much more limited languages).
Definition 4.
Given a schema mapping of tgds Σ ⊂ L tgd and a pair of instances (I, J), we define the set of repairs of Σ with respect to (I, J), denoted repairs (I,J) (Σ), as a set of finite sets of formulas, such that Σ ∈ repairs (I,J) (Σ) if it can be obtained from Σ by a finite sequence of the following operations:• Adding to the left-hand side of a tgd θ of Σ, with θ of the form ∀x ϕ(x) → ∃y ψ(x, y), a conjunction τ (x) of the form: V i xiαici where αi are either = or =, xi are variables from x and ci are constants.
• Adding to the right-hand side of a tgd θ of Σ, with θ as above, a formula τ (x, y) of the form:^ i ^ j xij = c ij !
→ yi = ci !
where xij are variables from x, yi variables from y, and c ij and ci constants.
• Adding to Σ a ground fact R(c1 . . . cn) where R is a relation of the target schema of arity n, and c1 . . . cn are constants.The language of repairs L * of a language L is the language consisting of all formulas which can be obtained from formulas of L with these operations (along with all ground facts over the target schema).
In a repair of a tgd ∀x ϕ(x) ∧ τ (x) → ∃yψ(x, y) ∧ τ (x, y), the term τ (x) is responsible for correcting cases when the tgd is not valid, by adding additional constraints on the universal quantifier, whereas τ (x, y) specifies the right-hand side of J, by giving the explicit value of each existentially quantified variable, in terms of the universally quantified variables.An interesting property of repairs is that they are reversible: Because all operations add constants to a language where constants do not exist, it is possible to compute (in linear time) the original schema mapping from a repair.
Indeed, constants are only used for repairing formulas; in other words, we consider that the relations that we need to find between the source and target instances are to be expressed with constant-free formulas, in order to abstract them as much as possible.
Clearly, this is a simplifying assumption that could be lifted in future works.
Note that this extension is not straightforward, however: It is not clear how to distinguish between constants which are rightfully part of the optimal schema mapping description and constants which are just used to correct some noise or missing data.The notion of size of a schema mapping is easily defined as follows; we could also use a more classical definition in function of the number of symbols of a formula, without much difference in the theory.Definition 5.
The size of a first-order formula ϕ ∈ L * , denoted size(ϕ) is computed as follows:• The size of ϕ is the number of occurrences of variables and constants in ϕ (we stress that each variable and constant is counted as many times as it occurs in ϕ); occurrences of variables as arguments of quantifiers do not count.
• If ϕ is a ground fact R(c1 . . . cn), then the size of ϕ is computed as if ϕ were the formula∃x1 . . . ∃xn R(x1 . . . xn) ∧ x1 = c1 ∧ · · · ∧ xn = cn.Therefore, size(ϕ) = 3n.
The size of a schema mapping is the sum of the size of its elements.The refinement on ground facts is performed so that such facts are not "too cheap": the cost of R(c1 . . . cn) is the same as that of the corresponding repair of ∃x1 . . . ∃xn R(x1 . . . xn), as will be illustrated in Example 8.
This is not a major assumption, however, and it does not impact the results of this paper in a significant way.
We are now ready to define the cost of a schema mapping, in terms of the size of its repairs:Definition 6.
The cost of a schema mapping Σ, with respect to a pair of instances (I, J), is defined by:cost (I,J) (Σ) = min Σ ∈repairs (I,J) (Σ)Σ valid and fully explains J size(Σ ).
Note that cost (I,J) (Σ) may not be defined if the minimizing set is empty.
A schema mapping Σ ⊂ L is optimal in the language L, with respect to a pair of instances (I, J), if:cost (I,J) (Σ) = min Σ ⊂L Σ finite cost (I,J) ` Σ ´ .
It is indeed possible that cost (I,J) (Σ) is not defined.
This is for instance the case for T = {(R , 1)}, Σ = {∃x R (x)} and J = ∅.
However, this case is easily recognizable; in other cases we have a linear bound on the cost of a schema mapping:Proposition 7.
There is a linear-time algorithm to check whether the cost of a schema mapping in L tgd is defined with respect to a pair of instances.
If it is defined, the cost is bounded by a linear function of the size of the data and the schema mapping itself.This linear bound is interesting, since we can imagine to use local search algorithms to find the tgd with minimum cost, as soon as we are able to compute in an efficient way the cost of a tgd.
We shall see in Section 5, unfortunately, that even for a very restricted language, computing the cost of a tgd is NP-complete.
Example 8.
Let us go back to the instances and schema mapping of Example 3, compute their respective cost, and see which one is optimal.cost (I,J) (Σ0) = 3 · 2 |J| = 30 cost (I,J) (Σ1) = 3 + 2 + 3 · 2 · 2 = 17 cost (I,J) (Σ2) = 3 + 4 · 4 + 3 · 2 = 25 cost (I,J) (Σ3) = 4 + 4 + 3 · 2 · 4 = 32 cost (I,J) (Σ4) = 2 + 4 + 3 · 2 · 4 = 30It appears here that Σ1 is the best of these schema mappings (and it can be shown that it is indeed optimal).
As expected, Σ2 is the second best.The fact that Σ4 has the same cost as Σ0 is no coincidence, this is due to the choice we made for the cost of a ground fact.At least on this simple example, our measure of cost seems reasonable.
We will further justify it in Section 4.
The following decision problems arise naturally once given this notion of optimality.
Each of them is defined for a given language L, and we shall investigate their complexity in Section 5.
Validity.
Given instances I, J, and a schema mapping Σ ⊂ L * , is Σ valid with respect to (I, J)?
Explanation.
Given instances I, J, and a schema mapping Σ ⊂ L * , does Σ fully explain J with respect to I?Zero-Repair.
Given instances I, J, and a schema mapping Σ ⊂ L * , is cost (I,J) (Σ) equal to size(Σ)?
Cost.
Given instances I, J, a schema mapping Σ ⊂ L and an integer K 0, is cost (I,J) (Σ) less than or equal to K?Existence-Cost.
Given instances I, J and an integer K 0, does there exist a schema mapping Σ ⊂ L such that cost (I,J) (Σ) is less than or equal to K?Optimality.
Given instances I, J, and a schema mapping Σ ⊂ L, is it true that Σ is optimal with respect to (I, J)?
Note that Validity, Explanation and Zero-Repair all consider formulas of the language of repairs L * .
This is an important point that will be used in Proposition 10 to derive relationships between the six decision problems above.
In this section, we justify the definitions of the previous section by observing that, when instances I and J are derived from each other by elementary operators of the relational algebra, the optimal schema mapping, in L tgd , is the one that "naturally" describes this operator.Let r, r be instances of relations.
We consider the following elementary operators of the relational algebra:Projection.
πi(r) denotes the projection of r along its ith attribute.Selection.
σϕ(r), where ϕ is a conjunction of equalities and negated equalities between an attribute of r and a constant, denotes the selection of r according to ϕ.
Note that we allow neither identities between attributes of r (this is the role of the join operation), nor disjunctions (they may be expressed using a combination of selection and union).
Union.
r ∪ r is the union of r and r .
Intersection.
r ∩ r is the intersection of r and r .
Product.
r × r is the cross product of r and r .
Join.
r 1ϕ r is the join of r and r according to ϕ, where ϕ is an equality between an attribute of r and an attribute of r ; ϕ is omitted when the context makes it clear.The relationship between a database instance I and the instance J obtained from I using one of these operators can often be (partially) expressed in a natural way by a tgd or a set of tgds, where I is the source instance and J the target instance (and similarly when the source instance is expressed as the result of applying some operator to the target instance).
For instance ∀x R1(x) ∧ R2(x) → R (x) is naturally associated with the intersection operator.
The only case when the relationship between I and J has no natural expression as a tgd is for the reciprocal of the union operator: If I = R J 1 ∪ R J 2 , the natural formula for describing this relation is ∀x R(x) → R1(x) ∨ R2(x), which is not a tgd since we do not allow disjunction.
In some cases, as tgds are not powerful enough to express the relationship, or as some information is lost, the correspondence is only partial.
For instance, ∀x R(x) → R (x) is the most natural tgd for the operation J = σϕ(I), but the tgd does not fully describe the selection.We now state that, using the notion of optimality of a schema mapping with respect to a pair of instances described in the previous section, and with some simple restrictions on the considered instances, the optimal schema mapping for a pair of instances obtained from each other with an operator of the relational algebra is precisely the schema mapping that is naturally associated with the operator.
This justifies the choice of this notion of optimality, at least in these elementary contexts.
We shall see in Section 6 other choices for the cost function, that might seem more natural at first, but that fail to satisfy the same property.
For brevity's sake, we state this result in an informal way and illustrate it on the example of the join operator.Theorem 9 (Informally stated).
For any elementary operator γ of the relational algebra, the tgd naturally associated with this operator (when it exists) is optimal with respect to (I, γ(I)) (or (γ(J), J), depending on the considered case), if some basic assumptions are fulfilled: the instances are not of trivial size and there is no simpler relation between attributes than the one described by the operator.Let us see what this means, and prove this result, for the join operator.
Suppose J = R I 1 1 R I 2 (with R1 and R2 two binary relation symbols), and let us add the basic assumptions that π1(J) = π2(J), π1(J) = π3(J), π2(J) = π3(J).
We have:cost (I,J) `˘ ∀x∀y∀z R1(x, y) ∧ R2(y, z) → R (x, y, z) ¯´= ¯´= 7since this tgd is valid and explains all facts of J.
The cost of the empty schema mapping, 9 |J|, is greater since J is not empty.
The only remaining relevant schema mappings with lesser size (of 5) have a single relation symbol R1 or R2 on the left-hand-side.
But this means that they either predict two identical columns in J (this is incorrect, and has to be fixed in a repair of the schema mapping, whose additional cost is at least 2), or use an existential quantifier on the right-hand size, which also has to be repaired.
Now consider the case where I = R 1 J 1 R 2 J , and let us suppose all three attributes πi(I) disjoint.cost (I,J) `˘ ∀x∀y∀z R(x, y, z) → R 1 (x, y) ∧ R 2 (y, z) ¯´= ¯´= 7 + 6 ˛ ˛ ˛ n (x, y) ∈ R 1 J | ∀z (y, z) / ∈ R 2 J o˛ ˛ ˛ + 6 ˛ ˛ ˛ n (y, z) ∈ R 2 J | ∀x (x, y) / ∈ R 1 J o˛ ˛ ˛ .
cost (I,J) (∅) = 6 |J| is greater than that as soon as I is not empty.
As we assumed all three attributes of I disjoint, we can eliminate a number of schema mappings that do not produce any correct facts.
The only remaining ones only have R 1 (w1, w2) or R 2 (w2, w3) terms on the right-hand size with those three variables either existentially quantified or appearing, respectively in the first, second or third position of a R(w1, w2, w3) atom on the left-hand side.
None of these schema mappings can explain the facts that the schema mapping above does not explain, and existential quantifiers have to be accounted for in repairs.These results could also be extended to the cases where we have relations of greater arity, but we would then require strong constraints, as the one we imposed for reciprocal join (that all attributes are disjoint), so as not to have any "hidden" relation between the different attributes.
A weaker assumption that could be made is to use a notion of Kolmogorov randomness [19]: A database instance selected at random cannot have a description of length lower than its size, thanks to a simple counting argument.
We can use such random instances to get a contradiction when we obtain a schema mapping that uses hidden relations between attributes of relations in the instance to have a lower cost than the natural schema mapping.
We now proceed to a study of the computational complexity of the different problems identified in Section 3, for the different subsets of L tgd that we presented in Section 2.
We focus here on combined complexity (when K and Σ are part of the input to the problem in addition to I and J), since we are precisely reasoning about the schema mappings themselves.
We first describe general relationships between the different problems, before giving complexity results for L tgd , L full , L facyc and Lacyc, in that order (it might seem natural to analyze Lacyc before L facyc but the proofs for the latter are slightly simpler, and will help to understand notions needed for the former).
Cost and Existence-Cost will be discussed separately.
We present at the end of the section data complexity results.General Complexity Results.
As the complexity of the different decision problems depends on the particular language considered, we add to the problem name a subscript identifying the considered language (say, Optimality tgd for the Optimality problem in L tgd ).
We have the following elementary relationships between these problems, that can be used to derive complexity results for one problem from complexity results for another one.Proposition 10.
For any language L:1.
Zero-Repair = Validity ∩ Explanation.2.
There is a polynomial-time reduction of Validity to Zero-Repair.
to Cost.
4.
Given an algorithm A for the Zero-Repair problem, and a polynomial-time algorithm for determining if a formula is in L, there are non-deterministic algorithms for Cost and Existence-Cost that run by using once the algorithm A, with an additional polynomial time cost.
5.
Given an algorithm A for Cost, and a polynomial-time algorithm for determining if a formula is in L, there is a non-deterministic algorithm for the complement of Optimality that runs by using a logarithmic number of times the algorithm A, with an additional polynomial time cost.
6.
If L ⊆ L , for any problem among Validity, Explanation, Zero-Repair and Cost, there is a constant-time reduction from the problem in L to the problem in L .
Note that for all languages considered here, there is a lineartime algorithm for determining if a formula is in this language; this is obvious for all except for Lacyc and L facyc , and an algorithm from [21] gives a linear-time algorithm for the acyclicity of hypergraphs.In the next sections, we shall investigate in detail the complexity of the different problems in each of the identified subsets of L tgd , starting from L tgd itself.
A summary of all combined complexity results proved in the following, along with their direct consequences, is shown in Table 1 Combined Complexity for Full Acyclic TGDs.
We now look at the complexity of the same problems for L facyc .
We shall need additional notions on acyclic joins from [2,22].
Note first that an acyclic full tgd ∀x ϕ(x) → ψ(x) that describes the relation between a pair of instances (I, J) can be seen, in the relational algebra, as a project-join expression over the source instance, π ψ (1ϕ(I)), ϕ expressing the join (which is, by hypothesis, acyclic) and ψ expressing the projection.
Adding repaired formulas, of the form ∀x (ϕ(x) ∧ τ (x)) → ψ(x), means adding an additional selection: π ψ (στ (1ϕ(I))).
A full reducer of a join expression is a program which removes some tuples to the relations to be joined (by performing semi-joins) so that each relation can then be retrieved as a projection of the full join.
Such a full reducer always exists in acyclic databases and can be obtained in polynomial time [4].
The full reducer itself runs in polynomial time.
Finally, note that a join tree of an acyclic join can be obtained in linear time [21].
[22] proposes then Algorithm 1 for computing the result to a project-join expression on an acyclic database, that we reuse with slight modifications in our next proposition.Algorithm 1 Result to a project-join expression on an acyclic database (after [22])Input: An acyclic join expression ϕ, a project expression ψ, an instance I.
An important property of this algorithm is that, at all time, the size of the relation stored in node r of T is bounded by the original (reduced) size of r times the size of the final output.
This means in particular that this algorithm computes in polynomial time the result to the project-join expression.
Actually, the same algorithm can be applied when repaired formulas are considered, since the only selection performed is a conjunction of constraints (equality and negated equality) on a given variable: These selections can be pushed inside the join.Proposition 13.
Validity facyc and Explanation facyc are in PTIME.Zero-Repair is then tractable in L facyc .
One might hope that this tractability extends to Cost.
Unfortunately, we now show the NP-hardness of Cost facyc , even for a very simple schema mapping.
For this purpose, we shall first need a quite general result on the minimal size of a vertex cover in a r-partite r-uniform hypergraph (for r 3).
A hypergraph is r-partite if the set of vertices can be decomposed into an r-partition, such that no two vertices of the same partitioning subset are in a same hyperedge.
It is r-uniform if all hyperedges have a cardinality of r.
A vertex cover of a hypergraph is a subset X of the set of vertices, such that for every hyperedge e, at least one of the elements of Zero-Repair Π P 2 -complete DP, (co)NP-hard DP, (co)NP-hard PTIMECost Σ P 3 , Π P 2 -hard Σ P 2 , (co)NP-hard Σ P 2 , (co)NP-hard NP-complete Existence-Cost Σ P 3 , NP-hard Σ P 2 , NP-hard Σ P 2 , NP-hard NP-complete Optimality Π P 4 , (co)NP-hard Π P 3 , (co)NP-hard Π P 3 , (co)NP-hard Π P 2 , (co)NP-harde is in X.
In regular graphs, Vertex-Cover (determining whether there is a vertex cover of size K) is one of the most known and useful NP-complete problems [11].
This obviously implies that Vertex-Cover is NP-hard in general hypergraphs.
Note that a 2-partite 2-uniform hypergraph is just a bipartite graph, and Vertex-Cover in bipartite graphs is PTIME, thanks to K˝ onig's theorem [6,16] which states that the maximal number of matchings in a bipartite graph is the mimimum size of a vertex cover.Lemma 14.
The problem of, given an r-partite r-uniform hypergraph H and a constant K, determining whether there exists a vertex cover in H of size less than or equal to K is NP-complete for r 3.
Proof.
This problem is clearly in NP: Just guess a set of vertices of size less than or equal to K and check in polynomial time whether it is a vertex cover.
For the hardness part, we prove the case r = 3; there is an obvious reduction from this case to the same problem for other values of r.
We use a reduction from 3SAT.
Note that this result appears in [14], but the reduction presented there is not exhaustive (in particular, nothing is said about interdependencies between clauses, or the fact that the hypergraph is tripartite) and it is not clear whether the proof was indeed led to completion.
We use here a proof inspired by the proof that 3-Dimensional-Matching is NPhard in [11].
Let ϕ = V n i=1 ci be an instance of 3SAT, where the ci are 3-clauses over some set x of variables.
We build a tripartite 3-uniform hypergraph H = (V, E) (with vertex partition V = V1∪V2∪V3) in the following way (see Figure 1 for an illustration when ϕ = ¬z ∨ x ∨ y).
For each variable x ∈ x, we add 12 nodes and 6 hyperedges to H. 6 out of the 12 nodes are anonymous nodes which only appear in one hyperedge; they are denoted by •.
The other nodes are denoted x1, x2, x3, ¯ x1, ¯ x2, ¯ x3.
Intuitively, all xi's are in a minimum covering if and only if a valuation satisfying ϕ maps xi to true (similarly with the ¯ xi's and false).
For each i, xi and ¯ xi belong to Vi.
The so-called local hyperedges are shown in Table 2.
Then, for each clause ci, we add a single global hyperedge which contains the vertices corresponding to the variables appearing in ci, while taking into account their position in the clause and whether they are negated.
For instance, if ci = ¬z ∨ x ∨ y, we add a hyperedge (¯ z1, x2, y3).
This ensures that the hypergraph remains tripartite.This reduction is polynomial.
Let m be the cardinality of x.
We now show that ϕ is satisfiable if and only if there is a vertex cover in H of size less than or equal to 3m (or, equivalently, if there is a minimum vertex cover of size less than or equal to 3m).
V1 V2 V3 x1 • ¯ x3 • x2 ¯ x3 ¯ x1 x2 • ¯ x1 • x3 • ¯ x2 x3 x1 ¯ x2 •Suppose first that ϕ is satisfiable, and let ν be a valuation of x which satisfies ϕ.
Let us consider the following set S of vertices of H: For each x ∈ x, we add to S, x1, x2 and x3 if ν(x) is true, ¯ x1, ¯ x2 and ¯ x3 otherwise.
S is of cardinality 3m.
Observe that S covers all local hyperedges and, since ν satisfies ϕ, all global hyperedges.Suppose now that there is a minimum vertex cover S of size less than or equal to 3m.
Since anonymous vertices only appear in a single hyperedge, we can always assume that S does not contain any anonymous vertex (they can always be replaced by another vertex of the hyperedge).
Let Si be, for each 1 i m, the subset of Si containing only the vertices corresponding to the ith variable of x.
It is easy to see that |Si| 3 for all i, for all local hyperedges to be covered, which means that |Si| = 3 since | S Si| 3m.
Si forms a vertex cover of the local sub-hypergraph corresponding to the ith variable of x (let us call it x) and must cover the hyperedges of this sub-hypergraph.
But there are only two vertex covers of this sub-hypergraph of cardinality 3: Either Si contains all x k 's, or it contains all ¯ x k 's.
We consider the valuation ν of the variables in x which maps x to true in the first case, to false in the second.
Then, since S is a vertex cover of H, ν satisfies all the clauses of ϕ.We now use this lemma to prove the NP-hardness of Cost facyc .
Proposition 15.
Cost facyc is NP-hard.
Proof.
We consider the case where we only allow negated equalities x = c, and no equalities x = c, on the left-hand side of repairs of tgds, with x a universally quantified variable, as the proof is clearer.
Because of space constraints, discussion of the changes that have to be made in the general case is omitted.We reduce the vertex cover problem in tripartite 3-uniform hypergraphs to Cost facyc .
Let H be a tripartite 3-uniform hypergraph.
We consider the following instance of Cost facyc :• S = {(R, 3)} and R I is the representation of H as a threecolumn table, where each row corresponds to an edge, • T = {(R , 1)} and J = ∅;• • • • • • x1 ¯ x1 x2 ¯ x2 x3 ¯ x3 • • • • • • y1 ¯ y1 y2 ¯ y2 y3 ¯ y3 • • • • • • z1 ¯ z1 z2 ¯ z2 z3 ¯ z3• Σ = {∀x1∀x2∀x3 R(x1, x2, x3) → R (x1)} (this is obviously an acyclic tgd).
As J = ∅, any schema mapping fully explains J.
This also means that the only repairs of Σ to be considered are the ones that add a "xi = ci" term to the left-hand side of the single element of Σ.
A repair of Σ has to "cancel" somehow with these additions each tuple of R I .
In other words, the cost of Σ is size(Σ) + 2r, where r is the minimal number of conjuncts in a formula of the form V xi = ci, such that this formula is false for all tuples of R I .
Such a formula expresses a vertex cover in H, and H has a vertex cover of size less than or equal to K if and only if cost (I,J) (Σ) size(Σ) + 2K, which concludes the proof in this case.It is an open issue whether Cost is in PTIME for the very restricted case when the schema mapping consists of a single full tgd with a single binary relation symbol appearing once in the left-hand side.Combined Complexity for Acyclic TGDs.
The last subset of L tgd that we consider here is Lacyc.
1.
Validityacyc is coNP-complete.2.
Explanationacyc and Zero-Repairacyc are both NPhard.
3.
Explanationacyc is in PTIME if, for all existentially quantified variables y and for all constants c, there is at most one term y = c appearing in each formula of the schema mapping.
This is in particular the case if the schema mapping is a subset of Lacyc instead of L * acyc .
Note that we use for both hardness results the repairs themselves to encode the instance of a NP-hard problem: Although the tgd itself is acyclic, its repairs are not.
We could probably get polynomial algorithms for the same problems if we impose some acyclicity condition to repairs of a formula; this, however, would weaken our notion of optimality.
L tgd , L full , Lacyc, L facyc Validity PTIME Explanation PTIME Zero-Repair PTIME Cost (K fixed) PTIME Cost (Σ fixed)NP, NP-hard for some Σ Existence-Cost PTIME Optimality Π P 2 , (co)NP-hard for some Σ Combined Complexity of Existence-Cost and Optimality.
With the help of Lemma 14, we show the intractability of Existence-Cost and Optimality, in all considered languages:Proposition 17.
Existence-Cost (respectively, Optimality) is NP-hard (respectively, both NP-hard and coNP-hard) in all the following languages:L tgd , L full , Lacyc, L facyc .
Data Complexity.
As far as data complexity is concerned, the situation is simpler, since we do not have any difference in complexity for all four subsets of L tgd .
The results are presented summarized in Table 3.
Proposition 18.1.
If Σ is fixed, Validityrc is in PTIME.2.
If Σ is fixed, Explanation tgd is in PTIME.3.
If K is fixed, Cost tgd and Existence-Cost tgd are in PTIME.
4.
For some fixed value of Σ, Cost facyc is NP-hard.
5.
For some fixed value of Σ, the problems Optimality facyc and Optimality tgd are NP-hard and coNP-hard.
We study in this section some extensions of our optimality notion to (i) formulas of the full relational calculus; (ii) other apparently simpler functions of cost.Extension to the Relational Calculus.
We can extend the definitions of Section 3 to the language Lrc of relational calculus, by the following adaptation of the notion of repair.A repair of a schema mapping Σ ⊂ Lrc is a set of formulas obtained from Σ by a finite sequence of the following operations:• Replacing in a formula of Σ a sub-formula ∀x ϕ(x, y) (we also assume that ϕ does not start with a ∀ symbol, and that the sub-formula is not preceded by a ∀ symbol) by ∀x τ (x, z) → ϕ(x, y) where z is the set of variables free in ϕ and τ is a boolean formula over terms w = c of the following form:^ i ^ j zij = c ij !
→ xiαici !
with zij variables from z, xi variables from x, αi either = or =, and c ij and ci constants.
• Replacing in a formula of Σ a sub-formula ∃x ψ(x, y) (we also assume that ψ does not start with a ∃ symbol, and that the sub-formula is not preceded by a ∃ symbol) by ∃x ψ(x, y) ∧ τ (x, z) where z is the set of variables free in ψ and τ is a boolean formula over terms w = c of the following form:^ i ^ j zij = c ij !
→ xi = ci !
with zij variables from z, xi variables from x, and c ij and ci constants.
• Adding to Σ a ground fact R(c1 . . . cn) with R a relation of the target schema of arity n, and c1 . . . cn constants.We can check that this definition amounts to the same as Definition 4 if we restrict ourselves to L tgd .
We can then use the same definitions of the size and cost of a formula, and consider the same decision problems.
We have the following complexity results: Proposition 19.1.
Validityrc is PSPACE-complete; 2.
Explanationrc is co-recursively enumerable; 3.
Explanationrc and Zero-Repairrc are not recursive.Interestingly, the computability of Optimalityrc remains open.
It seems to be a "harder" problem than Zero-Repairrc, but as there is no simple reduction between them, we cannot even be sure that Optimalityrc is not recursive.
We do not even know whether it is recursively enumerable or corecursively enumerable (but Costrc and Existence-Costrc are both co-recursively enumerable because of the co-recursive enumerability of Zero-Repairrc).
Note that a related problem is studied in [10], where it is shown that determining whether there exists a schema mapping Lrc (without repairs) that is valid and explain all facts of the target instance is coNP and co-graph-isomorphismhard.
In the case of L * rc , such a mapping obviously always exists since one can enumerate all ground facts of the target instance.Variants of the Cost Function.
The definition of repairs and cost that we presented in Section 3 may appear, at first, unnecessarily complicated.
We argued in Section 4 for a justification of this notion by showing that it has nice properties with respect to instances that are derived from each other with elementary operations of the relational algebra.
We consider in this section two alternative definitions of cost and optimality of a schema mapping with respect to database instances, and show that neither, although simpler and perhaps more intuitive, present the same properties and are thus adapted to our context.We keep our notions of validity of a schema mapping, of full explanation of a database instance by a schema mapping, and of size of a schema mapping, and we want to consider alternative ways to characterize the cost of a given schema mapping.
The first idea is to assign as the cost of a schema mapping the minimal number of tuples that have to be added or removed to the target instance J for the schema mapping to become valid and to fully explain J. (Each tuple may also be weighted by its arity, to get something closer to our original cost definition.)
Thus, the cost of the empty schema mapping corresponds to the size of the target instance, as before, while the cost of a schema mapping that fully explains the target instance but also incorrectly explains some tuples is the (possibly weighted) number of such tuples.
This sounds like a reasonable definition, but it presents an important problem: We lose the linear bound on the cost of a schema mapping in the size of the data and the schema mapping itself.
Indeed, consider the following schema mapping, for a given n, where R is a source relation of arity 1 and R a target relation of arity n:˘ ∀x1 . . . ∀xn R(x1) ∧ · · · ∧ R(xn) → R (x1, . . . , xn) ¯ .
If J is empty, the cost of this schema mapping according to the definition given in this paragraph is |I| n (or n |I| n if we weight with the arity of the relations), which is exponential in the size of the schema mapping.
This combinatorial explosion discourages all hopes of getting an optimal schema mapping by local search techniques.
Besides, all the problems that we describe for the variant that we consider next also arise here.
An alternate definition of cost, close to the previous one but for which we still have a linear bound on the cost of a mapping is the following: The cost of a schema mapping Σ is the minimal number of tuples to add or remove from the source and target instances I and J so that Σ becomes valid and fully explains J.
As before, we assume that we weight tuples by their arity; we could also choose to add an arbitrary constant weight to operations on J with respect to operations on I, or to deletion with respect to addition of tuples, without much difference.
The linear bound is clear since we can just remove all tuples of I and of J for Σ to be valid and to fully explain J. However, there is still a fundamental problem with this definition, which can be seen by looking back at Section 4.
We showed there that, for elementary operations of the relational algebra, the definition of optimality of Section 3 yielded the same as the intuitive tgds expressing these operations.
This is not true any more here, however, in particular in the presence of selections and projections.
For projections, this is due to the fact that a schema mapping that predicts existentially quantified tuples has a higher cost than the same schema mapping where these existentially quantified relation atoms are removed.
We exhibit next a concrete example of database instances that illustrate the problem with selections.Example 20.
Let us consider instances I and J of the following schemata: S = {(P, 2)} and T = {(P , 1)}, where: I contains a list of titles of publications (as first attribute) along with their kind: article , book , report , etc.; J contains a list of book titles.
Let us assume that J and I contain the same book titles.
In other words, J = π1(σ 2=book (I)).
It is quite natural to expect Σ = {∀x∀y P (x, y) → P (x)} as the "optimal" schema mapping in the language of tgds for these database instances, and indeed, cost (I,J) (Σ) = 5 is minimal as soon as J is large enough and there is no hidden relation between the second attribute of I and J. Now, observe that with the variant proposed in the preceding paragraph, the cost will be: 3 + min (2 · (|I| − |J|), |J|) , which is, in all cases when there are more publications of another kind than book (a common situation), greater than the cost of the empty schema mapping, which is then the optimal schema mapping for these instances.Then, although our definition of optimality is a bit complex, it is much more adapted to the addressed problem than these simpler definitions, since it can capture such things as the worth of an existentially quantified relation atom, or the possibility of limiting the scope of a tgd with a simple selection.
We discussed a theoretical framework that addresses the problem of finding a schema mapping optimal with respect to a pair of database instances, based solely on the structure and occurrences of constants in the instances.
We showed that this problem is both NP-hard and coNP-hard even for a very restricted language, namely full acyclic tuple-generating dependencies.
This is not unexpected, since it is well known that such learning problems have high complexity even in very simple cases (see, for instance, [12] for ILP).
Such a study is still useful since (i) it provides a formal framework for the discovery of schema mappings; (ii) complexity lower bounds are useful to detect the source of the complexity; (iii) complexity upper bounds often give practical algorithms.There are a number of open theoretical issues, especially on the computability and precise complexity of Optimality, but the most obvious direction for future work would be to connect such a theoretical framework with practical heuristics and approximation algorithm; in particular, the relation to inductive logic programming has to be explored.
We believe that this is an especially important problem, and that discovering and understanding hidden relations in data is one of the most fundamental tasks of artificial intelligence.
Other problems of interest would be to improve our complexity upper bounds by generalizing the notion of acyclicity to that of bounded hypertree width [13], and to look at the same problems when some fixed set of preconditions on instances is given.
We would like to thank Serge Abiteboul and Yann Ollivier for their input and feedback about this work.
