In this paper we describe ZKBoo 1 , a proposal for practically efficient zero-knowledge arguments especially tailored for Boolean circuits and report on a proof-of-concept implementation.
As an highlight, we can generate (resp.
verify) a non-interactive proof for the SHA-1 circuit in approximately 13ms (resp.
5ms), with a proof size of 444KB.
Our techniques are based on the "MPC-in-the-head" approach to zero-knowledge of Ishai et al. (IKOS), which has been successfully used to achieve significant asymp-totic improvements.
Our contributions include: • A thorough analysis of the different variants of IKOS, which highlights their pros and cons for practically relevant soundness parameters; • A generalization and simplification of their approach, which leads to faster Σ-protocols (that can be made non-interactive using the Fiat-Shamir heuristic) for statements of the form "I know x such that y = φ (x)" (where φ is a circuit and y a public value); • A case study, where we provide explicit protocols, implementations and benchmarking of zero-knowledge protocols for the SHA-1 and SHA-256 circuits.
Since their introduction in the 80s [16], zero-knowledge (ZK) arguments have been one of the main building blocks in the design of complex cryptographic protocols.
However, due to the lack of practically efficient solutions for proving generic statements, their application in realworld systems is very limited.
In particular, while there is a large body of work considering the efficiency of ZK protocols for algebraic languages (following the seminal work of Schnorr for discrete logarithm [26]), things are quite different when it comes to general purpose ZK.
1 Sounds like Peekaboo.A notable exception is the recent line of work on succinct non-interactive arguments of knowledge (SNARKs) (e.g. Pinocchio [23], libsnark [4], etc.).
SNARKs are an extremely useful tool when the size of the proof and the verification time matters: SNARKs are less than 300 bytes and can be verified in the order of 5ms, which makes them perfect for applications such as ZeroCash [3].
However, on the negative side, SNARKs require very large parameters (which must be generated in a trusted way) and the time to generate proofs are prohibitive for many applications.
As an example, the running time of the prover for generating a proof for SHA-1 is in the order of 10 seconds.
There is an inherent reason for this inefficiency: current SNARKs technology requires to perform expensive operations (in pairing friendly groups) for each gate in the circuit.Jawurek et al. [21] proposed a different approach to efficient ZK, namely using garbled circuits (GC).
Using GC, it is possible to prove any statement (expressed as a Boolean circuit) using only a (low) constant number of symmetric key operations per gate in the circuit, thus decreasing the proving time by more than an order of magnitude.
On the flip-side, GC-based ZK are inherently interactive, and they still require a few public-key operations (used for implementing the necessary oblivious transfers).
In this paper we describe efficient ZK protocols for circuits based on the "MPC-in-the-head" paradigm of Ishai et al. [19] (IKOS).
In IKOS, a prover simulates an MPC protocol between a number of "virtual" servers (at least 3) and then commits to the views and internal state of the individual servers.
Now the verifier challenges the prover by asking to open a subset of these commitments.
The privacy guarantee of the underlying MPC protocol guarantees that observing the state of a (sufficiently small) subset of servers does not reveal any information.
At the same time, the correctness of the MPC protocol guarantees that if the prover tries to prove a false statement, then the joint views of some of the server must nec-essarily be inconsistent, and the verifier can efficiently check that.
By plugging different MPC protocols into this approach, [19] shows how to construct ZK protocols with good asymptotic properties.
However, to the best of our knowledge, no one has yet investigated whether the IKOS approach can be used to construct practically efficient ZK protocols.
This paper is a first step in this direction.Structure of the paper.
In Section 3 we describe the different variants of the IKOS framework.
IKOS presents two strategies to achieve a negligible soundness error: either repeating a passive secure MPC protocol with few parties, or using a single instance of an active secure MPC protocol with a large number of parties.
While IKOS only provides asymptotic estimates of the soundness parameters, we concretely estimate the soundness of IKOS with different kind of MPC protocols and show that, if one is interested in a (reasonable) soundness error of 2 −80 , then the version of IKOS without repetition does not (unfortunately) lead to any practical advantage.
Then (in Section 4) we present a new interpretation of the IKOS framework when instantiated with a 2-private 3-party version of the GMW [15] protocol, where each pair of parties is connected with an OT-channel.
We observe that in general the OT-channels can be replaced with arbitrary 2-party functionalities.
Since those ideal functionalities do not have to be implemented using cryptographic protocols (remember, they are executed between pair of virtual servers in a simulation performed by the prover), this increases the degrees of freedom of the protocol designer and allows to construct more efficient MPC protocols (or, as we prefer to call them, function decompositions) that can be used for constructing ZK protocols.
(Note that this class of protocol has not been studied before, since it does not lead to any advantage in the standard MPC setting, and therefore we expect future work to improve on our approach by designing better MPC protocols for this special setting.)
All resulting protocols are Σ-protocols (3-move honest-verifier zeroknowledge protocols with special soundness) which can therefore be made non-interactive in the random oracle model using the Fiat-Shamir heuristic.Finally (in Section 5) we describe how our approach can be used to construct very efficient ZK protocols for proving knowledge of preimages for SHA-1 and SHA-256.
The resulting proofs are incredibly efficient: the verification time is essentially the same as the verification time for SNARKs, but the prover runs approximately 1000 times faster.
On the negative side the size of our proofs scales linearly with the circuit size, but we believe that in some applications this is a desirable trade-off.
Recent Related Work.
Ranellucci et al. [25] proposed a general-purpose public-coin ZK protocol which can be based on any commitment scheme.
The asymptotic performances are the same as ours (both communication and computation complexity are linear in the circuit size) but the concrete constants are higher (e.g., the proofs are approximately 3 times larger and computation more than 10 times slower).
Hazay et al. [18] show how to extend the IKOS technique to the case of two-party MPC protocols (2PC) with application to adaptive ZK protocols.
It is an open question whether their approach might lead to concrete efficiency improvements.
Standard notations: For an integer n, we write [n] = {1, 2,.
.
.
,n} and, given A ⊆ [n], |A| denotes the cardinality of A.
We say that a function ε is negligible in n, ε(n) = negl(n), if for every polynomial p there exists a constant c such that ε(n) < 1 p(n) when n > c. Given two random variables X ad Y with support S, the statistical distance between X and Y is defined asSD(X,Y ) = 1 2 ∑ i∈S | Pr[ X = i ]−Pr[Y = i ] |.
Two families X = {X k } and Y = {Y k }, k ∈ {0,1}* of random variables are said to be statistically indistinguishable if there exists a negligible function ε(·) such that for every k ∈ {0, 1} * , SD(X k ,Y k ) ≤ ε(|k|).
They are said to be computationally indistinguishable if for every efficient non-uniform distinguisher D there exists a negligible function ε(·) such that for every k ∈ {0,1} * , | Pr[D(X k ) = 1] − Pr[D(Y k ) = 1] ≤ ε(|k|).
Consider a public function f : ({0, 1} k ) n → {0, 1} 񮽙 and let P 1 ,.
.
.
,P n be n players modelled as PPT machines.
Each player P i holds the value x i ∈ {0, 1} k and wants to compute the value y = f (x) with x = (x 1 ,.
.
.
,x n ) while keeping his input private.
The players can communicate among them using point-to-point secure channels CH i, j in the synchronous model.
These can be classical secure channels (i.e. encrypted channels) or more powerful channels (e.g. OT-channel [11,24]).
If necessary, we also allow the players to use a broadcast channel.
To achieve their goal, the players jointly run a n-party MPC protocol Π f .
The latter is a protocol for n players that is specified via the next-message functions: there are several rounds of communication and in each round the player P i sends into the channel CH i, j (or in the broadcast channel) a message that is computed as a deterministic function of the internal state of P i (his initial input x i and his random tape k i ) and the messages that P i has received in the previous rounds of communications.
The view of the player P j , denoted by View P j (x), is defined as the concatenation of the private input x j , the random tape k j and all the messages received by P j during the execution of Π f .
Each channel CH i, j defines a relation of consistency between views.
For instance, in a plain channel two views are consistent if the messages reported in View P j (x) as incoming from P i are equal to the outgoing message implied by View P i (x) (i 񮽙 = j).
More powerful channels (such as OT channels), are defined via some function ϕ and we say that two views are consistent if the view of the sender implies an input x to the channel and the view of the receiver implies an input y and contains an output z such that z = ϕ(x, y).
For instance, in OT channels x = (m 0 , m 1 ), y is a bit and z = m y .
Finally, the output y can be computed from any of the view View P i (x), i.e. there are n functions Π f ,1 ,.
.
.
,Π f ,n such that y = Π f ,i (View P i (x)) for all i ∈ [n].
In order to be private, the protocol Π f needs to be designed in such a way that a curious player P i can not infer information about x j with j 񮽙 = i from his view View P i (x).
An additional security property, robustness, assures that a cheating player P i (who may not follow the instructions in the protocol) can not mislead the honest players, who still compute the correct output y.
More precisely, we have the following definition.Definition 2.1.
• (Correctness) We say that the protocol Π f realizes f with perfect (resp.
statistical) correctness if for any inputx = (x 1 ,.
.
.
,x n ), it holds that Pr[ f (x) 񮽙 = Π f ,i (View P i (x)) ] = 0 (resp.
negligi- ble) for all i ∈ [n].
The probability is over the choice of the random tapes k i .
• (Privacy) Let 1 ≤ t < n, the protocol Π f has perfect t-privacy if it is correct and for all A ⊆ [n] satisfying |A| ≤ t there exists a PPT algorithm S A such that the joint views (View P i (x)) i∈A have the same distribution as S A ( f , (x i ) i∈A , y), for all x = (x 1 ,.
.
.
,x n ).
We will speak about statistical (resp.
computational) t-privacy if the two distributions S A ( f , (x i ) i∈A , y) and (View P i (x)) i∈A are statistically (resp.
computationally) indistinguishable.
• (Robustness) Let 0 ≤ r < n, the protocol Π f has perfect (resp.
statistical) r-robustness if it is correct and for all A ⊆ [n] satisfying |A| ≤ r even assuming that all the players in A have been arbitrarily corrupted, then Pr[ f (x) 񮽙 = Π f ,i (View P i (x)) ] = 0 (resp.
negligible) for all i ∈ A c .
In this section we recall the notion of zero-knowledge and Σ-protocols, we review the IKOS construction [19] for zero-knowledge, and we discuss different possible instantiations.
Let R ⊆ {0, 1} * × {0, 1} * be a binary relation representing some computational problem (e.g. R = {(y, x) | y = SHA-256(x)}).
We will interpret R as a binary function from {0, 1} * × {0, 1} * to {0, 1} (i.e. R(y, x) = 1 ⇔ (y, x) ∈ R) and we will assume that:• ∀ y and ∀ x, R(y, x) can be computed in polynomialtime by a probabilistic Turing machine;• there exists a polynomial p such that if R(y, x) = 1 then the length of x is less or equal to p(|y|).
Such relation is called NP relation.
With L we indicate the set of the yes-instances of the relationR, i.e. L = {y |∃x s.t. R(y, x) = 1}.
An argument for L is a cryptographic protocols between two players: the prover P and the verifier V with the following features.
We assume that both P and V are probabilistic polynomial time (PPT) machines and that they know y, an instance of the relation R.
The situation is that P wants to convince V that y ∈ L.
This clearly makes sense only if the prover has some advantage over the verifier.
Thus, we allow the prover to have an extra private input (for example P knows x such that R(y, x) = 1).
The protocol is described by instructions for the players and has different rounds of communication.
At the end of the protocol, the verifier outputs accept if he is convinced or reject otherwise.
If y ∈ L, we require that an honest verifier convinces an honest prover with probability 1 (the protocol is complete).
On the other hand, we say that the protocol has soundness error ε if for all y / ∈ L Pr[V (y) = accept ] ≤ ε, no matter what the prover does.
In other words, ε is an upperbound of the probability that a cheating prover makes an honest verifier output accept for a false instance.However, in many interesting cryptographic applications, the language L is trivial and therefore the soundness property gives absolutely no guarantees: for every string y there exist a x s.t., y =SHA-256(x).
In this case we need a stronger property, namely proof-of-knowledge (PoK), which informally states that the verifier should output accept only if the prover knows the value x.Finally, ZK protocols get their name from the zeroknowledge property: Here, we want to express the requirement that whatever strategy a cheating verifier follows, he learns nothing except for the truth of the prover's claim.
In particular, he can not obtain information about the private input of P.
This is captured using the simulation-paradigm and saying that the messages received by the verifier during the protocol can be efficiently simulated only knowing the public input y.
More precisely, we have the following requirement: for any corrupted PPT verifier V * , there is a PPT algorithm S (the "simulator") with access to V * such that the output of S(y) and the real conversation between P and V * on input y are indistinguishable.In the rest of the paper we will be concerned with public-coin two-party protocols with a specific communication pattern known as Σ-protocols.
Definition 3.1 (Σ-protocol).
A protocol Π R between two players P and V is a Sigma Protocol for the relation R if it satisfies the following conditions:• Π R has the following communication pattern:1.
(Commit) P sends a first message a to V ;2.
(Challenge) V sends a random element e to P;3.
(Prove) P replies with a second message z.• (Completeness) If both players P and V are honest and y ∈ L, then Pr[(P,V )(y) = accept ] = 1;• (s-special soundness) For any y and any set of s accepting conversations {(a, e i , z i )} i∈ [s] with e i 񮽙 = e j if i 񮽙 = j, a witness x for y can be efficiently computed;• (Special honest-verifier ZK) There exists a PPT simulator S such that on input y ∈ L and e outputs a triple (a 񮽙 , e, z 񮽙 ) with same probability distribution of real conversations (a, e, z) of the protocol.
Σ-protocols have several properties (e.g. parallel composition, witness indistinguishability) that make them a useful building block for many other cryptographic primitives (identification schemes, signatures, etc).
See [7] or [17, Chapter 6] for more details on this.
Here we are mainly interested in the following facts: First, Σ-protocols are public-coin protocols and thus they can be made non-interactive in the random oracle model using the Fiat-Shamir heuristic [12].
Second, there exist efficient transformations from Σ-protocols to fully-fledged ZK and PoK: indeed, it is possible to efficiently transform a Σ-protocol into a zero-knowledge argument (resp.
zero-knowledge proof of knowledge) with the addition of one additional round (resp.
two additional rounds).
Note finally that if the challenge e is chosen uniformly at random form a set of cardinality c, then s-special soundness implies a bound of (s−1)/c on the soundness error of the protocol: if y 񮽙 ∈ L, then there exist no x s.t. R(x, y) = 1, and therefore fixed any a there are at most s − 1 challenges such that an accepting conversation for them exists.
In 2007 Ishai et al. show how to use any MPC protocol and the commitment-hybrid (Com) model 2 to obtain a ZK proof for an arbitrary NP relation R with asymptotically small soundness error.
Here we briefly recall their construction and moreover we explicitly analyse its soundness error.
Let Π f be an MPC protocol that realizes any n-party function f with perfect correctness (Definition 2.1).
Depending on the features of Π f (privacy, robustness, communication channels used), [19] presents slightly different ZK protocols.
However, the general structure is always the same and is the structure of a Σ-protocol, see Figure 1.
The high-level idea is the following: assume that y ∈ L is the public input of the ZK protocol, while x is the private input of the prover (i.e. R(y, x) = 1).
The prover first takes n random values x 1 ,.
.
.
,x n such that x = x 1 ⊕ ··· ⊕ x n , then he considers the n-input function f y defined asf y (x 1 , ·· · , x n ) := R(y, x 1 ⊕ ··· ⊕ x n )and emulates "in his head" the protocol Π f y on inputs x 1 ,.
.
.
,x n .
After the emulation, he computes the commitments to each of the n produced views (i.e. Com(View P i (x)) for i = 1,.
.
.
,n).
After all the commitments have been stored, the verifier challenges the prover to open some of them (i.e. the challenge is a random subset of [n] of a given size).
Finally, the prover opens the requested commitments and the verifier outputs accept if and only if all the opened views are consistent with each other and with output 1.
Here we focus on the ZK protocols presented in [19] that assume a perfectly correct (and eventually perfectly robust) MPC protocol and we collect them in two versions.
Version 1 considers the case of an MPC protocol with t-privacy and perfect r-robustness with t > 1.
3 Version 2 shows that 2-privacy is not necessary condition and indeed considers the case of an MPC protocol with 1-privacy only.
The verifier and the prover have input y ∈ L.
The prover knows x such that R(y, x) = 1.
A perfectly correct and t-private n-party MPC protocol Π f y is given (2 ≤ t < n).
Commit: The prover does the following:1.
Sample random vectors x 1 ,.
.
.
,x n s.t.x 1 ⊕ ··· ⊕ x n = x;2.
Run Π f y (x 1 ,.
.
.
,x n ) and obtain the viewsw i = View P i (x) for all i ∈ [n];3.
Commit to w 1 ,.
.
.
,w n .
Prove: The verifier chooses a subset E ⊆ [n] such that |E| = t and sends it to the prover.
The prover reveals the value w e for all e ∈ E.Verify: The verifier runs the following checks:1.
If ∃ e ∈ E s.t. Π f ,e (View P e (x)) 񮽙 = 1, output reject; 2.
If ∃{i, j} ⊂ E s.t. View P i (x)is not consistent with View P j (x), output reject;3.
Output accept;Figure 2: The IKOS zero-knowledge protocol for the relation R in the commitment-hybrid model.Version 1: Let t and r be two integers, 2 ≤ t < n and 0 ≤ r ≤ t.
We assume that the protocol Π f y is perfectly correct and satisfies two more properties: perfect, statistical or computational t-privacy and perfect r-robustness.
In this version of the IKOS protocol ( Figure 2) the verifier is allowed to ask for the openings of t of the commitments Com(View P i (x)).
In this way, the zero-knowledge property follows easily by the t-privacy of the protocol Π f y .
For the analysis of the soundness error of this protocol we use the so-called inconsistency graph G. Given an execution of Π f y , the graph G has n nodes and there is an edge (i, j) if and only if the views of the players P i and P j are inconsistent.
Assume that y / ∈ L and that the execution of Π f y is not a correct one (otherwise Pr[V (y) = accept ] = 0 because of the checks in step 1 of the procedure Verify).
Then we have two cases:1.
There is in G a vertex cover set 4 B of size at most 4 B is a vertex cover set for the graph G if each edge in G is incident to at least 1 node in B.r. Intuitively, this means that in the current execution of Π f y only the players in B have been actively corrupted.
Indeed, if we remove the nodes in B, we obtain a graph without edges.
That is, all the players not in B have views consistent among them and we can consider these players honest.
Since the size of B is less or equal to the parameter r, the robustness property assures that for all the players not in B (honest players) the view implies a 0 output (the correct output of the protocol Π f y ).
The probability that the verifier will not see one of these views choosing t of them uniformly at random is less or equal to 5p 1 (n,t, r) = 񮽙 r t 񮽙񮽙 n t 񮽙 −12.
If the size of the minimum vertex cover is > r, then the graph G has a matching 6 of size > r/2.
The probability that the verifier accepts the wrong proof is equal to the probability that between the t nodes that he chooses there are no edges of G and this is less or equal to the probability that there are no edges from the matching.
Clearly, this probability reaches the maximum when the matching is the smallest possible, that is it has size k = 񮽙r/2񮽙 + 1.
In this situation the aforementioned probability isp 2 (n,t, r) = 񮽙 0 otherwise 񮽙 ∑ k j=0 2 j 񮽙 k j 񮽙񮽙 n−2k t− j 񮽙 񮽙 񮽙 n t 񮽙 −1 if n − 2k > 0In general, the soundness error is equal to the value p(n,t, r) = max{p 1 (n,t, r), p 2 (n,t, r)}.
Version 2: A second version of the protocol was proposed in [20] to show that 2-privacy is not a necessary condition for the IKOS construction.
In other words, we can construct ZK proofs in from 1-private MPC protocols.
Notice that in this case the MPC protocol is allowed to use only standard point-to-point secure channels.
The idea of the construction is very similar to the previous one, but now the prover commits to all the 񮽙 n 2 񮽙 channels in addition to committing to the n views.
The verifier picks a random i ∈ [n] and challenges the prover to open the view of the player P i and all the n − 1 channels CH i j incident to him.
Finally, the verifier accepts if the opened view is consistent with the channels and with the output 1.
Again, the ZK property follows from the privacy property of the MPC protocol: the information revealed to the verifier is implied by the view of a single player.
To compute the soundness error in this case, observe that for any 5 񮽙 r t 񮽙 is 0 if r < t. incorrect execution of Π f y there is at least one player P i such that View P i (x) is inconsistent with a channel CH i j .
The probability Pr[V (y) = accept ] is less or equal to the probability that V does not choose this index i. Therefore, the soundness error of this version is 1 − 1/n.
In this section we discuss and motivate some of our design choices.Which MPC protocol?
As discussed, IKOS can be instantiated with a large number of MPC protocols.
In particular, using MPC protocols with good asymptotic properties (such as [8,9], etc.), one can obtain ZK protocols with equally good asymptotic properties.
However in this paper we are concerned with concrete, constant size circuits, and we do not want to put any restriction on the shape or width of the circuits.
Thus, the best two choices are BGW [2] style protocols with t = r = 񮽙 n−1 3 񮽙 which use simple point-to-point channels and GMW [15] style protocols with t = n − 1, r = 0 which use OT channels between each pair of parties.
Then we have the following two cases:1.
(GMW [15]:) In this case the soundness error is 2 n and we open n − 1 views.
Note that in these protocols each party must communicate with every other party, thus the size of the proof for soundness 2 −σ is given byc · (n − 1) 2 log 2 (n) − 1 · σwhere c is a constant which depends on the exact protocol.
It is easy to see that the function grows with n and therefore smallest proofs are achieved with n = 3.
Looking ahead, our protocol in Section 4 has c = 1/2 and σ = 80 and therefore the size of the proof is 274 bits per multiplication gate.2.
(BGW [2]:) In this case the soundness error is given by p 2 (n, 񮽙 n−1 3 񮽙, 񮽙 n−1 3 񮽙).
To get soundness error ≤ 2 −80 , we get that n ≥ 1122 and therefore the number of opened views is 񮽙 n−1 3 񮽙 = 373.
Thus, even if each party only had to store a single bit for each multiplication gate, the size of the proof would already be larger than in the previous case.
MPC protocol with t = r = 񮽙 2 3 n 񮽙 it would be enough to use (n,t, r) = (92, 64, 64) to achieve soundness 2 −80 .
The existence of such a protocol, where in addition each party only needs to store ≤ 4 bits per multiplication gate, would give rise to ZK proofs of size smaller than the one we construct.
We are not aware of any such protocols, however we cannot rule out their existence.
In particular, we note that such protocols have not been considered in the literature, since they give rise to poor MPC protocols in practice (note that such a protocol necessarily uses advanced channels, which in the standard MPC protocol need to be implemented using expensive cryptographic operations), and we believe that the quest for "MPC protocols" optimized for the ZK applications has just begun.
Figure 3 shows how, for a fixed number of parties n, the soundness error decreases as a function of t = r. Note that the soundness error for 2 3 n is much smaller than 1 3 n.Why only perfect correctness and robustness?
[19] presented also two extensions of the basic construction that allow to use MPC protocol with statistical correctness or with statistical robustness, but we are not considering those cases here for two reasons: first, the resulting ZK protocols have higher round complexity (and are therefore not Σ-protocols); second, perfectly secure MPC protocols are more efficient: practically efficient MPC protocols which only achieve statistical security (even when allowing arbitrary two-party channels, such as in [5,22]) require parties to store tags or MACs together with their shares, and to make sure that the sta-tistical error is negligibly small these tags need to be at least as long as the security parameter 7 , whereas in perfectly secure MPC protocols the share size can be made constant.Why not Version 2?
Note that the soundness error of Version 1 with (n,t, r) = (3, 2, 0) is the same as the soundness error of Version 2 with (n,t, r) = (3, 1, 0), thus the number of required rounds is exactly the same.
However (i) Version 2 requires to compute and open more commitments and (ii) Version 2 only works with plain channels, while Version 1 allows to use arbitrary channels which helps in constructing more efficient protocols.
This section contains a generalized and optimized version of the IKOS protocol that works for any relation defined by a function, φ : X → Y which can be decomposed in the "right way".
In particular, in Section 4.2 we will describe a ZK Σ-protocol for the relation R φ defined by R φ (y, x) = 1 ⇔ φ (x) = y, while the decomposition used to construct it is formalized in the following section.Protocol Π * φLet φ : X → Y be a function and D a related (2, 3)-decomposition as defined in Definition 4.1.
Input: x ∈ X 1.
Sample random tapes k 1 , k 2 , k 3 ;2.
Compute (x 1 , x 2 , x 3 ) ← Share(x; k 1 , k 2 , k 3 );3.
Let w 1 , w 2 , w 3 be vectors with N + 1 entries;• Initialize w i [0] = x i for all i ∈ {1, 2, 3};• For j = 1,.
.
.
,N, compute:• For i = 1, 2, 3, computew i [ j] = φ ( j) i 񮽙 (w m [0.
.
j − 1], k m ) m∈{i,i+1} 񮽙 4.
Compute y i = Output i (w i , k i ) for i ∈ {1, 2, 3};5.
Compute y = Rec(y 1 , y 2 , y 3 );Output: y ∈ Y Figure 4: Given a correct decomposition D, the protocol Π * φ can be used to evaluate the function φ .
7 This can be avoided for SIMD computations [10].
Given an arbitrary function φ : X → Y and an input value x ∈ X we want to compute the value φ (x) splitting the computation in 3 branches such that the values computed in 2 branches reveals no information about the input x.
In order to achieve this, we start by "splitting" the value x in three values x 1 , x 2 , x 3 (called input shares) using a surjective function that we indicate with Share.
These input shares as well as all the intermediate values are stored in 3 string w 1 , w 2 , w 3 called the views.
More precisely, w i contains the values computed in the computation branch i.
In order to achieve the goal and compute the value y = φ (x), we use a finite family of efficiently computable functions that we indicatewith F = 񮽙 N j=1 {φ ( j) 1 , φ ( j) 2 , φ ( j) 3 }.
The function φ ( j)m takes as inputs specific values from the views w m , w m+1 with m = {1, 2, 3} and where 3+1 = 1.
The functions are used in the following way: we use functions φ( j) 1 , φ ( j) 2 , φ ( j)3 to compute the next value to be stored in each view w m : The function φ (1) m takes as input w m , w m+1 (which at this point contain only the shares x m , x m+1 ) and outputs one value which is saved in position 1 of the views w m .
We continue like this for all N functions, with the difference that in step j > 1, the function φ ( j) m can receive as input (any subset of) the current views w m , w m+1 .
The initial function Share and all subfunctions φ ( j) m are allowed to be randomized, and they get their coins from k 1 , k 2 , k 3 , three random tapes which correspond to the three branches.
Finally, after the N steps described, the 3 functions Output 1 , Output 2 , Output 3 are used to compute the values y i = Output i (w i ) that we call output shares.
From these three values we compute the final output y = φ (x) using the function Rec.
The entire procedure is described in detail in Figure 4 (Protocol Π * φ ).
Definition 4.1.
A (2, 3)-decomposition for the function φ is the set of functions Figure 4, we have the following definitions.D = {Share, Output 1 , Output 2 , Output 3 , Rec} ∪ F such• (Correctness) We say that D is correct if Pr[ φ (x) = Π * φ (x)] = 1 for all x ∈ X.
The probability is over the choice of the random tapes k i .
• (Privacy) We say that D has 2-privacy if it is correct and for all e ∈ [3] there exists a PPT simulator S e such that ({k i , w i } i∈{e,e+1} , y e+2 ) and S e (φ , y)have the same probability distribution for all x ∈ X.w 1 [0] = x 1 w 2 [0] = x 2 w 3 [0] = x 3 Share x φ (1) 1 φ (1) 2 φ (1) 3 φ (2) 1 φ (2) 2 φ (2) 3 . . . . . . . . .
Output 1 Output 2 Output 3 Rec y x 1 x 2 x 3 w 1 [1] w 2 [1] w 3 [1] w 1 w 2 w 3 w 1 [2] w 2 [2] w 3 [2]y 1 y 2 y 3Figure 5: Pictorial representation of a (2,3)-decomposition of the computation y = φ (x) showing the three branches.
We present here an explicit example of a convenient (2,3)-decomposition.
Let Z be an arbitrary finite ring such that φ : Z k → Z 񮽙 can be expressed by an arithmetic circuit over the ring using addition by constant, multiplication by constant, binary addition and binary multiplication gates 8 .
The total number of gates in the circuit is N, the gates are labelled with indices in [N].
The linear (2,3)-decomposition of φ is defined as follows:• Share Z (x; k 1 , k 2 , k 3 ) samples random x 1 , x 2 , x 3such that x = x 1 + x 2 + x 3 ;• The familyF Z = 񮽙 N c=1 {φ (c) 1 , φ (c) 2 , φ (c)3 } is defined in the following way.
Assume that the c-th gate has input wires coming from the gate number a and the gate number b (or only gate number a in the case of a unary gate), then the function φ w i [c] = φ (c) i (w i [a]) = 񮽙 w i [a] + α if i = 1 w i [a] else − unary "mult.
α" gate, then ∀ i ∈ [3]:w i [c] = φ (c) i (w i [a]) = α · w i [a]− binary addition gate, then ∀ i ∈ [3]:w i [c] = φ (c) i (w i [a], w i [b]) = (w i [a] + w i [b]) − binary multiplication gate, then ∀ i ∈ [3]:w i [c] = φ (c) i 񮽙 w i [a, b], w i+1 [a, b]) 񮽙 = w i [a] · w i [b] + w i+1 [a] · w i [b] + w i [a] · w i+1 [b] + R i (c) − R i+1 (c)where R i (c) is a uniformly random function sampled using k i .
• For all i ∈ [3], Output Z i (w i , k i ) simply selects all the shares of the output wires of the circuit;• Finally, Rec Z (y 1 , y 2 , y 3 ) outputs y = y 1 + y 2 + y 3 above is a (2,3)-decomposition.
Moreover, the length of each view in D Z is (k + N + 񮽙) log |Z| + κ bits.Proposition 4.1.
The decomposition D Z = {Share Z , Rec Z , Output Z 1 , Output Z 2 , Output Z 3 } ∪ F Z definedCorrectness of the decomposition follows from inspection.
Privacy can be shown by constructing an appropriate simulator as shown in Appendix A In the linear decomposition just presented, the parameter N is equal to the total number of gates (unary and binary) in the circuit computing φ .
It is easy to slightly modify the definition of the functions φ (c) i in D Z in such a way that N results equal to the number of multiplication gates only.
In particular, note that the evaluation of addition gates (both unary and binary) only requires computation on values from the same branch, thus they can be embedded in a generalized multiplication gates which take as input arbitrary subsets of wires A, B, contains constants α, β , γ and computes the value:w[c] = 񮽙 ∑ a∈A α[a]w[a] 񮽙 · 񮽙 ∑ b∈B β [b]w[b] 񮽙 + γ Following the idea of [19], we turn a (2, 3)-decomposition of a function φ into a zero-knowledge protocol for statements of the form "I know x such that φ (x) = y".
We indicate with L φ the language {y |∃x s.t. φ (x) = y}.
Assume that a (2,3)-decomposition of the function φ is known (see Section 4.1).
The structure of the resulting protocol ( Figure 6) is very similar to the structure of the IKOS protocol.
If y ∈ L φ is the public input of the proof, then the prover P uses his private input x (with φ (x) = y) to run "in his head" the protocol Π * φ .
After the emulation of the protocol, P commits to each of the 3 produced views w 1 , w 2 , w 3 .
Now the verifier challenges the prover to open 2 of the commitments.
Finally, the verifier accepts if the opened views are consistent with the decomposition used and with output y. Proposition 4.2.
The ZKBoo protocol (Figure 6) is a Σ-protocol for the relation R φ with 3-special soundness.Proof.
Clearly, the ZKBoo protocol has the right communication pattern and it is complete given that the decomposition D is correct.
Moreover, the protocol satisfies the 3-special soundness property: consider 3 accepting conversations (a, i, z i ), i ∈ [3]: first note that thanks to the binding property of the commitment, the view w 1 contained in z 1 and the one contained in z 3 are identical, and the same holds for the other views w 2 , w 3 and random tapes k 1 , k 2 , k 3 .
Then, we can traverse the decomposition of φ backwards from the output to the input shares: since the three conversations are accepting, we have that Rec(y 1 , y 2 , y 3 ) = y, that y i = Output i (w i ) ∀i, and finally that every entry in all of w i was computed correctly.
Therefore, since the Share function is surjective, we can computex 񮽙 = Share −1 (w 1 [0], w 2 [0], w 3 [0]).
Thanks to the correctness of the decomposition we thus have that φ (x 񮽙 ) = y, which is what we wanted to prove.
Note that the protocol does not satisfy 2-special soundness, even if two accepting conversation actually contain all three views: in this case, since one of the branches of The verifier and the prover have input y ∈ L φ .
The prover knows x such that y = φ (x).
A (2,3)-decomposition of φ is given.
Let Π * φ be the protocol related to this decomposition.Commit: The prover does the following:1.
Sample random tapes k 1 , k 2 , k 3 ;2.
Run Π * φ (x) and obtain the views w 1 , w 2 , w 3 and the output shares y 1 , y 2 , y 3 ;3.
Commit to c i = Com(k i , w i ) for all i ∈ [3];4.
Send a = (y 1 , y 2 , y 3 , c 1 , c 2 , c 3 ).
Prove: The verifier choose an index e ∈ [3] and sends it to the prover.
The prover answers to the verifier's challenge sending opening c e , c e+1 thus revealing z = (k e , w e , k e+1 , w e+1 ).
Verify: The verifier runs the following checks:1.
If Rec(y 1 , y 2 , y 3 ) 񮽙 = y, output reject; 2.
If ∃ i ∈ {e, e + 1} s.t. y i 񮽙 = Output i (w i ), output reject; 3.
If ∃ j such that w e [ j] 񮽙 = φ ( j) e 񮽙 w e , w e+1 , k e , k e+1 񮽙 output reject;4.
Output accept; 񮽙 w i , w i+1 , k i , k i+1 񮽙 .
To prove the special honest-verifier ZK property, we consider the simulator S defined by the following steps.
The input are y ∈ L φ and e ∈ [3]: run the 2-privacy simulator (which is guaranteed to exist thanks to the 2-privacy property of the decomposition D as in Definition 4.1), which returns ({k i , w i } i∈{e,e+1} , y e+2 ), sets w e+2 = 0 |w| , k e+2 = 0 |k| and then constructs a by committing to the three views and tapes.Efficiency.
Let φ : Z k → Z 񮽙 be a function that can be expressed by a circuit over the finite ring Z with N mul-tiplication gates.
If we repeat σ (log 2 3 − 1) −1 copies of the ZKBoo protocol instantiated with the linear decomposition described in Section 4.1.1, and where we generate the random tapes pseudo-randomly with security parameter κ, we get a Σ-protocol with soundness 2 −σ and bit-sizeσ (log 2 3 − 1) −1 · 2 · [log 2 (|Z|)(k + N + 񮽙) + κ] In this section we describe our case study, in which we implemented the protocol described in Section 4 for proving knowledge of preimages of SHA-1 and SHA-256.
We start describing the choices we made in our implementation, describe the result of our empirical validation and finally compare with state-of-the-art protocols for the same task.
Our implementation is available at https://github.com/Sobuno/ZKBoo.
The linear-decomposition protocol described in Section 4 can be used with arithmetic circuits over arbitrary rings.
Our first choice is picking a ring in which to express the computation of SHA-1/SHA-256.
The two functions are quite similar, and they both use vectors of 32 bits for internal representation of values.
Three kind of operations are performed over these bit-vectors: bitwise XORs, bitwise ANDs, and additions modulo 2 32 .
Implementing the two algorithms (after some simple optimization to reduce the number of bitwise ANDs) requires the following number of operations 9 :AND XOR ADD SHA-1 40 372 325 SHA-256 192 704 600 Hence, the two natural choices for the ring are Z 2 (where XOR gates are for free but AND/ADD require 32 multiplication gates) and Z 2 32 (where ADD is free but bitwise operations require a linear number of multiplication gates).
Since the number of XORs dominates in both algorithms, we opted for an implementation over the ring Z 2 .
We wrote our software in C, using the OpenSSL 10 library.
We instantiated the building blocks in our protocol in the following way: RNG: We generate the random tapes pseudorandomly using AES in counter mode, where the keys are generated via the OpenSSL secure random number generator.
In the linear decomposition of multiplication gates, we use a random function R : [N] → Z 2 .
We implement this function by picking a bit from the stream generated using AES.
In particular, we computeR(i) = AES(K, 񮽙i/128񮽙)[i mod 128]which means that 3 calls to AES are sufficient to evaluate 128 individual AND gates.
Note that since N (the number of AND gates) is known in advance, we can precompute all calls to AES at the beginning of the protocol.
These two optimizations, together with the native support for AES in modern processors, proved very effective towards decreasing running times.
Commitments: In the first step of the protocol the prover commits to the three views w 1 , w 2 , w 3 .
Those commitments have been implemented using SHA-256 as the commitment function i.e., Com(x, r) = SHA-256 (x, r).
Under the (mild) assumptions that SHA-256 is collision resistant and that SHA-256(·, r) is a PRF (with key r) the commitments are binding and hiding.
The Fiat-Shamir Oracle.
To make the proofs noninteractive, we need a random oracle H : {0, 1} * → {1, 2, 3} r where r is the number of repetitions of our basic protocol.
We instantiate this using SHA-256 as a random oracle and by performing rejection sampling.
In particular, we compute the first output coordinate of H(x) by looking at the first two output bits of SHA-256(0, x) and mapping (a, b) → 2a + b + 1.
In case that (a, b) = (1, 1) we look at the third-fourth bit instead and repeat.
If there are no more bits left in the output of the hash function, we evaluate SHA-256 (1, x) and so on.
In our experiments the maximum number of repetition is r ∈ {69, 137}, thus we call the hash function once or twice (on expectation).
We report on the results of the implementation of SHA-1 and SHA-256 for 69 and 137 repetitions each.
Those correspond to soundness errors 2 −40 and 2 −80 .
While the security level 2 −40 is not sufficient for the case of noninteractive zero-knowledge, it offers reasonable security guarantees in the interactive case -note however that in this case our timings are only indicative of the local computation as they do not account for the necessary network communication.Our experiments were run on a machine with an AMD FX-8350 CPU, running 8 cores at 4.00 GHz.
The programs were run under Windows 10 Pro version 1511 (OS Build 10586.14) on a Seagate Barracuda 7200 RPM SATA 3.0 Gb/s hard drive with 16MB cache.
Note that computing and verifying our proofs is an embarrassingly parallel task, thus it was possible to effortlessly take advantage of our multi-core architecture using OpenMP 11 , an API useful for making a C program multi-threaded.
We note that we have only done this for the main loop of the program, which iterates over the individual repetitions of the proofs (which are clearly independent from each other), thus it is likely that there is room for further parallelisation.
Timings were done using C native clock() function and are measured in milliseconds.
Breakdown.
In Table 1 we report on the timings we obtained for both SHA-1 and SHA-256, with 69 and 137 rounds, both enabling and disabling parallelisation.
In this table we also present a breakdown of the running time.
In particular we measure the following phases for the prover:• Commit: This is the time to run the Commit procedure ( Figure 6) to produce a.
It is further divided into the following sub-timings: (Rand.
gen.) Generation of all needed randomness using OpenSSL RNG as well as preprocessing of the PRF; (Algorithm exec.)
Time taken to run the algorithm Π * φ .
This is the total time for all 69/137 rounds; (Commitment) Generating commitments of the views;• Gen. challenge: Using the random oracle to generate the challenge vector as e = H(y, a);• Prove: Building the vector z;• Output to disk: Writing (a, e, z) to disk; 12For the verifier:• Input from disk: Reading the proof from file;• Gen. challenge: Regenerate the challenge vector using the random oracle;• Verify: The time to run all the rounds of the Verify procedure;Finally, with proof size we indicate the size of the string π = (y, a, z) on disk in KB.Parallelisation.
Figure 7 and 8 show how the running time of the prover (resp.
verifier) changes when we change the number of rounds (from 1 to 137) and the number of threads (from 1 to 8 increases linearly with the number of rounds, and that the improvement due to multithreading is significant.
The graph indicates that there is some fluctuation in the algorithm's run time for all number of threads when using up to about 85 rounds, which is mostly due to the noise introduced by disk operations 13 .
We note that the runtime of the verifier benefits more from parallelisation.
This is consistent with Amdahl's law since, as shown in Table 1, the prover spends significantly more time performing tasks which do not benefit from parallelisation (e.g., writing to disk).
Here we compare the performances of ZKBoo with some of the state-of-the-art protocol for the same task.
In particular, we compare the performances of proving/verifying knowledge of SHA-1 preimages across ZKBoo, Pinocchio [23] and ZKGC [21].
Pinocchio [23] is an implementation of SNARKs for verifiable outsourcing of computation.
While not its main purpose, it can generate zero-knowledge proofs at a negligible extra cost over sound-only proofs.
The choice of benchmarking SHA-1 only (and not SHA-256) is due to the fact that the Pinocchio library only contains SHA-1.
The runtime reported for Pinocchio are obtained on the same machine as our implementation.
The results shows that ZKBoo is faster at both proving and verifying, with an incredible 10 3 factor for the prover.
Note here that if the underlying circuit had been larger, the proof size and the verification time of Pinocchio would not change, while its preprocessing and proving time would grow accordingly.
We note also that Pinocchio has a large preprocessing time where some prover/verifier key are generated.
Those keys are circuit dependent, and for SHA-1 the prover key is 6.5 MB and the verifier key is 1.1 MB.
To Pinocchio's defence, it must be noted that 1) Pinocchio is a general purpose system that can generate proofs for any circuit (provided as an input file) while our implementation contains the SHA circuit hard-coded; 2) according to [23], Pinocchio has not been parallelised; and 3) Pinocchio uses a SHA-1 circuit which is approximately 3 times larger than ours.
While it is conceivable that Pinocchio could be made faster using some of the optimizations introduced here, we do not believe that Pinocchio could ever reach proving times similar to ZKBoo, due to the use of heavy public-key technology (exponentiations in a pairing-friendly group) for each gate in the circuit.ZKGC [21].
For the case of ZKGC, we could not directly compare implementations, since the source code for [21] is not publicly available.
In addition, since the publication of [21], several significant improvements have been proposed but have not been implemented yet.
Therefore, in Table 2, we give an accurate estimate of the size of the proofs generated using ZKGC but only a lower-bound for its runtime.
The estimates are computed using the following tools: (GC) we estimate the proof size using the communication complexity of the most efficient (in terms of communication complexity) garbled circuits, namely privacy-free garbled circuits [13,27] that can be instantiated with as little as one ciphertext (128 bits using AES) per AND gate in the circuit; (OT) we plug the size and runtime given by the most efficient OT available [6].
Since the input size of SHA-1 is quite large (512 bits), it might be that using OT extension would prove useful.
Therefore, to make the comparison even more favourable towards ZKGC, we only count the runtime of 190 base OTs necessaries for active secure OT extensions [1] and we do not account at all for the runtime of the OT extension protocol nor the generation/verification of the GC.
The resulting estimates show that even when counting the base OTs alone, the runtime of ZKGC is already larger than the runtime of ZKBoo for the SHA-1 circuit.
As for proof size, we note that ZKGC produces shorter proofs.
However, the approach of ZKGC cannot be made non-interactive which is a qualitative drawback and it is likely to introduce significant slow-downs due to network latency.
In this paper we described ZKBoo, the first attempt to make general purpose zero-knowledge practical using the "MPC-in-the-head" approach of Ishai et al. [19].
We discussed how to generalize their protocol using the idea of (2, 3)-function decompositions, we showed simple linear decompositions for arithmetic circuits over any ring and we leave it as a future work to find compact decompositions for other interesting functions.Our experimental results show that for practically relevant circuits (such as SHA-1), our protocol is the fastest in terms of proving time, and where the verification time is comparable even with SNARKs technology.We now pass to prove the 2-privacy property.
Given e ∈ [3], we define the simulator S e on input y with the following instructions: , y 񮽙 e+2 ) It is easy to verify that the output of the simulator S e has the same distribution of the string ({k i , w i } i∈{e,e+1} , y e+2 ) produced by the protocol Π * φ .
Indeed, all the elements in the output of S e are computed using the same commands used in Π * φ , except for the element w 񮽙 e+1 [c] when the c-th gate is a multiplication gate.
In this case w 񮽙 e+1 [c] is sample uniformly at random, while w e+1 [c] in the protocol is computed using the function φ (c) e+1 .
In particular, w e+1 [c] is computed by subtracting to determined value the element R i+2 (c).
Since R i+2 is an uniformly random function sampled using an independent tape k e+2 , the distribution of w e+1 [c] in the protocol is the uniform one, that is it has the same distribution of w 񮽙 e+1 [c] in the output of S e .
Therefore, we can conclude that S e is a correct simulator for the decomposition D Z .
Finally, by inspection we have that |w i | = (k + N + 񮽙) log |Z| + κ for all i ∈ [3].
This project was supported by: the Danish National Research Foundation and The National Science Foundation of China (grant 61361136003) for the Sino-Danish Center for the Theory of Interactive Computation; the Center for Research in Foundations of Electronic Markets (CFEM); the European Union Seventh Framework Programme ( [FP7/2007[FP7/ -2013) under grant agreement number ICT-609611 (PRACTICE).
xProof of Proposition 4.1Proof.
In order to prove that the decomposition D Z is correct is enough to prove that for any c ∈ [N] the following holds.
(1) if the c-th gate is an "add α" gate, then:(2) if the c-th gate is an "mult.
α" gate, then:if the c-th gate is an addition gate, then:(4) if the c-th gate is a multiplication gate, then:Indeed, using (1), (2), (3) and (4) iteratively for all the gates in the circuit we can prove thatx i ) and from this it follows thatThe first three follow trivially by the definition of the function φwhen the c-th gate is a an "add α", "mult.
α" and addition gate, respectively.
Now assume that the c-th gate is a multiplication gate.
Then, using the definition for the function φ for this case and recalling that the index values are computed modulo 3, we have that Proof of Proposition 4.1Proof.
In order to prove that the decomposition D Z is correct is enough to prove that for any c ∈ [N] the following holds.
(1) if the c-th gate is an "add α" gate, then:(2) if the c-th gate is an "mult.
α" gate, then:if the c-th gate is an addition gate, then:(4) if the c-th gate is a multiplication gate, then:Indeed, using (1), (2), (3) and (4) iteratively for all the gates in the circuit we can prove thatx i ) and from this it follows thatThe first three follow trivially by the definition of the function φwhen the c-th gate is a an "add α", "mult.
α" and addition gate, respectively.
Now assume that the c-th gate is a multiplication gate.
Then, using the definition for the function φ for this case and recalling that the index values are computed modulo 3, we have that
