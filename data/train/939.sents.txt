Nous présentons un algorithme distribué déterministe qui calcule pour tout graphe connexe simple non pondéré, un sous-graphe couvrant (spanner) avec O(kn 1+1/k) arêtes et un facteur d'étirement (2k − 1, 0), n étant le nombre de sommets du graphe et k un paramètre entier strictement positif.
Si n est inconnu l'algorithme termine en temps 3k − 2, sinon il termine en temps k. En se basant sur cet algorithme pour k = 2, nous construisons de façon déterministe un sous-graphe couvrant avec O(ε −2 n 3/2) arêtes et un facteur d'étirement (1 + ε, 2) en O(ε −1) temps, ε > 0 est un paramètre arbitrairement petit.
Nous complétons nos algorithmes par des bornes inférieures.
D'abord, nous montrons que k unités de temps sont nécessaires pour calculer un sous-graphe couvrant avec o(n 1+1/(k−1)) arêtes et un facteur d'étirement (2k − 1, 0) pour k ∈ {2, 3, 5}.
Ensuite, nous montrons que pour tout k > 1, si un algorithme distribué construit un sous-graphe couvrant H ayant moins de n 1+1/k+ε arêtes en temps t n ε , alors H a un facteur d'étirement au moins (1 + Ω(k/t), Ω(kn ε)).
Nos bornes sont valables aussi bien pour des algorithmes déterministes que probabilistes, avec ou sans la connaissance de n. Dans ce papier nous nous intéressons à la construction distribuée de structures efficaces de graphes, appelées spanners.
Les spanners permettent de couvrir les sommets d'un graphe en utilisant peu d'arêtes tout en préservant les distances.
Plus formellement, étant donné un graphe G = (V (G), E(G)) qui modélise un réseau d'interconnexion, un sous-graphe H de G tel que V (H) = V (G) est un (α, β)-spanner si pour tout couple de sommets u et v, d H (u, v) α · d G (u, v) + β, (avec d X (u, v) désignant la distance dans X entre u et v).
Le facteur d'étirement du spanner H est définit par le couple (α, β) et sa taille par |E(H)| (le nombre d'arêtes utilisées par le spanner).
En pratique, les spanners sont utilisés de façon explicite ou implicite comme structure de base dans plusieurs applications distribuées tels que, les synchroniseurs [2], le routage compact [1,11], les forêts couvrantes [3], etc.Étant donné un graphe G avec n sommets et un paramètre entier positif k 1, il est bien connu que G admet un (2k − 1, 0)-spanner de taille O(n 1+1/k ).
Ce compromis entre la taille et le facteur d'étirement est considéré comme étant optimal d'après une conjecture d'Erdös [9] prouvée pour k ∈ {1, 2, 3, 5}.
Dans ce papier, nous considérons la complexité en temps de la construction de spanners optimaux avec des algorithmes distribués, c'est à dire dans un modèle de calcul où les sommets sont des entités autonomes de calcul pouvant communiquer en envoyant et en recevant des messages.
Le meilleur algorithme distribué déterministe existant [6] permet de construire des (4k − 3, 0)-spanner avec O(k · n 1+1/k ) arêtes en temps 2 O(k) log k−1 n. Le meilleur algorithme probabiliste [5] permet de construire un (2k − 1, 0)-spanner avec O(k · n 1+1/k ) arêtes en temps k. Cependant, ce dernier algorithme est de type Monte-Carlo, c'est à dire que les propriétés du spanner ne sont garanties qu'avec une certaine probabilité.
Ceci peut être problématique dans le cadre d'applications qui exigent des bornes sûres concernant les propriétés d'un spanner.
D'un point de vue plus fondamental, là où les algorithmes probabilistes permettent de calculer plusieurs structures de façon rapide, les algorithmes déterministes se voient ralentis considérablement notamment à cause des difficultés inhérentes aux problèmes de symétrie.
Casser la symétrie par des algorithmes déterministes est l'un des défis majeurs des calculs distribués.
Notre premier résultat est un algorithme distribué extrême-ment simple permettant de calculer de façon déterministe un (2k − 1, 0)-spanner de taille O(k · n 1+1/k ) en temps exactement k (n étant connu).
Notre algorithme possède en plus une propriété particulièrement intéressante : il ne nécessite pas la connaissance de n. Ceci n'est pas le cas des algorithmes (probabilistes ou déterministes) existants qui eux doivent connaître au moins une bonne approximation de n. Ceci rend notre algorithme particulièrement adéquat dans le cadre d'applications pratiques par exemple, dans des applications où le graphe est dynamique c'est à dire où des sommets peuvent apparaître et/ou disparaître.Par ailleurs, nous nous intéressons à un autre type de spanners dits additifs, c'est à dire des spanners où le facteur d'étirement est de la forme (1, β).
Seulement quelques spanners de ce type sont connus.
Plus précisément, il existe un(1, 2)-spanner avec O(n 3/2 ) arêtes [8] et un (1, 6)-spanner avec O(n 4/3 ) arêtes [4].
Cependant des constructions qui essayent de donner une approximation de spanners additifs existent.
Les algorithmes distribués les plus rapides [6] permettent de construire un spanner de taille O(n 3/2 ) avec un facteur d'étirement (1 + ε, 4) en temps n o(1) + O(ε −1 ) (ou O(log n + ε −1 ) temps en moyenne) ou avec un facteur d'étirement (1 + ε, 8 log n) en temps O(log n · ε −1 ).
Notre deuxième résultat est un algorithme distribué déterministe qui construit un (1 + ε, 2)-spanner de taille O(ε −2 n 3/2 ) en temps O(ε −1 ).
Là aussi, la connaissance de n n'est pas requise.Les algorithmes distribués que nous présentons sont complètement nouveaux dans le sens où ils ne sont pas une adaptation des techniques séquentielles ou distribués existantes (y compris celles probabilistes).
Finalement, nous complétons nos deux résultats par deux bornes inférieures.
Notre première borne montre que tout algorithme distribué (potentiellement probabiliste) nécessite au moins k temps pour calculer un (2k − 1, 0)-spanner de taille o(n 1+1/(k−1) ) pour k ∈ {2, 3, 5}.
En se basant sur la conjecture evoquée plus haut, le résultat reste vrai pour tout k > 1.
Notre deuxième borne inférieure montre que pour tout k > 1, il existe un ε > 0 tel que pour tout algorithme distribué construisant un spanner H pour G de taille inférieure à n 1+1/k+ε en temps n ε , il existe au moins deux sommets du graphe tel que d H (u, v) d G (u, v) + n Ω(ε) .
Ce résultat est en fait un corollaire d'un résultat plus technique qu'on donnera plus loin.
Nous considérons des graphes simples non pondérés.
Nous considérons le modèle de calcul classique de Linial [10].
Les sommets possèdent des identifiants uniques et ils effectuent des calculs de façon synchrone.
Chaque unité de temps, un sommet peut envoyer ou recevoir des messages de taille non limitée, et effectuer n'importe quel calcul local.
La complexité en temps est ainsi définie comme étant le nombre total d'unités de temps depuis le début de l'algorithme jusqu'à sa terminaison.
On note cependant que puisque on ne s'intéresse qu'au temps de calcul et non au nombre de messages échangés, un algorithme synchrone peut être adapté à un modèle asynchrone tout en gardant la même complexité en temps.Pour tout sommet u d'un graphe G, et pour tout entier positif r, nous définissons B G (u, r) le sous-graphe de G induit par les sommets à distance au plus r de u dans G. Nous omettrons de préciser G dans notre notation quand il n'y a pas d'ambiguïté.
L'idée générale de l'algorithme SPAN 2,t exécuté par un sommet u est de rajouter des plus courts chemins entre u et certains sommets du voisinage à distance O(t) de u. Ainsi, lorsqu'une longue distance est à approximer, on n'est pas obligé de payer un étirement 3 pour chaque arête.
Au contraire, on essaye de faire des sauts en utilisant les plus courts chemins que l'on a calculé.
En remarquant que les régions des sommets enlevés par la boucle sont disjointes et de taille supérieure à σ, on peut alors montrer le théorème suivant :Théorème 2 Pour tout ε ∈ (0, 4], il existe un algorithme distribué et déterministe tel que pour tout graphe connexe à n sommets (n n'est pas connu des sommets) calcule un (1 + ε, 2)-spanner avec O(ε −2 n 3/2 ) arêtes en temps O(ε −1 ).
Les preuves de nos bornes inférieures sont techniques et trop longues pour être exposées en détail.
Nous allons donc nous contenter de les énoncer et de donner la technique générale que nous avons utilisée.Un algorithme distribué éventuellement probabiliste opère toujours en cycles se composant d'une étape de communication suivie d'un calcul local.
La technique que nous utilisons se base sur l'observation suivante.
À un temps τ , un sommet u ne peut connaître que les identifiants des sommets à distance τ et les τ − d G (u, v) + 1 premiers choix aléatoires effectués par un sommet v. On peut ainsi définir la vue d'un sommet u, c'est à dire toute l'information que u peut avoir à sa disposition au bout d'un certain temps τ.
Ceci nous permet de définir l'état d'un sommet comme étant une fonction de sa vue.
Ainsi, deux sommets ayant la même vue auront forcément le même état indépendamment du graphe auquel ils appartiennent.La preuve de la première borne consiste à trouver deux familles de graphe pour lesquelles on peut trouver deux sommets ayant la même vue au bout d'un temps τ donné.
Mais, où un algorithme correct doit attribuer deux états différents à ces deux sommets.
Typiquement, pour le problème des spanners, un sommet doit décider de n'enlever aucune arête, alors que l'autre doit en enlever au moins une.
Ceci permet donc de prouver qu'un temps τ ne suffit pas pour résoudre le problème correctement.La preuve de la deuxième borne est techniquement différente.
Elle consiste à construire un graphe pour lequel on peut dire précisément, en s'appuyant sur les vues de certains sommets, quelles sont les arêtes qui doivent être enlevées du graphe pour garantir la taille désirée.
Ensuite, il s'agit de donner un chemin qui passe par ces arêtes et pour lequel la distance dans le spanner est forcément plus grande qu'une valeur qu'on sait calculer très précisément.
Ceci nous permet d'obtenir une borne sur le facteur d'étirement.
Les deux preuves s'appuient sur l'existence de graphes biparties dont la longueur du plus petit cycle est 2k + 2 et ayant c · n 1+Ψ(1/k) arêtes, avec c une constante, Ψ(k) = k si k ∈ {1, 2, 3, 5}, et Ψ(k) = 3k/2 sinon.
De plus, si la conjecture d'Erdos [9] est vraie alors Ψ(k) = k pour tout k. Théorème 3 Soit n, k des entiers vérifiant 1 < k log n. Soit un algorithme distribué A qui calcule pour tout graphe à n sommets un spanner de taille plus petite que c · n 1+1/Ψ(k−1) et un facteur d'étirement Ψ(k).
Alors, l'algorithme A a une complexité en temps au moins k.Théorème 4 Soit k, ε tel que 1 < k log n, et 1/ε > 3k 2 − k. Soit un algorithme distribué A qui calcule pour tout graphe à n sommets un spanner de taille plus petite que λ·n 1+1/Ψ(k) en temps t, pour k −3 t n ε et λ n ε .
Alors, il existe un graphe G et deux sommets u, v à distance d G (u, v) = Ω(tn ε ) tel que dans le spanner H calculé par l'algorithme A, on a :d H (u, v) > 1 + k − 1 t + 1 · d G (u, v) + 2k − 3 .
