We give an O(n log 3 n) algorithm that, given an n-node directed planar graph with arc capacities, a set of source nodes, and a set of sink nodes, finds a maximum flow from the sources to the sinks.
Previously, the fastest algorithms known for this problem were those for general graphs.
The maximum flow problem with multiple sources and sinks in a directed graph with arc-capacities is, informally, to find a way to route a single commodity from a given set of sources to a given set of sinks such that the total amount of the commodity that is delivered to the sinks is maximum subject to each arc carrying no more than its capacity.
In this paper we study this problem in planar graphs.The study of maximum flow in planar graphs has a long history.
In 1956, Ford and Fulkerson introduced the max st-flow problem, gave a generic augmenting-path algorithm, and also gave a particular augmentingpath algorithm for the case of a planar graph where s and t are on the same face Researchers have since published many algorithmic results proving running-time bounds on max st-flow for (a) planar graphs where s and t are on the same face, (b) undirected planar graphs where s and t are arbitrary, and (c) directed planar graphs where s and t are arbitrary.
The best bounds known are (a) O(n) [14], (b) O(n log log n) [17], and (c) O(n log n) [2], where n is the number of nodes in the graph.Maximum flow in planar graphs with multiple sources and sinks was studied by Miller and Naor [29].
When it is known how much of the commodity is produced/consumed at each source and each sink, finding a consistent routing of flow that respects arc capacities can be reduced to negative-length shortest paths, which we now know can be solved in planar graphs in O(n log 2 n/ log log n) time [30].
Otherwise, Miller and Naor gave an O(n log 3/2 n) algorithm for the case where all the sinks and the sources are on the boundary of a single face, and generalized it to an O(k 2 n 3/2 log 2 n)-time algorithm for the case where the sources and the sinks reside on the boundaries of k different faces.
1 However, the problem of maximum flow with multiple sources and sinks in planar graphs without any additional restrictions remained open.
In general (i.e., non-planar) graphs, multiple sources and sinks can be reduced to the single-source single-sink case by introducing an artificial source and sink and connecting them to all the sources and sinks, respectively-but this reduction does not preserve planarity.
For more than twenty years since the problem was explicitly stated and considered [29], the fastest known algorithm for computing multiple-source multiple-sink max-flow in a planar graph has been to use this reduction in conjunction with a general maximum-flow algorithm such as that of Sleator and Tarjan [32] which leads to a running time of O(n 2 log n).
For integer capacities less than U , one could instead use the algorithm of Goldberg and Rao [10], which leads to a running time of O(n 1.5 log n log U ).
No planarity-exploiting algorithm was known for the problem.Our Result The main result of this paper is an algorithm for the problem that is optimal up to a small poly-logarithmic factor.
Theorem 1.1.
There exists an algorithm that solves the maximum flow problem with multiple sources and sinks in an n-node directed planar graph in O(n log 3 n) time.Application to computer vision problems Multiple-source multiple-sink min-cut arises in addressing a family of problems associated with the terms metric labeling (Kleinberg and Tardos, [26]), Markov Random Fields [9], and Potts Model (see also [4,15]).
In low-level vision problems such as image restoration, segmentation, stereo, and motion, the goal is to assign labels from a set to pixels so as to minimize a penalty function.
The penalty function is a sum of two parts.
One part, the data component, has a term for each pixel; the cost depends on the discrepancy between the observed data for the pixel and the label chosen for it.
The other part, the smoothing component, penalizes neighboring pixels that are assigned different labels.For the binary case (when the set of available labels has size two), finding the optimal solution is reducible to multiple-source multiple-sink min-cut.
[12].
For the case of more than two labels, there is a powerful and effective heuristic [4] using very-large-neighborhood [1] local search; the inner loop consists of solving the two-label case.
The running time for solving the two-label case is therefore quite important.
For this reason, researchers in computer vision have proposed new algorithms for max flow and done experimental studies comparing the run-times of different max-flow algorithms on the instances arising in this context [3,27].
All of this is evidence for the importance of the problem.For the (common) case where the underlying graph of pixels is the two-dimensional grid graph, our result yields a theoretical speed-up for this important computer-vision subroutine.
2 Hochbaum [15] describes a special case of the penalty function in which the data component is convex and the smoothing component is linear; in this case, she shows that an optimal solution can be found in time O(T (m, n) + n log U ) where U is the maximum label, and T (m, n) is the time for finding a minimum cut.
She mentions specifically image segmentation, for which the graph is planar.
For this case, by using our algorithm, the optimal solution can be found in nearly linear time Application to maximum bipartite matching Consider the problem of maximum matching in a bipartite planar graph.
It is well-known how to reduce this problem to multiple-source, multiple-sink maximum flow.
Our result is the first planarity-exploiting algorithm for this problem (and the first near-linear one).
Techniques To obtain our result, we employ a wide range of sophisticated algorithmic techniques for planar graphs, some of which we adapted to our needs while others are used unchanged.
Our algorithm uses pseudoflows [11,16] and a divide-and-conquer scheme influenced by that of [19] and that of [29].
We adapt a method for using shortest paths to solve max st-flow when s and t are adjacent [13], and a data structure for implementing Dijkstra in a dense distance graph derived from a planar graph [8].
Among the other techniques we employ are: using cycle separators [28] recursively while keeping the boundary nodes on a constant number of faces [25,33,8], an algorithm for single-source single-sink max flow [2,7], an algorithm for computing multiple-source shortest paths [23,5], a method for cancelling cycles of flow in a planar graph [20], an algorithm for finding shortest paths in planar directed graphs with negative lengths [24,30], and a data structure for range queries in a Monge matrix [21].
We assume the reader is familiar with the basic definitions of planar embedded graphs and their duals (cf. [2]).
Let G = (V, E) be a planar embedded graph with node-set V and arc-set E.
We use the term arc to emphasize that edges are directed.
The term edge is used when the direction of an arc is not important.
For each arc a in the arc-set E, we define two oppositely directed darts, one in the same orientation as a (which we sometimes identify with a) and one in the opposite orientation [2].
We define rev(·) to be the function that takes each dart to the corresponding dart in the opposite direction.
It is notationally convenient to equate the edges, arcs and darts of G with the edges, arcs and darts of the dual G * .
Let S ⊂ V be a set of nodes called sources, and let T ⊆ V − S be a set of nodes called sinks.
A flow assignment f (·) is a real-valued function on darts satisfying antisymmetry:f (rev(d)) = −f (d) A capacity assignment c(·) is a real-valued function on darts.
A flow assignment f (·) respects the capacity of dart d if f (d) ≤ c(d).
f (·)is called a pseudoflow if it respects the capacities of all darts.For a given flow assignment f (·), the net inflow(or just inflow) node v is inflow f (v) = dart d:head(d)=v f (d) 3 .
The outflow of v is outflow f (v) = −inflow f (v).
A flow assignment f (·) is said to obey conservation at node v if inflow f (v) = 0.
A feasible flow is a pseudoflow that obeys conservation at every node other than the sources and sinks.
A feasible circulation is a pseudoflow that obeys conservation at all nodes.
The value of a feasible flow f (·) is the sum of inflow at the sinks, t∈T inflow f (t) or, equivalently, the sum of outflow at the sources.
The maximum flow problem is that of finding a feasible flow with maximum value.For two flow assignments f , f , the addition f + f is the flow that assigns f (d) + f (d) to every dart d.
A residual path in G is a path whose darts all have strictly positive capacities.
For two sets of nodes A, B, A G → B is used to denote the existence of some residual a-to-b path in G for some nodes a ∈ A and b ∈ B. Conversely, A G B is used to denote that no such path exists.
We will omit the graph G when it is clear from the context.The residual graph of G with respect to a flow assignment f (·) is the graph G f with the same arc-set, nodeset, sources and sinks, and with capacity assignment c f (·) such that for every dartd, c f (d) = c(d) − f (d).
It is well known that a feasible flow f in G is maximum if and only if S G f T .
Let f be a pseudoflow in a planar graph G. Let V + denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) > 0}.
Similarly, let V − denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) < 0}.
SupposeS ∪ V + G f T ∪ V − .
For a graph with n nodes and m edges, there exists an O(m log n)-time algorithm that converts the pseudoflow f into a maximum feasible flow f [19,32].
In planar graphs, this can be done in linear time by first canceling flow cycles using the technique of Kaplan and Nussbaum [20], and then by sending back flow from V + and into V − in topological sort order.
See Appendix C for details.
Consider the following recursive approach for finding a maximum multiple-source multiple-sink flow: split the input graph G in two using a simple cycle separator C [28] and recursively solve the max flow problem in the two subgraphs.
When the two recursive calls have been executed, in each of the two subgraphs there is no residual path from any source to any sink.
If we further make sure that in each of the two subgraphs there is no residual path from any source to C and from C to any sink, then, since C is a separator, there is no residual path from any source to any sink in G.We therefore solve a slightly more general problem recursively in the two subgraphs: roughly speaking, find a flow such that there is no residual path from a source to a sink or to C and no residual path from C to a sink (Section 2).
After the two recursive calls there is no residual path from any source to any sink in G. However, the requirement that there is no residual path from any source to C and from C to any sink cannot be achieved by a feasible flow but rather by a pseudoflow in which there might be excess inflow or excess outflow on nodes of C.
We deal with this by solving a new max flow problem where nodes of C are treated as sources and sinks, limited in supply/demand by their excess inflow/outflow (Section 3).
We exploit a relation between primal circulations and dual shortest paths to maintain a succinct representation of the flow during critical phases of the algorithm, using the fact that there are only O( √ n) sources and sinks, all cyclically ordered on C (Section 3.2).
Even though our representation does not explicitly store the flow on nearly any arc in the graph, we can augment it efficiently towards optimality while maintaining feasibility.
An important tool we use is Fakcharoenphol and Rao's efficient implementation of Dijkstra's algorithm [8], which we adapt to our needs.The resulting pseudoflow can then be turned into a max flow in linear time using existing techniques (Appendix C).
This leads to an O(n log 3 n) time algorithm for max flow.
Now we describe the algorithm, referred to as MultipleSourceMultipleSinkMaxFlow, in more detail.
In order to treat nodes of the cycle separator both as sources and as sinks in recursive calls, we introduce a new node set A.
At the top recursion level, A = ∅.
In general, A has constant size; more precisely |A| ≤ 6.
MultipleSourceMultipleSinkMaxFlow(G, c,S,T ,A) Input: a directed planar graph G with non-negative capacities c, a set S of source nodes, a set T of sink nodes, a set A of at most six nodes Output: a pseudoflow f obeying conservation everywhere but S, T, A and s.t.S G f T , S G f A, A G f T .
The algorithm finds a simple cycle separator C [28] and contracts all edges of C except one.
This, essentially, merges all the nodes of C into a single supernode v, and turns C into a self loop.
For simplicity of presentation we assume that no sources or sinks lie on C. 4 The algorithm then recursively solves the problem on the subgraphs enclosed and not enclosed by that self loop (the self loop itself need not be included in any of the subgraphs), adding the supernode v that represents C to the set A.
In order to keep the cardinality of A at most six, the algorithm alternately applies the cycle separator theorem with weights uniformly distributed on all nodes and uniformly distributed on only the nodes of A.
This technique is similar to that used in [25,33,8].
After the recursive calls, the algorithm uncontracts the edges of C.
At this stage there are no residual paths between sources and sinks in the entire graph, but there might be excess inflow (positive or negative) at the nodes of C.
The algorithm then calls the procedure FixConservationOnPath that pushes flow between the nodes of C so that there are no residual paths between nodes of C with positive inflow and nodes of C with negative inflow (the path in the name of the procedure is the cycle C without one edge).
This procedure is discussed in Section 3; the interface is:FixConservationOnPath(G, P, c, f 0 ) Input: a directed planar graph G, simple path P , capacity function c, and a pseudoflow f 0 Output: a pseudoflow f s.t. (i) f − f 0 satisfies conservation everywhere but P , and(ii) {v ∈ P : inflow(v) > 0} G f {v ∈ P : inflow(v) < 0}.
Running Time: O(n log 2 n/ log log n + |P | 2 log 2 n) Next, the algorithm iterates over the nodes a i of A.
The algorithm calls the procedure CycleToSingleSinkLimitedMaxFlow that, roughly speaking, pushes as much excess flow as possible from C to a i .
If C + i is the set of nodes of C that are reachable via residual paths from some node of C with positive inflow at the beginning of iteration i, CycleToSingleSinkLimitedMaxFlow pushes flow among the nodes of C + i and from the nodes of C + i to a i .
The result is that remaining inflow at nodes of C + i is non-negative and there are no residual paths from nodes of C with positive inflow to a i .
See Section 4; the interface is:CycleToSingleSinkLimitedMaxFlow(G, c, f 0 , C, a i ) Input: a directed planar graph G with capacities c, a pseudoflow f 0 , a simple cycle C, a sink a i .
Assumes: ∀v ∈ C + , inflow f0 (v) ≥ 0, where C + = {v ∈ C : {x ∈ C : inflow f0 (x) > 0} G f 0 → v}.
Output: a pseudoflow f s.t. (i) f − f 0 obeys conservation everywhere but C + ∪ {t}, (ii) ∀v ∈ C + , inflow f (v) ≥ 0, (iii) {v ∈ C : inflow f (v) > 0} G f a i .
Running Time: O(n log 2 n/ log log n + |C| 2 log 2 n).
A similar procedure SingleSourceToCycleLimitedMaxFlow is called to push flow from a i to C to eliminate as much negative inflow as possible (using a similarly defined set C − i ).
Finally, the algorithm pushes back flow from any nodes of C with positive inflow to S and pushes flow back from T into any nodes of C with negative inflow.
Input: a directed planar graph G with non-negative capacities c, a set S of source nodes, a set T of sink nodes, a set A consisting of a constant number of nodes A = {a i } k i=1 .
Output: a pseudoflow f obeying conservation everywhere except S, T, A and s.t.S G f T , S G f A, A G f T .1: add zero capacity arcs to triangulate and 2-connect G (required for simple cycle separators) 2: find a balanced (w.r.t. |G| and |A|, alternately) cycle separator C in G disjoint from S and T 3: let P be a path comprising of all of C's edges except one edge e 4: contract all the edges of P , turning e into a self loop incident to the only remaining node v of C 5: let G 1 and G 2 be the subgraph of G enclosed and not enclosed by e,respectively 6: f := MultipleSourceMultipleSinkMaxFlow(G 1 , c |G1 , S ∩ G 1 , T ∩ G 1 , (A ∩ G 1 ) ∪ {v}) 7: f := f + MultipleSourceMultipleSinkMaxFlow(G 2 , c |G2 , S ∩ G 2 , T ∩ G 2 , (A ∩ G 2 ) ∪ {v}) 8:uncontract the edges of P 9: f := FixConservationOnPath(G, P, c, f ) 10: for i = 1, 2, . . . , k 11:f := CycleToSingleSinkLimitedMaxFlow(G, c, f , C, a i ) 12:f := SingleSourceToCycleLimitedMaxFlow(G, c, f , a i , C) 13: push positive excess from C to S and negative excess to C from T 14: return f Correctness of Algorithm 1 The correctness of Algorithm 1 is proved in detail in Appendix A.
The proof consists of a sequence of lemmas that prove that each step of the algorithm eliminates some undesired residual paths without reintroducing undesired residual paths.
The arguments used are elementary.
The number of nodes of the separator cycle C used to partition G into G 1 and G 2 is O( |G|).
Therefore, each invocation of FixConservationOnPath, CycleToSingleSinkLimitedMaxFlow and SingleSourceToCycleLimitedMaxFlow in G takes O(|G| log 2 |G|/ log log |G| + |C| 2 log 2 |C|) = O(|G| log 2 |G|) time.The way we recursively partition into subgraphs is very similar to that of Fakcharoenphol and Rao [8].
In their algorithm, they spend O(|G | log 2 |G |) time on each subgraph G in the recursive decomposition and prove a total time bound of O(n log 3 n).
By the same arguments, our algorithm runs in O(n log 3 n) time.
In this section we present an efficient implementation of the fixing procedure which, roughly speaking, given a path with nodes having positive, negative, or zero inflow, pushes flow between the nodes of the path so that eventually there are no residual paths from nodes with positive inflow to nodes with negative inflow.
We begin by describing an abstract algorithm for the fixing procedure.
The abstract algorithm is given as Algorithm 2.
It is similar to a technique used by Venkatesan and Johnson [19].
Let M be the sum of capacities of all of the darts of G.
The algorithm first increases the capacities of darts of the path P and their reverses by M .
Let p 1 , p 2 , . . . , p k+1 be the nodes of P .
The algorithm processes the nodes of P one after the other.
Processing p i consists of decreasing the capacities of d i = p i p i+1 and rev(d i ) by M (i.e., back to their original capacities), and trying to eliminate positive inflow x at p i by pushing at most x units of flow from p i to p i+1 .
The intuition for doing so is that the flow after the push either obeys conservation at p i or there are no residual paths from p i to any of the other nodes of P (this is where we use the large capacities on the darts between unprocessed nodes).
See appendix B for a formal proof of correctness.
Negative inflow at p i is handled in a similar manner by pushing flow from p i+1 to p i .
Algorithm 2 AbstractFixConservationOnPath(G, P, c, f 0 ) Input: directed planar graph G, simple path P = d 1 d 2 . . . d k , capacity function c, and pseudoflow f 0 Output: a pseudoflow f s.t. (i) f − f 0 satisfies conservation at nodes not on P , and (ii) with respect to f , there are no residual paths from nodes of P with positive inflow to nodes of P with negative inflow.1: f = f 0 2: c[d] = c[d] + M for all darts d of P ∪ rev(P ) 3: for i = 1, 2, . . . , k 4:let p i and p i+1 be the tail and head of d i , respectively for d ∈ {d i , rev(d i )} 6: c[d] := c[d] − M 7: f [d] := min{f [d], c[d]} 8: f [rev(d)] := −f [d] 9:excess := inflow at p i 10:if excess > 0 then d := d i else d := rev(d i )find in which direction flow should be pushed add to f a maximum feasible flow from tail(d) to head(d) with limit excess 12: return f In this section, we give an inefficient implementation of line 11 of the abstract algorithm.
This will facilitate the explanation of the efficient procedure in the next section.
We first review the necessary ideas and tools.
An st-planar graph is a planar graph in which nodes s and t are incident to the same face.
Hassin [13] gave an algorithm for computing a maximum flow from s to t in an st-planar graph.
We briefly describe this algorithm here since we use it in implementing line 11 of Algorithm 2.
Hassin's algorithm starts by adding to G an artificial infinite capacity arc a from t to s. Let d be the dart that corresponds to a and whose head is t. Let t * be the head in G * of the dual of d. Compute in the dual G * a shortest path tree rooted at t * , where the length of a dual dart is defined as the capacity of the primal dart.
Let φ[·] denote the shortest path distances from t * in G * .
Consider the flowρ[d ] = φ[head G * (d )] − φ[tail G * (d )]for all darts d(1)After removing the artificial arc a from G, ρ is a maximum feasible flow from s to t in G.
We say that φ is a face potential vector that induces ρ.In our algorithm we are interested in a max flow with limit x from s to t rather than a maximum flow, i.e., a flow whose value is at most a given number x but is otherwise maximal.
It is not difficult to see that setting the capacity of the artificial arc a to x instead of infinity results in the desired limited max flow [22].
In our implementation, instead of using an artificial arc from t to s, we use an existing arc whose endpoints are s and t as the arc a above.
In order for this to work, the capacity of the dart d that corresponds to a and whose head is t must be zero (as is indeed the case if a is an artificial arc from t to s).
This can always be achieved by first pushing flow on d to saturate it.
Also note that in this case, we do not remove a from G. Hence, ρ is a feasible circulation, rather than a maximum flow, since flow is being pushed back from t to s along a. To convert it into a maximum flow one just has to undo the flow on a.
If we define f byf [d ] = −ρ[d ] if d corresponds to a 0 otherwise ,(2)then ρ + f is a maximum feasible st-flow.
We will use the fact that this flow can be represented implicitly by the face potential vector φ, and the flow values f [d ] for the two darts corresponding to a. Recall that f 0 is the flow at the beginning of the procedure.
Observe that the change to the flow in iteration i of the abstract algorithm (line 11) is a flow between the endpoints of the dart d i .
As discussed in Section 3.1.1, this flow can be represented as the sum of (i) a circulation ρ i and (ii) a flow on d i and rev(d i ).
Summing over the first i iterations, the flow f at that time can be represented as the sumf = ρ + f(3)where ρ = i j=1 ρ j is a circulation and f is a flow assignment that differs from f 0 only on the darts of {d j } i j=1 and their reverses.
The inefficient implementation of line 11 of the abstract algorithm appears as Algorithm 3.
We now describe it.
The total flow f is maintained by representing f and the circulation ρ as in Eq.
(3).
f is represented explicitly, but, in preparation for the efficient implementation, the circulations ρ j are represented implicitly by the face-potentials φ j .
By linearity of Eq.
(1), the sum φ = i j=1 φ j is the face potential vector that induces the circulation ρ.Recall that d is the dart of C such that flow needs to be sent from tail(d) to head(d) (line 10 of Algorithm 2).
In lines 1 -3, the procedure pushes as much as possible on d itself.
Consequently, either d is saturated or conservation at p i is achieved.Next, an implementation of Hassin's algorithm pushes a maximum flow with limit |inflow(p i )| from tail(d) to head(d).
The procedure first sets the length of darts to their residual capacities (line 4) and sets the length of rev(d) to be the flow limit |inflow(p i )| (line 5).
Since the flow maintained is feasible, all residual capacities are non-negative.
The procedure then computes all the head G * (d)-to-f distances φ i [f ] in G * using Dijkstra's algorithm (line 6).
Let ρ i be the circulation corresponding to the face-potential vector φ i .
The procedure sets val equal to ρ [d] in line 7, then subtracts val from f [d] and adds it to f [rev(d)].
Finally, in the last line, the current circulation is added to the accumulated circulation by adding the potential φ i to φ.Algorithm 3 Inefficient Implementation of line 11 of AbstractFixConservationOnPath (Algorithm 2)1: residual capacity := c[d] − f [d] − φ[head G * (d)] + φ[tail G * (d)]% push flow on d to make its residual capacity zero as required for Hassin's algorithm 2: val := min{residual capacity, |inflow(p i )|} amount of flow to push on d3: f [d] := f [d] + val ; f [rev(d)] := −f [d]% push excess inflow from tail(d) to head(d) using Hassin's algorithm 4: let [d ] := c[d ] − f [d ] − φ[head G * (d )] + φ[tail G * (d )] for all darts d ∈ G6: φ i (·) := Dijkstra(G * , , head G * (d)) face potential are distances in G * from head G * (d) w.r.t. residual capacities 7: val := φ i [head G * (d)] − φ i [tail G * (d)] In this section we give an efficient implementation of Algorithm 2.
We first review the necessary tools.
Let X be a set of nodes.
Let H be a planar graph in which the nodes of X lie a single face.
Let x 1 , x 2 , · · · be the clockwise order of the nodes of X on that face.
Let P be a set of darts not necessarily in the graph H whose endpoints are nodes in X. Fakcharoenphol and Rao [8] described a data structure that can be used in a procedure that efficiently implements Dijkstra's algorithm in H ∪ P .
The procedure takes as input a table D such that D [i, j] stores the distance between x i and x j in H, an array that stores the lengths of the darts in P , and a node v ∈ X.
It is assumed that the lengths in D and in are non-negative.
The procedure outputs the distances of the nodes of X from v in H ∪ P in O(|X| log 2 |X| + |P | log |X|)-time.We mention a technical issue whose importance will become apparent in the sequel.
The procedure partitions the table D into several subtables {D α } α that correspond to distances between pairs of disjoint sets of nodes of X, where each set consists of nodes that are consecutive in X.
It is assumed in [8, footnote on p. 884] that for each such subtable D α , a data structure that supports range minimum queries of the form min j1≤j≤j2 {D α [i, j]} for every i, j 1 , j 2 is given.
Fakcharoenphol and Rao note that such a data structure can be easily implemented by using a range-search tree [6] for every row i of D α .
The time required to construct all of the range-search trees for D α is proportional to the size of D α .
For a directed graph G with dart-lengths (·), a price function is a function φ from the nodes of G to the reals.
For a dart d, the reduced length with respect to φ is φ (d) = (d) + φ(tail(d)) − φ(head(d)).
A feasible price function is a price function that induces nonnegative reduced lengths on all darts of G (see [18]).
Single-source distances form a feasible price function.
Suppose that, for some node r of G, for every node v of G, φ(v) is the r-to-v distance in G with respect to (·).
Then for every arc uv, φ(v) ≤ φ(u) + (uv), so φ (uv) ≥ 0.
Here we assume, without loss of generality, that all distances are finite (i.e., that all nodes are reachable from r) since we can always add arcs with sufficiently large lengths to make all nodes reachable without affecting the shortest paths in the graph.We will use the following variant of Fakcharoenphol and Rao's efficient Dijkstra implementation.
The procedure FR(D, , φ X , v) takes as input the table D and the array as described above, as well as a feasible price function φ X on the nodes of X and a node v ∈ X.
It outputs the distances of the nodes of X from v in H ∪ P w.r.t. the reduced lengths w.r.t. φ X .
We stress that lengths in D and in may be negative, but the reduced lengths are all non-negative.
The computation takes O(|X| log 2 |X| + |P | log |X|) time.This differs from the procedure described in Section 3.2.1 only in the existence of the price function φ X .
We cannot afford to compute the entire table of reduced lengths since that would dominate the running time of the algorithm in [8].
Instead, whenever their algorithm requires some specific reduced length, we can compute it in constant time from D. This, however, does not suffice.
Recall that the algorithm in [8] requires that, for each of the subtables D α , range-search trees that support range minimum queries of the form min j1≤j≤j2{D α [i, j] + φ X [x i ] − φ X [x j ]} for every i, j 1 , j 2 are given.
Note that the results of such queries may be different for different price functions.
Computing the range-search trees would take O(|X| 2 ) which will dominate the running time of the entire procedure.
To overcome this difficulty we use Monge range-query data structures, due to Kaplan and Sharir [21], which can be constructed from the table D in O(|X| log |X|) time, and answer queries of the desired form in O(log |X|) time.
Finally, we describe the efficient implementation.
The procedure keeps track of the inflow at each node of P in an array v [·].
As in the inefficient implementation, the procedure will maintain the total flow as the sum of a circulation ρ and a flow assignment f that differs from f 0 only on the darts of P ∪ rev(P ).
Initially f is set equal to f 0 .
The circulation ρ will be represented by a face-potential vector φ.
However, we will show that it suffices to maintain just those entries of φ that correspond to faces incident to P .
Define each dart d's length by(d) = c[d] − f [d].
Let X * be the set of endpoints in the planar dual G * of the darts of P (i.e. the primal faces incident to P ).
Let H * be the graph obtained from G * by removing the darts of P .
Note that in H * , all the nodes of X * that did not disappear (i.e., that have degree greater than zero) are on the boundary of a single face, see Figure 1.
The procedure uses a multiple-source shortest paths (MSSP) algorithm [23,5] to compute a table D * [·, ·] of X * -to-X * distances in H * with respect to the lengths (·).
The implementation of lines 1-10 of the abstract algorithm using the chosen representation of f is straightforward.
We therefore focus on the implementation of line 11 of Algorithm 2, given as Algorithm 4.
Consider iteration i of the algorithm.
The main difference between the inefficient implementation and the efficient one is in implementing the Dijkstra step for computing shortest paths in the dual.
Instead of computing the entire shortest-path tree, the procedure computes just the distance labels of nodes in X * .
This is done using the FR data structure, whose initialization requires the X * -to-X * distances in H * with respect to the residual capacities.
We now explain how these distances can be obtained.The flow on a dart d in the primal isf [d] + φ[head G * (d)] − φ[tail G * (d)].
(4)Therefore the residual capacity of d is(c[d] − f [d]) − φ[head G * (d)] + φ[tail G * (d)](5)which is its reduced length φ [d] with respect to the length (·) and price function φ.
Suppose that d belongs to H * , i.e. d is not one of the darts of P ∪ rev(P ).
The procedure never changesf [d], so f [d] = f 0 [d].
Therefore (d) = c[d] − f 0 [d].
These lengths are known at the beginning of the procedure's execution.
The reduced length of an X * -to-X * pathQ = d 1 , d 2 , · · · , d j in H * is j i=1 ((d i ) − φ[head G * (d i )] + φ[tail G * (d i )]) = j i=1 (d i ) − φ[end(Q)] + φ[start(Q)].
(6)Therefore, for any nodes x, y ∈ X * , the x-to-y distance in H * w.r.t. the residual capacity is given byD * [x, y] − φ[y] + φ[x].
Since the procedure maintains the restriction of φ to faces of X * , this distance can be obtained in constant time.
Adapting FR's data structure to handle reduced distances w.r.t. a price function φ was discussed in Section 3.2.1.
Algorithm 4 Efficient Implementation of line 11 of AbstractFixConservationOnPath (Algorithm 2)1: residual capacity := c[d] − f [d] − φ X [head G * (d)] + φ X [tail G * (d)]% push flow on d to make its residual capacity zero as required for Hassin's algorithm2: val := min{residual capacity, |v[p i ]|} amount of flow pushed on d 3: f [d] = f [d] + val ; f [rev(d)] := −f [d] 4: v[tail(d)] = v[tail(d)] − val ; v[head(d)] = v[head(d)] + valupdate the inflow at pi and pi+1% push excess inflow from tail(d) to head(d) using Hassin's algorithm5: let [d ] := c[d ] − f [d ] for all darts d ∈ P ∪ rev(P )lengths of explicit darts are residual capacities (not including circulation component)6: [rev(d)] := |v[p i ]| − φ X [tail G * (rev(d))] + φ X [head G * (rev(d))]set the limit on the residual capacity of rev(d) (adjusted by circulation component)7: φ X i (·) := F R(D * , , φ X , head G * (d)) face potential are distances in G * from head G * (d) w.r.t. the reduced lengths induced by φ X 8: val := φ X i [head(d)] − φ X i [tail(d)]the amount of flow assigned to d by the circulation corresponding to φ Xi 9: f [d] := f [d] − val ; f [rev(d)] := −f [(d)]do not push the circulation on d and rev (d) 10:φ X = φ X + φ X i accumulate the current circulation 11: v[tail(d)] = v[tail(d)] − val ; v[head(d)] = v[head(d)] + valupdate the inflow at pi and pi+1It follows from the above discussion that, after executing line 11 of Algorithm 2 using the efficient implementation (Algorithm 4) for the last time, the flow assignment f maintained by the efficient implementation is the same as the one that would have been computed if the inefficient implementation (Algorithm 3) were used.
Moreover, the potential function φ X computed by the efficient implementation is the restriction to X * of the potential function φ that would have been computed by the inefficient implementation.In order to output the flow f in the entire graph G, we need to know the potential function φ rather than just its restriction φ X .
Observe, however, that any pseudoflow that differs from f by a circulation is a valid output of FixConservationOnPath since a circulation does not change the inflow at any node, nor does it introduce residual paths between nodes that are not connected by a residual path in G f .
It therefore suffices to find any feasible circulation χ in G f .
This can be done by computing shortest paths in G * w.r.t. the lengths := c − f from an arbitrary node x ∈ G * .
Note, however, that for darts of P ∪ rev(P ) these lengths might be negative.
We therefore use the O(n log 2 n/ log log n)-time algorithm for shortest paths with negative lengths in planar graphs [30] to compute a feasible circulation χ.
5 The pseudocode for the efficient implementation of FixConservationOnPath is given in appendix D.Running Time Analysis Let n and k be the number of nodes in G and in P , respectively.
The initialization time is dominated by the O(n log n + k 2 log n) time for MSSP.
The execution of each iteration of the main loop is dominated by the call to FR, which takes O(k log 2 k) time.
The number of iterations is k − 1, leading to a total of O(k 2 log 2 k) time for execution of the main loop.
Computing the circulation χ requires one shortest path computation, which takes O(n log 2 n/ log log n) time.
Thus total running time of the efficient implementation of FixConservationOnPath is O(n log 2 n/ log log n + k 2 log 2 k).
In this section we describe the procedure CycleToSingleSinkLimitedMaxFlow that pushes excess inflow from a cycle to a node not on the cycle.
The procedure is given as Algorithm 5.
The procedure SingleSourceToCycleLimitedMaxFlow is very similar.
We omit its description.Algorithm 5 CycleToSingleSinkLimitedMaxFlow(G, c, f 0 , C, t) Input: a directed planar graph G with capacities c, a pseudoflow f 0 , a simple cycle C, a sink a i .
Assumes: ∀v ∈ C + , inflow f0 (v) ≥ 0, whereC + = {v ∈ C : {x ∈ C : inflow f0 (x) > 0} G f 0 → v}.
Output: a pseudoflow f s.t. (i) f − f 0 obeys conservation everywhere but C + ∪ {t}, (ii) ∀v ∈ C + , inflow f (v) ≥ 0, (iii) {v ∈ C : inflow f (v) > 0} G f a i .1: let C + := {v ∈ C : there exists a residual path to v from a node x ∈ C with inflow f0 (x) > 0} 2: delete the nodes of C − C + 3: let v 1 , v 2 , . . . , v be the nodes of C + , labeled according to their cyclic order on C 4: add artificial arcs v i v i+1 for 1 ≤ i < 5: let P be the v 1 -to-v path of artificial arcs 6: contract all the edges of P , collapsing C + into the single node v 1 7: f := SingleSourceSingleSinkMaxFlow(G, c − f 0 , c 1 , t) 8: undo the contraction of the edges of P 9: f := FixConservationOnPath(G, P, c, f 0 + f ) −f 0 10: modify f to push back flow to nodes of C + whose inflow w.r.t f 0 + f is negative 11: f := f 0 + f 12: return f To compute C + in Line 1, consider the residual graph of G w.r.t. f 0 .
Add a node v and non-zero capacity arcs vw for every node w whose inflow w.r.t. f 0 is positive (these arcs may not preserve planarity).
In O(|G|) time, find the set X of nodes that are reachable from v via darts with non-zero capacity.
Then C + = C ∩ X.Since C + consists of all nodes of C reachable via residual paths from the nodes of C with positive inflow, the flow computed by the procedure involves no darts incident to nodes in C − C + .
Thus, restricting the computation to the graph obtained from G by deleting the nodes in C − C + (line 2) does not restrict the computed flow.
After deletion, adding artificial arcs between consecutive nodes of C + (line 4) will not violate planarity.
Contracting the artificial arcs effectively turns C + into a single node v 1 .
Next, the procedure computes a maximum flow f from C + to t w.r.t. residual capacities c − f 0 .
This is done by invoking a singlesource single-sink maximum flow algorithm [2] with source v 1 and sink t (line 7).
Uncontracting the artificial arcs turns f into a maximum C + -to-t flow in G w.r.t. the residual capacities c − f 0 .
However, some of the nodes of C + may have negative inflow w.r.t. f 0 +f .
In line 9, the procedure calls FixConservationOnPath to reroute the flow f among the nodes of C + so that, w.r.t. f 0 + f , there are no residual paths from nodes of C + with positive inflow to nodes of C + with negative inflow.
This implies that any node of C + that still has negative inflow has pushed too much flow.
Line 10 modifies f to push back such excess flow so that no node of C + has negative inflow w.r.t. f 0 + f .
This is done using the procedure of Section 1.1 described in the appendix.
Finally, the procedure returns f 0 + f .
See Appendix F for a formal proof of correctness.We next analyze the running time of this procedure on an n-node graph G and a k-node cycle C.
The st-maximum flow computation in line 7 takes O(n log n) time using the algorithm of Borradaile and Klein [2].
The running time of the procedure is therefore dominated by the call to FixConservationOnPath in line 9 which takes O(n log 2 n/ log log n + k 2 log 2 k) time.
Proof.
The fact that the properties hold just after line 7 follows from the properties of the recursive calls and from the fact that any residual path from a node in one piece to a node in the other consists of a residual path to C and a residual path from C. Note that, because of the contractions in line 4, at this time the cycle C consists of just the node v.
The the nonexistence of residual paths with respect to v in the recursive calls implies the nonexistence of residual paths w.r.t. any node of C after the contractions are undone in line 8.
Now, let us prove that the properties are maintained until just before the execution of line 13.
By the above argument, there is a cut separating S from T ∪A∪C which is saturated just after line 8.
The procedure in line 9 only pushes flow between vertices of C, and in lines 10-12, flow is only pushed between the nodes of A and C.
These sets are all on the same side of the cut which therefore stays saturated.
It follows that S T , S A, and S C at any point after line 7 and before line 13.
A similar argument applied to a saturated cut separating A ∪ C from T shows A T and C T .
Recall that C + i is the set of nodes of C that are reachable via residual paths from some node of C with positive excess at the beginning of iteration i, and that C − i is the set of nodes of C that have residual paths to some node of C with negative excess at the beginning of iteration i.Lemma A.5.
Just after line 9 of Algorithm 1 is executed, C + 1 C − 1 .
Proof.
Follows from the definition of FixConservationOnPath.Lemma A.6.
For all i < j, C + j ⊆ C + i and C − j ⊆ C − iProof.
It suffices to show that, for all i, C + i+1 ⊆ C + i and C − i+1 ⊆ C − i .
The flow pushed in iteration i of line 11 can be decomposed into a flow whose sources and sinks are all in C + i and a flow whose sources are in C + i and whose sink is a i .
Therefore, the set X of nodes of C with positive inflow immediately after iteration i of line 11 is a subset of C + i .
By definition of SingleSourceToCycleLimitedMaxFlow, the set of nodes of C with positive inflow does not change after line 12 is executed.
Therefore, C + i+1 is the set of nodes reachable from X by a residual path after iteration i of line 12.
By definition of C + i , immediately before iteration i of line 11 there are no C + i -to-{C − C + i } residual paths.
By sources lemma(C + i , C − C + i , C + i ), there are no C + i -to-{C − C + i } residual paths immediately after iteration i of line 11 as well.
This shows that there are no X-to-{C − C + i } residual paths at that time.
The flow pushed in line 12 can be decomposed into a flow whose sources and sinks are all in C − i and a flow whose source is a i and whose sinks are all in C − i .
By sinks lemma(C + i , C − C + i , C − i ), there are no C + i -to-{C − C + i } residual paths immediately after iteration i of line 12.
This shows that there are no X-to-{C − C + i } residual paths at that time.
Hence C + i+1 ⊆ C + i , as desired.
The proof of the analogous claim for C − i+1 is similar.Lemma A.7.
Just after line 11 of Algorithm 1 is executed in iteration i,C + i C − i , C + i+1 {a j } j≤i , {a j } j<i C − i .
Proof.
The flow pushed in line 11 can be decomposed into a flow whose sources and sinks are all in C + i and a flow whose sources are in C + i and whose sink is a i .
• C + i C − i by sources lemma(C + i , C − i , C + i ) • C + i+1 {a j } j<i by sources lemma(C + i+1 , a j , C + i ) • C + i+1 {a i } by definition of CycleToSingleSinkLimitedMaxFlow • {a j } j<i C − i by sources lemma(a j , C − i , C + i )Lemma A.8.
Just after line 12 of Algorithm 1 is executed in iteration i,C + i C − i , C + i+1 {a j } j≤i , {a j } j≤i C − i+1 .
Proof.
The flow pushed in line 12 can be decomposed into a flow whose sources and sinks are all in C − i and a flow whose source is a i and whose sinks are all in C − i .
• C + i C − i by sinks lemma(C + i , C − i , C − i ) • C + i+1 {a j } j≤i by sinks lemma(C + i+1 , a j , C − i ) • {a j } j<i C − i+1 by sinks lemma(a j , C − i+1 , C − i )• a i C − i+1 by definition of SingleSourceToCycleLimitedMaxFlow Let C + (C − ) denote the set of nodes in C with positive (negative) inflow just before line 13 is executed.Corollary A.9.
Just before line 13 of Algorithm 1 is executed,C + C − , C + A, A C − .
Lemma A.10.
The following are true upon termination:1.
f is a pseudoflow 2.
f obeys conservation everywhere except at S, T, A3.
S G f T, S G f A, A G f T .
Proof.
Since every addition to f along the algorithm respects capacities of all darts, f is a pseudoflow at all times.
By induction, the only nodes that do not obey conservations after the recursive calls are those of S, T and A. Subsequent changes to f only violate conservation on the nodes of C, but any such violation is eliminated in line 13.
Therefore upon termination f obeys conservation everywhere except S, T and A. Since, by Lemma A.4 and Corollary A.9 before line 13 C + A and C T , the flow pushed back from C + in line 13 must be pushed back to S. Similarly, the flow pushed back to C − must be pushed back from T .
Let f + (f − ) be the flow pushed back from C + to S (from T to C − ) in line 13.
Consider first pushing back f + .
• S T by sources lemma(S, T, C + )• S A by sources lemma(S, A, C + )• A T by sources lemma(A, T, C + )• S C − by sources lemma(S, C − , C + )• A C − by sources lemma(A, C − , C + )Next consider pushing f − • S T by sinks lemma(S, T, C − )• S A by sinks lemma(S, A, C − )• A T by sinks lemma(A, T, C − ) Lemma B.1.
The following holds immediately after iteration i of the main loop (line 3).1.
For j ≤ i, j > j, if p j has positive inflow, there is no residual path from p j to p j .
If p j has negative inflow, there is no residual path from p j to p j .2.
For j, j ≤ i, if p j has positive inflow and p j has negative inflow then there is no p j -to-p j residual path.Proof.
By induction on the number of iterations i of the loop.
For i = 0 the invariants are trivially satisfied.
First note that the adjustments to capacities and flow in lines 6-8 do not create any new residual paths since capacities are only reduced, and no residual capacity increases.
Therefore, it suffices to argue just about the flow pushed in line 11.
Assume the invariants hold up until the beginning of the i th iteration.
We show that the invariants hold at the end of the iteration.
Suppose that p i has positive inflow at the end of the i th iteration (the case of negative inflow is similar).1.
Since the flow pushed in line 11 is limited by |inflow(p i )|, the fact that p i has positive inflow at the end implies that the flow pushed was a maximum flow from p i to p i+1 .
Since the capacities of darts between p k+1 and p k for k > i are sufficiently large, the maximality of the flow implies that there are no p i -to-p k residual paths for any k > i.The invariant holds for nodes p j with positive inflow and j < i by sinks lemma({p j }, {p j : j > j}, {p i+1 }).2.
Invariant 2 holds for j, j < i by sinks lemma( {p j : j < i, inflow(p j ) > 0}, {p j : j < i, inflow(p j ) < 0}, {p i+1 }).
The invariant holds for p i by invoking the sources lemma({p i }, {p j : j < i, inflow(p j ) < 0}, {p i }).
Proof.
The flow f − f 0 satisfies conservation everywhere except at nodes of P since the algorithm only pushes flow between nodes of P .
By Lemma B.1, with respect to f , there are no residual paths from nodes of P with positive inflow to nodes of P with negative inflow.
Let f be a pseudoflow in a planar graph G with node set V , sources S and sinks T .
Let V + denote the set of nodes {v ∈ V − (S ∪ T ) : inflow f (v) > 0}.
Similarly, let V − denote the set of nodes {v ∈ V − (S ∪ T ) :inflow f (v) < 0}.
Suppose S ∪ V + G f T ∪ V − .
In this appendix we show how to convert f into a maximum feasible flow f .
This procedure was first described for planar graphs by Johnson and Venkatesan [19].
The original description of the procedure took O(n log n) time, but using the flow cycles canceling technique of Kaplan and Nussbaum [20] the running time is O(n).
We begin by converting f to an acycic pseudoflow in linear time [20].
That is, after the conversion there is no cycle C such that f The total running time is O(n), and since V + , V − are both empty, we get from the invariant S ∪ V + G f T ∪ V − that the resulting pseudoflow is a feasible flow.
This is the required flow f .
In this section we show that it is not necessary to use a generic shortest path algorithm that works with negative lengths to compute a feasible circulation χ in line 32 of Algorithm 6.
Instead of choosing x to be an arbitrary node in G * , let x be an arbitrary node of X * .
Let χ(y) denote the x-to-y distance in G * w.r.t. the lengths .
Instead of computing χ using a shortest path algorithm that accepts negative lengths, we will compute it more efficiently in two steps.
Pseudocode is given below as Algorithm 7.
In the first step we use FR to compute the distances to just the nodes of X * .
In the second step we extend these distances to all other nodes using Dijkstra's algorithm.In the first step the algorithm computes distances in G * from x to all nodes of X * w.r.t. φ X , the reduced lengths of induced by the feasible price function φ X .
This is done by an additional invocation of FR (line 2).
Let ψ X denote these distance labels.
By definition of reduced lengths and a telescoping sum similar to the one in the derivation of Eq.
(6), We thank Haim Kaplan and Micha Sharir for discussions of their unpublished data structure [21].
PNK and SM thank Robert Tarjan for encouraging us to work on this problem.
