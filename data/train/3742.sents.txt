Mobile app energy profilers provide a foundational energy diagnostic tool by identifying energy hotspots in the app source code.
However, they only tackle the first challenge faced by developers, as, after presented with the energy hotspots, developers typically do not have any guidance on how to proceed with the remaining optimization process: (1) Is there a more energy-efficient implementation for the same app task?
(2) How to come up with the more efficient implementation?
To help developers tackle these challenges, we developed a new energy profiling methodology called differential energy profiling that automatically uncovers more efficient implementations of common app tasks by lever-aging existing implementations of similar apps which are bountiful in the app marketplace.
To demonstrate its effectiveness, we implemented such a differential energy profiler, DIFFPROF, for Android apps and used it to profile 8 groups (from 6 popular app categories) of 5 similar apps each.
Our extensive case studies show that DIFFPROF provides developers with actionable diagnosis beyond a traditional energy profiler: it identifies non-essential (unmatched or extra) and known-to-be inefficient (matched) tasks, and the call trees of tasks it extracts further allow developers to quickly understand the reasons and develop fixes for the energy difference with minor manual debugging efforts.
Despite the prevalence of smartphones, the user experience has remained severely limited by their battery life.
As such, major mobile platform vendors such as Apple and Google have taken initiatives encouraging app developers to take effort optimizing their apps [7,26].
The typical development cycle for optimizing the energy drain of mobile apps is similar to that for optimizing the running time of traditional software -iterating the process of (1) finding hotspots in the app source code that contribute to a significant portion of the total app energy drain, and then (2) determining whether and how the energy hotspots can be restructured to drain less energy.However, modern mobile apps are highly complex, easily consisting of millions of lines of source code and third-party software, and interacting with the OSprovided frameworks in complex ways.
Without the help of automatic tools, even finding energy hotspots in the app source code by developers would be very hard.To this end, mobile app energy profilers (e.g., [32,31]) made a major step forward by providing a foundational energy diagnostic tool that automatically identifies energy hotspots in the app source code.
However, these profilers only help with the first step of the app energy optimization process, because after presented with the energy hotspots, developers typically do not have any guidance on whether and how the energy hotspots can be restructured to drain less energy.To help app developers with this remaining challenge in the energy optimization process, in this paper, we develop a new energy profiling methodology called differential energy profiling (or energy diffing for short) that can automatically uncover more efficient implementations of common app tasks, and in doing so, not only determines whether an energy-hotspot code segment can be optimized, but also gives hints on how to optimize it.The basic idea behind differential energy profiling is intuitive: if we can find a set of similar apps by different developers that implement many identical app tasks, chances are the implementations differ and will have different energy footprint.
Directly comparing their source-code energy profile generated by an energy profiler should expose more efficient implementation from the less one for the same app tasks.In this work, we first make three key observations about the uniqueness of the mobile app marketplace and common mobile app development practice: (1) Because of the low barriers to entry of app development, for every popular app in the app market, there are typically a few dozen competing apps that implement similar or identical app functions or app features.
(2) Using a traditional energy profiler, we profiled 8 selected app groups from 6 popular app categories from Google Play, each consisting of 5 similar apps and 5 different versions of one of them, and we found similar apps can differ significantly in energy drain in performing similar app functions.
(3) We further observe that mobile apps make heavy use of the common framework services provided by modern mobile OSes such as the Android framework, and our profiling analysis of the above 8 app groups has shown similar apps in each group share 38.6% to 81.9% of the same framework method calls and spent 44.0% to 96.7% of their app energy drain in calling framework services.Observations (1) and (2) suggest it is possible to learn more efficient implementation of the same app task by comparing the energy profiles of similar apps, but if apps have very different source code structures, such comparison may not be effective.
Observation (3) affirms such comparison of similar apps is actually meaningful and potentially effective.We then present the design and implementation of such a differential energy profiler, DIFFPROF.
Developing DIFFPROF faces three challenges: (1) What should be the diffing granularity?
(2) How to identify the diffing units in the source-code energy profiler output of each app?
(3) How to actually diff the energy profiles of similar apps?
We address these challenges as follows:(1) Using app tasks as the diffing granularity.
We argue following the widely adopted modular programming principle, an app is typically structured to implement a number of app features or tasks.
Since the ultimate goal of energy diffing is to uncover more efficient implementations of app tasks, the ideal diffing granularity that most directly helps the developers should be an app task.
(2) Characterizing how app tasks manifest in call trees.
Diffing at the app task granularity requires identifying app tasks in the call tree output by a source-code energy profiler.
To address this challenge, we examine the call trees for top 100 non-game apps and find that app tasks manifest themselves as Erlenmeyer flask-shaped slices (denoted as EFLASKS) represented in (call path, framework-method, subtree) tuples where the call path identifies the context of the task, the framework-method is used to invoke the framework service to accomplish the task, and the subtree captures the particular execution of the framework service.
(3) An efficient EFLASK matching algorithm.
We give insights on how and why different implementations (EFLASKS) of the same app task differ which motivates the need for approximate EFLASK matching.
We develop to our knowledge the first EFLASK-shaped tree slice matching algorithm that accurately finds similar EFLASKS corresponding to the same app task.To demonstrate its effectiveness, we implemented DIFFPROF on top of a state-of-the-art energy profiler EPROF [32] for Android, and compared it to EPROF in profiling 8 groups (from 6 popular app categories in Google Play) of 5 similar apps each.
We show DIFFPROF accurately identifies matched tasks that account for 79% of the app total energy drain on average as well as unique tasks (21% of total energy on average), in similar apps.Further, we conducted 12 case studies to show that DIFFPROF provides developers with actionable diagnosis beyond a traditional energy profiler: (1) When EPROF identifies energy bottlenecks, they may be necessary or not inefficient; DIFFPROF identifies non-essential (unmatched or extra) and known-to-be inefficient (matched) tasks; (2) The EFLASK of tasks extracted by DIFFPROF further shows the details of the more efficient implementation, which allows the developer to quickly understand the reasons for the energy difference with minor manual debugging efforts (e.g., setting breakpoints) since the developer did not author the similar app.
Out of the 12 inefficient or buggy implementations in 9 apps, 3 of which have already been confirmed by developers, and removing them reduces app energy drain by 5.2%-27.4%.
This work makes the following contributions: • It presents differential energy profiling, which tackles a key challenge faced by app developers in optimizing app energy drain -determining whether and how energy hotspots in app source code can be optimized, by identifying and comparing different implementations of the same tasks in similar apps.
• It presents DIFFPROF, an energy diffing tool for Android mobile apps.
It describes DIFFPROF's implementation and the core algorithm that finds approximate matching of Erlenmeyer flask-shaped slices in calling context trees of similar apps, and demonstrates its benefits over traditional energy profilers.
The DIFFPROF design is motivated by three key insights we make about the mobile app market.
Our first observation is about a unique phenomenon of the mobile app marketplace: (O1) for every popular app, there are typically a few dozen competing apps that implement similar or identical app functions or app features.
The top 100 non-game apps in Google Play belong to 34 functionally similar app groups and each of these categories consists of many competing popular apps.
Table 1 lists 8 such similar app groups with apps in the top 100 as well as outside the top 100 apps; the majority of them have 50M+ downloads.
1 We see that many groups include over a dozen similar apps each.
Moreover, similar apps, e.g., competing apps such as Pandora and Spotify, or a popular app (Candy Crush Saga) and its dozens of clones, typically have similar user interactions.
For example, the music playback screens of all music streaming apps have an album cover image, the song and the album title, a progress bar, elapsed and remaining time text, and buttons to control music playback, and every app performs music playback.
Table 1: Eight groups of similar apps from top 100 non-game apps, their competitors, and energy drain measurement. "
*": Popular but not a top 100 app, "+": Pre-installed app.
Given the abundance of similar apps for every popular app, we next ask the question: how do they stack against each other in energy drain, in performing similar app functions?
To answer this question, we profiled the similar apps in the 8 popular app categories on a Nexus 6 phone running Android 6.0.1 while connected to WiFi.We use automated tests to perform identical actions on the similar apps in each group and measure the energy drained by these actions using EPROF.
In particular, we use UI Automator, the Android black-box UI testing framework, which does not require app source code.For each group of similar apps, we first write a generic base test that interacts with common UI elements.
Next, for each app in the cluster, we launch the app on the phone and find the unique ids of all the UI elements involved in the base test using Android's uiautomatorview tool.
Finally, we run the base test with app-specific UI element ids, thus performing homogeneous interactions across similar apps.
The specific tests for the 8 app groups are listed in the sub-captions of Figure 1.
Figure 1 contrasts the total energy drain of 5 similar apps and 5 versions of 1 app under the same user interactions in each of the selected 8 app groups from Table 1.
We observe that the maximal to minimal energy drain across the 5 apps in each group range between 2.8x to 8.0x, as shown in Table 1.
We thus draw our second observation that (O2) similar apps easily differ significantly in energy drain in performing similar app functions.The above observation suggests that directly comparing the energy footprint of similar apps at the sourcecode level is promising to diagnose energy hotspots.
However, such comparison will be fruitful only if their source code have significant overlap.
Our next observation is that mobile apps make heavy use of the common framework services provided by modern mobile OSes such as the Android framework.
To simplify app programming, such frameworks implement and export to apps many services that implement commonly performed tasks, e.g., the Android framework provides LocationManager, DownloadManager, MediaPlayer, and WindowManager, among others.
Typically, an app presents requirements via configuration parameters to the services, and the services then perform the low-level work on the app's behalf.
We hypothesize that the heavy usage of framework services leads to a high percentage of app energy drain occurring in these common services and the framework methods called in similar apps have a high overlap.To confirm this hypothesis, we use EPROF to decouple the energy spent in app methods from those spent in framework services.
First, we run dexinfo [5] on all the framework jar files located in /system/framework/ on the phone to identify all the framework packages such as android.view, dalvik.system and java.math.
Next, for each app, we identify all the framework methods in its energy profiling output belonging to these framework packages.
Finally, we aggregate their energy drain to compute the total framework energy drain.
The remaining energy drain is marked as app energy drain.Our results (details for only 4 app groups are shown in Figure 2 due to page limit) show that the apps in the 8 app groups have significant pairwise overlap in the framework methods called during the profiling run, between 38.6% and 81.9% (61.7% on average).
Further, Table 1 shows that a significant portion of the total energy of the apps in each group was spent in framework API calls, ranging between 44.0% to 93.8% for Launcher apps to T u r b o C le a n e r F a s t C le a n e r C C le a n e r D F N D R C le a n M a s t e r C le a n M a s t e r -v 5 .
1 6 .
4 C le a n M a s t e r -v 5 .
1 5 .
9 C le a n M a s t e r -v 5 .
1 4 .
4 C le a n M a s t e r -v 5 .
between 89.3% to 94.9% for File explorer apps.
We thus draw our third observation that (O3) the heavy usage of framework services leads to a high percentage of app energy drain occurring in these shared services, up to over 90% of the app energy consumption.
This phenomenon suggests learning more efficient implementations of app functions by comparing their energy footprints not only is possible, but actually is a meaningful and practical approach.
The above three key insights suggest comparing the energy profiles of similar apps generated by a source-code energy profiler has the potential to automatically identify inefficiencies in implementing common app functions in similar apps.
We call this approach differential energy profiling, or energy diffing for short.Developing such a differential energy profiler has to address three challenges: (1) What is the diffing granularity?
(2) How to identify the diffing units in the energy profiler output of each app?
(3) How to actually diff the energy profiles of similar apps?
A mobile app typically implements many features.
We refer to the implementation of individual app features in the source code and their invocations at runtime as app tasks.
Similar apps are expected to implement a common set of core tasks pertaining to the apps' common, main functionality, e.g., music playback along with some basic UI features (e.g., progress bar) for music streaming apps.In addition, similar apps by different vendors often support some differentiating features which result in different tasks at runtime.
For example, among the five streaming apps, SoundCloud uniquely depicts the audio track using a waveform animation during music playback.Since there are two potential factors that contribute to the different energy drain of similar apps: (1) different implementation of common app tasks, and (2) app tasks unique to each of the similar apps, the natural granularity for energy diffing of similar apps should be an app task.
Diffing at the task granularity, however, faces a fundamental challenge: app tasks are not explicitly labeled by developers.
To overcome the above challenge, we examine how app tasks manifest in the call trees of Android apps.Android app programming is event-driven where the Android framework implements frequently used tasks as services.
These Android framework services provide sev- FastCleaner (773) TurboCleaner (605) CCleaner (468) C le a n M a s t e r ( 4 7 9 2 ) D F N D R ( 4 2 4 4 ) F a s t C le a n e r ( 4 0 6 8 ) T u r b o C le a n e r ( 3 8 3 7 ) C C le a n e r ( 2 9 9 9 eral Java interfaces and classes with callback methods that apps can override.
Apps then use the associated registration-callback mechanism to register the overridden callback app methods with the framework.
Upon an event, the Android framework calls these overridden methods registered for the event.We refer to Android framework methods as F-methods and app methods as A-methods.
The above asynchronous programming suggests (1) an app's energy profiling output typically consists of many call trees [9], one for each thread; (2) as shown in Figure 3, each call tree typically starts with some framework method (F 0 ) that receives call-back related messages and makes a callback into the app (A 1 ).
The app callback method (A 1 ) may call various other app methods (folded in A 1 ) which later call another framework method (F 2 or F 3 ) to register more callbacks (A 2 ) or for general processing that implements the task.Using a script, we examined the call tree output by EPROF for all the apps in Figure 1 and confirmed that their call trees all follow the above structure, with one minor variation: a path may contain only F-methods (e.g., (F 0 , F 1 )).
This happens when an app task calls some framework method X that in turn registers an asynchronous callback of some other framework method Y.
When framework method Y is invoked, it starts a new path off the root of the call tree consisting entirely of framework methods.
Typical generalpurpose framework methods that serve as the roots of the call trees include Handler.dispatchMessage and Binder.execTransact.
What constitutes a task in the call tree?
The above call tree structure suggests an app task typically manifests in a call tree in an Erlenmeyer flask-shaped [19] slice with three components 2 , as shown in Figure 3:• Call path: The call path from the root of the call tree consisting of some F-methods followed by some Amethods that lead to the F-method uniquely captures the context of the task, i.e., under which the F-method was called; • F-method: The specific F-method invoked by the app method that is the entry to the invoked framework service that accomplishes the app task;• Subtree: The actual execution of the F-method, given the context and the parameters passed to the entry method.
We denote the three-component structure as an EFLASK, which is a (path, F-method, subtree) task tuple.In practice, it is often not obvious to isolate all the EFLASKS in a given call tree that correspond to app tasks, due to the possibly many layers of interleaving of Amethods and F-methods.
Our EFLASK matching algorithm described in §3.4 takes the call trees of two similar apps and simultaneously identifies EFLASKS corresponding to app tasks and finds matching tasks.
Before discussing the diffing algorithm, we first explore different options of tree structures to perform diffing, as shown in Figure 4.
Call tree Since EPROF outputs a call tree for each execution profile, the baseline approach would be to directly diff the two call trees (CT).
However, this is not practical, since an app task may be invoked many times during a profiling run and thus its task tuple may appear many times in the call tree output.
Further, the call tree becomes hopelessly large, up to several million call tree nodes in just a few minutes of a typical profiling run.Dynamic call graph An alternative approach is to convert call trees to dynamic call graphs (DCG) [9] and diff DCGs instead, where every method executed has just one corresponding method node in a DCG.
However, using DCG faces a fundamental challenge that a DCG is not path preserving, i.e., it may contain code paths that never occurred during the profile run.
For example, the DCG in Figure 4(b) contains path M → A → B → D which never occurred in the CT in Figure 4(a).
Paths need to be preserved for matching the EFLASKS of the same app task.Calling context tree DIFFPROF overcomes the above shortcomings of CT and DCG by building and using calling context trees (CCT) [9], a middle ground between call trees and dynamic call graphs.
In a nutshell, two method call nodes in the call tree are merged in the CCT whenever both nodes have an identical path from the root.
In addition, recursive calls are merged to the nonrecursive ancestor to keep the tree bounded in size, for example node A in Figure 4(c) 3 .
Thus, using a CCT preserves the valuable path information while significantly reducing the number of nodes in the tree.
In practice, we found CCT to contain only tens of thousands of nodes in a few minutes of profiling run, allowing our sophisticated matching algorithm to run in less than 30 seconds ( §5).
We first discuss the need for approximate matching to find EFLASKS corresponding to the same app tasks.
We then review prior tree matching algorithms, discuss their drawbacks when applied to our problem, followed by our EFLASK matching algorithm.
The above understanding of how app tasks manifest in call trees in §3.2 suggests that different implementations and hence their EFLASK structures of the same task in two apps can differ in the following ways:• The corresponding call paths may differ slightly.
This can happen for two main reasons.
First, apps may use slightly different mechanisms to achieve the same app callback.
For example, an app can start its Runnable.run method directly from a new thread, or via ExecutorService; the two lead to different paths from root.
Second, the app can use different app callbacks for receiving similar events.
For example, the Turbocleaner app handles the "clean" button press using .
onClick callback while the DFNDR app uses.onItemClick callback after which both apps call Activity.startActivity to perform a common task.
• The entry F-methods may differ due to two main reasons.
First, the same task API can be provided by many different framework classes.
For example, both Https URLConnectionImpl.getInputStream and HttpURLConnectionImpl.getInputStream get data from a server, one from an https and another from an http connection.
Second, the same framework class may provide many alternate APIs to perform the same app task.
For example, three different apps, Wish, Kohl and letgo, share 8 common nodes in the call path from the root call and finally call three different APIs, ImageView.setImageDrawable, ImageView.setImageBitmap and ImageView.
setImageResource, respectively, for setting an image.
• The subtrees that reflect the actual executions of the app task in similar apps can differ.
Even when the developers use the same framework API call to accomplish a task, the program state and the call parameters passed in can differ which lead the framework service to take different paths resulting in different subtrees.
How to match two trees to find similar components has been previously studied with a diverse set of applications such as matching RNA structures, structured text databases and image analysis [12].
However, prior matching algorithms are not suitable for matching EFLASKS.Exact path matching Let T 1 and T 2 be two CCTs rooted at r 1 and r 2 , with the set of nodes denoted by V (T 1 ) and V (T 2 ).
Formally, exact path matching produces a maximal one-to-one node matching 4 M ⊆ V (T 1 )×V (T 2 ), where for any pair (v, w) ∈ {M − (r 1 , r 2 )}:(r 1 , r 2 ) ∈ M and (P(v), P(w)) ∈ M (Path Condition)(1)where P(v) and P(w) are parents of nodes v and w respectively.
However, exact path matching cannot match paths (e.g., of EFLASK) with minor variations.Prior approximate tree matching algorithms Tai et al. [38] gave the first approximate tree matching algorithm.
This algorithm produces a maximal one-to-one matching M where for any pair (v 1 , w 1 ), (v 2 , w 2 ) ∈ M:v 1 is ancestor of v 2 iff w 1 is ancestor of w 2 (Ancestor Condition)(2)The output matching replaces the Path Condition in Eqn.
1 with a significantly weaker Ancestor Condition (i.e., Path Condition implies Ancestor Condition).
However, the algorithm is Max-SNP hard.To reduce the running time, Zhang et al. [44] added a Structure Respecting Condition to output matching.
This algorithm produce a matching M, such that for any pairs(v 1 , w 1 ), (v 2 , w 2 ), (v 3 , w 3 ) ∈ M: nca(v 1 , v 2 ) =nca(v 1 , v 3 ) iff nca(w 1 , w 2 ) = nca(w 1 , w 3 ) (Structure Respecting Condition)(3)where nca(x, y) is the nearest common ancestor of nodes x and y. Due to the additional constraint, fewer matching possibilities need to be considered, making the algorithm's running time polynomial.
However, these algorithms may match EFLASKS with very different call paths.
In contrast to the exact path matching algorithm which focuses on matching the path (component of EFLASKS) without considering the subtrees underneath, the above approximate matching algorithms match two nodes only based on similarity of subtrees (another component of EFLASKS) underneath them disregarding the call paths.
The EFLASK matching algorithm we propose below leverages both the path and subtree information in matching two nodes, and in doing so, matches two EFLASKS.
The EFLASK matching algorithm relaxes the Path Condition incrementally, i.e., the paths from root to matched nodes in two trees can differ by at most α nodes, and maximizes the subtree overlap.
We replace the Path Condition in the exact matching algorithm with a Relaxed Path Condition while retaining the Structure Respecting Condition (Eqn.
3) and Ancestor Condition (Eqn.
2) to find such matching.
Formally, we wish to produce a maximal one-to-one matching M, that satisfies Eqn.
2 and Eqn.
3 and for any pair (v, w) ∈ M:w ∈ C α (v) (Relaxed Path Condition)(4)whereC α (v) ⊆ V (T 2 )is the candidate set, where the path from T 2 's root to each node in C α (v) differs from the path from T 1 's root to v by less than or equal to α nodes.
For example, Figure 5 highlights the nodes in the candidate set C α (b) for α equal to 0, 1 and 2.
C 0 (b) contains just 1 node that has the same path from its root as the b in T 1 .
C 1 (b) includes 3 additional nodes a, b and c whose path from root becomes identical to b's from T 1 's root, r → a → b by doing exactly one operation -deleting b, deleting a and replacing b by c, respectively.Notations Before presenting the algorithm we define a few notations.
Let T 1 , T 2 denote two unordered labeled tree with maximum degrees D 1 and D 2 , respectively.
We denote the set of children nodes of node v by child(v) and its label by label(v).
The path from the root to node v thus forms a string of labels and is represented by s(v).
While matching the nodes in two trees, we can perform three types of edit operations to the tree nodes -(1) a relabeling operation to change the node label, (2) a deletion operation to delete node v and make all the children of v the children of P(v), and (3) an insertion operation, the complement of deletion.Let λ denote a special blank symbol.
The cost of each edit operation can be specified using a cost function, γ.
Thus, γ(l 1 , l 2 ) is the cost of replacing l 1 by l 2 , γ(l 1 , λ ) is the cost of deleting l 1 and γ(λ , l 1 ) is the cost of inserting l 1 .
γ is generally assumed to be a distance metric, i.e., γ is non-negative, symmetric and follows triangular inequality.
We extend the notation such that γ(v, w) for nodes v and w denotes γ(label(v), label(w)).
We assume unit cost distance in the design of algorithm, i.e., γ(l 1 , l 2 ) = 1 when l 1 񮽙 = l 2 .
Now we are ready to define a few functions and their properties which form the basis of our algorithm.Path edit distance function We first find C α (v) by computing a path edit distance function ρ.
For some v ∈ V (T 1 ) and w ∈ V (T 2 ), ρ(s(v), s(w)) is the total cost of edit operations required for v and w to have identical paths from the root.
ThusC α (v) = {w ∈ V (T 2 )|ρ(s(v), s(w)) ≤ α}.
Since paths s(v) and s(w) are strings, path edit distance function ρ(s(v), s(w)) is thus equal to the string edit distance [41] between s(v) and s(w) and hence can be calculated in a similar manner.Since we only care about path edit distance when it is less than or equal to α, we prune some computation as soon as the distance exceeds α.
We can show the runtime for computingC α is O(min(N 1 D α+2 2 , N 1 N 2 )).
Subtree match function Next, we define a subtree match function µ α between two trees.
For v ∈ V (T 1 ) and w ∈ V (T 2 ), µ α (T 1 (v), T 2 (w)) is the size of maximal matching of subtrees T 1 (v) and T 2 (w) where the matching nodes' paths differ by at most α.Before providing the next lemma, we need the following definition.
A restricted matching RM(v, w) is a matching between nodes of F 1 (v) and F 2 (w) and is defined as follows: (1) RM(v, w) follows all the matching conditions -Relaxed Path Condition (Eqn.
4), Structure Respecting Condition (Eqn.
3), Ancestor Condition (Eqn.
2), and (2) if (p, q) is in RM(v, w), p is in T 1 (v i ) and q is in T 2 (w j ), then for any (p ′ , q ′ ) in RM(v, w), p ′ is in T 1 (v i ) iff q ′ is in T 2 (w j ) where v i ∈ child(v) and w j ∈ child(w).
In other words, node from a subtree T 1 (v i ) must only map to nodes of one subtree T 2 (w j ) and vice versa.Motivated by the constrained edit distance algorithm [44], we derive the recurrence relationship for µ α .
Lemma 3.1.
For all v ∈ V (T 1 ) and w ∈ V (T 2 ),µ α (T 1 (v), θ ) = 0 µ α (θ , T 2 (w)) = 0 µ α (T 1 (v), T 2 (w)) = 0 if w / ∈ C α (v) µ α (T 1 (v), T 2 (w)) = max       max w j ∈child(w) µ α (T 1 (v), T 2 (w j )) max v i ∈child(v) µ α (T 1 (v i ), T 2 (w)) max RM(v,w) µ α (RM(v, w)) +(1 − γ(v, w))       ; otherwiseProof.
Proof is similar to [44], we skip the details here.Again, for any v ∈ V (T 1 ), we need to compute the µ α (T 1 (v), T 2 (w)) function described above for all w ∈ C α (v).
The runtime for computing µ α is O(N 1 · min(D α+1 2 , N 2 ) · (D 1 + D 2 ) · log(D 1 + D 2 )) 2 .
The EFLASK matching algorithm Putting things together, the flexible tree matching algorithm makes two passes.
First, it makes a top-down pass to compute C α (v) for all v ∈ V (T 1 ), i.e., find nodes with call paths different by at most α nodes.
Next, it makes a bottom-up pass to compute µ α (T 1 , T 2 ).
Third, it uses a simple backtracking mechanism to find for each node v ∈ T 1 the matching node w ∈ T 2 that maximizes the T 1 -T 2 tree match.
Finally, it finds the matching EFLASKS based on these maximally matched nodes.The two passes together simultaneously accomplish matching of both the call path and the subtree components of similar EFLASKS.
The α value affects the tradeoff between finding more matching tasks (that vary in their call paths) and false positive matches.
To make the algorithm more effective, we identified several factors that may increase the path :,+3;<,= 55>#(2 ,""#?
<:=#55>#(2#,""#@ <8=#55>#-7&'# $%+A%)#,""#4()%B Figure 6: App namespace problem.
distance between the paths for the same app task, and preprocess the CCTs to remove such factors so that more matchings can be found with smaller α values.App namespace problem The call paths for the same task in two CCTs can contain many app methods that are unique to either app as different developers are likely to structure and name the app methods differently.
Such app-specific app methods can easily blow up the path edit distance of the call paths of a matching task.
Fig- ure 6(a,b) show an example of two paths with differing app methods.
We observe that all the callback app methods must override some predefined framework methods, and the remaining internal app methods called from other app methods have arbitrary names and are also often obfuscated.
We thus merge all the internal app method calls into the app callback method root node as shown in Fig- ure 6(c), and drop the app specific class names from app's callback node to allow matching callback methods.We note that like using DCGs, merging app methods to address the app namespace problem conceptually also reduces path sensitivity, but it actually improves the effectiveness of task matching.
This is because the internal methods of different apps tend to be named very differently and thus path sensitivity to app method names actually harms path similarity matching.Class hierarchy problem A similar issue arises due to the object-oriented nature of Java, as shown in the following example.
The two apps in Figure 7(a,b) share a same task pointed by the dashed arrow, but the first app uses method S.A which extends and calls method T.A and the second app directly uses T.A. Each such occurrence in the path increases the path edit distance by one, and more occurrences will quickly inflate the path edit distance.We solve this problem in two steps.
First, we merge T.A into the caller node S.A (S'.
A).
Second, we tweak the distance function γ to allow matching S.A with T.A, i.e., γ(S.A, T.A) = 0.
This allows matching the common task in Figure 7(a,b) with a path distance of zero while retaining the same path edit distance for sibling classes in Figure 7(a,c).
F-method only paths A third situation happens when a path off the root consists entirely of framework methods as discussed in §3.2 (path (F 0 , F 1 ) in Figure 3).
When this happens, in energy profiling, the energy consumption of the call path is not propagated to its asynchronous caller, i.e., the app task, which leaves the developer clueless as to what app task caused the energy drain.DIFFPROF patches such asynchronous framework only subtrees to its parent app task by adding additional logging in the Android framework.
In particular, it logs the callback object's .
hashCode() along with the current timestamp and thread id, when an asynchronous callback is enqueued in framework and when the callback is later dispatched.
During post-processing, for each dispatch method call, the nearest preceding enqueue method call with matching object .
hashCode log is patched as the dispatch method call's asynchronous caller.
5 We implemented DIFFPROF on top of EPROF [32] with 5.7K lines of Java code.
DIFFPROF is packaged as an IDE plugin that can be installed on a laptop, with a GUI front-end, for interacting with the developer and computing and showing the energy diffing result.
EPROF traces are collected on a phone running a modified Android 6.0.1 framework version that adds 95 lines to capture hidden causal relationships due to asynchronous programming ( §3.5).
6 After collecting EPROF traces of two similar apps, the developer specifies these traces to DIFFPROF, and DIFF-PROF performs energy diffing in the following steps.
(1) First, DIFFPROF patches the call tree dumped by EPROF using the call timing and the log timestamp as described in §3.5.
(2) Next, DIFFPROF converts EPROF's CT output into CCT and dumps the CCT along with the inclusive and exclusive energy consumption by and the number of recursive and non-recursive invocations of each CCT node.
(3) Next, the developer is presented with a list of Java package names that appeared in either app trace to determine app packages used for merging app methods as described in §3.5.
By default, all packages not belonging to the Android framework are marked as app packages.
For comparing two different apps, developers can skip this step, since packages not belonging to the Android framework are already marked as app packages.
When comparing two versions of the same app, however, this presents an opportunity for the developer to unmark certain app packages to expose app-internal path information (Figure 6) during matching.
(4) DIFF-PROF performs the EFLASK matching algorithm on the pair of CCTs.
(5) Finally, since the EFLASKS of multiple tasks may share a common path, DIFFPROF assigns the energy drain for each task as the inclusive energy of the F-method.
DIFFPROF gives two outputs: (1) a merged list of matched (with the other app) and unmatched tasks in the app, sorted by the energy drain for unmatched tasks and the energy difference for matched ones, i.e., based on the potential room for improvement; and (2) upon selection, a task's EFLASK in a graphical view.
Our evaluation answers the following questions: (1) Does DIFFPROF effectively identify matching and unique tasks among similar apps?
(2) Does DIFFPROF offer added benefits over EPROF, in particular, how does it help developers with understanding and coming up with more efficient implementation?
We use DIFFPROF to profile popular apps belonging to the 8 app groups in Table 1.
For each group, we pick 5 different apps and 4 older versions of one of the 5 apps, same as in Figure 1.
In running the tests, we ensure user interaction homogeneity using automated testing as described in §2.2.
All app tests are less than 1 minute long and are run on a Nexus 6 phone running DIFFPROF's modified version of Android 6.0.1.
The traces are post processed and task matching is performed on a Macbook pro laptop with a 2.5 GHz Intel i5 CPU and 8GB 1600 MHz DDR3 main memory.Impact of α We first evaluate the impact of changing α on the EFLASK matching algorithm's running time and output.
Table 2 summarizes the results.
We see that as expected, the running time grows close to exponentially with the α value (from 0 to 2 and from 2 to 4).
On average, the algorithm produces the energy diffing output within half a minute for all values of α ≤ 5.
Next, we observe that the average percentage of matching tasks grows steadily as we increase the value of α, starting 10.8% on average at α=0 up to 22.9% at α=5.
The growth slows down at α = 5.
Based on the above result, when profiling the 8 app groups, for each app pair in a category, we run DIFFPROF to find the matching tasks using the lowest α that can match 20% of the tasks, up to α = 5 (shown as dynamic α in Table 3).
The pairwise task overlap for 4 app groups (Music streaming, Cleaning, Email, Launcher) are shown in the upper triangles in Figure 2.
We see that the task overlap between similar apps is significant, ranging between 7%-61%, with an average of 27%, 24%, 28%, and 17%, for the 4 groups, respectively.
Table 3 gives the details of diffing results for each app in the 8 app groups.
For each app, we classify all its tasks into tasks that could not be matched with any of the 4 other apps in its category and tasks that were matched with 4, 3, 2 or 1 other app(s).
The columns under "Dynamic α" show that the count of such tasks for each app varies for different categories, e.g., Email apps have 17 5-way matching tasks while Music apps have only 2, suggesting the apps in different categories have different levels of overlapping tasks.
We manually examined 20% of the matched tasks and did not find any false positives.
Table 3 also shows that the percentage of energy drained by matched tasks (i.e., 1 minus that of unique tasks energy) is over 70% of the total energy drained by the app for 32 out of the 40 apps.
This suggests that although it is hard to measure the coverage (false negative) of task matching produced by DIFFPROF, in practice, DIFFPROF produces matched tasks that already account for a majority of the app energy drain which gives app developers enough focus for optimization.DIFFPROF also exposes app unique tasks that drain significant amounts of energy.
Table 3 shows SoundCloud and CM launcher drain 53.7% and 43.7% of the total energy in performing unique app tasks/features, waveform animation and rotation animation, respectively.To show the effectiveness of the EFLASK algorithm, Table 3 last column lists the number of tasks in each app that do not get matched using the exact path matching algorithm (α = 0).
We see that the EFLASK matching algorithm with dynamic α reduces the number of unmatched tasks by 13.5% on average (shown in second column).
We discuss how DIFFPROF offers added benefits over a standard energy profiler through extensive case studies.
Our case studies show that DIFFPROF provides developers with actionable diagnosis beyond a standard energy profiler in two ways: (1) DIFFPROF identifies nonessential (unmatched or extra) and known-to-be inefficient (matched) tasks; (2) the EFLASKS of tasks extracted by DIFFPROF further expose the reasons for the more efficient implementation.
For convenience, in the following, we often refer to a task by the F-method in its EFLASK 3-tuple.
Methodology We ran DIFFPROF on the top 3 energydraining apps in each of the 8 groups against the least energy-draining app in the same group, and looked at the top energy-draining app tasks output by DIFFPROF.
Out of these, we skip the cases where the app tasks are for supporting unique app features (e.g., 47.2% of SoundCloud's total energy was by a task supporting the waveform animation feature).
The remaining 12 tasks, summarized in Table 4, all belong to buggy or inefficient implementations, removing which reduces the app energy drain by 5.2%-27.4% (based on the energy difference).
Instant Messaging Table 5 shows Google Hangout's energy output from EPROF and from DIFFPROF when compared with Whatsapp.
When sorted by inclusive energy, EPROF shows really high-level Android methods such as Looper.loop on the top, and when sorted by exclusive energy, it shows really low-level Android methods such as BinderProxy.transactNative on the top.
Such top energy drainers in both inclusive and exclusive energy lists are F-methods that do not directly call app methods and are not directly called by the app; the developers thus do not get useful guidance on what to focus on from the long list of EPROF output.
In contrast, DIFFPROF outputs tasks sorted by energy drain.
It shows Hangout consumes more than 10% of its total energy in an unmatched task ContentResolver.query.Since tasks' F-methods are directly called by the app, the top task's name provides direct hints to developer on how to optimize the app.
EPROF, however, does not highlight such methods; the top task method appeared at position 27 when sorted by inclusive energy and at 1336 when sorted by exclusive energy.
Finding the reasons and optimization for task ContentResolver.query would have been easy for its developer from the EFLASK output, e.g., the ContentResolver.query method was called 116 times.
But since we did not write the app, to understand this energy drain, we set a breakpoint at the ContentResolver.query method and reran the app to examine the parameters passed to the method.
In one call to the method, the app queries multiple fields that are stored in a local database.
We found that at one message send, the app queries for 81 unique database fields which often are repeated across two different queries.
Moreover, 36 out of the 81 fields, such as author chat id and author first name, do not change across two send key presses, but keep on getting queried at each send.
This suggests that there is ample room for optimization by keeping a staleness flag; only when the user navigates away from a chat window, the 36 fields can be declared stale and re-queried later.Shopping Table 6 shows the Kohl's app's output from EPROF and from DIFFPROF when compared with letgo.
DIFFPROF shows ObjectInputStream.readObject and ObjectOutputStream.writeObject are two top energy draining extra tasks, consuming 3.9% and 3.2% respectively of its total energy consumption.
In contrast, EPROF outputs them at positions 90 and 133 when sorted by inclusive energy and at 1516 and 1547 when sorted by exclusive energy, respectively.
Since we did not write the app, we dug into the energy drain by setting breakpoints.
We found that the app keeps the entire catalog and current discount campaigns on the SD card in catalog.tmp and cms.tmp files respectively which were 227 KB and 21 KB at the time of the experiment.
Whenever a new catalog or a new campaign is synced with the server, the entire files are dumped again, rewriting the previous entries; using a database just to update new entries would have been more efficient.Note that task View.draw consumes 12.16 µAh energy, more than the above extra tasks, but does not appear in the top task list.
This is because DIFFPROF prioritizes the tasks with the most room for optimization: since the letgo app consumes 8.29 µAh for the same task, the difference is less than 4 µAh.Antivirus DIFFPROF highlights Thread.getStackTrace as an extra task in the Kaspersky app which consumes 39.57 µAh, 14.8% of the app's total energy drain (position 1 in DIFFPROF output, but 22 in EPROF output).
After decompiling the app apk using dex2jar [4], we inspected the caller of Thread.getStackTrace in the app source code and found that the app collects logs with unicode characters but in every such attempt, the code throws UnsupportedEncodingException which internally collects the thread stack trace thus unnecessarily wasting energy.
This bug was confirmed by Kaspersky developers.Music DIFFPROF highlights SharedPreferencesImpl$Editor.apply as an extra task in Pandora v8.0 that consumes 17.5% of its total energy drain (position 4 in DIFFPROF output but 42 in EPROF output).
This method is used to change app preferences.
The Android developer manual suggests that apps should call SharedPreferencesImpl$Editor.edit repeatedly to keep making changes in memory and then call SharedPreferencesImpl$Editor.apply once at the end to commit all the changes to the disk.
However, the app mistakenly calls SharedPreferencesImpl$Editor.apply once every second.
This bug was confirmed and fixed in the latest version of the Pandora app.Cleaner DIFFPROF shows that the DFNDR app calls framework method Runtime.exec, consuming 19.52 µAh, 5.2% of the app's total energy consumption (position 3 in DIFFPROF output but 50 in EPROF output).
We set a breakpoint at this method and examined its parameters and found that the app runs ps | grep <app pkg> for each app installed on the phone.
Since ps walks down the entire /proc directory, it would be more efficient to just obtain the ps output once and parse it to find the fields related to each app.
Shopping In diffing Wish and letgo, although the CCTs of the two apps differ a lot structurally as shown in Figure 8(a), DIFFPROF is able to match two commons tasks, Bitmap.compress and BitmapFactory.decodeStream, by collapsing app methods to ⋆.
run and its flexible EFLASK matching algorithm.For the Bitmap.compress task, DIFFPROF shows that Wish consumes 100.94 µAh, 15.9% of its total energy drain whereas letgo consumes only 7.14 µAh.
To find the root cause of energy difference, we examined the parameters passed to the F-method by setting a breakpoint and rerunning both apps.
We found that Wish compresses the image into a png image with quality set to 100 while letgo compresses into a jpg image with quality set to 90.
This causes the large energy difference while the images shown by both apps are visually similar.The above image format difference also explains the energy drain difference between the second common task BitmapFactory.decodeStream where Wish consumes 126.32 µAh, 19.9% of its total energy drain while letgo consumes only 5.01 µAh.
DIFFPROF further highlights the reason for the difference: in Pandora v5.7, the subtree additionally contains the ViewRootImpl.scheduleTraversal subtree that traverses and measures the entire view hierarchy.
We used a premium account to disable ads and played the same radio station on both Pandora versions for two hours while leaving the phone on the playback screen.
We found that Pandora v5.7 drained 9.2% battery per hour whereas Pandora v8.3 drained only 6.7% battery per hour.
We reported this bug to Pandora engineers, who verified that Pandora v5.7's layout.xml file erroneously declared the width of elapsed time and remaining time text views to wrap content.
This flag signals Android's ViewManager that the text view must be just large enough to enclose its content.
As a result, every second when the app updates the elapsed time and remaining time text views, Android ViewManager traverses the entire view hierarchy to recompute the size of the text boxes.
The text boxes were set to a fixed size in later versions of Pandora.Music -Spotify In diffing Pandora and Spotify apps, DIFFPROF shows that the common ProgressBar.setProgress task consumes 43.63 µAh, 28.1% of its total energy in Spotify, but just 1.74 µAh in Pandora.
The EFLASK output further shows that Spotify calls this method from App.doFrame 596 times while Pandora calls it only 29 times from App.onTrackElapsedTime during the 30 second music playback, i.e., while Pandora updates the progress bar once per second, Spotify updates it on every frame, which is unnecessarily frequent as many frame draws lead to no pixel change.Instant Messaging In diffing TextNow and Whatsapp, DIFFPROF shows that TextNow consumes 230.46 µAh, 40.6% of its total energy drain, in calling a common task ViewRootImpl.performTraversal, almost 10 times that in Whatsapp.
On inspecting the layout of the two apps with Android's HierarchyViewer, we found that TextNow contains 226 views compared to 76 in Whatsapp.
Our closer inspection of view properties shows that 172 views in TextNow are in fact not even visible on the screen.
The app statically loads all the possible UI interactions such as pause playing voice note button and change billing details button icon, keeping them all in the view hierarchy instead of dynamically loading views on demand as recommended by Android [3] and thus inflating the view hierarchy traversal energy.
Moreover, the app contains several LinearLayout with just an ImageView and a TextView which are recommended to be compressed into one compound view [8] to reduce the size of the view hierarchy.File Explorer DIFFPROF shows that Solid explorer consumes 35.52 µAh, 18.9% of its total energy in task Drawable.invalidateSelf whereas FX file explorer only consumes 1.24 µAh.
DIFFPROF further shows that Solid calls Drawable.invalidateSelf 1002 more times than FX and that the EFLASK contains ObjectAnimator.animateValue followed by Solid's CircularAnimatedDrawable$1.
set.
Upon inspecting this class, we found that the app does the animation when a new folder is created.
At each frame, it draws an arc and requests another frame.
However, after the folder gets created, the app stops drawing the arc but keeps requesting new frames, unnecessarily wasting energy.
DIFFPROF's effectiveness in finding energy optimizations stems from the large overlap of Android libraries used among competing Android apps and accurate source-level energy profiling.
As such, its central idea of diffing source-code-level profiling of similar apps in principle can be extended to find optimization opportunities in other performance metrics of interests to developers, such as latency, scalability and memory efficiency.One of the central principles of software engineering, DRY (Don't repeat yourself) [24], preaches the use of reusable code, by abstracting all common reusable code into standalone libraries.
The principle improves modern software developers' productivity and has gained wide adoption in recent years; almost every major build tool today [1,6,2] allows developers to specify library dependencies which are downloaded from a central repository and packaged with their software.
We envision that DIFF-PROF's approach can be extended to effectively compare source-code level profiling measurements of software in broader domains beyond mobile such as games, web frontends and server backends.
Performance and energy profiling There is a large body of work on performance profiling of sequential programs [20,15,30] and concurrent programs [17,39].
There are also several works on energy profiling for mobile apps [32,31,34,18].
EPROF [32] performs source-code-level energy profiling and accounts the energy drained by each phone component to individual app method calls.
ARO [34] performs cross-layer profiling for network usage to expose apps' inefficient interactions with lower layers.
Wattson [31] estimates app energy consumption on the developer workstation by emulating different environments such as network conditions, CPU speed and display technologies.
GfxDoctor [18] quantifies the energy drain spent in traversing the entire frame rendering stack due to each UI update.
All such profilers stop at finding performance/energy hotspots.
DIFFPROF builds on top of such traditional profilers and tackles the hard but critical question in the app energy optimization process: whether and how energy hotspots in app source code can be restructured to drain less energy.Diffing programs and runtime behavior.
(1) Programs.
There has been a large body of research to find regressions introduced from code revisions [13,36,22,23], and on data mining application source code to detect software bugs, e.g., [40].
DIFFPROF allows app developers to catch and debug energy drain regressions by comparing source-code energy profiles after code revisions.
(2) Runtime behavior.
Execution indexing [43] aligns event logs of two executions of the same program under different input or perturbations and has been used in detecting and understanding security leaks [27], deadlocks [28] and failures [45,21].
DIFFPROF aligns calling context trees of two executions that may be from apps written by different developers to find energy inefficiencies.Diffing beyond programs.
More generally, diffing is a pervasive technique that celebrates and exploits diversity and has been applied to many other scenarios in computer systems and networking.
Diffing data has been applied to storage data for data compression (e.g., [29]), to network traffic for traffic reduction (e.g., [11,10]), to data structures in memory images for detecting polymorphic malware [16], and to frames for reducing graphics energy for mobile devices [25].
Beyond data, many systems, e.g., PeerPressure [42], ClearView [33], Shen et al. [37], Encore [46], and DiffProv [14], apply diffing to learn or detect deviations from the correct or reference behavior, via statistical analysis or data mining, for detecting and diagnosing misconfigurations, performance anomalies or faulty events in the network and distributed systems.
This paper presents differential energy profiling which tackles the hard but critical question in the app energy optimization process faced by app developers: whether and how energy hotspots in app source code can be restructured to drain less energy.
By performing approximate matching of energy profiles of similar apps by a traditional energy profiler, energy diffing automatically uncovers more efficient implementations of common app tasks and app-unique tasks among similar apps.
We show how our prototype DIFFPROF tool provides developers with actionable diagnosis beyond a traditional energy profiler: it effortlessly reveals 12 inefficient or buggy implementations in 9 apps, and it further allows (non)developers to quickly understand the reasons and develop fixes for the energy difference.
s1 We did not include social networks because their main app functions appear to differ (e.g., Facebook, twitter, snapchat).2 F-method-only paths will be patched to other tasks as discussed in §3.5.3 Refer to [9] for more details on calling context tree construction.
4 A maximal one-to-one matching matches the most nodes in the two trees.
5 Our approach to tracking events is similar to AppInsight [35], but instead of instrumenting app binary, we directly modify the Android framework to track asynchronous calls.
Since we use timestamp and thread id in addition to hashCode to track objects, we did not see problems due to hashCode collisions in our experiments.
6 Since EPROF does not break down app energy drain into native code methods -it simply folds native code's energy into JNI boundary method for Java, DIFFPROF would not be able to identify tasks in native code.
In practice, tasks typically start from framework callback Java methods and hence most of the task structures are captured in the Java methods that invoke the native code.
1 We did not include social networks because their main app functions appear to differ (e.g., Facebook, twitter, snapchat).2 F-method-only paths will be patched to other tasks as discussed in §3.5.3 Refer to [9] for more details on calling context tree construction.
4 A maximal one-to-one matching matches the most nodes in the two trees.
5 Our approach to tracking events is similar to AppInsight [35], but instead of instrumenting app binary, we directly modify the Android framework to track asynchronous calls.
Since we use timestamp and thread id in addition to hashCode to track objects, we did not see problems due to hashCode collisions in our experiments.
6 Since EPROF does not break down app energy drain into native code methods -it simply folds native code's energy into JNI boundary method for Java, DIFFPROF would not be able to identify tasks in native code.
In practice, tasks typically start from framework callback Java methods and hence most of the task structures are captured in the Java methods that invoke the native code.
