We investigate a number of problems related to infinite runs of weighted timed automata, subject to lower-bound constraints on the accumulated weight.
Closing an open problem from [10], we show that the existence of an infinite lower-bound-constrained run is-for us somewhat unexpectedly-undecidable for weighted timed automata with four or more clocks.
This undecidability result assumes a fixed and known initial credit.
We show that the related problem of existence of an initial credit for which there exists a feasible run is decidable in PSPACE.
We also investigate the variant of these problems where only bounded-duration runs are considered, showing that this restriction makes our original problem decidable in NEXPTIME.
Finally, we prove that the universal versions of all those problems (i.e, checking that all the considered runs satisfy the lower-bound constraint) are decidable in PSPACE.
Weighted (or priced) timed automata [3], [2], [9] have emerged as a useful formalism for formulating a wide range of resource-allocation and optimization problems [4], [14], with applications in areas such as embedded systems [18].
In [10], a new class of resource-allocation problems was introduced, namely that of constructing infinite schedules subject to boundary constraints on the accumulation of resources.More specifically, we proposed weighted timed automata with positive as well as negative weight-rates in locations, allowing for the modeling of systems where resources (e.g. energy) are not only consumed but also possibly produced.
As a basic example, consider the two-clock weighted timed automaton A in Fig. 1 with infinite behaviours repeatedly delaying in 0 , 1 , 2 and 3 for a total duration of two time units, with one time unit spent in 0 and 3 and one time unit spent in 1 and 2 .
The weights (+2, +3 and +4) in the four locations indicate the rate by which energy is produced (or consumed, when negative), and the weights (−2 and −3) on the edges indicate instantaneous updates to the energy level.
Clearly, the energy remaining after a given iteration will depend not only on the initial energy but also highly on the distribution of the two time units over the four locations.
In this paper we consider a number of problems related to infinite runs subject to lower-bound constraints on the accumulated weight, i.e., infinite runs where the energy level never goes below zero.
In the absence of an upper bound, it suffices to consider runs along which the accumulated weight is maximized.
Fig. 2 illustrates three such energy-maximizing behaviours of A. For initial energy 8, the maximum energy left after one iteration is 8, thus providing an infinite lower-bound schedule.
In contrast, an initial energy-level of 1 does not even permit a single iteration (let alone an infinite schedule), and an initial energy-level 2 leaves at maximum 1, for which we already know that no infinite lower-bound schedule exists.
In fact, from Fig. 3(a)-which gives the maximum final energy e f as a function of the initial energy-level e 0 -it follows that 5 is the minimum initial energy-level which permits a lowerbounded infinite schedule (notice that the optimal schedule with initial credit 8 can be played with initial credit 5).
Moreover, Fig. 3(b) indicates optimal schedules (the solid line) in terms of the optimal delay t 0 to be spent in 0 given the initial energy-level e 0 .
The dashed area corresponds to pairs (e 0 , t 0 ) for which no feasible run exists.
Inside the feasible area, the optimal final credit is e f = e 0 − t 0 on the right of the solid line, while it is e f = 2e 0 + 2t 0 − 5 on the left.
For weighted timed automata with a single clock and a single weight variable, the existence of a lower-bound constrained infinite run has been shown decidable in polynomial time [10] with the restriction that no discrete updates of the accumulated weight occur on transitions.
In [8], it is shown that the problem remains decidable if this restriction is lifted and even if the accumulated weight grows not only linearly but also exponentially.
In contrast, the existence of interval-constrained infinite runs-where a simple energy-maximizing strategy does not suffice-have recently been proven undecidable for weighted timed automata with varying numbers of clocks and weight variables: e.g. two clocks and two weight variables [17], one clock and two weight variables [13], and two clocks and one weight variable [15].
Also, the interval-constrained problem is undecidable for weighted timed automata with one clock and one weight variable in the game setting [10].
Still, the general problem of existence of infinite lower-bound runs for weighted timed automata has remained unsettled since [10].
In this paper we close this open problem showing that it is undecidable for weighted timed automata with four or more clocks.
Given that this problem looks rather simple (it suffices to consider energy-maximizing runs), we find this result quite surprising and somewhat disappointing.
Thus, we consider a number of related problems for which we show decidability and settle complexity.
In particular, the undecidability result assumes a fixed and known initial energy-level.
We show that the related problem of existence of an initial energy-level allowing an infinite lower-bound constrained run is decidable in PSPACE.
We also investigate the variant of these problems, where only the existence of time-bounded runs is required: for instance, for the weighted timed automaton in Fig. 1 and initial energy level of 4, we may want to settle the existence of a run along which the energy level remains non-negative during the first 4.7 time-units, say.
Note that the time-bounded paradigm has recently emerged as a pertinent restriction option for the verification of real-time systems [16] (in quite the same way as bounded model checking has been used for untimed systems [6]).
We show that this restriction makes our original problem decidable and NEXPTIME-complete.
Our result has to be compared with rectangular hybrid automata, for which time-bounded reachability has recently been shown decidable in EXPSPACE (no matching lower bound is provided, though), under the hypothesis that all rates are non-negative (if rates can be negative, the problem is undecidable) [11].
Our model of weighted timed automata is a special case of rectangular hybrid automata, in which all variables are clocks (rate 1) and one variable can have non-negative as well as negative rates.
Therefore none of the two decidability results implies the other.
Finally, we prove that the universal versions of all the above problems (i.e., checking that all the considered runs satisfy the lower-bound constraint) are decidable in PSPACE.All technical details can be found in the Appendix.
We assume X is a finite set of variables called clocks.
A valuation v of the clocks is a mapping X → R ≥0 .
If v is a valuation and t ∈ R ≥0 , we write v + t for the valuation which assigns v(x) + t to clock x.
If R ⊆ X, we write v [R → 0] for the valuation which assigns 0 to clocks in R and v(x) to x ∈ X \R.
We write Φ(X) for the set of formulas (called clock constraints) defined by φ ::= true | φ ∧ φ | x ≤ c | x ≥ c with x ∈ X and c ∈ N.
The semantics of such formulas is given by sets of valuations and defined in a natural one.A weighted timed automaton is a tuple A = L, L 0 , X, inv, E, disc, rate consisting of a finite set L of locations, a finite set L 0 ⊆ L of initial locations, a finite set X of clocks, a location invariant mapping inv : L → Φ(X), a finite set E ⊆ L × Φ(X) × 2 X × L of edges, and functions disc : L → Z and rate : E → Z which assigns a value to each location and each edge of A.The semantics of a weighted timed automaton is defined as an infinite-state transition system G A = S, T with• S = {(, v, c) ∈ L × (R ≥0 ) X × R | v |= inv()}, • T ⊆ S × S contains two types of transitions:-delay transitions, which do not involve state change:{(, v, c) → (, v , c ) | ∃t ∈ R ≥0 .
v = v + t and c = c + rate() × t} -action transitions: {(, v, c) → ( , v , c ) | ∃e = (, g, R, ) ∈ E.v |= g and v = v[R → 0] and c = c + disc(e)}.
The above semantics is that of a timed automaton with an extra weight variable, which evolves with rate rate() in location and in a discrete manner (following the disc function) when firing transitions.
Notice that if (, v, c) → ( , v , c ) ∈ T , then for all γ, there exists γ such that (, v, γ) → ( , v , γ ) ∈ T .
That is, the weight variable does not constrain the behaviour of the automaton.
A (finite or infinite) run= ( 0 , v 0 , c 0 ) → ( 1 , v 1 , c 1 ) → .
.
.
of G A will be called a weighted run, and we will sometimes use the underlying standard timed run( 0 , v 0 ) → ( 1 , v 1 ) → .
.
.
, which abstracts from the weight information.
Since two consecutive delay transitions can be merged, we require that along any run, delay and action transitions alternate (by possibly inserting zero-delay transitions between two consecutive action transitions).
We define the length of a run as its number of action transitions.If ( 0 , v 0 , c 0 )is the first state of run , c 0 is the initial credit; is said to be initial if 0 ∈ L 0 and v 0 = 0, the valuation which assigns 0 to every clock.
If is a timed run, then for every initial credit c 0 there is a unique corresponding weighted run with initial credit c 0 .
B.
The lower-bound constrained problems1) The existential and universal L-problems.
Fix an initial credit c 0 ∈ Q ≥0 .
An infinite timed run = ( 0 , v 0 ) → ( 1 , v 1 ) → ( 2 , v 2 ) . . . of A satisfies the lower-bound constraint L(c 0 ) (which we write |= L(c 0 )) if the corresponding weighted run ( 0 , v 0 , c 0 ) → ( 1 , v 1 , c 1 ) → ( 2 , v 2 , c 2 ) .
.
.
with initial credit c 0 has c i ≥ 0 for every i.
In that case we say that the run is feasible with initial credit c 0 or simply that the corresponding weighted run is feasible.
We say that A |= ∃ ∞ L(c 0 ) (resp.
A |= ∀ ∞ L(c 0 )) whenever there exists an initial infinite run s.t. |= L(c 0 ) (resp.
for every initial infinite run with initial credit c 0 , it holds |= L(c 0 )).
The first (resp.
second) problem is called the existential (resp.
universal) L-problem, and denoted with∃ ∞ L(c 0 ) (resp.
∀ ∞ L(c 0 )).
2) The time-bounded L-problems.
Fix an initial credit c 0 ∈ Q ≥0 and a time bound T ∈ Q ≥0 .
A timed run = ( 0 , v 0 ) → ( 1 , v 1 ) → ( 2 , v 2 ) . . . satisfies the T -time-bounded lower- bound constraint L(c 0 ) (which we write |= T L(c 0 )) whenever the following holds 1 :• the total duration of is at most T , and can be strictly less than T only if is infinite.
We let p 0 be the number of transitions along ;• if ( 0 , v 0 , c 0 ) → ( 1 , v 1 , c 1 ) → ( 2 , v 2 , c 2 ) .
.
.
is the weighted run corresponding to with initial credit c 0 , then for everyi ≤ p 0 , c i ≥ 0.
We then say that A |= ∃ T L(c 0 ) (resp.
A |= ∀ T L(c 0 ))whenever there exists an initial run such that |= T L(c 0 ) (resp.
for all initial finite run of duration T and for all initial infinite run of duration at most T , it holds |= T L(c 0 )).
The first (resp.
second) problem is called the existential (resp.
universal) time-bounded L-problem .
In short we write∃ T L(c 0 ) (resp.
∀ T L(c 0 )).3) Existence of an initial credit.
The above four problems assume a fixed and known initial credit.
We will be interested also in the existence (and synthesis) of an initial credit for which the previous problems can be answered positively.
Formally, for Q ∈ {∃, ∀} and α ∈ {∞, T }, we write A |= ∃c 0 .
Q α L(c 0 ) whenever there exists an initial credit c 0 ∈ Q ≥0 such that A |= Q α L(c 0 ).
In short we denote this problem by ∃c. Q α L(c).
In this paper we solve the various above-mentioned problems.
Our results are summarized in Table I (the previously known result is displayed in gray).
Parameter Q is for existential or universal problem, whereas parameter α is for unbounded (∞) or bounded (T ) time.
In this table, constraints such as ≥ 3 refer to the number of clocks.
When unspecified, we mean that the result holds for arbitrarily many clocks.III.
UNDECIDABILITY OF A |= ∃ ∞ L(e 0 )We first prove the undecidability of the existential L-problem.
While its proof is not of the most difficult, the result is quite surprising (at least to us) as the problem looks rather simple (it amounts to checking that, by maximizing the accumulated weight, we can keep it non-negative).
Theorem 1.
The existential L-problem is undecidable for the class of weighted timed automata with at least four clocks (and rates in {0, 1}).
We only give a proof sketch here, which is simple to understand but requires five clocks.
Another proof can be obtained by using the encoding of the hardness proof in Section IV-B.
Sketch of proof: Consider the automata depicted on Fig. 4.
Writing x 0 for the value of clock x when entering 0 , the effect of these automata is to add x 0 (resp.
1 − x 0 ) to the weight, while preserving the value of all the clocks (provided that these values are in [0, 1)).
Using these modules, it is then easy to enforce linear constraints between clocks: Fig. 5 is an example, in which each box is a copy of one of the automata of Fig. 4 (after possibly exchanging the role of x and y).
Discrete values between boxes represent a discrete increase or decrease of the weight variable.
It is easily checked that for any run in this module with initial credit 0 and clock values x 0 and y 0 for clocks x and y, the final weight is 0 and the final values of the clocks are unchanged (assuming they are in [0, 1)).
Moreover, such a run exists if, and only if, y 0 ≤ 2x 0 .
One can obviously adapt this module to check any linear constraint between clocks, which entails undecidability (for instance by encoding additive constraints in timed automata, for which reachability is undecidable [5]).
This reduction uses five clocks, but the above automata for checking additive constraints can also be used to encode Turing machines, using only four clocks (cf. Section IV-B).
IV.
DECIDABILITY OF A |= ∃ T L(c 0 )In this section, we show that we recover decidability when we restrict to the time-bounded L-problem.
We also characterize the exact complexity of this problem.
Existence of initial creditP P P P P P α Q ∃ ∀ ∃ ∀ ∞ ≤ 1: decidable [8] ≥ 4: undecidable in PSPACE ≥ 3: PSPACE-c.
in PSPACE ≥ 3: PSPACE-c.
Tin NEXPTIME ≥ 5: NEXPTIME-c.
Theorem 2.
The existential time-bounded L-problem is NEXPTIME-complete (resp.
NP-complete) for weighted timed automata with five clocks or more, when the time bound is given in binary (resp.
unary).
We sketch the proof of the upper bound.
Full details are given in Appendix A.We fix a weighted timed automaton A and assume that it has an extra clock u that is never reset.
We fix a time bound T ∈ Q ≥0 and an initial credit c 0 ∈ Q ≥0 .
Our approach consists in building a finite (exponential-size) witness from any run witnessing A |= ∃ T L(c 0 ); our algorithm will then nondeterministically pick a path and check that it is a witness.
As stated in Lemma 3, the new witness may have the same duration as the original one, or it may end in a configuration from which there is a feasible zero-delay cycle with non-negative effect on the accumulated weight.
Such a cycle will be called a profitable zero-delay cycle (see Appendix A1).
Below, we explain the proof for the case where the initial run is finite.
The case where the witness is infinite reduces to that case (see Appendix A6).
1) Reduction scheme.
Theorem 2 is a consequence of the following lemma, which we explain below.Lemma 3.
If A has a feasible run from some ( 0 , v 0 , c 0 ) to some (, v, c) of duration at most T , then it also contains a feasible run of length 2 N in O(T · |X| 3 · |L| 2 ), starting from ( 0 , v 0 , c 0 ) and ending in ( , v , c ) such that• either ( , v ) = (, v) and c ≥ c and v (u) = v(u), • or from ( , v , c ) there is a profitable zero-delay cycle.The general idea for proving this lemma is to split the witness into a small number of chunks, which we prove (in Lemma 5) can be made short while (broadly speaking) preserving the total time elapse and and increasing the accumulated weight.For the rest of the proof we assume we are given a finite weighted run : ( 0 , v 0 , c 0 )δ(t0) − −− → ( 0 , v 0 + t 0 , c 0 ) e1 − → ( 1 , v 1 , c 1 ) δ(t1) − −− → ( 1 , v 1 + t 1 , c 1 ) . . . witnessing the fact that A |= ∃ T L(c 0 ).
The [i..
j]-segment of , denoted [i..
j], is defined as ( i , v i , c i ) → · · · → ( j , v j , c j ).
Segment [i..
j] is said flexible whenever for every clock x ∈ X \ {u}, there exist an integer2 Precisely, N = 1 + (|X| + 1) · (1 + (|L| + 1) · |L| · (|X| + 1) 2 ) · (T + 1), where T is the integral part of T .
0 ≤ d x ≤ M (where M is the maximal constant of A) and an index h x > i such that• clock x is not reset along [i..
h x − 1]; • for every i ≤ k < h x , it holds d x ≤ v k (x) ≤ d x + 1 (we assume M + 1 = ∞), • and for every h x ≤ k ≤ j, it holds 0 ≤ v k (x) ≤ 1.
The terminology flexible comes from the fact that we can modify delays along a flexible segments, while keeping the global time elapsed.
The following lemma states that a segment of duration less than 1 is made of few flexible sub-segments.
Lemma 4.
Let [i..
j] be a segment of duration less than 1.
Then [i..
j] can be split into at most |X| + 1 many flexible segments.
The sum of the lengths of the sub-runs which do not take part in a flexible segment is bounded by |X|.
Consider a flexible segment [i..
j] = ( i , v i , c i ) δ(ti) − −− → . . . ej − → ( j , v j , c j )along which clock u has constant integral part.
We define, for every i < h ≤ j, δ j = h−1 k=i t k .
For every clock x that is reset along [i..
j] we write m x (resp.
n x ) for the index of the first (resp.
last) edge along which x is reset.
The run [i..
j] is depicted on Fig. 6.
We transform [i..
j] into a (shorter) run i→j that starts in ( i , v i , c i ) and fires edges e j (resp.
e mx , e nx ) after exactly δ (resp.
δ mx , δ nx ) time units.
Furthermore that run will not reset clock x before firing e mx after δ mx time units, and it will not reset clock x after having fired e nx after δ nx time units (see Fig. 6).
This enforces that the clock constraints are satisfied along the new run, and that the final state of is the same as that of .
Edges e mx , e nx (for x ∈ X) and e j act as checkpoints.
Between two checkpoints we "optimize" the accumulated weight (which ensures that c j ≥ c j ) and shorten the path (which proves the existence of a short witness).2) Transformation of a segment between two checkpoints.
We first focus on one segment between two checkpoints.
It is characterized by a constraint described by a tuple γ = ((, v, c), α, e, B, R, c ) where:(a) (, v, c) is the initial state of that segment, (b) the duration α ∈ R >0 of that segment (with the assumption that frac(v(u)) + α < 1), (c) the final edge e of that segment, (d) the set B ⊆ X of clocks that should not be reset along that segment, (e) the set R ⊆ X of clocks that should have value 0 at the end of the segment (when firing e),e mx e my = e ny e nx e j [i..
j] × ( i , v i , c i ) × ( j , v j , c j ) first reset of x unique reset of y last reset of x δ mx δ my = δ ny δ nx δ j checkpoints e mx e my = e ny e nx e j i→j × ( i , v i , c i ) × ( j , v j , cj ) with c j ≥ c j no reset of x no reset of x no reset of y no reset of y (f ) a lower bound c ∈ R ≥0 for the accumulated weight at the end of the segment.
We write R γ (A) for the set of runs satisfying constraint γ (defined in an obvious way).
Intuitively, if we replace a segment of a feasible run with another segment satisfying the same constraint γ, then the newly constructed run is still feasible.
The following lemma shows that any constraint γ can be fulfilled by a short segment.Lemma 5.
Let K = (|L| + 1) · (|L| · (|X| + 1)).
The following two properties are equivalent:(i) there is a finite run in R γ (A); (ii) there is a run of length at most K that either is in R γ (A) or reaches a state ( , v , c ) from which there is a profitable zero-delay cycle.Roughly, the idea is to postpone any delay in a location with negative rate to the latest appearance of that location along the run, and to transfer all delays in a location with positive rate to its first appearance along the run.
This transformed run is in R γ (A), delays in at most |L| locations, and still satisfies the lower-bound constraint on the rate.
Then we can remove the zero-delay cycles (unless they are profitable).3) Completing the study of a flexible segment.
We glue runs we have constructed for all segments between two checkpoints (this requires some technical details that can be found in Appendix A5), and we get a run i→j , which starts in ( i , v i , c i ), has length at most (2|X| + 1) · K, satisfies the lower-bound constraint, and• either it ends in ( j , v j , c j ) with c j ≥ c j , and has duration that of [i..
j];• or it ends in a state from which there is a profitable zero-delay cycle, and its duration is at most that of [i..
j].
4) Conclusion and complexity.
We apply the previous constructions: we first split the run into segments along which the integral part of u is constant (there are T such segments).
Applying Lemma 4 we chunk each of these segments into at most |X| + 1 flexible segments.
We can then change these segments into short segments of length at most (2|X| + 1) · K each.The maximal length of the short witness is therefore inO(T · |X| 3 · |L| 2 ).
By guessing a sequence of consecutive edges of that length in A and then doing some linear programming resolution, we can check whether there exists a feasible witness along that sequence of edges.
This is an NEXPTIME procedure when T is given in binary.
It runs in NP if T is encoded in unary.
We reuse the modules defined in the proof of Theorem 1 for checking linear constraints between clocks.
These modules can be used to check constraints of the form αx + βy + γ ≥ 0, for integers α, β and γ.
If we allow integer rates (instead of only 0 and 1), we can assume the total time spent to check such a linear constraint is constant (2 time units).
1) Encoding a rule of a Turing machine.
We encode a (nondeterministic) Turing machine over alphabet {0, 1} as follows.
Assume the tape content is w 1 (q, a)w 2 where w 1 , w 2 ∈ {0, 1} * , q is a state of the Turing machine and a ∈ {0, 1} is the content of the cell which is being read.
We encode this with a location (q, a) and with the values of two clocks x 1 and x 2 , whose binary representation will be enc(x 1 ) = 0.
w 1 (we write w 1 for the word obtained from w 1 by reading from right to left) and enc(x 2 ) = 0.
w 2 .
We assume that (b, →, q ) ∈ δ(q, a) is a possible transition from (q, a) in the Turing machine.
In order to be able to mimic that transition, we want to go to state (q , c) with two clocks 3 y 1 and y 2 such that enc(y 1 ) = 0.
b · w 1 and enc(y 2 ) = 0.
w 2 where w 2 = c · w 2 .
The symbol c ∈ {0, 1} is the content of the new cell which is pointed.
In terms of value, we have to enforce:y 1 = 1 2 x 1 + 1 2 b and y 2 = 2(x 2 − 1 2 c).
The module is depicted on Fig. 7.
We write U on a transition instead of u = 1, u := 0.
On every locations, for every clock x that is not already used in an outgoing transition, there is a self-loop x = 1, x := 0, which is omitted on the figure (for readability).
The module works as follows: (a) in the first part (until module Test(2y 1 = x 1 + b)), the automaton non-deterministically resets clock y 1 , and checks that the new value has the property that after exactly two time units (i.e. after the second U -transition), it holds y 1 = (x 1 + b)/2.
(b) then, non-deterministically again, the automaton jumps to one of the two branches:• the left branch corresponds to the case where c = 1: this is checked by the module Test(2x 2 ≥ 1).
We then have to set y 2 accordingly, which is achieved by nondeterministically resetting y 2 and checking that y 2 = 2x 2 − 1.
• the right branch is for the case where c = 0: the encoding is similar to that used in the upper branch, adapted to the fact that c = 0.
Notice that we have to test a strict inequality, namely 2x 2 < 1.
This is achieved by crediting the variable with 1 − 2x 2 and checking that this value is positive.
This in turn can be tested by the module depicted on Fig. 8: this module checks positiveness of the weight variable while preserving the values of the weight and of all clocks, except z. 4 We assume that the total time needed to traverse this module is the same along both branches (even if it means adding some more states).
We write d 1 for that constant.2) The global reduction.
We fix a non-deterministic Turing machine M and an input u of length n.
We use the encoding of instructions of a non-deterministic Turing machine as in the previous section, and we glue all modules together to get automaton A.
We add an initialization module which leads to (q 0 , u 1 ), set x 1 to 0 and x 2 to n i=2 u i 2 −(i−1) ; this can easily be achieved using module Test(2 n−1 x 2 = n i=2 u i 2 n−i ), in total time d 2 = n − 1 (using rates 2 n−1 , 2 n−2 ).
We parametrize A with an integer K, yielding A [K].
In A [K], a new clock t is reset when reaching the initial state of M (after the initialization phase), and is used in an invariant t ≤ d 1 K in all locations (except the initialization phase and the halting location).
Furthermore from every location (except locations of the initialization phase and the halting location) we can go to a sink location with discrete weight −4 when t ≥ d 1 K (we call these transitions the bad transitions).
Notice that the maximal value of the accumulated weight within a module while mimicking the instructions of M never exceeds 3: hence, if this transition to the sink state is taken, then the lower-bound constraint will be violated.
The halting location has no outgoing transition, and we can wait there as long as we want, with rate zero.Note that automaton A has five clocks (four clocks for simulating the instructions of the Turing machine, and the extra clock t).
Proposition 6.
M halts on input u with a computation of at most K steps if, and only if,A[K] |= ∃ (d1K+d2)+1 L(0).
q, a Test(2y 1 = x 1 + b) Test(2x 2 ≥ 1) Test(2x 2 < 1) Test(y 2 = 2x 2 − 1) Test(y 2 = 2x 2 )q , 1 q , 0 Proof: Assume M has a halting computation of length k (with k ≤ K) on u.
In A, we can first safely initialize the two clocks and reach the initial state of the Turing machine.
The initialization phase takes d 2 time units.
Then all instructions can also be safely mimicked, and each instruction takes d 1 time units.
Hence globally the execution takes then d 2 + d 1 k time units before reaching the halting location, and we can wait there enough time to meet the requirement.y 1 := 0 U U U U U U y 2 := 0 y 2 := 0 U U U U u := 0Assume that A[K] |= ∃ (d1K+d2)+1 L(0).
Then it means that we have first safely initialized the clocks, and then mimicked properly instructions.
And then as we have not violated the lower-bound constraint, it means that we have reached a halting location at the latest when t = pK (since otherwise we should have taken the bad transition to the sink state, violating the lower-bound constraint).
If K is exponential (in n), the binary encoding of K, and therefore the binary encoding ofd 1 K + d 2 , is polynomial.The above reduction implies NEXPTIME-hardness for the existential time-bounded L-problem when the time bound is given in binary.
If K is polynomial in n, the unary encoding of d 1 K +d 2 is polynomial (since d 1 is a constant and d 2 = n−1).
This implies NP-hardness for the existential time-bounded Lproblem when the time bound is given in unary.Remark 7.
Notice that if we lift the time bound (hence we remove clock t), we encode a (generic) non-deterministic Turing machine.
This provides another proof of Theorem 1, which uses only four clocks.
In this section we show that the universal L-problems are much easier to solve than the existential L-problems.
Theorem 8.
The universal and the universal time-bounded L-problems are PSPACE-complete.
The PSPACE lower bounds are straightforward reductions from the reachability problem in timed automata: if there is a run reaching the final location, then there is a run of duration at most T def = |R(A)|, where R(A) is the region automaton of A (see [1]).
Therefore by giving a negative rate to accepting locations and rate zero to other locations, the non reachability problem is equivalent to the universal L-problem, time-bounded (by T ) or not.The PSPACE upper bound can be proven using the cornerpoint abstraction R cp (A) of A (see [7]).
The result then relies on the following lemma.
.
n], which violates the lower-bound constraint: there is 0 ≤ i ≤ n such that c i < 0.
Then applying [7, Prop. 3] we get that there is a finite path π in R cp (A) with the cost being smaller: this path violates the constraint as well.Conversely take an infinite path π in R cp (A) which violates the lower-bound constraint, and take a violating prefix.
Then applying [7, Prop. 6], for every ε > 0, we get a real path whose cost is ε-close to that of π, hence becomes negative (for ε small enough).
Lemma 10.
R cp (A) |= ∀ ∞ L(c 0 ) if, and only if, one of the following conditions is satisfied: (1) there is a reachable cycle with a negative effect; (2) there is an acyclic path from the initial state, which can be extended into an infinite path, that yields a negative cost.Proof: Take a path which violates the lower-bound constraint.
If it contains a cycle with negative effect, then (1) holds.
Otherwise consider a prefix which violates the lower-bound constraint.
We can remove from that prefix all cycles (since they have non-negative effect), and we still get a counter-example, which furthermore satisfies (2).
The above conditions can be checked in PSPACE (the size of R cp (A) is exponential, and a path in R cp (A) can be guessed using polynomial space).
This algorithm can be adapted to handle the time-bounded problem, by adding a clock u, which is never reset, but is used in an invariant u ≤ T on every location.
From every location we add a transition constrained by u = T leading to a sink location where cost remains constant.
This yields an automaton B such that A |= ∀ T L(c 0 ) if, and only if, B |= ∀ ∞ L(c 0 ).
We apply the previous algorithm to B.
The size of R(B) is exponential in the size of A and T .
This yields a PSPACE algorithm for deciding A |= ∀ ∞ L(c 0 ).
We prove here that if the initial credit is not known, then all the problems can be solved in PSPACE.
More precisely we prove the following theorem.Theorem 11.
The existence of an initial credit is PSPACEcomplete for all the L-problems (existential or universal, timebounded or not).
The complete proof of this theorem can be found in Appendix B.
The lower bounds are straightforward by reduction from the reachability problem in timed automata, which is known to be PSPACE-hard already when there are three clocks [12].
a) The time-bounded case.
In order to prove the upper bounds for the time-bounded problems, the idea is to reduce the size of possible witnesses using a construction similar to that in Lemma 3, which allows to bound the cost variation along a possible witness and therefore gives information on how much the initial credit needs be for satisfying the lower-bound constraint along the witness.
We give the details only for the time-bounded universal problem.
It relies on the following characterisation, which can be checked in polynomial space.Lemma 12.
A |= ∃c.∀ T L(c) if, and only if, there is a finite initial timed run of duration at most T , which ends in some configuration (, v) s.t. from (, v), there is a zero-delay cycle with negative accumulated weight.Proof: The right-to-left implication is obvious.Assume A |= ∃c.∀ T L(c) and fix a timed run of duration at most T (those will be the only possible witnesses contradicting ∀ T L(c)).
We transform as in the proof of Lemma 3 but we minimize the weight instead of maximizing it (and we do not require the lower-bound on the weight be satisfied).
This yields an alternative finite run which satisfies the following conditions (N s the uniform bound of Lemma 3):• its duration is at most T and its length is at most N ;• at any point in time, its accumulated weight is smaller than that of ; • additionally, either (i) it reaches a state (, v), from which there is a zero-delay cycle with a negative accumulated weight, or (ii) its duration is that of .
Assume we are in case (ii).
If we start with initial credit 0, the cost never goes below −(N + T ) · R where R is the maximal absolute value for a rate or a weight decorating a location or an edge of the automaton.
Therefore by setting c 0 = (N + T ) · R, we get that |= L(c 0 ).
By construction, has smaller accumulated weight than at any point in time, which implies |= L(c 0 ).
Assume towards a contradiction that case (i) never happens.
Then, for all runs of duration at most T , |= L(c 0 ).
This contradicts the assumption that A |= ∃c.∀ T L(c).
Therefore there is a run such that its corresponding satisfies (i).
b) The time-unbounded case.
For proving the upper bound for the standard problems, we rely on the corner-point abstraction R cp (A) (see [7]).
The case of ∃c.∀ ∞ L(c) is not very difficult.We give the proof for ∃c.∃ ∞ L(c) since it is more involved.
It relies on the following lemma, which immediately yields the PSPACE upper bound.Lemma 13.
A |= ∃c.∃ ∞ L(c) if, and only if, R cp (A) |= ∃c.∃ ∞ L(c).
Proof: Let be a witness for A |= ∃c.∃ ∞ L(c).
We project on R cp (A), yielding an infinite weighted tree.
For each index i there is a branch π i of length i of the tree, with overall weight better than that of [0.
.
i] ( [7, Prop. 6]).
Since the tree is finitely branching, applying König's lemma, there is an infinite branch π of the tree such that π i coincide with π[0.
.
i].
Let i 1 , . . . , i n , . . . the sequence of such positions i's.
W.l.o.g. we assume that the accumulated weight along (π[0.
.
i]) for i → ∞ converges, say to γ (which might be infinite).
If γ is finite, this is a stationary sequence (since R cp (A) is weighted finite automaton with integral values), and we can therefore find a cycle with overall weight zero: this yields a witness for the property (we can then easily compute a bound for the initial credit).
If γ = ∞, then we can find an increasing sub-sequence, and we therefore exhibit a cycle with positive weight, yielding a witness.Assume now that π is a witness for R cp (A) |= ∃c.∃ ∞ L(c).
As clock constraints are non-strict, π is a real timed run in A, which witnesses the property.
In this paper, we have shown the surprising result that exhibiting an infinite path in a weighted timed automaton satisfying a lower-bound constraint on the cost is actually undecidable when the initial credit is fixed.
On the other side, we have considered different variants of that problem, which we proved decidable.
The most notable one is the existence of a time-bounded path satisfying the lower-bound constraint, which we prove can be decided in NEXPTIME.As further work we want to investigate slightly different models for energy consumption, where for instance, the cost can be set to 0 in some places.
We think the time-bounded paradigm makes sense and we would like to push it further by analyzing the decidability of various problems which are unfortunately undecidable in general.
One of the problems of interest is the existence of a path that satisfies both a lowerbound and an upper-bound constraints.
A. Proof of Theorem 2 1) Zero-delay cycles.
A zero-delay cycle on state (, v) is a path starting and ending in (, v) in which all delay transitions are 0-delay.
In particular, such a cycle cannot visit a resetting transition, unless the reset clock already has value 0 in v.Our first task is to detect those configurations from which a zero-delay cycle is feasible.
For a state (, v) and a nonnegative real c, we set the Boolean predicate profit((, v), c) to true if, and only if, there is a zero-delay cycle from (, v, c) back to (, v, c ) for some c ≥ c, along which the lowerbound constraint is satisfied.
Such a cycle is called a profitable zero-delay cycle.
Note that profit((, v), c) = profit((, v ), c) whenever v and v belong to the same region r, so that the region-based predicate profit((, r), c) is well-defined (in the obvious way).
Detecting zero-delay cycles can be done efficiently:Lemma 14.
Given (, r), we can compute in polynomial time the smallest c such that profit((, r), c), if any.
Furthermore it is a natural number.Proof: Consider the sub-graph of the region automaton where only region r appears.
This is a weighted graph whose size is at most |L|.
Using a modified Bellman-Ford algorithm [10], we can compute the least c for which profit((, r), c), if any.
This algorithm runs in polynomial time, and returns a natural number (because discrete weights are integers).
We use this predicate to abstract weighted runs: from a state (, v, c) satisfying profit((, v), c), there is an infinite (Zeno) run satisfying the lower-bound constraint 5 .
Furthermore as we shall prove in Section A6, any (Zeno) infinite witness will visit a state satisfying profit((, v), c).
Hence we have reduced our problem to that of finding a finite witness, either with duration T or with duration less than T but ending in a state which carries a profitable zero-delay cycle.2) Proof of Lemma 4.
Since [i..
j] has duration less than 1, there are at most |X| many delay transitions along which some clock reaches the upper bound of the unit interval to which it belongs (that is, changes integral part with no reset operation).
Each segment between any two consecutive such transitions is clearly flexible.3) Equivalence between constraints.
We need to know how the fractional parts of the clocks compare to that of universal clock u.
A valuation v is said Y -small (for some Y ⊆ X) whenever for every y ∈ Y , it holds 0 ≤ frac(v(y)) ≤ frac(v(u)).
Notice that for any t < 1 − frac(v(u)), any valuation reached from v within t time units is Y -small.
The following lemma characterizes equivalent constraints: ), we have that:Lemma   ∀x ∈ (X \ Y ) ∩ B, v (x) = v (x) ∀x ∈ R, v (x) = v (x) = 0 v and v are ((X \ B) ∪ Y )-smallProof: Pick a flexible run in R γ (A).
We explain why this run can be mimicked (with the same delay-and action transitions) from (, v, c), yielding a flexible run in R γ (A).
Write for the run (we prove below that all guards are fulfilled, so that this is really a run in A) obtained by mimicking from (, v, c).
v agree, so that all conditions are fulfilled for being a flexible run in R γ (A).
We now prove the second point.
Along both and , clocks in B are not reset (except possibly for those also in R).
Therefore as v and v initially agree on X \ Y , we get the two first lines.
The third point is straightforward.
5 Notice that, using similar techniques, we could easily handle different variants of our time-bounded problem, for instance if it is required that the witness run must have duration at least T : when a state (, v, c) with profit((, v), c) is visited, the weight variable can be made arbitrarily large, and the lower-bound constraint is lifted.
It just remains to decide the existence of a run along which a sufficient amount of time elapses, with no weight constraint.
4) Proof of Lemma 5.
Pick a finite run in R γ (A), and modify it as follows: for every location 1 in which a positive delay is spent along , do the following:• if rate( 1 ) ≥ 0, then transfer all delays spent in such a location to the first occurrence of 1 along where some positive delay is already spent; • if rate( 1 ) < 0, transfer all delays spent in such a location to the last occurrence of 1 where some positive delay is already spent.
We can do so since none of the guards along is violated because of this change: indeed, if x ∈ B, from the first positive delay on, x is in (c; c + 1) all along (as is flexible and x is not reset along ).
If x / ∈ B, then v is {x}-small.
Assume that some transition has a guard x = c (with c > 0) along .
Then no delay is spent before this transition, or no delay is spent after.
Hence there is no transfer of delay from one side of this transition to the other, so that the guard is still fulfilled in the new run.
Similarly, if there is a guard x = 0 in the original run, then no time is elapsed since the previous reset of x (or since the beginning if x is zero at the beginning), and the guard is still fulfilled in the new run.
Finally, if there is a guard x ∈ [c; c + 1], then transferring delays to the beginning of the run (before a reset of x) may increase the value of x, but as v(x) < v(u) and frac(v(u)) < 1 all along , then x ∈ [c; c + 1] is still fulfilled along the new run.
Transferring delay after a reset of x would still keep x ∈ [0; 1].
The modified run delays in at most |L| locations, the lowerbound constraint is still satisfied (because the accumulated weight in any location of the new run is at least as high as in the original run).
We name the new run, which is a new witness for (i).
Consider a sub-run of that is taken in 0-delay: if a state ( 1 , v 1 ) is visited twice along that sub-run and if the corresponding cycle has a non-positive effect, then we can remove that part of the run, the overall weight will be larger and we still have a witness for (i); if a such a cycle has a positive effect, then profit(( 1 , v 1 ), c 1 ) is true (c 1 is the credit at the first visit), and the rest of the run can be dropped.The resulting run delays in at most |L| locations, and is acyclic in the 0-delay segments.
In a 0-delay segment, once a clock is reset, it remains equal to 0: therefore, the length of such an acyclic 0-delay segment is at most |L|·(|X|+1).
The length of the resulting run is thus bounded by (|L|+1)·(|L|·(|X|+1)).
This run is a witness for (ii).
5) Flexible segments.
We come back to our flexible segments[i..
j] = ( i , v i , c i ) δ(ti) − −− → . . . ej − → ( j , v j , c j ), and consider the checkpoints defined earlier.
We write I = {i, j} ∪ {m x , n x | x ∈ X} for the indices corresponding to checkpoints, and we assume that it is ordered as I = {i 0 < i 2 < · · · < i p }.
For each 0 ≤ h < p, we consider the constraintγ h = (( i h , v i h , c i h ), δ i h+1 − δ i h , e i h+1 , B h , R h , c i h+1 )where B h = {x ∈ X | h < m x or h ≥ n x } and R h = {x ∈ X | v i h+1 (x) = 0}.
The set B h is the set of clocks that should not be reset.
We first argue why this is a proper constraint.
Condition (b) is by assumption on clock u whereas condition (d) requires some arguments that we give now.
Pick y / ∈ B h : it means that m y ≤ h < n y .
We have that v i h (y) ≤ δ i h − δ my since y was reset at edge m y (and also possibly later).
In the meantime frac(v i h (u)) = frac(v(u)) + δ i h ≤ δ i h .
Therefore 0 ≤ v i h (y) ≤ frac(v i h (u)), which implies condition (d).
We build a run solving the constrained problem γ 0 , then γ 1 , then γ 2 , etc.
Constraints γ h will only differ from γ h in the initial valuation (which will still satisfy the hypotheses of Lemma 15).
First note that for every h, v i h is k<h (X \ B k ) -small.
By induction on h, we prove the following: if v i h is related to v i h as in the hypotheses of Lemma 15 (with • its length is at most (2|X| + 1) · K;Y h = k<h (X \ B k )).
We build a run in R γ h (A) (γ h is same as γ h except for the initial valuation which is v i h instead of v i h ).
The run [i h .
.
i h+1 ] is in R γ h (Ai h →i h+1 , say v i h+1 , is ((X \ B h ) ∪ Y h )-small.
By construction, for all clocks x such that v i h+1 (x) = 0 (this is R h ), v i h+1 (x) = 0.
Valuation v i• it satisfies the lower-bound problem;• if ( j , v j , c j ) is its final state, then v j = v j , and c j ≥ c j .
6) Case where the witness is infinite.
We now assume that = ( 0 , v 0 , c 0 ) → . . . ( n , v n , c n ) . . . is an infinite witness of total duration no more than T .
We will show that there is a finite run which satisfies the lower-bound constraint L(c 0 ) and which ends in a state from which it is possible to follow a zerodelay cycle while satisfying the lower-bound constraint and whose accumulated weight is non-negative (we can define a predicate profit ≥0 similar to profit, but where the accumulated weight is non-negative instead of positive).
There exists n such that the tail [n..
∞) of the witness is flexible (and clock u lies within one time unit).
For all locations 1 with rate( 1 ) > 0 in which some delay is spent along [n..
∞), we transfer all delays in location 1 to its first occurrence where some delay is spent.
We remove all delays spent in some location 2 with rate( 2 ) ≤ 0.
This yields a new witness such that m→+∞ is zero-delay: we can extract from that tail a zero-delay cycle which satisfies the lower-bound constraint and has a non-negative accumulated weight.
B. Proof of Theorem 11 1) PSPACE upper bound for ∃c.∃ T L(c).
Lemma 17.
A |= ∃c.∃ T L(c) if, and only if, there is a finite initial.
run s.t.(i) either its duration is T ; (ii) or its duration is no more than T , and it ends in configuration (, v) s.t. from (, v), there is a profitable zero-delay cycle.Proof: Assume A |= ∃c.∃ T L(c), and take a witness run .
If is finite, then (i) holds.
If is infinite, we apply a construction similar to the proof presented in Annex A6, and we get a finite run which satisfies the condition (ii).
Assume that either (i) or (ii) holds.
If (i) holds, then we can choose a large enough initial credit to compensate any decrease in the weight along : if the length of is , then if we start with initial credit 0, the cost never goes below −( + T ) · R, where R is the maximal absolute value for a rate or a weight decorating a location or an edge of A. Therefore by setting c 0 = ( + T ) · R, we get that |= L(c 0 ).
If (ii) holds, then we easily get an infinite witness for the property.
The initial credit will only be used to compensate any loo along the finite run.
Therefore A |= ∃c.∃ T L(c).
Note that in the proof above, by applying a construction to that of Lemma 3, we can bound the length of the finite paths by N .
Therefore, if there is some initial credit, then there is one which is bounded by (N + T ) · R.The two conditions of the lemma can be checked in polynomial space.
2) PSPACE upper bound for ∃c.∀ ∞ L(c).
Write R cp (A) for the corner-point abstraction of A (see [7]).
Then we show:Lemma 18.
A |= ∃c.∀ ∞ L(c) if, and only if, R cp (A) |= ∃c.∀ ∞ L(c).
This is an obvious consequence of Lemma 9.
This condition can be easily checked in polynomial space by detecting cycles with negative cost in R cp (A).
3) PSPACE lower bound for ∃c.∀ α L(c).
We fix a timed automaton A and we build the weighted timed automaton B by assigning weight and rate zero everywhere in A, and from the final location of A we go to a sink location, with a self-loop labelled with weight −1.
We define T = |R(A)|.
The following four properties are then equivalent:(i) the final location of A is reachable (ii) the final location of A is reachable in no more than T time units (iii) B |= ∃c.∀ ∞ L(c) (iv) B |= ∃c.∀ T L(c) 4) PSPACE lower bound for ∃c.∃ α L(c).
the argument is similar to the previous one: automaton B is now obtained from A by assigning weight and rate −1 everywhere: for any initial credit the weight of any run will decrease to infinity unless we allow to escape to a rate-zero location.
From the final location of A we go to a sink location, with a self-loop of weight zero.
The very same equivalent properties can be stated for this case.
