With the rapid growth of mobile devices and applications , geo-tagged data has become a major workload for big data storage systems.
In order to achieve scalability, existing solutions build an additional index layer above general purpose distributed data stores.
Fulfilling the semantic level need, this approach, however, leaves a lot to be desired for execution efficiency, especially when users query for moving objects within a high resolution geometric area, which we call geometry queries.
Such geometry queries translate to a much larger set of range scans, forcing the backend to handle orders of magnitude more requests.
Moreover, spatial-temporal applications naturally create dynamic workload hotspots 1 , which pushes beyond the design scope of existing solutions.
This paper presents Pyro, a spatial-temporal big-data storage system tailored for high resolution geometry queries and dynamic hotspots.
Pyro understands geome-tries internally, which allows range scans of a geometry query to be aggregately optimized.
Moreover, Pyro employs a novel replica placement policy in the DFS layer that allows Pyro to split a region without losing data locality benefits.
Our evaluations use NYC taxi trace data and an 80-server cluster.
Results show that Pyro reduces the response time by 60X on 1km×1km rectangle geometries compared to the state-of-the-art solutions.
Pyro further achieves 10X throughput improvement on 100m × 100m rectangle geometries 2 .
The popularity of mobile devices is growing at an unprecedented rate.
According to the report published by the United Nations International Telecommunication Union [1], mobile penetration rates are now about equal to the global population.
Thanks to positioning modules in mobile devices, a great amount of information generated today is tagged with geographic locations.
For example, users can share tweets and Instagram images with location information with family and friends; taxi companies collect pick-up and drop-off events data with geographic location information as well.
The abundances of geo-tagged data give birth to a whole range of applications that issue spatial-temporal queries.
These queries, which we call geometry queries, request information about moving objects within a user-defined geometric area.
Despite the urgent need, no existing systems manage to meet both the scalability and efficiency require-ments for spatial-temporal data.
For example, geospatial databases [2] are optimized for spatial data, but usually fall short on scalability on handling big-data applications, whereas distributed data stores [3][4][5][6] scale well but quite often yield inefficiencies when dealing with geometry queries.Distributed data stores, such as HBase [3], Cassandra [4], and DynamoDB [5], have been widely used for big-data storage applications.
Their key distribution algorithms can be categorized into two classes: random partitioning and ordered partitioning.
The former randomly distributes keys into servers, while the latter divides the key space into subregions such that all keys in the same subregion are hosted by the same server.
Compared to random partitioning, ordered partitioning considerably benefits range scans, as querying all servers in the cluster can then be avoided.
Therefore, existing solutions for spatial-temporal big-data applications, such as MD-HBase [7], and ST-HBase [8], build index layers above the ordered-partitioned HBase to translate a geometry query into a set of range scans.
Then, they submit those range scans to HBase, and aggregate the returned data from HBase to answer the query source, inheriting scalability properties from HBase.
Although these solutions fulfill the semantic level requirement of spatialtemporal applications, moving hotspots and large geometry queries still cannot be handled efficiently.Spatial-temporal applications naturally generate moving workload hotspots.
Imagine a million people simultaneously whistle taxis after the New Year's Eve at NYC's Times Square.
Or during every morning rush hour, people driving into the city central business district search for the least congested routes.
Ordered partitioning data stores usually mitigate hotspots by splitting an overloaded region into multiple daughter regions, which can then be moved into different servers.
Nevertheless, as region data may still stay in the parent region's server, the split operation prevents daughter regions from enjoying data locality benefits.
Take HBase as an example.
Region servers in HBase usually co-locate with HDFS datanodes.
Under this deployment, one replica of all region data writes to the region server's storage disks, which allows get/scan requests to be served using local data.
Other replicas spread randomly in the entire cluster.
Splitting and moving a region into other servers disable data locality benefits, forcing daughter regions to fetch data from remote servers.
Therefore, moving hotspots often lead to performance degradation.In this paper, we present Pyro, a holistic spatialtemporal big-data storage system tailored for high resolution geometry queries and moving hotspots.
Pyro con- [9,10] show that Pyro reduces the response time by 60X on 1km×1km rectangle geometries.
Pyro further achieves 10X throughput improvement on 100m × 100m rectangle geometries.
The remainder of this paper is organized as follows.
Section 2 provides background and design overview.
Then, major designs are described in Section 3.
Implementations and evaluations are presented in Sections 4 and 5 respectively.
We survey related work in Section 6.
Finally, Section 7 concludes the paper.
Pyro consists of PyroDB and PyroDFS.
The design of PyroDB and PyroDFS are based on HBase and HDFS respectively.
Figure 1 shows the high-level architecture, where shaded modules are introduced by Pyro.
HDFS [11] is an open source software based on GFS [12].
Due to its prominent fame and universal deployment, we skip the background description.HBase is a distributed, non-relational database running on top of HDFS.
Following the design of BigTable [13], HBase organizes data into a 3D table of rows, columns, and cell versions.
Each column belongs to a column family.
HBase stores the 3D table as a key-value store.
The key consists of row key, column family key, column qualifier, and timestamp.
The value contains the data stored in the cell.In HBase, the entire key space is partitioned into regions, with each region served by an HRegion instance.
HRegion manages each column family using a Store.
Each Store contains one MemStore and multiple StoreFiles.
In the write path, the data first stays in the MemStore.
When the MemStore reaches some pre-defined flush threshold, all key-value pairs in the MemStore are sorted and flushed into a new StoreFile in HDFS.
Each StoreFile wraps an HFile, consisting of a series of data blocks followed by meta blocks.
In this paper, we use meta blocks to refer to all blocks that store meta, data index, or meta index.
In the read path, a request first determines the right HRegions to query, then it searches all StoreFiles in those regions to find target key-value pairs.As the number of StoreFiles increases, HBase merges them into larger StoreFiles to reduce the overhead of read operations.
When the size of a store increases beyond a threshold, its HRegion splits into two daughter regions, with each region handles roughly half of its parent's keyspace.
The two daughter regions initially create reference files pointing back to StoreFiles of their past parent region.
This design postpones the overhead of copying region data to daughter region servers at the cost of losing data locality benefits.
The next major compaction materializes the reference files into real StoreFiles.HBase has become a famous big-data storage system for structured data [14], including data for locationbased services.
Many location-based services share the same request primitive that queries information about moving objects within a given geometry, which we call geometry queries.
Unfortunately, HBase suffers inefficiencies when serving geometry queries.
All cells in HBase are ordered based on their keys in a onedimensional space.
Casting a geometry into that onedimensional space inevitably results in multiple disjoint range scans.
HBase handles those range scans individually, preventing queries to be aggregately optimized.
Moreover, location-based workloads naturally create moving hotspots in the backend, requiring responsive resource elasticity in every HRegion.
HBase handles workload hotspots by efficiently splitting regions, which sacrifices data locality benefits for newly created daughter regions.
Without data locality, requests will suffer increased response time after splits.
Above observations motivate us to design Pyro, a data store specifically tailored for geometry queries.
Figure 1 shows the high-level architecture of Pyro.
Pyro internally uses Moore encoding algorithm [15][16][17][18] to cast two-dimensional data into one-dimensional Moore index, which is enclosed as part of the row key.
For geometry queries, the Geometry Translator module first applies the same Moore encoding algorithm to calculate scan ranges.
Then, the Multi-Scan Optimizer computes the optimal read strategy such that the IO latency is minimized.
Sections 3.1 and 3.2 present more details.
Pyro relies on the group-based replica placement policy in PyroDFS to guarantee data locality during region splits.
To achieve that, each StoreFile is divided into multiple shards based on user-defined pre-split keys.
Then, Pyro organizes DFS replicas of all shards into elaborately designed groups.
Replicas in the same group are stored in the same physical server.
After one or multiple splits, each daughter region is guaranteed to find at least one replica of all its region data within one group.
To preserve data locality, Pyro just need to move the daughter region into the physical server hosting that group.
The details of group-based replica placement are described in section 3.3.
Pyro makes three major contributions:• Geometry Translation: Apart from previous solutions that build an index layer above HBase, Pyro internally implements efficient geometry translation algorithms based on Moore encoding.
This design allows Pyro to optimize a geometry query by globally processing all its range scans together.
• Multi-Scan Optimization: After geometry translation, the multi-scan optimizer aggregately processes the generated range scans to minimize the response time of the geometry query.
By using storage media performance profiles as inputs, the multi-scan optimizer employs a dynamic programming algorithm to calculate the optimal HBase blocks to fetch.
• Block Grouping: To deal with moving hotspots, Pyro relies on a novel data block grouping algorithm in the DFS layer to split a region quickly and efficiently, while preserving data locality benefits.
Moreover, by treating meta block and data block differently, block grouping helps to improve Pyro's fault tolerance.
We first present the geometry translation and multiscan optimization in Sections 3.1 and 3.2 respectively.
These two solutions help to efficiently process geometry queries.
Then, Section 3.3 describes how Pyro handles moving hotspots with the block grouping algorithm.
In order to store spatial-temporal data, Pyro needs to cast 2D coordinates (x, y) into the one-dimensional key space.A straightforward solution is to use a fixed number of bits to represent x, and y, and append x after y to form the spatial key.
This leads to the Strip-encoding as shown in Figure 2 (a).
Another solution is to use ZOrder-encoding [7] that interleaves the bits of x and y.
An example is .
These encoding algorithms divide the 2D space into m × m tiles, and index each tile with a unique ID.
The tile is the spatial encoding unit as well as the unit of range scans.
We define the resolution as log 2 (m), which is the minimum number of bits required to encode the largest value of x and y.In most cases, encoding algorithms inevitably break a two-dimensional geometry into multiple key ranges.
Therefore, each geometry query may result in multiple range scans.
Each range scan requires a few indexing, caching, and disk operations to process.
Therefore, it is desired to keep the number of range scans low.
We carry out experiments to evaluate the number of range scans that a geometry query may generate.
The resolution ranges from 25 to 18 over the same set of randomly generated disk-shaped geometry queries with 100m radius in a 40, 000, 000m × 40, 000, 000m area.
The corresponding tile size ranges from 1.2m to 153m.
Figure 3 shows the number of range scans generated by a single geometry query under different resolutions.
It turns out that Strip-encoding and ZOrder-encoding translate a single disk geometry to a few tens of range scans when the tile size falls under 20m.
To reduce the number of range scans, we developed the Geometry Translator module.
The module employs the Moore-Encoding algorithm which is inspired by the Moore curve from the space-filling curve family [15][16][17][18].
A simple example is shown in Figure 2 (c).
A Moore curve can be developed up to any resolution.
As shown in Figure 4 (a), resolutions 1 and 2 of Moore encoding are special cases.
The curve of resolution 1 is called a unit component.
In order to increase the resolution, the Moore curve expands each unit component according to a fixed strategy as shown in Figure 5.
Results plotted in Figure 3 show that Moore-Encoding helps to reduce the number of range scans by 40% when compared to ZOrder-Encoding.
Moore curves may generalize to higher dimensions [19], Figure 4 (b) depicts the simplest The purpose of multi-scan optimization is to reduce read amplification.
Below, we first describe the phenomenon of read amplification, and then we present our solution to this problem.
When translating geometry queries, range scans are generated respecting tile boundaries at the given resolution.
But, tile boundaries may not align with the geometry query boundary.
In order to cover the entire geometry, data from a larger area is fetched.
We call this phenomenon Read Area Amplification.
Figure 3 plots the curve of read area amplification ratio, which is quantitatively defined as the total area of fetched tiles over the area of the geometry query.
The curves show that, solely tuning the resolution cannot achieve both a small number of range scans and a low ratio of read area amplification.
For example, as shown in Figure 3, restricting each geometry query to generate less than 10 scans forces Pyro to fetch data from a 22% larger area.
On the other hand, limiting the area amplification ratio to less than 5% leads to more than 30 range scans per geometry query.
The problem gets worse for larger geometries.
Moreover, encoding tiles are stored into fixed-size DB blocks on disks, whereas DB blocks ignore the boundaries of encoding tiles.
An entire DB block has to be loaded even when there is only one requested key-value pair fallen in that DB Block, which we call the Read Volume-Amplification.
Please notice that, DB blocks are different from DFS blocks.
DB blocks are the minimum read/write units in PyroDB (similar to HBase).
One DB block is usually only a few tens of KiloBytes.
In contrast, a DFS block is the minimum replication unit in PyroDFS (similar to HDFS).
DFS blocks are orders of magnitudes larger than DB blocks.
For example, the default PyroDFS block size is 64MB, which is 1024 times larger than the default PyroDB block size.Besides read area and volume amplifications, using a third-party indexing layer may also force the data store to unnecessarily visit a DB block multiple times, especially for high resolution queries.
We call it the Redundant Read Phenomenon.
Even though a DB block can be cached to avoid disk operations, the data store still needs to traverse DB block's data structure to fetch the requested key-value pairs.
Therefore, Moore encoding algorithm alone is not enough to guarantee the efficiency.For ease of presentation, we use the term Read Amplification to summarize the read area amplification, read volume amplification, and redundant read phenomena.
Read amplification may force a geometry query to load a significant amount of unnecessary data as well as visiting the same DB block multiple times, leading to a much longer response time.
In the next section, we present techniques to minimize the penalty of read amplification.
According to Figure 3, increasing the resolution helps to alleviate read area amplification.
Using smaller DB block sizes reduces read volume amplification.
However, these changes require Pyro to fetch significantly more DB blocks, pushing disk IO to become a throughput bottleneck.
In order to minimize the response time, Pyro optimizes all range scans of the same geometry query aggregately, such that multiple DB blocks can be fetched within fewer disk read operations.
There are several reasons for considering IO optimizations in the DB layer rather than relying on asynchronous IO scheduling in the DFS layer or the OS layer.
First, issuing a DFS read request is not free.
As a geometry query may potentially translate into a large number of read operations, maintaining those reads alone elicits extra overhead in all three layers.
Second, performance of existing IO optimizations in lower layers depend on the timing and ordering of request submissions.
Enforcing the perfect request submission ordering in the Geometry Translator is not any cheaper than directly performing the IO optimization in PyroDB.
Third, as PyroDB servers have the global knowledge about all p-reads from the same geometry request, it is the natural place to implement IO optimizations.Pyro needs to elaborately tune the trade-off between unnecessarily reading more DB blocks and issuing more disk seeks.
Figure 6 shows the profiling results of Hadoop-2.4.1 position read (p-read) performance on a 7,200RPM Seagate hard drive and a Samsung SM0256F Solid State Drive respectively.
In the experiment, we load a 20GB file into the HDFS, and measure the latency of p-read operations of varies sizes at random offsets.
The disk seek delay dominates the p-read response time when reading less than 1MB data.
When the size of pread surpasses 1MB, the data transmission delay starts to make a difference.
A na¨ıvena¨ıve solution calculates the disk seek delay and the per-block transmission delay, and Before diving into algorithm details, we present the abstraction of the block aggregation problem.
Suppose a geometry query hits shaded tiles (3,4,12,15) in Fig 2 (c).
For the sake of simplicity, assume that DB blocks align perfectly with encoding tiles, one block per tile.
Figure 7 shows the block layout in the StoreFile.
A 3 needs to determine what block ranges to fetch in order to cover all requested blocks, such that the response time of the geometry query is minimized.
In this example, let us further assume each block is 64KB.
According to the profiling result shown in Figure 6, reading one block takes about 9 ms, four blocks takes 14 ms, while reading thirteen blocks takes 20 ms. Therefore, the optimal solution reads blocks 3-15 using one p-read operation.A 3 works as follows.
Suppose a geometry query translates to a set Q of range scans.
Block indices help to convert those range scans into another set B 񮽙 of blocks, sorted in the ascending order of their offsets.
By removing all cached blocks from B 񮽙 , we get set B of n requested but not cached blocks.
Define S[i] as the estimated minimum delay of loading the first i blocks.
Then, the problem is to solve S[n].
For any optimal solution, there must exist a k, such that blocks k to n are fetched using a single p-read operation.
In other words, S[n] = S[k − 1]+ESTIMATE(k, n), where ESTIMATE(k, n) estimates the delay of fetching blocks from k to n together based on the profiling result.
Therefore, starting fromS[0], A 3 cal- culates S[i] as min{S[k − 1]+ESTIMATE(k, i)|1 ≤ k ≤ i}.
The pseudo code of A 3 is presented in Algorithm 1.
Input: blocks to fetch sorted by offset B Output: block ranges to fetch R 1 S ← an array of size |B|; initialize to ∞ 2 P ← an array of size |B|;S[0] ← 0 3 for i ← 1 ∼ |B| do 4 for j ← 0 ∼ i − 1 do 5 k = i − j; s ←ESTIMATE(k, i) +S[k − 1] 6 if s < S[i] then 7 S[i] ← s; P[i] ← k 8 i ← |B|; R ← / 0 9 while i > 0 do 10 R ← R ∪ (P[i], i); i ← P[i] − 1 11 return R Requested Block In Algorithm A 3 , the nested loop between line 3 − 7 leads to O(|B| 2 ) computational complexity.
If B is large, the quadratic computational complexity explosion can be easily mitigated by setting an upper bound on the position read size.
For example, for the hard drive profiled in Figure 6, fetching 10 7 bytes result in about the same delay as fetching 5 × 10 6 bytes twice.
Therefore, there is no need to issue position read larger than 5 × 10 6 bytes.
If block size is set to 64KB, the variable j on the 5 th line in Algorithm 1 only needs to loop from 0 to 76, resulting in linear computational complexity.
Moore encoding concentrates range scans of one geometry query into fewer servers.
This may lead to performance degradation when spatial-temporal hotspots exist.
To handle moving hotspots, a region needs to gracefully split itself to multiple daughters to make use of resources on multiple physical servers.
Later, those daughter regions may merge back after their workloads shrink.In HBase, the split operation creates two daughter regions on the same physical server, each owning reference files pointing back to StoreFiles of their parent region.
Daughter regions are later moved onto other servers during the next cluster balance operation.
Using reference files on one hand helps to keep the split operation light, but on the other hand prevents daughter regions from taking advantage of data locality benefits.
Because, after leaving the parent region's server, the two daughter regions can no longer find their region data in their local disks until daughters' reference files are materialized.
HBase materializes reference files during the next major compaction, which executes at a very low frequency (e.g., once a day).
Forcing earlier materialization does not solve the problem.
It could introduce even more overhead to the already-overwhelmed region, as materializa- An ideal solution should keep both split and materialization operations light, allowing the system to react quickly when a hotspot emerges.
Below, we present our design to achieve such ideal behaviors.
Same as HBase, Pyro suggests users to perform pre-split based on expected data distribution to gain initial load balancing among region servers.
Pyro relies on the expected data distribution to create more splitting keys for potential future splits.
Split keys divide StoreFiles into shards, and help to organize DFS block replicas into replica groups.
PyroDFS guarantees that DFS blocks respect predefined split keys.
To achieve that, PyroDFS stops writing into the current DFS block and start a new one as soon as it reaches a predefined split key.
This design relies on the assumption that, although moving hotspots may emerge in spatial-temporal applications, the long-round popularity of different geographic regions changes slowly.
Results presented in evaluation Section 5.1 confirm the validity of this assumption.Assume blocks are replicated r times and there are 2 r−1 −1 predefined split keys within a given region.
Split keys divide the region key space into 2 r−1 shards, resulting in r · 2 r−1 shard replicas.
Group 0 contains one replica from all shards.
Other groups can be constructed following a recursive procedure:1 Let Ψ be the set of all shards.
If Ψ contains only one shard, stop.
Otherwise, use the median split key κ in Ψ to divide all shards into two sets A and B. Keys of all shards in A are larger than κ, while keys of all shards in B are smaller than κ.
Perform step 2, and then perform step 3.
2 Create a new group to contain one replica from all shards in set A. Then, let Ψ ← A, and recursively apply step 1.
3 Let Ψ ← B, and then recursively apply step 1.
Replicas in the same group are stored in the same physical server, whereas different groups of the same region are placed into different physical servers.
According to the construction procedure, group 1 starts from the median split key, covering the bottom half of the key space (i.e., 2 r−2 shards).
Group 1 allows half of the regions workload to be moved from group 0's server to group 1's server without sacrificing data locality.
Figure 8 demonstrates an example of r = 3.
PyroDFS is compatible with normal HDFS workload whose replicas can be simply set as no group specified.
Section 3.3.2 explains why group 1 and 2 are placed at the end rather than in the beginning of the StoreFile.
Figure 8 also shows how Pyro makes use of DFS block replicas.
The shaded area indicates which replica serves workloads falling in that key range.
In the beginning, there is only one region server.
Replicas in group 0 take care of all workloads.
As all replicas in group 0 are stored locally in the region's physical server, data locality is preserved.
After one split, the daughter region with smaller keys stays in the same physical server, hence still enjoys data locality.
Another daughter region moves to the physical server that hosts replica group 1, which is also able to serve this daughter region using local data.
Subsequent splits are carried out under the same fashion.To distinguish from the original split operation in HBase, we call the above actions the soft split operation.
Soft splits are designed to mitigate moving hotspots.
Daughter regions created by soft splits eventually merge back to form their parent regions.
The efficiency of the merge operation is not a concern as it can be performed after the hotspot moves out of that region.
Please notice that the original split operation, which we call the hard split, is still needed when a region grows too large to fit in one physical server.
As this paper focuses on geometry query and moving hotspots, all splits in the following sections refer to soft splits.
As a persistent data store, Pyro needs to preserve high data availability.
The block grouping algorithm presented in the previous section affects DFS replica placement schemes, which in turn affects Pyro's fault tolerance properties.
In this section, we show that the block grouping algorithm allows Pyro to achieve higher data availability compared to the default random replica placement policy in HDFS.Pyro inherits the same HFile format [3] from HBase to store key-value pairs.
According to HFile Format, meta blocks are stored at the end of the file.
Losing any DFS block of the meta may leave the entire HFile unavailable, whereas the availability of key-value DFS blocks are not affected by the availability of other key-value DFS blocks.
This property makes the last shard of the file more important than all preceding shards.
Therefore, we choose two different objectives for their fault tolerance design.
• Meta shard: Minimize the probability of losing any DFS block.
• Key-value shard: Minimize the expectation of the number of unavailable DFS blocks.
Assume there are n servers in the cluster, and f nodes are unavailable during a cluster failure event.
For a given shard, assume it contains b blocks, and replicates r times, where g out of r replications are grouped.
PyroDFS randomly distributes the grouped g replications into g physical servers.
The remaining (r − g)b block replicas are randomly and exclusively distributed in the cluster.
If the meta fails, it must be the case that the g servers hosting the g grouped replications all fail (i.e.,񮽙 f g 񮽙 / 񮽙 n g 񮽙 ),and at least one block in each r − g ungrouped replications fails.
Hence, the probability of meta failure is Figure 9 plots how the number of grouped replications g affects the failure probability.
In this experiment, n and r are set to 10,000, and 3 respectively.
According to [20- 22], after some power outage, 0.5%-1% of the nodes fail to reboot.
Hence, we vary f to be 50, and 100.
The results show that the meta failure probability decreases when g increases.
Pyro sets g to the maximum value for the meta shard, therefore achieves higher fault tolerance compared to default HDFS where g equals 1.
Pr [meta failure] = 񮽙 f g 񮽙 񮽙 n g 񮽙   1 − 񮽙 1 − 񮽙 f −g r−g 񮽙 񮽙 n−g r−g 񮽙 񮽙 b   .
(1)For key-value shards, transient and small-scale failures are tolerable, as they do not affect most queries.
It is more important to minimize the scale of the failure (i.e., the number of unavailable DB blocks).
The expected failure scale is,E [failure scale|failure occurs] = b 񮽙 f −g r−g 񮽙 񮽙 n−g r−g 񮽙 .
(2)The failure scale decreases with the increase of grouped replication number g. Therefore, placing replica groups 1 and 3 at the end of the StoreFile minimizes both the meta shard failure probability and the failure scale of key-value shards.
PyroDFS and PyroDB are implemented based on HDFS-2.4.1 and HBase-0.99 respectively.
As previously shown in Figure 4 and Figure 5, each unit of Moore curve can be uniquely defined by the combination of its orientation (north, east, south, and west) and its rotation (clockwise, counter-clockwise).
Encode the orientation with 2 bits, d1 and d0, such that 00 denotes north, 01 east, 10 south, and 11 west.
With more careful observations, it can be seen that the rotation of a Moore curve component unit completely depends on its orientation.
Starting from the direction shown in Figure 4 (a), the encodings in east and west oriented units rotate clockwise, and others rotate counter-clockwise.
With a given integer coordinate (x, y), let x k and y k denote the k th lowest bits of x and y in the binary presentation.
Let d k,1 d k,0 be the orientation of the component unit defined by the highest r − k − 1 bits in x, and y. Then, the orien-tation d k−1,1 d k−1,0 can be determined based on d k,1 , d k,0 ,x k , and y k [15][16][17][18].
d k−1,0 = ¯ d k,1 ¯ d k,0 ¯ y k | ¯ d k,1 d k,0 x k | d k,1 ¯ d k,0 y k | d k,1 d k,0 ¯ x k (3) = ¯ d k,0 񮽙 d k,1 ⊕ ¯ y k 񮽙 | d k,0 񮽙 d k,1 ⊕ x 񮽙 (4) d k−1,1 = ¯ d k,1 ¯ d k,0 x k ¯ y k | ¯ d k,1 d k,0 ¯ x k y k | d k,1 ¯ d k,0 ¯ x k y k | d k,1 d k,0 x k ¯ y k (5) = d k,1 ( ¯ x k ⊕ y k ) | (x k ⊕ y k )(d 0 ⊕ x k ) (6)The formula considers all situations where d k−1,0 and d k−1,1 should equal to 1, and uses a logic or to connect them all.
For example, the term ¯ d k,1 ¯ d k,0 ¯ y k states that when the previous orientation is north ( ¯ d k,1 ¯ d k,0 ), the current unit faces east or west (d k−1,0 = 1) if and only if y k = 0.
The same technique can be applied to determine the final Moore encoding index ω.ω 2k+1 = ¯ d k,1 ¯ d k,0 ¯ x k | ¯ d k,1 d k,0 ¯ y k | d k,1 ¯ d k,0 x k | d k,1 d k,0 y k (7) = ¯ d k,0 񮽙 d k,1 ⊕ ¯ x k 񮽙 + d k,0 񮽙 d k,1 ⊕ ¯ y k 񮽙 (8) ω 2k = ¯ x k ⊕ y k(9)Then, each geometry can be translated into range scans using a quad tree.
Each level in the quad tree corresponds to a resolution level.
Each node in the tree represents a tile, which is further divided into four smaller tiles in the next level.
The translating algorithm only traverses deeper if the geometry query partially overlaps with that area.
If an area is fully covered by the geometry, there is no need to go further downwards.
Figure 10 shows the delay of translating a 5km × 5km square geometry.
The delay stays below 11ms even using the finest resolution.
After converting a geometry query into range scans, the multi-scan optimizer needs two more pieces of information to minimize the response time: 1) storage media performance profiles, and 2) the mapping from key ranges to DB blocks.
For the former one, an administrator may specify an HDFS path under the property name hbase.profile.storage in the hbase-site.xml configuration file.
This path should point to a file containing multiple lines of (p-read size, p-read delay) items, indicating the storage media performance profile result.
Depending on storage media types in physical servers, the administrator may set the property hbase.profile.storage to different values for different HRegions.
The file will be loaded during HRegion initialization phase.
For the latter one, HBase internally keeps indices of DB blocks.
Therefore, Pyro can easily translate a range scan into a serious of block starting offsets and block sizes.
Then, those information will be provided as inputs for the A 3 algorithm.
Distributed file systems usually keep replica placement policies as an internal logic, maintaining a clean separation between the DFS layer and higher layer applications.
This design, however, prevents Pyro from exploring opportunities to make use of DFS data replications.
Pyro carefully breaks this barrier by exposing a minimum amount of control knobs to higher layer applications.
Through these APIs, applications may provide replica group information when writing data into DFS.
It is important to choose the right set of APIs such that PyroDFS applications do not need to reveal too much about details in the DFS layer.
At the same time, applications are able to fully make use of data locality benefits of all block replicas.
In our design, PyroDFS exposes two families of APIs which help to alter its internal behavior.
• Sealing a DFS Block: PyroDB may force PyroDFS to seal the current DFS block and start writing into a new DFS block, even if the current DFS block has not reached its size limit yet.
This API is useful because DFS block boundaries may not respect splitting keys, especially when there are many StoreFiles in a region and the sizes of StoreFiles are about the same order of magnitude of the DFS block size.
The seal API family will help StoreFiles to achieve full data locality after splits.
• Grouping Replicas: PyroDB may specify replica namespace and replica groups when calling the write API in PyroDFS.
This usually happens during MemStore flushes and StoreFile compactions.
Under the same namespace, replicas in the same replica group will be placed into the same physi- cal server, and replicas in different groups will be placed into different physical servers.
If there are not enough physical servers or disk spaces, PyroDFS works in a best effort manner.
The mapping from the replica group to the physical server and corresponding failure recovery is handled within PyroDFS.
PyroDB may retrieve a physical server information of a given replica group using grouping APIs, which allows PyroDB to make use of data locality benefits.
Evaluations use NYC taxi dataset [9,10] We first briefly analyze the NYC taxi dataset.
Then, Sections 5.2, 5.3, and 5.4 evaluate the performance improvements contributed by Geometry Translator, MultiScan Optimizer, and Group-based Replica Placement respectively.
Finally, in Section 5.5, we measure the overall response time and throughput of Pyro.
Moving hotspot is an important phenomenon in spatialtemporal data.
Figure 11 (a) and (b) illustrate the heat maps of taxi pick-up and drop-off events in the Manhattan area during a 4 hour time slot starting from 8:00PM on December 31, 2010 and December 31, 2012 respectively.
The comparison shows that the trip distribution during the same festival does not change much over the years.
Figure 11 (c) plots the heat map of the morning (6:00AM-10:00AM) on January 1st, 2013, which drastically differs from the heat map shown in Figure 11 Figure 12.
Although hotspots move over time, the event count of a region changes within a reasonably small range.
During New Year midnight, popularity of more than 97% regions grow within four folds.When loading the data into HBase, both spatial and temporal information contribute to the row key.
The encoding algorithm translates the 2D location information of an event into a 32-bit spatial-key, which acts as the suffix of the row key.
Then, the temporal strings are parsed to Linux 64-bit timestamps.
We use the most significant 32 bits as the temporal-key.
Each temporal key represents roughly a 50-day time range.
Finally, as shown in Figure 13, the temporal-key is concatenated in front of the spatial key to form the complete row key.
Figure 14 shows how much Moore encoding helps to reduce the number of range scans at different resolutions when translating geometry queries in a 40, 000, 000m × 40, 000, 000m area.
Figures 14 (a) and (b) uses disk geometry and rectangle geometries respectively.
The two figures share the same legend.
For disk geometries, Moore encoding generates 45% fewer range scans when compared to ZOrder-encoding.
When a long rectangle is in use, Moore encoding helps to reduce the number of range scans by 30%.
To quantify the read volume amplification, we encode the dataset coordinates with Moore encoding algorithm using the highest resolution shown in Figure 3, and populate the data using 64KB DB Blocks.
Then, the experiment issues 1Km × 1Km rectangle geometries.
Figure 15 (a) shows the ratio of fetched key-value pairs volume over the total volume of accessed DB Blocks, which is the inverse of read volume amplification.
As the Stripencoding results in very high read volume amplification, using the inverse helps to limit the result in interval [0,1].
Therefore, readers can easily distinguish the difference between Moore-encoding and ZOrder-encoding.
We call the inverse metric the effective data ratio.
As Moore encoding concentrates a geometry query into fewer range scans, and hence fewer range boundaries, it also achieves higher effective data ratio.
counts when processing the same geometry query.It is clear that the number of redundant reads increases when using higher resolutions.
Another observation is that, Moore-encoding leads to large read redundancy.
Thanks to the multi-scan optimization design, this will not be a problem, as all redundant reads will be accomplished within a single DB block traverse operation.
In order to measure how A 3 algorithm works, we load data from the NYC taxi cab dataset using Moore encoding algorithm, and force all StoreFiles of the same store to be compacted into one single StoreFile.
Then, the RUE generates 1Km × 1Km rectangle geometry queries with the query resolution set to 13.
We measure the internal delay of loading requested DB blocks individually versus aggregately.The evaluation results are presented in Figure 16.
The curves convey a few interesting observations.
Let us look at the A 3 curve first.
In general, this curve rises as the block size increases, which agrees with our intuition as larger blocks lead to more severe read volume amplification.
The minimum response time is achieved at 8KB.
Because the minimum data unit of the disk under test is 4KB, further decreasing block size does not help any more.
On the computation side, using smaller block size results in larger input scale for the A 3 algorithm.
That explains why the response time below 8KB slightly goes up as the block size decreases.
The "individually" curve monotonically decreases when the block size grows from 1KB to 100KB.
It is because increasing block size significantly reduces the number of disk seeks when the block is small.
When the block size reaches between 128KB and 4MB, two facts become true: 1) key-value pairs hit by a geometry query tend to concentrate in less blocks; 2) data transmission time starts to make impacts.
The benefits of reducing the number of disk seeks and the penalties of loading DB blocks start to cancel each other, leading to a flat curve.
After 4MB, the data transmission delay dominates the response time, and the curve rises again.
Comparing the nadirs of the two curves concludes that A 3 helps to reduce the response time by at least 3X.
To measure the performance of soft splitting, this experiment uses normal scan queries instead of geometry queries, excluding the benefits of Moore encoding and multi-scan optimization.
A table is created for the NYC's taxi data, which initially splits into 4 regions.
Each region is assigned to a dedicated server.
The HBASE HEAPSIZE parameter is set to 1GB, and the MemStore flush size is set to 256MB.
Automatic region split is disabled to allow us to manually control the timing of splits.
Twelve RUE servers generate random-sized small scan queries.
Figure 17 shows the result.
The split occurs at the 240 th second.
After the split operation, HBase suffers from even longer response time.
It is because daughter region B does not have its region data in its own physical server, and has to fetch data from remote servers, including the one hosting daughter region A.
When the group based replication is enabled, both daughter regions read data from local disks, reducing half of the pressure on disk, cpu, and network resources.
We measure the overall response time and throughput improved by Pyro compared to the state-of-the-art solution MD-HBase.
Experiments submit rectangle geometry queries of size 1km × 1km and 100m × 100m to Pyro and MD-HBase.
The request resolutions are set to 13 and 15 respectively for two types of rectangles.
The block sizes vary from 8KB to 512KB.
When using MD-HBase, the remote query emulator initiates all scan queries sequentially using one thread.
This configuration tries to make the experiment fair, as Pyro uses a single thread to When using PyroM and PyroZ, the response times grow with the increase of block size regardless of whether the rectangle geometry is large or small.
It is because larger blocks weaken the benefits of block aggregation and force PyroM and PyroZ to read more data from disk.
After disabling A 3 , the response time rises by 6X for 1km × 1km rectangles, and 2X for 100m × 100m rectangles.
MD-HBase achieves the shortest response time when using 64KB DB blocks, which is 60X larger compared to PyroM and PyroZ when handling 1km × 1km rectangle geometries.
Reducing the rectangle size to 100m × 100m shrinks the gap to 5X.
An interesting phenomenon is that using 512KB DB blocks only increases the response time by 5% compared to using 64KB DB blocks, when the request resolution is set to 13.
However, the gap jumps to 33% if the resolution is set to 15.
The reason is that, higher resolution leads to more and smaller range scans.
In this case, multiple range scans are more likely to hit the same DB block multiple times.
According to HFile format, key-value pairs are chained together as a linked-list in each DB block.
HBase has to traverse the chain from the very beginning to locate the starting key-value pair for every range scan.
Therefore, larger DB block size results in more overhead on iterating through the key-value chain in each DB block.
Figure 20 shows the throughput evaluation results of the entire cluster.
Pyro regions are initially partitioned based on the average pick up/drop off event location distribution over the year of 2013.
Literature [9] presents more analysis and visualizations of the dataset.
During the evaluation, each RUE server maintains a pool of emulated users who submit randomly located 100m × 100m rectangle geometry queries.
The reason of using small geometries in this experiment is that MD-HBase results in excessively long delays when handling even a single large geometry.
The distribution of the rectangle geometry queries follows the heat map from 8:00PM to 11:59PM on December 31, 2013.
The configuration mimics the situation where an application only knows the long-term data distribution, and is unable to predict hotspot bursts.
When setting 600ms to be the maximum tolerable response time, Pyro outperforms MD-HBase by 10X.
As the volume of spatial-temporal data is growing at an unprecedented rate, pursing a scalable solution for storing spatial-temporal data has become a common goal shared by researchers from both the distributed system community and the database community.
Advances on this path will benefit a great amount of spatial-temporal applications and analytic systems.Traditional relational databases understand high dimensional data well [17,18,34,35] due to extensively studied indexing techniques, such as R-Tree [36], KdTree [37], UB-Tree [38,39], etc.
Therefore, researchers seek approaches to improve the scalability.
Wang et al. [40] construct a global index and local indices using Content Addressable Network [41].
The space is partitioned into smaller subspaces.
Each subspace is handled by a local storage.
The global index manages subspaces, and local indices manage data points in their own subspaces.
Zhang et al. [42] propose a similar architecture using R-tree as global index and Kd-tree as local indices.From another direction, distributed system researchers push scalable NoSQL stores [3-6, 13, 43-45] to better understand high dimensional data.
Distributed key-value stores can be categorized into two classes.
One class uses random partition to organize keys.
Such systems include cassandra [4], DynamoDB [5], etc.
Due to the randomness on key distribution, these systems are immune to dynamic hotspots concentrated in a small key range.
However, spatial-temporal data applications and analytic systems usually issue geometry queries, which translate to range scans.
Random partitioning cannot handle range scans efficiently, as it cannot extract all keys within a range with only the range boundaries.
Consequently, each range scan needs to query all servers.
Other systems, such as BigTable [13], HBase [3], couchDB [46], use ordered partitioning algorithms.
In this case, the primary key space is partitioned into regions.
The benefits are clear.
As data associated with a continuous primary key range are also stored consecutively, sorted partitioning helps to efficiently locate the servers that host the requested key range.The benefits of ordered partitioning encouraged researchers to mount spatial-temporal application onto HBase.
Md-HBase [7] builds an index layer on top of HBase.
The index layer encodes spatial information of a data point into a bit series using ZOrder-encoding.
Then, a row using that bit series as key is inserted into HBase.
The ST-HBase [8] develops a similar technique.
However when serving geometry queries, the index layer inevitably translates each geometry query into multiple range scans, and prevents data store from aggregately minimizing the response time.As summarized above, existing solutions either organize multiple relational databases together using some global index, or build a separate index layer above some general purpose distributed data stores.
This paper, however, takes a different path by designing and implementing a holistic solution that is specifically tailored for spatial-temporal data.
In this paper, we present the motivation, design, implementation, and evaluation of Pyro.
Pyro tailors HDFS and HBase for high resolution spatial-temporal geometry queries.
In the DB layer, Pyro employs Moore encoding and multi-scan optimization to efficiently handle geometry queries.
In the DFS layer, group-based replica placement policy helps Pyro to preserve data locality benefits during hotspots dynamics.
The evaluation shows that Pyro reduces the response time by 60X on 1km × 1km rectangle geometries and improves the throughput by 10X on 100m × 100m rectangle geometries compared to the state-of-the-art solution.
We are grateful to Professor Dirk Grunwald and reviewers for their invaluable comments during the revision process of this paper.
We would also like to thank Professor Dan Work for sharing with us the NYC taxi dataset.
This research was sponsored in part by the National Science Foundation under grants CNS 13-20209, CNS 13-02563, CNS 10-35736 and CNS 09-58314, the Army Research Laboratory, and was accomplished under Cooperative Agreement Number W911NF-09-2-0053.
The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Army Research Laboratory or the U.S. Government.
The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation here on.
