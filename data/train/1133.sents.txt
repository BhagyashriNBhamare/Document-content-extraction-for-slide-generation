We study the problem of clock synchronization in highly dynamic networks, where communication links can appear or disappear at any time.
The nodes in the network are equipped with hardware clocks, but the rate of the hardware clocks can vary arbitrarily within specific bounds, and the estimates that nodes can obtain about the clock values of other nodes are inherently inaccurate.
Our goal in this setting is to output a logical clock at each node, such that the logical clocks of any two nodes are not too far apart, and nodes that remain close to each other in the network for a long time are better synchronized than distant nodes.
This property is called gradient clock synchronization.
Gradient clock synchronization has been widely studied in the static setting.
We show that the bounds for the static case also apply to our highly dynamic setting: if two nodes remain at distance d from each other for sufficiently long, it is possible to synchronize their clocks to within O(d log(D/d)), where D is the diameter of the network.
This is known to be optimal for static networks, and since a static network is a special case of a dynamic network, it is optimal for dynamic networks as well.
Furthermore, we show that our algorithm has optimal stabilization time: when a path of length d appears between two nodes, the time required until the skew between the two nodes is reduced to O(d log(D/d)) is O(D), which we prove is optimal.
A core algorithmic problem in distributed computing is to establish coordination among the participants of a distributed system, which is often achieved through a common notion of time.
Typically, every node in a network has its own local hardware clock, which can be used for this purpose; however, hardware clocks of different nodes run at slightly different rates, and the rates can change over time.
This clock drift causes clocks to drift out of synch, requiring periodic communication to restore synchronization.
However, communication is typically subject to delay, and although an upper bound on the delay may be known, specific message delays are unpredictable.
Consequently, estimates for the current local time at other nodes are inherently inaccurate.A distributed clock synchronization algorithm computes logical clocks at every node, and the goal is to synchronize these clocks as tightly as possible.
Traditionally, distributed clock synchronization algorithms focus on minimizing the clock skew between the logical clocks of any two nodes in the network.
The clock skew between two clocks is simply the difference between the two clock values.
The maximum clock skew that may occur in the worst case between any two nodes at any time is called the global skew of a clock synchronization algorithm.
A well-known result states that no algorithm can guarantee a global skew better than Ω(D), where D denotes the diameter of the network [1].
However, in many cases it is more important to tightly synchronize the logical clocks of nearby nodes in the network than it is to minimize the global skew.
For example, if a time division multiple access (TDMA) protocol is used to coordinate access to a shared communication medium in a wireless sensor network, it suffices to synchronize the clocks of nodes that interfere with each other when transmitting.
The problem of providing better guarantees on the synchronization quality between nodes that are closer is called gradient clock synchronization.
The problem was introduced in a seminal paper by Fan and Lynch [5], where the authors show that a clock skew of Ω(log D/ log log D) cannot be prevented between immediate neighbors in the network.
The largest possible clock skew that may occur between the logical clocks of any two adjacent nodes at any time is called the local skew of a clock synchronization algorithm.
For static networks, it has been proved that the best possible local skew that an algorithm can achieve is bounded by Θ(log D) [11,12].
While tight bounds have been shown for the static model, the dynamic case has not been as well understood.
A dynamic network arises in many natural contexts: for example, when nodes are mobile, or when communication links are unreliable and may fail and recover.
The dynamic network model we consider in this paper is general: it allows communication links to appear and disappear arbitrarily, subject only to a global connectivity constraint (which is required to synchronize all nodes to each other).
Hence the model is suitable for modeling various types of dynamic networks which remain connected over time.In a dynamic network the distances between nodes change over time as communication links appear and disappear.
Consequently, we divide the synchronization guarantee into two parts: a global skew guarantee bounds the skew between any two nodes in the network at any time, and a dynamic gradient skew guarantee that bounds the skew between two nodes as a function of the distance between them and how long they remain at that distance.In [8], three of the authors showed that a clock synchronization algorithm cannot react immediately to the formation of new links, and that a certain stabilization time is required before the clocks of newly-adjacent nodes can be brought into synch.
The stabilization time is inversely related to the synchronization guarantee: the tighter the synchronization required in stable state, the longer the time to reach that state.
Intuitively, this is because when strict synchronization guarantees are imposed, the algorithm cannot change clock values quickly without violating the guarantee, and hence it takes longer to react.
The algorithm given in [8] achieved the optimal trade-off between skew bound and stabilization time; however, the local skew bound it achieved was O( √ D), which is far from optimal.
In this paper we describe two algorithms which achieve the same asymptotically optimal skew bounds as in the static model: if two nodes remain at distance d for sufficiently long, the skew between them is reduced to O(d log(D/d)), where D is the dynamic diameter of the network (corresponding roughly to the time it takes for information to reach from one end of the network to the other).
The two algorithms differ in the time required to reach this guarantee: their stabilization time is O(D log D) and O(D), respectively.
The first algorithm, which stabilizes in O(D log D) time, is much simpler to describe, and this extended abstract will focus on it.
The second algorithm, which stabilizes in O(D), is described in full in the accompanying technical report [7].
Finally, we improve the trade-off lower bound from [8] to show that a stabilization time of Ω(D) is necessary for an algorithm with the O(d log(D/d))-gradient skew property.
This shows that our second algorithm is optimal in its stabilization time as well as its skew guarantee.
The fundamental problem of synchronizing clocks in distributed systems has been studied extensively and many results have been published for various models over the course of the last approximately 30 years (see, e.g, [16,18,19,20]).
Until recently, the main focus has been on bounding the clock skew that may occur between any two nodes in the network, and a tight bound of Θ(D) has been proved [1,3,12,20].
The problem of synchronizing clocks of nodes that are close-by as accurately as possible has been introduced by Fan and Lynch [5].
In their work, the authors show that a clock skew of Ω(log D/ log log D) between neighboring nodes cannot be avoided if the clock values must increase at a constant minimum progress rate.
Subsequently, this result has been improved to Ω(log D) [12].
If we take the minimum clock rate α, the maximum clock rate β, and the maximum clock drift rate ρ into account, the more general statement of the lower bound is that a clock skew of Ω(log b D), where b := min{1/ρ, (β − α)/(αρ)} cannot be avoided.
The first algorithm guaranteeing a sublinear bound on the worst-case clock skew between neighbors achieves a bound of O( √ ρD) [13,14].
Recently, this result has been improved to O(log D) [11] (the base of the logarithm is a constant) and subsequently to O(log b D) [12].
Thus, tight bounds have been achieved for static networks in which neither nodes nor edges fail.The problem of synchronizing clocks in the presence of faults has also received considerable attention (see, e.g., [2,6,10,15,17]).
Some of the proposed algorithms are able to handle not only simple node or edges failures but also Byzantine behavior, which is outside the scope of this paper.
However, while these algorithms can tolerate a broader range of failures, their network model is not fully dynamic as their results rely on the assumption that a large part of the network remains non-faulty and stable at all times.
For the fully dynamic setting, it has been shown that there is an inherent trade-off between the clock skew S guaranteed between neighboring nodes that have been connected for a long time and the time it takes to guarantee a small clock skew over newly added edges.
In particular, the time it takes to reduce the clock skew over new edges to O(S) is Ω(D/S), where n denotes the number of nodes in the network [8].
In the same work, it is shown that for S ∈ Ω( √ ρD), there is an algorithm that reduces the clock skew between any two nodes to O(S) in Θ(D/S) time.
In this paper, we show that S can be reduced to Ω(log b D), i.e., the same optimal bound as for static networks can be achieved.
Clock synchronization.
In the clock synchronization problem, each node u is equipped with a continuous hardware clock Hu : R + 0 → R + 0 , which is initialized to Hu(0) := 0.
The hardware clocks do not necessarily progress at the rate of real time; they are subject to a (relative) clock drift bounded by ρ ∈ (0, 1).
At all times t we assume thatd dt Hu(t) ∈ [1 − ρ, 1 + ρ] for all nodes u.The objective of a clock synchronization algorithm (CSA) is to output a logical clock Lu : R + 0 → R + 0 (also initialized to Lu(0) := 0), such that at all times, the logical clock values of different nodes are close to each other.
Logical clocks must also have a bounded drift: there must exist constants α, β > 0 such that d dt Lu(t) ∈ [α, β] for all times t and for all nodes u.The estimate graph.
In [9] two of the authors introduced an abstraction called the estimate layer, which simplifies reasoning about CSAs.
Synchronization typically involves periodic exchanges of clock values between nodes, either through messages or by other means (e.g., RBS [4]).
The estimate layer encapsulates all means by which nodes can estimate the clock values of other nodes, and eliminates the need to reason explicitly about delay bounds and other parameters of the system.
The estimate layer provides an estimate graph, where each edge {u, v} represents the fact that node u has some means of estimating v's current clock value and vice versa.
The edges of the estimate graph are not necessarily direct communication links between nodes.
Node u is provided with a local estimate˜Lestimate˜ estimate˜L v u of Lv, whose accuracy is guaranteed by the estimate layer:∀t ∀u ∈ V, v ∈ Nu(t) : |Lv(t) − ˜ L v u (t)| ≤ {u,v} ,(1)where {u,v} is called the uncertainty, or the weight, of the edge {u, v}.
Each edge is also associated with a propagation delay T {u,v} that bounds the time needed to send a message from u to v and vice versa.
In the sequel, we refer to estimate edges of the sort described above simply as edges; similarly, when we say "the graph" we mean the estimate graph.
We do not reason explicitly about the communication graph, as the salient aspects of communication are encapsulated by the estimate layer.Dynamic networks.
We consider dynamic networks over a fixed set of nodes V , where we denote n := |V |.
Edge insertions and removals are modeled as discrete events controlled by a worst-case adversary.
In keeping with the abstract representation from [9], we say that there is an estimate edge {u, v} between two nodes u, v ∈ V at time t ≥ 0 iff u and v have a means of obtaining clock value estimates about each other at time t.
As explained above, this does not necessarily mean that there is a direct communication link between u and v at time t.We assume that nodes do not necessarily detect link formations and failures immediately, or even at the same time as the other endpoint of the link.
For each edge {u, v}, we assume that there is a parameter τ {u,v} such that both nodes u and v find out about the appearance or disappearance of edge {u, v} within τ {u,v} time units of the event itself.
Hence, although we are interested in undirected networks, we model the estimate layer as a directed graph, where edge (u, v) exists whenever u thinks v is its neighbor.
The appearance and disappearance of edges induces a dynamic graph G = (V, E), where E : R + 0 → 2 V ×V maps non-negative times t > 0 to a set of directed estimate edges that exist at time t.
The graph is subject to the following constraints, which approximate symmetry up to the delay (τ {u,v} ) in finding out about link changes: (a) if for all t ∈ [t − τ {u,v} , t + τ {u,v} ] we have (u, v) ∈ E(t ), then (v, u) ∈ E(t); (b) if for all t ∈ [t − τ {u,v} , t + τ {u,v} ] we have (u, v) ∈ E(t ), then (v, u) ∈ E(t).
Throughout each execution, every node u maintains a dynamic set of neighbors Nu : R + 0 → 2 V , where Nu(t) contains all nodes v such that (u, v) ∈ E(t).
In the sequel, we frequently refer to undirected edges {u, v}.
When we write {u, v} ∈ E(t) we mean that both (u, v) ∈ E(t) and (v, u) ∈ E(t).
To simplify the presentation, in Section 6 we assume that nodes find out about link changes immediately: that is, for all u, v ∈ V we have (u, v) ∈ E(t) iff (v, u) ∈ E(t).
This assumption is not made in the accompanying technical report.We say that edge {u, v} exists throughout a time interval [t1, t2] if for all t ∈ [t1, t2] we have {u, v} ∈ E(t).
By extension, a path p is said to exist throughout [t1, t2] if all its edges exist throughout the interval.Definition 1 (Weighted Paths).
Let G = (V, E) be a dynamic graph with edge weights e, e ∈ E(t).
A path p = (u0, . . . , u k ) of length k ≥ 0 in G at time t is a tuple of nodes such that for all i ∈ {1, . . . , k} it holds that {ui−1, ui} ∈ E(t).
The weight of p is p := P k i=1 {u i−1 ,u i } .
For simplicity, we will assume that the minimum edge weight is normalized to 1 throughout this extended abstract.We frequently refer to the skew on a path p = (u0, . . . , u k ) at time t, by which we mean |Lu 0 (t) − Lu k (t)|.
Dynamic diameter.
A fundamental lower bound [1] shows that the performance of a CSA in a static network depends on the diameter of the network.
In dynamic networks there is no immediate equivalent to a diameter.
Informally, the diameter corresponds to the length of time it takes (at most) for information to spread from one end of the network to the other.
To formalize this idea we adopt the following definitions.Definition 2 (Flooding).
A flood that originates at node u is a process initiated when node u sends a Flood message to all its neighbors.
Each node that receives the message for the first time forwards it immediately to all its neighbors.
We say that the flood is complete when all nodes have received a Flood message.Definition 3 (Dynamic Diameter).
We say that dynamic graph G has a dynamic diameter of D (or simply "diameter" for short) if a flood originating at any node in the graph at any time in the execution always completes in at most D time units.Clock skew.
To measure the quality of a CSA we consider two kinds of requirements: a global skew constraint which gives a bound on the difference between any two logical clock values in the system, and a dynamic gradient skew constraint which becomes stronger the closer two nodes u, v are to each other and the longer u, v stay close to each other.
In particular, for nodes that remain neighbors for a long time, the dynamic gradient skew constraint requires a much smaller skew than the global skew constraint.Definition 4 (Global Skew).
A CSA guarantees a global skew of ¯ G if at all times t, for any two nodes u, v ∈ V , it holds that Lu(t) − Lv(t) ≤ ¯ G.In contrast, the dynamic gradient skew constraint does depend on the dynamic graph: the older the shortest path between u and v, the better synchronized u and v are required to be.Definition 5 (Dynamic Gradient Skew).
Given a function S : R + 0 × R + 0 → R + 0that is non-decreasing in the first parameter (distance) and non-increasing in the second (time), we say that a CSA A guarantees a dynamic gradient skew of S if for all time intervals [t1, t2] and each path p = (u0, . . . , u k ) that exists throughout the interval [t1, t2], we have thatLu 0 (t2) − Lu k (t2) ≤ S(p, t2 − t1).
If a CSA A guarantees a dynamic gradient skew of S, we say that it ensures a stable gradient skew of S ∞ (d) := lim∆t→∞ S(d, ∆t), where S ∞ : R + 0 → R + 0 .
If a CSA A guarantees a dynamic gradient skew of S, then we call A an "S-dynamic gradient CSA".
The literature on gradient clock synchronization (e.g., [5,8,12,14]) is typically concerned with the local skew of a CSA, which bounds the skew on any single edge.
The local skew can be considered equivalent to the stable gradient skew S ∞ (1), provided that all edges are of uniform weight 1.
We will further discuss the stabilization time of a CSA, which we define as follows.Definition 6 (Stabilization Time).
Let A be a dynamic gradient CSA with a dynamic gradient skew of S.
The stabilization time of A is defined asTS := inf ˘ ∆t | ∀d ∀∆t ≥ ∆t : S(d, ∆t ) ≤ 2S ∞ (d) ¯ .
The dynamic and stable gradient skew and the stabilization time are parametrized by D, the diameter of the network, and potentially other parameters such as the bound on the clock drift ρ or the minimum edge weight.
Usually we omit these dependencies to simplify the notation.
Note that the choice of 2 as the constant in the definition above is arbitrary; we are interested in the asymptotic behavior of the clock skew as D → ∞.
The algorithms in the current paper are based on the algorithm of [12], which achieves the optimal gradient property for static networks.
In [9], the algorithm is presented as follows.
Each node of the network can be in one of two modes: in slow mode, the logical clock is increased at the rate of the node's hardware clock; in fast mode, the logical clock progresses at a faster rate.
The rate of the logical clock in fast mode is (1 + µ) times the rate of the hardware clock, where µ > 0 is a parameter of the algorithm.
This ensures that logical clock rates are always bounded as required: they are between α = 1 − ρ and β = (1 + ρ)(1 + µ) at all times.The heart of the algorithm is the logic that controls which mode a node is in at any given time.
This is specified in the form of two conditions: the fast condition (FC) tells nodes when to enter fast mode, and the slow condition (SC) tells nodes when to enter slow mode.
To determine the appropriate mode, each node examines its estimate for the logical clock values of its neighbors.
Both FC and SC are conditions on these estimates; informally, the fast condition FC checks if the node is too far behind its neighbors, in which case it enters fast mode; and the slow condition SC checks if the node is too far ahead of its neighbors, in which case it goes into slow mode.The two conditions FC and SC are mutually exclusive, and furthermore they are strictly separated and defined as closed regions.
This is necessary to ensure that (from a control-theoretic point of view) the algorithm can be implemented.
If neither condition is satisfied, a node is free to choose non-deterministically between fast and slow mode.In contrast to [12], the algorithm in [9] also allows the use of edges e with different uncertainties e. For every edge e, the algorithm uses a parameter κe ∈ Θ(e) which, roughly speaking, determines how much clock skew the nodes are willing to tolerate on the edge e.
Since κe is closely related to e, we will (in slight abuse of notation) also refer to κe as the weight of edge e. Recall that an edge {u, v} with a large weight κ {u,v} corresponds to a neighbor v for which node u cannot obtain reliable estimates.
Accordingly, node u treats its estimates of node v's clock value as less significant than estimates along edges with a smaller weight.
One may think of each edge as a "leash" that pulls the clocks of its endpoint together.
Edges with smaller weights correspond to shorter leashes, which require closer synchronization than edges with larger weights.
For example, if κ {u,v 1 } = 2κ {u,v 2 } , and a skew of ∆ is required on edge {u, v1} to cause u to enter fast mode or slow mode, then a skew of about 2∆ is required on {u, v2} to cause u to enter the same mode.
In this section, we adapt the algorithm of [9,12] for the dynamic model, and obtain an algorithm with an asymptotically optimal global skew of O(D) and stable local skew of O(log µ/ρ D), where µ ∈ O(1) is the parameter governing the logical clock rate in fast mode.
We present two variants of the algorithm, based on the same technique.
Both variants achieve optimal skew bounds: for any two nodes that remain at distance d from each other for sufficiently long, the algorithms guarantee a skew of at most O(d log(D/d)).
The first algorithm we present is more elegant and simpler to analyze, but it does not achieve the optimal trade-off between skew and stabilization time; its stabilization time is O((D log D)/µ), which is off by an O(log D) factor from the optimum.
The proof of the second variant is more intricate, and the algorithm achieves an optimal stabilization time of O(D/µ).
To simplify the presentation, we focus here on the first algorithm, which we describe and analyze in detail.
The second algorithm is presented in full in the accompanying technical report.
We include here a brief overview.
The first of the two algorithms we present, A DW , is a dynamic-weight algorithm.
Instead of a fixed value κe for an edge e, algorithm A DW maintains a dynamic weight κe that starts with a large value for each newly formed edge e and is gradually decreased.
The initial edge weight is chosen large enough such that an edge has no effect on its endpoints' modes immediately after insertion.
Then, κe is decreased exponentially until it reaches its final value, which corresponds to the uncertainty e of e (as in the static case).
Hence, edges are initially treated as unimportant, and they continuously gain in importance while present.Parameters and constants.
Algorithm A DW involves several parameters which can be tuned to reduce the skew at the cost of longer stabilization time, or vice-versa.
In addition we define several constants to simplify the presentation.
The constants and parameters are described below.
¯ G: an upper bound on the global skew of the algorithm.
We assume that all nodes have access to this bound.
It is sufficient for all nodes to know the number n of nodes in the network, and use n as a conservative estimate for the diameter D of the graph in the global skew bound established in Section 6.1.
µ: a parameter that determines the logical clock rate in fast mode.
To allow nodes to catch up when they are behind, µ must be sufficiently large; we requireµ ≥ 16ρ 1 − ρ .
(2)On the other hand, nodes should not increase their clocks too quickly, or synchronization will be lost; we also require µµ {u,v} ≤ 12 ¯ G for any possible edge {u, v}.
λ: a constant, chosen as 0 < λ < 1/4, which determines the slack in the fast and slow conditions (see Definitions 8 and 9).
The choice of λ does not affect the asymptotic behavior of the algorithm.κ ∞ {u,v} : the "stable" weight of edge {u, v}.
This is the weight eventually assigned to edge {u, v} if it exists long enough in the system, and it corresponds to the uncertainty {u,v} .
We requireκ ∞ {u,v} > 2 λ · " 1 + µ 6 " · {u,v} .
(3)η: a constant that controls the rate at which κ {u,v} is decreased.
It is defined asη := λ(1 − ρ) 6 · µ.
(4)Next we describe the components that make up the algorithm.Dynamic weights.
When an edge {u, v} appears at time t0, nodes u, v establish and maintain a dynamic weight κ {u,v} (t) for the edge.
Both u and v maintain a local estimate of the weight; we use κ v u (t) to denote u's estimate and κ u v (t) to denote v's estimate of κ {u,v} (t).
The "true" weight induced by the two estimates is defined by κ {u,v} (t) := min {κ v u (t), κ u v (t)}.
Suppose that u < v. 1 The node with the smaller identifier, in this case u, is responsible for setting the initial weight and decreasing it over time, while the other node, in this case v, periodically synchronizes its estimate to u's value.
Node u (the "master node") changes κ v u (t) over time according to the following dynamics, decreasing it exponentially from an initial value of ¯ G to the final value of κ ∞ {u,v} .
κ v u (t0) := κ {u,v} (t0) = ¯ G, d dt κ v u (t) := ( − η ¯ G · d dt Hu(t) (1+ρ) · κ v u (t) κ v u (t) > κ ∞ {u,v} , 0 κ v u (t) = κ ∞ {u,v} .
(5)Using the estimate layer, node v (the "slave node") conservatively synchronizes its estimate κ u v to u's value.
We omit the technical details here; the following lemma characterizes the accuracy of v's estimates.Lemma 7.
For all t ≥ 0 and nodes u < v, we have0 ≤ κ u v (t) − κ v u (t) ≤ µµ {u,v} 6 ¯ G · κ {u,v} (t).
In particular, we always have κ {u,v} (t) = κ v u (t), that is, the master node's estimate is the true weight.Max estimates.
As in [8,12,13,14], each node maintains a local estimate Mu of the maximum logical clock value in the network, and makes sure never to exceed it.
As this is a standard technique we omit the implementation details, and note only that max estimates satisfy the following constraint: if the dynamic graph has a diameter of D, then for all t ≥ 0 and for all nodes u we haveMu(t) ≤ max v∈V {Lv(t)} ,(6)∀t ≥ 2D : Mu(t) > max v∈V {Lv(t − 2D)} ,(7)Mu(t) ≥ Lu(t),(8)Mu(t) ≥ max v∈Nu(t) n ˜ L v u (t) − {u,v} o ,(9)That is, the max estimate of any node is never more than the true maximum, and it represents the true maximum from 2D time units ago, where D is the time required to complete a flood in the dynamic graph.
(The factor 2 arises from the fact that nodes do not constantly flood the network with max estimates.
It can be reduced to (1 + ι), where ι is an arbitrarily small constant, by starting floods sufficiently often.)
In addition, (8) asserts that nodes cannot set their logical clock ahead of their max estimate, and (9) asserts that the max estimate always reflects the logical clock values of immediate neighbors.The fast and slow conditions.
If node u finds that it is too far behind, it goes into fast mode and uses a fast rate of (1 + µ) d dt Hu(t) to increase its logical clock.
The following rule is used to determine when to go into fast mode.
Informally, it states that some neighbor is far ahead, and no neighbor is too far behind.Definition 8 (Fast condition FC).
At time t, node u ∈ V satisfies the fast condition, denoted FC, if there is some integer s ≥ 1 for which the following conditions are satisfied:∃w ∈ Nu(t) : ˜ L w u (t) − Lu(t) ≥ (s − λ)κ w u (t) ∀v ∈ Nu(t) : Lu(t) − ˜ L v u (t) ≤ (s + λ)κ v u (t).
Conversely, if a node is far behind some neighbor, and no other neighbor is too far ahead of it, it enters slow mode and uses the slow rate.
The rule for entering slow mode is as follows.Definition 9 (Slow condition SC).
At time t, node u ∈ V satisfies the slow condition, denoted SC, if there is some integer s ≥ 0 for which the following conditions are satisfied:∃w ∈ Nu(t) : Lu(t) − ˜ L w u (t) ≥ " s + 1 2 − λ « κ w u (t) ∀v ∈ Nu(t) : ˜ L v u (t) − Lu(t) ≤ " s + 1 2 + λ « κ v u (t).
Since a node cannot be in fast mode and in slow mode at the same time, SC and FC are required to be mutually exclusive, otherwise the algorithm would be impossible to implement.Lemma 10.
No node can satisfy FC and SC at the same time.This essentially follows from the fact that λ < 1/4, implying that s + 1/2 − λ > s + λ and s + 1/2 + λ < (s + 1) − λ for all s.
A formal proof of this statement is given in [9] and an analogous result for our second algorithm is shown in the technical report.With the above definitions in place, A DW is given by the following rules, executed at each node u at all times t: If neither of the conditions above holds, the node is free to choose its mode nondeterministically.
− If FC The second variant of the algorithm uses exactly the same definition of fast mode and slow mode.
In particular, it also guarantees that all logical clock rates are always in the range[1 − ρ, (1 + µ)(1 + ρ)].
The main difference is that the algorithm uses a different mechanism to ensure that new edges cannot immediately determine the current mode.
Instead of a dynamic weight κe, each node u uses several neighborhood sets N 1 u , N 2 u , . . . (in addition to Nu), for which it holds at all times that Nu ⊇ N 1 u ⊇ N 2 u etc.
Both FC and SC are changed in that they now apply when there is some integer s for which the FC/SC preconditions restricted to N s u (t) are satisfied.
For example, the first condition of FC changes to "when there is a neighbor w ∈ N s u (t) such that˜L that˜ that˜L w u (t) − Lu(t) ≥ (s − λ)κ w u (t)."
If the neighborhood sets are chosen and updated appropriately, these modified conditions also guarantee that new edges cannot cause a violation of the desired skew bounds.The crucial question is when and how the neighborhood sets are updated.
We will now briefly outline this procedure.
The algorithm operates in loosely synchronized rounds, i.e., a round always begins when the logical clock reaches a certain value (which may occur at different times at different nodes).
The edges that are incorporated in any round are all the new edges that are present at the beginning of the round, i.e., if new neighbors appear during the course of a round, they are ignored until the next round starts.
In each round, the sets N 1 u , N 2 u , . . . , are updated exactly once and in this order at times T1 < T2 < . . . etc.
Updating a set N s u simply means setting it to N s−1 u .
The set N 1 u is updated using the neighborhood Nu of u at time T1.
The update times occur in intervals that ensure that the targeted skew bounds are never violated.
In the technical report, we prove that these times can be defined in such a way that the duration of a round is O(D/µ) and that all new edges introduced at the beginning of a round have stabilized by its end.
In this section, we sketch the analysis of A DW and bound its worst-case global and dynamic gradient skew.
To simplify the presentation, we assume here that when an edge appears or disappears, both endpoints find out about this event immediately.
Hence, in this section, the following four statements are equivalent: I. (u, v) ∈ E(t), II.
(v, u) ∈ E(t), III.
u ∈ Nv(t), and IV.
v ∈ Nu(t).
Consequently, we refer only to undirected edges {u, v} throughout the section.
In the accompanying technical report, algorithm A OPT is analyzed without this assumption.
Like its predecessors in [9,12], Algorithm A DW achieves an asymptotically optimal global skew of O(D), where D is now defined as the dynamic diameter of the graph (see Section 3).
Theorem 11.
Algorithm A DW achieves a global skew of2(1 + ρ)D ∈ O(D) in networks of diameter D.Proof.
The proof is similar to the ones in [8,12].
First, consider the node u with the largest clock in the network, i.e., Lu(t) = maxv∈V {Lv(t)}.
From (6) and (8) we have Mu(t) = Lu(t), that is, node u knows that it has the largest clock value.
In addition, by (3) and (9) we have Mu(t) ≥ max v∈Nu(t) {Lv(t) − {u,v} } and for any neighbor v,(1 − λ)κ v u (t) ≥ (1 − λ)κ ∞ {u,v} > {u,v} .
Hence, u's estimates of its neighbors' clock values cannot be large enough for FC to hold.
Together with the fact that Lu(t) = Mu(t), this forces u to be in slow mode.For this reason, the maximum clock value in the network increases at most at rate 1 + ρ, the maximum hardware clock rate.
From (7) it follows that for any node v we have Mv(t) > maxw∈V {Lw(t)} − 2(1 + ρ)D; that is, the max estimates of all nodes are "not too far off" the true maximum.
Now consider a node u with the smallest clock in the network, Lu(t) = minv∈V {Lv(t)}, and suppose that Lu(t) = maxv∈V {Lv(t)} − 2D(1 + ρ), in other words, that there is a large gap between the smallest and largest clocks.
Because Mv(t) > maxw∈V {Lw(t)} − 2(1 + ρ)D, we immediately obtain Lu(t) < Mu(t), so node u knows it is behind.
In addition, since node u has the smallest clock, for each v ∈ Nu(t) we have Lv(t) ≥ Lu(t), and hence˜L hence˜ hence˜L vu (t) ≥ Lu(t) − {u,v} > Lu(t) − (1/2 − λ)κ v u (t), which means that SC does not hold (all of u's neighbors are too far ahead).
Together with the fact that Lu(t) < Mu(t), this forces node u to be in fast mode.We have shown that whenever there is a large enough skew such that minv∈V {Lv(t)} = maxv∈V {Lv(t)}−2(1+ρ)D, all nodes with the smallest logical clock value, minv∈V {Lv(t)}, will be in fast mode, and all nodes with the largest logical clock value will be in slow mode.
A node in fast mode increases its logical clock at a rate of at least (1 + µ)(1 − ρ), and a node in slow mode increases its logical clock at a rate of at most (1 + ρ).
By (2), (1 + µ)(1 − ρ) > 1 + ρ, so the nodes that are the most behind cannot fall behind any further.
The continuity of logical clocks thus ensures that the global skew never exceeds 2(1 + ρ)D.As explained in Section 5.1, we assume that each node maintains an upper bound ¯ G on the global skew of the network.
This can be done dynamically, by running an estimation protocol alongside the clock synchronization algorithm, or the bound ¯ G can be computed statically based on known properties of the network.
For simplicity, we use a single global skew estimate ¯ G throughout the paper.
All algorithms and proofs can however be adapted to a scenario where each node maintains an individual and possibly dynamic upper bound on the global skew.
In this section, we prove the gradient property of Algorithm A DW .
The algorithm has an asympotically optimal stable gradient skew of O(d log µ/ρ (D/d)).
For the sake of simplicity, we show the following slightly weaker statement:Theorem 12.
Algorithm A DW has a stable gradient skew of O(d log(D/d)) with stabilization time O((D/µ) log D)).
We start by analyzing some properties of the dynamic weights κ {u,v} (t).
For a path p = (u0, . . . , u k ) that exists at time t, we define κp(t) := P k i=1 κ {ui−1,ui} (t) to be the total weight of the path at time t.
In addition, for any path p that exists throughout an interval [t0, t1], let ∆κp(t0, t1) := κp(t1) − κp(t0) be the change in the path's weight from time t0 to time t1.
The following technical lemma asserts that over sufficiently short intervals [t0, t1], the change in a path's weight is bounded as a function of its weight at time t1.Lemma 13.
For any path p, integer s ≥ 1, and times t1 ≥ t0 such that t1− t0 ≤ ¯ G/2 s−1 (1−ρ)µ , we have 0 ≥ ∆κp(t0, t1) ≥ −κp(t1) · λ/3 s + 1/2 .
Proof.
First, observe that κp(t) is positive and nonincreasing (along paths that do not disappear).
From (5), we have∆κp(t0, t1) ≥ −κp(t0) · η ¯ G (t1 − t0) = −κp(t0) · λ 3 · 2 s ≥ −κp(t0) · λ/3 s + 1 .
This implies that κp(t1)/κp(t0) ≥ 1− λ/3 s+1 ≥ s−1/2 s+1, and thus the claim follows.The following definition captures the formal requirement on the skew along paths of different weight.Definition 14 (Legal State).
We say that the network is in a legal state at time t if and only if for all integers s ≥ 1 and all paths p = (v0, . . . , v k ) with κp(t) ≥ Cs := ¯ G/2 s−1 that exist at time t it holds thatLv k (t) − Lv 0 (t) ≤ s · κp(t).
We will show that the legal state condition is an invariant maintained throughout any execution of the algorithm, which implies Theorem 12.
In the analysis we work with two notions of "weighted skew", capturing how much a node v0 is ahead or behind any other node, respectively.
Both notions of weighted skew are essentially the difference between the clocks of the nodes at the endpoints of a path, normalized by the total weight of the path.
However, we use different constants for each, corresponding to the constants used in FC and SC.Definition 15.
Given an integer s ≥ 1, a time t, and a path p = (v0, . . . , v k ), we defineΞ s p (t) := Lv 0 (t) − Lv k (t) − s · κp(t),and Ξ s v 0 (t) := max Definition 21.
Given a node u and times t > t0 ≥ 0, we define the swing time of u relative to t0 and t by swu(t0, t) := min( t ∈ [t0, t] ˛ ˛ ˛ ˛ ˛ Lu(t) − Lu(t ) ≤ (1 + ρ) · (t − t ) ) .
(12)By definition, swu(t0, t) is the earliest time relative to t such that between swu(t0, t) and t node u's clock increased by no more than its maximal natural rate.
Hence, the rate at time swu(t0, t) is greater than 1 + ρ and thus u is in fast mode at time swu(t0, t) provided that swu(t0, t) > t0.
2 We show that in this case, one of the following two conditions must hold at time swu(t0, t).
(SW-∃) There exist a neighbor w ∈ Nu(swu(t0, t)) and an integer s ≥ 0 such thatLw(swu(t0, t)) − Lu(swu(t0, t)) > " s + 1 + λ 2 « κ {u,v} (swu(t0, t)).
(SW-∀) For all neighbors w ∈ Nu(swu(t0, t)) and integers s ≥ 0 we haveLu(swu(t0, t)) − Lw(swu(t0, t)) < " s + 1 − λ 2 « κ {u,v} (swu(t0, t)).
Lemma 22.
For all nodes u and times t, if swu(t0, t) > t0, then either (SW-∃) or (SW-∀) holds.Proof.
Omitted.
An analogous statement for A OPT is proved in the technical report.The following theorem proves the gradient skew property of A DW .
Due to lack of space, we include only an overview of the proof.
For the full proof, we refer to the technical report.Theorem 23.
The system is always in a legal state.Proof.
Assume by way of contradiction that the legal state condition is violated, and let t be the infimum of times for which it is violated.
In this case there exists an integer s ≥ 1 and a path q = (w, . . . , w ) such that κq(t) ≥ Cs+1 and Lw(t) − L w (t) = (s + 1) · κq(t).
(13)Note that by the global skew constraint, the legal state is always satisfied for paths q with κq(t) ≥ C1.
We can therefore assume that s ≥ 1.
Let p = (u0, . . . , u k ) be a path for which Ψ s p −1 (t) = Ψ s (t).
We haveΨ s p −1 (t) = Ψ s (t) ≥ Ψ s (w ,...,w) (t) = Ξ s (w,...,w ) (t) − κq(t) 2 (13) = κq(t) 2 ≥ Cs+1 2 .
(14)From legality (which still holds at time t) and (13), we obtain κp(t) < Cs.
Definet := t − Cs (1 − ρ)µ .2 More precisely, there is a time t0 < t < swu(t0, t) for which it holds that the amortized rate of u is larger than 1 + ρ over any time interval [t , swu(t0, t)] where t ∈ (t , swu(t0, t)).
Roughly speaking, our goal is to show that there is always some node that pulls node u k ahead, acting to reduce Ξ.
For this to happen we need Ξ to remain large as we go back in time, allowing us to use Lemma 19.
Furthermore, in order to show an actual decrease of Ξ, we need the node that is ahead to remain in slow mode while u k (or whichever node is behind the most) catches up.
We cannot guarantee that the foremost nodes will indeed remain in slow mode, but we know that if node v enters fast mode, there is a reason: node v believes itself free to move at the fast rate, therefore either some neighbor w is far ahead (SW-∃), or no neighbor is very far behind (SW-∀).
In the first case (SW-∃), we can switch to reasoning about the path that extends to w, and doing so only increases the weighted skew of the path (because w has a large weighted skew relative to v).
We refer to such a switch as a forward switch.
However, the second case (SW-∀) is problematic: in this case we actually lose weighted skew, because we have to switch to a node that is behind v, and the weighted skew of the path decreases.
We call this a backwards switch.
In order to retain positive weighted skew we must bound the number of backwards switches.
This is accomplished by only making backwards switches along the path from u0 to u k , so that eventually we "run out of nodes".
We show that eventually we can stop making backwards switches.I.
Backwards switches, tracing p inwards towards u k .
We define a sequence of non-increasing times t0 = t ≥ t1 ≥ . . . ≥ t , where < k.
The construction is inductive, with t0 = t and for all 1 ≤ i ≤ , ti+1 := swu i (t, ti).
The construction stops at the minimal index such that either t +1 = t or (SW-∃) is satisfied for u at time t +1 .
First, observe that since ti+1 = swu i (t, ti), for all 0 ≤ i ≤ k − 1 and times t ∈ [ti+1, ti] we haveΞ s u i ,...,u k (t) = Ξ s u i ,...,u k (ti) − Iu i (t, ti) + Iu k (t, ti) + s∆κ (u 0 ,...,u i ) (t, ti) (12) ≥ Ξ s u i ,...,u k (ti) − (1 + ρ)(ti − t) + Iu k (t, ti) + s∆κ (u 0 ,...,u i ) (t, ti).
(15)Next, it follows by induction on i that for all i ∈ {0, . . . , },Ξ s u i ,...,u k (ti) ≥ Ξ s p (t0) − κu 0 ,...,u i (t0) 2 − (1 + ρ)(t0 − ti) + Iu k (ti, t0) + s∆κ (u 0 ,...,u i ) (ti, t0).
(16)The induction is omitted here for lack of space.
Informally, this bounds the weighted skew from below as we trace p inwards towards node u k , showing that plenty of weighted skew remains.
This will be used to derive a contradiction to the fact that the system is legal at time t.II.
Forward switches until time t. Having reached a node where we can make a forward switch for the first time, we show that we can continue to make forward switches as we go back in time until we reach t.
We construct a chain v , . . . , v +m , where v = u , and a sequence of times t , . . . , t +m = t (where t is the time we reached in the previous part).
The times ti are defined as before, for all ≤ i ≤ + m − 1, we define ti+1 := swv i (t, ti).
The construction is inductive.
Assume that we have reached node vi at time ti+1 = swv i (t, ti).
To obtain vi+1, we show that we can make a forward switch from vi, that is, that (SW-∃) is satisfied at vi at time ti+1.
For i = the claim follows from the halting condition of Part I; thus, suppose that i > and that (SW-∃) is not satisfied.
Then from Lemma 22, (SW-∀) is satisfied at time ti+1 for vi.
In particular, for vi−1 ∈ Nv i (ti+1) we then haveLv i (ti+1) − Lv i−1 (ti+1) < " s + 1 − λ 2 « κ {vi,vi−1} (ti+1).
(18) Since vi was reached by a forward switch from vi−1 at time ti, we also haveLv i (ti) − Lv i−1 (ti) > " s + 1 + λ 2 « κ {vi,vi−1} (ti).
(19)Combining (18) and (19) yieldsIv i−1 (ti+1, ti) < Iv i (ti+1, ti) − λκ {vi,vi+1} (ti) − " s + 1 − λ 2 « ∆κ {vi,vi+1} (ti+1, ti) (Lem.
13) ≤ Iv i (ti+1, ti).
(20)We thus obtainIv i−1 (ti+1, ti−1) = Iv i−1 (ti+1, ti) + Iv i−1 (ti, ti−1) (20) < Iv i (ti+1, ti) + Iv i−1 (ti, ti−1)(12)≤ (1 + ρ)(ti−1 − ti+1).
This is a contradiction to the choice of ti = sw(ti−1).
Thus, (SW-∃) must be satisfied at node vi at time ti+1.
Therefore, we can choose a node vi+1 ∈ Nv i for whichLv i+1 (ti+1) − Lv i (ti+1) > " s + 1 + λ 2 « κ {vi,vi+1} (ti+1).
(21) In the following, we show by induction on i that for all i ∈ {, . . . , + m − 1},Ξ s v i (ti+1) ≥ Ξ s v (t +1 ) + ((1 − ρ)µ − 2ρ − η)(t +1 − ti+1) > 0.
(22)Induction base.
The base case follows from applying the bound obtained in (14) to (16), with i = and t = t +1 .
We omit the details.Induction step.
We first extend the path by adding node vi+1.
Let p = (vi, . . . , v) be a path maximizing Ξ s v i (ti+1).
Note that since p exists at time ti+1 and vi+1 ∈ Nv i (ti+1), the path (vi+1, vi, . . . , v) exists at time ti+1 as well.
We haveΞ s v i+1 (ti+1) ≥ Ξ s (v i+1 ,v i ,...,v) (ti+1) = Ξ s (v i ,...,v) (ti+1) + Lv i+1 (ti+1) − Lv i (ti+1) − sκ {vi+1,vi} (ti+1) (23) (21) > Ξ s (v i ,...,v) (ti+1) = Ξ s v i (ti+1) (I.H.) ≥ Ξ s v (t +1 ) + ((1 − ρ)µ − 2ρ − η)(t +1 − ti+1) > 0.
(24)We now show that Ξ s v i+1 (t) > 0 for all times t ∈ [ti+2, ti+1].
For the sake of contradiction, assume that there is a t ∈ [ti+2, ti+1] for which Ξ s v i+1 (t) ≤ 0 and assume that t is the largest such time.
We then have Ξ s v i+1 (τ ) > 0 for all τ ∈ (t, ti+1] and therefore0 (24) < Ξ s v i+1 (ti+1) = Ξ s v i+1 (t) + Z t i+1 t d dt Ξ s v i+1 (τ )dτ (Lem.
19) ≤ Lv i+1 (ti+1) − ((1 − ρ)(1 + µ) − η)(ti+1 − t) − Lv i+1 (t) (17) ≤ −((1 − ρ)µ − 2ρ − η)(ti+1 − t) < 0.
We conclude that Ξ s v i+1 (t) > 0 for all t ∈ [ti+2, ti+1], which allows us to apply Lemma 19 to lower bound Ξ s v i+1 (ti+2):Ξ s v i+1 (ti+2) ≥ Ξ s v i+1 (tt+1) + ((1 − ρ)µ − 2ρ − η)(ti+1 − ti+2) (24) ≥ Ξ s v (t +1 ) + ((1 − ρ)µ − 2ρ − η)(t +1 − ti+2).
III.
Putting everything together.
Using Inequality (16) for i = and t = t +1 , we obtainΞ s u (t) ≥ Ξ s (u ,...,v k ) (t) = Ξ s u (t +1 ) + Iu (t +1 , t) − Iu k (t +1 , t) − s∆κ (u ,...,u k ) (t +1 , t)(25)(16),(10) ≥ Ψ s p −1 (t) − (1 + ρ)(t − t +1 ) + Iu (t +1 , t) + s∆κ (u 0 ,...,u ) (t, t).
(26)Applying (22) for i = + m (note that u = v ) yields Theorem 12 follows from Theorem 23: the legal state condition implies that the stable local skew is O(d log(D/d)).
Since we assumed that µ is constant, the stabilization time of O(D log D) follows from the dynamics of κ {u,v} , which stabilizes to its final value of κ ∞ {u,v} after O((D log D)/µ) time.
(The weights are defined in terms of the global skew ¯ G, which Theorem 11 shows to be in O(D).)
Ξ s v +m (t) (22) ≥ Ξ s u (t +1 ) + ((1 − ρ)µ − 2ρ − η)(t +1 − t) (Lem.
19) ≥ Ξ s u (t) − Iu (t +1 , t) + ((1 − ρ)(1 + µ) − η) · (t − t +1 ) + ((1 − ρ)µ − 2ρ − η)(t +1 − t)( The lower bound of [8] stated, roughly speaking, that the stabilization time of any S-dynamic gradient CSA with a stable gradient skew of S ∞ must be at least Ω(D/S ∞ (1)) in graphs of diameter D. For CSA with O(log D)-local skew, this bound implies that the stabilization time must be Ω(D/ log D).
Algorithm A OPT has a stabilization time of O(D), which does not match the bound in [8]; however, by refining the analysis in the lower bound we can show that the algorithm is in fact asymptotically optimal in its stabilization time.
The key to the stronger bound is reasoning about the full gradient property, which bounds the skew on paths of all distances, rather than just the local skew property, which only bounds the skew on single edges.Let us call a dynamic gradient CSA non-trivial if it has a stable gradient skew satisfying S ∞ (1) ∈ o(D).
This essentially means that the algorithm guarantees a local skew (e.g., along single edges) that is better than the global skew.
The stronger lower bound states the following.Theorem 24.
Let F = ˘ fD : R + 0 → R + 0 | D ∈ R ¯ be a family of functions, and let c1, c2 ∈ (0, 1/16) be constants such that for all fD ∈ F we have fD(c1D) ≤ c2D.
Let A be a non-trivial stabilizing CSA guaranteeing a dynamic gradient skew of fD in graphs of weighted diameter D.
Then the stabilization time of A is at least Ω(D).
The proof is similar to the one in [8]; it appears in the technical report.
Algorithms A OPT and A DW , which guarantee a stable gradient skew of S ∞ (d) ∈ O(d log(D/d)), satisfy the conditions of the theorem; hence, A OPT has optimal stabilization time, while A DW is within a log D factor of optimal.
We have presented two gradient clock synchronization algorithms for dynamic networks.
If logical clocks are allowed to increase at a rate of at most (1 + µ)(1 + ρ) for a parameter µ ∈ O(1), both algorithms achieve a stable local skew of O(d log µ/ρ (D/d)) between nodes at distance d, where D is the dynamic diameter of the network.
Choosing µ large allows us to achieve asymptotically optimal local skew of O(d log 1/ρ (D/d)), whereas choosing µ ∈ O(ρ) gives almost optimal local skew and logical clocks that behave like hardware clocks with slightly worse clock drift.
Note, however, that choosing µ small also entails that a larger stabilization time must be accepted.The algorithms we give can be extended in various ways.
The current analysis assumes that the node set is fixed, and that only the edge set of the network graph can be dynamic.
However, we only use this assumption to establish a bound on the global skew of the algorithms.
As long as node insertions and removals occur in a way that allows the nodes to maintain an upper bound on the global skew, the analysis can be extended to the completely dynamic setting.
Another interesting direction would be to change A DW in the following way: instead of immediately forgetting about edges that disappear (which can be thought of as assigning them infinite weight), nodes could gradually increase the weight on an edge that has disappeared.
The weights would have to be increased at a rate that ensures that the system remains legal at all times.
This should allow us to reduce the skew faster on edges that re-appear after disappearing for a short time.
One could envision combining this version of A DW with A OPT to obtain an algorithm that can optimally insert new edges and quickly recover from transient edge failures.
