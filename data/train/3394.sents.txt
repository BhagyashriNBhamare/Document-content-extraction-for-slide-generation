Network functions virtualization (NFV) promises to offer networks great exibility in handling middlebox load spikes and failures by helping spin up new virtual instances and dynamically redistributing trac among instances.
Central to realizing the beneets of such elasticity and fault tolerance is the ability to handle internal middlebox state during trac redistribution.
Because middlebox state is dynamic (it can be updated for each incoming packet) and critical (its current value determines middlebox actions), the relevant internal state must be made available when trac is rerouted to a diierent middlebox instance [ [[, , ].
Recognizing this, and given the high-overhead and poor eeciency of existing approaches for replicating and sharing application state [ [[, , ] However, for middleboxes to work with these frameworks, middlebox developers must modify, or at least annotate, their code to perform custom state allocation, track updates to state, and (de)serialize state objects. 񮽙
e central contribution of this paper is a novel, frameworkindependent system that greatly reduces the eeort involved in making such modiications.񮽙
ree factors make such modiications diicult today: (i) middlebox soware is extremely complex, and the logic to update/create diierent pieces of state can be intricate; (ii) there may be s----s of object types that correspond to state that needs explicit handling; and (iii) middleboxes are extremely diverse.
Factors i and ii make it diicult to reason about the completeness or correctness of manual modiications.
And, iii means manual techniques that apply to one middlebox may not extend to another.
Our own experience in modifying middleboxes to work with OpenNF [[[] underscores these problems.
Making even a simple monitoring appliance (PRADS [[], with K LOC) OpenNF-compliant took over manhours.
We had to iterate over multiple code changes and corresponding unit tests to ascertain completeness of our modiications; moreover, the process we used for modifying this middlebox could not be easily adapted to other more complex ones! 񮽙
ese diiculties signiicantly raise the bar for the adoption of these otherwise immensely useful state handling frameworks.
To reduce manual eeort and ease adoption, we develop StateAlyzr, a system that relies on data and control-ow analysis to automate identiication of state objects that need explicit handling.
Using StateAlyzr's output, developers can easily make frameworkcompliant changes to arbitrary middleboxes, e.g., identify which state to allocate using custom libraries for [ [[, , ], determine where to track updates to state [ [[, , ], (de)serialize relevant state objects for transfer/-cloning [ [[], and merge externally provided state with internal structures [[[, ].
In practice we nd StateAlyzr to be highly eeective.
For example, leveraging StateAlyzr to make PRADS OpenNF-compliant took under manhours of work.Importantly, transferring/cloning state objects identied with StateAlyzr is provably sound and precise. 񮽙
e former means that the aggregate output of a collection of instances following redistribution is equivalent to the output that would have been produced had redistribution not occurred. 񮽙
e latter means that StateAlyzr identiies minimal state to transfer so as to ensure that redistribution oers good performance and incurs low overhead.However, achieving high precision without compro- mising soundness is challenging.
Key attributes of middlebox code contribute to this: e.g., numerous data structures and procedures, large callgraphs, heavy use of (multi-level) pointers, and indirect calls to packet processing routines that modify state (See Table ).
To overcome these challenges, StateAlyzr cleverly adapts program analysis techniques, such as slicing [ [[, ] and pointer analysis [[, ], to typical middlebox code structure and design patterns, contributing new algorithms for detailed classiication of middlebox state. 񮽙
ese algorithms can automatically identify: (i) variables corresponding to state objects that pertain to individual or groups of ows, (ii) the subset of these that correspond to state objects that can be updated by an arbitrary incoming packet at runtime, (iii) the ow space corresponding to a state object, (iv) middlebox I/O actions that are impacted by each state object, and (v) objects updated at runtime by an incoming packet.To evaluate StateAlyzr, we both prove that our algorithms are sound (Appendix B) and use experiments to demonstrate precision and the resultant impact on the eeciency of state transfer/cloning.
We run StateAlyzr on four open source middleboxes-Passive Real-time Asset Detection System (PRADS) [[] • StateAlyzr's algorithms improve precision signiicantly: whereas the middleboxes have ---k variables, only --correspond to state that needs explicit handling, and --are updateable at run time.
By automatically identifying updateable state, StateAlyzr allows developers to focus on the necessary subset of variables among the many present.
StateAlyzr can be imprecise: of the updateable variables are mis-labeled (they are in fact read-only), but the information StateAlyzr provides allows developers to ignore processing these variables.
• Using StateAlyzr output, we modiied PRADS and Snort to support fault tolerance usingOpenNF [[[].
We nd that StateAlyzr reduces the manual eeort needed.
We could modify Snort (our most complex middlebox) and PRADS in and man-hours, respectively.
Further, by helping track which owspace an incoming packet belongs to, and which state objects it had updated, StateAlyzr reduces unneeded runtime state transfers between the primary and backup instances of PRADS and Snort by and 񮽙񮽙񮽙񮽙 respectively compared to naive approaches.
• StateAlyzr can process middlebox code in a reasonable amount of time.
Finally, it helped us identify important variables that we missed in our earlier modications to PRADS, underscoring its usefulness.
Middlebox scaling and failure recovery should be transparent to end-users and applications.
Key to ensuring this is maintaining output equivalence: for any input trafc stream, the aggregate output of a dynamic set of middlebox instances should be equivalent to the output produced by a single, monolithic, always-available instance that processes the entire input [ [[]. 񮽙
e output may include network trac and middlebox logs.As shown in prior works [ [[, , ], achieving output equivalence is hard because middleboxes are stateful.
Every packet the middlebox receives may trigger updates to multiple pieces of internal state, and middlebox output is highly dependent on the current state. 񮽙
us, malfunctions can occur when trac is rerouted to a middlebox instance without the relevant internal state being made available at the instance.
Approaches like naively rerouting newly arriving ows or forcibly rerouting ows with pertinent state can violate output equivalence. 񮽙
e reader is referred to [[[, ] for a more formal treatment of the need to handle internal state.
Traditional approaches for replicating and sharing application state are resource intensive and slow [[[, , 񮽙񮽙] Table ):• Split/Merge [[[] and Pico Replication [[] requiremiddleboxes to allocate and access all per-and cross--ow state-i.e., state that supports the processing of multiple packets within and across ows, respectively-through a specialized shared library, instead of using system-provided functions (e.g., malloc Making the above modiications to middleboxes is difcult because middlebox code is complex.
As shown in Table , several popular middleboxes have between K and K lines of code (LOC), dozens of diierent structures and classes, and, in some cases, complex eventbased control ow.
If a developer misses a change to some structure, class, or function, then output equivalence may be violated under certain input patterns, and a middlebox may fail in unexpected ways at run time.
FTMB is the only system that aims to avoid such problems.
It automatically modiies middleboxes using LLVM [[].
However, there are two problems: (i) developers must still manually specify which variables may contain/point-to cross--ow state; (ii) the tool is limited to Click-based middleboxes [[].
Making the aforementioned changes to even simple middleboxes can take numerous man-hours as our own experience with OpenNF suggests. 񮽙
is is a serious barrier to adopting any of the previously mentioned systems.A system that can automatically identify what state a middlebox creates, where the state is created, and how the state is used could be immensely helpful in reducing the man-hours.
It can provide developers guidance on writing custom state allocation routines, and on adding appropriate state ltering, serialization, and merging functions. 񮽙
us, it would greatly lower the barriers to adopting the above frameworks.Building such a system is challenging because of soundness and precision requirements.
Soundness means that the system must not miss any types, storage locations, allocations, or uses of state required for output equivalence.
A precise system identiies the minimal set of state that requires special handling to ensure state handling at runtime is fast and low-overhead.
Well-known program analysis approaches can be applied to identify middlebox state and its characteristics.
Dynamic analysis.
We could use dynamic taint analysis [[] to monitor which pieces of state are used and modiied while a middlebox processes some sample input.
Unfortunately, the sample inputs may not exercise all code paths, causing the analysis to miss some state.
We also nd that such monitoring can signiicantly slow middleboxes down (e.g., PRADS [[] [[, ]. 񮽙
Symbolic execution can be employed to explore all possible code paths by representing input and runtime state as a series of symbols rather than concrete values.
We can then track the state used in each path.
While this is sound, the complexity of most middleboxes (Table ) makes it impossible to explore all execution paths in a tractable amount of time.
For example, we symbolically executed PRADS-which has just K LOC-for hours using SSE [ Packet processing loop while (event = dequeue()) Packet processing procedures In this paper, we make clever use of data-/control--ow analysis to automatically evaluate how to handle middlebox state.
Naively applying standard data-/control--ow analysis identiies all variables as pertaining to 'state that needs handling' (e.g., variables pertaining to per-packet state, read-only state, and state that falls outside the scope of a owspace of interest); if developers modify a middlebox to specially handle all these variables, it can result in arbitrarily poor runtime performance during redistribution.
We show how middlebox code structure and design patterns can be used to design novel algorithms that employ static program analysis techniques in a way that signiicantly improves precision without compromising soundness.
Our approach is general and does not assume use of any particular state management framework.
Most middleboxes' code can be logically divided into three basic parts (Figure ): initialization, packet receive loop, and packet processing. 񮽙
e initialization code runs when the middlebox starts.
It reads and parses connguration input, loads supplementary modules or les, and opens log les.
All of this can be done in the main() procedure, or in separate procedures called by main. 񮽙
e packet receive loop is responsible for reading a packet (or byte stream) from the kernel (via a socket) and passing it to the packet processing procedure(s). 񮽙
e latter analyzes, and potentially modiies, the packet. 񮽙
is procedure(s) reads/writes internal middlebox state to inform the processing of the current (and future) packet.Our approach consists of three primary stages that leverage this structure.
In each stage we further reene our characterization of a middlebox's state. 񮽙
e stages and their main challenges are described next: ) Identify Per-/Cross-Flow State.
In the rst stage, we identify the storage location for all per-and cross--ow state created by the middlebox. 񮽙
e enal output of this stage is a list of what we call top-level variables that contain or indirectly refer to such state.Unlike state that is only used for processing the current packet, per-/cross--ow state innuences other packets' processing.
Consequently, the lifetime of this state extends beyond the processing a single packet.
We leverage this property, along with knowledge of the relation between variable and value lifetimes, to rst identify variables that may contain or refer to per-/cross--ow state.We improve precision by considering which variables are actually used in packet processing code, thereby eliminating variables that contain or refer to state that is only used for middlebox initialization.
We call the remaining variables "top-level". 񮽙
e main challenge here is dealing with indirect calls to packet processing in event-based middleboxes ( Figure ), which complicate the task of identifying all packet processing code.
We develop an algorithm that adapts forward program slicing [[[] to address this challenge ( § §.
.)
. )
Identify Updateable State. 񮽙
e second stage further categorizes state based on whether it may be updated while a packet is processed.
If state is readonly, we can avoid repeated cloning (in Pico Replication and OpenNF), avoid unnecessary logging of accesses (FTMB), and allow simultaneous access from multiple instances (StatelessNF); all of these will reduce the frameworks' overhead.
We can trivially identify updateable state by looking for assignment statements in packet processing procedures.
However, this strawman is complicated by heavy use of pointers in middlebox code which can be used to indirect state update.
To address this challenge we show how to employ ow-, context-, and eldinsensitive pointer analysis [[, ] ( § §.
.)
. )
Identify States' Flowspace Dimensions.
Finally, the third stage determines a state's owspace: a set of packet header elds (e.g. src ip, dest ip, src port, dest port & proto) that delineate the subset of trac that relates to the state.
Flowspace must be considered when modifying a middlebox to use custom allocation functions [[, ] or lter state in preparation for export [[[].
It is important to avoid the inclusion of irrelevant header elds and the exclusion of relevant elds in a state's owspace, because it impacts runtime correctness and performance, respectively.
To solve this problem we developed an algorithm that leverages common state access patterns in middleboxes to identify program points where we can apply program chopping [[[] to determine relevant header elds ( § §.
.)
.
Soundness.
In order for StateAlyzr to be sound it is necessary for these three stages to be sound.
In Appendix B, we prove the soundness of our algorithms.
Assumptions about middlebox code.
Our proofs are based on the assumption that middleboxes use standard API or system calls to read/write packets and hashtables or link-lists to store state. 񮽙
ese assumption are not limitations of our analysis algorithms.
Instead, they are made to ease the implementation of StateAlyzr.
Our implementation can be extended to add additional packet read-/write methods or other data structures to store the state.
We now describe our novel algorithms for detailed state classiication.
To describe the algorithms, we use the example of a simple middlebox that blocks external hosts creating too many new connections (Figure ).
Our analysis begins by identifying the storage location for all relevant per-and cross--ow state created by the middlebox. 񮽙
is has two parts: (i) exhaustively identifying persistent variables to ensure soundness, and (ii) carefully limiting to top-level variables that contain or refer to per-/cross--ow values to ensure precision.
Because per-/cross--ow state necessarily innuences two or more packets within/across ows, values corresponding to such state must be created during or prior to the processing of one packet, and be destroyed during or after the processing of a subsequent packet.
Hence, the corresponding variables must be persistent, i.e., their values persist beyond a single iteration of the packet processing loop.
In Figure , variables declared on lines to are persistent, whereas curr on line is not.
Our algorithm rst identiies such variables.
Analysis Algorithm.
We traverse a middlebox's code, as shown in Figure . 񮽙
e values of all global and static variables exist for the entire duration of the middlebox's execution, so these variables are always persistent.
Variables local to the loop-procedure 񮽙 -i.e., the procedure containing the packet processing loop-exist for the duration of this procedure, and hence the duration of the packet processing loop, so they are also persistent.Local variables of procedures that precede the loopprocedure on the call stack are also persistent, because the procedures' stack frames last longer than the packet processing loop.
However, these variables cannot be used 񮽙 To automatically detect packet processing loops, we use the fact that middleboxes read packets using standard library/system functions.
within the packet processing loop, or a procedure called therein, because the variables are out of scope. 񮽙
us we exclude these from our list of persistent variables, improving precision.񮽙
e above analysis implicitly considers heap-allocated values by considering the values of global, static, and local variables, which can point to values on the heap.
Values on the heap exist until they are explicitly freed (or the middlebox terminates), but their usable lifetime is lim- ited to the time frame in which they are reachable from a variable's value. 񮽙 񮽙
erefore, we can conclude that a heapallocated value's persistence is predicated on the persistence of a variable identiied by our algorithm. 񮽙
e above algorithm identiies a superset of variables that may be bound, or point, to per-/cross--ow state.
It includes variables bound to state used in initialization for loading/processing connguration/signature les: e.g., variables intPcap and extPcap in Figure .
Such variables don't need handling during trac redistribution; they can simply be copied when an instance is launched.To eliminate such variables and improve precision, the key insight we leverage is that, by deenition, per-/crossow state is used in some way during packet processing.
However, identifying all such variables is non-trivial, and missing variables impact analysis soundness.
Figure shows our algorithm for identifying top-level variables that contain or refer to per-/cross--ow values. 񮽙
e rst half of the algorithm (lines --) focuses on identifying packet processing code.
Obviously any code contained in the packet processing loop is used for processing packets, but, crucially, the code of procedures (indirectly) called from within the loop is also packet processing code. 񮽙
A heap value whose lifetime is longer than its usable lifetime is a memory leak.We considered a strawman approach of using call graphs to identify packet processing procedure.
A call graph is constructed by starting at each procedure call within the packet processing loop, and classifying each appearing procedure as a packet processing procedure.
However, this analysis does not capture packet processing procedures that are called indirectly. 񮽙
e Squid proxy, e.g., does initial processing of the received packet, then enqueues an event to trigger further processing through later calls to additional procedures.
Hence the analysis may incorrectly eliminate some legitimate per-/crossow state which is used in such procedures.񮽙
us, we need an approach that exhaustively considers the dependencies between the receipt of a packet and both direct and indirect invocations of packet processing procedures.
Below, we show how system dependence graphs [[] and program slicing [[[] can be used for this.A system dependence graph (SDG) consists of multiple program dependence graphs (PDGs) -one for each procedure.
Each PDG contains vertices for each statement along with their data and control dependency edges.
A data dependence edge is created between statements p and q if there is an execution path between them, and p may update the value of some variable that q reads.
A control dependence edge is created if p is a conditional statement, and whether or not q executes depends on p.
A snippet of the control and data edges for our example in Figure is in Figure .
Whereas control edges capture direct invocations of packet processing, we can rely on data edges to capture indirect procedure calls.
For example, the dashed yellow lines in Figure fail to capture invocation of the processPacket procedure on bottom right (because there is no control edge from the while loop or any of its subsequent procedures to processPacket).
In contrast, we can follow the data edges, the dashed red line, to track such calls.Given a middlebox's SDG, we compute a forward program slice from a packet receive function call for the variable which stores the received packet.
A forward slice contains the set of statements that are aected by the value of a variable starting from a speciic point in the pro-gram [[[].
Most middleboxes use standard library/system functions to receive packets-e.g., pcap next, or recvso we can easily identify these calls and the variable pointing to the received packet.
We consider any procedure appearing in the computed slice to be a packet processing procedure.
For middleboxes which invoke packet receive functions at multiple points, we compute forward slices from every call site and take the union of the procedures appearing in all such slices.
Values Used in Packet Processing Procedures. 񮽙
e second half of our algorithm ( Figure , packet processing procedure.
We analyze each statement in the packet processing procedures.
If the statement contains a persistent variable, then we mark that persistent variable as a top-level variable.
Next, we delineate updateable top-level variables from read only variables to further improve precision.
In Fig- ure , variable head, tail, hosts and queue are updateable, whereas threshold is not.
Because state is updated through assignment statements, one strawman choice here is to statically identify top-level variables on the lee-hand-side (LHS) of assignment statements.
In Figure , this identiies head, hosts and queue.However, this falls short due to aliasing, where multiple variables are bound to the same storage location due to the use of pointers [[[].
Aliasing allows a value reachable from a top-level variable to be updated through the use of a diierent variable. 񮽙
us our strawman can mis-label top-level variables as read-only, compromising soundness.
For example, tail is mislabeled in Figure , because it never appears on the LHS of assignment statements.
But on line index is updated which points to tail.
Analysis Algorithm.
We develop an algorithm to identify updateable top-level variable (Figure ).
Since we are concerned with variables whose (referenced) values are updated during packet processing, we analyze each assignment statement contained in the packet process- If the assignment statement's LHS contains a top-level variable, then we mark the variable as updateable (similar to our strawman).
Otherwise, we compute the points-to set for the variable on the LHS and compare this with the set of updateable top-level variables and their points-to sets.
A variable's points-to set contains all variables whose associated storage locations are reachable from the variable.
To compute this set, we employ ow-, context-, and eld-insensitive pointer analysis [[].
If the points-to set of the variable on the LHS contains a top-level variable, or has a non-null intersection with the points-to set of a top-level variable, then we mark the toplevel variable as updateable.Due to limitations of pointer analysis, our algorithm may still mark read-only top-level variables as updateable.
E.g., eld insensitive pointer analysis can mark a top-level struct variable as updateable even if just one of its subelds is updateable.
Finally, we identify the packet header elds that deene the owspace associated with the values of each top-level variable.
Identifying too ne-grained of a owspace for a value-i.e., more header elds than those that actually deene the owspace-is unsound; such an error will cause a middlebox to incorrectly lter out the value when it is requested by a middlebox state management framework [[ [, , , ].
Contrarily, assuming an overly permissive owspace (e.g., the entire owspace) for a value hurts precision.To Algorithm.
We leverage the above design patterns in our algorithm shown in Figure .
In the rst step (lines -), if the top-level variable is a struct or a pointer, we mark it as a possible candidate for having a owspace associated with it. 񮽙
is lters out all the top-level variables which cannot represent more than one entry; e.g., variables head and tail in Figure .
We assume that middleboxes use hash tables or linked lists to organize their values, 񮽙 and that these data structures are accessed using: square brackets, e.g. entry = table [index]; pointer arithmetic, e.g. entry = head + offset; or iteration 񮽙 , e.g. while(entry->next!
=null){entry=entry->next;} for(i=0; i<list.length; i++) {...} 񮽙e second step is thus to identify all statements like these where a top-level variable marked above is on the right-hand-side (RHS) of the statement (square brackets or pointer arithmetic scenario) or in the conditional mapping between such keys and packet header elds 񮽙 Our approach can easily be extended to other data structures. 񮽙
Middleboxes may also use recursion, but we have not found this access pattern in the middleboxes we study, so we do not consider it in our algorithm.
expression (iteration scenario).
When square brackets or pointer arithmetic are used, we compute a chop between the variables in the access statement and the variable containing the packet returned by the packet receive procedure.
A chop between a set of variables U at program point p and a set of variables V at program point q is the set of statements that (i) may be aected by the value of variables in U at point p, and (ii) may aect the values of variables in V at point q. 񮽙us, the chop we compute above is a snippet of executable code which takes a packet as input and outputs the index or oset required to extract the value from the hashtable.In a similar fashion, when iteration is used, we identify all conditional statements in the body of the loop.
We compute a chop between the packet returned by the packet receive procedure and the set of all the variables in the conditional expression which do not point to any of the top-level variables; in our example ( Figure ), the chop starts at line and terminates at line .
We output the resulting chops, which collectively contain all conditional statements that are required to lookup a value in a linked list data structure based on a ow space deenition.
Assuming that the middlebox accesses packet elds using standard system-provided structs (e.g., struct ip as deened in netinet/ip.h), we conduct simple string matching on the code snippets to produce a list of packet header elds that deene a state's owspace.
Data and control ow analysis can help improve precision, but they have some limitations in that they cannot guarantee that exactly the relevant state and nothing else has been identiied.
In particular, static analysis cannot diierentiate between multiple memory regions that are allocated through separate invocations of malloc from the same call site. 񮽙
erefore, we cannot statically determine if only a subset of these memory regions have been updated aer processing a set of packets.
To overcome potential eeciency loss due to such limitations, we can employ custom algorithms that boost precision in speciic settings.
We present two candidates below.
In addition to the three main code blocks (Figure ), middleboxes may optionally have packet and log output functions. 񮽙
ese pass a packet to the kernel for forwarding and record the middlebox's observations and actions in a log le, respectively. 񮽙
ese functions are usually called from within the packet processing procedure(s).
In some cases, operators may desire output equivalence only for speciic types of output.
For example, an operator may want to ensure client connections are not broken when a NAT fails-i.e., packet output should be equivalent-but may not care if the log of NAT' d connec-tions is accurate.
In such cases, internal state that only impacts non-essential forms of output does not need special handling during redistribution and can be ignored.To aid such optimizations, we develop an algorithm to identify the type of output that updateable state aects.
We use two key insights.
First, middleboxes typically use standard libraries and system calls to produce packet and log output: either PCAP (e.g. pcap dump) or socket (e.g. send) functions for the former, and regular I/O functions (e.g. write) for the latter. 񮽙
Second, the output produced by these functions can only be impacted by a handful of parameters passed to these functions. 񮽙
us, we focus on the call sites of these functions, and their parameters.
Algorithm.
We use program slicing [[[] to identify the dependencies between a speciic type of output and updateable variables.
We sketch the algorithm and relegate details to Appendix A.
We rst identify the call sites of packet or log output functions by checking each statement in each packet processing procedure ( § §....). 񮽙
en we use the SDG produced in the rst stage of our analysis ( Figure ) to compute a backward slice from each call site.
Such a slice contains the set of statements that aect (i) whether the procedure call is executed, and (ii) the value of the variables used in the procedure call, such as the parameters passed to the output function.
We examine each statement in a backward slice to determine whether it contains an updateable per-/cross--ow variable.
Such variables are marked as impacting packet (or log) output.
Developers aiming to design fault-tolerant middleboxes can use the algorithms in § § and § §.
.
to eeciently clone state to backup instances.
For example, if trac will be distributed among multiple instances in the case of failure, then only state whose owspace overlaps with that assigned to a speciic instance needs to be cloned to that instance.
However, the potential performance gains from these optimizations may be limited due to constraints imposed by data/control--ow analysis.
For example, our analysis can only identify whether a persistent variable's value may be updated during the middlebox's execution.
If we can determine at runtime exactly which values are updated, and when, then we can further improve the eeciency of state cloning and speed up failover.To achieve higher precision, we must use (simple) run time monitoring.
For example, we can track, at run time, whether part of an object is updated during packet processing.
To implement this monitoring, we must modify the middlebox to set an "updated bit" whenever a value reachable from a top-level variable is updated during packet processing.
Figure a shows such modiications, in red, for a simple middlebox.
We create a unique 񮽙 Our approach can be easily extended to consider non-standard output functions.
S->acknum = t->ackum{ } { 2} { 2,0} { 2} { 2,0} { 2,0} exit { 2,0} { 2,0} { 2,0}(b) Annotated control ow graph used for pruning redundant updated-bit-setting (shaded) statements Figure : Implementing update tracking at run time updated bit for each top-level variable-there are three such variables in the example-and we set the appropriate bit before any statement that updates a value that may be reachable from the corresponding variable.
We use the same analysis discussed in § §.
.
to determine where to insert statements to set updated bits.
For any statement where a top-level variable is updated, we insert a statement-just prior to the assignment statement-that sets the appropriate updated bit.However, this approach can add a lot more code than needed: if one assignment statement always executes before another, and they always update the same value, then we only need to set the updated bit before the erst assignment statement.
For example, line in Figure a updates the same compound value as line , so the code on line is redundant.
We use a straightforward control ow analysis to prune unneeded updated-bit-setting statements.
First, we construct a control ow graph (CFG) for each modiied packet processing procedure.
Next, we perform a depthrst traversal of each CFG, tracking the set of updated bits that have been set along the path; as we traverse each edge, we label it with the current set of updated bits.
Lastly, for each updated-bit-setting statement in a procedure's CFG, we check whether the bit being set is included in the label for every incoming edge.
If this is true, then we prune the statement; e.g., we prune line in Figure a.
We implement StateAlyzr using CodeSurfer [[] which has built-in support for constructing CFGs, performing ow-and context-insensitive pointer analysis, constructing PDGs/SDGs, and computing forward/backward slices and chops for C/C++ code.
CodeSufer uses proven sound algorithms to implement these static analysis techniques.
We use CodeSurfer's Scheme API to access output from these analyses in our algorithms.
We Fault Tolerance.
We use the output from StateAlyzr to add fault tolerance to PRADS and Snort, both o-path middleboxes.
We added code to both to export/import internal state (to a standby).
We used the output of our rst two analysis phases ( § §.
.
and § §.
.)
to know which top level variables' values we need to export, and where in a hot-standby we should store them.
We used the output of our third analysis phase ( § §.
.)
as the basis for code that looks up per-/cross--ow state values. 񮽙
is code takes a owspace as input and returns an array of serialized values.
We use OpenNF [[[] to transfer serialized values to a hot-standby.
Similarly, import code deserializes the state and stores it in the appropriate location.
We also implemented both enhancements discussed in § §.
We report on the outcomes of applying StateAlyzr to four middleboxes.
We address the following questions:• Eectiveness: Does StateAlyzr help with making modiications to today's middleboxes?
How many toplevel variables do these middleboxes maintain, relative to all variables?
What relative fractions of these pertain to state that may need to be handled during redistribution?
How precise is StateAlyzr?
• Runtime eeciency and manual eeort: To what extent do StateAlyzr's mechanisms help improve the runtime eeciency of state redistribution?
How much manual eeort does it save?
• Practical considerations: Does StateAlyzr take prohibitively long to run (like symbolic execution; § §.
.)
?
Is it sound in practice?
.
In Table , we present a variety of key statistics derived for the four middleboxes using StateAlyzr.
We use this to highlight StateAlyzr's ability to improve precision, thereby underscoring its usefulness for developers. 񮽙
e complexity of middlebox code is underscored by the overall number of variables in between and k, and other relevant code complexity metrics shown in Table . 񮽙
us, manually identifying state that needs handling, and optimizing its transfer, is extremely diicult.
We also note from Table that 񮽙e drastic reduction to the nal number of updateable variables shows that naive approaches that attempt to transfer/clone values corresponding to all variables can be very ineecient at runtime.
(We show this empirically in § §...) Even so, the number of updateable variables can be as high as , and attempting to manually identify them and argument code suitably can be very diicult.
By automatically identifying them, StateAlyzr simpliies modications; we provide further details in § §...Finally, the reductions we observe in going from persistent variables to top-level variables (((----reduction) and further to updateable ones ( (--reduction) show that our techniques in § §.
.
and § §.
.
oer useful improvements in precision.In Figure , we characterize the owspaces for the variables found in Snort and PRADS.
From the lee gure, we see that Snort maintains state objects that could be keyed by as many as s or r header relds; the maximum number of such elds for PRADS is . 񮽙
e gure on the right shows the number of variables that use a particular number of header elds as owspace keys; for instance, in the case of Snort, variables each are keyed on n and d elds. 񮽙
e total number of variables keyed on at least one key is and for Snort and PRADS, respectively (sum of the heights of the respective bars).񮽙
ese numbers are signiicantly lower than the updateable variables we discovered for these middleboxes (( and , respectively).
Digging deeper into Snort (for example) we nd that: • updateable variables pertain to all ows (i.e., a owspace key of "*").
Of these, variables are related to conngurations and signatures, while are function pointers (that point to diierent detection and processing plugins). 񮽙
ese variables can be updated from the command line at middlebox run time (when an operator provides new conngurations and signatures, or new analysis plugins).
• updateable variables-or -are only used for processing a single packet; hence they don't correspond to per-/cross--ow state. 񮽙
is points to StateAlyzr's imperfect precision. 񮽙
ese variables are global in scope and are used by diierent functions for processing a single incoming packet, which is why our analysis labels them as updateable.
A developer can easily identify these variables and can either remove them from the list of updateable variables or modify code to make them local in scope.
.
Runtime eciency and manual eort Using fault tolerant PRADS/Snort versions ( § §), we show that StateAlyzr helps signiicantly cut unneeded state transfers, improving state operation time/overhead.
Man-hours needed.
Modifying PRADS based on StateAlyzr analysis took roughly man-hours, down from over man-hours when we originally modiied PRADS for OpenNF (Two diierent persons made these modiications.)
.
Modifying Snort, a much more complex middlebox, took man-hours.
In both cases, most of the time ( ) was spent in writing serialization code for the data structures identiied by StateAlyzr (( for PRADS and for Snort; Table ).
Providing support for exporting/importing state objects according to OpenNF APIs took just t and d hours, respectively.
Runtime benets.
We consider a primary/hot standby setup, where the primary sends a copy of the state to the hot standby aer processing each packet.
We use a university-to-cloud packet trace [[] with around k packets for our trace-based evaluation of this setup. 񮽙
e primary instance processes the rst half of the trace le until a random point, and the hot standby takes over after that.
We consider three models for operating the hot standby which reeect progressive application of the different optimizations in § § and § §: (i) the primary instance sends a copy of all the updateable states to the hot standby, (ii) the primary instance only sends the state which applies to the owspace of the last processed packet, and (iii) in addition to considering the owspace, we also consider which top level variables are marked as updated for the last processed packet.
Figure a shows the average case results for the amount of per packet data transferred between the primary and secondary instances for all three models for PRADS.
Transferring state which only applies to the owspace of the last processed packet, i.e., the second model, reduces the data transferred by compared to transferring all per-/cross--ow state.
Furthermore, we nd that the third model, i.e., run time marking of updated state variables, further reduces the amount of data transferred by , on average. 񮽙
is is because not all values are updated for every packet: the values pertaining to a speciic connection are updated for every packet of that connection, but the values pertaining to a particular host and its services are only updated when processing certain packets. 񮽙
is behavior is illustrated in Figure b, which shows the size of the state transfer aer processing each of the rst packets in a randomly selected ow.We measured the increase in per packet processing time purely due to the code instrumentation needed to identify state updates for highly available PRADS.
We observed an average increase of .
.
µsec, which is around .
.
of the average per packet processing time for unmodiied PRADS.Figure shows the corresponding results for Snort.
Transferring just the updateable state results in a reduction in the amount of state transferred compared to transferring all per-/cross--ow state. 񮽙
is is because, a signiicant portion of the persistent state in Snort consists of connguration and signatures which are never updated during packet processing.
Transferring state which only applies to a particular owspace further reduces the data transfer by .
.
.
Unlike PRADS, the amount of state transfer in the second model remains constant for a particular row because most of the state is created on the erst few packets of a ow.
Finally, runtime marking further reduces the amount of state transferred by .
.
.
Table includes the number of variables that impact packet or log output.
For on-path HAproxy (OpenVPN), (((() of updateable variables aect packet output; a slightly higher fraction impact log output.
(() variables impact both outputs.
A much smaller number impacts packet output but not log ( ( and , respectively).
Another handful impact logs but not packets (( and ); operators who are interested in just packet output consistency can ignore transferring the state pertaining to these variables, but the beneet will likely not be signiicant for Being o-path, PRADS and Snort have no variables that impact packet output.
For PRADS, out of updateable variables impact log output.
StateAlyzr did nd other updateable variables-tos, tstamp, in pkt, and mtu-but did not mark them as aecting packet output or log output.
Upon manual code inspection we found that these values are updated as packets are processed, but they are never used; thus, these variables can be removed from PRADS without any impact on its output, pointing to another beneet of StateAlyzr-code clean-up.
Table shows the time and resources required to run our analysis.
CodeSurfer computes data and control dependencies and points-to sets at compile time, so the middleboxes take longer than normal to compile. 񮽙
is phase is also memory intensive, as illustrated by peak memory usage.
Snort, being complex, takes the longest to compile and analyze ( 񮽙񮽙.
.
h). 񮽙
is is not a concern since StateAlyzr only needs to be run once, and it runs oine.
Empirically showing soundness in practice is hard.
Nevertheless, for the sake of completeness, we use two approaches to verify soundness of the modiications we make on the basis of StateAlyzr's outputs.First, we use the experimental harness from § §... We compare logs at PRADS/Snort in the scenario where a single instance processes the complete trace le against concatenated logs of the primary and hot standby, using the trace and the three models as above.
In all cases, there was no diierence in the two sets of logs.Next, we compare with manually making all changes.
Recall that we had manually modied PRADS to make it OpenNF-compliant.
We compared StateAlyzr's output for PRADS against the variables contained in the state transfer code we added during our prior modiications to PRADS.
StateAlyzr found all variables we had considered in our prior modiications, and more.
Speciically, we found that our prior modiications had missed an important compound value that contains a few counters along with connguration settings.
Aside from the works discussed in § § and § § [[, , , , , , , , , ] StateAlyzr is related to a few other eeorts.
Some prior studies have focused on transforming non-distributed applications into distributed applications [[, ].
However, these works aim to run diierent parts of an application at diierent locations.
We want all analysis steps performed by a middlebox instance to run at one location, but we want diierent instances to run on a diierent set of inputs without changing the collective output from all instances.
Our goal was to aid middlebox developers by identifying state objects that need explicit handling during redistribution operations.
In comparison with today's manual and necessarily error-prone techniques, our program analysis based system, StateAlyzr, vastly simpliies this process, and ensures soundness and high precision.
Key to StateAlyzr is novel state characterization algorithms that marry standard program analysis tools with middlebox structure and design patterns.
StateAlyzr results in nearly reduction in manual eeort, and can automatically eliminate nearly of variables in middlebox code for consideration during framework-speciic modiications, resulting in dramatic performance and overhead improvements in state reallocation.
Ultimately, we would like to fully automate the process of making middlebox code framework-compliant, thus fulllling the promise of using NFV eeectively for middlebox elasticity and fault tolerance.
Our work addresses basic challenges in code analysis, a diicult problem on its own which is necessary to solve rst.
Proof.
For a procedure to perform packet processing: (i) there must be a packet to process, and (ii) the procedure must have access to the packet, or access to values derived from the packet. 񮽙
e former is true only aer a packet receive function returns. 񮽙
e latter is true only if some variable in a procedure has a data dependency on the received packet. 񮽙
erefore, a forward slice computed from a packet receive function over the variable containing (a pointer to) the packet will identify all packet processing procedures.񮽙
eorem .
If a value is per-/cross--ow state, then our analysis outputs a top-level variable containing this value, or containing a reference from which the value can be reached (through arbitrarily many dereferences).
Proof.
Assume no top-level variable is identiied for a particular per-/cross--ow value.
By the deenition, a per-/cross--ow must (i) have a lifetime longer than the lifetime of any packet processing procedure, and (ii) be used within some packet processing procedure.
For a value to be used within a packet processing procedure, it must be the value of, or be a value reachable from the value of, a variable that is in scope in that procedure.
Only global variables and the procedure's local variables will be in scope.Since we identify statements in packet processing procedures that use global variables, and points-to analysis is sound [[], our analysis must identify a global variable used to access/update the value; this contradicts our assumption.񮽙
is leaves the case where a local variable is used to access/update the value.
When the procedure returns the variable's value will be destroyed.
If the variable's value was the per-/cross--ow value, then the value will be destroyed and cannot have a lifetime beyond the packet processing procedure; this is a contradiction.
If the variable's value was a reference through which the per-/cross--ow value could be reached, then this reference will be destroyed when the procedure returns.
Assuming a value's lifetime ends when there are no longer any references to it, the only way for the per-/cross--ow value to have a lifetime beyond any packet processing procedure is for it be reached through another reference. 񮽙
e only such reference that can exist is through a top-level variable.
Since points-to analysis is sound [[] this variable would have been identiied, which contradicts our assumption. 񮽙
eorem .
If a top-level variable's value, or a value reachable through arbitrarily many dereferences starting from this value, may be updated during the lifetime of some packet processing procedure, then our analysis marks this top-level variable as updateable.Proof.
According to the language semantics, scalar and compound values can only be updated via assignment statements.
According to 񮽙eorem , we identify all packet processing procedures. 񮽙
erefore, identifying all assignment statements in these procedures is suucient to We thank our shepherd, Mona Attariyan, and the anonymous reviewers for their insightful feedback. 񮽙
is work is supported in part by National Science Foundation (grants CNS--, CNS--and CNS--) and the Wisconsin Institute on Soware-Deened Datacenters of Madison.
x A. Output-Impacting State -AlgorithmFigure outlines the algorithm for identifying state that impacts packet/log output (from § §.
.)
.
identify all possible value updates that may occur during the lifetime of some packet processing procedure.񮽙
e language semantics also state that the variable on the lee-hand-side of an assignment is the variable whose value is updated. 񮽙
us, when a top-level variable appears on the lee-hand-side of an assignment, we know its value, or a reachable value, is updated.
Furthermore, ow-insensitive context-insensitive pointer alias is provably guaranteed to identify all possible points-to relationships [[]. 񮽙
erefore, any assignment to a variable that may point to a value also pointed to (indirectly) by a top-level variable is identiied, and the top-level variable marked updateable.
source variables (i.e., the packet variable) and target variables (i.e., the index variable, increment variable, or variable in a conditional inside a loop) will be included in the chop.
IdentifyingIdentifying Output-Impacting State 񮽙eorem .
If a top-level variable's value, or a value reachable through arbitrarily many dereferences starting from this value, may aect a call to a packet output function or the output produced by the function, then our analysis marks this top-level variable as impacting packet output.Proof.
Follows from SDG construction soundness [[, ].
If/when a packet output function is called is determined by a sequence of conditional statements. 񮽙
e path taken at each conditional depends on the values used in the condition.
Control and data dependency edges in a system dependence graph capture these features.
Since SDG construction is sound [[, ], we will identify all such dependencies, and thus all values that may aect a call to a packet output function.Only parameter values, or values reachable through arbitrarily many dereferences starting from these values, can aect the output produced by a packet output function. 񮽙
us, knowing what values a parameter value depends on is suucient to know what values aect the output produced by an output function.
Again, since SDG construction is sound, we will identify all such dependencies.
Figure outlines the algorithm for identifying state that impacts packet/log output (from § §.
.)
.
identify all possible value updates that may occur during the lifetime of some packet processing procedure.񮽙
e language semantics also state that the variable on the lee-hand-side of an assignment is the variable whose value is updated. 񮽙
us, when a top-level variable appears on the lee-hand-side of an assignment, we know its value, or a reachable value, is updated.
Furthermore, ow-insensitive context-insensitive pointer alias is provably guaranteed to identify all possible points-to relationships [[]. 񮽙
erefore, any assignment to a variable that may point to a value also pointed to (indirectly) by a top-level variable is identiied, and the top-level variable marked updateable.
source variables (i.e., the packet variable) and target variables (i.e., the index variable, increment variable, or variable in a conditional inside a loop) will be included in the chop.
Identifying Output-Impacting State 񮽙eorem .
If a top-level variable's value, or a value reachable through arbitrarily many dereferences starting from this value, may aect a call to a packet output function or the output produced by the function, then our analysis marks this top-level variable as impacting packet output.Proof.
Follows from SDG construction soundness [[, ].
If/when a packet output function is called is determined by a sequence of conditional statements. 񮽙
e path taken at each conditional depends on the values used in the condition.
Control and data dependency edges in a system dependence graph capture these features.
Since SDG construction is sound [[, ], we will identify all such dependencies, and thus all values that may aect a call to a packet output function.Only parameter values, or values reachable through arbitrarily many dereferences starting from these values, can aect the output produced by a packet output function. 񮽙
us, knowing what values a parameter value depends on is suucient to know what values aect the output produced by an output function.
Again, since SDG construction is sound, we will identify all such dependencies.
