The fabrication of digital Integrated Circuits (ICs) is increasingly outsourced.
Given this trend, security is recognized as an important issue.
The threat agent is an attacker at the IC foundry that has information about the circuit and inserts covert, malicious circuitry.
The use of 3D IC technology has been suggested as a possible technique to counter this threat.
However, to our knowledge, there is no prior work on how such technology can be used effectively.
We propose a way to use 3D IC technology for security in this context.
Specifically, we ob-fuscate the circuit by lifting wires to a trusted tier, which is fabricated separately.
This is referred to as split manufacturing.
For this setting, we provide a precise notion of security, that we call k-security, and a characterization of the underlying computational problems and their complexity.
We further propose a concrete approach for identifying sets of wires to be lifted, and the corresponding security they provide.
We conclude with a comprehensive empirical assessment with benchmark circuits that highlights the security versus cost trade-offs introduced by 3D IC based circuit obfuscation.
The security of digital integrated circuits (ICs), the building blocks of modern computer hardware systems, can be compromised by covertly inserted malicious circuits.
The threat from such maliciously inserted hardware is of increasing concern to government and military agencies [2] and commercial semiconductor vendors.
Recently, Skorobogatov et al. [28] demonstrated the presence of a backdoor in a military grade FPGA manufactured by Actel that enabled access to configuration data on the chip.
The authors initially conjectured that the backdoor was maliciously inserted since the key used to trigger the backdoor was undocumented.
Actel has since clarified that the backdoor was inserted by design for internal test purposes [23].
Nonetheless, this incident has further heightened the perceived threat from maliciously inserted hardware, and effective counter-measures to deter or prevent such attacks are of increasing importance.The threat of maliciously inserted hardware arises from two factors.
First, owing to their complexity, digital ICs are designed at sites across the world.
In addition, parts of the design are often outsourced or purchased from external vendors.
Second, a majority of semiconductor design companies are fabless, i.e., they outsource IC manufacturing to a potentially untrusted external fabrication facility (or foundry).
Both factors make it easier for a malicious attacker in a design team or a malicious foundry (or a collusion between the two) to insert covert circuitry in a digital IC.Three-dimensional (3D) integration, an emerging IC manufacturing technology, is a promising technique to enhance the security of computer hardware.
A 3D IC consists of two or more independently manufactured ICs that are vertically stacked on top of each other -each IC in the stack is referred to as a tier.
Interconnections between the tiers are accomplished using vertical metal pillars referred to as through-silicon vias (TSV).3D IC manufacturing can potentially enhance hardware security since each tier can be manufactured in a separate IC foundry, and vertically stacked in a secure facility.
Thus, a malicious attacker at any one foundry has an incomplete view of the entire circuit, reducing the attacker's ability to alter the circuit functionality in a desired manner.Tezarron, a leading commercial provider of 3D stacking capabilities, has alluded to the enhanced security offered by 3D integration in a white paper [1].
The white paper notes that "A multi-layer circuit may be divided among the layers in such a way that the function of each layer becomes obscure.
Assuming that the TSV connections are extremely fine and abundant, elements can be scattered among the layers in apparently random fashion."
However, the paper does not provide any formal Figure 1: A two tier 3D IC.
In this instance, the top tier is an interposer, i.e., it only implements metal wires, while the bottom tier has both transistors/gates and wires.
notion of security for split manufacturing, nor does it propose techniques to quantify security or achieve a certain security level.
These are the open challenges that we address in this paper.Our threat model assumes a malicious attacker in an IC foundry who wants to modify the functionality of a digital IC in a specific, targeted manner.
The attack proposed by King et al. [19] modifies the state of hardware registers in a processor to raise the privilege level of the attacker -this is an example of a targeted attack since it requires the attacker to determine the gate or wire in the circuit that corresponds to the privilege bit.
Fault insertion attacks in cryptographic hardware also require that certain vulnerable bits be targeted.
For example, it has been shown that if the LSB bit of the 14 th round of a DES implementation is set to logic zero, the secret key can be recovered in as few as two messages [9].
However, to succeed, the attacker must be able to determine which gate corresponds to the LSB bit of the 14 th round.To effect a targeted attack, an attacker must first identify specific logic gates or wires in the circuit that implement the functionality that he wants to monitor and/or modify; for example, the gate or wire that corresponds to the privilege bit for the privilege escalation attack proposed in [19].
A malicious foundry can identify the functionality of every gate and wire in the circuit if it gets to fabricate the entire chip, i.e., if a conventional planar, 2D fabrication process is used.
On the other hand, as we show in this paper, 3D integration significantly reduces the ability of an attacker in a malicious foundry to correctly identify gates or wires in the circuit that he wants to attack.The specific 3D integration technology that we exploit in this work, since it is the only one that is currently in large volume commercial production [8], splits a design into two tiers.
The bottom tier consists of digital logic gates and metal wires used to interconnect logic gates.
The top tier, also referred to as an interposer, only consists of metal wires that provide additional connections between logic gates on the bottom tier.The bottom tier -this tier is expensive to fabricate since it implements active transistor devices and passive metal -is sent to an external, untrusted foundry for fabrication.
This is referred to as the untrusted tier.
The top tier implements only passive metal and can be fabricated at lower cost in a trusted fabrication facility.
We refer to this tier as the trusted tier.Assume, for the sake of argument, that all interconnections between logic gates are implemented on the trusted tier, the attacker (who only has access to the untrusted tier) observes only a "sea" of disconnected digital logic gates.
From the perspective of the attacker, gates of the same type, for example all NAND gates, are therefore indistinguishable from each other.
(Assuming that the relative size or placement of gates reveals no information about interconnections between gates.
This is addressed in Section 4.)
Assume also that the attacker wants to attack a specific NAND gate in the circuit, and not just any NAND gate.
The attacker now has two choices: (a) the attacker could randomly pick one NAND gate to attack from the set of indistinguishable NAND gates, and only succeed in the attack with a certain probability; or (b) the attacker could attack all indistinguishable NAND gates, primarily in cases where the attacker wants to monitor but not modify gates in the circuit, at the expense of a larger malicious circuit and thus, an increased likelihood of the attack being detected.
In either instance, the attacker's ability to effect a malicious, targeted attack on the circuit is significantly hindered.
We refer to this technique as circuit obfuscation.In general, we define a k-secure gate as one that, from the attacker's perspective, cannot be distinguished from k − 1 other gates in the circuit.
Furthermore, a k-secure circuit is defined as one in which each gate is at least k-secure.
Contributions We make the following contributions:• We propose a concrete way of leveraging 3D IC technology to secure digital ICs from an active attacker at the foundry.
Whereas the use of 3D IC technology for security has been alluded to before, we are not aware of prior work like ours that discusses how it can be used meaningfully.
• We propose a formal notion of security in this context that we call k-security.
We give a precise characterization of the underlying technical problemscomputing k-security and deciding which wires to lift -and identify their computational complexity.
• We have devised a concrete approach to addressing the problem of lifting wires, which comprises a greedy heuristic to identify a candidate set of wires to be lifted, and the use of a constraint (SAT) solver to compute k-security.
• We have conducted a thorough empirical assessment of our approach on benchmark circuits, including a case-study of a DES circuit, that illustrates the inability of an attacker to effectively attack circuits secured using 3D IC based obfuscation.
In this section, we overview the IC manufacturing process in the specific context of 3D integration, and discuss the attack model that we assume in this paper.
We also discuss related work on hardware security including both attacks and countermeasures, and on the use 3D integration for enhancing the security of computer hardware.
Digital ICs consist of a network of inter-connected digital logic gates.
This network of gates is often referred to as a netlist.
Digital logic gates are built using complementary metal-oxide-semiconductor (CMOS) transistors.
In a conventional planar/2D IC, CMOS transistors, and by extension digital logic gates, lie in a single layer of silicon.
In addition, there are several layers of metal wires used to inter-connect the gates.3D integration enables the vertical stacking of two or more planar ICs.
Each IC in the vertical stack is referred to as a tier.
Vertical interconnects (TSVs) are provided to allow the transistors and metal wires in each tier to connect to each other.The initial motivation for 3D integration came from the potential reduction in the average distance between logic gates -in a 3D IC, the third, vertical dimension can be used to achieve a tighter packing of logic gates [6].
However, a number of issues, including high power density, temperature and cost, have plagued high volume, commercial availability of logic-on-logic 3D ICs [13].
A more practical 3D IC technology that has been demonstrated in a commercial product (a Xilinx FPGA [8]) is shown in Figure 1.
It consists of two tiers.
The bottom tier contains both transistors/gates and metal wires, while the top tier, the interposer, contains only metal wires.
The two tiers are interfaced using uniformly spaced metallic bond-points.
TSVs make use of these bond-points to provide connections between wires in the top and bottom tiers.
This technology has also been referred to as 2.5D integration [14].
In the rest of this paper, we use 3D instead of 2.5D since our techniques can easily be generalized to full 3D.
Since the bottom tier consists of CMOS transistors, it is fabricated at one of the few foundries worldwide with advanced lithographic capabilities at high cost.
The top tier, i.e., the interposer, only contains passive metal and can be fabricated at significantly reduced cost [21].
Figure 2 shows a 3D IC design flow with appropriate modifications for security.
The design flow begins with the design specified using a hardware description language (HDL), which is then synthesized to a netlist of gates.
The types of gates allowed in the gate netlist are specified in a technology library.In the wire lifting stage, the edges (or wires) in the netlist that are to be implemented on the top tier are selected.
These are referred to as lifted wires.
The rest of the netlist, implemented on the bottom tier, is referred to as the unlifted netlist and consists of unlifted gates and unlifted wires.The unlifted gates are then placed on the surface of the bottom tier, i.e., the (x, y) co-ordinates for each gate are selected.
Unlifted wires are routed using the bottom tier metal layers.
Two bond-points are selected for every lifted wire; one each for the two gates that the wire connects.
The gates are connected to the corresponding bond-points.
Finally, lifted wires are routed between pairs of bond-points in the top tier using the top tier routing resources.Finally, the two tiers are fabricated at separate foundries.
The chips from the two foundries are vertically stacked to create the final 3D IC chip that is shipped to the vendor.We now discuss the attack model that we address in this paper, in the context of the 3D design and fabrication flow outlined above.
The attack model that we address in this paper is that of a malicious attacker in the foundry.
This attack model has been commonly used in the hardware security literature because of the serious threat it presents [18].
We further strengthen the attack by assuming a malicious observer in the design stage, working in collusion with the malicious attacker in the foundry.
1 The malicious observer has full knowledge of the circuit as it goes through the design process, but can not effect any changes.
The malicious attacker in the foundry can, on the other hand, effect changes in the circuit layout before the chip is fabricated.To defend against this attack, the following steps of the design and fabrication flow are assumed to be secure, i.e., executed by a trusted party: (a) the wire lifting, placement and routing steps in the design, and (b) the fabrication of the top tier (therefore also referred to as the trusted tier).
Three aspects of the attack and defense models deserve further mention.
First, we note that the attack model described above subsumes a number of other practically feasible attack models.
It is stronger than a malicious attacker in the foundry working by himself.
It is also stronger than a malicious attacker in the foundry with partial design knowledge -for example, the attacker is likely to know the functionality and input/output behaviour of circuit he is attacking (an ALU or a DES encryption circuit, etc.).
Providing the attacker with the precise circuit netlist can only strengthen the attack.Second, the steps in the design and fabrication process that are assumed to be trusted are also relatively easy to perform in a secure manner, compared to the untrusted steps.
Wire lifting and placement/routing (in the design stage) are performed using automated software tools, the former based on algorithms that we propose in this paper, and the latter using commercially available software from electronic design automation (EDA) vendors.
In comparison, writing the HDL code is manually intensive, time-consuming and costly.
Furthermore, only the top tier is fabricated in a trusted foundry.
The top tier only consists of passive metal wires that are inexpensive compared to the active CMOS transistors and metal wires in the untrusted, bottom tier [21].
Finally, we assume that that all IC instances are manufactured before being sent out for stacking.
If this were not the case, an attacker could intercept a stacked IC and reverse engineer the connections on the top tier.
Armed with this knowledge, the attacker could then insert malicious hardware in future batches of the IC as they are being fabricated in the foundry.
In this section, we discuss related work in the literature on hardware security and, specifically, the use of 3D ICs in this context.
We also discuss the relationship of our work to database and graph anonymizing mechanisms.Hardware Security Malicious circuits are expected to consist of two components, a trigger and the attack itself.
The trigger for the attack can be based on data, for example when a specific cheat code appears at selected wires in the circuit [19], or on time, i.e., the trigger goes off after a certain period of time once the IC is shipped [33].
Once triggered, the malicious attack can either transmit or leak sensitive information on the chip, modify the circuit functionality or degrade the circuit performance.
Tehranipoor and Koushanfar discuss a number of specific backdoors that fall within one of these categories [31].
Countermeasures against malicious attacks can be categorized in various ways.
Design based countermeasures modify or add to the design of the circuit itself to provide greater security.
These include N-variant IC design [4], data encryption for computational units [33] and adding run-time monitors to existing hardware [32].
Our work falls within this category.
In contrast, testing based counter-measures use either pre-fabrication or post-fabrication testing and validation to detect, and in some cases, disable malicious circuits.
A survey of these techniques can be found in [11].
Another way to categorize countermeasures is by their impact on the attack.
Countermeasures to detect malicious circuits include IC fingerprinting [3] and unused circuit identification [17].
Some countermeasures can be used to disable malicious circuitry; for example, the power cycling based defense against timer triggers [33].
The proposed defense mechanism aims to deter attackers by hiding a part of the circuit and making it more difficult for the attacker to effect a successful attack.3D Integration for Hardware Security Valamehr et al. [32] also exploit 3D integration capabilities to enhance the security of computer hardware, although in a manner orthogonal to ours.
Their proposal involves adding a "control tier" on top of a regular IC to moni-tor the activity of internal wires in the IC in a cost effective way.
By monitoring internal wires on the chip, the control tier is able to detect potentially malicious activity and take appropriate recourse.
Adding the monitors vertically on top of the IC to be protected reduces the power and performance cost of monitoring the IC.
A similar technique was proposed by Bilzor [7].
Or technique exploits 3D integration in a different way, i.e., we use it to provide a malicious attacker in an IC foundry with an incomplete view of the circuit netlist, thus deterring the attack.
Although the potential for this kind of defense mechanism has been alluded to before by Tezarron [1], ours is the first work, to our knowledge, to address this technique in any consequential way.Hardware Obfuscation Hardware obfuscation techniques have been proposed to make circuits more difficult to reverse engineer.
In particular, Roy et al. [26] augment a combinational circuit with key bits in such a way that the circuit only provides correct outputs when the key bits are set to pre-determined values.
Rajendran et al. [24] further strengthen this defense mechanism by increasing the bar on the attacker to determine the secret key.A difference between key-based circuit obfuscation mechanisms and circuit obfuscation via split manufacturing is that the notion of security in the former is conditioned on the computational capabilities of the attacker.
In contrast, our notion of security is unconditional in that no matter the computational capabilities of the attacker, he cannot distinguish each gate from k − 1 other gates.
We note that these mechanisms are not necessarily mutually exclusive -it might be possible to leverage split manufacturing based circuit obfuscation to further strengthen key-based circuit obfuscation, or vice-versa.
Independent of this work, Rajendran et al. [25] have recently examined the security obtained from split manufacturing.
However, the authors provide no well-founded notion of security for split manufacturing, as we do in this paper.
The authors do not address the wire lifting problem at all, and implicitly assume that the circuit is partitioned using traditional min-cut partitioning heuristics.
Finally, it is assumed that the attacker reconstructs the circuit by simply connecting the closest gates with disconnected inputs/outputs.
Anonymizing Databases and Social Networks Our work bears relationship to prior work on anonymizing databases and social network graphs, but also has significant differences.
A database is k-anonymous if the information for each individual is indistinguishable from k − 1 other individuals [30] in the database.
The notion of k-anonymity for a social network is similar, except that instead of operating on relational data, it operates on a graph.
Two individuals in a social network are indistinguishable if their local neighbourhoods are the same [34].
In our setting, the similarity of the local neighborhood of two gates is only a necessary but not sufficient condition for indistinguishability.
This is because the attacker is assumed to have access to the original circuit netlist and an incomplete view of the same netlist, and must thus match all gates in the incomplete netlist to gates in the original netlist.The circuit obfuscation problem also introduces a number of distinct practical issues.
These include the additional information that might be conveyed by the circuit layout (for example, the physical proximity of gates), and the role of the number of gate types in the technology library.
In this section, we formulate the circuit obfuscation problem that we address in this paper as a problem in the context of directed graphs.
We begin by discussing the example circuit for a full adder that we show in Figure 3.
As we mention in Section 1, in the most powerful attack model we consider, an attacker is in possession of two pieces of information: the originally designed (complete) circuit netlist, and the layout of the circuit that is sent to the foundry for fabrication, which we call the unlifted netlist.
The latter results from the defender lifting wires from the former.
Assume that the defender chooses to lift the wires A → {1, 2}, B → {1, 2},C IN → {3, 4}, 1 → {3, 4} and 3 → C OUT .
Note that gates in the unlifted netlist in Figure 3(b) are labeled differently from those in the original circuit in Figure 3(a).
This reflects the fact that the attacker obtains the original circuit netlist and the unlifted netlist in completely different formats.
The original netlist is a set of gates and wires in HDL format.
On the other hand, the unlifted netlist is reconstructed from the circuit layout, which is a set of shapes and their locations on the surface of the chip, as also discussed in Section 4.3.
The labeling and ordering of objects in the circuit layout file is unrelated to that in the netlist of the original circuit.
Although not required, the defender can perform an additional random re-labeling and re-ordering step before the layout of H is sent to the foundry.Given these two pieces of information, the attacker now seeks a bijective mapping of gates in the unlifted netlist to gates in the complete circuit netlist.
If the attacker is successful in obtaining the correct mapping, he can carry out a targeted attack on any gate (or gates) of his choosing.
The security obtained from lifting wires in the context of this example can be explained as follows.
From the attacker's perspective, either Gate u or Gate w in the unlifted netlist could correspond to Gate 1 in the original netlist.
Thus the attacker's ability to carry out a targeted attack on Gate 1 is hindered.
The same can be said for the attacker's ability to carry out a targeted attack on Gate 2, 3 or 4.
However, note that the attacker can determine the identity of Gate 5 with certainty -it must correspond to Gate y since this is the only OR gate in the netlist.
Thus, in this example, the lifting does not provide any security for Gate 5.
Informally, our notion of security is based on the existence of multiple isomorphisms (mappings) between gates in the unlifted netlist and the original netlist.
In our example, there exist 4 distinct bijective mappings between the gates in the unlifted and original netlists.
However, this notion of security may be seen as too permissive.
It can be argued that given the fact that across all mappings, gate 5 is mapped uniquely, we have no security at all (i.e., security of 1).
A more restrictive notion of security, one that we adopt in this paper, requires that for each gate in the original netlist, there exist at least k different gates in the unlifted netlist that map to it over all isomorphisms.
This is intended to capture the intuition that the attacker is unable to uniquely identify even a single gate.
We now formalize our notion of security.
We now formulate our problem as a graph problem.
A circuit can be perceived as a directed graph -gates are vertices, and wires are edges.
The direction of an edge into or out of a vertex indicates whether it is an input or output wire to the gate that corresponds to the vertex.
If G is a graph, we denote its set of vertices as V [G], and its set of edges as E [G].
Each vertex in the graph is associated with a color that is used to distinguish types of gates (e.g, AND and OR) from one another.
Consequently, a graph G is a 3-tuple, 񮽙V, E, c񮽙, where V is the set of vertices, E the set of edges and the function c : V → N maps each vertex to a natural number that denotes its color.
For example, the circuit in Figure 3 and its unlifted portion can be represented by the graphs in Figure 4.
A main challenge for the defender is to lift wires in a way that provides security.
Our notion of security corresponds to a certain kind of subgraph isomorphism.
For example, in Figure 4, a subgraph isomorphism, φ , isDefinition 1 (Graph isomorphism).
Given two graphs G 1 = 񮽙V 1 , E 1 , c 1 񮽙 , G 2 = 񮽙V 2 , E 2 , c 2 񮽙, we say that G 1 is iso- morphic to G 2 if there exists a bijective mapping φ : V 1 → V 2 such that 񮽙u, v񮽙 ∈ E 1 if and only if 񮽙φ (u), φ (v)񮽙 ∈ E 2 and c 1 (u) = c 2 (φ (u)), c 1 (v) = c 2 (φ (v)).
φ (1) = U, φ (2) = V, φ (3) = X, φ (4) = W, φ (5) = Y .
Intuition Let G be the graph that represents the original circuit with all wires, and H the graph of the circuit after wires have been lifted.
Then, the attacker knows that G is subgraph isomorphic to H.
What he seeks is the correct mapping of vertices in G to H (or vice versa).
This is equivalent to him having reconstructed the circuit, and now, he can effect his malicious modifications to the circuit that corresponds to H.From the defender's standpoint, therefore, what we seek intuitively is that there be several subgraph isomorphisms between G and H.
As we mention in Section 1, this then gives the kind of security in a k-anonymity sense -the attacker cannot be sure which of the mappings is the correct one, and therefore is able to reconstruct the circuit with probability 1/k only.
As we mention there and discuss in more detail in the related work Section, though our notion of security has similarities to k-anonymity, there are important differences, and we call it k-security instead.k-security We now specify our notion of security.
We do this in three stages.
(1) We first define a problem that captures our intuition of a gate being indistinguishable from another gate.
We do this by requiring the existence of a particular kind of subisomorphic mapping between graphs that represent circuits.
(2) We then define the notion of a k-secure gate.
Such a gate is indistinguishable from at least k − 1 other gates in the circuit.
(3) Finally, we define the notion of k-security, which is security across all gates in the circuit.
This definition requires simply that every gate in the circuit is k-secure.
In the following definition, we characterize the problem GATE-SUBISO, which captures (1) above -a notion of what it means for a gate to be indistinguishable from another.
φ : V [G] → V [H] that is a subgraph isomorphism from G to H such that φ (u) = v.The above definition is a special case of the wellknown subgraph isomorphism problem [16].
In the subgraph isomorphism problem, we take as input two graphs A, B, and ask whether B is subgraph isomorphic to A.
In GATE-SUBISO, both the graphs G, H are restricted to be DAGs, and H is a specific subgraph of G -one with some edges removed from G. Of course, we know that H is subgraph isomorphic to G, with the identity mapping from a vertex to itself serving as evidence (a certificate).
However, in the GATE-SUBISO problem, we require the existence of a subgraph isomorphism that is different from the identity mapping, and furthermore, require that the vertex u be mapped under that subgraph isomorphism to a specific vertex v.The intuition behind GATE-SUBISO is the following.
G is the graph that corresponds to the original circuit, and H is the graph that corresponds to the circuit after wires are lifted.
The above definition for GATE-SUBISO asks whether there exists a mapping under which the vertex u in the original circuit is indistinguishable from v in the unlifted circuit.
That is, given that u 񮽙 = v, an attacker does not know whether u in G corresponds to u or v in H.Based on GATE-SUBISO above, we now define the notion of a k-secure gate.
It captures the intuition that the gate is indistinguishable from at least k − 1 other gates.
i ∈ [1, k], φ i (u) = v i .
The above definition expresses that u is indistinguishable from each of the v i 's.
Of course, one of the v i 's may be u itself.
Therefore, every gate is 1-secure, and if a gate is not 2-secure, then that gate is uniquely identifiable, for this particular choice of E 񮽙 .
The maximum that k can be is |V [G]|, the number of a vertices in G.Given the above definition for a k-secure gate, it is now straightforward to extend it to the entire graph (circuit).
We do this with the following definition.Definition 5 (k-security).
Given a DAG G, and a DAG H that we get from G by removing the edges from a set E 񮽙 ⊆ E [G].
We say that 񮽙G, E 񮽙 񮽙 is k-secure if every vertex in G is k-secure.
The above definition is a natural extension of the notion of a k-secure gate, to every gate in the circuit.
What it requires for k-security is that every vertex in the corresponding graph is indistinguishable from at least k vertices.
We point out that some gates may be more than k-secure; k-security is a minimum across all gates.
As the maximum k for any gate is |V [G]|, a graph can be, at best, |V [G]|-secure.
Every graph is 1-secure, which is the minimum.We denote as σ (G, E 񮽙 ) the maximum k-security we are able to achieve with G, E 񮽙 .
In Figure 4, for example, we know that σ evaluates to 1, because the node 5 can be mapped to itself only.
The nodes 1, 2, 3 and 4, however, are 2-secure gates.
The reason is that each can be mapped either to itself, or to another node.
We now consider the computational complexity of determining the maximum k-security, σ .
We consider a corresponding decision problem, k-SECURITY-DEC, which is the following.
We are given as input 񮽙G, E 񮽙 , k񮽙 where G is a DAG,E 񮽙 ⊆ E[G]is a set of edges in G, andk ∈ [1, |V [G]|].
The problem is to determine whether lifting the edges in E 񮽙 results in k-security.
We point out that if we have an oracle that decides k-SECURITY-DEC, then we can compute the maximum ksecurity we can get by lifting E 񮽙 from G using binary search on k.
That is, the problem of computing σ is easy if deciding k-SECURITY-DEC is easy.
Theorem 1.
k-SECURITY-DEC ∈ NP-complete under polynomial-time Turing reductions.To prove the above theorem, we need to show that k-SECURITY-DEC is in NP, and that it is NP-hard.
For the former, we need to present an efficiently (polynomialsized) certificate that can be verified efficiently.
Such a certificate is k mappings each of which is a subgraph isomorphism, for each vertex u ∈ V [G].
Each such mapping can be encoded with size O(|V [G]|), and there are at most k|V [G]| such mappings, and therefore the certificate is efficiently-sized.
The verification algorithm simply checks that each mapping is indeed a subgraph isomorphism, and that u is mapped to a distinct vertex in each of the k mappings that corresponds to it.
This can be done in timeO(|V [G]| 3 ).
We show that k-SECURITY-DEC is NP-hard under polynomial-time Turing reductions in the Appendix.
(Henceforth, we drop the qualification "under polynomial-time Turing reductions," and simply say NP-complete and NP-hard.)
Indeed, our proof demonstrates that deciding even 2-security is NP-hard.
The knowledge that k-SECURITY-DEC is NP-complete immediately suggests techniques for approaches for solving k-SECURITY-DEC, and thereby computing k-security.
We discuss this further in the next section.
Lifting edges E 񮽙 from G incurs a cost c(G, E 񮽙 ).
A simple cost metric, one that we adopt in this paper is c(G, E 񮽙 ) = |E 񮽙 |, i.e., the cost is proportional to the number of lifted edges.
Given the cost of lifting edges, the defender's goal is to determine E 񮽙 , the set of edges that should be lifted, such that σ (G, E 񮽙 ) ≥ k and c(G, E 񮽙 ) is minimized.We observe that from the standpoint of computational complexity, the problem of determining E 񮽙 given G, k, where G is the graph and E 񮽙 is the set of edges to be lifted so we get k-security, is no harder than k-SECURITY-DEC.
That is, that problem is also in NP.To prove this, we need to show that there exists an efficiently sized certificate that can be verified efficiently.
Such a certificate is E 񮽙 , and k subgraph isomorphisms for every vertex.
The latter component of the certificate is the same as the one we used in our proof above for k-SECURITY-DEC's membership in NP.
The verification algorithm, in addition to doing what the verification algorithm for k-SECURITY-DEC above does, also checks that E 񮽙 is indeed a subset of G's edges.We note that the k-security from lifting all the edges in G is no worse than lifting any other set of edges, and the k-security from lifting no edges in G is no better than lifting any other set of edges.
More generally, given any n 1 , n 2 such that |E[G]| ≥ n 1 > n 2 , we know that for every G, there exists a set of edges of size n 1 that if lifted, provides at least as much security as every set of edges of size n 2 .
That is, there is a natural trade-off between the number of edges we lift, i.e., cost, and the security we achieve.
In Section 4, we outline an approach to determine the cost-security trade-off using a greedy wire lifting procedure.
Given our notion of k-security, a natural question to ask is whether there are stronger or different attack models for which k-security would be inadequate.
We discuss this in the context of two attack models that differ from the one assumed.
Finally, we also discuss a related question -that of the computational capabilities of the attacker.
The notion of ksecurity is premised on an attack model in which the attacker needs to precisely identify one or more gates in the unlifted netlist, for example, the privilege escalation bit in a microprocessor [19] or the LSB of the 14 th round in a DES implementation [9].
However, one can imagine a scenario in which the attack would be successful if the attacker correctly identifies any one of n gates.
For example, there could be multiple privilege escalation bits in the microprocessor implementation.More concretely, in the example in Figure 3, assume that the attacker wants to change the circuit functionality by inverting the output of Gate 2.
The same objective can be accomplished by inverting the output of Gate 4.
However, as we observe before, Gate v in the unlifted netlist must correspond to either Gate 2 or Gate 4.
Thus, although this gate is 2-secure, the attack would be successful with probability 1.
Although our notion of security does not directly address the alternate attack model described above, it can be easily modified to do so.
Say that the defender is aware that Gate v and Gate x are each equally vulnerable to the same kind of attack.
Then, the defender can insist that Gate v is k-secure if and only if it is indistinguishable from k − 1 other gates excluding Gate x.
Such information that the defender may have about the relative vulnerability of gates can be built into the notion of k-security.
Our attack model strengthens the attacker with access to the original cir-cuit netlist, G, along with the unlifted netlist H.
Since the attacker has access to G, it is reasonable to ask if an even stronger attacker with access to G and the procedure used to lift wires would compromise security.
It would not.
Figure 5: Example illustrating that the unlifted netlist H is 2-secure even if the attacker knows that edge 2 → 3 was lifted from original netlist G.In fact, even if there is a deterministic choice of edges that must be lifted to provide a certain security level, knowledge of which edges are lifted does not compromise security, as long as G and H are differently labeled.
We illustrate this with an example in Figure 5, where wire 2 → 3 must be lifted to provide 2-security.
This knowledge does not compromise the security obtained from lifting.
When there is choice, i.e., lifting two or more edges provides the same security, the choice is made uniformly at random.
This is discussed in Section 4.
Computational capabilities of the attacker Our notion of k-security is not predicated on the computational capabilities of the attacker.
In fact, we assume that the attacker is able to identify (all) subgraph isomorphisms from H to G. Nonetheless, given that the attacker's goal might be to identify a single gate in the netlist, it is natural to ask why (and whether) the attacker needs determine a mapping for each gate in H.In particular, the attacker can identify all gates in H with the same type and connectivity, i.e., number and type of gates it connects to, as the one he is interested in attacking.
Prior work on k-anonymity for social network graphs assumes this kind of attack strategy.
From the perspective of the attacker, this strategy is sub-optimal.
This is because, for any gate in G that the attacker wants to target, this strategy will provide at least as many candidate mappings in H as the strategy in which the attacker enumerates all subgraph isomorphisms.
Having considered the computational complexity of the problem that underlies our work in the previous section, in this section, we propose a concrete approach for it.
As our discussions in the prior section reveal, there are two parts to the solution: (a) computing the maximum k-security for �G, E � �, given the graph G that represents the complete circuit, and, (b) choosing the set E � .
We propose an approach for each in this section.
For the problem of computing security, we employ constraint-solving.
We discuss this in Section 4.1.
For the problem of choosing E � , we propose a greedy heuristic.
We discuss that in Section 4.2.
We conclude this section with Section 4.3 with some practical considerations, specifically, scalability and layout-anonymization.
As shown in Section 3, the problem of determining the security level of circuit G, given the unlifted netlist H is NP-complete.
Given the relationship of the problem to subgraph isomorphism, a natural approach to solving this problem would be to use graph (sub)isomorphism algorithms proposed in literature -of these, the VF2 algorithm [12] has been empirically shown to be the most promising [15].
However, in our experience, VF2 does not scale for circuits with > 50 gates (more on scalability in Section 4.3).
Instead, motivated by the recent advances in the speed and efficiency of SAT solvers, we reduce the subisomorphism problem to a SAT instance and use an offthe-shelf SAT solver to decide the instance.
Given graphs G and H, we define a bijective mapping φ from the vertex set of H to the vertex set of G as follows: Boolean variable φ i j is true if and only if vertex q i ∈ H maps to a vertexr j ∈ G.
Here V [G] = {r 1 , r 2 ,..., r |V [G]| } and V [H] = {q 1 , q 2 ,...,q |V [H]| }We now construct a Boolean formula that is true if and only if graphs G and H are sub-isomorphic for the mapping φ .
We will construct the formula in parts.First, we ensure that each vertex in G maps to only one vertex in H:F 1 = |V [H]| ∏ i |V [G]| ∑ j 񮽙 φ i, j |V [G]| ∏ k� =i ¬φ i,k 񮽙and vice-versa:F 2 = |V [G]| ∏ j |V [H]| ∑ i 񮽙 φ i, j |V [H]| ∏ k� =i ¬φ k, j 񮽙Finally we need to ensure that each edge in H maps to an edge inG.
Let E[H] = {e 1 , e 2 ,...,e |E[H]| } and E[G] = { f 1 , f 2 ,..., f |E[G]| }.
Furthermore, let e k = �q src(e k ) , q dest(e k ) � ∈ E[H] and f k = �r src( f k ) , r dest( f k ) � ∈ E[G].
This condition can be expressed as follows:F 3 = |E[H]| ∏ k |E[G]| ∑ l φ src(e k ),src( f l ) ∧ φ dest(e k ),dest( f l )The formula F that is input to the SAT solver is then expressed as a conjunction of the three formulae above:F = F 1 ∧ F 2 ∧ F 3 .
The formula F has O(|V [H]||V [G]|) variables and O(|E[H]||E[G]|) clauses.
To determine a candidate set of edges, E 񮽙 , to lift, we employ a greedy heuristic.
Our heuristic is shown as Algorithm 1.1 E 񮽙 ← E[G] 2 while |E 񮽙 | > 0 do 3 s ← 0 4 foreach e ∈ E 񮽙 do 5 E 񮽙 ← E 񮽙 − {e} 6 if σ (G, E 񮽙 ) > s then 7 s ← σ (G, E 񮽙 ) 8 e b ← e 9 E 񮽙 ← E 񮽙 ∪ {e} 10 if s < k then return E 񮽙 11 E 񮽙 ← E 񮽙 − {e b } 12 return E 񮽙 Algorithm 1: lift wires(G, k)In our heuristic, we begin with the best security we can achieve.
This occurs when we lift every edge in E [G]; that is, we set E 񮽙 to E [G] at the start in Line 1.
We then progressively try to remove edges from E 񮽙 , in random order.
We do this if not lifting a particular edge e still gives us sufficient security.That is, we iterate while we still have candidate edges to add back (Line 2).
If we do, we identify the "best" edge that we can add back, i.e., the one that gives us the greatest security level if removed from E 񮽙 .
If even the best edge cannot be removed from E 񮽙 , then we are done (Line 10).
The heuristic does not necessarily yield an optimal set of edges.
The reason is that we may greedily remove an edge e 1 from E 񮽙 in an iteration of the above algorithm.
And in later iterations, we may be unable to remove edges e 2 and e 3 .
Whereas if we had left e 1 in E 񮽙 , we may have been able to remove both e 2 and e 3 .
Note that removing as many edges from E 񮽙 is good, because our cost is monotonic in the size of E 񮽙 (set of edges being lifted).
From a graph-theoretic perspective, the wire lifting procedure outlined provides a set of wires to lift that guarantees a certain security level.
However, two practical considerations merit further mention -the scalability of the proposed techniques to "large" circuits, and the security implication of the attacker having access to the layout of H, as opposed to just the netlist.
Although the SAT based technique for computing security scales better than the VF2 algorithm, we empirically observe that it times out for circuits with > 1000 gates.
To address this issue, we propose a circuit partitioning approach that scales our technique to larger circuits of practical interest.
We note that circuit partitioning is, in fact, a commonly used technique to address the scalability issue for a large number of automated circuit design problems.Algorithm 2 is a simplified description of the partitioning based wire lifting procedure.
The function partition(G) recursively partitions the vertex set of the graph into P mutually exclusive subsets and returns subgraphs {G 1 , G 2 ,.
.
.
,G P } of size such that they can be tractably solved by the SAT based greedy wire lifting procedure.
The final set of lifted wires includes the union of all wires that cross partitions, and those returned by P calls to Algorithm 1.
We have used this technique to lift wires from circuits with as many as 35000 gates (see Section 5).1 {G 1 , G 2 ,.
.
.
,G P } ← partition(G) 2 E R ← E − 񮽙 i∈[1,P] E i 3 for i ∈ [1, P] do 4 E R ← E R 񮽙 li f t wires(G i , s req ) 5 return E R Layout anonymization We have, so far, assumed that the unlifted circuit H is a netlist corresponding to the unlifted gates and wires.
However, in practice, the attacker observes a layout corresponding to H, from which he reconstructs the netlist of H.
We therefore need to ensure that the layout does not reveal any other information to the attacker besides the reconstructed netlist.Existing commercial layout tools place gates on the chip surface so as to minimize the average distance, typically measured as the Manhattan distance, between all connected gates in the circuit netlist.
Thus, if the complete circuit G is used to place gates, the physical proximity of gates will reveal some information about lifted wires -gates that are closer in the bottom tier are more likely to be connected in the top tier.
The attacker can use this information to his advantage.Instead of using the netlist G to place gates, we instead use the netlist H.
Since this netlist does not contain any lifted wires, these wires do not have any impact on the resulting placement.
Conversely, we expect the physical proximity of gates to reveal no information about hidden wires in the top tier.
In Section 5, we empirically validate this fact.
However, anonymizing the layout with respect to the hidden wires does result in increased wire-length between gates, which has an impact on circuit performance.
This impact is also quantified in Section 5.
We conduct our experimental study using two exemplar benchmarks, the c432 circuit from the ISCAS-85 benchmark suite [10] (a 27-channel bus interrupt controller) with ≈ 200 gates, and a larger DES encryption circuit with ≈ 35000 gates.
We use the c432 circuit to investigate security-cost trade-offs obtained from the proposed techniques and use the larger DES circuit for a case study.All experimental results are obtained using an IBM 0.13µ technology.
For 3D integration, bond points are assumed to be spaced at a pitch of 4µm, allowing for one bond-point per 16µm 2 .
This is consistent with the design rules specified in the Tezzaron 0.13µm technology kit.Circuit synthesis was performed using the Berkeley SIS tool [27].
Placement and routing is performed using Cadence Encounter.
Finally, we used miniSAT as our SAT solver [29].
: Maximum, average and minimum security levels for the c432 circuit using the proposed greedy wire lifting procedure and random wire lifting.
Proposed Vs. Random Wire Lifting Figure 6 compares the proposed greedy wire lifting technique with a baseline technique in which wires are lifted at random.
In both cases, we show the maximum, average and minimum security achieved by these techniques over all runs.Observe that greedy wire lifting provides significantly greater security compared to random wire lifting.
With 80 unlifted wires, the greedy solution results in a 23-secure circuit, while all random trials resulted in 1-secure (equivalently, completely insecure) circuits.
Figure 6 reveals that, for c432, at least 145 of the 303 (≈ 47%) wires must be lifted to get any meaningful degree of security.
If any fewer wires are lifted, circuit obfuscation provides no security at all.
However, once more than this minimum number of wires is lifted, the security offered increases quite rapidly.
Another observation that merits mention are the plateaus in security level, for example between E[H] = 30 and E[H] = 55.
In other words, in some cases, wires can be retained in the untrusted tier without any degradation in security.
Figure 7 shows three layouts for the c432 circuit.
The far left corresponds to the original 1-secure c432 circuit without any wire lifting.
The other two layouts correspond to the top and bottom tiers of an 8-secure version of c432 with ≈ 66% lifted wires.
Of particular interest is the wire routing in the trusted top tier -because the placement of the corresponding gates in the untrusted bottom tier have been anonymized, the lifted wires are routed seemingly randomly.
This is in stark contrast to the wire routing in the original circuit that is far more structured.
Figure 8 shows the histogram of wire lengths for the three layouts shown in Figure 7.
Note that, in the original 1-secure circuit, a large majority of wires are short; in other words, connected gates are placed closer together.
Wire lengths on the bottom untrusted tier of the 8-secure circuit also skew towards shorter values -however, these wires are already observable to the attacker and he gains no additional information from their lengths.
On the other hand, the wire length distribution of the top tier is more evenly spread out.
This reflects that fact that the physical proximity of gates in the bottom tier reveals very little information about the lifted wires.
A Chi Square test was performed to determine if the distribution of wirelengths in the top tier is different from one that would be obtained from a random placement of gates.
The test does not provide any evidence to reject the null hypothesis (N = 11, χ 2 = 0.204 and p = 0.999), i.e., it does not reveal any significant difference between the two distributions.Area, Delay and Power Cost Area, delay (inversely proportional to clock frequency) and power consumption are important metrics of circuit performance.
3D integra- tion based circuit obfuscation introduces overheads on all three metrics.
The area of a 3D circuit is determined by the larger of two areas: the area consumed by the standard cells in the bottom tier, and the area consumed by the bond-points required to lift wires to the top tier.
The bond-point density is limited by technology (1 bond-point per 16µm 2 in our case) and therefore more lifted wires correspond to increased area.Delay and power are strong functions of wire length, as increased wire length results in increased wire capacitance and resistance.
Layout anonymization results in increased wire length as we have observed before.
Table 1 shows the area, power and delay for the c432 circuit for different security levels.
Compared to the original circuit, the 8-secure circuit has 1.6× the power consumption, 1.8× delay, and about 3× the area.
The technology library determines the type of gates that are allowed in the circuit netlist.
Diverse technology libraries with many different gate types allow for more optimization, but also hurt security.
Figure 9 shows the security levels achievable for c432 for five different technology libraries with between three and seven gates.
We use the DES encryption benchmark circuit to demonstrate that applicability of our techniques, including circuit partitioning based wire lifting, to larger circuits.
The DES circuit takes as input a fixed-length string of plaintext and transforms the string into cipher text using 16 rounds of obfuscation, as shown in the block-level circuit diagram in Figure 10.
The original, 1-secure implementation of DES that we synthesized has ≈ 35000 logic gates, which results in an intractable SAT instance.
However, using recursive circuit partitioning, we are able to lift wires to obtain a 64-secure implementation.
We note that a security level of 16 is obtained in the first few rounds of partitioning by removing only 13% of the wires, i.e., all wires that lie between successive DES rounds.
This is because the circuit description of each DES round is identical -thus, once the wires between the rounds have been removed, each round can be confused for any other round.
The final 64-secure implementation has only 30% of the wires unlifted, and consumes 2.38× the area of the original 1-secure circuit.Attack Scenario Boneh et al. [9] have shown that specific bits in a DES implementation are particularly susceptible to fault attacks.
For example, if the attacker is able to insert an attack such that the LSB output of the 14 th round is stuck at logic zero, the secret key can be recovered using as few as two messages.
Figure 11 shows how such an attack might be effected using a trigger (we do not address here how this trigger may be activated) and three additional gates in an insecure (or 1-secure) circuit.
When the trigger is set, the output is set to zero, but is equal to the correct value when the trigger is at logic zero.
Now, assume that wire lifting is performed to make the circuit 64-secure.
Given the set of lifted wires, we note that the LSB of the 14 th round is, in fact, 256-secure, i.e., there are 255 other gates in the circuit that are indistinguishable from the LSB of the 14 th round.
The attacker now has two choices.
he can either attack one of the 256 options, and only succeed with probability 1 256 , or he can choose to carry out a multiplexed attack on all 256 gates.
This is shown in Figure 11.
In this attack, the trigger transmits a sequence of 8-bits that identify which of the 256 signals the attacker wants to attack.
These 8-bits feed an 8:256 demultiplexer that generates individual triggers for each of the 256 signals that are indistinguishable.The attacker can now iteratively insert attacks in each gate one at a time and conceivably determine which iteration actually corresponds to the LSB of the 14 th round.
However, in doing so, the attacker incurs two costs: (i) the modified attack circuit now requires 1280 gates instead of just 3, a 420× overhead; (ii) the attacker would require, in the worst case 255× more messages to recover the key.
We have so far illustrated the quantitative trade-off between cost and security using benchmark circuits.
We now discuss this trade-off qualitatively.
In particular, we address aspects relating to both the security that 3D IC based split manufacturing can provide and the cost that it incurs in doing so.From a security standpoint, we note that our notion of k-security is conservative.
This is for two reasons.
First, we have assumed a strong attack model in which the attacker has access to the original circuit netlist.
In prac- tice, the attacker might only have access to the Boolean functionality of the circuit under attack, but not its gate level implementation.
Second, in realistic attack scenarios, the attacker might need to identify more than one gate in the netlist.
In both settings k-security serves as a lower bound on the security obtained from 3D IC based split manufacturing.Furthermore, hardware attacks that are inserted in the foundry are different from other attack scenarios in that they are single shot, and require more effort, risk and expense to carry out.
Thus, even relatively low values of k are likely to act as a significant deterrent for the attacker.
If the attacker picks one gate to attack at random from the candidate set, he is only successful with probability 1 k and receives a payoff which is greater than his cost.
However, with probability k−1 k , the attacker incurs a (significant) cost and receives no payoff.
With k = 100 for example, the attacker's payoff must be > 99× his cost for him to break even (on average).
Alternatively, the attacker could try attacking all 100 gates that are candidate mappings for his desired target (as shown in Figure 11), but this would incur a significantly increased risk of detection during post-fabrication testing.From a cost standpoint, our empirical evaluations suggest a 1.5 × −2× overhead in area, performance (performance is proportional to circuit delay) and power consumption, which is the price we pay for security.
Although there is relatively little work in this area, these overheads compare well to those of competing solutions such as field programmable gate arrays (FPGAs).
In an FPGA, the desired circuit netlist is programmed on the FPGA after fabrication, so an attacker in a foundry receives no information about the circuit the designer wants to implement.
However, benchmark studies have shown that FPGAs are 20×, 12× and 4× worse than custom digital ICs in terms of area, power and performance, respectively [20].
In addition, the FPGA itself could be attacked during fabrication in a way that allows an attacker in the field (after fabrication) to recover the circuit that has been programmed on it.Finally, we note that the proposed technique can be selectively applied to only small, security critical parts of the design.
Thus the area, performance and power overheads of split manufacturing would be amortized over the parts of the design that are conventionally implemented.
It might also be possible to use split manufacturing in conjunction with other security techniques proposed in the literature such as key-based obfuscation [26,24].
Key-based obfuscation is only conditionally secure, conditioned on the attacker's computational capabilities.
We believe that split manufacturing can be used to further strengthen key-based obfuscation and make it unconditionally secure, although we leave this investigation as future work.
In this paper, we have proposed the use of 3D integration circuit technology to enhance the security of digital ICs via circuit obfuscation.
The specific 3D technology we exploit allows gates and wires on the bottom tier, and only metal wires on the top.
By implementing a subset of wires on the top tier, which is manufactured in a trusted fabrication facility, we obfuscate the identity of gates in the bottom tier, thus deterring malicious attackers.We introduce a formal notion of security for 3D integration based circuit obfuscation and characterize the complexity of computing security under this notion.
We propose practical approaches to determining the security level given a subset of lifted wires, and of identifying a subset of wires to lift to achieve a desired security level.
Our experimental results on the c432 and DES benchmark circuits allow us to quantify the power, area and delay costs to achieve different security levels.
In addition, we show, using a DES circuit case study, that 3D IC based circuit obfuscation can significantly reduce the ability of an attacker to carry out an effective attack.
In this section, we provide outlines of the proofs that underlie our assertion in Section 3 that k-SECURITY-DEC is NP-hard under polynomial-time Turing, or Cook, reductions [5].
Such reductions work the following way.
Suppose we want to reduce problem A to B.
We show that if we have an oracle for B, then A ∈ P.Such reductions are unlikely to be as strong as Karpreductions [5], that are customarily used to show NPhardness.
Indeed, the Karp-reduction is a special case of the Cook-reduction, and some of our reductions below are Karp-reductions.
Nevertheless, the existence of a Cook-reduction from a problem that is NP-hard is evidence of intractability [22].
In particular, in the above example, if A reduces to B, then if B ∈ P, then A ∈ P.Recall from Section 3 that k-SECURITY-DEC is the following decision problem.
Given as input 񮽙G, E 񮽙 , k񮽙 where E 񮽙 ⊆ E [G], does lifting the edges in E 񮽙 give us k-security?
We show that k-SECURITY-DEC is NP-hard in three steps.
First, we show that SUB-ISO-SELF (defined below) is NP-hard.
We then reduce SUB-ISO-SELF to GATE-SUBISO (see Section 3), thereby showing that GATE-SUBISO is NP-hard.
Finally, we reduce GATE-SUBISO to k-SECURITY-DEC.
All graphs we consider are directed, acyclic (DAGs).
Thus, all subisomorphisms we consider are for the special case that the graphs are DAGs.
It turns out that the subgraph isomorphism problem is NP-hard for even the restricted case, SUB-ISO-9, below.
Definition 6 (SUB-ISO-9).
SUB-ISO-9 is the following special case of the subgraph isomorphism problem.
Given as input 񮽙G, H񮽙 where G is a DAG and H is a directed tree, SUB-ISO-9 is the problem of determining whether there exists a subgraph of G that is isomorphic to H. SUB-ISO-9 is known to be NP-hard [16].
Definition 7 (SUB-ISO-SELF).
Given as input 񮽙G, H񮽙 such that G is a DAG and H is obtained from G by removing the edges in a set E 񮽙 ⊆ E [G], SUB-ISO-SELF is the problem of determining whether there exists a subgraph isomorphism φ from G to H that is not the identity mapping.Theorem 2.
SUB-ISO-SELF ∈ NP-hard.
Note that the above theorem is not qualified that it is under Cook-reductions.
This is because we have a Karpreduction from SUB-ISO-9 ro SUB-ISO-SELF.
The reduction proceeds in several steps.
First, we show that SUB-ISO-9 restricted to the case that |V [G] Then, we show that if we add the further restriction that G and H are strongly connected (i.e., every vertex reachable from every other vertex), the problem is still NP-hard.
For this reduction, we first check whether the two graphs are strong connected.
If not, we introduce a new vertex of a colour distinct from every vertex in the graphs which has an edge to and from every other vertex.We then show that SUB-ISO-SELF is NP-hard as follows.
We introduce into G an exact copy of H that is disjoint from G.
We use the same technique as above of adding coloured vertices to ensure that G (within G 񮽙 ) and G 񮽙񮽙 in H 񮽙񮽙 are not automorphic.
Finally, we connect every new vertex added above to the vertices of G, to every original vertex of H 񮽙 , and every new vertex added to H 񮽙 to every original vertex of G.
We do the same in H 񮽙񮽙 .
We now are able to show that 񮽙G, H񮽙 is a true instance of SUB-ISO-9 if and only if 񮽙G 񮽙 , H 񮽙񮽙 񮽙 is an instance of SUB-ISO-SELF.
Theorem 3.
GATE-SUBISO ∈ NP-hard under Cookreductions.Recall that GATE-SUBISO comprises those instances 񮽙G, E 񮽙 , u, v񮽙, where, if H is produced from G by removing the edges in E 񮽙 , and u, v are distinct vertices in G (and therefore H), there is a subgraph isomorphism from G to H that maps u to v.
In our reduction, we assume that we have an oracle for GATE-SUBISO.
We simply invoke it for every pair of vertices u, v ∈ G.
If any of them is true, then we know that 񮽙G, H񮽙 is a true instance of SUB-ISO-SELF.
Otherwise, it is not.Theorem 4.
k-SECURITY-DEC ∈ NP-hard under Cookreductions.We Karp-reduce GATE-SUBISO to k-SECURITY-DEC.
Let 񮽙G, E 񮽙 , k񮽙 be a prospective instance of k-SECURITY-DEC, and H is produced from G by removing the edges in E 񮽙 .
We first ensure that every vertex other than u is 2-secure.
We do this by introduce a new vertex for every vertex other than u that has exactly the same connectivity.
Then, in G, we introduce a new vertex of a completely new colour and attach it to u and v.
We include the edge between v and this new vertex in E 񮽙 .
Call the G so modified G 񮽙񮽙 , and the new set of edges E 񮽙񮽙 .
We can now show that 񮽙G 񮽙񮽙 , E 񮽙񮽙 , 2񮽙 is a true instance of k-SECURITY-DEC if and only if 񮽙G, E 񮽙 , u, v񮽙 is a true instance of GATE-SUBISO.
We thank our shepherd, Cynthia Sturton, and the anonymous reviewers for their feedback and comments.
We thank also Vijay Ganesh and Supreeth Achar for their inputs at the initial stages of this research.
The work was supported by funding from the NSERC Discovery and Strategic grant programs.
