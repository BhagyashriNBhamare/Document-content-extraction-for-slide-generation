There is an increasing need to bring machine learning to a wide diversity of hardware devices.
Current frameworks rely on vendor-specific operator libraries and optimize for a narrow range of server-class GPUs.
Deploying workloads to new platforms-such as mobile phones, embedded devices, and accelerators (e.g., FPGAs, ASICs)-requires significant manual effort.
We propose TVM, a compiler that exposes graph-level and operator-level optimizations to provide performance portability to deep learning workloads across diverse hardware back-ends.
TVM solves optimization challenges specific to deep learning, such as high-level operator fusion, mapping to arbitrary hardware primitives, and memory latency hiding.
It also automates optimization of low-level programs to hardware characteristics by employing a novel, learning-based cost modeling method for rapid exploration of code optimizations.
Experimental results show that TVM delivers performance across hardware back-ends that are competitive with state-of-the-art, hand-tuned libraries for low-power CPU, mobile GPU, and server-class GPUs.
We also demonstrate TVM's ability to target new accelerator back-ends, such as the FPGA-based generic deep learning accelerator.
The system is open sourced and in production use inside several major companies.
This section describes TVM by using an example to walk through its components.
Figure 2 summarizes execution steps in TVM and their corresponding sections in the paper.
The system first takes as input a model from an existing framework and transforms it into a computational graph representation.
It then performs high-level dataflow rewriting to generate an optimized graph.
The operator-level optimization module must generate efficient code for each fused operator in this graph.
Operators are specified in a declarative tensor expression lan- Figure 2: System overview of TVM.
The current stack supports descriptions from many deep learning frameworks and exchange formats, such as CoreML and ONNX, to target major CPU, GPU and specialized accelerators.guage; execution details are unspecified.
TVM identifies a collection of possible code optimizations for a given hardware target's operators.
Possible optimizations form a large space, so we use an ML-based cost model to find optimized operators.
Finally, the system packs the generated code into a deployable module.End-User Example.
In a few lines of code, a user can take a model from existing deep learning frameworks and call the TVM API to get a deployable module: import tvm as t # Use keras framework as example, import model graph, params = t.frontend.from_keras(keras_model) target = t.target.cuda() graph, lib, params = t.compiler.build (graph, target, params) This compiled runtime module contains three components: the final optimized computational graph (graph), generated operators (lib), and module parameters (params).
These components can then be used to deploy the model to the target back-end: import tvm.runtime as t module = runtime.create(graph, lib, t.cuda(0)) module.set_input(**params) module.run(data=data_array) output = tvm.nd.empty(out_shape, ctx=t.cuda(0)) module.get_output (0, output) TVM supports multiple deployment back-ends in languages such as C++, Java and Python.
The rest of this paper describes TVM's architecture and how a system programmer can extend it to support new back-ends.
Computational graphs are a common way to represent programs in DL frameworks [3,4,7,9].
Figure 3 shows conv2d relu conv2d relu flatten dense softmax operation inputs dataflow dependency w1 w2 w3 data channels=32, kernel_size=(3,3), padding=(1,1), use_bias=0example attributes shape=(1,10)Figure 3: Example computational graph of a two-layer convolutional neural network.
Each node in the graph represents an operation that consumes one or more tensors and produces one or more tensors.
Tensor operations can be parameterized by attributes to configure their behavior (e.g., padding or strides).
an example computational graph representation of a twolayer convolutional neural network.
The main difference between this high-level representation and a lowlevel compiler intermediate representation (IR), such as LLVM, is that the intermediate data items are large, multi-dimensional tensors.
Computational graphs provide a global view of operators, but they avoid specifying how each operator must be implemented.
Like LLVM IRs, a computational graph can be transformed into functionally equivalent graphs to apply optimizations.
We also take advantage of shape specificity in common DL workloads to optimize for a fixed set of input shapes.
TVM exploits a computational graph representation to apply high-level optimizations: a node represents an operation on tensors or program inputs, and edges represent data dependencies between operations.
It implements many graph-level optimizations, including: operator fusion, which fuses multiple small operations together; constant-folding, which pre-computes graph parts that can be determined statically, saving execution costs; a static memory planning pass, which pre-allocates memory to hold each intermediate tensor; and data layout transformations, which transform internal data layouts into back-end-friendly forms.
We now discuss operator fusion and the data layout transformation.Operator Fusion.
Operator fusion combines multiple operators into a single kernel without saving the intermediate results in memory.
This optimization can greatly reduce execution time, particularly in GPUs and specialized accelerators.
Specifically, we recognize four categories of graph operators: (1) injective (one-to-one map, e.g., add), (2) reduction (e.g., sum), (3) complexout-fusable (can fuse element-wise map to output, e.g., conv2d), and (4) opaque (cannot be fused, e.g., sort).
We provide generic rules to fuse these operators, as follows.
Multiple injective operators can be fused into another injective operator.
A reduction operator can be fused with input injective operators (e.g., fuse scale and sum).
Operators such as conv2d are complex-out-fusable, and we can fuse element-wise operators to its output.
We can apply these rules to transform the computational graph into a fused version.
Figure 4 demonstrates the impact of this optimization on different workloads.
We find that fused operators generate up to a 1.2× to 2× speedup by reducing memory accesses.Data Layout Transformation.
There are multiple ways to store a given tensor in the computational graph.
The most common data layout choices are column major and row major.
In practice, we may prefer to use even more complicated data layouts.
For instance, a DL accelerator might exploit 4 × 4 matrix operations, requiring data to be tiled into 4 × 4 chunks to optimize for access locality.Data layout optimization converts a computational graph into one that can use better internal data layouts for execution on the target hardware.
It starts by specifying the preferred data layout for each operator given the constraints dictated by memory hierarchies.
We then perform the proper layout transformation between a producer and a consumer if their preferred data layouts do not match.While high-level graph optimizations can greatly improve the efficiency of DL workloads, they are only as effective as what the operator library provides.
Currently, the few DL frameworks that support operator fusion require the operator library to provide an implementation of the fused patterns.
With more network operators introduced on a regular basis, the number of possible fused kernels can grow dramatically.
This approach is no longer sustainable when targeting an increasing number of hardware back-ends since the required number of fused pattern implementations grows combinatorially with the number of data layouts, data types, and accelerator intrinsics that must be supported.
It is not feasible to handcraft operator kernels for the various operations desired by a program and for each back-end.
To for yo in range(128): for xo in range (128) ((1024, 1024)) B = t.placeholder ((1024, 1024)) k = t.reduce_axis((0, 1024)) C = t.compute ((1024, 1024) this end, we next propose a code generation approach that can generate various possible implementations for a given model's operators.
TVM produces efficient code for each operator by generating many valid implementations on each hardware back-end and choosing an optimized implementation.
This process builds on Halide's idea of decoupling descriptions from computation rules (or schedule optimizations) [32] and extends it to support new optimizations (nested parallelism, tensorization, and latency hiding) and a wide array of hardware back-ends.
We now highlight TVM-specific features.
We introduce a tensor expression language to support automatic code generation.
Unlike high-level computation graph representations, where the implementation of tensor operations is opaque, each operation is described in m, n, h = t.var('m'), t.var('n'), t.var('h') A = t.placeholder((m, h), name='A') B = t.placeholder((n, h), name='B') k = t.reduce_axis((0, h), name='k') C = t.compute((m, n), lambda y, x: t.sum(A[k, y] * B[k, x], axis=k))result shape computing ruleEach compute operation specifies both the shape of the output tensor and an expression describing how to compute each element of it.
Our tensor expression language supports common arithmetic and math operations and covers common DL operator patterns.
The language does not specify the loop structure and many other execution details, and it provides flexibility for adding hardware-aware optimizations for various backends.
Adopting the decoupled compute/schedule principle from Halide [32], we use a schedule to denote a specific mapping from a tensor expression to low-level code.
Many possible schedules can perform this function.We build a schedule by incrementally applying basic transformations (schedule primitives) that preserve the program's logical equivalence.
Figure 5 shows an example of scheduling matrix multiplication on a specialized accelerator.
Internally, TVM uses a data structure to keep track of the loop structure and other information as we apply schedule transformations.
This information can then help generate low-level code for a given final schedule.Our tensor expression takes cues from Halide [32], Darkroom [17], and TACO [23].
Its primary enhancements include support for the new schedule optimizations discussed below.
To achieve high performance on many back-ends, we must support enough schedule primitives to cover a diverse set of optimizations on different hardware back-ends.
Figure 6 summarizes the operation code generation process and schedule primi- tives that TVM supports.
We reuse helpful primitives and the low-level loop program AST from Halide, and we introduce new primitives to optimize GPU and accelerator performance.
The new primitives are necessary to achieve optimal GPU performance and essential for accelerators.
CPU, GPU, TPU-like accelerators are three important types of hardware for deep learning.
This section describes new optimization primitives for CPUs, GPUs and TPU-like accelerators, while section 5 explains how to automatically derive efficient schedules.
Parallelism is key to improving the efficiency of compute-intensive kernels in DL workloads.
Modern GPUs offer massive parallelism, requiring us to bake parallel patterns into schedule transformations.
Most existing solutions adopt a model called nested parallelism, a form of fork-join.
This model requires a parallel schedule primitive to parallelize a data parallel task; each task can be further recursively subdivided into subtasks to exploit the target architecture's multi-level thread hierarchy (e.g., thread groups in GPU).
We call this model sharednothing nested parallelism because one working thread cannot look at the data of its sibling within the same parallel computation stage.An alternative to the shared-nothing approach is to fetch data cooperatively.
Specifically, groups of threads can cooperatively fetch the data they all need and place it into a shared memory space.
1 This optimization can take advantage of the GPU memory hierarchy and en-able data reuse across threads through shared memory regions.
TVM supports this well-known GPU optimization using a schedule primitive to achieve optimal performance.
The following GPU code example optimizes matrix multiplication.
for xi in range (8):C[yo*8+yi][xo*8+xi] = CL[yi][xi]Figure 7 demonstrates the impact of this optimization.
We introduce the concept of memory scopes to the schedule space so that a compute stage (AS and BS in the code) can be marked as shared.
Without explicit memory scopes, automatic scope inference will mark compute stages as thread-local.
The shared task must compute the dependencies of all working threads in the group.
Additionally, memory synchronization barriers must be properly inserted to guarantee that shared loaded data is visible to consumers.
Finally, in addition to being useful to GPUs, memory scopes let us tag special memory buffers and create special lowering rules when targeting specialized DL accelerators.
DL workloads have high arithmetic intensity, which can typically be decomposed into tensor operators like matrix-matrix multiplication or 1D convolution.
These natural decompositions have led to the recent trend of adding tensor compute primitives [1,12,21].
These new primitives create both opportunities and challenges for schedule-based compilation; while using them can improve performance, the compilation framework must seamlessly integrate them.
We dub this tensorization: it is analogous to vectorization for SIMD architectures but has significant differences.
Instruction inputs are multidimensional, with fixed or variable lengths, and each has different data layouts.
More importantly, we cannot support a fixed set of primitives since new accelerators are emerging with their own variations of tensor instructions.
We therefore need an extensible solution.We make tensorization extensible by separating the target hardware intrinsic from the schedule with a mechanism for tensor-intrinsic declaration.
We use the same tensor expression language to declare both the behavior of each new hardware intrinsic and the lowering rule associated with it.
The following code shows how to declare an 8 × 8 tensor hardware intrinsic.w, x = t.placeholder( (8,8)), t.placeholder( (8,8)) k = t.reduce_axis((0, 8)) y = t.compute( (8,8), lambda i, j:t.sum(w[i, k] * x[j, k], axis=k))def gemm_intrin_lower(inputs, outputs): ww_ptr = inputs [0].
access_ptr("r") xx_ptr = inputs [1].
access_ptr("r") zz_ptr = outputs [0].
access_ptr("w") compute = t.hardware_intrin("gemm8x8", ww_ptr, xx_ptr, zz_ptr) reset = t.hardware_intrin("fill_zero", zz_ptr) update = t.hardware_intrin("fuse_gemm8x8_add", ww_ptr, xx_ptr, zz_ptr) return compute, reset, update gemm8x8 = t.decl_tensor_intrin(y.op, gemm_intrin_lower) declare behavior lowering rule to generate hardware intrinsics to carry out the computationAdditionally, we introduce a tensorize schedule primitive to replace a unit of computation with the corresponding intrinsics.
The compiler matches the computation pattern with a hardware declaration and lowers it to the corresponding hardware intrinsic.Tensorization decouples the schedule from specific hardware primitives, making it easy to extend TVM to support new hardware architectures.
The generated code of tensorized schedules aligns with practices in high-performance computing: break complex operations into a sequence of micro-kernel calls.
We can also use the tensorize primitive to take advantage of handcrafted micro-kernels, which can be beneficial in some platforms.
For example, we implement ultra low precision operators for mobile CPUs that operate on data types that are one-or two-bits wide by leveraging a bit-serial matrix vector multiplication micro-kernel.
This microkernel accumulates results into progressively larger data types to minimize the memory footprint.
Presenting the micro-kernel as a tensor intrinsic to TVM yields up to a 1.5× speedup over the non-tensorized version.
Latency hiding refers to the process of overlapping memory operations with computation to maximize utilization of memory and compute resources.
It requires different strategies depending on the target hardware back-end.
On CPUs, memory latency hiding is achieved implicitly with simultaneous multithreading [14] or hardware prefetching [10,20].
GPUs rely on rapid context switching of many warps of threads [44].
In contrast, specialized DL accelerators such as the TPU [21] usually favor leaner control with a decoupled access-execute (DAE) architecture [35] and offload the problem of fine-grained synchronization to software.
Figure 9 shows a DAE hardware pipeline that reduces runtime latency.
Compared to a monolithic hardware design, the pipeline can hide most memory access overheads and almost fully utilize compute resources.
To achieve higher utilization, the instruction stream must be augmented with fine-grained synchronization operations.
Without them, dependencies cannot be enforced, leading to erroneous execution.
Consequently, DAE hardware pipelines require fine-grained dependence enqueuing/dequeuing operations between the pipeline stages to guar- Figure 9: Decoupled Access-Execute in hardware hides most memory access latency by allowing memory and computation to overlap.
Execution correctness is enforced by low-level synchronization in the form of dependence token enqueueing/dequeuing actions, which the compiler stack must insert in the instruction stream.
antee correct execution, as shown in Figure 9's instruction stream.Programming DAE accelerators that require explicit low-level synchronization is difficult.
To reduce the programming burden, we introduce a virtual threading scheduling primitive that lets programmers specify a high-level data parallel program as they would a hardware back-end with support for multithreading.
TVM then automatically lowers the program to a single instruction stream with low-level explicit synchronization, as shown in Figure 8.
The algorithm starts with a highlevel multi-threaded program schedule and then inserts the necessary low-level synchronization operations to guarantee correct execution within each thread.
Next, it interleaves operations of all virtual threads into a single instruction stream.
Finally, the hardware recovers the compute bound memory bound Hardware Evaluation of Latency Hiding.
We now demonstrate the effectiveness of latency hiding on a custom FPGA-based accelerator design, which we describe in depth in subsection 6.4.
We ran each layer of ResNet on the accelerator and used TVM to generate two schedules: one with latency hiding, and one without.
The schedule with latency hiding parallelized the program with virtuals threads to expose pipeline parallelism and therefore hide memory access latency.
Results are shown in Figure 10 as a roofline diagram [47]; roofline performance diagrams provide insight into how well a given system uses computation and memory resources for different benchmarks.
Overall, latency hiding improved performance on all ResNet layers.
Peak compute utilization increased from 70% with no latency hiding to 88% with latency hiding.Given the rich set of schedule primitives, our remaining problem is to find optimal operator implementations for each layer of a DL model.
Here, TVM creates a specialized operator for the specific input shape and layout associated with each layer.
Such specialization offers significant performance benefits (in contrast to handcrafted code that would target a smaller diversity of shapes and layouts), but it also raises automation challenges.
The system needs to choose the schedule optimizationssuch as modifying the loop order or optimizing for the memory hierarchy -as well as schedule-specific parameters, such as the tiling size and the loop unrolling factor.
Such combinatorial choices create a large search space of operator implementations for each hardware back-end.
To address this challenge, we built an automated schedule optimizer with two main components: a schedule explorer that proposes promising new configurations, and a machine learning cost model that predicts the performance of a given configuration.
This section describes these components and TVM's automated optimization flow (Figure 11).
We built a schedule template specification API to let a developer declare knobs in the schedule space.
The template specification allows incorporation of a developer's domain-specific knowledge, as necessary, when specifying possible schedules.
We also created a generic master template for each hardware back-end that automatically extracts possible knobs based on the computation description expressed using the tensor expression language.
At a high level, we would like to consider as many configurations as possible and let the optimizer manage the selection burden.
Consequently, the optimizer must search over billions of possible configurations for the real world DL workloads used in our experiments.
One way to find the best schedule from a large configuration space is through blackbox optimization, i.e., autotuning.
This method is used to tune high performance computing libraries [15,46].
However, auto-tuning requires many experiments to identify a good configuration.An alternate approach is to build a predefined cost model to guide the search for a particular hardware backend instead of running all possibilities and measuring their performance.
Ideally, a perfect cost model considers all factors affecting performance: memory access patterns, data reuse, pipeline dependencies, and thread- We instead take a statistical approach to solve the cost modeling problem.
In this approach, a schedule explorer proposes configurations that may improve an operator's performance.
For each schedule configuration, we use an ML model that takes the lowered loop program as input and predicts its running time on a given hardware back-end.
The model, trained using runtime measurement data collected during exploration, does not require the user to input detailed hardware information.
We update the model periodically as we explore more configurations during optimization, which improves accuracy for other related workloads, as well.
In this way, the quality of the ML model improves with more experimental trials.
Table 1 summarizes the key differences between automation methods.
ML-based cost models strike a balance between auto-tuning and predefined cost modeling and can benefit from the historical performance data of related workloads.Machine Learning Model Design Choices.
We must consider two key factors when choosing which ML model the schedule explorer will use: quality and speed.
The schedule explorer queries the cost model frequently, which incurs overheads due to model prediction time and model refitting time.
To be useful, these overheads must be smaller than the time it takes to measure per- (2): formance on real hardware, which can be on the order of seconds depending on the specific workload/hardware target.
This speed requirement differentiates our problem from traditional hyperparameter tuning problems, where the cost of performing measurements is very high relative to model overheads, and more expensive models can be used.
In addition to the choice of model, we need to choose an objective function to train the model, such as the error in a configuration's predicted running time.
However, since the explorer selects the top candidates based only on the relative order of the prediction (A runs faster than B), we need not predict the absolute execution times directly.
Instead, we use a rank objective to predict the relative order of runtime costs.C[yo*2+yi][xo*2+xi] += A[k][yo*2+yi] * B[k][xo*2+xiWe implement several types of models in our ML optimizer.
We employ a gradient tree boosting model (based on XGBoost [8]), which makes predictions based on features extracted from the loop program; these features include the memory access count and reuse ratio of each memory buffer at each loop level, as well as a one-hot encoding of loop annotations such as "vectorize", "unroll", and "parallel."
We also evaluate a neural network model that uses TreeRNN [38] to summarize the loop program's AST without feature engineering.
Figure 13 summarizes the workflow of the cost models.
We found that tree boosting and TreeRNN have similar predictive quality.
However, the former performs prediction twice as fast and costs much less time to train.
As a result, we chose gradient tree boosting as the default cost model in our experiments.
Nevertheless, we believe that both approaches are valuable and expect more future research on this problem.On average, the tree boosting model does prediction in 0.67 ms, thousands of times faster than running a real measurement.
Figure 12 compares an ML-based optimizer to blackbox auto-tuning methods; the former finds better configurations much faster than the latter.
Once we choose a cost model, we can use it to select promising configurations on which to iteratively run real measurements.
In each iteration, the explorer uses the ML model's predictions to select a batch of candidates on which to run the measurements.
The collected data is then used as training data to update the model.
If no initial training data exists, the explorer picks random candidates to measure.The simplest exploration algorithm enumerates and runs every configuration through the cost model, selecting the top-k predicted performers.
However, this strategy becomes intractable with large search spaces.
Instead, we run a parallel simulated annealing algorithm [22].
The explorer starts with random configurations, and, at each step, randomly walks to a nearby configuration.
This transition is successful if cost decreases as predicted by the cost model.
It is likely to fail (reject) if the target configuration has a higher cost.
The random walk tends to converge on configurations that have lower costs as predicted by the cost model.
Exploration states persist across cost model updates; we continue from the last configuration after these updates.
A distributed device pool scales up the running of onhardware trials and enables fine-grained resource sharing among multiple optimization jobs.
TVM implements a customized, RPC-based distributed device pool that enables clients to run programs on a specific type of de Table 2: Configurations of all conv2d operators in ResNet-18 and all depthwise conv2d operators in MobileNet used in the single kernel experiments.
H/W denotes height and width, IC input channels, OC output channels, K kernel size, and S stride size.
All ops use "SAME" padding.
All depthwise conv2d operations have channel multipliers of 1.
function remotely, and access results in the same script on the host.
TVM's RPC supports dynamic upload and runs cross-compiled modules and functions that use its runtime convention.
As a result, the same infrastructure can perform a single workload optimization and end-to-end graph inference.
Our approach automates the compile, run, and profile steps across multiple devices.
This infrastructure is especially critical for embedded devices, which traditionally require tedious manual effort for cross-compilation, code deployment, and measurement.
TVM's core is implemented in C++ (∼50k LoC).
We provide language bindings to Python and Java.
Earlier sections of this paper evaluated the impact of several individual optimizations and components of TVM, namely, operator fusion in Figure 4, latency hiding in Figure 10, and the ML-based cost model in Figure 12.
We now focus on an end-to-end evaluation that aims to answer the following questions:• Can TVM optimize DL workloads over multiple platforms?
• How does TVM compare to existing DL frame- To answer these questions, we evaluated TVM on four types of platforms: (1) a server-class GPU, (2) an embedded GPU, (3) an embedded CPU, and (4) a DL accelerator implemented on a low-power FPGA SoC.
The benchmarks are based on real world DL inference workloads, including ResNet [16], MobileNet [19], the LSTM Language Model [48], the Deep Q Network (DQN) [28] and Deep Convolutional Generative Adversarial Networks (DCGAN) [31].
We compare our approach to existing DL frameworks, including MxNet [9] and TensorFlow [2], that rely on highly engineered, vendor-specific libraries.
TVM performs end-to-end automatic optimization and code generation without the need for an external operator library.
We first compared the end-to-end performance of deep neural networks TVM, MXNet (v1.1), Tensorflow (v1.7), and Tensorflow XLA on an Nvidia Titan X. MXNet and Tensorflow both use cuDNN v7 for convolution operators; they implement their own versions of depthwise convolution since it is relatively new and not yet supported by the latest libraries.
They also use cuBLAS v8 for matrix multiplications.
On the other hand, Tensorflow XLA uses JIT compilation.
Figure 14 shows that TVM outperforms the baselines, with speedups ranging from 1.6× to 3.8× due to both joint graph optimization and the automatic optimizer, which generates high-performance fused opera- Table 2 for operator configurations.
We also include a weight pretransformed Winograd [25] for 3x3 conv2d (TVM PT).
tors.
DQN's 3.8 x speedup results from its use of unconventional operators (4×4 conv2d, strides=2) that are not well optimized by cuDNN; the ResNet workloads are more conventional.
TVM automatically finds optimized operators in both cases.To evaluate the effectiveness of operator level optimization, we also perform a breakdown comparison for each tensor operator in ResNet and MobileNet, shown in Figure 15.
We include TensorComprehension (TC, commit: ef644ba) [42], a recently introduced auto-tuning framework, as an additional baseline.
2 TC results include the best kernels it found in 10 generations × 100 population × 2 random seeds for each operator (i.e., 2000 trials per operator).
2D convolution, one of the most important DL operators, is heavily optimized by cuDNN.
However, TVM can still generate better GPU kernels for most layers.
Depthwise convolution is a newly introduced operator with a simpler structure [19].
In this case, both TVM and TC can find fast kernels compared to MXNet's handcrafted kernels.
TVM's improvements are mainly due to its exploration of a large schedule space and an effective ML-based search algorithm.
We evaluated the performance of TVM on an ARM Cortex A53 (Quad Core 1.2GHz).
We used Tensorflow Lite (TFLite, commit: 7558b085) as our baseline system.
Figure 17 compares TVM operators to hand-optimized 2 According to personal communication [41], TC is not yet meant to be used for compute-bound problems.
However, it is still a good reference baseline to include in the comparison.
Table 2 for the configurations of these operators.ones for ResNet and MobileNet.
We observe that TVM generates operators that outperform the hand-optimized TFLite versions for both neural network workloads.
This result also demonstrates TVM's ability to quickly optimize emerging tensor operators, such as depthwise convolution operators.
Finally, Figure 16 shows an end-toend comparison of three workloads, where TVM outperforms the TFLite baseline.
3Ultra Low-Precision Operators We demonstrate TVM's ability to support ultra low-precision inference [13,33] by generating highly optimized operators for fixed-point data types of less than 8-bits.
Lowprecision networks replace expensive multiplication with vectorized bit-serial multiplication that is composed of bitwise and popcount reductions [39].
Achieving efficient low-precision inference requires packing quantized data types into wider standard data types, such as int8 or int32.
Our system generates code that outperforms hand-optimized libraries from Caffe2 (commit: 39e07f7) Baseline was a single-threaded, hand-optimized implementation from Caffe2 (commit: 39e07f7).
C5, C3 are 1x1 convolutions that have less compute intensity, resulting in less speedup by multi-threading.
[39].
We implemented an ARM-specific tensorization intrinsic that leverages ARM instructions to build an efficient, low-precision matrix-vector microkernel.We then used TVM's automated optimizer to explore the scheduling space.
Figure 18 compares TVM to the Caffe2 ultra lowprecision library on ResNet for 2-bit activations, 1-bit weights inference.
Since the baseline is single threaded, we also compare it to a single-threaded TVM version.
Single-threaded TVM outperforms the baseline, particularly for C5, C8, and C11 layers; these are convolution layers of kernel size 1×1 and stride of 2 for which the ultra low-precision baseline library is not optimized.
Furthermore, we take advantage of additional TVM capabilities to produce a parallel library implementation that shows improvement over the baseline.
In addition to the 2-bit+1-bit configuration, TVM can generate and optimize for other precision configurations that are unsupported by the baseline library, offering improved flexibility.
For our mobile GPU experiments, we ran our end-to-end pipeline on a Firefly-RK3399 board equipped with an ARM Mali-T860MP4 GPU.
The baseline was a vendorprovided library, the ARM Compute Library (v18.03).
As shown in Figure 19, we outperformed the baseline on three available models for both float16 and float32 (DCGAN and LSTM are not yet supported by the baseline).
The speedup ranged from 1.2× to 1.6×.
Vanilla Deep Learning Accelerator We now relate how TVM tackled accelerator-specific code generation on a generic inference accelerator design we prototyped on an FPGA.
We used in this evaluation the Vanilla Deep Learning Accelerator (VDLA) -which distills characteristics from previous accelerator proposals [12,21,27] into a minimalist hardware architecture -to demonstrate TVM's ability to generate highly efficient schedules that can target specialized accelerators.
Figure 20 shows the high-level hardware organization of the VDLA architecture.
VDLA is programmed as a tensor processor to efficiently execute operations with high compute intensity (e.g, matrix multiplication, high dimensional convolution).
It can perform load/store operations to bring blocked 3-dimensional tensors from DRAM into a contiguous region of SRAM.
It also provides specialized onchip memories for network parameters, layer inputs (narrow data type), and layer outputs (wide data type).
Finally, VDLA provides explicit synchronization control over successive loads, computes, and stores to maximize the overlap between memory and compute operations.Methodology.
We implemented the VDLA design on a low-power PYNQ board that incorporates an ARM Cortex A9 dual core CPU clocked at 667MHz and an Artix-7 based FPGA fabric.
On these modest FPGA resources, we implemented a 16 × 16 matrix-vector unit clocked at 200MHz that performs products of 8-bit values and accumulates them into a 32-bit register every cycle.
The theoretical peak throughput of this VDLA design is about 102.4GOPS/s.
We allocated 32kB of resources for activation storage, 32kB for parameter storage, 32kB for microcode buffers, and 128kB for the register file.
These on-chip buffers are by no means large enough to provide sufficient on-chip storage for a single layer of ResNet and therefore enable a case study on effective memory reuse and latency hiding.We built a driver library for VDLA with a C runtime API that constructs instructions and pushes them to the target accelerator for execution.
Our code generation algorithm then translates the accelerator program to a series of calls into the runtime API.
Adding the specialized accelerator back-end took ∼2k LoC in Python.
End-to-End ResNet Evaluation.
We used TVM to generate ResNet inference kernels on the PYNQ platform and offloaded as many layers as possible to VDLA.
We also used it to generate both schedules for the CPU only and CPU+FPGA implementation.
Due to its shallow convolution depth, the first ResNet convolution layer could not be efficiently offloaded on the FPGA and was instead computed on the CPU.
All other convolution layers in ResNet, however, were amenable to efficient offloading.
Operations like residual layers and activations were also performed on the CPU since VDLA does not support these operations.
Figure 21 breaks down ResNet inference time into CPU-only execution and CPU+FPGA execution.
Most computation was spent on the convolution layers that could be offloaded to VDLA.
For those convolution layers, the achieved speedup was 40×.
Unfortunately, due to Amdahl's law, the overall performance of the FPGA accelerated system was bottlenecked by the sections of the workload that had to be executed on the CPU.
We envision that extending the VDLA design to support these other operators will help reduce cost even further.
This FPGA-based experiment showcases TVM's ability to adapt to new architectures and the hardware intrinsics they expose.
Deep learning frameworks [3,4,7,9] provide convenient interfaces for users to express DL workloads and deploy them easily on different hardware back-ends.
While existing frameworks currently depend on vendor-specific tensor operator libraries to execute their workloads, they can leverage TVM's stack to generate optimized code for a larger number of hardware devices.High-level computation graph DSLs are a typical way to represent and perform high-level optimizations.
Tensorflow's XLA [3] and the recently introduced DLVM [45] fall into this category.
The representations of computation graphs in these works are similar, and a high-level computation graph DSL is also used in this paper.
While graph-level representations are a good fit for high-level optimizations, they are too high level to optimize tensor operators under a diverse set of hardware back-ends.
Prior work relies on specific lowering rules to directly generate low-level LLVM or resorts to vendor-crafted libraries.
These approaches require significant engineering effort for each hardware back-end and operator-variant combination.Halide [32] introduced the idea of separating computing and scheduling.
We adopt Halide's insights and reuse its existing useful scheduling primitives in our compiler.
Our tensor operator scheduling is also related to other work on DSL for GPUs [18,24,36,37] and polyhedralbased loop transformation [6,43].
TACO [23] introduces a generic way to generate sparse tensor operators on CPU.
Weld [30] is a DSL for data processing tasks.
We specifically focus on solving the new scheduling challenges of DL workloads for GPUs and specialized accelerators.
Our new primitives can potentially be adopted by the optimization pipelines in these works.High-performance libraries such as ATLAS [46] and FFTW [15] use auto-tuning to get the best performance.
Tensor comprehension [42] applied black-box auto-tuning together with polyhedral optimizations to optimize CUDA kernels.
OpenTuner [5] and existing hyper parameter-tuning algorithms [26] apply domainagnostic search.
A predefined cost model is used to automatically schedule image processing pipelines in Halide [29].
TVM's ML model uses effective domainaware cost modeling that considers program structure.
The based distributed schedule optimizer scales to a larger search space and can find state-of-the-art kernels on a large range of supported back-ends.
More importantly, we provide an end-to-end stack that can take descriptions directly from DL frameworks and jointly optimize together with the graph-level stack.Despite the emerging popularity of accelerators for deep learning [11,21], it remains unclear how a compilation stack can be built to effectively target these devices.
The VDLA design used in our evaluation provides a generic way to summarize the properties of TPU-like accelerators and enables a concrete case study on how to compile code for accelerators.
Our approach could potentially benefit existing systems that compile deep learning to FPGA [34,40], as well.
This paper provides a generic solution to effectively target accelerators via tensorization and compiler-driven latency hiding.
We proposed an end-to-end compilation stack to solve fundamental optimization challenges for deep learning across a diverse set of hardware back-ends.
Our system includes automated end-to-end optimization, which is historically a labor-intensive and highly specialized task.
We hope this work will encourage additional studies of end-to-end compilation approaches and open new opportunities for DL system software-hardware co-design techniques.
We would like to thank Ras Bodik, James Bornholt, Xi Wang, Tom Anderson and Qiao Zhang for their thorough feedback on earlier versions of this paper.
We would also like to thank members of Sampa, SAMPL and Systems groups at the Allen School for their feedback on the work and manuscript.
We would like to thank the anonymous OSDI reviewers, and our shepherd, Ranjita Bhagwan, for helpful feedbacks.
This work was supported in part by a Google PhD Fellowship for Tianqi Chen, ONR award #N00014-16-1-2795, NSF under grants CCF-1518703, CNS-1614717, and CCF-1723352, and gifts from Intel (under the CAPA program), Oracle, Huawei and anonymous sources.
