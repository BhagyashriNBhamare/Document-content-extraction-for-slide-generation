To better support interactive applications, individual network operators are decreasing the timers that affect BGP convergence, leading to greater diversity in the timer settings across the Internet.
While decreasing timers is intended to improve routing convergence, we show that, ironically, the resulting timer heterogeneity can make routing convergence substantially worse.
We examine the widely-used Min Route Advertisement Interval (MRAI) timer that rate-limits update messages to reduce router overhead.
We show that, while routing systems with homogeneous MRAI timers have linear convergence time, diverse MRAIs can cause exponential increases in both the number of BGP messages and the convergence time (as measured in "activations").
We prove tight upper bounds on these metrics in terms of MRAI timer diversity in general dispute-wheel-free networks and economically sensible (Gao-Rexford) settings.
We also demonstrate significant impacts on the data plane: blackholes sometimes last throughout the route-convergence process, and forwarding changes, at best, are only polynomially less frequent than routing changes.
We show that these problems vanish in contiguous regions of the Internet with homogeneous MRAIs or with next-hop-based routing policies, suggesting practical strategies for mitigating the problem, especially when all routers are administered by one institution.
The Border Gateway Protocol (BGP) [1], the Internet's interdomain routing protocol, reacts slowly to topology changes.
After a failure, BGP routing messages propagate through a network of tens of thousands of Autonomous Systems (ASes) that must update their routing tables and start forwarding traffic along new paths.
In the meantime, data packets are lost, delayed, or delivered out of order.
A growing body of anecdotal accounts and measurement studies [2]- [4] show that BGP convergence is too slow for interactive applications like VoIP, multi-player games, and financial transactions.
In an effort to reduce convergence time, router vendors and network operators are reducing the timers that control the BGP convergence process.
By limiting the rate of update messages between BGP neighbors, the Minimum Route Advertisement Interval (MRAI) timer plays a critical role in BGP convergence.
The MRAI timer trades off convergence speed against bad behavior during convergence-transient routing and forwarding changes, as well as high overhead on the routers.
Although the BGP RFC recommends a default timer of 30 seconds [1], router vendors and the IETF alike are moving toward lowering or removing this recommendation entirely [5], [6].
Early simulation work [7] supports these decisions, suggesting that smaller timers may indeed reduce convergence time.In this paper, we consider what could potentially happen if the proposed MRAI "improvements" get incrementally deployed, and uncover a problem.
We show that the worstcase convergence time of the network may not get better until lower MRAI settings are universally deployed, while the network's behavior during convergence may get exponentially worse.
That is, incrementally-deployed changes to MRAI, and especially the complete deregulation thereof, can be destructive to both sides of the tradeoff that MRAI addresses-both to convergence time and to behavior during convergence.
Based on our results, we advocate a more careful deployment of MRAI changes.Studying convergence time only makes sense if the routing system converges in the first place.
This property, BGP safety, has been studied in depth over the past decade [8]- [14].
Yet, oscillations rarely happen in practice, most likely because real BGP policies are constrained by the business and performance objectives.
If we consider all networks that converge eventually, the worst-case convergence time looks hopeless-some BGP systems require exponential time to converge [12].
Instead, we focus on "reasonable" networks, constrained by the well-studied "No-Dispute-Wheel" (NDW) condition [10] or by the economic Gao-Rexford conditions (GR) [11].
We study convergence as a function of the number of nodes (in NDW networks) or the depth of the customerprovider hierarchy (in GR networks).
Most analysis of convergence (e.g. [15], [16]) assumes routing changes happen in fair phases, where each BGP participant updates its routing state (i.e., "activates") at least once.
Under the NDW and GR constraints, BGP converges after at most a linear number of phases [15], [16].
Yet, a network can also experience exponentially many routing changes [17], [18].
Both properties are evident in Figure 1, a variation on a construction in [17].
Each node X i has 2 i possible routes to destination d. Node X i 's preferences are indicated by the binary number "spelled out" by the labels on the edges, read from left to right with higher numbers preferred over lower ones.
For example, X 3 prefers the path X 3 X 2 X 1 over the paths X 3 Y 2 X 2 X 1 and X 3 Y 2 X 2 Y 1 X 1 .
With , not yet processed for selection -selected route is announced Φ -waiting to announce route, due to MRAI Fig. 1.
Sawtooth Gadget: exponential path exploration within a linear number of fair phases these preferences, the X i nodes converge on paths using only the "1" edges.In this example, a failure can lead to an exponential number of messages during convergence.
Suppose that the nodes start in the stable state, with the X i routing through "1" edges and each Y i routing through its neighbor X i .
Now, suppose the leftmost "1" edge fails.
The sole stable configuration after this failure has X i using "1" edges all the way to X 1 .
However, with the given activation pattern, an exponential amount of path exploration will occur before convergence, as X 4 explores all nine routes from "1111" to "0111" in decreasing order.
Meanwhile, the nodes activating least frequently, X 1 and Y 1 , need activate only once, making the system converge in a single fair phase -well below the linear upper bound.The exponential path exploration is enabled by a particular timing pattern, with nodes X i and Y i activating more frequently for higher i.
In Figure 1, and in the rest of the paper, darker nodes activate more slowly, and lighter nodes activate faster.
This timing is precisely a distinction in MRAIs, with darker nodes having slower MRAIs than lighter nodes.
With the MRAI timers for X i and Y i set to twice as long as those for X i+1 and Y i+1 , extending the above pattern ensures that X n will explore 2 n−1 paths before convergence.
Both here and throughout, we defer the formal inductive proofs of counter-example behavior to the full version of the paper.
As the recommended MRAI values change, the deployment will naturally proceed incrementally.
Some AS will change immediately to a range of lower MRAI settings, while other ASes continue using the current default configuration.
The uncoordinated deployment will lead to much more heterogeneous MRAI values.
We study BGP convergence behavior as a function of two coarse parameters of MRAI heterogeneity:• Disparity: The ratio r between the highest and lowest MRAI values in use.
• Diversity: The number v of different MRAI settings in use.
To evaluate the impact of MRAI disparity and diversity, we consider the following measures of convergence after a network event:• Convergence time: The time until the BGP system is stable ( ˆ T ).
• Routing updates: The maximum number of routing updates sent along a particular edge (ˆ r), and the number of updates sent system-wide ( ˆ R).
• Forwarding changes: The global number of forwarding changes ( ˆ F ), as a measure of the impact on data traffic.
To set the stage for our results, Section II briefly reviews our model of BGP, directly borrowed from [15] (a somewhat simplified version of the more detailed queue-based model of [10]), and augments it with MRAI timers.
In Section III, we show the relationship between both disparity and diversity of MRAIs and convergence behavior.
In particular, we show that convergence time may not improve as long as the slowest MRAIs don't change.
Section IV extends these results to forwarding behavior.
In Section V, we discuss possible strategies to mitigate these problems and other implications of this work, as well as the limitations of our results and open questions.
To model BGP dynamics, we start with the simple BGP model and notation used in [15].
We model the Internet as a graph G = (N, L) of routers as nodes, interconnected by physical communication links, and independently treat the problem of routing to any particular destination d. Router i has a set P i of possible simple paths to d, and a preference function λ i that has no ties between paths with different next hops.
It may also have import and export policies specifying which routes can be imported from, and exported to, which neighbor.The key change is the introduction of timing, with a perneighbor, per-destination MRAI timer t i assigned to each node.
This contrasts both the arbitrary, adversarial asynchronous activations measured in terms of fair phases, as in [15], and a uniform global timing, as in [16], [19].
The MRAI timer constrains announcement events: If a node i has changed its route selection, and this change will be reflected in an update to its neighbor j (i.e., the new route is non-empty and exportable to j), i sends a corresponding announcement to j just after t i seconds elapse since the last announcement to j, or immediately, if the last announcement to j was more than t i seconds ago.
Route changes triggering withdrawals (i drops the route itself, or picks a route that it will not export to j) always result in immediate withdrawal announcements to j.
We use t * to denote the slowest MRAI in the system, t * = max i t i , and t * to denote the fastest MRAI, t * = min i t i .
Since we aim to study the convergence of a network after some specific event, it is reasonable to assume that, at the time of the initial event, all the MRAI timers have had time to expire since the previous oscillation, and thus the first updated route that any node wants to announce gets announced immediately.
We call this the clean phase model, in contrast to the more general dirty phase model where, at the time of the initial event, some nodes may still be in mid-MRAI delay, due to having recently announced something before the event.
A dirty phase model may also be helpful in studying per-neighbor MRAIs, discussed in Section V. Almost everywhere below, we use, implicitly, the stronger of the two models: all but one of our counter-example results demonstrate bad behavior even under the clean phase restriction; all the positive results (upper bounds on convergence) work even in the more general, dirty phase model.The MRAI heterogeneity measures we study are:• Disparity: r = t * /t * , and• Diversity: v = | i {t i }|For the selection events, we use the approach of [16].
Assume that, once node i has received any particular combination of updates that changes its preferred route, it would notice this, select the route, and be ready to export it, all within some short span of time, s i .
Throughout the paper, we assume that s i is non-zero.
That is, if a node has been waiting to send an update to a neighbor due to an MRAI timer, and the timer expires right as the node receives a new update, the first, soon-to-beoutdated, announcement is still sent out since the node has yet to process the new update.
On the other hand, we assume that s i is fast enough to treat it as negligible relative to the t i settings, since modern routers can process updates far more quickly than the typical MRAI values of 5 and 30 seconds frequently in use today.As established in [15], the above model, captures the relevant features of BGP for studying convergence, while abstracting away some of the details of lower-level processing of update messages as modeled by the well-known Simple Path Vector Protocol model of [10].
In terms of convergence, the only impact of disregarding the lower-level details, and effectively setting s i = is that we discard the possibility of the router's internal processing taking so long that it meanwhile has a chance to send out spurious updates that don't correspond to the best route currently available to it.
These are outsider our scope here and are treated in depth in [20].
We first consider routing convergence when the fastest MRAIs are much faster than the slowest ones, yielding a high MRAI disparity r.
We start with what appear like crude upper bounds directly derived from [15], and then use a delicate combination of some previously known BGP gadgets and some new constructions to show that these bounds are actually tight.In [15]'s terminology, each "fair phase" takes at most max i s i + t i ≈ t * time.
Any node i that, at the start of the phase, is about to change its route selection will do so within s i after the start, and will announce it within t i after that.
Any other node may as well be "activated" at the beginning of the phase, both for selection and for announcement, and nothing will happen there.These bounds follow directly: Corollary 1 (from 4.2 and 4.3 of [15]):NDW systems converge inˆTinˆ inˆT = O(nt * ) = O(nrt * ) time.
Each edge (i, j) will see at most O(nrt * /t i ) ≤ O(nr)updates in that time, ensuringˆrensuringˆ ensuringˆr = O(nr) and thus at mostˆRmostˆ mostˆR = O(nmr) routing updates sent system-wide.
Since node i can receive new information only O(nr) times from each of its neighbors, it would only have O(nr deg(i)) opportunities to change its forwarding, yieldingˆFyieldingˆ yieldingˆF = O(nr deg(i)) = O(nmr).
By parallel arguments for GR networks,ˆ T = O(αrt * ), ˆ r = O(αr), ˆ R = O(αmr), andˆFandˆ andˆF = O(αmr).
These bounds appear crude.
The time bound derives from, effectively, just assuming that everyone's MRAI is as slow as the slowest one.
The behavior during convergence bounds derive effectively from assuming that almost everyone's MRAI is as fast as the fastest one, and the maximum possible number of control and data plane events happens in the time allowed by the time bound.Surprisingly, we find that these bounds are asymptotically tight.
This establishes that the worst-case convergence duration in the network won't improve until even the slowest MRAI is sped up, while the number of control and data plane events can indeed be amplified linearly by a large disparity between the fastest and slowest nodes.
Formally:Theorem 2: In NDW networks with n nodes and m edges, in the worst case,ˆ T = Θ(nrt * ), ˆ r = Θ(nr), ˆ R = Θ(nmr), andˆFandˆ andˆF = Θ(nmr).
In GR networks with α levels and m edges, the same bounds apply:ˆ T = Θ(αrt * ), ˆ r = Θ(αr), ˆ R = Θ(αmr), andˆFandˆ andˆF = Θ(αmr).
The worst-case behaviors for all of these can occur in the same network.Proof sketch: With the upper bounds already established above, we can demonstrate a family of GR networks parameterized by (1) α or n, and (2) m = Ω(n) that match all of the bounds simultaneously.
Consider the "Christmas tree" gadget shown in Figure 2.
The node set contains the destination d and 4 other groups of nodes:• a "trunk" of m/4n nodes T j ; and the remaining n−m/4n nodes split equally into 5 groups of k: • a "base" group of k pairs of nodes S i and R i ,S 4 R 3 S 3 R 2 S 2 R 1 S 1 d X 1 Y 1 X 2 Y 2 X 3 Y 3 X 4 Y 4 B 4 B 3 B 2 B 1 T 1 T 2 T 3 1 0 1 0 1 0 e e Fig. 2.
A "Christmas Tree" gadget: worst-case behavior with disparity r• a "stump" group of k pairs of left and right nodes X i and Y i , and • a "branches" group of k nodes B i .
The poor behavior of this system arises from the interaction between the "base" and the "stump" groups.The "base" group uses a synchronous variation on the Sawtooth Gadget of Fig. 1.
It guarantees that, after e fails, Θ(nt * ) time passes until all S i 's confirm that they can only route through e .
At it * seconds after e fails, S i+1 will announce that it can only route through e , and then S i+2 announces a route through R i+1 leading to e, right as R i+1 announces to it that R i+1 , too, is now routing through e .
The MRAI of S i+2 will then require another t * interval until the news spreads further right.In the "stump" group, isomorphic to the Sawtooth Gadget of Figure 1 with its disparate MRAIs, the X i 's prefer any route through e over any route through e , and within each category prefer to go through the fewest S i 's, and, for each fixed S i , use the same lexicographical ordering as in the Sawtooth Gadget.
Each time a new base node announces that it now routes via e , the stump performs the full pattern of the Sawtooth Gadget.
The fastest nodes, at the top, make Θ(r) forwarding changes, and send Θ(r) announcements out, for every one announcement that the "stump" receives from the "base".
The base thus ensures that Θ(n) phases will happen, and, crucially, that each phase will involve the worst possible behavior in the stump, yielding Θ(kr) = Θ(nr) messages on, e.g., edge (X k−1 , X k ), and X k performs Θ(nr) forwarding changes.
The "branches" group yields a tight bound on the global count of routing updates and forwarding changes ( ˆ R andˆFandˆ andˆF ) in sparse graphs, and the trunk lets us parameterizê F andˆRandˆ andˆR by m. With the arrows set to point from providers to customers, this network obeys the Gao-Rexford constraints, with α = Θ(n), yielding the matching Gao-Rexford bounds, too.
The construction of the previous section notably requires a broad variety of values for the MRAI timer.
Both the IETF and major router vendors could potentially maintain the status quo and keep the number of different MRAI values in common use relatively small, via recommendations and standardized default settings, respectively.
We now establish that this is indeed advisable, to ensure good worst-case behavior under convergence.
That is, we show that the number of control and data plane updates during convergence can skyrocket exponentially as a function of MRAI diversity v (the number of different MRAI values in use):Theorem 3: In an NDW network with n nodes that use v ≤ n/2 distinct MRAI values among them, the number of control and data plane updates ( ˆ F andˆRandˆ andˆR) can be (n/v) Ω(v) .
If the network is Gao-Rexford, with α levels and v ≤ α/2, ˆ F andˆR andˆ andˆR can be (α/v) Ω(v) .
For higher diversity, v ≥ n/2 in NDW networks and v ≥ α/2 in GR networks, the behavior remains exponential, withˆFwithˆ withˆF andˆRandˆ andˆR both bounded by 2 Ω(n) for NDW and 2 Ω(α) for GR.Proof sketch: The diversity-based lower bounds are achieved by the "Chain" gadget in Fig. 3, which amalgamates the Sawtooth Gadget and the synchronous behavior of the Christmas Tree gadget's base in a different way, by replacing each "tooth" of the Sawtooth Gadget with a copy of the "base".
Now, each "link" of the chain, like the "base" above, shares MRAI value t i and spends n/v "ticks" of the t i timer to count down its "digit" from n/v to 0.
With t i being n/v times slower than t i+1 , this lets the preference functions produce exponential path exploration by simulating counting down vdigit numbers in base n/v rather than base 2,The fastest node, X v , will receive (n/v) v routing updates, each of which will trigger a forwarding change; the routing and forwarding events at this node will asymptotically dominate the global sum over such events, ensuring thatˆFthatˆ thatˆF andˆRandˆ andˆR are both (n/v) Ω(v) , and, since α = n here, (α/v) Ω(v) .
In the degenerate case of almost unique MRAIs, v > n/2, or if v > α/2 in a GR network, using the chain gadget for v = n/2, and adding miniscule noise to some of the t i 's will not change the performance of the system while keeping the Ω(2 n ) and Ω(2 α ) bounds.CanˆRCanˆ CanˆR andˆFandˆ andˆF get even worse than this with diverse MRAIs?
We show that the above example is fairly tight.
That is, NDW networks with MRAI diversity v won't get substantially asymptotically worse:Theorem 4: In any NDW network with v distinct MRAIs, the number of routing updates and forwarding changes is no worse than (n/v 1/3 ) O(v) .
Let us first split the nodes into "groups" G 1 , . . . , G v by distinct MRAI value, in order, so that G 1 are the nodes with the fastest MRAI, G v are those with the slowest, etc.
For each i, we consider what happens in the interval between two adjacent announcements by any "slow" nodes, defined, relative to i, as the set H i = {d}∪ v j=i+1 G j .
We call such an interval of time an i + 1-interval.
From the viewpoint of the nodes in all of the "fast" nodes, defined as the set G 1,i = i j=1 G j , the slow nodes have announced a particular route before the i+ 1-interval, and don't announce anything again for the rest of the i + 1-interval, as if that route is "fixed" as a stable selection.Lemma 3.1: Within an i + 1-interval, routing changes can happen for at most |G 1,i | i-fair phases, defined as sequences where each node in G 1,i selects and announces to each neighbor at least once.Proof of lemma: The proof requires "steinerizing" the inductive argument of [15].
Their result was an induction that grew a routing tree from the destination.
Here, we will consider any subsets of nodes with "fixed" routes, and have the induction grow a forest of route prefixes from the slow nodes, whose announced but possibly outdated routes are effectively arbitrary route suffixes steadily available for use by fast nodes.Inductively, suppose some strict subset of fast nodes ∅ ⊆ S ⊂ G 1,i is "steady", i.e. (1) each s ∈ S has picked a route that follows only other steady nodes to a slow node (i.e. a route that starts with s, s 1 , s 2 , . . . , s k , z, with s j ∈ S and z ∈ H i ), and (2) this route is consistent with the choices of all the steady nodes that appear before the first slow node on the path (i.e., for all j, s j also picks s j , . . . , s k , z), and with the route announced by the first slow node z.Given a set of steady and slow nodes and their selected routes, we say that a route v 1 , v 2 , . . . , v l = d that starts at any fast node has a consistent fast prefix if it is consistent with the routes selected by its first slow node and any steady nodes that come before it (if, for all k < j, v k ∈ H i , and v j ∈ S ∪ H i , then v j must have selected v j , . . . , v l ).
Note that, by construction, up until the first slow node, steady nodes may only be followed by other steady nodes.Pick an arbitrary fast, non-steady nodev 1 ∈ G 1,i \ S. Let P 1 = (v 1 = v 1 1 , v 1 2 , .
.
.
, d) be v 1 's highest-preferred path among all paths that have a consistent fast prefix, with v 1 j being the first slow or steady node on that path.
Let v 2 = v 1 j−1 , and consider its most preferred path with a consistent fast suffix.
Continue this process until reaching the sequence of v j s first loops, producing the first pair v a = v b , for b < a.
The loop is guaranteed to happen since the node set is finite.
If a > b + 1, the loop has 2 or more nodes.
Consider then each step in the resulting loop of v j 's.
The suffix of P j that starts at v j+1 is available to v j+1 , and has an (empty) consistent fast prefix, but v j+1 prefers a different path P j+1 .
These suffixes thus form the spoke paths of a dispute wheel, with the matching prefixes forming the rims, violating the NDW condition.Thus, a = b + 1, that is, there is a node v a which, with all the nodes in S ∪ H i having selected their paths, most prefers a path that goes directly to a node in S ∪H i , and has a consistent fast prefix, thus allowing us to add v a to S to complete the induction.Proof of Theorem 4: Denote by m i the number of edges with an endpoint in G i , ensuring i m i ≤ 2m; we disregard the degenerate case of m i = 0.
The global bounds ensure at most n fair phases before convergence, so the slowest nodes, those in G v , will each make at most n = |G 1,v | announcements on each of their edges, yielding at most m v · |G 1,v | + 1 v-intervals.
Within each i + 1-interval, at most m i · |G 1,i | announcements by the G i nodes will yield at most that many, plus 1 i-intervals.
For v ≥ 2, by induction, the number of route announcements, upper bounded by the number of 1-intervals, is:ˆ R ≤ v i=1 (1 + m i |G 1,i |) ≤ (n + 1) v v i=1 m i ≤ (n + 1) v 2m v v ≤ n v 1/3 O(v)For the remaining case of v = 1, the claim comes directly from Corollary 1.
What about convergence behavior in diverse Gao-Rexford networks?
In completely homogeneous networks, with v = r = 1, Corollary 1 guarantees thatˆRthatˆ thatˆR = O(αm).
This is sensible: it represents an average load of O(α) routing messages on any given edge (in regard to routes to any given destination d), a very moderate bound.
However, with more diversity, just carrying over the proof from Theorem 4 yields a bound ofˆRofˆ ofˆR ≤ (αm/v) O(v) .
This threatens to disrupt one of the most optimistic previous bounds known on BGP convergence.
Could it be that, with any amount of diversity, Gao-Rexford networks can have average control-plane traffic per edge, per-destination scale with m, not just with α as in Theorem 3?
BGP is already infamous for scaling linearly with the number of destination prefixes, but such a scenario would create a threat of superlinear control-plane load growth as the network scales.
Or is there a tighter upper bound that prevents this?The following result gives some concrete cause for worry, at least in the so-called dirty phase model (defined in Section II):Theorem 5: For a fixed α and v, there are Gao-Rexford networks of arbitrary size n where per-edge average number of routing messages until convergence can scale as n Ω(min{α,v}) , when converging in response to a network event occurring while some MRAI timers are still running.Proof sketch: The counter-example is the Sharktooth gadget in Fig. 4, with a fixed number, k = min{2α−2, v −1}, of "tooth columns" (k = 3 above), all of which grow linearly with n grows.
Let t i = t i+1 · n/k.
If, when the leftmost 1 edge fails, each tooth column has its teeth's timers spread out evenly, with the MRAI of tooth j in column i expiring in jt i /k seconds, we can show that all possible routes ending in the 1 edge will be explored, while the MRAIs remain "evenly out of phase".
The dirty phase model is admittedly not as strong for modeling the response to a single event, since it requires some recent previous event to have set the MRAI timers in motion.
On the other hand, it is more reasonable in the setting of per-edge MRAIs, addressed in Section V. Also, no upper-bound techniques we have found thus far succeed at differentiating worst-case dirty-phase behavior from worstcase clean-phase behavior, further indicating that this problem may indeed extend to clean-phase counterexamples.
We leave this question as one of the important open problems of this work.Lastly, in our discussion of MRAI diversity, we have thus far omitted its impact on convergence time.
In a sense, convergence time, too, grows "exponentially" with v: the Chain gadget hasˆThasˆ hasˆT = t * · (n/v) Ω(v) .
But the exponential dependence on v in terms of the fastest MRAI is not as relevant to the practical concern of incrementally deploying speedups of MRAIs.
As a function of "unimproved", slowest MRAIs, convergence time is still linear with no exponential dependence on v. Thus, the conclusion here is that, with incrementally deployed diversification of MRAIs, convergence time won't necessarily get better, while the other side of the MRAI tradeoff, control-and data-plane activity, can get exponentially worse.
There is no doubt that the gadgets above are not typical network designs.
As with any worst-case analysis, we need to consider whether the worst case behavior is limited to artificial situations, with "reasonable" networks exhibiting none of the worst-case problems.
Since our goal is to capture the asymptotic worst-case problems that may arise as the network evolves, we should not fix our attention on a particular measured network graph, or a particular synthetic network model, and we must instead consider what properties all realistic networks, current and future, are expected to have.The most prominent potential culprit for the "artificiality" of both of the above gadgets is the "counting in k-ary" preference function required for the combinatorial path exploration.
But, it turns out, this exotic-sounding preference function is isomorphic to a number of rather reasonable BGP preferences, involving each node optimizing a quantity similar to weighted shortest path over some globally-known measure.As discussed in [21], this family of "semi-ring" preference functions can correspond to a number of relevant network phenomena: optimizing expected latency, optimizing packet loss rates, etc.
Formally: Theorem 6: The local preferences of all nodes in the Christmas Tree and Chain gadgets as shown in Theorems 2 and 3 are identical to an environment where each node's local preference over paths optimize a combination of per-edge quantities that form a semi-ring.
Proof sketch: The relevant weights are shown in Figure 5 (unspecified weights are zero).
These can be thought of as, e.g., per-edge latencies, the sum of which each node tries to optimize, but this construction is also isomorphic to other policies that optimize over semi-rings.
See [21] for a wide range of common examples.Even though the preference functions are reasonable, there are other atypical features that enable the exponential path exploration: the paths explored contain many hops and the preference function is very "fine-grained", i.e. some nodes make very fine distinctions among a very large set of options.
However, neither of these features prevents exponentially bad dependence on v:Theorem 7: Even a GR network with only a constant number of allowed paths, all of constant length can produce an exponential number of routing updates and forwarding changes as a function of v before convergence, in terms of both n and α.
That is, ˆ F andˆRandˆ andˆR are both lower bounded by 2 Ω(v) , where v = Θ(n) = Θ(α).
6) by linking v copies of a cross-like subnetwork into a chain.
For each permitted path at node X i (and Y i ), its next-hop is either X i−1 or Y i−1 , its "next-next-hop" is either X i−2 or Y i−2 , and its final hop is to the destination, for a total of 4 permitted paths, all of length 3.
With the arrows set to point from, e.g., providers to customers, the gadget obeys the GaoRexford constraints, with α = Θ(n).
To accommodate the update sequences we describe below, each pair (X i , Y i ) has a different MRAI timer value, and thus v = Θ(n) = Θ(α).
The exponential number of routing updates and forwarding changes that can occur in the Braid gadget are the result of a particular sequence of updates that exploits an "amplification" property of the network.
More precisely, there is a sequence of updates at each pair of nodes (X i , Y i ) such that, whenever the sequence occurs, it causes the sequence of updates for the pair (X i+1 , Y i+1 ) to occur twice consecutively, resulting in 2 Ω(v) total updates throughout the network.
Moreover, each update actually changes some node's next-hop, so both control and data plane activity are exponential in v.
The Sawtooth and Chain gadgets each have a similar amplification property, but in those gadgets the sequence of updates could be described by the incrementing of a k-ary number.
The situation for the Braid gadget is more complicated, and is best described by introducing some specialized terminology.We say that X i is using a straight path if the next-hop of its current path is X i−1 , and say it is using a cross path if the next-hop is Y i−1 .
We define straight and cross paths for Y i similarly.
A braid is a sequence of updates at a pair of nodes (X i , Y i ) such that the path types for these nodes change according to the following pattern: Path type stepX i Y i t 1 straight straight t 2 cross straight t 3cross cross t 4 cross straight t 5 straight straight These path changes, visualized, resemble the braiding of a rope or ponytail.
The key to the proof is establishing the following fact: It is possible to assign preference functions to each node so that, whenever a braid occurs at the pair (X i , Y i ), it generates a sequence of update messages which cause a braid to occur twice consecutively at the pair (X i+1 , Y i+1 ).
There is one important complication that we have not addressed: The pair (X 2 , Y 2 ) have no braids occurring "down- Fig. 7.
The "Frog Eyes" gadget stream" from their position, so to complete the gadget, we must insert a subnetwork at the rightmost end of the gadget, between the pair (X 1 , Y 1 ) and the destination d, that causes a single braid to occur at (X 2 , Y 2 ) upon the failure of some link to the destination.
However, in the interests of a cleaner diagram, and because it adds little to the understanding of the gadget, the description of this subnetwork has been omitted.d P C R R G L L G Forwarding changes can have a substantial impact on the system by causing out-of-order packet delivery, and sometimes introducing transient packet drops.
However, the worst-case scenario for the data plane while the system is converging in response to a network event is far worse:Theorem 8: After a network change, even in a Gao-Rexford network, even if no node ever becomes physically disconnected from d, there exists a network which may still forward a node's traffic to a black hole for the entire worst possible duration of control-plane convergence, Θ(nrt * ).
Proof sketch: The gadget in Fig. 7 is actually more general.
It allows us to transform any gadget G like the ones above 1 , and create black holes that last as long as the worstcase control-plane convergence in G does.Arrows point from providers to customers, and edges without arrows are peer arrows, in the Gao-Rexford sense [11].
G permits a path from L to L and from R to R that follows provider-to-customer links only.
Thus, at first, L and R route through their copies of G, and down through L and R, then through C.
If the (C, D) link goes down, L and R no longer have a customer route, and prefer to take the peer route to R and L respectively, over their provider routes via P or d.
After that, L and R will perform whatever path exploration G creates before exhausting their options for customer routes, and switching to a provider-learned route, which they do not export over their peer links to R and L, forcing the latter to take a provider route.
For as long as G's path exploration is ongoing, L forwards packets to R , R , via G, to R, R to L , and L , via G, to L, creating a black hole.Inserting the "Christmas Tree base" pattern for G, for instance, yields a blackhole lasting for Θ(nrt * ) = Θ(αrt * ) time.
Recall that a routing update implies that a node has changed its path, while a forwarding change implies something stronger: a node has actually switched its next-hop.
Since only forwarding changes impact the data plane, exponential lower bounds on the number of routing updates in a network are not necessarily cause for concern.
However, all of the exponential bounds in the previous sections applied to both routing updates and forwarding changes.
Was this a coincidence, or indicative of a general phenomenon?
The next theorem shows that the number of routing updates and forwarding changes are indeed tightly related, and can never be exponentially far apart; specifically, they are always within a factor of n 2 of each other.
Thus any exponential characterization of control plane convergence (a bound onˆRonˆ onˆR) also exponentially bounds forwarding plane convergence ( ˆ F ), and vice-versa.
Theorem 9: In a network with n nodes,ˆ F ≤ ˆ R ≤ n 2 ˆ F .
Proof:Since a routing update occurs whenever there is a forwarding change, we immediately havê F ≤ ˆ R.
Now define a frozen phase to be any sequence of routing updates in which no node changes its next-hop.
We will prove that no node can change paths more than n times during a frozen phase.
Since there are n nodes, this implies the theorem.Fix a frozen phase, and consider a node v 1 .
Let F be the longest acyclic path (v 1 , v 2 , · · · , v k ) such that v i+1 is the nexthop of v i during the phase, for all i.
So F is (a prefix of) the forwarding path of packets that originate at v 1 .
Because F is acyclic, the length of F is at most n. Define the agreement length of F to be the length of the longest prefix F of F such that the path used by each node v on F is a suffix of some common path P .
For example, after the first time v 1 changes paths during the phase, since we know v 1 and v 2 do not change their next-hops during the phase, the agreement length of F will be at least 2.
In general, every time v 1 changes paths during the phase, the agreement length of F increases by at least 1.
And the agreement length of F cannot exceed n.
One approach to limiting forwarding changes is to place global restrictions on the policies that nodes can use to select and filter routes, even beyond what is needed to ensure BGP safety.
One commonly studied type of restriction is to demand that each node use a next-hop import policy, i.e. each node's preference for a path depends only on the path's next-hop.
In limited cases, this can help: During instabilities in which there are only path announcements, and if all nodes have a next-hop import policy, the number of forwarding changes is upper bounded by a polynomial in n [22].
However, during instabilities in which there are path withdrawals, the situation is essentially hopeless: There can be exponentially many forwarding changes even if every node uses a shortest-path-first rule [17] to select routes.
In fact, we can extend this result to the case where every node uses a next-hop import policy.
The proof, which is omitted for lack of space, is another example of our "amplification" technique for leveraging MRAI diversity to construct exponentially long update sequences, but applied to the "Trapezoid" gadget described in [17].
Mitigation recommendations: The results above clearly show that network-wide consistency in MRAIs significantly improves the worst-case guarantees we can make about BGP convergence.
We believe that our theoretical worst-case examples are worth considering as a practical matter.
This is not because we expect these structures to appear verbatim in practice, but because they may suggest plausible patterns in the network that could substantially degrade performance, even if the real network never approaches the true worst case.
To that extent, we believe it worthwhile to evaluate the counterexamples in detailed simulation to measure the likelihood of the worst-case chain of events.
Also, we have yet to identify network properties that curtail bad convergence, and are characteristic of the real Internet, but not our counterexamples.
The search for such properties would benefit from examining worst-case examples, with an eye to evaluating the realism of proposed properties via measurement studies.We agree that the status quo of MRAI defaults is untenable, since the current default values are clearly large enough to cause substantial convergence delays.
The deployment of any MRAI changes will necessarily be incremental, but, in light of Theorems 4 and 5, we recommend updating the recommended MRAI default, rather than de-standardizing it completely.
If router vendors and operators do not substantially deviate from the new recommended default, the difference in worst-case convergence behavior may be like the difference between, e.g., quadratic scaling of path exploration versus exponential scaling, or perhaps, even more dramatically, the difference between BGP message loads scaling as a function of customerprovider hierachy height (≈ 5), versus scaling linearly or worse as a function of the network size (≈ 40000).
More practical is the question of MRAI settings within a single autonomous system, or multiple ASes run by the same institution.
In regard to convergence, the iBGP route reflector hierarchy effectively mirrors the behavior of GaoRexford eBGP systems [13], [14], so we fully expect that the same bounds would apply to route information propagating through an iBGP system with route reflectors.
But a single AS, unlike the IETF, can indeed enforce homogeneous timer settings by "flag day" changes within its network, and our results are thus a strong and practical recommendation that any single AS update its MRAI settings homogeneously.We have thus far cast the motivations in terms of default MRAI settings.
Anecdotal accounts from operators suggest that, indeed, most operators do not alter the vendor-specified default timer settings, and the small number of popular router vendors thus roughly upper-bounds the diversity of timer settings.
We thus leave open the consequently relevant question of what can happen to convergence if a just a small fraction of individual router operators change the timers, while the vast majority of the network retains the defaults.
Conversely, also open is whether a small group of routers or ISPs can collaboratively set their timings to improve networkwide behavior, assuming the collaborators are in positions of influence in the network (e.g., some or all Tier 1s).
Limitations: Our analysis pertains to MRAI timers as recommended in the RFC [1]: a separate timer for announcements about each destination prefix over each BGP session with a neighbor.
In practice, many implementations only permit cruder MRAI timers, which apply to any announcements sent to a particular next hop.
This means that the routing convergence processes for two different destinations are no longer independent, with slow convergence for one destination producing MRAI delays for all the others.
The singledestination, dirty-phase model, as used in Theorem 5 is a solid starting point for analyzing how two destinations' convergence processes may interfere with each other in the worst case.
But it's entirely possible that even more dire worst case behavior will arise from fully general interactions between convergence processes to several destinations.
As noted in Section II, we also do not treat the corner case of MRAI being set to zero, as currently done by default by some vendors, or MRAI set to be faster than the time it takes for incoming updates to be processed.
The convergence in that case can be modeled by asynchronous results like [15], [17], or, worse, if updates can be released mid-processing, the system may engage in qualitatively different long-term behaviors, treated in [20].
We also forego entirely the question of jitter, the required randomization of MRAI values by each router [1].
The full paper shows that all of our upper bounds remain intact under jitter.
The lower-bound counter examples also remain valid, in that stochastic jitter could end up be effectively equal at all routers, simulating a jitter-less network.
That is exponentially improbable, but we expect that a stochastic analysis of our worst-case examples will retain the asymptotic behavior, even in expectation.
We conjecture that, roughly, all our counterexamples (except Sharktooth) require at most "one direction" of exact timing (if jitter causes event A to occur before B, the counterexample may "skip a beat", but if B is before A, it will perform as above); and that combining these effects will at most halve the exponent of the exponential results, but confirming this rigorously is an open question.Why MRAI?
: Lastly, a worthwhile question to consider is, why MRAI?
This timer was introduced to enable a practicable and desirable tradeoff, allowing operators to lower controlplane load by potentially reducing convergence time.
But MRAI is clearly a simple and crude way to implement this tradeoff, with a single timer value for a node, or for an edge, with no regard to what update is being delayed by it.
There has been some implementation and simulation work proposing various more sophisticated alternatives [23], [24].
We believe that some of our negative results may well be a peculiar artifact of MRAI timers as such, not a general property of all tools that enable the control-plane load vs time tradeoff.
We thus think that, before deploying any of the new proposals, it's worth evaluating them in the worst-case framework we presented, starting with the many badly-behaved examples above.It may well be that even a simple adjustment to make MRAI timers adaptive, based on the path being announced, may mitigate much of the worst-case convergence problems.
We note in particular that all of our examples of bad behavior require nodes further from the destination to be updating much faster than those that are closer.
If each node was aware of the timer settings of others on the path, it could resolve to not update faster than any node ahead of it on the path being announced.
We conjecture that such an approach may yield a polynomial upper bound on control and data plane activity.
