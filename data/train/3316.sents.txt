NetVM brings virtualization to the Network by enabling high bandwidth network functions to operate at near line speed, while taking advantage of the flexibility and customization of low cost commodity servers.
NetVM allows customizable data plane processing capabilities such as firewalls, proxies, and routers to be embedded within virtual machines, complementing the control plane capabilities of Software Defined Networking.
NetVM makes it easy to dynamically scale, deploy, and reprogram network functions.
This provides far greater flexibility than existing purpose-built, sometimes proprietary hardware, while still allowing complex policies and full packet inspection to determine subsequent processing.
It does so with dramatically higher throughput than existing software router platforms.
NetVM is built on top of the KVM platform and In-tel DPDK library.
We detail many of the challenges we have solved such as adding support for high-speed inter-VM communication through shared huge pages and enhancing the CPU scheduler to prevent overheads caused by inter-core communication and context switching.
NetVM allows true zero-copy delivery of data to VMs both for packet processing and messaging among VMs within a trust boundary.
Our evaluation shows how NetVM can compose complex network functional-ity from multiple pipelined VMs and still obtain through-puts up to 10 Gbps, an improvement of more than 250% compared to existing techniques that use SR-IOV for vir-tualized networking.
Virtualization has revolutionized how data center servers are managed by allowing greater flexibility, easier deployment, and improved resource multiplexing.
A similar change is beginning to happen within communication networks with the development of virtualization of network functions, in conjunction with the use of software defined networking (SDN).
While the migration of network functions to a more software based infrastructure is likely to begin with edge platforms that are more "control plane" focused, the flexibility and cost-effectiveness obtained by using common off-the-shelf hardware and systems will make migration of other network functions attractive.
One main deterrent is the achievable performance and scalability of such virtualized platforms compared to purpose-built (often proprietary) networking hardware or middleboxes based on custom ASICs.Middleboxes are typically hardware-software packages that come together on a special-purpose appliance, often at high cost.
In contrast, a high throughput platform based on virtual machines (VMs) would allow network functions to be deployed dynamically at nodes in the network with low cost.
Further, the shift to VMs would let businesses run network services on existing cloud platforms, bringing multiplexing and economy of scale benefits to network functionality.
Once data can be moved to, from and between VMs at line rate for all packet sizes, we approach the long-term vision where the line between data centers and network resident "boxes" begins to blur: both software and network infrastructure could be developed, managed, and deployed in the same fashion.Progress has been made by network virtualization standards and SDN to provide greater configurability in the network [1][2][3][4].
SDN improves flexibility by allowing software to manage the network control plane, while the performance-critical data plane is still implemented with proprietary network hardware.
SDN allows for new flexibility in how data is forwarded, but the focus on the control plane prevents dynamic management of many types of network functionality that rely on the data plane, for example the information carried in the packet payload.This limits the types of network functionality that can be "virtualized" into software, leaving networks to continue to be reliant on relatively expensive network appliances that are based on purpose-built hardware.Recent advances in network interface cards (NICs) allow high throughput, low-latency packet processing using technologies like Intel's Data Plane Development Kit (DPDK) [5].
This software framework allows end-host applications to receive data directly from the NIC, eliminating overheads inherent in traditional interrupt driven OS-level packet processing.
Unfortunately, the DPDK framework has a somewhat restricted set of options for support of virtualization, and on its own cannot support the type of flexible, high performance functionality that network and data center administrators desire.To improve this situation, we have developed NetVM, a platform for running complex network functionality at line-speed (10Gbps) using commodity hardware.
NetVM takes advantage of DPDK's high throughput packet processing capabilities, and adds to it abstractions that enable in-network services to be flexibly created, chained, and load balanced.
Since these "virtual bumps" can inspect the full packet data, a much wider range of packet processing functionality can be supported than in frameworks utilizing existing SDN-based controllers manipulating hardware switches.
As a result, NetVM makes the following innovations:1.
A virtualization-based platform for flexible network service deployment that can meet the performance of customized hardware, especially those involving complex packet processing.
2.
A shared-memory framework that truly exploits the DPDK library to provide zero-copy delivery to VMs and between VMs.
3.
A hypervisor-based switch that can dynamically adjust a flow's destination in a state-dependent (e.g., for intelligent load balancing) and/or data-dependent manner (e.g., through deep packet inspection).
4.
An architecture that supports high speed inter-VM communication, enabling complex network services to be spread across multiple VMs.
5.
Security domains that restrict packet data access to only trusted VMs.We have implemented NetVM using the KVM and DPDK platformsâˆ’all the aforementioned innovations are built on the top of DPDK.
Our results show how NetVM can compose complex network functionality from multiple pipelined VMs and still obtain line rate throughputs of 10Gbps, an improvement of more than 250% compared to existing SR-IOV based techniques.
We believe NetVM will scale to even higher throughputs on machines with additional NICs and processing cores.
This section provides background on the challenges of providing flexible network services on virtualized commodity servers.
Software routers, SDN, and hypervisor based switching technologies have sought to reduce the cost of deployment and increase flexibility compared to traditional network hardware.
However, these approaches have been stymied by the performance achievable with commodity servers [6][7][8].
These limitations on throughput and latency have prevented software routers from supplanting custom designed hardware [9][10][11].
There are two main challenges that prevent commercial off-the-shelf (COTS) servers from being able to process network flows at line speed.
First, network packets arrive at unpredictable times, so interrupts are generally used to notify an operating system that data is ready for processing.
However, interrupt handling can be expensive because modern superscalar processors use long pipelines, out-of-order and speculative execution, and multi-level memory systems, all of which tend to increase the penalty paid by an interrupt in terms of cycles [12,13].
When the packet reception rate increases further, the achieved (receive) throughput can drop dramatically in such systems [14].
Second, existing operating systems typically read incoming packets into kernel space and then copy the data to user space for the application interested in it.
These extra copies can incur an even greater overhead in virtualized settings, where it may be necessary to copy an additional time between the hypervisor and the guest operating system.
These two sources of overhead limit the the ability to run network services on commodity servers, particularly ones employing virtualization [15,16].
The Intel DPDK platform tries to reduce these overheads by allowing user space applications to directly poll the NIC for data.
This model uses Linux's huge pages to pre-allocate large regions of memory, and then allows applications to DMA data directly into these pages.
Fig- ure 1 shows the DPDK architecture that runs in the application layer.
The poll mode driver allows applications to access the NIC card directly without involving kernel processing, while the buffer and ring management systems resemble the memory management systems typically employed within the kernel for holding sk buffs.While DPDK enables high throughput user space applications, it does not yet offer a complete framework for constructing and interconnecting complex network services.
Further, DPDK's passthrough mode that provides direct DMA to and from a VM can have significantly lower performance than native IO 1 .
For example, DPDK supports Single Root I/O Virtualization (SR-IOV 2 ) to allow multiple VMs to access the NIC, but packet "switching" (i.e., demultiplexing or load balancing) can only be performed based on the L2 address.
As depicted in Fig- ure 2(a), when using SR-IOV, packets are switched on a per-port basis in the NIC, which means a second data copy is required if packets are forwarded between VMs on a shared port.
Even worse, packets must go out of the host and come back via an external switch to be transmitted to a VM that is connected to another port's virtual function.
Similar overheads appear for other VM switching platforms, e.g., Open vSwitch [19] and VMware's vNetwork distributed switch [20].
We seek to overcome this limitation in NetVM by providing a flexible switching capability without copying packets as shown in Fig- ure 2(b).
This improves performance of communication between VMs, which plays an important role when chained services are deployed.Intel recently released an integration of DPDK and Open vSwitch [21] to reduce the limitations of SR-IOV switching.
However, the DPDK vSwitch still requires copying packets between the hypervisor and the VM's memory, and does not support directly-chained VM communication.
NetVM's enhancements go beyond DPDK vSwitch by providing a framework for flexible state-or data-dependent switching, efficient VM communication, and security domains to isolate VM groups.
While platforms like DPDK allow for much faster processing, they still have limits on the kind of flexibility they can provide, particularly for virtual environments.
The NIC based switching supported by DPDK + SR-IOV is not only expensive, but is limited because the NIC only has visibility into Layer 2 headers.
With current techniques, each packet with a distinct destination MAC can be delivered to a different destination VM.
However, in a network resident box (such as a middlebox acting as a firewall, a proxy, or even if the COTS platform is acting as a router), the destination MAC of incoming packets is the same.
While advances in NIC design could reduce these limitations, a hardware based solution will never match the flexibility of a software-based approach.By having the hypervisor perform the initial packet switching, NetVM can support more complex and dynamic functionality.
For example, each application that supports a distinct function may reside in a separate VM, and it may be necessary to exploit flow classification to properly route packets through VMs based on mechanisms such as shallow (header-based) or deep (databased) packet analysis.
At the same time, NetVM's switch may use state-dependent information such as VM load levels, time of day, or dynamically configured policies to control the switching algorithm.
Delivery of packets based on such rules is simply not feasible with current platforms.
Network providers construct overall network functionality by combining middleboxes and network hardware that typically have been built by a diverse set of vendors.
While NetVM can enable fast packet processing in software, it is the use of virtualization that will permit this diverse set of services to "play nice" with each othervirtualization makes it trivial to encapsulate a piece of software and its OS dependencies, dramatically simplifying deployment compared to running multiple processes on one bare-metal server.
Running these services within VMs also could permit user-controlled network functions to be deployed into new environments such as cloud computing platforms where VMs are the norm and isolation between different network services would be crucial.
The consolidation and resource management benefits of virtualization are also well known.
Unlike hardware middleboxes, VMs can be instantiated on demand when and where they are needed.
This allows NetVM to multiplex one server for several related network functions, or to dynamically spawn VMs where new services are needed.
Compared to network software running on bare metal, using a VM for each service simplifies resource allocation and improves performance isolation.
These characteristics are crucial for network services that often have strict performance requirements.
Figure 4: NetVM only requires a simple descriptor to be copied via shared memory (solid arrows), which then gives the VM direct access to packet data stored in huge pages (dashed arrow).
forms, packets arrive at the NIC and are copied into the hypervisor.
A virtual switch then performs L2 (or a more complex function, based on the full 5-tuple packet header) switching to determine which VM is the recipient of the packet and notifies the appropriate virtual NIC.
The memory page containing the packet is then either copied or granted to the Guest OS, and finally the data is copied to the user space application.
Not surprisingly, this process involves significant overhead, preventing line-speed throughput.In the second case (Figure 3(b)), SR-IOV is used to perform L2 switching on the NIC itself, and data can be copied directly into User Space of the appropriate VM.
While this minimizes data movement, it does come at the cost of limited flexibility in how packets are routed to the VM, since the NIC must be configured with a static mapping and packet header information other than the MAC address cannot be used for routing.The architecture of NetVM is shown in Figure 3(c).
It does not rely on SR-IOV, instead allowing a user space application in the hypervisor to analyze packets and decide how to forward them.
However, rather than copy data to the Guest, we use a shared memory mechanism to directly allow the Guest user space application to read the packet data it needs.
This provides both flexible switching and high performance.
Network providers are increasingly deploying complex services composed of routers, proxies, video transcoders, etc., which NetVM could consolidate onto a single host.
To support fast communication between these components, NetVM employs two communication channels to quickly move data as shown in Figure 4.
The first is a small, shared memory region (shared between the hypervisor and each individual VM) that is used to transmit packet descriptors.
The second is a huge page region shared with a group of trusted VMs that allows chained applications to directly read or write packet data.
Memory sharing through a "grant" mechanism is commonly used to transfer control of pages between the hypervisor and guest; by expanding this to a region of memory accessible by all trusted guest VMs, NetVM can enable efficient processing of flows traversing multiple VMs.NetVM Core, running as a DPDK enabled user application, polls the NIC to read packets directly into the huge page area using DMA.
It decides where to send each packet based on information such as the packet headers, possibly content, and/or VM load statistics.
NetVM inserts a descriptor of the packet in the ring buffer that is setup between the individual destination VM and hypervisor.
Each individual VM is identified by a "role number"âˆ’a representation of each network function, that is assigned by the VM manager.
The descriptor includes a mbuf location (equivalent to a sk buff in the Linux kernel) and huge page offset for packet reception.
When transmitting or forwarding packets, the descriptor also specifies the action (transmit through the NIC, discard, or forward to another VM) and role number (i.e., the destination VM role number when forwarding).
While this descriptor data must be copied between the hypervisor and guest, it allows the guest application to then directly access the packet data stored in the shared huge pages.After the guest application (typically implementing some form of network functionality like a router or firewall) analyzes the packet, it can ask NetVM to forward the packet to a different VM or transmit it over the network.
Forwarding simply repeats the above processNetVM copies the descriptor into the ring buffer of a different VM so that it can be processed again; the packet data remains in place in the huge page area and never needs to be copied (although it can be independently modified by the guest applications if desired).
Shared memory is typically managed with locks, but locks inevitably degrade performance by serializing data accesses and increasing communication overheads.
This is particularly problematic for high-speed networking: to maintain full 10 Gbps throughput independent of packet size, a packet must be processed within 67.2 ns [22], yet context switching for a contested lock takes on the order of micro-seconds [23,24], and even an uncontested lock operation may take tens of nanoseconds [25].
Thus a single context switch could cause the system to fall behind, and thus may result in tens of packets being dropped.We avoid these issues by having parallelized queues with dedicated cores that service them.
When working with NICs that have multiple queues and Receive Side Scaling (RSS) capability 1 , the NIC receives pack- ets from the link and places them into one of several flow queues based on a configurable (usually an n-tuple) hash [27].
NetVM allows only two threads to manipulate this shared circular queue-the (producer) DPDK thread run by a core in the hypervisor and the (consumer) thread in the guest VM that performs processing on the packet.
There is only a single producer and a single consumer, so synchronization is not required since neither will read or write simultaneously to the same region.Hyper visor VM R R T T R R T T (a) Single VM Hypervisor VM#1 VM#2 R R T T R R F F T T F F R R F F T T F F (b) Multiple VMs (Inter-VM)Our approach eliminates the overhead of locking by dedicating cores to each queue.
This still permits scalability, because we can simply create additional queues (each managed by a pair of threads/cores).
This works with the NIC's support for RSS, since incoming flows can automatically be load balanced across the available queues.
Note that synchronization is not required to manage the huge page area either, since only one application will ever have control of the descriptor containing a packet's address.
Figure 5(a) depicts how two threads in a VM deliver packets without interrupting each other.
Each core (marked as a circle) in the hypervisor receives packets from the NIC and adds descriptors to the tail of its own queue.
The guest OS also has two dedicated cores, each of which reads from the head of its queue, performs processing, and then adds the packet to a transmit queue.
The hypervisor reads descriptors from the tail of these queues and causes the NIC to transmit the associated packets.
This thread/queue separation guarantees that only a single entity accesses the data at a time.
Multi-processor systems exhibit NUMA characteristics, where memory access time depends on the memory location relative to a processor.
Having cores on different sockets access memory that maps to the same cache line should be avoided, since this will cause expensive cache invalidation messages to ping pong back and forth between the two cores.
As a result, ignoring the NUMA aspects of modern servers can cause significant performance degradation for latency sensitive tasks like network processing [28,29].
Quantitatively, a last-level-cache (L3) hit on a 3GHz Intel Xeon 5500 processor takes up to 40 cycles, but the miss penalty is up to 201 cycles [30].
Thus if two separate sockets in NetVM end up processing data stored in nearby memory locations, the performance degradation can potentially be up to five times, since cache lines will end up constantly being invalidated.Fortunately, NetVM can avoid this issue by carefully allocating and using huge pages in a NUMA-aware fashion.
When a region of huge pages is requested, the memory region is divided uniformly across all sockets, thus each socket allocates a total of (total huge page size / number of sockets) bytes of memory from DIMMs that are local to the socket.
In the hypervisor, NetVM then creates the same number of receive/transmit threads as there are sockets, and each is used only to process data in the huge pages local to that socket.
The threads inside the guest VMs are created and pinned to the appropriate socket in a similar way.
This ensures that as a packet is processed by either the host or the guest, it always stays in a local memory bank, and cache lines will never need to be passed between sockets.
Figure 5 illustrates how two sockets (gray and white) are managed.
That is, a packet handled by gray threads is never moved to white threads, thus ensuring fast memory accesses and preventing cache coherency overheads.
This also shows how NetVM pipelines packet processing across multiple cores-the initial work of handling the DMAed data from the NIC is performed by cores in the hypervisor, then cores in the guest perform packet processing.
In a multi-VM deployment where complex network functionality is being built by chaining together VMs, the pipeline extends to an additional pair of cores in the hypervisor that can forward packets to cores in the next VM.
Our evaluation shows that this pipeline can be extended as long as there are additional cores to perform processing (up to three separate VMs in our testbed).
While each individual huge page represents a large contiguous memory area, the full huge page region is spread across the physical memory both because of the persocket allocations described in Section 3.3, and because it may be necessary to perform multiple huge page allocations to reach the desired total size if it is bigger than the default unit of huge page sizeâˆ’the default unit size can be found under /proc/meminfo.
This poses a problem since the address space layout in the hypervisor is not known by the guest, yet guests must be able to find packets in the shared huge page region based on the address in the descriptor.
Thus the address where a packet is placed by the NIC is only meaningful to the hypervisor; the address must be translated so that the guest will Figure 6: The huge pages spread across the host's memory must be contiguously aligned within the VM.
NetVM must be able to quickly translate the address of a new packet from the host's virtual address space to an offset within the VM's address space.be able to access it in the shared memory region.
Further, looking up these addresses must be as fast as possible in order to perform line-speed packet processing.NetVM overcomes the first challenge by mapping the huge pages into the guest in a contiguous region, as shown in Figure 6.
NetVM exposes these huge pages to guest VMs using an emulated PCI device.
The guest VM runs a driver that polls the device and maps its memory into user space, as described in Section 4.3.
In effect, this shares the entire huge page region among all trusted guest VMs and the hypervisor.
Any other untrusted VMs use a regular network interface through the hypervisor, which means they are not able to see the packets received from NetVM.Even with the huge pages appearing as a contiguous region in the guest's memory space, it is non-trivial to compute where a packet is stored.
When NetVM DMAs a packet into the huge page area, it receives a descriptor with an address in the hypservisor's virtual address space, which is meaningless to the guest application that must process the packet.
While it would be possible to scan through the list of allocated huge pages to determine where the packet is stored, that kind of processing is simply too expensive for high-speed packet rates because every packet needs to go through this process.
To resolve this problem, NetVM uses only bit operations and precomputed lookup tables; our experiments show that this improves throughput by up to 10% (with 8 huge pages) and 15% (with 16 huge pages) in the worst case compared to a naive lookup.When a packet is received, we need to know which huge page it belongs to.
Firstly, we build up an index map that converts a packet address to a huge page index.
Security is a key concern in virtualized cloud platforms.Since NetVM aims to provide zero-copy packet transmission while also having the flexibility to steer flows between cooperating VMs, it shares huge pages assigned in the hypervisor with multiple guest VMs.
A malicious VM may be able to guess where the packets are in this shared region to eavesdrop or manipulate traffic for other VMs.
Therefore, there must be a clear separation between trusted VMs and non-trusted VMs.
NetVM provides a group separation to achieve the necessary security guarantees.
When a VM is created, it is assigned to a trust group, which determines what range of memory (and thus which packets) it will have access to.
While our current implementation supports only trusted or untrusted VMs, it is possible to subdivide this further.
Prior to DMAing packet data into a huge page, DPDK's classification engine can perform a shallow analysis of the packet and decide which huge page memory pool to copy it to.
This would, for example, allow traffic flows destined for one cloud customer to be handled by one trust group, while flows for a different customer are handled by a second NetVM trust group on the same host.
In this way, NetVM enables not only greater flexibility in network function virtualization, but also greater security when multiplexing resources on a shared host.
Figure 4 shows a separation between trusted VM groups and a non-trusted VM.
Each trusted VM group gets its own memory region, and each VM gets a ring buffer for communication with NetVM.
In constrast, non-trusted VMs only can use generic network paths such as those in Figure 3 (a) or (b).
NetVM's implementation includes the NetVM Core Engine (the DPDK application running in the hypervisor), a NetVM manager, drivers for an emulated PCI device, modifications to KVM's CPU allocation policies, and NetLib (our library for building in-network functional-ity in VM's userspace).
Our implementation is built on QEMU 1.5.0 (KVM included), and DPDK 1.4.1.
KVM and QEMU allow a regular Linux host to run one or more VMs.
Our functionality is split between code in the guest VM, and code running in user space of the host operating system.
We use the terms host operating system and hypervisor interchangeably in this discussion.
The NetVM manager runs in the hypervisor and provides a communication channel so that QEMU can pass information to the NetVM core engine about the creation and destruction of VMs, as well as their trust level.
When the NetVM manager starts, it creates a server socket to communicate with QEMU.
Whenever QEMU starts a new VM, it connects to the socket to ask the NetVM Core to initialize the data structures and shared memory regions for the new VM.
The connection is implemented with a socket-type chardev with "-chardev socket,path=<path>,id=<id>" in the VM configuration.
This is a common approach to create a communication channel between a VM and an application running in the KVM host, rather than relying on hypervisor-based messaging [31].
NetVM manager is also responsible for storing the configuration information that determines VM trust groups (i.e., which VMs should be able to connect to NetVM Core) and the switching rules.
These rules are passed to the NetVM Core Engine, which implements these policies.
The NetVM Core Engine is a DPDK userspace application running in the hypervisor.
NetVM Core is initialized with user settings such as the processor core mapping, NIC port settings, and the configuration of the queues.
These settings determine how many queues are created for receiving and transmitting packets, and which cores are allocated to each VM for these tasks.
NetVM Core then allocates the Huge Page region and initializes the NIC so it will DMA packets into that area when polled.The NetVM core engine has two roles: the first role is to receive packets and deliver/switch them to VMs (using zero-copy) following the specified policies, and the other role is to communicate with the NetVM manager to synchronize information about new VMs.
The main control loop first polls the NIC and DMAs packets to huge pages in a burst (batch), then for each packet, NetVM decides which VM to notify.
Instead of copying a packet, NetVM creates a tiny packet descriptor that contains the huge page address, and puts that into the private shared ring buffer (shared between the VM and NetVM Core).
The actual packet data is accessible to the VM via shared memory, accessible over the emulated PCI device described below.
QEMU and KVM do not directly allow memory to be shared between the hypervisor and VMs.
To overcome this limitation, we use an emulated PCI device that allows a VM to map the device's memory-since the device is written in software, this memory can be redirected to any memory location owned by the hypervisor.
NetVM needs two seperate memory regions: a private shared memory (the address of which is stored in the device's BAR#0 register) and huge page shared memory (BAR#1).
The private shared memory is used as ring buffers to deliver the status of user applications (VM â†’ hypervisor) and packet descriptors (bidirectional).
Each VM has this individual private shared memory.
The huge page area, while not contiguous in the hypervisor, must be mapped as one contiguous chunk using the memory region add subregion function.
We illustrated how the huge pages map to virtual addresses, earlier in Section 3.4.
In our current implementation, all VMs access the same shared huge page region, although this could be relaxed as discussed in 3.5.
Inside a guest VM that wishes to use NetVM's highspeed IO, we run a front-end driver that accesses this emulated PCI device using Linux's Userspace I/O framework (UIO).
UIO was introduced in Linux 2.6.23 and allows device drivers to be written almost entirely in userspace.
This driver maps the two memory regions from the PCI device into the guest's memory, allowing a NetVM user application, such as a router or firewall, to directly work with the incoming packet data.
Application developers do not need to know anything about DPDK or NetVM's PCI device based communication channels.
Instead, our NetLib framework provides an interface between PCI and user applications.
User applications only need to provide a structure containing Figure 8 illustrates a packet flow.
When a packet is received from the hypervisor, a thread in NetLib fetches it and calls back a user application with the packet data.
Then the user application processes the packet (read or/and write), and returns with an action.
NetLib puts the action in the packet descriptor and sends it out to a transmit queue.
NetLib supports multi-threading by providing each user thread with its own pair of input and output queues.
There are no data exchanges between threads since NetLib provides a lockless model as NetVM does.
NetVM enables high speed packet delivery in-and-out of VMs and between VMs, and provides flexibility to steer traffic between function components that reside in distinct VMs on the NetVM platform.
In this section, we evaluate NetVM with the following goals:â€¢ Demonstrate NetVM's ability to provide high speed packet delivery with typical applications such as: Layer 3 forwarding, a userspace software router, and a firewall ( Â§ 5.2), â€¢ Show that the added latency with NetVM functioning as a middlebox is minimal ( Â§ 5.3), â€¢ Analyze the CPU time based on the task segment ( Â§ 5.4), and â€¢ Demonstrate NetVM's ability to steer traffic flexibly between VMs( Â§ 5.5).
In our experimental setup, we use two Xeon CPU X5650 @ 2.67GHz (2x6 cores) servers-one for the system under test and the other acting as a traffic generator-each of which has an Intel 82599EB 10G Dual Port NIC (with one port used for our performance experiments) and 48GB memory.
We use 8GB for huge pages because Figure 9 shows that at least 6GB is needed to achieve the full line-rate (we have seen in Intel's performance reports setting 8GB as a default huge page size).
The host OS is Red Hat 6.2 (kernel 2.6.32), and the guest OS is Ubuntu 12.10 (kernel 3.5).
DPDK-1.4.1 and QEMU-1.5.0 are used.
We use PktGen from WindRiver to generate traffic [33].
The base core assignment otherwise mentioned differently follows 2 cores to receive, 4 cores to transmit/forward, and 2 cores per VM.We also compare NetVM with SR-IOV, the high performance IO pass-through system popularly used.
SR-IOV allows the NIC to be logically partitioned into "virtual functions", each of which can be mapped to a different VM.
We measure and compare the performance and flexibility provided by these architectures.
L3 Forwarder [34]: We use a simple layer-3 router.
The forwarding function uses a hash map for the flow classification stage.
Hashing is used in combination with a flow table to map each input packet to its flow at runtime.
The hash lookup key is represented by a 5-tuple.
The ID of the output interface for the input packet is read from the identified flow table entry.
The set of flows used by the application is statically configured and loaded into the hash at initialization time (this simple layer-3 router is similar to the sample L3 forwarder provided in the DPDK library).
Click Userspace Router [10]: We also use Click, a more advanced userspace router toolkit to measure the performance that may be achieved by 'plugging in' an existing router implementation as-is into a VM, treating it as a 'container'.
Click supports the composition of elements that each performs simple computations, but together can provide more advanced functionality such as IP routing.
We have slightly modified Click by adding new receive and transmit elments that use Netlib for faster network IO.
In total our changes comprise approximately 1000 lines of code.
We test both a standard version of Click using Linux IO and our Netlib zero-copy version.
Firewall [35]: Firewalls control the flow of network traffic based on security policies.
We use Netlib to build the foundational feature for firewalls-the packet filter.
Firewalls with packet filters operate at layer 3, the network layer.
This provides network access control based on several pieces of information in a packet, including the usual 5-tuple: the packet's source and destination IP address, network or transport protocol id, source and destination port; in addition its decision rules would also factor in the interface being traversed by the packet, and its direction (inbound or outbound).
Packet Forwarding Performance: NetVM's goal is to provide line rate throughput, despite running on a virtualized platform.
To show that NetVM can indeed achieve this, we show the L3 packet forwarding rate vs. the input traffic rate.
The theoretical value for the nominal 64-byte IP packet for a 10G Ethernet interfaceâˆ’with preamble size of 8 bytes, a minimum inter-frame gap 12 bytesâˆ’is 14,880,952 packets.
Figure 10 shows the input rate and the forwarded rate in packets/sec for three cases: NetVM's simple L3 forwarder, the Click router using NetVM (Click-NetVM), and Click router using native Linux (Click-NativeLinux).
NetVM achieves the full line-rate, whereas Click-NetVM has a maximum rate of around 6Gbps.
This is because Click has added overheads for scheduling elements (confirmed by the latency analysis we present subsequently in Table 1).
Notice that increasing the input rate results in either a slight drop-off in the forwarding rate (as a result of wasted processing of packets that are ultimately dropped), or plateaus at that maximum rate.
We believe Click-NetVM's performance could be further improved by either adding multi-threading support or using a faster processor, but SR-IOV can not achieve better performance this way.
Not surprisingly, Click-NativeLinux performance is extremely poor (max 327Mbps), illustrating the dramatic improvement provided simply by zero-copy IO.
[10].
With SR-IOV, the VM has two virtual functions associated with it and runs DPDK with two ports using two cores.
SR-IOV achieves a maximum throughput of 5Gbps.
We have observed that increasing the number of virtual functions or cores does not improve the maximum throughput.
We speculate this limitation comes from the speed limitation on hardware switching.
Figure 11 now shows the forwarding rate as the packet size is varied.
Since NetVM does not have further overheads as a consequence of the increased packet size (data is delivered by DMA), it easily achieves the full line-rate.
Also, Click-NetVM also can provide the full line-rate for 128-byte and larger packet sizes.
Inter-VM Packet Delivery: NetVM's goal is to build complex network functionality by composing chains of VMs.
To evaluate how pipelining VM processing elements affects throughput, we measure the achieved throughput when varying the number of VMs through which a packet must flow.
We compare NetVM to a set of SR-IOV VMs, the state-of-the-art for virtualized networking.
Figure 12 shows that NetVM achieves a significantly higher base throughput for one VM, and that it is able to maintain nearly the line rate for chains of up to three VMs.
After this point, our 12-core system does not have enough cores to dedicate to each VM, so there begins to be a processing bottleneck (e.g., four VMs require a total of 14 cores: 2 coresâˆ’one from each processor for NUMA-awarenessâˆ’to receive packets in the host, 4 cores to transmit/forward between VMs, and 2 cores per VM for application-level processing).
We believe that more powerful systems should easily be able to support longer chains using our architecture.For a more realistic scenario, we consider a chain where 40% of incoming traffic is processed only by the first VM (an L2 switch) before being transmitted out the wire, while the remaining 60% is sent from the L2 switch VM through a Firewall VM, and then an L3 switch VM (e.g., a load balancer).
In this case, our test machine has sufficient CPU capacity to achieve the line-rate for the three VM chain, and sees only a small decrease if additional L3 switch VMs are added to the end of the chain.
In contrast, SR-IOV performance is affected by the negative impact of IOTLB cache-misses, as well as a high data copy cost to move between VMs.
Input/output memory management units (IOMMUs) use an IOTLB to speed up address resolution, but still each IOTLB cachemiss renders a substantial increase in DMA latency and performance degradation of DMA-intensive packet processing [36,37].
While maintaining line-rate throughput is critical for innetwork services, it is also important for the latency added by the processing elements to be minimized.
We quantify this by measuring the average roundtrip latency for L3 forwarding in each platform.
The measurement is performed at the traffic generator by looping back 64-byte packets sent through the platform.
We include a timestamp on the packet transmitted.
Figure 13 shows the roundtrip latency for the three cases: NetVM, Click-NetVM, and SR-IOV using identical L3 Forwarding function.
Latency for Click-NetVM and SR-IOV increases especially at higher loads when there are additional packet processing delays under overload.
We speculate that at very low input rates, none of the systems are able to make full benefit of batched DMAs and pipelining between cores, explaining the initially slightly worse performance for all approaches.
After the offered load exceeds 5Gbps, SR-IOV and Click are unable to keep up, causing a significant portion of packets to be dropped.
In this experiment, the queue lengths are relatively small, preventing the latency from rising significantly.
The drop rate of SR-IOV rises to 60% at 10Gbps, while NetVM drops zero pockets.
Figure 13: Average roundtrip latency for L3 forwarding.
are larger than the true values because using Xeon cycle counters has significant overhead (the achieved throughput drops from 10Gbps to 8.7Gbps).
Most of the tasks performed by a NetVM's CPU are included in the table.
"NIC â†’ Hypervisor" measures the time it takes DPDK to read a packet from the NIC's receive DMA ring.
Then NetVM decides which VM to send the packet to and puts a small packet descriptor in the VM's receive ring ("Hypervisor â†’ VM").
Both of these actions are performed by a single core.
"VM â†’ APP" is the time NetVM needs to get a packet from a ring buffer and delivers it to the user application; the application then spends "APP (L3 Forwarding)" time; the forwarding application (NetVM or Click) sends the packet back to the VM ("APP â†’ VM") and NetVM puts it into the VM's transmit ring buffer ("VM â†’ Hypervisor").
Finally, the hypervisor spends "Hypervisor â†’ NIC" time to send out a packet to the NIC's transmit DMA ring.The Core# column demonstrates how packet descriptors are pipelined through different cores for different tasks.
As was explained in Section 3.3, packet processing is restricted to the same socket to prevent NUMA overheads.
In this case, only "APP (L3 Forwarding)" reads/writes the packet content.
NetVM allows for flexible switching capabilities, which can also help improve performance.
Whereas Intel SR-IOV can only switch packets based on the L2 address, NetVM can steer traffic (per-packet or per-flow) to a spe- cific VM depending on system load (e.g., using the occupancy of the packet descriptor ring as an indication), shallow packet inspection (header checking), or deep packet inspection (header + payload checking) in the face of performance degradation.
Figure 14 illustrates the forwarding rate when load-balancing is based on load of packets queuedâˆ’the queue with the smallest number of packets has the highest priority.
The stacked bars show how much traffic each VM receives and the total.
NetVM is able to evenly balance load across VMs.
Click-NetVM shows a significant performance improvement with multiple VMs (up to 20%) since additional cores are able to load balance the more expensive application-level processing.
The SR-IOV system is simply unable to make use of multiple VMs in this way since the MAC addresses coming from the packet generator are all same.
Adding more cores to the single SR-IOV VM does also not improve performance.
We believe this will be a realistic scenario in the network (not just in our testbed) as the MAC addresses of incoming packets at a middlebox or a router will likely be the same across all packets.
We also have observed the same performance graph for NetVM's shallow packet inspection that loadbalances based on the protocol type; deep-packet inspection overhead will depend on the amount of computation required while analyzing the packet.
With many different network functions deployed, more dynamic workloads with SDN capability are left for the future works.
We have shown NetVM's zero-copy packet delivery framework can effectively bring high performance for network traffic moving through a virtualized network platform.
Here we discuss related issues, limitations, and future directions.
Scale to next generation machines: In this work, we have used the first CPU version (Nehalem architecture) that supports Intel's DPDK.
Subsequent generations of processors from Intel, the Sandy-bridge and Ivy-bridge processors have significant additional hardware capabilities (i.e., cores), so we expect that this will allow both greater total throughput (by connecting to multiple NIC ports in parallel), and deeper VM chains.
Reports in the commercial press and vendor claims indicate that there is almost a linear performance improvement with the number of cores for native Linux (i.e., non-virtualized).
Since NetVM eliminates the overheads of other virtual IO techniques like SR-IOV, we also expect to see the same linear improvement by adding more cores and NICs.Building Edge Routers with NetVM: We recognize that the capabilities of NetVM to act as a network element, such as an edge router in an ISP context, depends on having a large number of interfaces, albeit at lower speeds.
While a COTS platform may have a limited number of NICs, each at 10Gbps, a judicious combination of a low cost Layer 2 (Ethernet) switch and NetVM will likely serve as an alternative to (what are generally high cost) current edge router platforms.
Since the features and capabilities (in terms of policy and QoS) required on an edge router platform are often more complex, the cost of ASIC implementations tend to rise steeply.
This is precisely where the additional processing power of the recent processors combined with the NetVM architecture can be an extremely attractive alternative.
The use of the low cost L2 switch provides the necessary multiplexing/demultiplexing required to complement NetVM's ability to absorb complex functions, potentially with dynamic composition of those functions.Open vSwitch and SDN integration: SDN allows greater flexibility for control plane management.
However, the constraints of the hardware implementations of switches and routers often prevent SDN rules from being based on anything but simple packet header information.
Open vSwitch has enabled greater network automation and reconfigurability, but its performance is limited because of the need to copy data.
Our goal in NetVM is to build a base platform that can offer greater flexibility while providing high speed data movement underneath.
We aim to integrate Open vSwitch capabilities into our NetVM Manager.
In this way, the inputs that come from a SDN Controller using OpenFlow could be used to guide NetVM's management and switching behavior.
NetVM's flexibility in demultiplexing can accommodate more complex rule sets, potentially allowing SDN control primitives to evolve.Other Hypervisors: Our implementation uses KVM, but we believe the NetVM architecture could be applied to other virtualization platforms.
For example, a similar setup could be applied to Xen; the NetVM Core would run in Domain-0, and Xen's grant table functionality would be used to directly share the memory regions used to store packet data.
However, Xen's limited support for huge pages would have to be enhanced.
The introduction of multi-core and multi-processor systems has led to significant advances in the capabilities of software based routers.
The RouteBricks project sought to increase the speed of software routers by exploiting parallelism at both the CPU and server level [39].
Similarly, Kim et.
al. [11] demonstrate how batching I/O and CPU operations can improve routing performance on multi-core systems.
Rather than using regular CPU cores, PacketShader [28] utilizes the power of general purpose graphic processing units (GPGPU) to accelerate packet processing.
Hyper-switch [40] on the other hand uses a low-overhead mechanism that takes into account CPU cache locality, especially in NUMA systems.
All of these approaches demonstrate that the memory access time bottlenecks that prevented software routers such as Click [10] from performing line-rate processing are beginning to shift.
However, none of these existing approaches support deployment of network services in virtual environments, a requirement that we believe is crucial for lower cost COTS platforms to replace purposebuilt hardware and provide automated, flexible network function management.The desire to implement network functions in software, to enable both flexibility and reduced cost because of running on COTS hardware, has recently taken concrete shape with a multitude of network operators and vendors beginning to work together in various industry forums.
In particular, the work spearheaded by European Telecommunications Standards Institute (ETSI) on network function virtualization (NFV) has outlined the concept recently [41,42].
While the benefits of NFV in reducing equipment cost and power consumption, improving flexibility, reduced time to deploy functionality and enabling multiple applications on a single platform (rather than having multiple purpose-specific network appliances in the network) are clear, there is still the outstanding problem of achieving high-performance.
To achieve a fully capable NFV, high-speed packet delivery and low latency is required.
NetVM provides the fundamental underlying platform to achieve this.Improving I/O speeds in virtualized environments has long been a challenge.
Santos et al. narrow the performance gap by optimzing Xen's driver domain model to reduce execution costs for gigabit Ethernet NICs [43].
vBalance dynamically and adaptively migrates the interrupts from a preempted vCPU to a running one, and hence avoids interrupt processing delays to improve the I/O performance for SMP-VMs [44].
vTurbo accelerates I/O processing for VMs by offloading that task to a designated core called a turbo core that runs with a much smaller time slice than the cores shared by production VMs [45].
VPE improves the performance of I/O device virtualization by using dedicated CPU cores [46].
However, none of these achieve full line-rate packet forwarding (and processing) for network links operating at 10Gbps or higher speeds.
While we base our platform on DPDK, other approaches such as netmap [47] also provide highspeed NIC to userspace I/O.
Researchers have looked into middlebox virtualization on commodity servers.
Split/Merge [48] describes a new abstraction (Split/Merge), and a system (FreeFlow), that enables transparent, balanced elasticity for stateful virtual middleboxes to have the ability to migrate flows dynamically.
xOMB [6] provides flexible, programmable, and incrementally scalable middleboxes based on commodity servers and operating systems to achieve high scalability and dynamic flow management.
CoMb [8] addresses key resource management and implementation challenges that arise in exploiting the benefits of consolidation in middlebox deployments.
These systems provide flexible management of networks and are complementary to the the high-speed packet forwarding and processing capability of NetVM.
We have described a high-speed network packet processing platform, NetVM, built from commodity servers that use virtualization.
By utilizing Intel's DPDK library, NetVM provides a flexible traffic steering capability under the hypervisor's control, overcoming the performance limitations of the existing, popular SR-IOV hardware switching techniques.
NetVM provides the capability to chain network functions on the platform to provide a flexible, high-performance network element incorporating multiple functions.
At the same time, NetVM allows VMs to be grouped into multiple trust domains, allowing one server to be safely multiplexed for network functionality from competing users.We have demonstrated how we solve NetVM's design and implementation challenges.
Our evaluation shows NetVM outperforms the current SR-IOV based system for forwarding functions and for functions spanning multiple VMs, both in terms of high throughput and reduced packet processing latency.
NetVM provides greater flexibility in packet switching/demultiplexing, including support for state-dependent load-balancing.
NetVM demonstrates that recent advances in multi-core processors and NIC hardware have shifted the bottleneck away from software-based network processing, even for virtual platforms that typically have much greater IO overheads.
We thank our shepherd, KyoungSoo Park, and reviewers for their help improving this paper.
This work was supported in part by NSF grant CNS-1253575.
