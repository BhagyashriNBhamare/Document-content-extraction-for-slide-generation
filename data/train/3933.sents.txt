Private Set Intersection (PSI) allows two parties to compute the intersection of private sets while revealing nothing more than the intersection itself.
PSI needs to be applied to large data sets in scenarios such as measurement of ad conversion rates, data sharing, or contact discovery.
Existing PSI protocols do not scale up well, and therefore some applications use insecure solutions instead.
We describe a new approach for designing PSI protocols based on permutation-based hashing, which enables to reduce the length of items mapped to bins while ensuring that no collisions occur.
We denote this approach as Phasing, for Permutation-based Hashing Set Intersection.
Phasing can dramatically improve the performance of PSI protocols whose overhead depends on the length of the representations of input items.
We apply Phasing to design a new approach for circuit-based PSI protocols.
The resulting protocol is up to 5 times faster than the previously best Sort-Compare-Shuffle circuit of Huang et al. (NDSS 2012).
We also apply Phasing to the OT-based PSI protocol of Pinkas et al. (USENIX Security 2014), which is the fastest PSI protocol to date.
Together with additional improvements that reduce the computation complexity by a logarithmic factor, the resulting protocol improves run-time by a factor of up to 20 and can also have similar communication overhead as the previously best PSI protocol in that respect.
The new protocol is only moderately less efficient than an insecure PSI protocol that is currently used by real-world applications, and is therefore the first secure PSI protocol that is scalable to the demands and the constraints of current real-world settings.
Private set intersection (PSI) allows two parties P 1 and P 2 with respective input sets X and Y to compute the intersection X ∩ Y of their sets without revealing any information but the intersection itself.
Although PSI has been widely studied in the literature, many real-world applications today use an insecure hash-based protocol instead of a secure PSI protocol, mainly because of the insufficient efficiency of current PSI protocols.In this work we present Phasing, Permutation-based Hashing Set Intersection, which is a new approach for constructing PSI protocols based on a hashing technique that ensures that hashed elements can be represented by short strings without any collisions.
The overhead of recent PSI protocols depends on the length of these representations, and this new structure of construction, together with other improvements, results in very efficient performance that is only moderately larger than that of the insecure protocol that is in current real-world usage.
The motivation for this work comes from scenarios where PSI must be applied quite frequently to large sets of data, and therefore performance becomes critical.
Moreover, the communication overhead might be even more important than the computation overhead, since in large data centers it is often easier to add computing power than to improve the outgoing communication infrastructure.
We describe here three scenarios which require large-scale PSI implementations.Measuring ad conversion rates Online advertising, which is a huge business, typically measures the success of ad campaigns by measuring the success of converting viewers into customers.
A popular way of measuring this value is by computing the conversion rate, which is the percentage of ad viewers who later visit the advertised site or perform a transaction there.
For banner ads or services like Google Adwords it is easy to approximate this value by measuring ad click-throughs.
However, measuring click-throughs is insufficient in other online advertising settings.
One such setting is mobile advertising, which is becoming a dominating part of online ad-1 516 24th USENIX Security Symposium USENIX Association vertising.
Even though mobile ads have a great effect, click-throughs are an insufficient measure of their utility, since it is unlikely, due to small displays and the casual nature of mobile browsing, that a user will click on an ad and, say, purchase a car using his mobile device.
Another setting where click rate measurement is unsatisfactory is advertising of offline goods, like groceries, where the purchase itself is done offline.
1 An alternative method of measuring ad performance is to compare the list of people who have seen an ad with those who have completed a transaction.
These lists are held by the advertiser (say, Google or Facebook), and by merchants, respectively.
It is often possible to identify users on both ends, using identifiers such as credit card numbers, email addresses, etc.
A simple solution, which ignores privacy, is for one side to disclose its list of customers to the other side, which then computes the necessary statistics.
Another option is to run a PSI protocol between the two parties.
(The protocol should probably be a variant of PSI, e.g. compute total revenues from customers who have seen an ad.
Such protocols can be derived from basic PSI protocols.)
In fact, Facebook is running a service of this type with Datalogix, Epsilon and Acxiom, companies which have transaction records for a large part of loyalty card holders in the US.
According to reports 2 , the computation is done using a variant of the insecure naive hashing PSI protocol that we describe in §3.1.
Our results show that it can be computed using secure protocols even for large data sets.Security incident information sharing Security incident handlers can benefit from information sharing since it provides them with a global view during incidents.
However, incident data is often sensitive and potentially embarrassing.
The shared information might reveal information about the business of the company that provided it, or of its customers.
Therefore, information is typically shared rather sparsely and protected using legal agreements.
Automated large scale sharing will improve security, and there is in fact work to that end, such as the IETF Managed Incident Lightweight Exchange (MILE) effort.
Many computations that are applied to the shared data compute the intersection and its variants.
Applying PSI to perform these computations can simplify the legal issues of information sharing.
Efficient PSI protocols will enable it to be run often and in large scale.Private contact discovery When a new user registers to a service it is often essential to identify current regis- 1 See, e.g., http://www.reuters.com/article/2012/10/01/ us-facebook-ads-idUSBRE8900I120121001 .
2 See, e.g., https://www.eff.org/deeplinks/2012/09/deep -dive-facebook-and-datalogix-whats-actually-getting -shared-and-how-you-can-opt.
tered users who are also contacts of the new user.
This operation can be done by simply revealing the user's contact list to the service, but can also be done in a privacy preserving manner by running a PSI protocol between the user's contact list and the registered users of the service.
This latter approach is used by the TextSecure and Secret applications, but for performance reasons they use the insecure naive hashing PSI protocol described in §3.1.
3 In these cases each user has a small number of records n 2 , e.g., n 2 = 256, whereas the service has millions of registered users (in our experiments we use n 1 = 2 24 ).
It therefore holds that n 2 񮽙 n 1 .
In our best PSI protocol, the client needs only O(n 2 log n 1 ) memory, O(n 2 ) symmetric cryptographic operations and O(n 1 ) cheap hash table lookups, and the communication is O(n 1 log n 1 ).
(The communication overhead is indeed high as it depends on n 1 , but this seems inevitable if brute force searches are to be prevented.)
Our goal in this work is to enable PSI computations for large scale sets that were previously beyond the capabilities of state-of-the-art protocols.
The constructions that we design in this work improve performance by more than an order of magnitude.
We obtain these improvements by generalizing the hashing approach of [22] and applying it to generic secure computation-based PSI protocols.
We replace the hash function in [22] by a permutation which enables us to reduce the bit-length of internal representations.
Moreover, we suggest several improvements to the OT-based PSI protocol of [22].
We explain our contributions in more detail next:Phasing: Using permutation-based hashing to reduce the bit-length of representations.
The overhead of the best current PSI protocol [22] is linear in the length of the representations of items in the sets (i.e., the ids of items in the sets).
The protocol maps items into bins, and since each bin has very few items in it, it is tempting to hash the ids to shorter values and trust the birthday paradox to ensure that no two items in the same bin are hashed to the same representation.
However, a closer examination shows that to ensure that the collision probability is smaller than 2 −λ , the length of the representation must be at least λ bits, which is too long.In this work we utilize the permutation-based hashing techniques of [1] to reduce the bit-length of the ids of items that are mapped to bins.
These ideas were suggested in an algorithmic setting to reduce memory us- 3 See https://whispersystems.org/blog/contact-disco very/ and https://medium.com/@davidbyttow/demystifying -secret-12ab82fda29f , respectively.age, and as far as we know this is the first time that they are used in a cryptographic or security setting to improve performance.
Essentially, when using β bins the first log β bits in an item's hashed representation define the bin to which the item is mapped, and the other bits are used in a way which provably prevents collisions.
This approach reduces the bit-length of the values used in the PSI protocol by log β bits, and this yields reduced overhead by up to 60%-75% for the settings we examined.Circuit-Phasing: Improved circuit-based PSI.
As we discuss in §3.4 there is a great advantage in using generic secure computation for computing PSI, since this enables to easily compute variants of the basic PSI functionality.
Generic secure computation protocols evaluate Boolean circuits computing the desired functionality.
The best known circuit for computing PSI was based on the Sort-Compare-Shuffle circuit of [12].
We describe Circuit-Phasing, a new generic protocol that uses hashing (specifically, Cuckoo hashing and simple hashing) and secure circuit evaluation.
In comparison with the previous approach, our circuits have a smaller number of AND gates, a lower depth of the circuit (which affects the number of communication rounds in some protocols), and a much smaller memory footprint.
These factors lead to a significantly better performance.OT-Phasing: Improved OT-based PSI.
We introduce the OT-Phasing protocol which improves the OT-based PSI protocol of [22] as follows:• Improved computation and memory.
We reduce the length of the strings that are processed in the OT from O(log 2 n) to O(log n), which results in a reduction of computation and memory complexity for the client from O(n log 2 n) to O(n log n).
• 3-way Cuckoo hashing.
We use 3 instead of 2 hash functions to generate a more densely populated Cuckoo table and thus decrease the overall number of bins and hence OTs.
OT-Phasing improves over state-of-the-art PSI both in terms of run-time and communication.
Compared to the previously fastest PSI protocol of [22], our protocol improves run-time by up to factor 10 in the WAN setting and by up to factor 20 in the LAN setting.
Furthermore, our OT-Phasing protocol in some cases achieves similar communication as [18], which was shown to achieve the lowest communication of all PSI protocols [22].
We give preliminary information in §2 and summarize related work in §3.
In §4 we describe Phasing, our optimization for permutation-based hashing that reduces the bit-length of elements in PSI.
Afterwards, we apply Phasing to generic secure computation protocols, and present Circuit-Phasing, our new approach for circuitbased PSI §5.
Thereafter, we apply Phasing to the previously fastest OT-based PSI protocol of [22] and present several optimizations in §6.
In §7 we analyze the hashing failure probability of Circuit-and OT-Phasing.
Finally, we provide an evaluation of our PSI protocols in §8.
We denote the parties as P 1 and P 2 .
For all protocols we assume that P 2 obtains the output.
The respective input sets are denoted as X and Y , with sizes n 1 = |X| and n 2 = |Y |.
Often n 1 = n 2 and we use the notation n = n 1 = n 2 .
We assume that elements are of bit-length σ .
We call the symmetric security parameter κ, the bitlength of the elliptic curves ϕ, and the statistical security parameter λ .
Throughout the paper we assume 128-bit security, i.e., κ = 128, ϕ = 283 (using Koblitz-curves), and λ = 40.
For symmetric encryption we use AES-128.
We refer to the concatenation of bit-strings by ||, to the exclusive-OR (XOR) operation by ⊕, and to the i-th element in a sequence S by S[i].
In many protocols, we shorten the size of hash values that are sent to 񮽙 = λ + log 2 (n 1 ) + log 2 (n 2 ) instead of 2κ.
This yields collision probability 2 −λ , which is suited for most applications.
Two types of adversaries are typically discussed in the secure computation literature: A semi-honest adversary is trusted to follow the protocol, but attempts to learn as much information as possible from the messages it receives.
This adversary model is appropriate for scenarios where execution of the correct software is enforced by software attestation or where an attacker might obtain the transcript of the protocol after its execution, either by stealing it or by legally enforcing its disclosure.
In contrast, a malicious adversary can behave arbitrarily.
Most work on PSI was in the semi-honest setting.
Protocols that are secure against malicious adversaries, e.g., [9,10,14], are considerably less efficient.
We focus on optimal performance and therefore design protocols secure against semi-honest adversaries only.
Furthermore, the security of the protocols is proven in the random oracle model, as is justified in the full version [21].
Our protocols hash the input items to bins and then operate on each bin separately.
In general, our hashing schemes use a table T consisting of β bins.
An element e is mapped to the table by computing an address a = H(e) using a hash function H that is modeled as a random function.
A value related to e is then stored in bin T [a].
There is a rich literature on hashing schemes, which differ in the methods for coping with collisions, the complexity for insertion/deletion/look-up, and the utilization of storage space.
In [9,10,22], hashing to bins was used to improve the number of comparisons that are performed in PSI protocols.
In the following, we detail the two most promising hashing schemes for use in PSI, according to [22]: simple hashing and Cuckoo hashing.
For the OT-based PSI protocol of [22] it was shown that a combination of simple hashing (for P 1 ) and Cuckoo hashing (for P 2 ) results in the best performance.
Simple hashing builds the table T by mapping each element e to bin T [H(e)] and appending e to the bin.
Each bin must, of course, be able to store more than one element.
The size of the most populated bin was analyzed in [23], and depends on the relation between the number of bins and the total number of elements.
Most importantly for our application, when hashing n elements into β = n bins, it was shown that the maximum number of elements in a bin is ln n ln ln n (1 + o (1)).
In §7.1 we give a theoretical and an empirical analysis of the maximum number of elements in a bin.
Cuckoo hashing [19] uses h hash functions H 1 , ..., H h to map an element e to a bin using either one of the h hash functions.
(Typically, h is set to be h = 2; we also use h = 3.)
In contrast to simple hashing, it allows at most one element to be stored in a bin.
If a collision occurs, Cuckoo hashing evicts the element in the bin and performs the insertion again for the evicted element.
This process is repeated until an empty bin is found for the evicted element.
If the resulting sequence of insertion attempts fails a certain number of times, the current evicted element is placed in a special bin called stash.
In [16] it was shown that for h = 2 hash functions, β = 2(1 + ε)n bins, and a stash of size s ≤ ln n, the insertion of elements fails with small probability of O(n −s ), which is smaller than n −(s−1) for sufficiently large values of n (cf. §7.2).
1-ouf-of-2 oblivious transfer (OT) [8] is a protocol where the receiver with choice bit c, chooses one of two strings (x 0 , x 1 ) held by the sender.
The receiver receives x c but gains no information about x 1−c , while the sender gains no information about c.OT extension protocols [2,17] precompute a small number (say, κ = 128) of "real" public-key-based OTs, and then compute any polynomial number of OTs using symmetric-key cryptography alone.
The most efficient OT variant that we use computes random OT.
In that protocol the sender has no input but obtains random (x 0 , x 1 ) as output, while the receiver with input c obtains x c [2].
The advantage of this protocol is that the sender does not need to send messages based on its inputs, as it does not have any inputs, and instead computes them on-the-fly during the OT extension protocol.
As a result, the communication overhead of the protocol is greatly reduced.An additional improvement that we use, described in [17], efficiently computes 1-out-of-N OT for short strings.
The communication for a random 1-out-of-N OT (for 3 ≤ N ≤ 256) is only 2κ-bits, whereas the communication for a random 1-out-of-2 OT is κ-bits.
The computation for a random 1-out-of-N OT amounts to four pseudo-random generator (PRG) and one correlationrobust function (CRF) evaluations for the receiver and two PRG and N CRF evaluations for the sender.
In addition, if the sender only requires i ≤ N outputs of the OT, it only needs to perform i CRF evaluations.We use 1-out-of-N OT since we have to perform OTs for every bit of an element.
By using 1-out-of-N OT for N = 2 µ , we process µ bits in parallel with communication equal to that of processing two bits.
We denote m 1-out-of-N OTs on 񮽙-bit strings by񮽙 N 1 񮽙 -OT m 񮽙 .
Generic secure two-party computation protocols allow two parties to securely evaluate any function that can be expressed as a Boolean circuit.
The communication overhead and the number of cryptographic operations that are computed are linear in the number of nonlinear (AND) gates in the circuit, since linear (XOR) gates can be evaluated "for free" in current protocols.
Furthermore, some protocols require a number of interaction rounds that are linear in the AND depth of the circuit.
The two main approaches for generic secure two-party computation on Boolean circuits are Yao's garbled circuits [25] and the protocol by Goldreich-MicaliWigderson [11].
We give a summary of these protocols in the full version [21].
We reflect on existing PSI protocols by following the classification of PSI protocols in [22]: the naive hashing protocol ( §3.1), server-aided PSI protocols ( §3.2), public-key cryptography-based PSI protocols ( §3.3), generic secure computation-based PSI protocols ( §3.4), and OT-based PSI protocols ( §3.5).
For each category, we review existing work and outline the best performing protocol, according to [22].
In the naive hashing protocol, detailed in the full version [21], P 1 permutes and hashes its elements, and sends the results to P 2 which compares these values to the hashes of its elements.
This approach is very efficient and is currently employed in practice, but it allows P 2 to brute-force the elements of P 1 if they do not have high entropy.
Furthermore, even if inputs elements have high entropy, forward-secrecy is not provided since P 2 can check at any later time whether an element was in X. To increase the efficiency of PSI, protocols that use a semi-trusted third party were proposed [15].
These protocols are secure as long as the third party does not collude with any of the participants.
We mention this set of protocols here for completeness, as they require different trust assumptions as protocols involving no third party.
The protocol of [15] has only a slightly higher overhead than the naive hashing PSI solution described in §3.1.
In that protocol, P 1 samples a random κ-bit key k and sends it to P 2 .
Both parties computeh i = F k (x i ) (resp.
h 񮽙 j = F k (y j )),where F k is a pseudo-random permutation that is parametrized by k. Both parties then send the hashes to the third party (in randomly permuted order) who then computes I = h i ∩ h 񮽙 j , for all 1 ≤ i ≤ n 1 and 1 ≤ j ≤ n 2 and sends I to P 2 .
P 2 obtains the intersection by computing F −1 k (e) for each e ∈ I.
The first protocols for PSI were outlined in [13,18] and were based on the Diffie-Hellmann (DH) key exchange.
The overhead of these protocols is O(n) exponentiations.In [9,10], a PSI protocol based on El-Gamal encryption was introduced that uses oblivious polynomial evaluation and requires O(n log log(n)) public-key encryptions (the advantage of that protocol was that its security was not based on the random oracle model).
A PSI protocol that uses blind-RSA was introduced in [3].
We implement the DH-based protocol of [13,18] based on elliptic-curve-cryptography, which was shown to achieve lowest communication in [22].
We describe the protocol in the full version [21].
Generic secure computation can be used to perform PSI by encoding the intersection functionality as a Boolean circuit.
The most straightforward method for this encoding is to perform a pairwise-comparison which compares each element of one party to all elements of the other party.
However, this circuit uses O(n 2 ) comparisons and hence scales very poorly for larger set sizes [12].
The Sort-Compare-Shuffle (SCS) circuit of [12] is much more efficient.
As indicated by its name, the circuit first sorts the union of the elements of both parties, then compares adjacent elements for equality, and finally shuffles the result to avoid information leakage.
The sort and shuffle operations are implemented using a sorting network of only O(n log n) comparisons, and the comparison step requires only O(n) comparisons.The work of [12] describes a size-optimized version of this circuit for use in Yao's garbled circuits; [22] describes a depth-optimized version for use in the GMW protocol.
The size-optimized SCS circuit has σ (3n log 2 n + 4n) AND gates 4 and AND depth (σ + 2) log 2 (2n)+log 2 (σ )+1 while the depth-optimized SCS circuit has about the same number of gates and AND depth of (log 2 (σ ) + 4) log 2 (2n), for n = (n 1 + n 2 )/2.
PSI protocols based on generic secure computation have higher run-time and communication complexity than most special-purpose PSI protocols [4,22].
Yet, these protocols are of great importance since they enable to easily compute any functionality that is based on basic PSI.
Consider, for example, an application that needs to find if the size of the intersection is greater than some threshold, or compute the sum of revenues from items in the intersection.
Computing these functionalities using specialized PSI protocols requires to change the protocols, whereas a PSI protocol based on generic computation can be adapted to compute these functionalities by using a slightly modified circuit.
In other words, changing specialized protocols to have a new functionality requires to employ a cryptographer to design a new protocol variant, whereas changing the functionality of a generic protocol only requires to design a new circuit computing the new functionality.
The latter task is of course much simpler.
An approximate PSI protocol that uses generic secure computation protocols in combination with Bloom filters was given in [24].
OT-based PSI protocols are the most recent category of PSI protocols.
Their research has been motivated by recent efficiency improvements in OT extension.
The garbled Bloom filter protocol of [7] was the first OT-based PSI protocol and was improved in [22].
A novel OTbased PSI protocol, which we denote OT-PSI protocol, was introduced in [22], combining OT and hashing to achieve the best run-time among all analyzed PSI protocols.
We next summarize the OT-PSI protocol of [22] and give a detailed description in the full version [21].
The abstract idea of the OT-PSI protocol is to have both parties hash their elements into bins using the same hash function (Step 1, cf. §3.5.1) and compare the elements mapped to the same bin.
The comparison is done using OTs that generate random masks from the elements (Step 2, cf. §3.5.2), such that the intersection of the random masks corresponds to the intersection of the original inputs (Step 3, cf. §3.5.3).
Finally, the intersection of the elements in the stash is computed ( §3.5.4).
We give the overhead of the protocol in §3.5.5.
In the first step of the protocol, the parties map their elements into their respective hash tables T 1 and T 2 , consisting of β = h(1 + ε)n 2 bins (cf. §7).
P 2 uses Cuckoo hashing with h hash functions (with h = 2), and obtains a one-dimensional hash table T 2 .
P 1 hashes each item h times (once for each hash function) using simple hashing and obtains a two-dimensional hash table T 1 (where the first dimension addresses the bin and the second dimension the elements in the bin).
Each party then pads all bins in its table to the maximum size using respective dummy elements: P 1 pads each bin to max β elements using a dummy element d 1 (where max β is computed using β and n 1 as detailed in §7 to set the probability of mapping more items to a bin to be negligible), while P 2 fills each empty bin with dummy element d 2 (different than d 1 ).
The padding is performed to hide the number of elements that were mapped to a specific bin, which would leak information about the input.
After the hashing, the parties use OT to generate an 񮽙-bit random mask for each element in their hash table.Naively, for each bin, and for each item that P 2 mapped to the bin, the parties run a 1-out-of-2 OT for each bit of this item.
P 2 is the receiver and its input to the OT is the value of the corresponding bit in the single item that it mapped to the bin.
P 1 's input is two random 񮽙-bit strings.
After running these OTs for all σ bits of the item, P 1 sends to P 2 the XOR of the strings corresponding to the bits of P 1 's item.
Note that if P 1 's item is equal to that of P 2 then the sent value is equal to the XOR of the output strings that P 2 received in the OTs.
Otherwise the values are different with high probability, which depends on the length 񮽙 of the output strings.This basic protocol was improved upon in [22] in several ways:• Recall that OT extension is more efficient when applied to 1-out-of-N OT [17].
Therefore, the protocol uses µ-bit characters instead of a binary representation.
It splits the elements into t µ-bit characters, and uses t invocations of 1-out-of-N OT where N = 2 µ , instead of tµ invocations of 1-out-of-2 OT.
• In each bin the parties run OTs for all max β items that P 1 mapped to the bin, and to all characters in these items.
P 2 's inputs are the same for all max β OTs corresponding to the same character.
Thus, the parties could replace them with a single OT, where the output string of the OT has max β longer size.
• Recall that random OT, where the protocol randomly defines the inputs of P 1 , is more efficient than an OT where P 1 chooses these inputs by itself.
For the purpose of PSI the protocol can use random OT.
It is also important to note that if P 1 mapped m < max β elements to a bin, it only needs to evaluate inputs for m random OTs in this bin and not for all max β random OTs that are taking place.
This improves the overhead of the protocol.
The parties compute the intersection of their elements using the random masks (XOR values) generated duringStep 2: P 1 generates a set V as the masks for all of its non-dummy elements.
P 1 then randomly permutes the set V to hide information about the number of elements in each bin, and sends V to P 2 .
P 2 computes the intersection X ∩Y by computing the plaintext intersection between V and the set of XOR values that it computed.
The OT-based PSI protocol of [22] uses Cuckoo hashing with a stash of size s.
The intersection of P 2 's elements with P 1 's elements is done by running the masking procedure of Step 2 for all s items in the stash, comparing them with all n 1 items in P 1 's input.
Finally, P 1 sends the masks it computed to P 2 (in randomly permuted order) which can then check the intersection as in Step 3.
The overhead of this protocol is linear in the bit-length of the input elements.
Therefore, any reduction in the bit-length of the inputs directly results in a similar improvement in the overhead.
For readers interested in the exact overhead of the protocol, we describe here the details of the overhead.
In total, the parties have to evaluate random񮽙 N 1 񮽙 -OT βt max β 񮽙 + 񮽙 N 1񮽙 -OT st n 1 񮽙 and send (h + s)n 1 masks of 񮽙-bit length, where β = h(n 2 + ε), N = 2 µ , t = 񮽙σ /µ񮽙, 񮽙 = λ + log 2 (n 1 ) + log 2 (n 2 ), and s is the size of the stash.
To be exact, the server has to perform 2t(β + s) pseudorandom generator evaluations during OT extension, (h + s)n 1 t correlation-robust function evaluations to generate the random masks, and send (2 + s)n 1 񮽙 bits.
The client has to perform 4t(β + s) pseudo-random generator evaluations during OT extension, n 2 tmax β 񮽙/o + sn 1 t񮽙/o correlation-robust function evaluations to generate the random masks, and send 2(β + s)tκ bits during OT extension, where o is the output length of the correlationrobust function.
Note especially that the client has to evaluate the correlation-robust function O(n log 2 n) times to generate the random bits which represent the masks of the server's elements.
This cost can become prohibitive for larger sets, as we will show in our evaluation in §8.
The overhead of the OT-based PSI protocol of [22] and of the circuit-based PSI protocols we describe in §5 depends on the bit-lengths of the items that the parties map to bins.
The bit-length of the stored items can be reduced based on a permutation-based hashing technique that was suggested in [1] for reducing the memory usage of Cuckoo hashing.
That construction was presented in an algorithmic setting to improve memory usage.
As far as we know this is the first time that it is used in secure computation or in a cryptographic context.The construction uses a Feistel-like structure.
Let x = x L |x R be the bit representation of an input item, where |x L | = log β , i.e. is equal to the bit-length of an index of an entry in the hash table.
(We assume here that the number of bins β in the hash table is a power of 2.
It was shown in [1] how to handle the general case.)
Let f () be a random function whose range is [0, β − 1].
Then item x is mapped to bin x L ⊕ f (x R ).
The value that is stored in the bin is x R , which has a length that is shorter by log β bits than the length of the original item.
This is a great improvement, since the length of the stored data is significantly reduced, especially if |x| is not much greater than log β .
As for the security, it can be shown based on the results in [1] that if the function f is k-wise independent, where k = polylog n, then the maximum load of a bin is log n with high probability.The structure of the mapping function ensures that if two items x, x 񮽙 store the same value in the same bin then it must hold that x = x 񮽙 : if the two items are mapped to the same bin, thenx L ⊕ f (x R ) = x 񮽙 L ⊕ f (x 񮽙 R ).
Since the stored values satisfy x R = x 񮽙 R it must also hold that x L = x 񮽙 L , and therefore x = x 񮽙 .
As a concrete example, assume that |x| = 32 and that the table has β = 2 20 bins.
Then the values that are stored in each bin are only 12 bits long, instead of 32 bits in the original scheme.
Note also that the computation of the bin location requires a single instantiation of f , which can be implemented with a medium-size lookup table.A comment about an alternative approach An alternative, and more straightforward approach for reducing the bit-length could map x using a random permutation p() to a random |x|-bit string p(x).
The first log β bits of p(x) are used to define the bin to which x is mapped, and the value stored in that bin holds the remaining |x| − log β bits of p(x).
This construction, too, has a shorter length for the values that are stored in the bins, but it suffers from two drawbacks: From a performance perspective, this construction requires the usage of a random permutation on |x| bits, which is harder to compute than a random function.
From a theoretical perspective, it is impossible to have efficient constructions of k-wise independent permutations, and therefore we only know how to prove the log n maximum load of the bins under the stronger assumption that the permutation is random.
PSI protocols that are based on generic secure computation are of great importance due to their flexibility (cf. §3.4 for details).
The best known construction of a circuit computing the intersection (of σ -bit elements) is the SCS circuit of [12] with about 3nσ log 2 n AND gates and an AND depth of Θ(log 2 σ · log 2 n).
We describe a new construction of circuits with the same order of AND gates (but with smaller constants), and a much smaller depth.
Our experiments, detailed in §8.1, demonstrate that the new circuits result in much better performance.The new protocol, which we denote as CircuitPhasing, is based on the two parties mapping their inputs to hash tables before applying the circuit.
The idea is similar to the OT-based PSI protocol of [22] described in §3.5, but instead of using OTs for the comparisons, the protocol evaluates a pairwise-comparison circuit between each bin of P 1 and P 2 in parallel:• Both parties use a table of size β = O(n) to store their elements.
Our analysis ( §7) shows that setting β = 2.4n reduces the error probability to be negligible for reasonable input sizes (2 8 ≤ n ≤ 2 24 ) when setting the stash size according to Tab.
4.
• P 2 maps its input elements to β bins using Cuckoo hashing with two hash functions and a stash; empty bins are padded with a dummy element d 2 .
• P 1 maps its input elements into β bins using simple hashing.
The size of the bins is set to be max β , a parameter that is set to ensure that no bin overflows (see §7.1).
The remaining slots in each bin are padded with a dummy element d 1 񮽙 = d 2 .
The analy-sis described in §7.1 shows how max β is computed and is set to a value smaller than log 2 n.• The parties securely evaluate a circuit that compares the element that was mapped to a bin by P 2 to each of the max β elements mapped to it by P 1 .
• Finally, each element in P 2 's stash is checked for equality with all n 1 input elements of P 1 by securely evaluating a circuit computing this functionality.
• To reduce the bit-length of the elements in the bins, and respectively the circuit size, the protocol uses permutation-based hashing as described in §4.
(Note that using this technique is impossible with SCS circuits of [12].)
A detailed analysis of the circuit size and depth Let m be the size of P 1 's input to the circuit with m = β max β + sn 1 , i.e., for each of the β bins, P 1 inputs max β items as well as n 1 items for each of the s positions in the stash.
The circuit computes a total of m comparisons between the elements of the two parties.
Each element is of length σ 񮽙 bits, which is the reduced length of the elements after being mapped to bins using permutationbased hashing, i.e. σ 񮽙 = σ − log 2 β .
A comparison of two σ 񮽙 -bit elements is done by computing the bitwise XOR of the elements and then a tree of σ 񮽙 − 1 OR gates, with depth 񮽙log 2 σ 񮽙 񮽙.
The topmost gate of this tree is a NOR gate.
Afterwards, the circuit computes the XOR of the results of all comparisons involving each item of P 2 .
(Note that at most one of the comparisons results in a match, therefore the circuit can compute the XOR, rather than the OR, of the results of the comparisons.)
Overall, the circuit consists of about m · (σ 񮽙 − 1) ≈ n 1 · (max β + s) · (σ 񮽙 − 1) non-linear gates and has an AND depth of 񮽙log 2 σ 񮽙.
Advantages Circuit-Phasing has several advantages over the SCS circuit:• Compared to the number of AND gates in the SCS circuit, which is 3nσ log n, and recalling that σ 񮽙 < σ , and that max β was shown in our experiments to be no greater than log n, the number of nonlinear gates in Circuit-Phasing is smaller by a factor greater than 3 compared to the number of non-linear gates in the SCS circuit (even though both circuits have the same big "O" asymptotic sizes).
• The main advantage of Circuit-Phasing is the low AND depth of log 2 (σ ), which is also independent of the number of elements n.
This affects the overhead of the GMW protocol that requires a round of interaction for every level in the circuit.
• Another advantage of Circuit-Phasing is its simple structure: the same small comparison circuit is evaluated for each bin.
This property allows for a SIMD (Single Instruction Multiple Data) evaluation with a very low memory footprint and easy parallelization.Hashing failures: The correct performance of the protocol depends on the successful completion of the hashing operations: The Cuckoo hashing must succeed, and the simple hashing must not place more than max β elements in each bin.
Tables of size 2(1 + ε)n and max β = O(log n) guarantee these properties with high probability.
We analyze the exactly required table sizes in §7 and set them to be negligible in the statistical security parameter λ .
We improve the OT-PSI protocol of [22] by applying the following changes to the protocol:• Reducing the bit-length of the items using the permutation-based hashing technique described in §4.
This improvement reduces the length of the items from |x| bits to |x|−β bits, where β is the size of the tables, and consequently reduces the number of OTs by a factor of β /|x|.
• Using OTs on a single mask instead of on O(log n) masks before.
This improvement is detailed in §6.1.
• Improving the utilization of bins by using 3-way Cuckoo hashing ( §6.2).
We call the resulting PSI protocol that combines all these optimizations OT-Phasing.
In the full version [21], we evaluate the performance gain of each optimization individually and micro-benchmark the resulting protocol.
In order to hide information about the number of items that were mapped to a bin, the original OT-PSI protocol of [22] (cf. §3.5) padded all bins to a maximum size of max β = O(log n).
The protocol then ran OTs on max β masks of 񮽙-bit length where the parties had to generate and process all of the max β masks.
We describe here a new construction that enables the parties to compute only a constant number of masks per element, regardless of the number of elements that were mapped to the bin by P 1 .
While this change seems only small, it greatly increases the performance and scalability of the protocol (cf. iterative performance improvements in the full version [21]).
In particular, this change results in two improvements to the protocol:• The number of symmetric cryptographic operations to generate the masks is reduced from O(log 2 n) to O(log n).
Furthermore, note that P 2 had to compute the plaintext intersection between his n 2 max β generated masks and the 2n 1 masks sent by P 1 .
This also greatly improves the memory footprint and plaintext intersection.
• In the previous OT-based protocol, a larger value of the parameter max β reduced the failure probability of the simple hashing procedure used by P 1 , but increased the string size in the OTs.
In the new protocol the value of max β does not affect the overhead.
Therefore P 1 can use arbitrarily large bins and ensure that the mapping that it performs never fails.
Recall that in the OT-based PSI protocol of [22] (cf. §3.5) the parties had inputs of t characters, where each character was µ bits long, and we used the notation N = 2 µ .
The parties performed OTs on strings of max β masks per bin.
Each mask had length 񮽙 = λ + log 2 (n 1 ) + log 2 (n 2 ) bits, corresponded to an element that P 1 mapped to the bin, and included a 1-out-of-N random-OT for each of the t characters of this element.
P 1 was the sender, received all the N sender input-strings of each OT, and chose from them the one corresponding to the value of the character in its own element.
P 2 was the receiver and received the string corresponding to the value of the character in its own element.
Then P 1 computed the XOR of the t strings corresponding to the t characters of its element and sent this XOR value to P 2 , which compared it to the XOR of its t outputs from OT.The protocol can be improved by running the t 1-outof-N OTs on a single mask per bin.
Denote by u the actual number of items mapped by P 1 to a bin.
The value of u is not revealed to P 2 in the new protocol and therefore there is no need to pad the bin with dummy items.
Denote the single item that P 2 mapped to the bin as y = y 1 ,.
.
.
,y t , and the u items that P 1 mapped to the bin as x 1 ,.
.
.
,x u , where each x i is defined as x i = x i 1 ,.
.
.
,x i t .
Define the input strings to the j-th OT as {s j,, } 񮽙=1...N .
The protocol that is executed is a random OT and therefore these strings are chosen by the protocol and not by P 1 Note that over all bins, P 1 needs to perform this computation only O(n 1 ) times and compute O(n 1 ) hash values.
P 1 then sends all these values to P 2 in randomly permuted order.
P 2 computes the intersection between these values and the H(S P 2 ) values that it computed in the protocol.Efficiency: P 2 computes only a single set of t OTs per bin on one mask, compared to t OTs on max β masks in the OT-based protocol of [22].
As for P 1 's work, it computes a single set of OTs per bin, and in addition computes a XOR of strings and a hash for each of its O(n 1 ) input elements.
This is a factor of max β = O(log n 1 ) less work as before.
Communication is only O(nσ ) strings, as before.Security: Assuming that the OT protocols are secure and that the parties are semi-honest, the only information that is received by any party in the protocol is the H(S i P 1 ) values that are sent from P 1 to P 2 .
For all values in the intersection of the input sets of the two parties, P 1 sends to P 2 the same hash values as those computed by P 2 .
Consider the set of input elements ¯ X that are part of P 1 's input and are not in P 2 's input, and the set of XOR values corresponding to ¯ X.
There might be linear dependencies between the XOR values of ¯ X, but it holds with overwhelming probability that all these values are different, and they are also all different from the XOR values computed by P 2 .
Therefore, the result of applying a random hash function H() to these values is a set of random elements in the range of the hash function.
This property enables to easily provide a simulation based proof of security for the protocol.
The original OT-based PSI protocol of [22] uses Cuckoo hashing which employs two hash functions to map elements into bins.
It was shown in [20] that if n elements are mapped to 2(1 + ε)n bins, Cuckoo hashing succeeds with high probability for ε > 0.
This means that Cuckoo hashing achieves around 50% utilization of the bins.
If the number of hash functions h is increased to h > 2, a much better utilization of bins can be achieved [6].
However, using h hash functions in our protocol requires P 1 to map each element h times into its bins using simple hashing and requires P 1 to send hn 1 masks in the intersection step of the protocol.We detail in Tab.
1 the utilization and total communication of our PSI protocol for n 1 = n 2 = 2 20 and n 2 = 2 8 񮽙 n 1 = 2 20 , for σ = 32-bit elements with different numbers of hash functions.
We observe that there is a tradeoff between the communication for the OTs and the communication for the masks that are sent by P 1 .
Our goal is to minimize the total communication, and this is achieved for h = 3 hash functions in the setting of n 1 = n 2 and for h = 2 in the setting of n 2 񮽙 n 1 .
For n 1 = n 2 using h = 3 instead of h = 2, as in the original protocol of [22], reduces the overall communication by 33%.
Hashing failures: We observe that with OT-Phasing, there is essentially no bound on the number of items that the server can map to each specific bin, since the client does not observe this value in any way (the message that the client receives only depends on the total number of items that the server has).
However, the parameters used Table 1: Overall communication for a larger number of hash functions h. Communication is given for a) n 1 = n 2 = 2 20 and b) n 2 = 2 8 񮽙 n 1 = 2 20 elements of σ = 32-bit length.
Utilization according to [6].
in the protocol do need to ensure that the Cuckoo hashing procedure does not fail.
The analysis appears in §7.
The PSI schemes we presented use simple hashing (by P 1 ), and Cuckoo hashing (by P 2 ).
In both hashing schemes, the usage of bins (or a stash) of constant size, might result in hashing failures if the number of items mapped to a bin (or the stash) exceeds its capacity.
When hashing fails, the party which performed the hashing has two options: (1) Ignore the item that cannot be mapped by the hashing scheme.
This essentially means that this item is removed from the party's input to the PSI protocol.
Consequently, the output of the computation might not be correct (although, if this type of event happens rarely, the effect on correctness is likely to be marginal).
(2) Attempt to use a different set of hash functions, and recompute the hash of all items.
In this case the other party must be informed that new hash functions are used.
This is essentially a privacy leak: for example, the other party can check if the input set S of the first party might be equal to a set S 񮽙 (if a hashing failure does not occur for S 񮽙 then clearly S 񮽙 񮽙 = S).
The effect of this leak is likely to be weak, too, but it is hard to quantify.The effect of hashing failures is likely to be marginal, and might be acceptable in many usage settings (for example, when measuring ad conversion rates it typically does not matter if the revenue from a single ad view is ignored).
However, it is preferable to set the probability of hashing failures to be negligibly small.In OT-Phasing, P 2 does not learn the number of items that P 1 maps to each bin, and therefore P 1 can set the size of the bins to be arbitrarily large.
However, in that PSI protocol P 1 knows the size of the stash that is used in the Cuckoo hashing done by P 2 .
In Circuit-Phasing, each party knows the size of the bins (or stash) that is used by the other party.
We are therefore interested in learning the failures probabilities of the following schemes, and bound them to be negligible, i.e., at most 2 −40 :• §7.1: Simple hashing in the Circuit-Phasing scheme, where n items are mapped using two independent functions to 2.4n bins.
This is equivalent to mapping 2n items to 2.4n bins.
• §7.2: Cuckoo hashing, using 2.4n bins and either 2-way hashing (for Circuit-Phasing), or 3-way hashing (for OT-Phasing).
The failure probability for 3-way hashing is smaller than for 2-way hashing (since there is an additional bin to which each item can be mapped), and therefore we will only examine the failure probability of 2-way Cuckoo hashing.
It was shown in [23] that when n balls are mapped at random to n bins then the maximum number of elements in a bin is with high probability ln n ln ln n (1 + o (1)).
Let us examine in more detail the probability of the following event, "2n balls are mapped at random to 2.4n bins, and the most occupied bin has at least k balls":Pr(∃bin with ≥ k balls) (1) ≤ 2.4n · Pr(bin #1 has ≥ k balls) (2) ≤ 2.4n 񮽙 2n k 񮽙񮽙 1 2.4n 񮽙 k (3) ≤ 񮽙 2ne k 񮽙 k 񮽙 1 2.4n 񮽙 k−1 (4) = n 񮽙 2e k 񮽙 k 񮽙 1 2.4 񮽙 k−1 .
(5)It is straightforward to see that this probability can be bounded to be at most 2 −40 by setting k ≥ max(6, 2e log n/ log log n).
We calculated for some values of n the desired bin sizes based on the upper bound of Eq.
(6) and the tighter calculation of Eq.
(5), and chose the minimal value of k that reduces the failure probability to below 2 −40 .
The results are in It was shown in [16] that Cuckoo hashing with a stash of size s fails with probability O(n −s ).
The constants in the big "O" notation are unclear, but it is obvious that O(n −s ) ≤ n −(s−1) for sufficiently large values of n.
We would like to find the exact size of the stash that ensures that the failure probability is smaller than 2 −40 .
We ran 2 30 repetitions of Cuckoo hashing, mapping n items to 2.4n bins, for n ∈ {2 11 , 2 12 , 2 13 , 2 14 }, and recorded the stash size s that was needed for Cuckoo hashing to be successful.
Tab.
3 depicts the number of repetitions where we required a stash of size s. From the results we can observe that, to achieve 2 −30 failure probability of Cuckoo hashing, we would require a stash of size s = 6 for n = 2 11 , s = 5 for n = 2 12 , and s = 4 for both n = 2 13 and n = 2 14 elements.However, in our experiments we need the stash sizes for larger values of n ≥ 2 14 to achieve a Cuckoo hashing failure probability of 2 −40 .
To obtain the failure probabilities for larger values of n, we extrapolate the results from Tab.
3 using linear regression and illustrate the results in Fig. 1.
We observe that the stash size for achieving a failure probability of 2 −40 is drastically reduced for higher values of n: for n = 2 16 we need a stash of size s = 4, for n = 2 20 we need s = 3, and for n = 2 24 we need s = 2.
This observation is in line with the asymptotic failure probability of O(n −s ).
Finally, we extrapolate the required stash sizes s to achieve a failure probability of 2 −40 for smaller values of n ∈ {2 8 , 2 12 } and give the results together with the stash sizes for n ∈ {2 16 , 2 20 , 2 24 } in Tab Table 4: Required stash sizes s to achieve 2 −40 error probability when mapping n elements into 2.4n bins.
We report on our empirical performance evaluation of Circuit-Phasing ( §5) and OT-Phasing ( §6) next.
We evaluate their performance separately ( §8.1 and §8.2), since special purpose protocols for set intersection were shown to greatly outperform circuit-based solutions in [22].
(The latter are nevertheless of independent interest because their functionality can be easily modified.)
Figure 1: Error probability when mapping n elements to 2.4n bins using 2-way Cuckoo hashing for stash sizes 1 ≤ s ≤ 6.
The solid lines correspond to actual measurements, the dashed lines were extrapolated using linear regression.
Both axes are in logarithmic scale.Benchmarking Environment We consider two benchmark settings: a LAN setting and a WAN setting.
The LAN setting consists of two desktop PCs (Intel Haswell i7-4770K with 3.5 GHz and 16GB RAM) connected by Gigabit LAN.
The WAN setting consists of two Amazon EC2 m3.medium instances (Intel Xeon E5-2670 CPU with 2.6 GHz and 3.75 GB RAM) located in the US east coast (North Virginia) and Europe (Frankfurt) with an average bandwidth of 50 MB/s and average latency (round-trip time) of 96 ms. We perform all experiments for a symmetric security parameter κ = 128-bit and statistical security parameter λ = 40 (cf. §2.1), using a single thread (except for GMW, where we use two threads to compute OT extension), and average the results over 10 executions.
In our experiments, we frequently encountered outliers in the WAN setting with more than twice of the average run-time, for which we repeated the execution.
The resulting variance decreased with increasing input set size; it was between 0.5% − 8.0% in the LAN setting and between 4% − 16% in the WAN setting.
Note that all machines that we perform our experiments on are equipped with the AES-NI extensions which allows for very fast AES evaluation.Implementation Details We instantiate the random oracle, the function for hashing into smaller domains, and the correlation-robust function in OT extension with SHA256.
We instantiate the pseudo-random generator using AES-CTR and the pseudo-random permutation in the server-aided protocol of [15] using AES.
To compute the 񮽙 2 µ 1 񮽙 -OT t 񮽙 functionality, we use the random 1-out-of-N OT extension of [17] and set µ = 8, i.e., use N = 256, since this was shown to result in minimal overhead in [22].
We measure the times for the function evaluation including the cost for precomputing the OT extension protocol and build on the OT extension implementation of [2].
Our OT-Phasing implementation is available online at https://github.com/encryptogroup/PSI and our Circuit-Phasing implementation is available as part of the ABY framework of [5] at https://github .
com/encryptogroup/ABY.
For simple hashing we use the maximum bin sizes that were computed using Equation 5 in §7.1 (cf. Tab.
2).
For Cuckoo hashing, we set ε = 0.2 and map n elements to 2(1 + ε)n bins for 2-way Cuckoo hashing and to (1 + ε)n bins for 3-way Cuckoo hashing with a stash size according to Tab.
4.
The only exception for the stash size are the experiments with different set sizes in §8.2.2, where we use no stash for our OT-Phasing protocol.For OT-based PSI [22] and OT-Phasing, where the performance depends on the bit-length of elements, we hash the σ -bit input elements into a 񮽙 = λ + log 2 (n 1 ) + log 2 (n 2 )-bit representation using SHA256 if σ > >.
We use a garbled circuits implementation with most recent optimizations (cf. full version [21] for details).
We emphasize that all implementations are done in the same programming language (C++), use the same underlying libraries for evaluating cryptographic operations (OpenSSL for symmetric cryptography and Miracl for elliptic curve cryptography), perform the plaintextintersection of elements using a standard hash map, are all executed using a single thread (except for the GMW implementation which uses two threads), and run in the same benchmarking environment.
For the generic secure computation-based PSI protocols, we perform the evaluation on a number of elements varying from 2 8 to 2 20 and a fixed bit-length of σ = 32-bit.
For n = 2 20 all implementations, except CircuitPhasing with GMW, exceeded the available memory, which is due to the large number of AND gates in the SCS circuit (estimated 2 billion AND gates) and the requirement to represent bits as keys for Circuit-Phasing with Yao, where storing only the input wire labels to the circuit requires 1 GB.
A more careful implementation, however, could allow the evaluation of these circuits.
We compare the sort-compare-shuffle (SCS) circuit of [12] and its depth-optimized version of [22], with Circuit-Phasing ( §5), by evaluating both constructions using Yao's garbled circuits protocol [25] and the GMW protocol [11] in the LAN and WAN setting.
We use the size-optimized version of the SCS circuit in Yao's garbled circuit and the depth-optimized version of the circuit in the GMW protocol (cf. §3.4).
For the evaluation in Circuit-Phasing, we set the maximum bin size in simple hashing according to Equation 5 (cf. Tab.
2, set ε = 0.2, set the stash size according to Tab.
4, and assume n = n 1 = n 2 .
The run-time of Circuit-Phasing would increase linear in the bin size max β , while the stash size s would have a smaller impact on the total run-time as the concrete factors are smaller.Run-Time (Tab.
5) Our main observation is that Circuit-Phasing outperforms the SCS circuit of [12] for all parameters except Yao's garbled circuits with small set sizes n = 2 8 .
In this case, the high stash size of s = 12 greatly impacts the run-time of Circuit-Phasing.
When evaluated using Yao's garbled circuits, Circuit-Phasing outperforms the SCS circuit by a factor of 1-2, and when evaluated using GMW it outperforms SCS by a factor of 2-5.
Furthermore, the run-time for Circuit-Phasing grows slower with n than for the SCS circuit for all settings except for GMW in the WAN setting.
There, the run-time of the SCS circuit grows slower than that of Circuit-Phasing.
This can be explained by the high number of communication rounds of the SCS based protocol, which are slowly being amortized with increasing values of n.
The slower increase of the run-time of CircuitPhasing with increasing n is due to the smaller increase of the bin size max β ∈ O( ln n ln ln n ) vs. O(log n) for the SCS circuit, and the use of permutation-based hashing, which reduces the bit-length of the inputs to the circuit.
Note that our Yao's garbled circuits implementation suffers from similar performance drawbacks in the WAN setting as our GMW implementation, although being a constant round protocol.
This can be explained by the pipelining optimization we implement, where the parties pipeline the garbled circuits generation and evaluation.
The performance drawback could be reduced by using an implementation that uses independent threads for sending / receiving.Communication (Tab.
6) Analogously to the run-time results, Circuit-Phasing improves the communication of the SCS circuit by factor of 1-4 and grows slower with increasing values of n.
The improvement of the round complexity, which is mostly important for GMW, is even more drastic.
Here, Circuit-Phasing outperforms the SCS circuit by a factor of 16-38.
Note that the round complexity of Circuit-Phasing only depends on the bit-length of items and is independent of the number of elements.
For the special purpose PSI protocols we perform the experimental evaluation for equally sized sets n 1 = We compare OT-Phasing ( §6) to the original OT-based PSI protocol of [22], the naive hashing solution ( §3.1), the semi-honest server-aided protocol of [15] ( §3.2), and the Diffie-Hellmann (DH)-based protocol of [18] ( §3.3) using elliptic curves.
Note that the naive hashing protocol and the server-aided protocol of [15] have different security assumptions and cannot directly be compared to the remaining protocols.
We nevertheless included them in our comparison to serve as a base-line on the efficiency of PSI.
For the protocol of [15], we run the server routine that computes the intersection between the sets on the machine located at the US east coast (North Virginia) and the server and client routine on the machine in Europe (Frankfurt).
For the original OT-based PSI and OTPhasing, we give the run-time and communication for three bit-lengths: short σ = 32 (e.g., for IPv4 addresses), medium σ = 64 (e.g., for credit card numbers), and long σ = 128 (for set intersection between arbitrary inputs).
Note that the OT-based PSI protocol of [22] and our OT-Phasing protocol both evaluate public-key cryptography during the base-OTs, which dominates the run-time for small sets.
However, these base-OTs only need to be computed once and can be re-used over multiple sessions.
In the LAN setting, the average run-time for computing the 256 base-OTs was 125 ms while in the WAN setting the run-time was 245 ms. Nevertheless, our results all contain the time for the base-OTs to provide an estimation of the total run-time.
In the experiments for input sets of equal size n = n 1 = n 2 we set n ∈ {2 8 , 2 12 , 2 16 , 2 20 , 2 24 } in the LAN setting and n ∈ {2 8 , 2 12 , 2 16 , 2 20 } in the WAN setting.
Note that for larger bit-lengths σ ≥ 64 and for n = 2 24 elements, the memory needed for the OT-based PSI protocol of [22] exceeded the available memory.Run-Time (Tab.
7) As expected, the lowest run-time for the equal set-size experiments is achieved by the (insecure) naive hashing protocol followed by the serveraided protocol of [15], which has around twice the runtime.
In the LAN setting, however, for short bit-length σ = 32, our OT-Phasing protocol nearly achieves the same run-time as both of these solutions (which are in a different security model).
In particular, when computing the intersection for n = 2 24 elements, our OT-Phasing protocol requires only 3.5 more time than the naive hashing protocol and 2.5 more time than the server-aided protocol.
In comparison, for the same parameters, the original OT-based PSI protocol of [22] has a 68 times higher run-time than the naive hashing protocol, and the DHbased ECC protocol of [18] has a four orders of magnitude higher run-time compared to naive hashing.While the run-time of our OT-Phasing protocol increases with the bit-length of elements, for σ = 128-bit its run-time is only 15 times higher than the naive hashing protocol, and is still nearly two orders of magnitude better than the DH-based ECC protocol.Overall, in the LAN setting and for larger sets (e.g., n = 2 24 ), the run time of OT-Phasing is 20x better than that of the original OT-based PSI protocol of [22], and [15] 0.01 0.16 2.5 40.0 640.0 (n 1 + n 2 + |X ∩Y |)κ DH-based ECC [18] 0.02 0.28 4.56 74.0 1,200.0 (n 1 + n 2 )ϕ + n 1 񮽙 Bit-length σ = 32-bit OT PSI [22] 0.09 Table 8: Communication in MB for PSI protocols with n = n 1 = n 2 elements. 񮽙
= λ + log 2 (n 1 ) + log 2 (n 2 ).
Assuming intersection of size 1/2 · n for TTP-based protocol.
(Protocols with ( * ) are in a different security model.)
60-278x better than that of the DH-ECC protocol of [18].
When switching to the WAN setting, the run-times of the protocols are all increased by a factor of 2-6.
Note that the faster protocols suffer from a greater performance loss (factors of 5 and 6 for 2 20 elements, for the naive hashing protocol and server-aided protocol) than the slower protocols (factor 3 for the DH-based and our OT-Phasing protocol and 2.5 for the OT-based PSI protocol of [22]).
This difference can be explained by the greater impact of the high latency of 97 ms on the runtime of the protocols.
The relative performance among the protocols remains similar to the LAN setting.Communication (Tab.
8) The amount of communication performed during protocol execution is often more limiting than the required computation power, since the latter can be scaled up more easily by using more machines.
The naive hashing approach has the lowest communication among all protocols, followed by the serveraided solution of [15].
Among the secure two-party PSI protocols, the DH-based ECC protocol of [18] has the lowest communication.
In the setting for n = 2 24 elements of short bit-length σ = 32 bit, our OT-Phasing protocol nearly achieves the same complexity as the DH-based ECC protocol, which is due to the use of permutation-based hashing.
This is quite surprising, as protocols that use public-key cryptography, in particular elliptic curves, were believed to have much lower communication complexity than protocols based on other cryptographic techniques.In comparison to the original OT-based PSI protocol of [22], OT-Phasing reduces the communication for all combinations of elements and bit-lengths by factor 2.5 -4.
We also observe that OT-Phasing reduces the impact when performing PSI on elements of longer bit-length.
In fact, it even has a lower communication for σ = 128 than the original OT-based PSI protocol has for σ = 32.
For examining the setting where the two parties have different input sizes, we set n 1 ∈ {2 16 , 2 20 , 2 24 } and n 2 ∈ {2 8 , 2 12 } and run the protocols on all combinations such that n 2 񮽙 n 1 .
Note that we excluded the original OT-based PSI protocol of [22] from the comparison, since the bin size max β becomes large when β 񮽙 n and the memory requirement when padding all bins to max β elements quickly exceeded the available memory.
In this setting, unlike the equal input sizes experiments in §8.2.1, we use h = 2 hash functions instead of h = 3, Setting LAN WAN Protocol n 2 = 2 8 n 2 = 2 12 n 2 = 2 8 n 2 = 2 12 n 1 = 2 16 n 1 = 2 20 n 1 = 2 24 n 1 = 2 16 n 1 = 2 20 n 1 = 2 24 n 1 = 2 16 n 1 = 2 20 n 1 = 2 16 n 1 = 2 20Naive Hashing Table 10: Communication in MB for special purpose PSI protocols with n 2 񮽙 n 1 elements. 񮽙
= λ + log 2 (n 1 ) + log 2 (n 2 ).
Assuming intersection of size 1/2 · n 2 for the TTP-based protocol.
(Protocols with ( * ) are in a different security model.)
since this results in less total computation and communication (cf. §6.2).
Since we use h = 2 hash functions, we also increase the number of bins from 1.2n 2 to 2.4n 2 .
Furthermore, we do not use a stash for our OT-Phasing protocol with different input sizes, since the stash would greatly increase the overall communication.
However, not using a stash reveals some information on P 2 's set (cf. §7).
We show how to secure our protocol at a much lower cost by increasing the number of bins in the full version [21].
Run-Time (Tab.
9) Similar to the results for equal set sizes, the naive hashing protocol is the fastest protocol for all parameters.
The server-aided protocol of [15] is the second fastest protocol but it scales better than the naive hashing protocol for increasing number of elements.
The best scaling protocol is our OT-Phasing protocol.
It achieves the same performance as the serveraided protocol for n 2 = 2 8 , n 1 = 2 24 with short bit-length σ = 32.
For n 1 = 2 24 its run-time is at most twice that of the server-aided protocol in both network settings.
When switching to the WAN setting, the run-times of all protocols are increased by a factor 4-6 while the relative performance between the protocols remains similar, analogously to the equal set size experiments.Communication (Tab.
10) As expected, the naive hashing solution again has the lowest communication overhead.
Surprisingly, our OT-Phasing protocol achieves nearly the same communication as the serveraided protocol of [15] and has only two times the communication of the naive hashing protocol for all bitlengths.
Furthermore, our OT-Phasing protocol requires a factor of 2-3 less communication than the DH-based ECC protocol of [18] for nearly all parameters.
The low communication of our OT-Phasing protocol for unequal set sizes is due to the low number of OTs performed.
