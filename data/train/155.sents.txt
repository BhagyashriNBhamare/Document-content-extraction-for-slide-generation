Overlay networks have emerged as a generic networking paradigm to improve network performance and construct new applications.
Although many overlay algorithms have been proposed lately, they tend to focus on a single overlay, without considering how to share network capacity with other traffic and other overlays.
In this paper, we study optimal capacity sharing of network with multiple overlays.
We first formulate the problem of optimal capacity sharing of networks with multiple overlays as a nonlinear optimization problem.
We show that traditional flow-level rate controllers result in sub-optimal sharing results between the different overlays.
We design efficient and distributed overlay flows control algorithms and demonstrate the effectiveness of our design.
Overlay networks are emerging as a new paradigm for constructing new distributed applications and improving network performance.
In the last few years, many overlay networks have been proposed, evaluated, and deployed.
For instance, many large-scale, overlay-style content-delivery networks such as Akamai have been deployed.
Various large-scale testbed networks such as PlanetLab [1] and Emulab [2] are also structured as overlay networks.
The traffic generated by peerto-peer file-sharing applications such as BitTorrent, and VoIP applications such as Skype, is continuously on the rise.
In some networks, the traffic generated by such overlays is becoming the dominant traffic.However, there are serious concerns about the wide deployment of overlay networks.
One particular concern is that current overlay algorithms tend to focus on a single overlay, without considering the co-existence of other traffic and other overlays.
An overlay network may make resource allocation decisions too aggressively to utilize all available network resources without consideration of others, resulting in sub-optimal resource allocation, unfairness, and/or wild oscillations [3], [4].
Thus, a serious concern is that overlays improve their performance at the expense of others, and wide deployment of overlays may lead to overall degradation of the performance of the entire network.One way to regulate the behavior of overlays is to implement network congestion control.
While many traditional network congestion control schemes have been successfully proposed (e.g., [5], [6], [7], [8]) they work for point-to-point connections as opposed to the many-to-many connectivity seen in the world of overlays.
For example, under a widely used framework introduced by Kelly et al. in [9], the basic congestion control unit is a single unicast flow from one specific source to a specific destination.
However, an overlay network typically consists of many unicast flows belonging to multiple source-destination pairs.
If we view each overlay link as a single unicast flow, the whole overlay network could be treated as a collection of end-to-end flows.
We call them flowlevel rate controllers if the flows are controlled individually.
If they coordinate with each other, we call them overlaylevel rate controllers.
As we will show in Sec.
II, flow-level rate controllers may result in unfair and sub-optimal share of network resource between overlays.
Thus, a new overlaylevel rate control scheme is needed to share network resources efficiently, fairly, and distributedly in the emerging world of overlay networks.In this paper, we present a systematic framework to study the resource allocation and congestion control for networks with adaptive traffic generated by multiple overlays.
Specifically, we first formulate the optimal capacity sharing problem among multiple overlays using nonlinear optimization theory.
By modeling a traditional end-to-end flow as an overlay with only two nodes, our formulation is more general than existing models and considers both current adaptive point-to-point traffic and general overlay traffic.A technical challenge we need to address is how to solve the nonlinear optimization problem where an overlay may consist of multiple logical links in a distributed and efficient way.
In this paper, inspired by recent advances in optimization based congestion control, we derive general overlay-level congestion control algorithms to achieve optimal capacity sharing among overlays using queuing delay dynamics as a feedback from underlay networks.
Similar to many delay-based approaches, such as TCP Vegas [7] and FAST TCP [10], our solution can be implemented at each overlay node to adjust the traffic rate in a distributed way.We demonstrate the effectiveness of our algorithm using a case study of heterogeneous networks where multiple overlays try to find the maximum low from its sender to receiver.
We illustrate that overlays can share network capacity more efficiently by implementing our algorithms.
Overlays can improve overall network performance by probing for available network resources in a controlled manner, instead of by being unfair to other adaptive flows.The rest of the paper is organized as follows.
In Section II, we present our problem formulation and the sub-optimal results of capacity sharing among overlays.
In Section III, we derive a primal-dual algorithm to optimally share network capacity among multiple overlays.
We propose a distributed protocol to implement the algorithm.
In Section IV, we use overlay maximum flow as a case study to show the effectiveness of our algorithms by simulations.
Related work is discussed in Section V and Section VI concludes the paper.
We begin this section by defining the physical network and multiple overlays on top of it.
After that we formulate the optimal capacity sharing of multiple overlays as a constrained nonlinear optimization problem.
Then, we illustrate that the resource allocation could be sub-optimal if one uses only the flow-level rate control in this scenario.
Our underlay physical network is a graph G = (V, L, c), where V is the set of physical nodes, and L is the set of undirected physical links.
We assume each physical link has capacity c l .
Thus c = (c l ), l ∈ L is the vector representation of all link capacities.
The physical network resources are shared by multiple overlays.We represent each overlay network O i as a graphG i = (H i , E i ), where H i is the set of hosts, and E i is the set of directed overlay links.
The union of all overlay nodes is H = 񮽙 n i=1 H i and the union of all overlay links is E = 񮽙 n i=1 E i .
The end-to-end flow rate of each overlay link e ∈ E is x e .
If an overlay link belongs to E i , it is controlled by overlay O i .
We define overlay flows, x i = (x i e ) = (x i uv ), e = (h iu , h iv ) ∈ E i , as a vector of all end-to-end flows controlled by O i .
Generalizing traditional flow-level rate control, which regulates the flow rate of a single sender to a single receiver, overlay flows rate control adjusts a vector of flow rates among multiple participants.
Note that a traditional end-to-end flow is an overlay with just two nodes.Each overlay link e ∈ E corresponds to a physical path consisting of multiple physical links.
We use L(e) ⊆ L to represent this set of physical links.
We also define a L × E i routing indicator matrix A i = (A i le ), l ∈ L, e ∈ E i for each overlay O i , where A i le = 1 if l ∈ L(e) and A i le = 0 otherwise.
Each physical link l can be used by multiple overlay links.
We define E(l) ⊆ E as the set of overlay links that uses l.When multiple overlays co-exist in the same physical network, the physical constraints will place a limit on the combined traffic of all overlays.
This is where multiple overlays interact with each other.
Let A = (A i ), x = (x i ).
The physical capacity constraint can be represented asA · x ≤ c.(1)Many overlay networks are application specific.
While physical constraints specify the capacity limit on the physical network, application constraints preserve the relationship between different x e within an overlay.
For instance, flow conservation at each overlay node in many overlay applications is one such constraint.
Specifically, the flow conservation constraint can be represented as the follows.
Let e = (u, v).
For overlay O i , we can define a H i × E i matrix F i = (F i he ), h ∈ H i , e ∈ E i as following:F i he = ⎧ ⎨ ⎩ 1 if h = v −1 if h = u 0 otherwise.Thus, a compact representation of the flow conservation constraint isF i · x i = 0.
(2)For the general case, F i specifies the data relaying relationship in application level.
It is determined by application level topology, which is under control of the overlay topology construction algorithms.Note that in the preceding problem formulation, the same physical node is considered to be different in different overlays.
This is also true for overlay links that connect the same pairs of physical nodes.
This representation allows different overlay flows to use different control algorithms.
Table I ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ · ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ x 1 13 x 1 32 x 1 34 x 1 25 x 1 45 x 2 25 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ ≤ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 2 1 1 2 2 2 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ .
Equation (2) is application-specific.
For instance, in Fig. 1, we assume the objective of O 1 is to find the maximum flow from node 1 to node 5.
Since the source and destination node of maximum flow will not have any flow conservation constraints, the equality constraint forO i is ⎛ ⎜ ⎜ ⎜ ⎜ ⎝ 0 0 0 0 0 1 −1 −1 0 0 0 1 0 −1 0 0 0 1 0 −1 0 0 0 0 0 ⎞ ⎟ ⎟ ⎟ ⎟ ⎠ · ⎛ ⎜ ⎜ ⎜ ⎜ ⎝ x 1 13 x 1 32 x 1 34 x 1 25 x 1 45 ⎞ ⎟ ⎟ ⎟ ⎟ ⎠ = 0.
Each overlay can have its own objective.
The objective of overlay network O i can be represented by a utility function U i , which overlay O i tries to maximize.
The input to U i is an aggregation function applied to x i .
We use f i (x i ) to represent DefinitionO i ∈ {1, 2, ..., n}Overlay Network Session i.H i = {h i1 , h i2 , ..., h ij },|H i | = H i End hosts in session i. h ∈ H = S n i=1 H i , |H| = HSet of all overlay nodes.E i = {e i1 , e i2 , ..., e ik } Overlay links in session i. e = (u, v) ∈ E = S n i=1 E i , |E| = ESet of all overlay links.x i = (x i uv ), e = (h iu , h iv ) ∈ E iFlow rate vector in session i.f i (x i ) : x i → R Aggregation function for session i. l ∈ L = {1, .
.
, L} Set of physical links.
c = (c l , l ∈ L)The capacity constraint vector.
Overlay nodes.A i = (A i le ) L×E iRouting matrix for session i.F i = (F i he ) H i ×E i Application constraint matrix for i.this aggregation function.
Thus, the objective of overlayO i is to maximize U i (f i (x i )), under physical and application constraints.
Let F = (F i ).
If the system design objective is to maximize the sum of the utilities of all overlays, we can write the system problem as:P : Maximize: n 񮽙 i=1 U i (f i (x i ))(3)Subject to:A · x ≤ c (4) F · x = 0 (5)over:x e ≥ 0, ∀e ∈ E.(6)As a special case when all overlays are single end-to-end flows, f i (x) = x, F does not exist, and the above formulation is reduced to that of Kelly's framework in [9].
U i and f i are application specific.
We assume that U i is strictly concave.
For f i , we assume that it is differentiable but does not need to be strictly concave.
As an example,f i (x i ) = 񮽙 e∈Ei x e .
Many overlays [11] use periodical probing for available bandwidth and adjusting the flow rates to achieve the overall performance goal.
By formulating the overlay's objective in the optimization framework, we can have a better understanding of its behavior when they share the network resource with others.To solve the system problem P requires centralized computation and global knowledge of the network including each overlay's utility function, routing and capacity information in the underlay, and flow conservation information of each application.
Those make it almost impossible to solve in practice.
We will show a distributed algorithm that decouples the computation in a scalable way in Section III.
Before we solve the system problem P, we first show the necessity of solving P.
Since we are concerned with rate control and resource sharing, one possibility to do is to ignore the structure of overlays.
Thus, each overlay link will be considered as an individual flow.
The rate of each overlay link then is determined by traditional transport mechanism.
We call such a scheme flow-level rate control.
We will show that flowlevel rate control is inefficient for overlays.
We illustrate our points using two examples.
The first example consists of an overlay network O 1 and a competing TCP flow.
The physical network is shown in Fig. 1(a).
The overlay network and the TCP flow are shown in Fig. 1(b).
Let x tcp be the throughput of the TCP flow.
We write down the overlay flows of x 1 asx 1 = (x 1 13 , x 1 32 , x 1 34 , x 1 25 , x 1 45 ).
We assume the objective of O 1 is to find the maximum flow from node 1 and node 5.
Thus the aggregation functionf 1 (x 1 ) = x 1 25 + x 1 45 .
Since TCP is a single flow, f tcp (x tcp ) = x tcp .
Now we can write down the optimization objectives of both.
We consider proportional fairness among overlays.
So both overlays will use a log like utility function.
We have thatU tcp (f tcp (x tcp )) = log(x tcp ) U 1 (f 1 (x 1 )) = log(x 1 25 + x 1 45 ).
Thus any rate allocation which maximizes total utility U 1 + U tcp = log(x 1 25 + x 1 45 ) + log(x tcp ) under physical and application constraints achieves system optimum.
In particular, x 1 = (1, 0, 1, 0, 1), x tcp = 1 is a system optimal solution with a total utility value being 0.
However, if we use only flow-level control, then we may reach the following equilibrium: x 1 = (1, 1/3, 2/3, 1/3, 2/3), and x tcp = 1/3, when the network implements flow level fair sharing.
This is because when the overlay O 1 and the TCP flow saturate the bottleneck link c 2 = 1, each flow will get 1/3 of the link capacity.
No one can further increase its utility because the probing for available bandwidth will return 0 for x 1 25 ,x 1 32 and x tcp .
Although overlay O 1 achieves its optimum (U 1 (f 1 (x 1 )) = 0), the TCP flow does not (U tcp (x tcp ) = −0.48 ).
The total utility is only −0.48.
This simple example shows that we may not be able to achieve system optimum if we use only flow-level rate control.
Since overlays generally use more flows than a single TCP flow, they may improve performance at the expense of other TCP flows.2) Example 2: Sub-optimal capacity sharing of multiple overlays: In our second example, we will show that using flow-level rate control may lead to sub-optimal performance for overlays.
Thus overlays will have incentives to adopt new overlay flow control algorithms to achieve their optimum as well as system optimum.
The example consists of two overlays O 1 and O 2 .
The physical network is shown in Fig. 2(a).
The topology of O 1 is the same as the preceding example, and the topology of O 2 is shown in Fig 2(b).
The overlay flows of x 2 isx 2 = (x 2 31 , x 2 32 , x 2 14 , x 2 24 , x 2 45 ).
The objective of O 1 is still to find the maximum flow from node 1 to node 5.
The objective of O 2 is to find maximum flow from node 3 to node 5.
So the aggregation functions aref 1 (x 1 ) = x 1 25 + x 1 45 , f 2 (x 2 ) = x 2 45.
Consider the case when both overlays use linear utility functions.
ThusU 1 (f 1 (x 1 )) = x 1 25 + x 1 45 U 2 (f 2 (x 2 )) = x 2 45 .
The system optimization objective isU 1 + U 2 = x 1 25 + x 1 45 + x 2 45 .
We can see that x 1 = (1, 1, 0, 1, 0), x 2 = (0, 1, 0, 1, 1) is a system optimal solution with total utility value being 2.
However, if we use only fair sharing at flow level, then we may have the following sub-optimal equilibrium, in which O 1 and O 2 saturate the capacity of c 1 and c 4 : Equilibriumx 1 = (1/3, 0, 1/3, 0, 1/3) U 1 (f 1 (x 1 )) = 1/3.
Bottleneck: c 1 ,c 4 x 2 = (1/3, 1/3, 1/3, 1/3, 2/3) U 2 (f 2 (x 2 )) = 2/3.
At this equilibrium, both overlays get lower utilities compared with system optimum.
The total system utility value is only 1.
The example shows that if the overlay O 1 or O 2 uses only flow-level control it may reach sub-optimal solutions as it does not take into account the presence of other overlays.Given the preceding two examples, a natural question to ask then is whether it is possible to design an overlay flows control algorithm to make overlays friendly to TCP flows and to share network resource optimally among multiple overlays.
We address both questions in the next section.
In this section, we show a systematic framework to design algorithms for solving the problem P formulated in the preceding section.
To be scalable, we focus on distributed algorithms.
The distributed algorithms should have low communications overhead and shouldn not require explicit support from the underlay network.
Inspired by recent developments in optimization based Internet congestion control [6], [8], [12], we design a distributed overlay flows control algorithm to achieve the above goals.
Since different overlays may be formulated differently in P (e.g., with different f i and application constraints), our presentation is a generic framework.
In the next section, we will present a concrete instance.Below we first discuss the technical challenges.
Then we present primal-dual algorithms with convergence guarantees.
In problem P, although U i , the utility functions of overlays, are strictly concave, the final objective function U i (f i (x)) may not be strictly concave on x if f i is not strictly concave on x.
This would pose problems since the dual of the problem may not be differentiable at every point [13].
Some existing techniques based on duality (e.g., [6], [12]) can only deal with strictly concave objective functions.We address this problem by making the objective function in P strictly concave.
In particular, we use the Proximal Minimization method ( [13], Chapter 8) which enforces strict concavity by adding a quadratic term to the objective function and then iterates to eliminate the effects of the term.
Specifically, we introduce the vectorb = (b e ), ∀e ∈ E, b e ≥ 0 and define U e (x e ) = − 1 2κ (x e − b e ) 2 ,where κ is a positive scalar parameter.
Now consider the optimization problem P1 under the same constraints in (4)-(6), with objective function asP1 : Maximize: n 񮽙 i=1 U i (f i (x)) − n 񮽙 i=1 񮽙 e∈Ei 1 2κ (x e − b e ) 2Subject to:A · x ≤ c F · x = 0 over: x e ≥ 0, ∀e ∈ E.(7)If b = x * , where x * is the optimal solution to P, then the optimal solution to P1 is optimal to P as well.
Consider the iterative proximal minimization algorithm in Fig. 3, where x (0) is any feasible point and b (0) = x (0) .
for n = 1, 2, ... do: step 1.
Solve problem P1, with b = b (n−1) , obtain the optimal solution x (n) .
step 2.
Set b (n) = x (n) .
We show that the algorithm in Fig. 3 converges to the optimal solution of problem P as n → ∞ ( [14], pp 233).
Note that the preceding algorithm is a two-level optimization procedure.Step 2 in the algorithm is executed only when the procedure of solving Step 1 converges.
When κ is large, the objective function of P1 is close to the one in P.Step 1 may converge to a value close to the optimum with less iterations.
More detailed discussions on choosing κ and step size could be found in ( [14], pp234).
The preceding algorithm requires us to solve P1.
The Lagrangian of P1 can be derived as follows (b is constant in each iteration):L(x, p, μ) = n 񮽙 i=1 {U i (f i (x)) − 񮽙 e∈Ei 1 2κ (x e − b e ) 2 } 񮽙 񮽙񮽙 񮽙 Ψi(xi) − p(A · x − c) − μ(F · x) = n 񮽙 i=1 Ψ i (x i ) − 񮽙 l∈L p l ( 񮽙 e∈E A le x e − c l ) − μ(F · x) = n 񮽙 i=1 Ψ i (x i ) − 񮽙 e∈E x e 񮽙 l∈L p l A le − 񮽙 e∈E x e 񮽙 h∈H μ h F he + 񮽙 l∈L p l c l = n 񮽙 i=1 Ψ i (x i ) − 񮽙 e∈E x e q e − 񮽙 e∈E x e λ e + 񮽙 l∈L p l c l = n 񮽙 i=1 (Ψ i (x i ) − 񮽙 e∈Ei (q e + λ e )x e ) + 񮽙 l∈L p l c l = n 񮽙 i=1 Φ i (x i ) + 񮽙 l∈L p l c l .
(8)Here p = (p l , l ∈ L) represents the price vector of the physical links.
Letq e = 񮽙 l∈L p l A le = 񮽙 l∈L(e) p lbe the price of an overlay link.
Letλ e = 񮽙 h∈H μ h F hebe the application specified price.
The interpretation of the prices will vary in different applications depending on the format of F.Since the objective function of P1 is a strictly concave function of x, there exist a unique maximizing solution in Equation (7), say x * , and Lagrange multipliers p * and μ * , which satisfy the following Karush-Kuhn-Tucker conditions.
∂L ∂x e = 0 ⇒ ∀i, e ∈ E i , ∂Ψ i (x i ) ∂x e − (q * e + λ * e ) = 0 ⇒ U 񮽙 i (f i (x * )) · ∂f i ∂x e − 1 κ (x * e − b e ) − (q * e + λ * e ) = 0; p * (A · x * − c) = 0 A · x * ≤ c (9) F · x * = 0 ∀l ∈ L p * l ≥ 0.
To find the unique solution to P1 in a decentralized fashion, we can use either dual algorithms like [6], [12] or primaldual algorithms like [8], [15], [16].
Here, we consider primaldual algorithms, which solve convex programming problems by computing the primal and dual variables simultaneously and moving towards the saddle point at each step.Lety = A · x = (y l ), l ∈ L, z = F · x = (z h ), h ∈ {1, 2, ..., H} .
Also, define (y) + x for x ≥ 0 as follows (y) + x = 񮽙 y if x>0 max(y, 0) if x = 0.
(10)The primal-dual algorithm is described in Fig. 4.
Here, k e (x e ) > 0, h l (p l ) > 0, and m h (μ h ) > 0 are nondecreasing continuous functions.
We can see that in this algorithm, the dual variable p l is determined by the queuing process at physical links.
μ h could be updated by overlay flows control algorithms at each overlay node by comparing its total incoming flow rate with total outgoing flow rate.
x e will be updated by each flow controller using the shared information within its overlay (the aggregation function) and the feedback price information from q e and λ e .
All those updates are fully distributed like the updates discussed in [5], [6].
In addition, we have the following theorem: Theorem 3.1: The algorithm presented in Table 4 is globally asymptotically stable.
Proof: Please see appendix .
The global, asymptotic stability of the algorithm guarantees that starting from any initial condition, the primal-dual algorithm will converge to the unique solution of problem P1.
In the next section, we will use overlay maximum flow problem as a case study to show a detailed protocol implementation of the above algorithm.
∀e ∈ E ˙ x e = k e (x e )(U 񮽙 i (f i (x)) · ∂fi ∂xe − 1 κ (x e − b e ) − (q e + λ e )).
∀l ∈ L ˙ p l = h l (p l )(y l − c l ) + p l .
∀h ∈ H ˙ μ h = m h (μ h )(z h ).
In this section, we use overlay maximum flow as a case study to illustrate how to apply the algorithms in Section III to a specific problem.
The overlay maximum flow problem was also studied in [11] to demonstrate the importance of correlated link capacity constraints on overlay quality.
We will use the example in Fig.1 and Fig.2 to show the formulation and the resulting algorithm design.
We continue using the notation in Table I to formulate the problem.
We use h is and h ir to represent the sender and receiver in each overlay O i .
Overlay maximum flow problem is to find the maximum flow rate between h is and h ir .
For each node in an overlay network, we have the following flow conservation constraints.
∀i, ∀v ∈ H, v 񮽙 = h ir , v 񮽙 = h is 񮽙 (u,v)∈Ei x i uv = 񮽙 (v,w)∈Ei x i vw (11) ∀i, ∀v ∈ H, h ir , 񮽙 (hir,v)∈Ei x i rv = 0 (12) ∀i, ∀u ∈ H, h is , 񮽙 (u,his)∈Ei x i us = 0.
(13)In this problem, ∀u, v ∈ H, x uv ≥ 0, so from equation (12) and (13), we know that ∀h ir , h is , v ∈ H, x i rv = 0, x i vs = 0.
For simplicity, we remove such variables from x and remove constraints in equation (12) and (13) as well.
Let e = (u, v), the flow conservation constraints matrix F is:F i he = ⎧ ⎨ ⎩ 1 if h = v, h 񮽙 = h ir −1 if h = u, h 񮽙 = h is 0 otherwise.Then all the flow conservation constraints can be written as F · x = 0.
We define the aggregation function f i for overlay maximum flow problem asf i (x) = 񮽙 (u,hir)∈Ei x i ur = M i · x.(14)Here, M i is a 1 × E row vector where M i (e) = 1 when e = (u, h ir ), otherwise M i (e) = 0.
Then the objective of optimal capacity sharing among multiple overlays isn 񮽙 i=1 U i (M i · x).
We assume each overlay network has a strictly concave utility function U i .
In the physical network of Fig. 2(a), there are two overlay networks (n = 2).
⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ · ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ ≤ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 2 1 4 3 2 2 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ .
Matrix F in eqaution (5) becomes ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 0 0 0 0 0 0 0 0 0 0 1 −1 −1 0 0 0 0 0 0 0 0 1 0 −1 0 0 0 0 0 0 0 0 1 0 −1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 −1 0 0 0 0 0 0 0 0 1 0 −1 0 0 0 0 0 0 0 0 1 1 −1 0 0 0 0 0 0 0 0 0 0 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ .
In this example,M 1 = (0 0 0 1 1 0 0 0 0 0) f 1 (x) = x 1 25 + x 1 45 .
Also,M 2 = (0 0 0 0 0 0 0 0 0 1) f 2 (x) = x 2 45 .
Let q e = 񮽙 l∈L(e) p l , λ e = 񮽙 h∈Hi μ h F he = μ v − μ u when e = (u, v), assume ∀i, μ his = 0, μ hir = 0.
With the preceding formulation, the overlay flows control for the overlay maximum flow problem can be implemented using the proximal minimization and primal-dual algorithm.
In this section, we describe the assumptions, measurements and messages exchanged in implementing them in practice.
We focus on the requirements of the primal-dual algorithm.First, we assume that a flow rate x e is controlled and adjusted by the end host, denoted as the flow owner, O e .
The flow rate adaptation could be receiver based or sender based.
We use sender based approach similar to TCP: try and backoff from the sender.Since the algorithm is designed for overlay applications, we make no assumptions on the knowledge of the physical network.
The end hosts do not know the physical topology and capacity information, i.e., A and c in equation (1).
Instead, the overlays use natural accumulative path feedback metrics such as queuing delay dynamics from the underlay network as an indication of network congestion price.
In particular, end hosts measures the end to end delay of each virtual link periodically and thus infer the queuing delay on it.
This can be done in a way similar to TCP Vegas [7] and FAST [10].
Note that the information between the same pair of hosts can be shared among different overlays who are using it.
This can save the measurement overhead.We have two types of price: network price p l at each physical link; node price μ h at each overlay node, which indicates the flow conservation violation at that node.
Each flow owner will try to send the traffic at a certain rate and then observe the resulting prices of those two.
Then the flow owner will update the flow rate based on the received prices and current sending rate.
The protocol is presented in Fig. 5.
We implement the algorithm in Fig. 5 and study its effectiveness by extensive simulations using example topologies in Fig. 1 and Fig. 2 and topologies generated by the BRITE [17] topology generator.
Here we show the simulation results for the two examples discussed in Section II-C.
The utility function we used in the simulation is u(x) = log(x) for all users.
The results are summarized as follows.For the first example in Section II, as we can see in Fig. 6, the TCP flow converges to its optimal throughput 1 within 5 seconds.
O 1 converges to its optimal maximum flow rate 1 with 10 seconds.
Because overlay flows control need to adjust the flow rates on all of its links in a distributed manner, it generally converges slower than point-to-point flows.
The At time t = 1, 2, ... 1.
Receive flow rate x e(t) from all overlay flows e ∈ E(l).
2.
Update price:p l (t + 1) = [p l (t) + γ( P e∈E(l) xe(t) − c l )] + .
3.
Send p l (t + 1) to all overlay unicast flows e ∈ E(l) .
The above process is approximated by queuing process at physical network.
The p l is the queuing delay at each physical link.Node Price Update (by overlay node h):1.
Receive flow rate x e(t) from all adjacent links in its session.
2.
Update price:μ h (t + 1) = μ h (t) + γ( P e=(u,h) xe(t) − P e=(h,v) xe(t)).
3.
Send the updated price μ h (t + 1) to the senders who is connected to this node.
(by each overlay link e = (u, v)'s sender O e):1.
Measure qe(t) = P l∈L(e) p l (t).
This is the end to end queuing delay at the overlay link e. 2.
Receive node prices μ h (t) from node u and v. at the overlay receiver.
λ e(t) = μv(t) − μu(t) .
5.
Adjust rate:xe(t + 1) = ke(xe(t))(U 񮽙 i (Mi(x(t))) · ∂f i ∂xe .
− 1 κ (xe(t) − be) − (qe(t) + λe(t))) .
6.
Send x e(t + 1) to all links l ∈ L(e) and all neighbors.
time-varying values of the link prices and relay prices are plotted in Fig. 6 For the second example, from Fig. 7, we can see both overlays are able to converge to the system optimum with maximum flow rate 1 for each within 10 seconds.
By using an algorithm which considers other flows in the network, both overlays avoid the sub-optimal equilibria.From these examples, we can see that the primal-dual algorithm presented in Fig. 5 achieves optimality by requiring both unicast flows and overlay traffic to cooperate.
The algorithm converges to the optimal rate starting from different initial values.
One could consider our proposed framework as a generalization of protocol compliance requirements, such as TCP friendliness.
We also note that our framework solves the system optimization problem effectively without requiring explicit support from underlay routers.We also study the convergence of the flow rate in a dynamic environment.
In example 1, we add more TCP flows between node 2 and 5 at different time and observe the reaction of TCP flow 1.
The result is shown in Fig. 8.
We can see that our algorithm can react to the network changes quickly.
The rate of TCP flow 1 converges to the new optimal rate within 3 seconds when new members join in the physical network.
Overlay networks have been used to improve reliability (e.g., [18]) and provide better QoS support (e.g., [19]).
As selforganizing networks, they provide opportunities for end users to explore all available resources in a network.
Many overlay algorithms have been proposed lately.
However, they tend to focus on designing protocols for a single overlay network without considering sharing network resource with others.The aggressive use of network resources by overlays raises concerns to Internet users, designers and researchers.
In a recent work [3], Jiang et.
al propose the concept of overlay optimal routing, as a contrast to selfish routing [20].
In particular, they study the "interactions" among multiple overlays.
They show that when overlays optimize for performance in a selfish manner, the resulting equilibrium is inefficient and unfair.
Our work can be regarded as a study of what happens when the overlay networks play by the rules; we show that global optimality can be achieved if each overlay is wellbehaved and reacts to feedback from the physical network.Co-existing overlays have also been studied recently by Keralapura et al. in [4].
They investigate potential causes of race conditions and oscillations.
Overlapping routes and periodic path probing processes are some of the causes.
Coordination among overlays could alleviate this problem.
In our study, we realize that overlays interact with each other at saturated physical links.
Thus congestion control can be used to achieve the resource allocation goal and potentially help to reduce oscillations.Our work is also inspired by the study of correlations of overlay links [11].
In particular, Zhu et al. show that even a single overlay can benefit from finding the correlation among its links due to physical constraints, which means overlays not only interact with each other at bottleneck links but also have self-interference at those links.
Our design addresses both issues.Optimization based rate control (e.g., [21], [6], [7], [22]) provides us a powerful tool to solve system optimization problem in an efficient and distributed way.
In our model, each overlay network is a user, which extends the traditional flow based formulation.
In this paper, we study optimal capacity sharing of multiple overlays when each overlay network maximizes its own utility function.
We first show that using traditional flow-level rate control may not achieve system-wide optimality.
Then we provide a framework to solve the problem systematically.
We use congestion control mechanisms to allocate resources so that overlays can interact with other adaptive traffic, generated by unicast TCP flows or other overlays, in a friendly way.
We generalize traditional point-to-point congestion control mechanisms to work in multi-point, multi-overlay settings.
We then use our proposed framework to study the overlay maximum flow problem and provide simulation results to show the effectiveness of our distributed algorithm.
We hope this work can lead to further discussions on how to model and control the interactions among overlays, before overlay networks gain further traction in the Internet.
We thank Hao Wang and Haiyong Xie for their valuable discussions.
We also thank the anonymous reviewers for their helpful comments and suggestions.
Zheng Ma is supported by NSF grants ANI-0238038 and CNS-0435201.
Yang Richard Yang is supported in part by NSF grants ANI-0238038 and CNS-0435201.
Proof: We prove the stability of the primal-dual algorithm in Table 4 by using Lyapunov stability theory.
For more details on this, we refer interested readers to [8, Section 3.10].
Let's assume the unique solution of the optimization problem P1 is (x * , p * , μ * ).
It's easy to verify that it is an equilibrium point of the primal-dual algorithm.
We now prove that this point is globally asymptotically stable.
We will construct a continuously differentiable function V (x, p, μ) such thatV (x, p, μ) > 0, ∀ (x, p, μ) 񮽙 = (x * , p * , μ * ),and also˙ V (x, p, μ) ≤ 0, ∀ (x, p, μ) (15) ˙ V (x, p, μ) < 0, ∀ (x, p, μ) 񮽙 = (x * , p * , μ * ) (16) V (x, p, μ) → ∞, when 񮽙(x, p, μ)񮽙 → ∞.
(17)Consider the following function as a candidate for the Lyapunov function:V (x, p, μ) = n 񮽙 i=1 񮽙 e∈Ei 񮽙 xe x * e 1 k e (α) (α − x * e )dα + 񮽙 l∈L 񮽙 p l p * l 1 h l (β) (β − p * l )dβ + 񮽙 h∈H 񮽙 μ h μ * h 1 m h (γ) (γ − μ * h )dγ.
(18)Note that V (x * , p * , μ * ) = 0.
Since k e (α) > 0, when x e 񮽙 = x * e , we have the following 񮽙 xex * e 1 k e (α) (α − x * e )dα > 0.
This argument can be extended to other terms as well.
So when (x, p, μ) 񮽙 = (x * , p * , μ * ), we have V (x, p, μ) > 0 and unbounded when 񮽙(x, p, μ)񮽙 → ∞.
We only need to show Eq.
15 and Eq.
16 are true.
Now, using the primal-dual algorithm in Table 4, we have˙ V = n 񮽙 i=1 񮽙 e∈Ei ( ∂Ψ i (x) ∂x e − q e − λ e ) · (x e − x * e ) + 񮽙 l∈L (p l − p * l )(y l − c l ) + p l + 񮽙 h∈H (μ h − μ * h ) · z h .
(19)Note that (p l − p * l )(y l − c l ) + p l ≤ (p l − p * l )(y l − c l ).
(20)* l ≥ 0, 0 ≤ (p l − p * l )(y l − c l ).
Therefore, ˙ V ≤ n 񮽙 i=1 񮽙 e∈Ei ( ∂Ψ i (x) ∂x e − q e − λ e ) · (x e − x * e ) + 񮽙 l∈L (p l − p * l )(y l − c l ) + 񮽙 h∈H (μ h − μ * h ) · z h = n 񮽙 i=1 񮽙 e∈Ei ( ∂Ψ i (x) ∂x e − q * e − λ * e ) · (x e − x * e ) + 񮽙 l∈L (p l − p * l )(y * l − c l ) + 񮽙 h∈H (μ h − μ * h ) · z * h + n 񮽙 i=1 񮽙 e∈Ei (−q e − λ e + q * e + λ * e ) · (x e − x * e ) + 񮽙 l∈L (p l − p * l )(y l − y * l ) + 񮽙 h∈H (μ h − μ * h ) · (z h − z * h ).
(21)From the Karush-Kuhn-Tucker conditions in Eq.
9, we have˙ V ≤ n 񮽙 i=1 񮽙 e∈Ei ( ∂Ψ i (x) ∂x e − ∂Ψ i (x * ) ∂x e ) · (x e − x * e ) + 񮽙 l∈L p l (y * l − c l ) + 0 − n 񮽙 i=1 񮽙 e∈Ei (q e − q * e ) · (x e − x * e ) − n 񮽙 i=1 񮽙 e∈Ei (λ e − λ * e ) · (x e − x * e ) + 񮽙 l∈L (p l − p * l )(y l − y * l ) + 񮽙 h∈H (μ h − μ * h ) · (z h − z * h )(22)For q e , x e , y l , λ e , p l , μ h , z h , we have the following relationshipq e = 񮽙 l∈L p l A le = 񮽙 l∈L(e) p l y l = 񮽙 e∈E A le x e = n 񮽙 i=1 񮽙 e∈Ei A le x e λ e = 񮽙 h∈H μ h F he z h = 񮽙 e∈E F he x e = n 񮽙 i=1 񮽙 e∈Ei F he x e .
So n 񮽙 i=1 񮽙 e∈Ei q e · x e = n 񮽙 i=1 񮽙 e∈Ei 񮽙 l∈L p l A le x e = 񮽙 l∈L p l n 񮽙 i=1 񮽙 e∈Ei A le x e = 񮽙 l∈L p l y l .
(23) n 񮽙 i=1 񮽙 e∈Ei λ e · x e = n 񮽙 i=1 񮽙 e∈Ei 񮽙 h∈H μ h F he x e = 񮽙 h∈H μ h n 񮽙 i=1 񮽙 e∈Ei F he x e = 񮽙 h∈H μ h z h .
(24)With the above equations, Eq.
22 becomes˙ V ≤ n 񮽙 i=1 񮽙 e∈Ei ( ∂Ψ i (x) ∂x e − ∂Ψ i (x * ) ∂x e ) · (x e − x * e ) + 񮽙 l∈L p l (y * l − c l ).
(25)Because of the strict concavity of Ψ i (x), when x e ↑, ∂Ψi(x) ∂xe ↓.
So˙ V ≤ 񮽙 l∈L p l (y * l − c l ),(26)with equality if and only if x = x * .
So it follows that ˙ V ≤ 0 for all p l ≥ 0 since y * l − c l ≤ 0.
Further, ˙ V = 0 only when x = x * and for each link l, either p l = p * l or y * l = c l .
Thus, it follows by the theory of Lyapunov stability theory that the primal-dual algorithm is globally asymptotically stable.
