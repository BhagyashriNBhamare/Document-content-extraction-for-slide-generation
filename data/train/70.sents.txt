We consider the design of strategyproof cost-sharing mechanisms.
We give two simple, but extremely versatile , black-box reductions, that in combination reduce the cost-sharing mechanism-design problem to the al-gorithmic problem of finding a minimum-cost solution for a set of players.
Our first reduction shows that any truthful, α-approximation mechanism for the social-cost minimization (SCM) problem satisfying a technical no-bossiness condition can be morphed into a truthful mechanism that achieves an O(α log n)-approximation where the prices recover the cost incurred.
Thus, we de-couple the task of truthfully computing an outcome with near-optimal social cost from the cost-sharing problem.
This is fruitful since truthful mechanism-design, especially for single-dimensional problems, is a relatively well-understood and manageable task.
Our second reduction nicely complements the first one by showing that any LP-based ρ-approximation for the problem of finding a min-cost solution for a set of players yields a truthful, no-bossy, (ρ + 1)-approximation for the SCM problem (and hence, a truthful (ρ + 1) log n-approximation cost-sharing mechanism).
These reductions find a slew of applications, yielding , as corollaries, the first or improved polytime cost-sharing mechanisms for a variety of problems.
For example, our first reduction coupled with the celebrated VCG mechanism shows that for any cost-sharing problem (with a monotone cost function) one can obtain a truthful mechanism that achieves an O(log n)-approximation where the prices recover the cost incurred.
Other applications include O(log n)-approximation mechanisms for: survivable network design problems, facility location (FL) problems including capacitated and connected FL problems, and minimum-makespan scheduling on unrelated machines.
Our results demonstrate that in contrast with our current understanding of group-strategyproof and acyclic mechanisms , strategyproofness allows for ample flexibility in cost-sharing mechanism design enabling one to effectively leverage various algorithmic results.
* Consider a setting where n self-interested players compete to receive a service or good.
Each player has a private value for receiving the service, and may declare a bid that deviates from her true value if that increases her utility.
The service provider has to decide which set S of players will receive the service and at what prices, incurring a publicly-known cost C(S).
We assume that C(.)
is monotone: C(S) ≤ C(T ) if S ⊆ T .
How can one design a computationally-efficient protocol or mechanism that incentivizes truthful bidding where the outcome computed has good social welfare and the prices charged recover the cost incurred?
This is the subject of cost-sharing mechanism design.
More formally, a mechanism consists of an algorithm that outputs a solution, and a pricing scheme for specifying prices charged to the players; the utility earned by a player is her value under the algorithmic outcome minus the price she has to pay.
A mechanism is said to be truthful or strategyproof if each player maximizes her utility by declaring her true private value regardless of what the other players declare.
Three basic desirable properties of costsharing mechanisms that pervade the literature on costsharing mechanisms are: (a) strategyproofness (SP) (or stronger notions like group-SP (GSP)); (b) cost recovery, i.e., the revenue of the mechanism is at least the incurred cost; and (c) economic efficiency, i.e., socialwelfare maximization.
In algorithmic mechanism design we also require that the mechanism be computationally efficient.
The standard notion of social-welfare yields an ill-behaved optimization problem for which no approximation guarantees are achievable in polytime [19].
So, following [50], we formalize economic efficiency using the social-cost minimization (SCM) objective: minimize the sum of the cost incurred and the total value of players who do not receive service.In light of the impossibility of achieving all three requirements [22,47] much effort has been devoted into approaches that relax, or drop, one of the requirements.
General (algorithmic) mechanism-design techniques are much sought after, but quite rare.
Before describing our results, which make progress in this direction, we briefly discuss some known generic constructions.
The celebrated VCG mechanism [53,14,23] satisfies (a) and (c) (for any cost function) but achieves poor revenue and is computationally intractable in general.
(No such analogue, achieving (a) and relaxed versions of (b), (c) is known for general cost-sharing problems.)
At the other end, Moulin mechanisms [43] (in general) satisfy (a) and (b) at the expense of efficiency.
A Moulin-style mechanism is an iterative mechanism where prices are offered in each iteration to the current set of players; players who cannot afford to pay these prices drop out and we iterate with the remaining set of players.
The mechanism halts when all (current) players accept their prices.
Different variants arise depending on how exactly (i.e., simultaneously or one at a time) players are offered prices and drop out.
Moulin [43] proved that if the price-sequence offered to a player is nondecreasinga property called cross-monotonicity-and the prices recover the cost incurred for the current set, then the resulting mechanism is GSP and satisfies cost-recovery.
[50] recently showed that if the price-sequences satisfy a property called summability, then one can also bound the approximation of the resulting Moulin mechanism.Moulin's result has fueled much work on the design and analysis of such price sequences (also called cost shares) for various problems [44,33,50,46,49,34,12,26,7].
We emphasize however that all these results are tailored to the problem at hand.
There is no known black-box way of leveraging Moulin mechanisms (in conjunction with approximation algorithms) to obtain cost-sharing mechanisms that satisfy (a), relaxed versions of (b), (c).
In fact, as shown in [31], designing suitable cost shares can often be much more challenging than the underlying algorithmic problem.
For example, for vertex cover, cross-monotonic cost shares cannot recover more than O(1/|V | 1/3 )-fraction of the cost [31], and hence no Moulin mechanism that recovers the cost can achieve approximation better than Ω(1/|V | 1/3 ) (see Section 2).
As a means of overcoming these limitations, Mehta et al. [41] propose acyclic mechanisms, which are also Moulin-style mechanisms.
They show that for various problems, one can adapt known primal-dual algorithms for the underlying cost-minimization problem to obtain suitable cost shares, which yield acyclic mechanisms with improved guarantees.
But their techniques do not yield an automatic way of obtaining suitable cost shares from primal-dual algorithms and again the construction of cost shares is problem dependent.Our results.
We give two simple, but extremely versatile, black-box reductions, that in combination reduce the cost-sharing mechanism-design problem to the algorithmic cost-minimization (CM) problem of finding a minimum-cost solution for a set of players.Informal statement of reductions (1) Any truthful, α-approximation mechanism (for the SCM problem) that satisfies an additional no-bossiness property can be transformed in polytime into a truthful, O(α log n)-approximation mechanism that fully recovers the cost.
(2) For a large family of cost-sharing problems, any LP-based ρ-approximation algorithm for the CM problem yields a polytime truthful, no-bossy, (ρ + 1)-approximation mechanism.
(No-bossiness is the condition that if a winning player is unaffected by changing her bid, then neither is the outcome computed.)
Thus, our first reduction (Section 3) conveniently decouples the task of truthfully computing a solution with near-optimal social cost (i.e., properties (a) and (b) above) and the cost-recovery requirement (c).
We emphasize that this reduction applies to any (monotone) cost function.
The log n factor matches the approximation lower bound proved by Dobzinski et al. [17] for truthful cost-sharing mechanisms (for subadditive cost functions), which shows that the reduction is tight (up to constant factors).
This reduction is quite fruitful since (as our second reduction shows) truthful mechanism-design, especially for single-dimensional problems, is a relatively well-understood and manageable task.
One of the most widely used and remarkably successful paradigms in the design of approximation algorithms, is that of expressing a relaxation of the problem as a linear program (LP) and using this to design the approximation algorithm, either via LP rounding or via a primal-dual approach.
Our second reduction (see Section 4) shows that any LP-based approximation algorithm for the CM problem can be used to obtain a truthful, no-bossy, approximation mechanism that can be fed as input to the first reduction.
Thus, in combination, our reductions yield a generic way of exporting LPbased approximations for the CM problem into truthful, cost-recovering mechanisms with related approximation guarantees.
In contrast (to our liberal requirement of having an LP-based approximation algorithm), much of the extant work on cost-sharing mechanisms requires the use of cost shares satisfying various properties to obtain (good) cost-sharing mechanisms.
(Observe that an LP-based ρ-approximation for the SCM problem is also an LP-based ρ-approximation for the CM problem.)
With subadditive costs, our mechanisms (in addition to individual rationality) also ensure that no player i is charged a price larger than C({i}), a property we call individual competitiveness (ICT).
This is desirable, as otherwise an over-charged player has an incentive to refuse participation (and try to obtain the service from elsewhere at lower cost).
A related point is that we do not insist that the mechanism's revenue be at most β times the cost incurred (for some β > 1).
(This condition along with cost-recovery is called β-budget balance.)
The usual rationale for the upper bound is that one does not want the coalition of winning players to have an incentive to secede from the mechanism and Problem category Previous results Survivable network design problems (SNDPs) (rmax = maximum requirement)Edge-disjoint SNDP - O(log n) Element-Disjoint SNDP - O(log n) Vertex-Disjoint SNDP - O(r 3 max log 2 n) Steiner-Tree O(log 2 n) [50] O(log n) Steiner-Forest O(log 2 n) [12] O(log n) Facility location (FL) Uncapacitated FL O(log n) [49, 41] O(log n) Soft-capacitated FL (CFL)-O(log n) Multicommodity connected FL O(log 2 n) [49] O(log n)Covering problems Set cover O(log 2 n) [41] O(log 2 n) Vertex cover O(log n) [41] O(log n)Scheduling problems Makespan minimization on -O(log n) unrelated machines obtain the service from elsewhere at lower cost.
Since we focus on strategyproofness, we explicitly do not consider the effect of coalitions; focusing on individual players yields ICT instead as the natural requirement.A key feature of our reductions is their generality.
An immediate notable implication is that taking the VCG mechanism as input in the first reduction, we obtain, for any cost function, a truthful, O(log n)-approximation, cost-recovering mechanism.
Previously, such a result was known only for subadditive cost functions [5].
For a wide variety of cost-sharing problems, we obtain the first, or improved polytime cost-sharing mechanisms simply by plugging in a suitable LP-based algorithm.
We consider a few representative applications in Section 5, and summarize our results in Table 1.
We believe that our reductions will find many more applications.
Section 6 considers some extensions to multidimensional cost-sharing problems.
Our results demonstrate that in contrast with our current understanding of group-strategyproof and acyclic mechanisms, strategyproofness allows for ample flexibility in cost-sharing mechanism design enabling one to effectively leverage various algorithmic results.Our constructions are quite intuitive and easy to describe.
For the first reduction, we first observe that regardless of the cost shares used, the allocation rule f of a Moulin-style mechanism is always monotone, and hence one can find prices {p i } such that f, {p i } is a truthful mechanism.
Now we simply initialize the Moulin mechanism with the outcome returned by the input truthful mechanism and then use the uniform cost shares C(S)/|S|.
Since the Moulin mechanism preserves truthfulness, the resulting mechanism is truthful, while the cost shares prescribed ensure cost recovery at the expense of a log n-factor loss in approximation.
The second reduction proceeds by rejecting all the players who are rejected fractionally in the SCM LP, and using the LP-based algorithm for the CM problem to compute a solution for the remaining players.
Simple LP theory shows that for a broad class of LPs, this mechanism has all the desirable properties.Related work.
Moulin [43] and Moulin and Shenker [44] developed the theory of Moulin mechanisms.
Subsequently, suitable cost-sharing methods were developed for various combinatorial-optimization problems, such as Steiner tree [33], Steiner forest [34], facility location [46], connected facility location [27,39], and scheduling problems [4].
Prior to [50], such results focused on the design of cross-monotonic, approximately budget balanced (BB) cost shares; the resulting Moulin mechanisms do not however come with any (SCM-) approximation guarantees.
Immorlica et al. [31] exposed an inherent limitation of this method by proving lower bounds on the BB-factor achievable by crossmonotonic cost shares for various problems.
Devanur et al. [16] designed truthful, cost-recovering non-Moulin mechanisms for set cover and facility location, but do not prove any approximation guarantees.Roughgarden and Sundararajan [50] proposed the social-cost objective, and isolated a property of the costsharing method called summability that bounds the approximation of the resulting Moulin mechanism.
Subsequent work designed new cost-sharing methods [49,26,7,6] and/or re-analyzed previous cost-sharing methods [12,50,49] to also show summability bounds.
[50,7] also prove lower bounds on the summability and/or BB factor of cost-sharing methods, and [50] observed that such lower bounds, translate to poor approximation and/or poor BB for Moulin mechanisms.
Mehta et al. [41] proposed acyclic mechanisms, which also require suitable cost shares, as a means of circumventing these obstacles.
They show that for certain problems, primaldual algorithms for the underlying cost-minimization problem can be easily adapted to yield acyclic mechanisms with good guarantees.None of these results yield generic ways of translating algorithmic results for the SCM problem into analogous cost-sharing mechanisms.
The design of crossmonotonic cost-shares satisfying various properties is tailored to the problem at hand and often quite intricate.
[41] obtain some success, but they too are not able to automatically translate primal-dual algorithms into suitable cost shares and have to proceed in a problem-dependent way.
The work of Bleischwitz et al. [5] is perhaps closest in spirit to our work.
They show that for subadditive cost functions, one can obtain (not necessarily polytime) truthful (also, weakly GSP), O(log n)-approximation, 1-BB mechanisms.
Let Alg be a ρ-approximation algorithm Alg for the CM problem.
[5] also show that if the cost function induced by Alg, denoted C Alg , has a certain ordering property, then one can obtain a polytime truthful, polytime, O(ρ log n)-approximation mechanism.
However, this property is not known to be satisfied for various problems of interest; e.g., Steiner tree, facility location etc.
Brenner and Schafer [8] show that if the cost function satisfies a different ordering property, then Alg can be used to obtain an acyclic mechanism with ρ-BB; if C Alg and C satisfy some other conditions they also obtain approximation guarantees.
In comparison with our requirement that Alg be an LP-based algorithm, these conditions on Alg and C seem much more restrictive; indeed, the applications in [5,8] are limited to scheduling problems.In the area of social-welfare-maximization (SWM) packing problems, more success has been obtained in devising black-box reductions.
Lavi and Swamy [37] and Dughmi and Roughgarden [18] show how to translate certain algorithms into truthful-in-expectation mechanisms with the same approximation guarantee; [37] require an integrality-gap verifying approximation algorithm, whereas [18] require an FPTAS.
We note that our requirement of "LP-based ρ-approximation" is much weaker than the integrality-gap requirement in [37].
Most recently, Huang et al. [30] showed that for a symmetric single-dimensional SWM problem, any approximation algorithm can be converted to a truthful mechanism with the same approximation.
If one relaxes the truthfulness condition to Bayesian incentive compatibility, then black-box reductions were recently obtained by Hartline and Lucier [29] in the single-dimensional setting, and [2,28] in the multidimensional setting.
None of these reductions translate to the cost-sharing domain.
In a cost-sharing mechanism-design problem, we have n players with private types who compete for some service or good, and each outcome specifies a set S ⊆ [n] of players who will receive the service.
Let [n] denote the set {1, . . . , n}, and A ⊆ 2 [n] denote the set of all possible outcomes.
Also, there is a publicly-known costfunction C : A → R ≥0 that specifies the cost incurred for serving a given set of players; we use C(i) to denote C({i}).
As is standard, we assume that A is downwardsclosed and C is monotone, that is, if T ∈ A and S ⊆ T , then S ∈ A and C(S) ≤ C(T ).
In keeping with the vast literature on cost-sharing mechanisms, we focus for the most part on single-dimensional costsharing problems, wherein each player i's private type consists of a single nonnegative parameter v i specifying her value for receiving the service.
We use v to denote the tuple (v 1 , . . . , v n ) and v −i to denote the tuple(v 1 , . . . , v i−1 , v i+1 , . . . , v n ).
A (direct revelation) mechanism for a cost-sharing problem consists of an allocation rule (that is, an algorithm) f : R n + → A, and a pricing scheme p i : R n + → R for each player i. Each player i reports a type v i (possibly deviating from his true type), and the mechanism computes the outcome f (v) and charges price p i (v) to player i.
We sometimes refer to the players in f (v) (i.e., who receive service) as "winners".
Throughout we use v i to denote the true type of player i.
The utility u i (v i ; v i , v −i ) player i derives when she declares v i and the others declarev −i is v i − p i (v i , v −i ) if i ∈ f (v i , v −i ) and −p i (v i , v −i )otherwise, and each player aims to maximize her own utility.We are interested in designing mechanisms where the outcome computed approximates the optimum social cost with respect to the players' true types, which is defined as min S∈A SC(v; S) := C(S) + i / ∈S v i , and the prices recover the cost incurred by the mechanism.
More precisely, we formalize this by requiring a costsharing mechanism M = f, {p i } to satisfy the following desirable properties:• M is strategyproof (a.k.a truthful), which means that each player maximizes her utility by revealing her true value: for any i, v −i , and any v i , v i , we haveu i (v i ; v i , v −i ) ≥ u i (v i ; v i , v −i ).
We use the terms strategyproofness and truthfulness interchangeably from now on.
M is individually rational (IR) and has no positive transfers (NPT), i.e., u i (v i ; v i , v −i ) ≥ 0 and p i (v i , v −i ) ≥ 0 for every i, v i , v −i .
(In the sequel, whenever we say truthful, we mean truthful, IR, and NPT.)
• (Approximation) f is an α-approximation algorithm for the social-cost minimization (SCM) problem: forevery input v = (v 1 , . . . , v n ), we have SC(f (v)) ≤ α min S∈A SC(v; S).
We drop the input v in SC(.
; .)
when this is clear from the context.
• (Cost recovery) The prices recover at least a β-fraction of the mechanism-designer's cost: for every input v, we havei p i (v) ≥ C f (v) /β.We call such a mechanism a truthful, α-approximation, β-cost-recovering mechanism.
(We abbreviate 1-cost-recovering to cost-recovering.)
Often, computing C(S) for a set S turns out to be NPhard, and a polytime mechanism must therefore also specify a candidate (low-cost) solution for the set of players it serves.
In such settings, the approximation and cost-recovery requirements are modified toC M (f (v)) + i / ∈f (v) v i ≤ α min S∈A SC(v; S), andi p i (v) ≥ C M (f (v))/β, where C M (f (v)) is the cost of the solution computed by M for the set f (v).
We say that an allocation rule f is implementable if there exist prices {p i } such that f, {p i } is a truthful mechanism.
For single-dimensional problems, we have the following well-known and useful characterization of implementable allocation rules.
Call an allocation rule f (for a single-dimensional problem) monotoneif i ∈ f (v i , v −i ) and v i > v i implies that i ∈ f (v i , v −i ) (i.e., a winning player remains a winner by increasing her bid).
Theorem 2.1.
( [45,1]) Given an allocation rule f , there exist prices {p i } implementing f iff f is monotone.
Suppose that f is monotone and for every i and v −i , there is a well-defined threshold t i (v −i ) such that for any input (v, v −i ), player i wins when v > t i (v −i ) and loses when v < t i (v −i ).
Then, setting p i (v) = t i (v −i ) if player i wins and 0 otherwise for every i, gives the unique prices that implement f and ensure IR, NPT.We say that a cost function is subadditive if C(S) + C(T ) ≥ C(S∪T ) for every S, T ∈ A such that S∪T ∈ A.
The vast majority of cost-sharing problems that have been studied in the literature involve subadditive functions (e.g., Steiner forest, vertex cover, facility location).
For subadditive cost functions, an additional desirable property that we would like to achieve is that the price charged by the mechanism to a (winning) player does not exceed the cost of serving her individually.
We call this property individual competitiveness (ICT).
• (Individual competitiveness) p i (v) ≤ C(i) for every player i.(If C is not subadditive, then ICT conflicts with costrecovery, so we impose ICT only when C is subadditive.)
We view individual competitiveness as a basic sanity check: in its absence, a player i who is charged a price larger than C(i) has an incentive to secede from the mechanism and find alternate means of obtaining the service (by herself, or from a competitor) at a cost lower than the price she currently pays.
This is the same rationale as the one used to motivate the core of a cooperative cost-sharing game.
But since our focus is on strategyproofness we explicitly do not consider collusions among players; focusing on individual players yields ICT instead as the natural requirement.
A related point is that our β-cost-recovery condition is subtly different from the β-budget balance condition that is used in the literature, wherein we require thatC(f (v)) β ≤ i p i (v) ≤ C(f (v)) (or equivalently, via scaling, i p i (v) ∈ C(f (v)), βC(f (v))).
As in the case of the core, the usual rationale for imposing the upper bound is that in its absence the coalition of winning players has an incentive to secede from the mechanism.
As before, since we explicitly focus on individual players and not coalitions, we drop this upper-bound requirement, and insist on (approximate) cost-recovery and ICT.Our first reduction (Section 3) requires as input a truthful, approximation mechanism that satisfies an additional technical condition called no-bossiness, which is defined as follows: an allocation rule f satisfies nobossiness if for every i,v −i and v, v , if i ∈ f (v, v −i ) and i ∈ f (v , v −i ), then f (v, v −i ) = f (v , v −i ).
That is, if a winning player remains a winner by changing her bid, then the outcome computed is unaffected.Lower bounds.
Dobzinski et al. showed that for the public-excludable good problem (C PEG (S) = 1 if S = ∅ and is 0 otherwise) any truthful mechanism for the SCM problem achieving β-budget balance must be Ω(log n/β)-approximate.
It is easy to that their proof also holds for β-cost-recovering truthful mechanisms.
Since C PEG can be encoded as the cost function of many problems (e.g., Steiner tree, vertex cover, facility location), this implies an analogous lower bound for these cost-sharing problems.Moulin-style mechanisms.A Moulin-style mechanism works as follows.
The mechanism takes as input a cost-sharing method ξ :2 [n] × [n] → R + .
Given a current set S (initialized to [n]) of candidate players for receiving service, the mechanism tentatively asks each player i ∈ S if v i ≥ ξ(S, i).
If this is true for all players, then the mechanism outputs S and charges each player i ∈ S the price ξ(S, i) (and 0 to the other players).
Otherwise, the mechanism drops one, some, or all of the players who have v i < ξ(S, i), and iterates with the remaining set of players (we call the latter the "all-drop" rule.)
Different variants arise based on the exact rule for dropping players.
Moulin [43] showed that if the cost-sharing method is cross-monotonic, -that is, ξ(S, i) ≤ ξ(T, i) for every S ⊆ T, i ∈ S-then all variants yield the same mechanism and this mechanism is strategyproof (in fact, group-strategyproof (GSP)).
Moreover, if i∈S ξ(S, i) ≥ C(S) for all S, then the mechanism satisfies cost-recovery.
Say that a cost-sharing method ξ is competitive if ξ(S, S) ≤ C(S) for all S; say that ξ is cost-recovering if ξ(S, S) ≥ C(S) for all S. Define the budgetbalance (BB) factor of a cost-sharing method ξ to be max max S C(S)/ξ(S, S), max S ξ(S, S)/C(S) .
Immorlica et al. [31] proved lower bounds on the BB-factor achievable by competitive, cross-monotonic ξ for various problems.
Clearly, this also implies lower-bounds for cost-recovering, cross-monotonic ξ.
[50] observed that the approximation of the Moulin mechanism M ξ constructed from a competitive, cross-monotonic ξ is Ω(BB-factor of ξ).
We observe that the same holds for cost-recovering ξ.
Coupled with the lower bounds in [31] for various cost functions, this implies lower bounds on the approximation of every cost-recovering Moulin mechanism for these cost-functions.
Lemma 2.1.
Let ξ be cost-recovering and crossmonotonic with BB-factor β.
Then, M ξ has approximation ratio Ω(β).
Proof.
Let S be an inclusion-wise minimal set such that ξ(S, S) = βC(S).
So ξ(S, i) > 0 for all i ∈ S. Consider the following input.
Set v i = ξ(S, i) − > 0 for all i ∈ S, where > 0 is negligible, and v i = 0 for all i / ∈ S. M ξ will return the empty set and incur social cost ξ(S, S) − |S|, whereas choosing S as the outcome yields social cost C(S).
Thus the approximation ratio tends to β as goes to 0.
In this section we prove the following theorem, which reduces the cost-sharing (i.e., truthful, approximation, cost-recovering) mechanism-design problem to the task of truthful and no-bossy approximation mechanism design.Theorem 3.1.
Given a truthful, α-approximation mechanism M = g, {q i } satisfying no-bossiness, we can obtain a mechanism M such that: (a) M is a truthful, O(α log n)-approximation, cost-recovering mechanism, and is polytime computable if M is; (b) if M is ICT and C is subadditive, then M is ICT.The proof follows from two constructions.
The first construction is quite simple to describe and illustrates many of the ideas involved.
The idea here is to simply initialize the Moulin mechanism with the output of the mechanism M and then use the uniform cost shares ξ(S, i) = C(S)/|S|.
Since the Moulin mechanism preserves truthfulness, the resulting mechanism inherits truthfulness from M , while the uniform cost shares ensure cost-recovery while degrading the approximation by a log n-factor.
The resulting mechanism satisfies all the properties mentioned in Theorem 3.1 except ICT.
(As mentioned earlier, for non-subadditive cost functions, we cannot hope to achieve both cost-recovery and ICT.)
Next, for subadditive cost functions, we show how one can also obtain ICT by suitably refining the first construction.
We describe this construction after detailing the first construction.
For a set S ⊆ [n], we define R(S) = {i ∈ S : v i < C(S)/|S|}.
Mechanism M1 = f1, {p1,i}Given: a truthful, α-approximation mechanism M = g, {qi} satisfying nobossiness.
On input v, we do the following.C1.
Initialize j ← 0 and S0 ← g(v).
C2.
While R(Sj) = ∅, set Sj+1 ← Sj \ R(Sj) and j ← j + 1.
C3.
Return Sj as the winner set.
The prices, as specified via Theorem 2.1, equate to (see Lemma 3.1)p1,i(v) = max qi(v), C(S 0 ) |S 0 | , . . . , C(S j ) |S j | if i ∈ Sj, 0 otherwise.Lemma 3.1.
Mechanism M 1 satisfies property (a) of Theorem 3.1.
Proof.
We assume here for simplicity that C(.)
is polytime computable, in which case it is clear that M 1 is polytime computable if M is; Remark 3.1 shows that with a slight modification to the above construction, this continues to hold even otherwise.
Consider any input v, and let g(v) = S 0 and f 1 (v) = W ⊆ S 0 .
Let OPT = min S∈A SC(v; S).
(Note that M 1 always returns a feasible solution, since it returns a subset of g(v), and A is downwards closed.)
Fix a player i who is a winner in M 1 under the input v, and let v i > v i .
Since i is a winner, we have i ∈ S 0 .
Observe that g(v i , v −i ) = S 0 since g is monotone (so i remains a winner in M ) and satisfies no-bossiness.
So since v i > v i , mechanism M 1 proceeds identically on the inputs v and (v i , v −i ), and hence i remains a winner under the input (v i , v −i ).
We have C(S 0 ) + i / ∈S0 v i ≤ αOPT .
Let k = |S 0 | and let S 0 \ W = {i 0 , . . . , i m },where the players are arranged in the order they were dropped (breaking ties in the players dropped in the same iteration arbitrarily).
Then, we must have C(i ) ≤ C(S 0 )/(k−) since if player i was dropped from the set S r , then we have C(i ) ≤ C(S r )/|S r | and |S r | ≥ |S 0 |− (since i is the -th player to be dropped).
So C(i ) ≤ C(S 0 )/(k − ), and hence, it follows thatSC(W ) = C(W )+ i / ∈S0 v i + i∈S0\W v i ≤ c(S 0 ) + i / ∈S0 v i + C(S 0 ) · H k ≤ α(1 + H n )OPT .
To argue that M 1 satisfies cost-recovery, we prove that the threshold of each winner i is given byτ i := max q i (v), C(S0) |S0| , . . . , C(Sj ) |Sj |.
This implies that the prices specified in the construction are indeed those determined by Theorem 2.1, which immediately yields cost-recovery since theni∈W p 1,i (v) ≥ i∈W C(W )/|W | = C(W ).
Consider some input v = (v i , v −i ).
Suppose that i wins in M 1 under v .
Since M is truthful and no-bossy, and i ∈ g(v ), this implies that v i ≥ q i (v ) = q i (v) = (i's threshold value in M for v −i ), and g(v ) = g(v).
Notice then that M 1 proceeds identically on both v and v .
So we must havev i ≥ max C(S0) |S0| , . . . , C(Sj ) |Sj | }.
Also note that player i wins in M 1 for any v i > τ i .
This implies that i's threshold in M 1 is τ i .
Remark 3.1.
When C(.)
is NP-hard to compute, we cannot necessarily compute R(S).
Also, as discussed earlier, M 1 must now also specify a solution for the set of winners.
Both issues can be handled as follows.
We make the very mild assumption that a solution for S 0 also induces a solution of no greater cost for any subset of S 0 .
We now redefine R(S) as R S0 (S) = {i ∈ S : v i < C M (S 0 )/|S|}, and the solution we return for the winner set W = S j is the one induced by S 0 .
Mimicking the proof of Lemma 3.1, it is easy to see thatC M1 (W ) + i / ∈W v i ≤ (1 + H n )C M (S 0 ) + i / ∈S0 v i ≤ α(1 + H n )OPT , and i∈W p 1,i (v) ≥ C M (S 0 ) ≥ C M1 (W ).
Also, notice that if we use C M (S 0 )/β|S| in the definition of R S0 (S), where β ≥ 1, then the proof of Lemma 3.1 shows that we get O(α log n/β) approximation and β-cost recovery.One noteworthy application of the above construction is the following very general result, which can be viewed as an analogue of VCG for cost-sharing problems.
Taking M to be the VCG mechanism, which solves the SCM problem exactly and can be assumed to be no-bossy by fixing a rule for breaking ties between multiple optimal solutions, we obtain that for any monotone cost function, there is a truthful, O(log n)-approximation, cost-recovering mechanism.
No such general result was previously known.Individual competitiveness with subadditive cost functions.
We now describe how to refine the construction of M 1 so as to obtain individual competitiveness when C(.)
is subadditive.
A natural first attempt would be to set the threshold for a player i to remain in the current candidate set S to be min{C(i), C(S)/|S|} (instead of the uniform threshold C(S)/|S|).
This however fails to ensure cost-recovery: the problem arises because one may accept a winnerset W where only a small subset T ⊆ W of winners pay the price C(W )/|W |, which could be much smaller than C(T )/|T |.
To rectify this, we need a more sophisticated scheme.
Given the current candidate set S, we keep track of the set T (S) of players in S for which C(i) < C(S)/|S|.
The players in T (S) are asked to pay their individual price C(i) and are (permanently) accepted or rejected based on whether they can do so.
If T (S) = ∅, we update S to S \T (S) and iterate with this set.
Otherwise, the players in S are asked to pay the price C(S)/|S|.
The players who cannot do so are rejected and we iterate with the remaining set of players.
The resulting mechanism is described in detail below.
Recall that R(S) = {i ∈ S : v i < C(S)/|S|}.
We also define the sets T (S) = {i ∈ S : C(i) < C(S)/|S|} and R (S) = {i ∈ S : v i < C(i)}.
Mechanism M2 = f2, {p2,i} Given: a truthful, α-approximation mechanism M = g, {qi} satisfying nobossiness.
On input v, we do the following.D1.
Initialize j ← 0 and S0 ← g(v).
Also, set A ← ∅, R ← ∅.
D2.
While T (Sj) ∪ R(Sj) = ∅, proceed as follows.
D2.1.
If T (Sj) = ∅, then set R ← R ∪ R (T (Sj)) and A ← A ∪ T (Sj) \ R (T (Sj)).
Set Sj+1 ← Sj \ T (Sj).
D2.2.
Otherwise (i.e., T (Sj) = ∅, R(Sj) = ∅), set R ← R ∪ R(Sj) and Sj+1 = Sj \ R(Sj).
D2.3.
Update j ← j + 1.
D3.
Return A ∪ Sj as the winner set, and let {p2,i(v)} be the corresponding prices as specified by Theorem 2.1.
We show that if qi(v) is given then p2,i(v) can be computed in polytime (see Lemma 3.2).
As before, if C(.)
is NP-hard to compute (but say C(i) is polytime computable, as is often the case), then we can redefine R(S) and T (S) as R S0 (S) = {i ∈ S : v i < C M (S 0 )/|S|} and T S0 (S) = {i ∈ S : C(i) < C M (S 0 )/|S|}, and return the solution induced by S 0 for A ∪ S j .
With this modification, M 2 is polytime computable if M is.
Also, as before, we can trade off approximation with cost-recovery.
Lemma 3.2.
Given the prices {q i }, the prices {p 2,i } implementing f 2 can be computed in polytime.
Theorem 3.1 is satisfied by taking M = M 2 .
Proof.
Consider any input v, and let g(v) = S 0 and f 2 (v) = W ⊆ S 0 and OPT = min S∈A SC(v; S).
The proof of monotonicity of f 2 and approximation follow by mimicking the proof of Lemma 3.1.
Since M is truthful and no-bossy, if a winner i in M 2 raises her bid, then M will return the same set S 0 and hence, M 2 proceeds identically on v and the new input, and so i remains a winner.
Let i be the ( + 1)-th player dropped from S 0 .
Suppose i ∈ S r \ S r+1 , so |S r | ≥ k − .
If i ∈ R (T (S r )), then v i < C(i) < C(S r )/|S r |; otherwise, i ∈ R(S r ) and we again have v i < C(S r )/|S r |.
So in both cases,v i < C(S r )/|S r | ≤ C(S 0 )/(k − ); hence i∈S0\W v i ≤ C(S 0 ) · H k which in turn implies that SC(W ) ≤ α(1 + H n )OPT .
We now show that M 2 is ICT if M is.
Fix any winner i ∈ W .
It suffices to argue that if v i ≥ C(i) then i will be chosen as a winner in M 2 .
Since v i ≥ C(i) ≥ q i (v i , v −i ), i is in S 0 .
Suppose i ∈ S r .
If i ∈ T (S r ), then clearly i is added to A; otherwise, we have i ∈ S r+1 , since i / ∈ R(S r ) as v i ≥ C(i) ≥ C(S r )/|S r |.
It follows that if i / ∈ A, then i is in the final set S j .
So i is a winner.Next, we show that the prices implementing f 2 can be computed efficiently.
Consider a player i ∈ W and some input v = (v i , v −i ).
Suppose that i wins in M 2 under v .
As before, since M is truthful and no-bossy, we have v i ≥ q i (v ) = q i (v) = (i's threshold value in M for v −i ) and g(v ) = g(v), so M 2 proceeds identically on v and v .
Now, i is chosen as a winner either because (1) it is added to A at some point when our candidate set was, say, S r ; or because (2) i is part of the final set S j .
Importantly, since (fixing v −i ) M 2 proceeds identically on every winning bid of i, which of these two cases happen does not depend on i's (winning) bid.
If the former case happens (for every winning bid), then we must have v i ≥ C(i); also, i wins in M 2 whenever v i > max{q i (v), C(i)}.
So here, we have p 2,i (v) = max{q i (v), C(i)}.
In the latter case, let S ⊆ {S 0 , S 1 , . . . , S j } be the collection of sets for which T (S) = ∅.
Then, we must have v i ≥ max S∈S C(S)/|S|, and moreover, i wins in M 2 whenever v i > max q i (v), max S∈S C(S)/|S| .
So if this case happens, we have p 2,i (v) = max q i (v), max S∈S C(S)/|S| .
In particular, we note that since S j ∈ S, we havep 2,i (v) ≥ C(S j )/|S j |.
Finally, cost-recovery follows because i∈W p 2,i (W ) ≥ i∈A C(i) + i∈Sj C(S j )/|S j | ≥ C(A) + C(S j ) ≥ C(A ∪ S j )where the last two inequalities follow from subadditivity.
Complementing the construction described in Section 3, we now describe how to obtain a truthful, (ρ + 1)-approximation mechanism satisfying no-bossiness in a black-box fashion from an LP-based ρ-approximation algorithm for the cost-minimization problem of finding a min-cost way of serving a given set of players.Combined with the reduction in Section 3, this yields a truthful, O (ρ+1) log n -approximation cost-recovering mechanism.
These reductions find numerous applications, which we discuss in Section 5.
A generic LP-model.
We describe two LPmodels for the cost-minimization (CM) problem and the associated SCM problem.
The first model captures general covering problems without multiplicity constraints; the second allows for multiplicity constraints but captures a restricted class of general covering problems that nevertheless includes {0, 1}-covering problems.
We focus on the first model below, and discuss the second model later.
Consider a cost-sharing problem where the problem of finding a min-cost solution for a set S of players admits an LP-relaxation of the following form.
i) , b (i) ≥ 0 for every i, and OPT C1-P(S) ≤ C(S) for every set S (where C1-P(S) denotes (C1-P) for the set S).
These conditions are satisfied by the LP-relaxations of many combinatorialoptimization covering problems, such as {0, 1}-covering problems (which includes various cost-sharing problems studied in [33,46,34,50,41]).
We give two examples (see also Section 5).
(1) Survivable-network design problem (SNDP), where each player i is an (s i , t i ) pair requiring r i edge-disjoint paths, and multiple (unrestricted number of) copies of an edge may be included.
This non-{0,1}-covering problem can be cast as (C1-P).
We have an x e variable for every edge e; the player-specific constraints are: x δ(Q) ≥ r i for every s i -t i cut Q, and there are no global constraints.
(2) Makespan-minimization problem on unrelated machines, where jobs are players: we have a variable x i for every machine and job i, and a variable T .
We want to minimize T subject to the player-specific constraints x i ≥ 1 (for every job i ∈ S), and the global con-min c T x (C1-P) s.t.
A (i) x ≥ b (i) for all i ∈ S Bx ≥ d x ∈ R m + .
Here A (i) x ≥ b (i)denotes some constraints specific to player i that arise because i has to be served, and Bx ≥ d models various global constraints.
We require that d ≥ 0 and A (straints T − i p i x i ≥ 0, T − p i x i ≥ 0 ∀i, .
Given the LP-relaxation (C1-P) for the CM problem, the corresponding SCM problem can be encoded as follows.
For each player i, we introduce a variable z i that indicates that i does not receive service.
The player-i-specific constraints then get modified toA (i) x + b (i) z i ≥ b (i).
So we obtain the following LPrelaxation for the SCM problem.min c T x + v T z (SC1-P) s.t.
A (i) x + b (i) z i ≥ b (i) for all i (4.1) Bx ≥ d (4.2) x ∈ R m + , z ∈ R n + .
Observe that a feasible solution x to C1-P(S) extends to a feasible solution to (SC1-P) by setting z i = 1 for i / ∈ S.Constructing the mechanism.
Suppose we have an algorithm Alg that for every set S, returns a solution of cost at most ρ · OPT C1-P(S) .
We use Alg to devise a polytime mechanism M = (g, {q i }) as follows.
On input v, we compute an optimal solution (x * , z * ) to (SC1-P) using some fixed total ordering over vectors (e.g., lexicographic ordering) to break ties if there are multiple optimal solutions.
We refer to (x * , z * ) as the optimal solution for input v.
We return g(v) = W = {i : z * i = 0} as the winner set, and use Alg to compute a solution for W .
Let {q i } be the prices implementing g (which we prove are polytime computable).
Theorem 4.1.
M is a polytime truthful, no-bossy, (ρ+ 1)-approximation, ICT mechanism for any SCM problem for which the cost-minimization problem is captured by (C1-P).
Proof.
Lemma 4.1 proves the approximation guarantees, and Lemma 4.2 shows that M is ICT and the prices implementing g are polytime computable.
We argue that g is monotone and satisfies no-bossiness.
Consider some input v, and let W = g(v).
Let (x * , z * ) be the optimal solution to (SC1-P) for input v. x * + v T z * ≤ c T x + v T z and c T x + v T z ≤ c T x * + v T z * and simplifying gives (v i − v i )(z * i − z i ) ≤ 0.
Hence, i remains a winner under input v .
Further, we claim that (x , z ) = (x * , z * ).
Observe that (v i − v i )(z * i − z i ) = 0 implies that c T x * + v T z * = c T x + v T z and c T x + v T z = c T x * + v T z * .
So both (x * , z * ) and (x , z ) are optimal solutions for both v and v .
So since we use a fixed tie-breaking rule, this means that (x * , z * ) = (x , z ).
Thus, M computes the same solution for both v and v , which means that M satisfies no-bossiness.
(i) T µ i + d T ω (SC1-D) s.t. i A (i) T µ i + B T ω ≤ c (4.3) b (i) T µ i ≤ v i for all i (4.4) µ i , ω ≥ 0.
Here µ i and ω are nonnegative dual variables corresponding respectively to the primal constraints (4.1) and (4.
Proof.
Fix an input v and a winning player i. Let OPT (t) denote the optimal value of (SC1-P) for (t, v −i ).
The threshold value at which i wins is the smallest value t such that there is some optimal solution x(t), z(t) to (SC1-P) for (t, v −i ) with z i (t) = 0.
This is because for any t > t, every optimal solution to (SC1-P) must have z i = 0 (by the monotonicity proof in Theorem 4.1).
So i wins under every bid t > t and loses under every bid t < t. Let OPT denote the optimal value of (SC1-P) when we force z i = 0.
Notice that OPT (t) ≤ OPT , and when z i (t) = 0, we have OP T (t) = OPT .
So the threshold value is given by min t s.t. OPT (t) ≥ OPT .
Notice that OPT (t) ≥ OPT is equivalent to the condition that there exists a feasible solution {µ i }, ω to (SC1-D) (for (t, v −i )), and a feasible solution (x, z) to (SC1-P) with z i = 0, such the value of {µ i }, ω is at least the value of (x, z).
Thus, the threshold value can be computed efficiently by solving an LP.Suppose that {µ * i }, ω * , x * , z * is an optimal value to this "threshold-LP".
Then, observe that (µ * i , ω * ) is a feasible solution to the dual of C1-P({i}).
Sot = b (i) T µ * i ≤ b (i) T µ * i + d T ω * ≤ OPT C1-P({i}) ≤ C(i).
Hence, M satisfies ICT.Cost-minimization problems with multiplicity constraints.
We now consider the following LPrelaxation for the CM problem, which closely resembles (C1-P), but allows for multiplicity constraints.min c T x (C2-P) s.t.
A (i) x ≥ b (i) for all i ∈ S Bx ≥ d 0 ≤ x ≤ u ∈ Z m + .
min c T x + v T z (SC2-P) s.t.
A (i) x + b (i) z i ≥ b (i) for all i (4.5) Bx ≥ d (4.6) 0 ≤ x ≤ u, z ∈ R n + .
As before, we require that d ≥ 0 and A (i) , b (i) ≥ 0 for every i, and OPT C2-P(S) ≤ C(S) for every set S. Further, we also require that B ≥ 0, and for every i, if A (i)re > 0 and u e > 0 then A (i) re u e ≥ b (i)r .
(SC2-P) is the corresponding LP-relaxation of SCM problem.Mechanism M is constructed in exactly the same way as before; the only obvious change is that we now solve (SC2-P) (instead of (SC1-P)) to get (x * , z * ).
Theorem 4.2.
M is a polytime truthful, no-bossy, (ρ+ 1)-approximation, ICT mechanism for any SCM problem for which the cost-minimization problem is captured by (C2-P).
Proof.
The argument for the monotonicity and nobossiness of the allocation rule is exactly as in the proof of Theorem 4.1.
The proof that prices are polytime computable mimics the proof of Lemma 4.2.
We now prove the approximation ratio and that M is ICT.
Fix an input v. Let W = g(v) and (x * , z * ) be the optimal solution to (SC2-P) for input v.
As in the proof of Lemma 4.1, it suffices to show that i:z * i >0 v i ≤ OPT = OPT SC2-P .
Again the key is to consider the dual of (SC2-P).
max i b (i) T µ i + d T ω − u T θ (SC2-D) s.t. i A (i) T µ i + B T ω − θ ≤ c (4.7) b (i) T µ i ≤ v i for all i (4.8) µ i , ω ≥ 0, θ ∈ R m + .
Here θ is the new dual variable corresponding to the x ≤ u multiplicity constraints.
Let{µ * i }, ω * , θ * be an opti- mal dual solution.
Then i:z * i >0 v i = i:z * i >0 b (i) T µ * i .
Note that θ * e > 0 implies that x * e = u e , so e:θ * e >0 u e c e = e:θ * e >0 u e i,r A (i) re µ * ir + r B re ω * r − θ * e.
So we havei:z * i >0 b (i) T µ * i + e:θ * e >0 u e c e = i,r µ * ir κ ir + r,e:θ * e >0 x * e B re ω * r − u T θ * where κ ir = b (i) r + e:θ * e >0 u e A (i) re if z * i > 0 and κ ir = e:θ * e >0 u e A (i) re otherwise.
We claim that µ * ir κ ir ≤ µ * ir b (i)r .
This is true if z * i = 0 since then µ * ir κ ir = µ * ir e:θ * e >0 u e A (i) re ≤ µ * ir e x * e A (i) re = µ * ir b (i) r .
If u e ≥ 1, z * i > 0,re x * e + b (i) r z * i > b (i) r since A (i) re u e ≥ b (i)r , which contradicts complementary slackness.
Therefore, we haveµ * ir κ ir ≤ µ * ir b (i) r .
Also, r,e:θ * e >0 x * e B re ω * r ≤ r,e x * e B re ω * r = d T ω * .
So i:z * i >0 v i ≤ i,r µ * ir κ i,r + r,e:θ * e >0 x * e B re ω * r −u T θ * ≤ i b (i) T µ * i +d T ω * −u T θ * = OPT .
Let t * be the price of a winning player i. For any t < t * , we know that every optimal solution x(t), z(t) to (SC2-P) for (t,v −i ) must have z i (t) > 0.
Let {µ * i }, ω * , θ * be an optimal solution to (SC2-D),Then t = b (i) T µ * i and the argument above shows thatt + j =i b (j) T µ * j ≤ j b (j) T µ * j + d T ω * − u T θ * , that is, t ≤ b (i) T µ * i + d T ω * − u T θ * .
Finally, observe (µ * i , ω * , θ * )is a feasible solution to the dual of C2-P({i}), so t ≤ OPT C2-P({i}) ≤ C(i).
This holds for all t < t * , so t * ≤ C(i).
This proves that M is ICT.Remark 4.1.
We remark that although our construction is described in terms of an LP model for the CM problem, our ideas have wider applicability.
In particular, we can also allow for a semidefiniteprogramming-(SDP) or convex-relaxations of the CM and SCM problems that involve covering constraints.
The proof of monotonicity and no-bossiness is unchanged.
Examining Lemma 4.1, the only property we need is that the optimal Lagrangian multipliers (i.e., dual values) for the constraints involving the z i variables can "pay" (approximately) fori:z * i >0 v i .
Lemma 4.2 easily extends: if OPT (t) denotes the optimal value of the convex-program for the SCM problem for (t, v −i ), then the price of a winner i under v −i is the minimum t such that OPT (t) ≥ optimum value of the SCM problem when we fix z i = 0, which can be efficiently computed since OPT (t) is a concave function of t.
We showcase the versatility of our reductions by considering cost-sharing problems from various domains for which our constructions yield the first or improved results.
In each case, we only need to verify that the cost-minimization problem admits an LP-relaxation of the form (C1-P) (or (C2-P)) and we have a suitable approximation algorithm for it.
The cost function in all of these applications is subadditive, so all our resulting mechanisms are polytime and ICT.Survivable network design problems (SNDPs).
SNDPs are cost-minimization problems where each player is an (s i , t i ) pair who requires r i edge-, or element-, or vertex-disjoint paths between s i and t i (giving rise to EC-, ELC-, VC-SNDP respectively).
We consider the setting where an unrestricted number of copies of an edge may be bought, in which case SNDP can be cast as (C1-P).
Section 4 shows this for EC-SNDP.
This also holds for the standard LP-relaxations for ELC-SNDP and VC-SNDP (see, e.g., [20] and [10]) as shown below.
Let V be the node-set and T = i {s i , t i }.
For ELC-SNDP, the player-i constraintsA (i) x ≥ b (i) consist of x(P, Q) ≥ r i − |V \ (P ∪ Q)| ∀P, Q ⊆ V, P ∩ Q = ∅, s i ∈ P, t i ∈ Q, P ∪ Q ⊇ T.For VC-SNDP, player i's constraints comprisex(P, Q) ≥ r i − |V \ (P ∪ Q)| ∀P, Q ⊆ V, P ∩ Q = ∅, s i ∈ P, t i ∈ Q.These problems admit LP-based approximation algorithms with the following guarantees: 2 for EC-SNDP [32] and ELC-SNDP [20], and O(r 3 max log n) for VC-SNDP [13].
(Although not explicitly stated, the algorithm of [13] also obtains an LP-relative approximation.
Also, improved LP-based guarantees are known for the single-source and all-pairs versions of VC-SNDP, which translate to our mechanisms.)
Theorem 5.1.
There are truthful, cost-recovering mechanisms for EC-SNDP, ELC-SNDP, and VC-SNDP with approximation ratios of O(log n), O(log n) and O(r 3 max log 2 n) respectively.These are the first results for SNDP cost-sharing problems.
Previously, cost-sharing mechanisms were only known for the special cases of Steiner tree and Steiner forest; even for these, our result improves upon the O(log 2 n)-approximation achieved by Moulin mechanisms [50,12] and acyclic mechanisms [41].
Facility location (FL).
Various FL problems (where the clients are players) are captured by (C1-P).
In all such problems, we have variables {y } for the facilities and variables {x i } for (facility, client) pairs, and A (i) x ≥ b (i) corresponds to the constraints x i ≥ 1.
In uncapacitated FL (UFL), the global constraints Bx ≥ d are: y − x i ≥ 0 for every i, ; in softcapacitated FL (soft-CFL), the global constraints also include u y − i x i ≥ 0 for every .
(Notice that although the LP for a client-set S has variables also for clients not in S, we include the x i ≥ 1 constraints only for players in S, so this does indeed model the min-cost problem for S.) (C1-P) also captures connected facility location (ConFL) problems [25,52,36].
In the general version, multicommodity ConFL (MConFL), each player i is an (s i , t i ) pair.
Serving a set S of players involves assigning the s i s and t i s to nodes called facilities, and building a network where for every (s i , t i ) pair, the facilities catering to s i and t i are interconnected.
The LPrelaxation of Kumar et al. [36] for MConFL is of the type (C1-P):x si ≥ 1, x ti ≥ 1 for every i ∈ S are the player-specific constraints, and the global constraints are the remaining constraints that also involve edge variables {w e }:w(δ(Q)) − ∈Q x si − x ti ≥ 0, w(δ(Q)) − ∈Q x ti − x si ≥ 0for every , i and node-set Q.Both UFL and soft-CFL have LP-based O(1)-approximations; see, e.g., [9] and [40] and the references there in.
[36] designed an O(1)-approximation for MConFL relative to the LP described above.
So we obtain the following results which, match the guarantees known for UFL [49,41], yield the first results for soft-CFL, and improve upon the O(log 2 n)-approximation for MConFL [49].
Theorem 5.2.
UFL, soft-CFL, and MConFL have truthful, O(log n)-approximation, cost-recovering mechanisms.Set-cover problems.
In the cost-sharing problem the players are the elements to be covered.
The natural LP-relaxation for set cover (and hence vertex cover) is easily seen to be a special case of (C1-P).
Set cover and vertex cover have LP-based O(log n)-and 2-approximation algorithms respectively.
A direct application of Theorems 4.1 and 3.1 yields an O(log 2 n)-approximation for set cover (and O(log n)-approximation for vertex cover).
But as observed in Remark 3.1, for any β ≥ 1, we can obtain O(log 2 n/β)-approximation and β-cost-recovery.
So we obtain the following, which matches the results in [41].
Theorem 5.3.
There are truthful, cost-recovering mechanisms for vertex cover and set cover with approximation ratios of O(log n) and O(log 2 n) respectively.
For set cover, we also obtain an O(log n)-approximation, O(log n)-cost-recovering mechanism.Scheduling.
We now consider scheduling problems where the jobs are players and the cost of a set S of jobs is the minimum makespan incurred for scheduling jobs in S on a given set of unrelated machines.
An LP-relaxation for this problem was given in Section 4 and shown to be of the form (C1-P).
Correa et al. [15] devise a 4-approximation relative to this LP.
Thus, we obtain the following theorem.Theorem 5.4.
There is a truthful, O(log n)-approximation, cost-recovering mechanism for makespan-minimization on unrelated machines.
In this section, we show that our ideas can be applied to obtain guarantees also for various multidimensional cost sharing problems.
We consider two types of multidimensional settings.In the first setting (Section 6.1), which we call the multi-element (ME) setting, each player i ∈ [n] now controls a publicly known disjoint set of elements E i and outcomes are now subsets of E := i E i (so A ⊆ 2 E ).
We consider additive valuations, so player i's private type is a vector v i ∈ R Ei + with v i,e > 0 denoting the value i gets if element e ∈ E i is served; the value of a player i under an outcome T ⊆ E is v i (T ) := e∈T ∩Ei v i,e .
Correspondingly, the social cost of outcome T is now given by SC(T ) := C(T ) + i v i (E i \ T ).
The second multidimensional setting (Section 6.2) is the multi-demand (MD) setting considered by [41].
Here each player i ∈ [n] has a publicly known maximum level of service R i ∈ Z + .
An outcome is now a vector = ( 1 , . . . , n ), with i ∈ [R i ] representing the level of service offered to player i. Player i's private type is a vector v i ∈ R Ri + with v i,k > 0 denoting the additional value to i of level k over level k − 1.
We assume that these marginal values are nonincreasing with k (i.e., a player's true type and her reported type should satisfy this requirement).
The value of player i under outcome is i k=1 v i,k and hence, the social cost of outcome is now given by SC() := C() + i Ri k=i+1 v i,k .
Two related, but distinct, difficulties arise when considering multidimensional cost-sharing problems.
First, we no longer have a simple condition like (value) monotonicity [45] for the implementability of an allocation rule.
The implementability condition is now much more demanding, requiring it to satisfy cyclemonotonicity [48] in general, or weak-monotonicity with convex domains [3,51].
Second, the specification of prices implementing an allocation rule is significantly more involved; prices are obtained by computing shortest paths in a certain allocation graph (see, e.g., [24,38]) whose size is polynomial in |A|.
We avoid these difficulties by essentially reducing the multi-dimensional problem to the singledimensional problem.
By suitably adapting the constructions and arguments in Sections 3 and 4, we then obtain guarantees for the multidimensional problem.6.1 The multi-element setting.
Notice that since a player's valuation is additive, algorithmically, the multi-element SCM problem is identical to the SCM problem where we consider each element e ∈ E to be a player whose value is v i,e if e ∈ E i .
So we can work with the same LP-models (C1-P), (C2-P) for the CM problem (where now S ⊆ E) and (SC1-P), (SC2-P) for the SCM problem.
We now say that a mechanism f, {p i } is individually competitive if p i (v) ≤ C(f (v) ∩ E i ) for all i.
A special case of the ME problem is the single-dimensional problem where player i has the same value v i ∈ R + for getting any of her elements served; sov i (T ) := v i |T ∩E i | and SC(T ) = C(T )+ i v i |E i \T |;we call this the multi-element single-dimensional (MESD) problem.
We obtain the following results.
An LP-based ρ-approximation algorithm for the CM problem refers to an algorithm that always returns a solution of cost at most ρ times the optimal value of the LP-relaxation ((C1-P) or (C2-P)) of the CM problem.Theorem 6.1.
Let k = max i |E i | and λ(v) = max i v i (E i )/ min e∈Ei v i,e .
Given an LP-based ρ-approximation algorithm for the CM problem, we can obtain a truthful, cost-recovering mechanism that has approximation ratio: (a) O ρk log n for the ME problem with subadditive C; (b) O (ρ + k) log n for the MESD problem, and is ICT if C is subadditive; and (c) O ρλ(v) log n on input v for the ME problem, and is ICT if C is subadditive.To the best of our knowledge, these are the first results for multi-element cost-sharing problems.
Notice that our guarantees are weaker than those obtained for the single-dimensional problem.
In light of this and the aforementioned difficulties involved in multidimensional cost-sharing mechanism-design, one can ask which of the tasks performed by our two reductions-(1) translating approximation algorithms to truthful, approximation mechanisms, and (2) translating truthful, approximation mechanisms to cost-sharing mechanismsbecomes harder in the multidimensional setting.
We give a partial answer to this question.
We show that (see Theorem 6.2) if one has an LP-based ρ-approximation algorithm for the SCM problem that satisfies an additional property then one can obtain a truthful-inexpectation, ρ-approximation mechanism for the SCM problem.
Unfortunately, we do not how to modify this mechanism so as to achieve cost-recovery, and in fact, in the multidimensional setting, we do not know of any black-box way of injecting cost-recovery into a (deterministic) truthful, approximation mechanism (that is possibly required to satisfy some additional properties).
We leave the question of whether one can obtain reductions for multidimensional problems that are analogous to those in Sections 3 and 4, as an open problem.Proof of Theorem 6.1.
Part (a) follows from the following simple reduction to the single-dimensional setting.
We partitionE (= i E i ) into k sets U 1 , . . . , U k such that |U j ∩ E i | ≤ 1for all i and j. (It is easy to construct such a partition by repeatedly picking a new element from the E i s to construct a new part U j .)
Each U j induces a (one-element) single-dimensional problem where player i has the element Ei ∩ U j ; if E i ∩ U j = ∅,then player i does not participate.
We use the constructions in Sections 3 and 4 to solve this problem.
Let T j ⊆ U j be the set served, and p j,i be the prices charged to player i in the j-th problem; we set p j,i (v) = 0 if i does not participate in the j-th problem.
We return the set k j=1 T j , and charge player i the price k j=1 p j,i .
Since valuations are additive, the utility of player i is the sum of her utilities in the k single-dimensional problems, and hence, the mechanism constructed is truthful.
Since i p j,i ≥ C(T j ) for each j and the cost function is subadditive, cost-recovery follows.
The approximation guarantee follows from noting that the optimal solution induces a solution to the j-th problem of cost at most OPT (since C is monotone).
Therefore, C(T j ) + i e∈(Ei∩Uj )\Tj v i,e = O(ρ log n)OPT , and since C is subadditiveSC j T j ≤ j C(T j ) + i e∈(Ei∩Uj )\Tj v i,e = O(ρk log n)OPT .
Parts (b) and (c).
We use a different reduction to the single-dimensional setting, where we consider "allor-nothing" outcomes; that is, for each player i, we either serve all of E i , or no elements of E i .
Given an LP-based ρ-approximation algorithm Alg for the CM problem, we describe how to obtain a truthful, no-bossy (defined precisely later) mechanism M with (ρ + k)-and (ρ + 1)λ(v)-approximations for the MESD and ME problems respectively.
The procedure for injecting cost-recovery into M is the same in both cases.
Let A := {S ⊆ [n] : i∈S E i ∈ A}.
(Recall that A ⊆ 2 E is the (downwards-closed) set of all outcomes.)
We simulate the construction from Section 3 for the cost function C : A → R + defined by C (S) := C( i∈S E i ).
Note that A is downwards closed and, if C is subadditive then so is C .
Thus, each player i is now a single-dimensional player (owning one element) whose value is v i (E i ).
So Theorem 3.1 combined with the above results shows that we obtain (polytime) truthful, cost-recovering mechanisms with approximation O((ρ + k) log n) and O ρλ(v) log n for the MESD and ME problems respectively.
Moreover, these mechanisms are ICT if C is subadditive.Constructing a mechanism from Alg.
The LPrelaxation of the SCM problem is (SC1-P) or (SC2-P) (depending on whether (C1-P) or (C2-P) captures the CM problem) where we consider each e ∈ E i to be a player with value v i,e .
So we have variables z i,e for every i, e ∈ E i .
Let (SC-P) denote this LP.
The single-dimensional MESD problem.On input v, we compute the optimal solutionx * , z * to (SC-P).
Let OPT denote its value.
Let z * i (E i ) denote e∈Ei z * i,e .
We return g(v) := i:z * i (Ei)=0 E ias the outcome, and use Alg to compute a solution for g(v).
In the sequel, we say that "i wins" if E i is served.
Let t i (v −i ) denote the smallest value of v i |E i | under which i wins.
We set q i (v) = t i (v i ) if i wins and 0 otherwise for all i.
We argue that M = g, {q i } is polytime, truthful, ICT, achieves a (ρ+k)-approximation, and has the following no-bossiness property: ifE i ⊆ g(v i , v −i ) and E i ⊆ g(v i , v −i ) then g(v i , v −i ) = g(v i , v −i ).
Suppose that i is a winner under input v. Let (x , z ) be an optimal solution for v = (v i , v −i ) where v i > v i .
Then, as in the proof of Theorem 4.1, it is easy to see that z (E i ) ≤ z * (E i ) = 0 and hence, that (x , z ) = (x * , z * ).
Hence, i is also a winner under v , and g(v) = g(v ).
The proof that M is ICT and that t i (v −i ) is polytime computable follows by mimicking the proof of Lemma 4.2 (or Theorem 4.2).
To prove the approximation, as before, it suffices to show that i:z * (Ei)>0 v i |E i | ≤ k · OPT .
This follows since i:z * (Ei)>0 v i |E i | ≤ k i,e:z * i,e >0 v iand the proofs of Lemma 4.1 and Theorem 4.2 show thati,e:z * i,e >0 v i ≤ OPT .
The ME problem.
Recall that to inject cost-recovery, we considered the cost function C defined by C (S) := C( i∈S E i ), where we treat each player i as a singleton player whose value is v i (E i ).
We construct a mechanism M for the multi-dimensional problem by simulating the construction in Section 4 for C .
Notice that the LPrelaxation for this modified SCM problem is an LP of the same form as (SC-P) but where we have a single variable z i for each player i, with z i = 0 indicating that E i is served and z i = 1 indicating that no element of E i is served.
Let (MSC-P) denote this modified SCM-LP.
(Equivalently, (MSC-P) is (SC-P) with the constraints z i,e = z i,e for all i, e, e ∈ E i .)
On input v, we compute the optimal solution (˜ x, ˜ z) to (MSC-P).
LetõptLet˜Letõpt denote its value.
We return g(v) := i:˜ zi=0 E i as the outcome, and use Alg to compute a solution for g(v).
Let t i (v −i ) denote the smallest value of v i (E i ) under which i wins.
We set q i (v) = t i (v −i ) if i wins and 0 otherwise for all i. Recall that λ(v) = max i v i (E i )/ min e∈Ei v i,e .
We abbreviate this to λ in the sequel.
We show that M = g, {q i } is polytime, truthful, ICT, no-bossy, and achieves a (ρ + 1)λ-approximation.
Since M simulates the construction in Section 4 for the singleton modified SCM problem, the proofs in Section 4 show that (i) g satisfies no-bossiness; (ii) q i (v) ≤ C(E i ); (iii) g has the monotonicity property thatv i > v i implies that g(v i , v −i ) ⊇ g(v i , v −i ); and (iv) t i (v −i ) can be computed in polytime for all i, v −i .
To see truthfulness, let v i = (v i,e ) e∈Ei be i's true input.
Fix v −i .
Suppose i wins under (v i , v −i ).
Her utility is u i (v i ; v i , v −i ) = v i (E i ) − t i (v −i ) ≥ 0.
Since q i (v) = t i (v −i ) if i wins, i cannot improve her utility by lying.
If i loses under (v i , v −i ) then (iii) implies that v i (E i ) ≤ t i (v −i )and so i cannot improve her utility by lying.We have shown that M is polytime, truthful, and ICT.
We now prove the approximation guarantee.
Let W = g(v).
By Lemma 4.1 and Theorem 4.2 we know thatC M (W ) + i:˜ zi>0 v i (E i ) ≤ (ρ + 1) ˜ opt.
Let (x * , z * )be an optimal solution to the original SCM-LP (SC-P) for v and OPT denote its value.
Define z i = z * (E i ).
Observe that (x * , z) is a feasible solution to (MSC-P).
Since v i (E i ) ≤ λv i,e for all i, e ∈ E i , ˜ opt is at most c T x * + i v i (E i )z i ≤ c T x * + i,e∈Ei λv i,e z * i,e ≤ λOPT .
Converting approximation algorithms to truthful, approximation mechanisms.
We say that Alg is a Lagrangian-multiplier-preserving (LMP) ρ-approximation algorithm for the SCM problem, if for every input v, it returns a set S ⊆ E such thatC Alg (S) + ρ i e∈Ei\S v i (e) ≤ ρOPT (SC-P).
(Recall that (SC-P) is the LP-relaxation of the SCM problem.)
Such LMP approximations are indeed known for various SCM problems, such as Steiner tree [21], set cover, vertex cover [35], and facility location [11].
A randomized mechanism is truthful in expectation, if each player always maximizes her expected utility by revealing her true type.Theorem 6.2.
Given an LMP ρ-approximation algorithm Alg for the SCM problem, one can obtain a truthful-in-expectation, ρ-approximation mechanism for the ME problem.Proof.
The construction exploits the convexdecomposition idea used in [37].
This observation is also used in [42].
On input v, we compute an optimal solution x * , z * to (SC-P).
Let OPT denote its value.
Note that since we solve (SC-P) optimally, we can use the VCG prices {p i } (which can be computed efficiently) to obtain a fractional truthful mechanism.
More precisely, this means that if (x , z ) is the optimal solution to (SC-P) for input (v i , v −i ), then we havee∈Ei v i,e (1 − z * e,i ) − p i (v) ≥ e∈Ei v i,e (1 − z e,i ) − p i (v i , v −i ).
We show that using Alg one can obtain a convex combination of polynomially many integral solutions to (SC-P) such that Pr[element e ∈ E i is not served] = z * e,i for all i, e ∈ E i and the expected cost is at most ρ · OPT .
Our randomized allocation rule chooses an integral solution with probability equal to its weight in this convex combination.
Let X denote the random set served.
As in [37], we can come up with random prices{Q i } such that Q i (v) ≤ v i (X) and E Q i (v) = p i (v).
This randomized mechanism clearly achieves a ρ-approximation.
It is truthful in expectation because a player's expected utility is the same as her utility in the fractional truthful mechanism.
Formally, if player i's true type is v i and the others report v −i , her expected utilityE u i (v i ; v i , v −i ) when she re- ports v i is e∈Ei v e,i 1 − Pr[e is not served] − p i (v) = e∈Ei v e,i (1−z * e,i )−p i (v), and if she reports v i , we haveE u i (v i ; v i , v −i ) = e∈Ei v e,i (1 − z e,i ) − p i (v i , v −i ) ≤ E u i (v i ; v i , v −i ) .
Let {(x (l) , z (l))} l∈I denote the collection of all integral solutions to (SC-P) where z e,i ∈ {0, 1} for all i, e ∈ E i .
Examining (SC1-P) and (SC2-P) we see that if (x, z) is a feasible solution, then so is (x, z ) where z ≥ z. Consider the following LP.
The index l below indexes integral solutions and ranges over I.max l γ l (P) s.t. l γ l ≤ 1 (6.9) l γ l c T x (l) ≤ ρc T x * (6.10) l γ l z (l) ≤ z * (6.11) γ ≥ 0.
We claim that a feasible solution to this LP with value 1 (which is therefore an optimal solution) can be modified so that (6.11) holds at equality.
To see this, supposethat l γ l z (l)i,e < z * i,e .
Then, we can take some l such that γ l > 0 and z i ,e for all (i , e ) = (i, e).
By repeatedly doing this, we can obtain a convex combination where (6.11) holds at equality.
To show that the optimal value of (P) is 1 and that it can be solved efficiently, we move to the dual.min ρ(κc T x * + w T z * ) + δ (D) s.t. κc T x (l) + ρw T z (l) + δ ≥ 1 ∀l κ, δ, w ≥ 0.
Here δ and κ are the dual variables corresponding to (6.9) and (6.10) respectively, and ρw e,i is the dual variable corresponding to the (i, e)-th constraint of (6.11).
Suppose there is some (κ, δ, w) for which the objective value of (D) is less than 1.
Then, since Alg is an LMP ρ-approximation algorithm, we can run it on the input (c, w/κ) to obtain an integer solution (x (l) , z (l) ) such that c T x (l) + ρw T z (l) /κ ≤ ρ(c T x * + w T z * /κ) < (1 − δ)/κ.But this means that the corresponding constraint of (D) is violated.
This shows that OPT (D) = OPT (P) ≥ 1, and hence is exactly one.
By using the ellipsoid method with Alg providing a separation oracle, we can get an LP with only polynomially many constraints that is equivalent to (D); taking its dual yields an LP of the form (P) with only polynomially many variables.
Solving this, and then tweaking the γ values so that (6.11) holds at equality yields the desired convex combination (with polynomial support).6.2 The multi-demand setting.
Recall that in the multi-demand (MD) setting, each player i has a maximum level of service R i .
An outcome is a vector = ( 1 , . . . , n ) with i specifying the level offered to player i. Player i's value under is v i ( i ) := i k=1 v i,k , where v i ∈ R Ri + is her private type with v i,k > 0 being the marginal value of increasing i's level to k from k − 1.
We assume that v i,k is non-increasing with k.
The social cost of outcome is SC() := C() + i v i (R i ) − v i ( i )and ICT is the condition that the price charged to a player i is at most C(0, . . . , 0, i , 0, . . . , 0).
We assume that the outcome-set is downwards-closed and C is monotone: if ≤ and ∈ Z n + , then is an outcome if is, and C( ) ≤ C().
We say that C is sub-additive if C() + C( ) ≥ C {max( i , i )} i∈[n].
As in Section 6.1, we also consider the single-dimensional special case wherev i,k = v i for all k ∈ [R i ] (so SC() = C() + i v i (R i − i )); we call this the multi-demand single-dimensional (MDSD) problem.Analogous to (SC1-P) and (SC2-P), we consider MD problems where the SCM problem is captured by (MD1-P) or (MD2-P).
Here z i,k = 1 indicates that player i is offered level of service at most R i − k.
In the following, we require that b(i) r ∈ [R i ] for all i, r. min c T x + i Ri k=1 v i,Ri−k+1 z i,k (MD1-P) s.t. e A (i) re x e + b (i) r k=1 z i,k ≥ b (i) r ∀i, r (6.12) Bx ≥ d (6.13) x ∈ R m + , 0 ≤ z i,k ≤ 1 ∀i, k. min c T x + i Ri k=1 v i,k z i,k (MD2-P) s.t. e A (i) re x e + b (i) r k=1 z i,k ≥ b (i) r ∀i, r Bx ≥ d 0 ≤ x ≤ u, 0 ≤ z i,k ≤ 1 ∀i, k.As before, we require that d ≥ 0 and A (i) , b (i) ≥ 0 for every i. For (MD2-P), we also require that B ≥ 0, and for every i, if A (i)re > 0 and u e > 0 then A (i) re u e ≥ b (i)r .
The LP-relaxations corresponding to (MD1-P) and (MD2-P) for the CM problem where we want to find the min-cost way of serving each player i at level i are obtained by dropping all the z i,k variables, and replacing b r − (R i − i )}.
In the sequel, we use (MD-P) (which is (MD1-P) or (MD2-P)) to denote the SCM-LP.
As an example of an MD problem modeled by (MD-P), let us revisit EC-SNDP when multiple copies of an edge may be picked.
Each player i is an (s i , t i ) pair who requires R i edge-disjoint s i -t i paths.
A feasible solution may only provide i ≤ R i edge-disjoint s i -t i and incur a "penalty" for player i equal to Ri k=i+1 v i,k .
(Contrast this with the single-dimensional setting considered in Section 5, where a solution must either provide 0 or R i edge-disjoint s i -t i paths and incur the penalty for i in the former case.)
Another example is the set-multicover problem, where an element seeks to be covered by multiple sets (and sets may be picked multiple times).
Theorem 6.3.
Let R max = max i R i and λ(v) = max i v i (R i )/ min k∈[Ri] v i,k. Given an LP-based ρ-approximation algorithm for the multi-demand CM problem, we can obtain a truthful, cost-recovering mechanism with approximation ratio: (a) O (ρ+R max ) log n for the MDSD problem; and (b) O ρλ(v) log n on input v for the MD problem.
Both mechanisms are ICT if C is subadditive.Thus, we obtain truthful, cost-recovering, ICT mechanisms for:• EC-SNDP and ELC-SNDP with approximation O(R max log n) for the MDSD problem and O(λ(v) log n for the MD problem;• VC-SNDP with approximation O(R 3 max log 2 n) for the MDSD problem and O(R 3 max λ(v) log 2 n) for the MD problem;• set-multicover with approximation O((log n + R max ) log n) for the MD problem and O(λ(v) log 2 n) for the MD problem.These approximation factors can be improved by a factor of β at the expense of obtaining β-cost-recovery.
Proof.
The proof (as well as the theorem statement) is along the same lines as that of parts (b) and (c) of Theorem 6.1.
We reduce the multidimensional problem to the single-dimensional one by considering all-or-nothing outcomes; that is, outcomes where every player i is either served at level R i or not served at all.
For example, the all-or-nothing MD EC-SNDP problem is precisely the single-dimensional EC-SNDP problem considered in Section 5, where serving player i entails providing R i edge-disjoint paths, and not serving i involves incurring penalty v i (R i ).
We describe shortly how to obtain a truthful, nobossy (defined precisely later) mechanisms with (ρ + R max )-and (ρ + 1)λ(v)-approximations for the MDSD and MD problems respectively.
The procedure for injecting cost-recovery into this mechanism is the same in both cases.
For a set S ⊆ [n], let L S be the vector where L S,i = R i if i ∈ S and is 0 otherwise.
Let A := {S ⊆ [n] : L S ∈ A}.
(where A is the (downwards-closed) set of all outcomes.)
We simulate the construction from Section 3 for the cost function C : A → R + defined by C (S) := C(L S ).
Note that A is downwards closed and, if C is subadditive then so is C .
Thus, each player i is now a single-dimensional player whose value is v i (R i ).
So Theorem 3.1 combined with the above results shows that we obtain (polytime) truthful, cost-recovering mechanisms with approximation O((ρ + R max ) log n) and O ρλ(v) log n for the MDSD and MD problems respectively.
Moreover, these mechanisms are ICT if C is subadditive.
The single-dimensional MDSD problem.On input v, we compute the optimal solution x * , z * to (MD-P).
Let OPT denote its value.
Let z * i (R i ) denote k∈ [Ri] z * i,k .
Let S = {i : z * (R i ) = 0}.
We return g(v) := L S as the outcome, and use Alg to compute a solution for g(v).
In the sequel, we say that "i wins" if i is served at level R i .
Let t i (v −i ) denote the smallest value of v i R i under which i wins.
We set q i (v) = t i (v i ) if i wins and 0 otherwise for all i.
We argue that M = g, {q i } is polytime, truthful, ICT, achieves a (ρ + k)-approximation, and has the following no-bossiness property: if g(v i , v −i ) i = R i and g(v i , v −i ) i = R i then g(v i , v −i ) = g(v i , v −i ).
Suppose that i is a winner under input v. Let (x , z ) be an optimal solution for v = (v i , v −i ) where v i > v i .
Then, as in the proof of Theorem 4.1, it is easy to see that z (R i ) ≤ z * (R i ) = 0 and hence, that (x , z ) = (x * , z * ).
Hence, i is also a winner under v , and g(v) = g(v ).
The proof that M is ICT and that t i (v −i ) is polytime computable follows by mimicking the proof of Lemma 4.2 (or Theorem 4.2).
To prove the approximation, as before, it suffices to show that i:z * (Ri)>0 v i R i ≤ k · OPT .
If z * (R i ) > 0 then there is some k such that z * i,k > 0, so we only need to show that i,k:z * i,k >0 v i ≤ OPT .
This is easy to see if (MD-P) is (MD1-P).
Let {µ * i,r }, ω * , {π * i,k } be an optimal dual solution, where µ * i,r , ω * , and π * i,k correspond respectively to (6.12), (6.13) and the z i,k ≤ 1 constraint.
Then by complementary slackness, r + d T ω * − u T θ * − i,k π * i,k = OPT .
The MD problem.
Recall that C (S) := C(L S ).
We construct a mechanism M for the multi-dimensional problem by simulating the construction in Section 4 for C .
The LP-relaxation for this modified SCM problem is (MD-P) with the constraints z i,k = z i,k for all i, k, k ∈ [R i ].
Let (MMD-P) denote this modified SCM-LP.
Observe that (MMD-P) is of the same form as (SC-P) (for the corresponding all-or-nothing problem).
On input v, we compute the optimal solution (˜ x, ˜ z) to (MMD-P).
LetõptLet˜Letõpt denote its value.
Let S = {i : ˜ z i,1 = 0}.
We return g(v) := L S as the outcome, and use Alg to compute a solution for g(v).
Let t i (v −i ) denote the smallest value of v i (R i ) under which i wins.
We set q i (v) = t i (v −i ) if i ∈ S and 0 otherwise for all i. Recall that λ(v) = max i v i (R i )/ min k∈ [Ri] v i,k .
We abbreviate this to λ in the sequel.
We show that M = g, {q i } is polytime, truthful, ICT, no-bossy, and achieves a (ρ + 1)λ-approximation.
Since M simulates the construction in Section 4 for the (one-element) modified SCM problem, the proofs in Section 4 show that (i) g satisfies no-bossiness; (ii) q i (v) ≤ C (i) := C(L {i} ); (iii) g has the monotonicity property that v [Ri] λv i,k z * i,k ≤ λOPT .
