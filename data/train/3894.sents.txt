In response to increasingly sophisticated state-sponsored Internet censorship, recent work has proposed a new approach to censorship resistance: end-to-middle proxying.
This concept, developed in systems such as Telex, Decoy Routing, and Cirripede, moves anticensorship technology into the core of the network, at large ISPs outside the censoring country.
In this paper, we focus on two technical obstacles to the deployment of certain end-to-middle schemes: the need to selectively block flows and the need to observe both directions of a connection.
We propose a new construction, TapDance, that removes these requirements.
TapDance employs a novel TCP-level technique that allows the anticensorship station at an ISP to function as a passive network tap, without an inline blocking component.
We also apply a novel steganographic encoding to embed control messages in TLS ciphertext, allowing us to operate on HTTPS connections even under asymmetric routing.
We implement and evaluate a TapDance prototype that demonstrates how the system could function with minimal impact on an ISP's network operations.
Repressive governments have deployed increasingly sophisticated technology to block disfavored Internet content [5,50].
To circumvent such censorship, many users employ systems based on encrypted tunnels and proxies, such as VPNs, open HTTPS proxies, and a variety of purpose-built anticensorship tools [1,2,13,25,37].
However, censors are able to block many of these systems by discovering and banning the IP addresses of the servers on which they rely [46,47].
Some services attempt to remain unblocked by frequently changing their IP addresses, but they face a tension between the desire to make their network locations known to would-be users and the need to keep the same information secret from the censor.To avoid this tension and escape the cat-and-mouse game that results between censors and anticensorship tools, researchers have recently introduced a new approach called end-to-middle (E2M) proxying [21,26,49].
In an E2M system, friendly network operators agree to help users in other, censored countries access blocked information.
These censored users direct traffic toward uncensored "decoy" sites, but include with such traffic a special signal (undetectable by censors) through which they request access to different, censored destinations.
Participating friendly networks, upon detecting this signal, redirect the user's traffic to the censored destination.
From the perspective of the censor -or anyone else positioned between the censored user and the friendly network -the user appears to be in contact only with the decoy site.
In order to block the system, the censor would have to block all connections that pass through participating ISPs, which would result in a prohibitive level of overblocking if E2M systems were widely deployed at major carriers.Deployment challenges While E2M approaches appear promising compared to traditional proxies, they face technical hurdles that have thus far prevented any of them from being deployed at an ISP.
All existing schemes assume that participating ISPs will be able to selectively block connections between users and decoy sites.
Unfortunately, this requires introducing new hardware in-line with backbone links, which adds latency and introduces a possible point of failure.
ISPs typically have service level agreements (SLAs) with their customers and peers that govern performance and reliability, and adding in-line flow-blocking components may violate their contractual obligations.
Additionally, adding such hardware increases the number of components to check when a failure does occur, even in unrelated parts of the ISP's network, potentially complicating the investigation of outages and increasing downtime.
Given these risks, ISPs are reluctant to add in-line elements to their networks.
In private discussions with ISPs, we found that despite being willing to assist Internet freedom in a technical and even financial capacity, none were willing to deploy existing E2M technologies due to these potential operational impacts.
Furthermore, our original E2M proposal, Telex, assumes that the ISP sees traffic in both directions, clientdecoy and decoy-client.
While this might be true when the ISP is immediately upstream from the decoy server, it does not generally hold farther away.
IP flows are often asymmetric, such that the route taken from source to destination may be different from the reverse path.
This asymmetry limits an ISP to observing only one side of a connection.
The amount of asymmetry is ISP-dependent, but tier-2 ISPs typically see lower amounts of asymmetry (around 25% of packets) than tier-1s, where up to 90% of packets can be part of asymmetric flows [48].
This severely constrains where in the network E2M schemes that require symmetric flows can be deployed.Our approach In this paper, we propose TapDance, a novel end-to-middle proxy approach that removes these obstacles to deployment at the cost of a moderate increase in its susceptibility to active attacks by the censor.
TapDance is the first E2M proxy that works without an inline-blocking or redirecting element at an ISP.
Instead, our design requires only a passive tap that observes traffic transiting the ISP and the ability to inject new packets.
TapDance also includes a novel connection tagging mechanism that embeds steganographic tags into the ciphertext of a TLS connection.
We make use of this to allow the system to support asymmetric flows and to efficiently include large steganographic payloads in a single packet.Although TapDance appears to be more feasible to deploy than previous E2M designs, this comes with certain tradeoffs.
As we discuss in Section 5, there are several active attacks that a censor could perform on live flows in order to distinguish TapDance connections from normal traffic.
We note that each of the previous E2M schemes is also vulnerable to at least some active attacks.
As a potential countermeasure, we introduce active defense mechanisms, which utilize E2M's privileged vantage point in the network to induce false positives for the attacker.Even with these tradeoffs, TapDance provides a realistic path to deployment for E2M proxy systems.
Given the choice between previous schemes that appear not to be practically fieldable and our proposal, which better satisfies the constraints of real ISPs but requires a careful defense strategy, we believe TapDance is the more viable route to building anticensorship into the Internet's core.Organization Section 2 reviews the three existing E2M proposals.
Section 3 introduces our chosen ciphertext steganography mechanism, and Section 4 explains the rest of the TapDance construction.
In Section 5, we analyze the security of our scheme and propose active defense strategies.
In Section 6, we compare TapDance to previous E2M designs.
We describe our proof-of-concept implementation in Section 7 and evaluate its performance in Section 8.
We discuss future work in Section 9 and related work in Section 10, and we conclude in Section 11.
There are three original publications on end-to-middle proxying: Telex [49], Decoy Routing [26], and Cirripede [21].
The designs for these three systems are largely similar, although some notable differences exist.
Figure 1 show the Telex scheme, as one example.In each design, a client wishes to reach a censored website.
To do so, the client creates an encrypted connection to an unblocked decoy server, with the connection to this server passing through a cooperating ISP (outside the censored country) that has deployed an ISP station.
The decoy can be any server and is oblivious to the operation of the anticensorship system.
The ISP station determines that a particular client wishes to be proxied by recognizing a tag.
In Telex, this is a public-key steganographic tag placed in the random nonce of the ClientHello message of a Transport Layer Security (TLS) connection [12].
In Cirripede, users register their IP address with a registration server by making a series of TCP connections, encoding a similar tag in the initial sequence numbers (ISNs).
In Decoy Routing, the tag is placed in the TLS client nonce as in Telex, but the client and the ISP station are assumed to have a shared secret established out of band.In both Telex and Cirripede, the tag consists of an elliptic curve Diffie-Hellman (ECDH) public key point and a hash of the ECDH secret shared with the ISP station.
In Decoy Routing, the tag consists of an HMAC of the previously established shared secret key, the current hour, and a per-hour sequence number.
In all cases, only the station can observe this tag, using its private key or shared secret.Once the station has determined that a particular flow should be proxied, all three designs employ an inline blocking component at the ISP to block further communication between the client and the decoy server.
Telex and Decoy Routing both block only the tagged flow using an inline-blocking component.
Cirripede blocks all connections from a registered client.
Cirripede's inline blocking is based on the client's IP address and has a long duration, possibly making it easier to implement than the flow-based blocking used in Telex and Decoy Routing.After the TLS handshake has completed and the clientserver communication is blocked, all three designs have the station impersonate the decoy server, receiving packets to and spoofing packets from its IP address.
In Telex, the station uses the tag in the TLS client nonce to compute a shared secret with the client, which the client uses to seed its secret keys during the key exchange with the decoy server.
Using this seed and the ability to observe both sides of the TLS handshake, Telex derives the master secret under which the TLS client-server communication is encrypted, and continues to use this shared secret between station and client.
In Cirripede and Decoy Routing, the station changes the key stream to be encrypted under Server Telex Inline block starts; Telex forwards packets Telex resets server and impersonates server to client Figure 1: Telex End-to-Middle Scheme -To establish communication with an ISP-deployed Telex station, the client performs a TLS connection with an unblocked decoy server.
In the TLS ClientHello message, it replaces the random nonce with a public-key steganographic tag that can be observed by the Telex station at the on-path ISP outside the censored country.
When the station detects this tag with its private key, it blocks the true connection using an inline-blocking component and forwards packets for the remainder of the handshake.
Once the handshake is complete, Telex stops forwarding and begins to spoof packets from the decoy server in order to communicate with the client.
While here we only show the details of Telex, all of the first generation ISP proxies (Telex, Cirripede, and Decoy Routing) are similar in architecture; we note differences in Section 2.
the secret exchanged during registration (Cirripede) or previously shared (Decoy Routing).
Changing the communication to a new shared secret opens Cirripede and Decoy Routing to replay and preplay attacks by the adversary.
If an adversary suspects a user is accessing these proxies, it can create a new connection that replays parts from the suspected connection and receive confirmation that a particular flow uses the proxy.
For example, in Decoy Routing, the adversary can simply use the suspected connection's TLS client nonce in a new connection and send a request.
If the first response cannot be decrypted with the client-server shared secret, it confirms that the particular nonce was tagged.
For Cirripede, a similar replay of the tagged TCP SYN packets will register the adversary's client, and a connection to the decoy server over TLS will confirm this: if the adversary can decrypt the TLS response with the established master secret, the adversary is not registered with Cirripede, indicating that the TCP SYN packets were not a secret Cirripede tag.
Otherwise, if the adversary cannot decrypt the response, this indicates that the SYN packets were indeed a Cirripede tag.Telex is not vulnerable to either of these attacks, because the client uses the client-station shared secret to seed its half of the key exchange.
This allows the station to also compute the client-server shared master secret and verify that the client has knowledge of the client-server shared secret by verifying the TLS finished messages.
If an adversary attempted to replay the client random in a new connection, Telex would be able to determine that the user (in this case, the adversary) did not have knowledge of the client-station shared secret, because the user did not originally generate the Diffie-Hellman tag.
Thus, Telex is unable to decrypt and verify the TLS finished messages as expected, and will not spoof messages from the server.Both Cirripede and Decoy Routing function in the presence of asymmetric flows.
In Cirripede, the station only needs to observe communication from the client to the decoy server in order to establish its shared secret with the client.
In Decoy Routing, the client sends any missing information (i.e., information contained in messages from the server to the client) via another covert channel.
In contrast, Telex's approach does not handle asymmetric paths, as the station needs to see both sides of the communication in order to learn the client-server shared master secret.Unlike any of the existing schemes, TapDance functions without an inline blocking component, potentially making it much easier to deploy at ISPs.
Unlike Telex, it supports asymmetric flows, but in doing so it sacrifices some of Telex's resistance to active attacks.
We defer a complete comparison between TapDance and the firstgeneration E2M schemes until Section 6, after we have introduced the details of the system.
Previous E2M covert channels have been limited in size, forcing implementations to use small payloads or several flows in order to steganographically communicate enough information to the ISP station.
However, because TapDance does not depend on inline flow-blocking and must work with asymmetric flows, we need a way to communicate the client's request directly to the TapDance station while maintaining a valid TLS session between the client and the decoy server.
We therefore introduce a novel technique, chosen-ciphertext steganography, which allows us to encode a much higher bandwidth steganographic payload in the ciphertexts of legitimate (i.e., censor-allowed) TLS traffic.The classic problem in steganography is known as the prisoners' problem, formulated by Simmons [41]: two prisoners, Alice and Bob, wish to send hidden messages in the presence of a jailer.
These messages are disguised in legitimate, public communication between Alice and Bob in such a way that the jailer cannot detect their presence.
Many traditional steganographic techniques focus on embedding hidden messages in non-uniform cover channels such as images or text [4]; in the network setting, each layer of the OSI model may provide potential cover traffic [19] of varying bandwidths.
To avoid detection, these channels must not alter the expected distribution of cover traffic [32].
In addition, use of header fields in network protocols for steganographic cover limits the carrying capacity of the covert channel.We observe it is possible for the sender to use stream ciphers and CBC-mode ciphers as steganographic channels.
This allows a sender Alice to embed an arbitrary hidden message to a third party, Bob, inside a valid ciphertext for Cathy.
That is, Bob will be able to extract the hidden message and Cathy will be able to decrypt the ciphertext, without alerting outside entities (or, indeed, Cathy, subject to certain assumptions) to the presence of the steganographic messages.Moreover, through this technique, we can place limited constraints on the plaintext (such as requiring it be valid base64 or numeric characters), while encoding arbitrary data in the corresponding ciphertext.
This allows us to ensure not only that Cathy can decrypt the received ciphertext, but also that the plaintext is consistent with the protocol used.
Note that this is a departure from the original prisoners' problem, as we assume Alice is allowed to securely communicate with Cathy, so long as this communication looks legitimate to outside entities.As our technique works both with stream ciphers and CBC-mode ciphers, which are the two most common modes used in TLS [28], we will use this building block to encode steganographic tags and payloads in the ciphertext of TLS requests.
To describe our technique, we start with a stream cipher in counter mode.
The key observation is that counter mode ciphers, even with authentication tags, have ciphertexts that are malleable from the perspective of the sender, Alice.
That is, stream ciphers have the general property of ciphertext malleability, in that flipping a single bit in the ciphertext flips a single corresponding bit in the decrypted plaintext.
Alice can likewise change bits in the plaintext to effect specific bits in the corresponding ciphertext.
Since Alice knows the keystream for the stream cipher, she can choose an arbitrary string that she would like to appear in the ciphertext, and compute (decrypt) the corresponding plaintext.
Note that this does not invalidate the MAC or authentication tag used in addition to this cipher, because Alice first computes a valid plaintext, and then encrypts and MACs it using the standard library, resulting in ciphertext that contains her chosen steganographic data.Furthermore, Alice can "fix" particular bits in the plaintext and allow the remaining bits to be determined by the data encoded in the ciphertext.
For example, Alice could require that each plaintext byte starts with 5 bits set to 00110, and allow the remaining 3 bits to be chosen by the ciphertext.
In this way, the plaintext will always be an ASCII character from the set "01234567" and the ciphertext has a steganographic "carrying capacity" to encode 3 bits per byte.While it seems intuitive that Alice can limit plaintext bits for stream ciphers, it may not be as intuitive to see how this is also possible for CBC-mode ciphers.
However, while the ciphertext malleability of stream ciphers allows Alice partial control over the resulting plaintext, we show that it is also possible to use this technique in other cipher modes, with equal control over the plaintext values.In CBC mode, it is possible to choose the value of an arbitrary ciphertext block (e.g., C 2 ), and decrypt it to compute an intermediary result.
This intermediary result must also be the result of the current plaintext block (P 2 ) xored with the previous ciphertext block (C 1 ) in order to encrypt to the chosen ciphertext value.
This means that, given a ciphertext block, we can choose either the plaintext value (P 2 ), or the previous ciphertext block (C 1 ), and compute the other.
However, we can also choose a mixture of the two; that is, for each bit we pick in the plaintext, we are "forced" to choose that corresponding bit in the previous plaintext block and viseversa.
Choosing any bits in a ciphertext block (C 1 ) will force us to repeat this operation for the previous plaintext block (P 1 ) and twice previous ciphertext block (C 0 ).
We can choose to pick the value of plaintext blocks (fixing the corresponding ciphertext blocks), all the way IV P 0 P 1 P 2 C 0 C 1 C 2Figure 2: CBC Chosen Ciphertext Example -In this example, bits chosen by the encoding are in black, while bits "forced" by computation are red.
For example, we choose all 6-bits to be 0 in the last ciphertext block.
This forces the block's intermediary to be "forced" to a value beyond our control; in this case 001101.
To obtain this value, we can choose a mixture of bits in the plaintext, which forces the corresponding bits in the previous ciphertext block.
In this example, we choose the plaintext block to be of the form 1xx1xx, allowing us to choose 4-bits in the ciphertext, which we choose to be 0s.
Thus, the ciphertext has the form x00x00.
We solve for the unknown bits in the ciphertext and plaintext (1xx1xx ⊕ x00x00 = 001101) to fill in the missing "fixed" values.
We can repeat this process backward until the first block, where we simply compute the IV in order to allow choosing all the bits in the first plaintext block.back to the first plaintext block, where we are left to decide if we want to choose the value of the first plaintext block or the Initialization Vector (IV) value.
At this point, fixing the IV is the natural choice, as this leaves us greater control over the first plaintext block.
Figure 2 shows an example of this backpropagation, encoding a total of 4-bits per 6-bit ciphertext block (plus a full final block).
This scheme allows us to restrict plaintexts encrypted with CBC to the same ASCII range as before, while still allowing us to encode arbitrary-length messages in the ciphertext.While the sender can encode any value in the ciphertext in this manner, we do not wish to change the expected ciphertext distribution.
The counter and CBC modes of encryption both satisfy indistinguishability from random bits [38], so encoding anything that is distinguishable from a uniform random string would allow third parties (e.g., a network censor) to detect this covert channel.
To prevent this, Alice encrypts her hidden message if necessary, using an encryption scheme that produces ciphertexts indistinguishable from random bits.
The resulting ciphertext for Bob is then encoded in the CBC or stream-cipher ciphertext as outlined above.
To an outside adversary, this resulting "ciphertext-in-ciphertext" should still be a string indistinguishable from random, as expected.
The TapDance protocol requires only a passive network tap and traffic injection capability, and is carefully designed to work even if the station is unable to observe communication between the decoy server and the client.
To accomplish this, we utilize several tricks gleaned from a close reading of the TCP specification [35] to allow the TapDance station to impersonate the decoy server without blocking traffic between client and server.
Figure 3 gives an overview of the TapDance protocol.
In the first step, the client establishes a normal TLS connection to the decoy web server.
Once this handshake is complete, the client and decoy server share a master secret, which they use to generate encryption keys, MAC keys, and initialization vector or sequence state.The TapDance protocol requires the client to leak knowledge of the client-server master secret, thereby allowing the station to use this shared secret to encrypt all communications.
The client encodes the master secret as part of a steganographic tag visible only to the TapDance station.
This tag is hidden in an incomplete HTTP request sent to the decoy server through the encrypted channel.
Since this request is incomplete, the decoy server will not respond with data to the client; this can be accomplished, for example, by simply withholding the two consecutive line breaks that mark the end of an HTTP request.
The decoy server will acknowledge this data only at the TCP level by sending a TCP ACK packet and will then wait for the rest of the client's incomplete HTTP request until it times out.
As shown in Figure 5, our evaluation reveals that most TLS hosts on the Internet will leave such incomplete request connections open for at least 60 seconds before sending additional data or closing the connection.When the TapDance station observes this encrypted HTTP request, it is able to extract the tag (and hence the master secret), as discussed in detail in Section 4.2.
The station then spoofs an encrypted response from the decoy server to the client.
This message acts as confirmation for the client that the TapDance station is present.
In particular, this message is consistent with a pipelined HTTPS connection, so by itself does not indicate that TapDance is in use.At the TCP level, the client acknowledges this spoofed data with a TCP ACK packet, and because there is no inline-blocking between it and the server, the ACK will reach the server.
However, because the acknowledgment number is above the server's SND.NXT , the server will not respond.
Similarly, if the client responds with additional data, the acknowledgment field contained in those TCP packets will also be beyond what the server has sent.
This allows the TapDance station to continue to imper- The server sends a TCP ACK message in response to the incomplete HTTP request and waits for the request to be completed or until it times out.
(5) The station, meanwhile, spoofs a response to the client from the decoy server.
This message is encrypted under K and indicates the station's presence to the client.
(6) The client sends a TCP ACK (for the spoofed data) and its real request (blocked.com).
The server ignores both of these, because the TCP acknowledgment field is higher than the server's TCP SND.NXT.
(7) The TapDance station sends back the requested page (blocked.com) as a spoofed response from the server.
(8) When finished, the client and TapDance station simulate a standard TCP/TLS authenticated shutdown, which is again ignored by the true server.
(9) After the connection is terminated by the client, the TapDance station sends a TCP RST packet that is valid for the server's SND.NXT, silently closing its end of the connection before its timeout expires.sonate the server, acknowledging data the client sends, and sending its own data in response, without interference from the server itself.
In TapDance, we rely on elliptic curve Diffie-Hellman to agree on a per-connection shared secret between the client and station, which is used to encrypt the steganographic tag payload.
The tag consists of the client's connectionspecific elliptic curve public key point (Q = eG), encoded as a string indistinguishable from uniform, followed by a variable-length encrypted payload used to communicate the client-server TLS master secret (and intent for proxying) to the station.
In order to properly disguise the client's elliptic curve point, we use Elligator 2 [8] over Curve25519 [7].
Elligator 2 is an efficient encoding function that transforms, for certain types of elliptic curves, exactly half of the points on the curve to strings that are indistinguishable from uniform random strings.The client uses the TapDance station's public key point (P = dG) and its own private key (e) to compute an ECDH shared secret with the station (S = eP = dQ), which is used to derive the payload encryption key.
The encrypted payload contains an 8-byte magic value used by the station to detect successful decryption, the client and server random nonces, and the client-server master secret of the TLS connection.
With this payload, typically contained in a single packet from the client, the station is able to derive the TLS master secret between client and server.We insert the tag, composed of the encoded point and encrypted payload, into the ciphertext of the client's incomplete request to the server using the chosen ciphertext steganographic channel described in Section 3.
In order to avoid the server generating unwanted error messages, we maintain some control over the plaintext that the server receives using the plaintext-limiting technique as described in Section 3.
Specifically, we split the tag into 6-bit chunks and encode each chunk in the low order bits of a ciphertext byte.
This allows the two most significant bits to be chosen freely in the plaintext (i.e. not decided by the decryption of the tag-containing ciphertext).
We choose these two bits so that the plaintext always falls within the ASCII range 0x40 to 0x7f.
We verified that Apache was capable of handling this range of characters in a header line without triggering an error.
Our threat model is similar to that of previous end-tomiddle designs.
We assume an adversarial censor that can observe, alter, block, or inject network traffic within their domain or geographic region (i.e., country) and may gain access to foreign resources, such as VPNs or private servers, by leasing them from providers.
Despite control over its network infrastructure, however, we assume the censor does not have control over end-users' computers, such as the ability to install arbitrary programs or Trojans.The censor can block its citizens' access to websites it finds objectionable, proxies, or other communication endpoints it chooses, using IP blocking, DNS blacklists, and deep-packet inspection.
We assume the censor uses blacklisting to block resources and that the censor does not wish to block legitimate websites or otherwise cut themselves off from the rest of the Internet, which may inhibit desirable commerce or communication.
In addition, we assume that the censor allows end-to-end encrypted communication, specifically TLS communication.
As websites increasingly support HTTPS, censors face increasing pressures against preventing TLS connections [14].
While the threat model for TapDance is similar to those assumed by prior end-to-middle schemes, our fundamentally new design has a different attack surface than the others.
We perform a security analysis of TapDance and compare it to the previous generation designs, focusing on the adversarial goal of distinguishing normal TLS connections from TapDance connections.
In particular, we do not attempt to hide the deployment locations of the TapDance stations themselves.
TLS handshake TLS allows implementations to support many different extensions and cipher suites.
As a result, implementations can be easy to differentiate based on the ciphers and extensions they claim to support in their ClientHello or ServerHello messages.
In order to prevent this from being used to locate suspicious implementations, our proxy must blend in to or mimic another popular client TLS implementation.
For example, we could support the same set of ciphers and extensions as Chrome for the user's platform.
Currently, our client mimics Chrome's cipher suite list for Linux.Cryptographic attacks A computationally powerful adversary could attempt to derive the station's private key from the public key.
However, our use of ECC Curve25519 should resist even the most powerful computation attacks using known discrete logarithm algorithms.
The largest publicly known ECC key to be broken is only 112 bits, broken over 6 months in 2009 on a 200-PlayStation3 cluster [9].
In contrast to Telex, TapDance also supports increasing the key size as needed, as we are not limited to a fixed field size for our tag.Forward secrecy An adversary who compromises an ISP station or otherwise obtains a station's private key can use it to trivially detect both future and previously recorded flows in order to tell if they were proxy flows.
Additionally, they can use the key to decrypt the user's request (and proxy's response), learning the censored websites users have visited.
To address the first problem, we can use a technique suggested in Telex [49].
The ISP station generates many private keys ahead of time and stores them in either a hardware security module or offline storage, and provides all of the public keys to the clients.
Clients can then cycle through the public keys they use based on a course-grained time (e.g., hours or days).
The proxy could also cycle through keys, destroying expired keys and limiting access to future ones.To address the second problem, TapDance is compatible with existing forward-secure protocols.
For example, for each new connection it receives, the TapDance station can generate a new ECDH point randomly, and establish a new shared secret between this new point and the original point sent by the client in the connection tag.
The station sends its new ECDH public point to the client in its Hello message, and the remainder of the connection is encrypted under the new shared secret.
This scheme has the advantage that it adds no new round trips to the scheme and only 32-bytes to the original ISP station's response.Packet timing and length The censor could passively measure the normal round-trip time between potential servers and observe the set of packet lengths of encrypted data that a website typically returns.
During a proxy connection, the round-trip time or the packet lengths of the apparent server may change for an observant censor, as the station may be closer or have more processing delay than the true server.
This attack is possible on all three of the first generation E2M schemes, as detailed in [40].
However, such an attack at the application level may be difficult to carry out in practice, as larger, legitimate websites may have many member-only pages that contain different payload lengths and different processing overhead.
The censor must be able to distinguish between "blind pages" it cannot confirm are part of the legitimate site and decoy proxy connections.
We note that this is difficult at the application level, but TCP round-trip times may have a more consistent and distinguishable difference.Lack of server response If the TapDance station fails to detect a client's flow, it will not respond to the client.
This may appear suspicious to a censor, as the client sends a request, but there is no response at the application level from the server.
This scenario could occur for three reasons.
First, the censor may disrupt the path between client and TapDance station in order to cause such a timeout, using one of the active attacks below (such as the routingaround attack), in order to confirm a particular flow is attempting to use TapDance.
Second, such false pickups may happen intermittently (due to ISP station malfunction).
Finally, a client may attempt to find new TapDance stations by probing many potential decoy servers with tagged TLS connections.
Paths that do not contain ISP stations will have suspiciously long server response times.To address the last issue, probing clients could send complete requests and tag their requests with a secret nonce.
The station could record these secret nonces, and, at a later time (out of band, or through a different TapDance station), the client can query the station for the secret nonces it sent.
In this way, the client learns new servers for which the ISP station is willing to proxy without revealing the probing pattern.
To address the first two problems, we could have clients commonly use servers that support long-polling HTTP push notification.
In these services, normal requests can go unanswered at the application layer as long as the server does not have data to send to the client, such as in online-gaming or XMPP servers.
Another defense is to have the client send complete requests that force the server to keep the connection alive for additional requests, and to have the TapDance station inject additional data after the server's initial response.
This requires careful knowledge of the timing and length of the server's initial response, which could either be provided by active probing from the station or information given by the client.TCP/IP protocol fingerprinting The adversary could attempt to observe packets coming from potential decoy servers and build profiles for each server, including the set of TCP options supported by the server, IP TTL values, TCP window sizes, and TCP timestamp slope and offset.
If these values ever change, particularly in the middle of a connection (and only for that connection), it could be a strong indication of a particular flow using a proxy at an on-path ISP.
To prevent this attack, the station also needs to build these profiles for servers, either by actively collecting this profile from potential servers, or passively observing the server's responses to non-proxy connections and extracting the parameters.
Alternatively, the client can signal to the station some of the parameters.
First generation schemes varied in defense for this type of attack; for example, Telex's implementation is able to infer and mimic all of these parameters from observing the servers' responses, although Telex requires a symmetric path in order to accomplish this.
In theory, parameters that the adversary can measure for fingerprinting can also be measured by the station and mimicked.
However, given that the adversary has only to find one distinguisher in order to succeed, server mimicry remains difficult to achieve in practice.
TLS attacks The censor may issue fake TLS certificates from a certificate authority under its control and then target TLS sessions with a man-in-the-middle attack.While TapDance and previous designs are vulnerable to this attack, there may be external political pressure that discourages a censor from this attack, as it may be disruptive to foreign e-commerce in particular.
We also argue that as the number of sites using TLS continues to increase, this attack becomes more expensive for the censor to perform without impacting performance.
Finally, decoy servers that use certificate pinning or other CA-protection mechanisms such as Perspectives [45], CAge [27], or CA country pinning [42], can potentially avoid such attacks.Packet injection Because TapDance does not block packets from the client to the true server, it is possible for the censor to inject spoofed probes from the client that will reach the server.
If the censor can craft a probe that will result in the server generating a response that reveals the server's true TCP state, the censor will be able to use this response to differentiate real connections from proxy connections.
While the previous designs also faced this threat [40], the censor had to inject the spoofed packet in a way that bypassed the station's ISP inline blocking element.
In TapDance, there is no blocking element, and so the censor is able to simply send it without any routing tricks.
An example of this attack is the censor sending a TCP ACK packet with a stale sequence number, or one for data outside the server's receive window.
The server will respond to this packet with an ACK containing the server's TCP state (sequence and acknowledgment), which will be smaller than the last sequence and/or acknowledgments sent by the station.There are a few ways to deal with this attack if the censor employs it.
First, we can simply limit each proxy connection to a single request from the client and a response from the station, followed immediately by a connection close.
This will dramatically increase the overhead of the system but will remove the potential for the adversary to use injected packets and their responses to differentiate between normal and proxy connections.
This is because the TCP state between the station and real server will not diverge until the station has sent its response, leaving only a very small window where the censor can probe the real server for its state and get a different response.Active defense Alternatively, in order to frustrate the censor from performing packet injection attacks, we can perform active defense, where the station observes active probes such as the TCP ACK and responds to them in a way that would "reveal" a proxy connection, even for flows that are not proxy connections.
To the censor, this would make even legitimate non-proxy connections to the server appear as if they were proxy connections.As an example, consider a censor that injects a stale ACK for suspected proxy connections.
Connections that are actually proxy connections will respond with a stale ACK from the server, revealing the connection to the censor.
However, the station could detect the original probe, and if it is not a proxied connection, respond with a stale ACK so as to make it appear to the censor as if it were.
In this way, for every probe the censor makes, they will detect, sometimes incorrectly, that the connection was a proxy connection.Replay attacks The censor could capture suspected tags and attempt to replay them in a new connection, to determine if the station responds to the tag.
To specifically attack TapDance, the adversary could replay the client's tag-containing request packet after the connection has closed and observe if the station appears to send back a response.
We note that both Cirripede and Decoy Routing are also vulnerable to tag replay attacks, although Telex provides some limited protection from them.
To protect against duplicated tags, the station could record previous tags and refuse to respond to a repeated tag.
To avoid saving all tags, the station could require clients to include a recent timestamp in the encrypted payload 1 .
However, such a defense may enable a denial of service attack: the censor could delay the true request of a suspected client and send it in a different connection first.
In this preplay version of the attack, the censor is also able to observe whether the station responds with the ClientHello message.
If it does, the censor will know the suspected request contained a tag.Denial of service The censor could attempt to exhaust the station's resources by creating many proxy connections, or by sending a large volume of traffic that the ISP station will have to check for tags using an expensive ECC function.
We estimate that a single ISP station deployment of our implementation on a 16-core machine could be overwhelmed if an attacker sends approximately 1.2 Gbps of pure TLS application data packets past it.
This type of attack is feasible for an attack with a small botnet, or even a few well-connected servers.
Because ISPs commonly perform load balancing by flow-based hashing, we can scale our deployment linearly to multiple branches of machines and use standard intrusion detection techniques to ignore packets that do not belong to valid connections or that come from spoofed or blacklisted sources [34].
A recent paper by Schuchard et al. details a novel attack against our and previous designs [40].
In this attack, the censor is able to change local routing policy in a way that redirects outbound flows around potential station-deploying ISPs while still allowing them to reach their destinations.
This prevents the ISP station from being able to observe the tagged flows and thus from being a proxy for the clients.
However, Houmansadr et al. investigate the cost to the censor of performing such an attack and find it to be prohibitively expensive [23].
Although both of these papers ultimately contribute to deciding which ISPs should deploy proxies in order to be most resilient, we consider such a discussion outside our current scope.Tunneling around the proxy A more conceptually simple attack is for the censor to transparently tunnel specific suspected flows around the ISP station.
For example, the censor could rent a VPN or VPS outside the country and send specific flows through them to avoid their paths crossing the ISP station.
This attack is expensive for the adversary to perform, and so could not reasonably be performed for an entire country.
However, it could be performed for particular targets and combined with previous passive detection attacks to aid the censor in confirming whether particular users are tagging their flows.Complicit servers A censor may be able to compromise, coerce, or host websites that can act as servers for decoy connections.
The vantage point from a server allows them to observe incomplete requests from clients, including the plaintext that the client mangled in order to produce the tag in the ciphertext.
This allows the censor to both observe specific clients using the ISP station and also disrupt use of the proxy with the particular server.
There is little TapDance or previous designs can do to avoid cooperation between servers and the censor, as the two can simply compare traffic received and detect proxy flows as ones that have different data at the two vantage points.
However, using this vantage point to disrupt proxy use could be detected by clients and the server avoided (and potentially notified in the case of a compromise).
On the protocol level, TapDance bears more similarity to Telex than Cirripede, in that clients participate in TapDance on a per-connection basis, rather than participating in a separate registration phase as in Cirripede, and in that client-station communication, after the initial DiffieHellman handshake, is secured using the client-server master secret.
In order to conserve bandwidth, our design, like both Telex and Cirripede, leverages elliptic curve cryptography to signal intent to use the system and to establish a shared secret between client and station.However, TapDance exhibits several important differences from previous protocols, which has implications for both security and functionality.
As discussed in Section 1, one of the largest challenges to deploying E2M proxies at ISPs is the inline flow-blocking component.
TapDance has the singular advantage in that it allows client-server communication to continue unimpeded.
In fact, our design requires only that the TapDance station be able to passively observe communication from client to server and be able to inject messages into the network; the station can be oblivious to communication passing from server to client.The advantages of the TapDance protocol stem from its careful use of chosen-ciphertext steganography (described in Section 3) to hide the client's tag and the fact that a high percentage of servers ignore stale TCP-level messages.
In contrast, previous proposals rely on inline blocking to prevent server-client communication, and TCP sequence numbers and TLS ClientHello random nonces to disguise the client's steganographic tag.
In general, these fields are useful in steganography because these strings should be uniformly random for legitimate connections, providing a good cover for the tag that replaces them, so long as this tag is indistinguishable from random.However, both of these fields are fixed size; each TLS nonce can be replaced with a 224-bit uniform random tag, and each TCP sequence number with only 24 bits of a tag.
Cirripede, which encodes the client's tag into TCP sequence numbers, uses multiple TCP connections to convey the full tag to the station.
Telex and Decoy Routing both use a single TLS nonce to encode the client's tag.
Given the limited bandwidth of these covert channels, they are useful to convey only short secrets, while the rest of the payload (such as the request for a blocked website) must take place in a future packet.TapDance, on the other hand, leverages chosenciphertext steganography in order to encode steganographic tags in the ciphertext of a TLS connection, without invalidating the TLS session itself.
Encoding the tag in the ciphertext has several advantages.
First, the tag is no longer constrained to a fixed field size of either 24 or 224 bits, allowing us to encode more information in each tag, and use larger and more secure elliptic curves.
Second, because the ciphertext is sent after the TLS handshake has completed, it is possible to encode the connection's master secret in this tag, allowing the station to decrypt the TLS session from a single packet, and without requiring the station to observe packets from the server.In addition, TapDance takes advantage of recent work by Bernstein et al. [8], in order to disguise elliptic curve points as strings indistinguishable from uniform, namely Elligator 2.
Traditional encoding of elliptic curve points is distinguishable from random for several reasons, which are outlined in detail in [8].
Telex and Cirripede address this concern by employing two closely related elliptic curves, which is less efficient than TapDance's use of Elligator 2, as the latter method requires only a single elliptic curve to achieve the same functionality.From a security perspective, the only attacks unique to TapDance are the lack of server response and packet injection attacks.
Besides these, we find our design has no additional vulnerabilities from which all previous designs were immune.
While these two attacks do pose a threat to TapDance, the benefits of a practical ISP station deployment -at least as a bridge to stronger future systems -may outweigh the potential risks.
In summary, our approach obviates the need for an inline blocking element at the ISP, which is a requirement of Telex, Cirripede, and Decoy Routing, while preserving system functionality in the presence of asymmetric flows, which is an advantage over Telex.
In addition, the covert channel used in TapDance is higher bandwidth than that of previous proposals and holds potential for future improvements (e.g., in terms of number of communication rounds required and flexible security levels) of client-station protocols.
We have implemented TapDance in two parts: a client that acts as a local HTTP proxy for a user's browser, and a station that observes a packet tap at an ISP and injects traffic when it detects tagged connections.
Our station code is written in approximately 1,300 lines of C, using libevent, OpenSSL, PF_RING [33], and forge_socket 2 .
Our client is written in approximately 1,000 lines of C using libevent [29] and OpenSSL [36].
The client currently takes the domain name of the decoy server as a command line argument, and for each new local connection from the browser, creates a TLS connection to the decoy server.
Once the handshake completes, the client sends the incomplete response to prevent the server from sending additional data, and to encode the secret tag in the ciphertext as specified in Section 4.2.
The request is simply an HTTP request with a valid HTTP request line, "Host" header, and an "X-Ignore" header that precedes the "garbage" plaintext that will be computed to result in the chosen tag appearing in the ciphertext.
We have implemented our ciphertext encoding for AES_128_GCM [39], although 2 https://github.com/ewust/forge_socket/ it also works without modification for AES_256_GCM cipher suites.
We have implemented Elligator 2 to work with Curve25519, in order to encode the client's public point in the ciphertext as a string that is indistinguishable from uniform random.
After this 32-byte encoded point, the client places a 144-byte encrypted payload.
This payload is encrypted using a SHA-256 hash of the 32-byte shared secret (derived from the client's secret and station's public point) using AES-128 in CBC mode.
We use the first 16-bytes of the shared secret hash as the key, and the last 16 bytes as the initialization vector (IV).
The payload contains an 8-byte magic value, the 48-byte TLS master secret, 32-byte client random, 32-byte server random, and a 16-byte randomized connection ID that allows a client to reconnect to a previous proxy connection in case the underlying decoy connection is prematurely closed.
Our TapDance station consists of a 16-core Supermicro server connected over a gigabit Ethernet to a mirror port on an HP 6600-24G-4XG switch in front of a well-used Tor exit node generating about 160 Mbps of traffic.
The station uses PF_RING, a fast packet capture Linux kernel module, to read packets from the mirror interface.
In addition to decreasing packet capture overhead, PF_RING supports flow clustering, allowing our implementation to spread TCP flow capture across multiple processes.
Using this library, our station can have several processes on separate cores share the aggregate load.For each unique flow (4-tuple), we keep a small amount of state whether we have seen an Application Data packet for the flow yet.
If we have not, we verify the current packet's TCP checksum, and inspect the packet to determine if it is an Application Data packet.
If it is, we mark this flow as having been inspected, and pass the packet ciphertext to the tag extractor function.
This function extracts the potential tag from the ciphertext, decoding the client's public point using Elligator 2, generating the shared secret using Curve25519, and hashing it to get the AES decryption key for the payload.
The extractor decrypts the 144-byte payload included by the client, and verifies that the first 8 bytes are the expected magic value.
If it is, the station knows this is a tagged flow, and uses the master secret and nonces extracted from the encrypted payload to compute the key block, which contains encryption and decryption keys, sequence numbers or IVs, and MAC keys (if not using authenticated encryption) for the TLS session between the client and server.This "ciphertext-in-ciphertext" is indistinguishable from random to everyone except the client and station.
The 144-byte payload is encrypted using a strong symmetric block cipher (AES-128) in CBC mode, whose key is derived from the client-station shared secret.
The remainder of the tag is the client's ECDH public point, encoded using Elligator 2 [8] over Curve25519 [7].
The encoded point is indistinguishable from uniform random due to the properties of the Elligator 2 encoding function.Once the station has determined the connection is a tagged flow, it sets up a socket in the kernel to allow it to spoof packets from and receive packets for the server using the forge_socket kernel module.
The station makes this socket non-blocking, and attaches an SSL object initialized with the extracted key block to it.
The station then sends a response to the client over this channel, containing a confirmation that the station has picked up, and the number of bytes that the client is allowed to send toward this station before it must create a new connection.
Because the server's connection with the client remains open, the server receives packets from the client, including data and acknowledgments for the station's data.
The server will initially ignore these messages, however there are two instances where the server will send data.
When it does so, the censor would be able to see this anomalous behavior, because the server will send data with stale sequence numbers and different payloads from what the station sent.The first instance of the server sending data is when the server times out the connection at the application level.
For example, web servers can be configured to timeout incomplete requests after a certain time, by using the mod_reqtimeout 3 module in Apache.
We found through our development and testing the shortest timeout was 20 seconds, although most servers had much longer timeouts.
We measured TLS hosts to determine how long they would take to time out or respond to an incomplete request similar to one used in TapDance.
We measured a 1% sample of the IPv4 address space listening on port 443, and the Alexa top million domains using ZMap [15], and found that many servers had timeouts longer than 5 minutes.
Figure 5 shows the fraction of server timeouts.
The second reason a server will send observable packets back to the client is if the client sends it a sequence number that is outside of the server's current TCP receive window.
This happens when the client has sent more than a window's worth of data to the station, at which point the server will respond with a TCP ACK packet containing the server's stale sequence and acknowledgment numbers, alerting an observant censor to the anomaly.To prevent both of these instances from occurring in our implementation, we limit the connection duration to less than the server's timeout, and we limit the number of bytes that a client can send to the station to up to the server's receive window size.
Receive window sizes after the TLS handshake completes are typically above about 16 KB.
We note that the station is not limited to the number of bytes it can send to the client per connection, making the 16 KB limit have minimal impact on most download-heavy connections.In the event that the client wants to maintain its connection for longer than the duration or send more than 16 KB, the client can reuse the 16-byte connection ID in a new E2M TLS connection to the server.
The station will decode the connection ID and reconnect the new flow to the old proxy connection seamlessly.
This allows the browser to communicate to the HTTP proxy indefinitely, without having to deal with the limitations of the underlying decoy connection.
Throughout our evaluation, we used a client running Ubuntu 13.10 connected to a university network over gigabit Ethernet.
For our decoy server, we used a Tor exit server at our institution, with a gigabit upstream through an HP 6600-24G-4XG switch.
For our ISP station, we used a 16-core Supermicro server with 64 GB of RAM, connected via gigabit NICs to an upstream and to a mirror port from the HP switch.
Our ISP station is therefore able to observe (but not block) packets to the Tor exit server, which provides a reasonable amount of background traffic on the order of 160 Mbps.
In our tests, the Tor exit node generates a modest amount of realistic user traffic.Although not anywhere near the bandwidth of a Tier-1 ISP, Tor exit nodes generate a greater ratio of HTTPS flows than a typical ISP (due to the Tor browser's inclusion of the HTTPS Everywhere plugin), and we can use this microbenchmark to perform a back-of-the-envelope calculation to the loads we would see at a 40 Gbps Transit ISP tap.
We evaluate our proof-of-concept implementation with the goal of demonstrating that our system operates as described, and that our implementation is able to function within the constraints of our mock-ISP.
To demonstrate that our system operates as described, we set Firefox to use our client as a proxy, and browsed several websites while capturing packets on the client and the decoy server.
We then manually inspected the recorded packets to confirm that there were no additional packets sent by the server that would reveal our connections to be proxied connections.
Empirically, we note that we are able to easily browse the Internet through this proxy, for example watching high-definition YouTube videos.To evaluate the performance of our system, we created 8 proxy processes on our ISP station, using the same PF_RING cluster ID in order to share the load across 8 cores.
The background traffic from the Tor exit server does not appear to have a significant impact on the proxy's load: each process handles between 20 and 50 flows at a given time, comprising up to 35 Mbps of TLS traffic.
The CPU load during this time was less than 1%.
We used Apache Benchmark 4 in order to issue 5,000 requests through our station proxy, with a concurrency of 100, and compared the performance for fetching a simple page over HTTP and over HTTPS.
We also compare fetching the same pages directly from the server and through a single-hop proxy.
Figure 4 shows the cumulative distribution function for the total time to download the page.
Although there is a modest overhead for end-to-middle proxy connections compared to direct or simple proxies, the overhead is not prohibitive to web browsing habits; users are still able to interact with the page, and pages can be expected to load in a reasonable time period.
In particular, our proxy adds a median latency of 270 milliseconds to a page download in our tests when compared with a direct download.We find that the CPU performance is bottlenecked by our single-threaded client.
During our tests, the client consumes 100% CPU on a single core, while each of the 8 processes on the ISP station consume between 4-7% CPU.
We also observe that a majority of the download time is spent waiting for the connection handshake to complete with the server.
To improve this performance, we could speculatively maintain a connection pool in order to decrease the wait-time between requests.
However, care must be taken in order to mimic the same connection pool behaviors that a browser might exhibit.We also note that although the distribution of download times appear different for ISP station vs. normal connections, this does not necessarily indicate an observable feature for a censor.
This is because our download involves a second round trip between client and server before the data reaches the client.
The censor would still have to distinguish between this type of connection behavior and innocuous HTTP pipelined connections.
It still may be possible for the censor to distinguish, however, as we discussed in Section 5, traffic analysis is an open problem for existing network proxies, and outside the scope of this paper.Tag creation and processing In order to evaluate the overhead of creating and checking for tags, we timed the creation and evaluation of 10,000 tags.
We were able to create over 2,400 tags/second on our client and verify over 12,000 tags/second on a single core of our ISP station.
We find that the majority of time (approximately 80%) during tag creation is spent performing the expected three ECC point multiplications (an expected two to generate the client's Elligator-encodable public point and one to generate the shared secret).
Similarly, during tag checking, nearly 90% of the computation time is spent on the single ECC point multiplication.
Faster ECC implementations (such as tuned-assembly or ASICs) could have a significant impact toward improving the performance of tag verification on the ISP station.Server support In order to measure how many servers can act as decoy destinations, we probed samples of the IPv4 address space as well as the Alexa top million hosts with tests to indicate support for TapDance.
In our first experiment, we tested how long servers would wait to timeout an incomplete request, such as the one used by the client in TapDance.
We scanned TLS servers in a 1% sample of the IPv4 address space, as well as the Alexa top million hosts, and sent listening servers a TLS handshake, followed by an incomplete HTTP request containing the full range of characters used in the TapDance client.
We timed how long each server waited to either respond or close the connection.
Servers that responded immediately do not support the TapDance incomplete request, either because they do not support incomplete requests, or the request contained characters outside the allowed range.
Figure 5 shows the results of this experiment.
For the 20-second timeout used in our implementation, over 80% of servers supported our incomplete request.We also measured how servers handled the out-ofsequence TCP packets sent by the TapDance client, including packets acknowledging data not yet sent by the server.
Again, we used a 1% sample of the IPv4 address space and the Alexa top million hosts.
For each host, we connected to port 80 and sent an incomplete HTTP request, followed by a TCP ACK packet and a data-containing packet, both with acknowledgements set 100 bytes ahead of the true value.
We find that the majority of Alexa servers still allow such packets, however, older or embedded systems often respond to our probes, in violation of the TCP specification.
We conclude that TapDance clients must carefully select which servers they use as end points, but that there is no shortage of candidates from which to select.
The long-term goal of end-to-middle proxies is to be implemented and deployed in a way that effectively combats censorship.
While we have suggested a design that we believe is more feasible than previous work, more engineering must be done to bring it to maturity.For example, deploying an end-to-middle proxy such as TapDance at an ISP requires not only scaling up to meet the demands of proxy users, but also of the deploying ISP's non-proxy traffic, which can be on the order of gigabits per second.
One potential solution to this problem is to make the ISP component as stateless as possible.
Extending TapDance, it may be possible to construct a "single-packet" version of an end-to-middle proxy.
In this version the client uses the ciphertext steganographic channel to encode its entire request to the proxy.
The proxy needs only detect these packets, fetch the requesting page, and inject a response.
Such a design would not need to reconstruct TCP flows or keep state across multiple packets, allowing it to handle higher bandwidths of traffic, at the expense of making active attacks easier to perform by an adversary.
Further investigation may discover an optimal balance between these tradeoffs.Another open research question is where specifically in the network such proxies should be deployed.
Previously, "Routing around Decoys" [40] outlined several novel attacks that a censor could perform in order to circumvent many anticensorship deployment strategies.
There is ongoing discussion in the literature about the practical costs of these attacks, and practical countermeasures deployments could take to protect against them [11,23].
As mentioned in Section 5, traffic fingerprinting is a concern for all proxies, and remains an open problem.
Previous work has discussed these attacks as they apply to ISP-located proxies [40] and other covert channel proxies [18,20].
Future work in this direction could provide insight into how to generate or mimic network traffic and protocols.Finally, there is room to explore more active defense techniques, as outlined in Section 5.
As end-to-middle proxies become more prominent, this is likely to become an important problem, as China has already started to employ active attacks in order to detect and censor Tor bridge relays [13,46,47].
Collaborating with ISPs will allow us to explore the technical capabilities and policies that would permit active defense against these attacks.
Besides end-tomiddle proxies, previous anticensorship approaches, including Collage [10] and Message in a Bottle [24], have leveraged using user-generated content on websites to bootstrap communication between censored users and a centrally-operated proxy.
However, these designs are not intended to work with low-latency applications such as web browsing.
SkypeMorph [30], FreeWave [22], CensorSpoofer [43] and StegoTorus [44] are proxies or proxytransports that attempt to mimic other protocols, such as Skype, VoIP, or HTTP in order to avoid censorship by traffic fingerprinting.
However, recent work appears to suggest that such mimicry may be detectable under certain circumstances by an adversary [18,20].
Finally, browserbased proxies work by running a small flash proxy inside non-censored users browsers (for example, when they visit a website), and serve as short-lived proxies for cen-sored users [17].
These rapidly changing proxies can be difficult for a censor to block in practice, though it is essentially a more fast-paced version of the traditional censor cat-and-mouse game.
Other techniques [3,6,31] leverage pseudorandom public-key encryption (i.e., encryption that produces ciphertext indistinguishable from random bits) in order to solve the classic prisoners' problem.
These techniques allow protocol participants to produce messages that mimic the distribution of an "innocent-looking" communication channel.
The problem setting differs from ours, however, and the encoding of hidden messages inside an allowed encrypted channel (as valid ciphertexts) is not considered.Dyer et al. [16] introduce a related technique called format transforming encryption (FTE), which disguises encrypted application-layer traffic to look like an innocent, allowed protocol from the perspective of deep packet inspection (DPI) technologies.
The basic notion is to transform ciphertexts to match an expected format; as DPI technologies typically use membership in a regular language to classify application-layer traffic, FTE works by using a (bijective) encoding function that maps a ciphertext to a member of a pre-specified language.
This steganographic technique differs significantly from ours, in that we do not attempt to disguise the use of a particular internet protocol itself (i.e., TLS), but rather ensure that our encoded ciphertext does not alter the expected distribution of the selected protocol traffic (i.e., TLS ciphertexts, in our system design).
End-to-middle proxies are a promising concept that may help tilt the balance of power from censors to citizens.
Although previous designs including Telex, Cirripede, and Decoy Routing have laid the ground for this new direction, there are several problems when it comes to deploying any of these designs in practice.
Previous designs have required inline blocking elements and sometimes assumed symmetric network paths.
To address these concerns, we have developed TapDance, a novel end-to-middle proxy that operates without the need for inline flow blocking.
We also described a novel way to support asymmetric flows without inline-flow blocking, by encoding arbitrary-length steganographic payloads in ciphertext.
This covert channel may be independently useful for future E2M schemes and other censorship resistance applications.Ultimately, anticensorship proxies are only useful if they are actually deployed.
We hope that removing these barriers to end-to-middle proxying is a step towards that goal.
The authors thank Joe Adams, Karl Fogel, Derek Harkness, Steven Kent, Michael Milliken, David Robinson, Steve Schultze, Bob Stovall, Stelios Valavanis, and James Vasile for helpful discussions and encouragement.
We also thank Roger Dingledine and the anonymous reviewers.
Eric Wustrow conducted this research as an OpenITP Scholar at the New America Foundation.
This work was supported in part by TerraSwarm, one of six centers of STARnet, a Semiconductor Research Corporation program sponsored by MARCO and DARPA.
This material is based upon work supported by the National Science Foundation under Grant Nos.
CNS-1255153 and CNS-1345254 and by an NSF Graduate Research Fellowship.
