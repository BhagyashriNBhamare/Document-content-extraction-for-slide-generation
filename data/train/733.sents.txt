This paper proposes Facetedpedia, a faceted retrieval system for information discovery and exploration in Wikipedia.
Given the set of Wikipedia articles resulting from a keyword query, Facetedpedia generates a faceted interface for navigating the result articles.
Compared with other faceted retrieval systems, Facetedpedia is fully automatic and dynamic in both facet generation and hierarchy construction , and the facets are based on the rich semantic information from Wikipedia.
The essence of our approach is to build upon the collaborative vocabulary in Wikipedia, more specifically the intensive internal structures (hyperlinks) and folksonomy (category system).
Given the sheer size and complexity of this corpus, the space of possible choices of faceted interfaces is prohibitively large.
We propose metrics for ranking individual facet hierarchies by user's navigational cost, and metrics for ranking interfaces (each with 񮽙 facets) by both their average pairwise similarities and average nav-igational costs.
We thus develop faceted interface discovery algorithms that optimize the ranking metrics.
Our experimental evaluation and user study verify the effectiveness of the system.
Wikipedia has become the largest encyclopedia ever created, with close to 3 million English articles by far.
The prevalent manner in which the Web users access Wikipedia articles is keyword search.
Keyword search has been effective in finding specific Web pages matching the keywords.
Therefore it may well satisfy the users when they are causally interested in a single topic and use Wikipedia as a dictionary or encyclopedia for that topic.
However, Wikipedia has now become a primary knowledge source for many casual users and even an integral component in the knowledge management systems of businesses for decision making.
It is thus typical for a user Copyright is held by the International World Wide Web Conference Committee (IW3C2).
Distribution of these papers is limited to classroom use, and personal use by others.
to explore a set of relevant topics, instead of targeting a particular topic, for more sophisticated information discovery and exploratory tasks.
With only keyword search, one would have to digest the potentially long list of search result articles, follow hyperlinks to connected articles, adjust the query and perform multiple searches, and synthesize information manually.
This procedure is often timeconsuming and error-prone.
One useful mechanism for information exploration is the faceted interface, or the so-called hierarchical faceted categories (HFC) [9].
A faceted interface for a set of objects is a set of category hierarchies, where each hierarchy corresponds to an individual facet (dimension, attribute, property) of the objects.
The user can navigate an individual facet through its hierarchy of categories and ultimately a specific "property" value if necessary, thus reaching those objects associated with the categories and the value on that facet.
The user navigates multiple facets and the intersection of the chosen objects on individual facets are brought to the user's attention.
The procedure hence resembles repeated constructions of conjunctive queries with selection conditions on multiple dimensions.In this paper we propose Facetedpedia 1 , a faceted retrieval system which is capable of dynamically generating query-dependent facets for a set of Wikipedia articles.
We use the following example to further illustrate.
Imagine that a user is exploring information about action films.
The Facetedpedida system takes a keyword query, say, "us action film", as the input and obtains a ranked list of search result articles.
It will create a faceted interface, as shown in Figure 1.
The system dynamically derives 񮽙 facets (region (A)) for covering the top 񮽙 result articles.
For instance, for "us action film", these dimensions (facets) can include Companies, Actors, and so on.
Each facet is associated with a hierarchy of categories.
Each article can be assigned to the nodes in these hierarchies, with each assignment representing an attribute value of the article.
On each facet, the user can navigate through the category path which is formed by parent-child relationships of Wikipedia categories.
2 The interface also shows the navigation paths (region (B)) and article titles (region (C)).
When the user clicks one article title, the corresponding Wikipedia article would be shown.
(This part of the interface is omitted.)
Here in Figure 1 we only show three facets from the generated interface in region (A): (1) Film_production_companies_of_the_United _States; (2) American_film_actors; (3) American_television_actors.
When the user selects any facet items for navigation in region (A), a user navigational path is added in region (B).
Here we show only one path: Films_by_subgenre>Action_films_by_genre>Science_ fiction_action_films, which means the user selected facet root Films_ by_subgenre, then its subcategory Action_films_by_genre, and the subcategory of subcategory, Science_fiction_action_films.
There are thirteen articles satisfying the chosen navigational paths, and they are shown in region (C).
In this way, the user filters the large number of result articles and finds those matching her interests.
We study the problem of dynamic discovery of query-dependent faceted interfaces.
Given the set of top-񮽙 ranked Wikipedia articles as the result of a keyword search query, Facetedpedia produces an interface of multiple facets for exploring the result articles.We focus on automatic and dynamic faceted interfaces.
The facets could not be pre-computed due to the query-dependent nature of the system.
In applications where faceted interfaces are deployed for relational tuples or schema-available objects, the tuples/objects are captured by prescribed schemata with clearly defined dimensions (attributes), therefore a query-independent static faceted interface (either manually or automatically generated) may suffice.
By contrast, the articles in Wikipedia are lacking such predetermined dimensions that could fit all possible dynamic query results.
Therefore efforts on static facets would be futile.
Even if the facets can be pre-computed for some popular queries, say, based on query logs, the computation must be automatic and dynamic.
Given the sheer size and complexity of Wikipedia and its rapid growth, a manual approach would be prohibitively time-consuming and cannot scale to stay up-to-date.
The main challenges in realizing Facetedpedia are summarized as follows: Challenge 1: The facets and their category hierarchies are not readily available.The concept of faceted interface is built upon two pillars: facets (i.e., dimensions or attributes) and the category hierarchy associated with each facet.
The definition of "facet" itself for Wikipedia does not arise automatically, leaving alone the discovery of a faceted interface.
Therefore we must answer two questions: (1) facet identification-What are the facets of a Wikipedia article?
; and (2) hierarchy construction-Where does the category hierarchy of a facet come from?
Challenge 2: We need metrics for measuring the "goodness" of facets both individually and collectively.We need to find facets useful for user navigation.
A goodness metric for ranking the facets is needed.
The problem gets even more complex because the utilities of multiple facets do not necessarily build up linearly-Since the facets in an interface should ideally describe diverse aspects of the result articles, a set of individually "good" facets may not be "good" collectively.
Challenge 3: We must design efficient faceted interface discovery algorithms based on the ranking criteria.It is infeasible to directly apply the ranking metric exhaustively on all possible choices, due to the large search space.
Furthermore, the interactions between the facets in a faceted interface make the computation of its exact cost intractable.
Even computing the costs of individual facets without considering the interactions is nontrivial, given the size and the complexity of Wikipedia.
• Concept: Faceted Wikipedia.
We propose an automatic and dynamic faceted retrieval system for Wikipedia.
To the best of our knowledge, this is the first system of its kind.
The key philosophy of our approach is to exploit collaborative vocabulary as the backbone of faceted interfaces.
• Metrics: Facet Ranking.
Based on a user navigation model, we propose metrics for measuring the "goodness" of facets, both individually and collectively.
(Section 4) • Algorithms: Faceted Interface Discovery.
We develop effective and efficient algorithms for discovering faceted interfaces in the large search space.
(Section 5) • System Evaluation: Facetedpedia.
We conducted user study to evaluate the effectiveness of the system and to compare with alternative approaches.
We also measured its quality and efficiency quantitatively.
(Section 6) Faceted interface has become influential over the last few years and we have seen an explosive growth of interests in its application [11,17,9,17,9,16,6,5,14,15,8,7,3].
Commercial faceted search systems have been adopted by vendors (such as Endeca, IBM, and Mercado), as well as E-commerce Websites (e.g., eBay.com, Amazon.com).
The utility of faceted interfaces was investigated in various studies [11,9,12,17,10,12,13,9], where it was shown that users engaged in exploratory tasks often prefer such result grouping over simple ranked result list (commonly provided by search engines), as well as over alternative ways of organizing retrieval results, such as clustering [4,18,10].
In this section we present taxonomies to characterize the relevant faceted retrieval systems and compare them with Facetedpedia.
Existing research prototypes or commercial faceted retrieval systems mostly cannot be applied to meet our goals, because they either are based on manual or static facet construction, or are for structured records or text collections with prescribed metadata.
Very few have investigated the problem of dynamic discovery of both facet dimensions and their associated category hierarchies.To the best of our knowledge, we are the first to propose a querydependent faceted retrieval system for Wikipedia.
CompleteSearch [2] supports query completions and query refinement in Wikipedia by a special type of "facets" on three dimensions that are very different from our notion of general facets: query completions matching the query terms; category names matching the query terms; and categories of result articles.
Recently, a faceted Wikipedia search interface came out of the DBPedia [1] project around the same time as our work.
The facets there appear to be query-independently extracted from common Wikipedia infobox attributes, although the underlying method remains to be proprietary at this moment.
Previous systems roughly belong to two groups on this aspect.
In some systems the facets are on relational data (e.g., Endeca, Mercado, [15]) or structured attributes in schemata (e.g., [17,7,3]) and the hierarchies on attribute values are predefined based on domainspecific taxonomies.
The hierarchies could even be manually created, thus could contain rich semantic information.
In some other systems a facet is a group of textual terms, over which the hierarchy is built upon thesaurus-based IS-A relationships (e.g., [16]) or frequency-based subsumption relationships between general and specific terms (e.g., [6,5]).
These systems cannot leverage as much semantic information.
The work [8] is in the middle of Figure 2(a) since it has both structured dimensions and a subsumption-based topic taxonomy.In contrast, Facetedpedia enables semantic-rich facet hierarchies (distilled from Wikipedia category system) over text attributes (hyperlinked Wikipedia article titles).
In the absence of predefined schemata, it builds facet hierarchies with abundant semantic information from the collaborative vocabulary, instead of relying on IS-A or subsumption relationships.
When building the two pillars in a faceted interface, namely the facet and the hierarchy, Facetedpedia is both automatic and dynamic, as motivated in Section 1.1.
On this aspect, none of the existing systems could be effectively applied in place of Facetedpedia, because none is fully automatic in both facet identification and hierarchy construction.In some systems (e.g., Endeca, Mercado, [15,3,17,7]) the dimensions and hierarchies are predefined, therefore they do not discover the facets or construct the hierarchy.
In [7,15] a subset of interesting/important facets are automatically selected from the predefined ones.
In [6,5] the set of facets are predefined, but the hierarchies are automatically created based on subsumption.
In [8] only one special facet (a topic taxonomy) is automatically generated and the rest are predefined.With respect to the automation of faceted interface discovery, the closest work to ours is the Castanet algorithm [16].
The algorithm is intended for short textual descriptions with limited vocabularies in a specific domain.
It automatically creates facets from a collection of items (e.g., recipes).
The hierarchies for the multiple facets are obtained by first generating a single taxonomy of terms by IS-A relationships and then removing the root from the taxonomy.
In discovering faceted interfaces for Wikipedia, the basis of our approach is to exploit its user-generated collaborative vocabulary such as the "grassroots" category system.
Even internal Wikipedia hyperlinks are an instance of collaborative vocabulary in a broader sense, as they indicate the users' collaborative endorsement of relationships between entities.
The collaborative vocabulary represents the collective intelligence of many users and rich semantic information, and thus constitutes the promising basis for faceted interfaces.
With regard to the concept of facet dimension, the Wikipedia articles hyperlinked from a search result article are exploited as its attributes.
The fact that the authors of an article collaboratively made hyperlinks to other articles is an indication of the significance of the linked articles in describing the given article.
This view largely enriches the semantic information associated with the result articles.
With regard to the concept of category hierarchy, the Wikipedia category system provides the category-subcategory relationships between categories, allowing users to go from general to specific when specifying conditions.
We now formally define the concepts in our framework and deliver the problem specification.
are the target articles of 񮽙.
Given a target article 񮽙, each Wikipedia article 񮽙 ′ that is hyperlinked from 񮽙 is an attribute article of 񮽙.
This relationship is represented as 񮽙 ′ ← 񮽙.
Given 񮽙 , the set of attribute articles is 񮽙={񮽙 ′ 1 , ..., ′ 񮽙 }, where each 񮽙 ′ 񮽙 is an attribute article of at least one target article 񮽙񮽙∈ .
is a connected, rooted directed acyclic graph ℋ(񮽙ℋ, 񮽙ℋ, ℰℋ), where the node set 񮽙ℋ={񮽙} is the set of categories and the edge set ℰℋ= {񮽙񮽙 ′ } is the set of category(񮽙)-subcategory(񮽙 ′ ) relationships.
The root category of ℋ, 񮽙ℋ, is Category:Fundamental.
3 Definition 3 (Facet): A facet ℱ(, 񮽙ℱ , ℰℱ ) is a rooted and connected subgraph of the category hierarchy ℋ(񮽙ℋ, 񮽙ℋ, ℰℋ), where 񮽙ℱ ⊆ℋ, ℰℱ ⊆ℰℋ, and 񮽙∈ℱ is the root of ℱ.
Figure 3 there are 7 target articles (񮽙1, . . ., 񮽙7) and 9 attribute articles (񮽙 ′ 1 , . . ., 񮽙 ′ 9 ).
The category hierarchy has 14 categories (񮽙1, . . ., 񮽙14).
The figure highlights 6 facets (ℱ1, . . ., ℱ5, and ℱ ′ 2 ).
For instance, 񮽙2 is rooted at 񮽙2 and consists of 3 categories (񮽙2, 񮽙7, 񮽙8) and 2 edges (񮽙2񮽙7, 񮽙2񮽙8).
There are many more facets since every rooted and connected subgraph of the hierarchy is a facet.
Note that the figure may give the impression that edges such as 񮽙11񮽙14 and 񮽙7⇒񮽙 ′ 1 are unnecessary since there is only one choice under 񮽙11 and 񮽙7, respectively.
The example is small due to space limitations.
Such single outgoing edge is very rare in the real Wikipedia category hierarchy.
We will use Figure 3 as the running example throughout the paper.
The categories in the facet can "reach" the target articles 񮽙 through attribute articles 񮽙.
That is, by following the category-subcategory hierarchy of the facet, we could find a category, then find an attribute article belonging to the category, and finally find the target articles that have the attribute.
These target articles are called reachable target articles.
A facet is a safe reaching facet if ∀񮽙∈ℱ , there exists a target article 񮽙∈ such that 񮽙 reaches 񮽙, i.e., there exists 񮽙...⇒񮽙 ′ ←񮽙, a navigational path of ℱ, starting from 񮽙, that reaches 񮽙.
In order to capture the notion of "reach", we formally define navigational path as follows.
Definition 4 (Navigational Path): With respect to the target articles 񮽙 , the attribute articles 񮽙, and a facet ℱ(, 񮽙ℱ , ℰℱ ), a navigational path in ℱ is a sequence 񮽙1...񮽙񮽙⇒񮽙 ′ ←񮽙, where,• for 1≤񮽙≤񮽙, 񮽙񮽙∈ℱ , i.e., 񮽙񮽙 is a category in ℱ;• for 1≤񮽙≤񮽙−1, 񮽙񮽙񮽙񮽙+1∈ℰℱ , i.e., 񮽙񮽙+1 is a subcategory of 񮽙񮽙 (in category hierarchy ℋ) and that category-subcategory relationship is kept in ℱ.
• 񮽙 ′ ∈, and 񮽙񮽙 is a category of 񮽙 ′ (represented as 񮽙񮽙 ⇒ 񮽙 ′ );• 񮽙∈ , and 񮽙 ′ is an attribute article of 񮽙 (i.e., there is a hyperlink 񮽙 → 񮽙 ′ ).3 http://en.wikipedia.org/wiki/Category:Fundamental Given a navigational path 񮽙1...񮽙񮽙⇒񮽙 ′ ←񮽙, we say that the corresponding category path 񮽙1...񮽙񮽙 reaches target article 񮽙 through attribute article 񮽙 ′ , and we also say that category 񮽙񮽙 (for any 1≤񮽙≤񮽙) reaches 񮽙 through 񮽙 ′ .
Interchangeably we say 񮽙 is reachable from 񮽙񮽙 (for any 1≤񮽙≤񮽙).
Given a keyword query 񮽙, a faceted interface 񮽙={ℱ񮽙} is a set of safe reaching facets of the target articles 񮽙 .
That is, ∀ℱ񮽙∈񮽙, ℱ񮽙 safely reaches 񮽙 .
Continue the running example.
In Figure 3, 񮽙={ℱ2, ℱ5} is a 2-facet interface.
Two examples of navigational paths are 񮽙2񮽙8⇒񮽙 ′ 3 ←񮽙5 and 񮽙5񮽙13⇒񮽙 ′ 9 ←񮽙5.
However, {ℱ ′ 2 , ℱ5} is not a valid faceted interface because ℱ ′ 2 is not a safe reaching facet, as category 񮽙6 cannot reach any target articles.Based on the formal definitions, the Faceted Interface Discovery Problem is: Given the category hierarchy ℋ(񮽙ℋ, 񮽙ℋ, ℰℋ), for a keyword query 񮽙 and its resulting target articles 񮽙 and corresponding attribute articles 񮽙, find the "best" faceted interface with 񮽙 facets.
We shall develop the notion of "best" in Section 4.
The search space of the faceted interface discovery problem is prohibitively large.
Given the set of 񮽙 target Wikipedia articles to a keyword query, 񮽙 , there are a large number of attribute articles which in turn have many categories associated with complex hierarchical relationships.
To just give a sense of the scale, in Wikipedia there are about 3 million English articles with hundreds of millions of internal links.
The category system ℋ contains close to half a million categories and several million category-subcategory relationships.
By definition, any rooted and connected subgraph of ℋ that safely reaches 񮽙 is a candidate facet, and any combination of 񮽙 facets would be a candidate faceted interface.
Given the large space, we need ranking metrics for measuring the "goodness" of facets, both individually and collectively as interfaces.Given that a faceted interface is for a user to navigate through the associated category hierarchies and ultimately reaching the target articles, it is natural to rank the interfaces by the user's navigational cost, i.e., the amount of effort undertaken by the user during navigation.
4 The "best" 񮽙-facet interface is the one with the smallest cost.
Therefore as the basis of such ranking metrics, we model users' navigational behaviors as follows.User Navigation Model: A user navigates multiple facets in a 񮽙-facet interface.
At the beginning, the navigation starts from the roots of all the 񮽙 facets.
At each step, the user picks one facet and examines the set of subcategories available at the current category on that facet.
She follows one subcategory to further go down the category hierarchy.
Alternatively the user may select one of the attribute articles reachable from the current category.
The selections made on the 񮽙 facets together form a conjunctive query.
After the selection at each step, the list of target articles that satisfy the conjunctive query are brought to the user.
The navigation terminates when the user decides that she has seen desirable target articles.Example 4 (Navigation in Faceted Interface): Continue the running example in Figure 3.
Consider a faceted interface 񮽙={ℱ2, ℱ5}.
A sequence of navigational steps on this interface are in Figure 4.
At the beginning, the user has not selected any facet to explore, therefore all 7 target articles are available (step 1).
Once the user decides to explore ℱ2 which starts from 񮽙2, 񮽙7 is filtered out since it is unreachable from ℱ2 (step 2).
The user then selects 񮽙5, whichStep 1Step 2 Step 5 further removes 񮽙3 from consideration (step 3).
After the user further explores ℱ2 by choosing 񮽙8 (step 4), 񮽙11 is not a choice under 񮽙5 anymore because no target articles could be reached by both 񮽙2񮽙8 and 񮽙5񮽙11.
The user continues to explore ℱ5 by choosing 񮽙13 (step 5), which removes 񮽙 ′ 2 and also trims down the satisfactory target articles to {񮽙5}.
The user may decide she has seen desirable articles and the navigation stops.
In this section we focus on how to measure the costs of facets individually.
Based on the navigational model, we compute the navigational cost of a facet as the average cost of its navigational paths.
Intuitively a low-cost path, i.e., a path that demands small user effort, should have a small number of steps and at each step only require the user to browse a small number of choices.
Therefore, we formally define the cost of a navigational path as the summation of the fan-outs (i.e., the number of choices) at every step, in logarithmic form.
5 With respect to the target articles 񮽙 , the corresponding attribute articles 񮽙, and a facet ℱ(, 񮽙ℱ , ℰℱ ), the cost of a navigational path in ℱ is(񮽙) = 2 ( (񮽙 ′ )) + 񮽙 񮽙∈{񮽙 1 ,...,񮽙} 2 ( (񮽙))(1)where 񮽙=񮽙1...񮽙񮽙⇒񮽙 ′ ←񮽙.
In Formula 1, (񮽙 ′ ) is the number of (directly) reachable target articles through the attribute article 񮽙 ′ ,(񮽙 ′ ) = | 񮽙 ′ |(2)񮽙 񮽙 ′ = {񮽙|񮽙 ∈ ∧ 񮽙 → 񮽙 ′ (i.e., ∃ a hyperlink from 񮽙 to 񮽙 ′ )} (3)In Formula 1, (񮽙) is the fanout of category 񮽙 in ℱ,(񮽙) = |񮽙| + |񮽙| (4)where 񮽙񮽙 is the set of attribute articles belonging to 񮽙,񮽙񮽙 = {񮽙 ′ |񮽙 ′ ∈ ∧ 񮽙 ⇒ 񮽙 ′ }(5)and 񮽙񮽙 is the set of subcategories of 񮽙 in ℱ,񮽙񮽙 = {񮽙 ′ |񮽙 ′ ∈ ℱ ∧ 񮽙 񮽙 ′ ∈ ℰ ℱ }(6)Note that we made several assumptions for simplicity of the model.
The cost formula only captures the "browsing" cost.
A full-fledged formula would need to incorporate other costs, such as the "clicking" cost in selecting a choice and the cost of "backward" navigation when the user decides to change a previous selection.
Furthermore, we assume the user always completes the navigational path till reaching the target articles.
In reality, however, the user may stop in the middle when she already finds desirable articles reachable from the current selection of category.
We leave the investigation of more sophisticated models to future study.
5 The intuition behind the logarithmic form is: When presented with a number of choices, the user does not necessarily scan through the choices linearly but by a binary search.
We continue the running example.
Given 񮽙=񮽙5񮽙12⇒񮽙 ′ 8 ←񮽙6, a navigational path of ℱ5 in Figure 3,(񮽙)= (񮽙5)+ (񮽙12)+ (񮽙 ′ 8 ) =2(3)+2(2)+2(3)=4.17.
Albeit the basis of our facet ranking metrics, the definition of navigational cost is not sufficient in measuring the goodness of a facet.
It does not consider such a scenario that a facet cannot fully reach all the target articles, which presents an unsatisfactory user experience.
In fact, low-cost and high-coverage could be two qualities that compete with each other.
On the one hand, a low-cost facet could be one that reaches only a small portion of the target articles.
On the other hand, a comprehensive facet with high coverage may tend to be wider and deeper, thus more costly.
Therefore we must incorporate into the cost formula the notion of "coverage", i.e., the ability of a facet to reach as many target articles as possible.
To combine navigational cost with coverage, we penalize a facet by associating a high-cost pseudo path with each unreachable article.
We then define the cost of a facet as the average cost in reaching each target article.
With respect to the target articles 񮽙 , the cost of a safe reaching facet ℱ(, 񮽙ℱ , ℰℱ ), (ℱ񮽙), is the average cost in reaching each target article.
The cost for a reachable target article is the average cost of the navigational paths that start from 񮽙 and reach the target, and the cost for an unreachable target is a pseudo cost .
(ℱ񮽙) = 1 | | × ( 񮽙 񮽙∈񮽙 (ℱ񮽙, ) + × | − 񮽙|)(7)where (ℱ񮽙, ) is the average cost of reaching 񮽙 from 񮽙,(ℱ񮽙, ) = 1 |񮽙񮽙| × 񮽙 񮽙∈񮽙񮽙 (񮽙)(8)where 񮽙񮽙 is the set of navigational paths in ℱ that reach 񮽙 from 񮽙,񮽙񮽙 = {񮽙|񮽙 = 񮽙 ... ⇒ 񮽙 ′ ← 񮽙}(9)In Formula 7, is the cost of the aforementioned expensive pseudo path that "reaches" the unreachable target articles, i.e., −񮽙, for penalizing a facet for not reaching them.
Its value is empirically selected (Section 6) and is at least larger than the highest cost of any path to a reachable target article.
( 񮽙 񮽙∈{񮽙 1 , 2 , 3 , 4 , 5 , 6 } (ℱ2, ) +×| −ℱ 2 |)= 1 7 ×(16+7×1)=3.286.
ℱ2 and ℱ5 achieve lower costs than other facets.
Even though the paths in ℱ4 are cheap, ℱ4 has higher cost due to the penalty for unreachable target articles (񮽙6 and 񮽙7).
ℱ1 is even more costly due to its wider and deeper hierarchy, although it reaches all target articles.
Figure 6: The sequences of navigational steps.
Even with the cost metrics for individual facets, measuring the "goodness" of a faceted interface, i.e., a set of facets, is not straightforward.
This is because the best 񮽙-facet interface may not be simply the cheapest 񮽙 facets.
The reason is that when the user navigates multiple facets, the selection made at one facet has impact on the available choices on other facets, as illustrated by Example 4.
To directly follow the approach of ranking faceted interfaces by navigational cost, in principle we could represent the navigational steps on multiple facets as if the navigation is on one "integrated" facet.
To illustrate, consider the navigation on a 2-facet interface ℐ={ℱ2, ℱ5} from Figure 3.
Two possible sequences of navigational steps are shown in Figure 6(a).
One is 񮽙2, 񮽙5, 񮽙8, 񮽙13, 񮽙 ′ 9 , 񮽙 ′ 3 , 񮽙5, which are the steps taken by the user in Figure 4, followed by choosing 񮽙 ′ 9 , 񮽙 ′ 3 , and finally 񮽙5.
(Remember, for simplification of the model, we assumed that the user will always complete navigational paths till reaching the target articles.)
At each step, the available choices from both facets are put together as the choices in the "integrated" facet.
Note that after 񮽙8 is chosen, 񮽙12 and 񮽙13 are still valid choices but 񮽙11 is not available anymore because 񮽙11 cannot reach the target articles that 񮽙8 reaches.
For the same reason, after 񮽙13 is chosen, 񮽙 ′ 3 is still a valid choice but 񮽙 ′ 2 is not anymore.
The other highlighted sequence is 񮽙5, 񮽙11, 񮽙2, 񮽙7, 񮽙 ′ 1 , 񮽙14, 񮽙 ′ 6 , 񮽙1.
There are many more possible sequences not shown in the figure due to space limitations.With the concept of "integrated" facet, one may immediately apply Definition 7 to define the cost of a faceted interface.
That entails computing all possible sequences of interleaving navigational steps across all the facets in the interface.
The interaction between facets is query-and data-dependent, rendering such exhaustive computation practically infeasible.
However, the "integrated" facet does shed light on what are the characteristics of good faceted interfaces.
In general an interface should not include two facets that overlap much.
Imagine a special case when two facets form a subsumption relationship, i.e., the root of one facet is a supercategory of the other root.
Presenting both facets would not be desirable since they overlap significantly, thus cannot capture the expected properties of reaching target articles through different dimensions.
As a concrete example, consider the navigational steps of ℱ2 and ℱ3 in Figure 6(b).
After the user selects 񮽙2 from ℱ2 and then 񮽙3 from ℱ3, the available choices become {񮽙7, 8, 9}, which all come from the "dimension", ℱ3.
The same happens if the user selects 񮽙3 and then 񮽙2.
Based on the above observation, we propose to capture the overlap of the 񮽙 facets by their average pair-wise similarity.
The pairwise similarity of two facets is the degree of overlap of their category hierarchies and associated attribute articles, defined below.
The average pair-wise similarity of a 񮽙-facet interface is(ℐ = {ℱ 1 , ..., ℱ 񮽙 }) = 񮽙 1≤<≤񮽙 (ℱ 񮽙 , ℱ 񮽙 ) 񮽙(񮽙 − 1)/2 ,(10)where (ℱ񮽙, ℱ񮽙 ) is defined by the Jaccard coefficient,(ℱ 񮽙 , ℱ 񮽙 ) = | ℱ 񮽙 񮽙 񮽙 ℱ 񮽙 | + | ℱ 񮽙 񮽙 񮽙 ℱ 񮽙 | | ℱ 񮽙 񮽙 񮽙 ℱ 񮽙 | + | ℱ 񮽙 񮽙 񮽙 ℱ 񮽙 |(11)where 񮽙ℱ 񮽙 is the set of categories in ℱ񮽙 (Definition 3) and 񮽙ℱ 񮽙 is the set of attribute articles reachable from ℱ񮽙,񮽙 ℱ 񮽙 = {񮽙 ′ |񮽙 ′ ∈ ∧ ∃񮽙 ∈ ℱ 񮽙 .
.
⇒ 񮽙 ′ }(12)We choose Jaccard coefficient since it is one of the simplest setsimilarity measures.
While more complex measures that give different weights to nodes higher in the hierarchy are possible, we do not follow that in the interest of simplicity.
Consider facets ℱ1, . . ., ℱ5 in Figure 3.
(ℱ2, ℱ3)= | ℱ 2 񮽙 񮽙 ℱ 3 |+| ℱ 2 񮽙 񮽙 ℱ 3 | | ℱ 2 񮽙 񮽙 ℱ 3 |+| ℱ 2 񮽙 񮽙 ℱ 3 | = |{񮽙 7 , 8 }|+|{񮽙 ′ 1 , ′ 2 , ′ 3 }| |{񮽙 2 , 7 , 8 , 3 , 9 }|+|{񮽙 ′ 1 , ′ 2 , ′ 3 , ′ 4 }| =5/9.
Other pair-wise similarities can be computed in the same way.
The average pari-wise similarity of ℐ={ℱ2, ℱ3, ℱ5} is (ℐ) = ((ℱ2, ℱ3) + (ℱ2, ℱ5) + (ℱ3, ℱ5))/3 = 5/27.
We do not design a single function to combine the average pairwise similarity of a faceted interface with its navigational cost, since they represent two measures with different natures.
Instead, in Section 5.3 we discuss how to search the space of candidate interfaces by considering both measures.
A straightforward approach for faceted interface discovery is to enumerate all possible 񮽙-facet interfaces with respect to the category hierarchy ℋ and apply the ranking metrics directly to find the best interface.
Such a naïve method results in the exhaustive examination of all possible combinations of 񮽙 instances of all possible facets, i.e., rooted and connected subgraphs of ℋ.
Clearly it is a prohibitively large search space, given the sheer size and complexity of Wikipedia.
The naïve technique would be extremely costly.
Therefore finding the best 񮽙-facet interface is a challenging optimization problem.Our 񮽙-facet discovery algorithm hinges on (1) reducing the search space; and (2) searching the space effectively and efficiently.Reducing the Search Space: There are two search spaces in finding a good 񮽙-facet interface: the space of facets and the space of 񮽙-facet interfaces, which are sets of 񮽙 facets.
To reduce the space of candidate facets, we focus on a subset of the safe reaching facets, ℛℋ-induced facets, which are the facets that contain all the descendant categories of their roots (Section 5.1).
To further reduce the space of faceted interfaces, we rank the facets individually by their navigational costs (Section 5.2) and only consider the top ranked facets that do not subsume each other (Section 5.3).
Searching the Space: Instead of exhaustively examining all possible interfaces, we design a hill-climbing based heuristic algorithm to look for a local optimum (Section 5.3).
To further tackle the challenge of modeling the interactions of multiple facets in measuring the cost of an interface, the hill climbing algorithm optimizes for both the average navigational cost and the pair-wise similarity of the facets.Our 񮽙-facet discovery algorithm is outlined as three steps: construction of relevant category hierarchy, ranking single facet, and searching for k-facet interface.
By Definition 5, the facets in a faceted interface must be safe reaching facets, i.e., they do not contain "dead end" categories that cannot reach any target articles.
Therefore the categories appearing in any safe reaching facet could only come from the relevant category hierarchy (ℛℋ), which is a subgraph of the Wikipedia category hierarchy ℋ, defined below.
Given the category hierarchy ℋ(񮽙ℋ, 񮽙ℋ, ℰℋ), the target articles 񮽙 , and the attribute articles 񮽙, the relevant category hierarchy (ℛℋ) of 񮽙 is a subgraph of ℋ.
Given any category in ℛℋ, it is either directly a category of some attribute article 񮽙 ′ ∈ or a supercategory or ancestor of such categories.
There exists an edge (category-subcategory relationship) between two categories in ℛℋ if the same edge exists in ℋ.
By this definition the root of ℋ is also the root of ℛℋ.The procedural algorithm for getting ℛℋ is in Algorithm 1.
Based on definition, straightforwardly we could prove every safe reaching facet of the target articles 񮽙 is a (rooted and connected) subgraph of ℛℋ.
However, not every rooted and connected subgraph of ℛℋ is a safe reaching facet.
Therefore, even though ℛℋ is much smaller than ℋ, the search space is still very large which needs us to further shrink the space by considering only one type of safe reaching facets, the ℛℋ-induced facets.Definition 10 (-Induced Facet): Given the relevant category hierarchy ℛℋ of the target articles 񮽙 , a facet ℱ(񮽙, 񮽙ℱ ,ℰℱ ) is ℛℋ-induced if it is a rooted induced subgraph of ℛℋ, i.e., in ℱ all the descendants of the root 񮽙 and their category-subcategory relationships are retained from ℛℋ.Example 8 ( and -Induced Facet): Continue the running example.
In Figure 3, the ℛℋ contains all the categories in the category hierarchy ℋ except 񮽙6 (and thus the edge 񮽙2񮽙6), since 񮽙6 cannot reach any target article.
ℱ2 is an ℛℋ-induced facet, but would not be if it does not contain 񮽙7 (or 񮽙8).
Note that every ℛℋ-induced facet is safe reaching, and the single-facet ranking and searching for k-facet are performed on it.
Among all the ℛℋ-induced facets, only the top 񮽙 facets with the smallest navigational costs are considered in searching for a faceted interface.
In ranking the facets by their costs, one straightforward approach is to enumerate all the ℛℋ-induced facets and to separately compute the cost of each facet by enumerating all of its navigational paths.
This approach is exponentially complex due to repeated traversal of the edges in ℛℋ, because the ℛℋ-induced facets would have many common categories and categorysubcategory relationships.To avoid the costly exhaustive method, we design a recursive algorithm that calculates the navigational costs of all the ℛℋ-induced facets by only one pass depth-first search of ℛℋ.
The details are in Algorithm 2.
The essence of the algorithm is to, foreach 񮽙 ′ ∈ do 1 񮽙 񮽙 ′ ← {񮽙|񮽙 ∈ ∧ ∃ 񮽙 → 񮽙 ′ (hyperlink from 񮽙 to 񮽙 ′ ) } 2 (񮽙 ′ ) ← | 񮽙 ′ | 3initialize (񮽙) to be for every 񮽙 ∈ ℛℋ.
(񮽙ℋ) // recursively compute the costs of all 5 the ℛℋ-induced facets, starting from the root of ℛℋ.
ℐ񮽙← the top 񮽙 ℛℋ-induced facets with the smallest costs.
during the recursive traversal of ℛℋ, book-keep the number of navigational paths in a facet in addition to its navigational cost.
The bookkeeping is performed for each reachable target article because the cost is averaged across all such articles by Definition 7.
The cost of a facet rooted at 񮽙 can be fully computed based on the book-keeped information of the facets rooted at 񮽙's direct subcategories, without accumulating the individual costs of the facets rooted at 񮽙's descendants.
Therefore it avoids the aforementioned repeated traversal of ℛℋ.
More specifically, the lines 11-14 in Algorithm 3 are for computing (ℱ񮽙, ) in Formula 7.
However, the algorithm does not compute it by a direct translation of Formula 8 and 1, i.e., enumerating all the navigational paths that reach 񮽙.
Instead, line 12 gets 1, the total cost of all the navigational paths 񮽙⇒񮽙 ′ ←񮽙, i.e., the ones that reach 񮽙 without going through any other categories; line 13 computes 2, the total cost of all the navigational paths that go through other categories, by utilizing (ℱ񮽙, ) and ℎ(ℱ񮽙, ) of the subcategories 񮽙, but not other descendants.
We omit the formal correctness proof.
Algorithm 4 searches for 񮽙-facet interface.
To reduce the search space, our algorithm only considers ℐ񮽙, the top 񮽙 facets from Algorithm 2.
We further reduce the space by excluding those top ranked 7 (񮽙)← |񮽙| + |񮽙| 8 񮽙񮽙← (∪ 񮽙 ′ ∈񮽙 񮽙 񮽙 ′ ) 񮽙 (∪񮽙∈ 񮽙 񮽙񮽙) // reachable target articles.
9 foreach 񮽙 ∈ 񮽙 do 10 ℎ(ℱ񮽙, )← 11 |{񮽙 ′ |񮽙 ′ ∈񮽙,∈ 񮽙 ′ }|+ 񮽙 񮽙∈񮽙 ℎ(ℱ񮽙, ) 1← 12 񮽙 񮽙 ′ ∈񮽙 .
.
∈ 񮽙 ′ (2( (񮽙)) + 2( (񮽙 ′ ))) 2← 13 񮽙 񮽙∈񮽙 (2( (񮽙))+(ℱ񮽙, ))×ℎ(ℱ񮽙, ) (ℱ񮽙, )← 1 + 2 ℎ(ℱ񮽙 ,) 14 (ℱ񮽙)← 񮽙 񮽙∈񮽙 (ℱ񮽙, )+×| − 񮽙| 15 return 16facets that are subsumed by other top facets (line 1).
In other words, we only keep ℐ 񮽙 − , the maximal antichain of ℐ񮽙 based on the graph (category hierarchy) subsumption relationship.
This is in line with the idea of avoiding large overlap between facets (Section 4.2).
Given ℐ 񮽙 − , instead of exhaustively considering all possible 񮽙-element subsets of ℐ 񮽙 − , we apply a hill-climbing method to search for a local optimum, starting from a random 񮽙-facet interface ℐ 񮽙 .
At every step, we try to find a better neighboring solution, where a 񮽙-facet interface ℐ is a neighbor of ℐ 񮽙 if they only differ by one facet (line 9).
Given the 񮽙×(񮽙−񮽙) possible neighbors at every step, we examine them in the order of average navigational costs (line 5, 6, and 9).
The algorithm jumps to the first encountered better neighbor.
The algorithm stops when no better neighbor can be found.
As the goal function to be optimized in hill-climbing, ℐ is considered better if the facets of ℐ have both smaller pair-wise similarities and smaller navigational costs than that of ℐ 񮽙 (line 14).
The idea of considering both similarity and cost is motivated in Section 4.2.
Facetedpedia is implemented in C++ and the dataset is stored in a MySQL database.
The experiments are executed on a Dell PowerEdge 2900 III server running Linux kernel 2.6.27, with dual quad-core Xeon 2.0 GHz processors, 2x6MB cache, 8GB RAM, and three 1TB SATA hard drivers in RAID5.Dataset: We downloaded the Wikipedia dump of July 24, 2008 from http://download.wikimedia.org and loaded the data into a MySQL database.
In particular, we used the tables page.sql, pagelinks.sql, categorylinks.sql, and redirect.sql, which provide all the relevant data including the hyperlinks between articles, categories of articles, and the category system.
We performed several preprocessing tasks on the tables, including the detection and removal of cycles in the category hierarchy.
Although cycles should usually be avoided as suggested by Wikipedia, the category system in Wikipedia contains a very small number (594 in the dataset) of elementary cycles 6 due to various reasons.
We applied depth-first search algorithm to detect the elementary cycles.
The category hierarchy is made acyclic by removing the last encountered edge in each elementary cycle during the depth-first search.
Other performed preprocessing steps include: removing tuples irrelevant to articles and categories; replacing redirect articles by their original articles; removing special articles such as lists and stubs.
We also applied basic performance tuning of the database, including creating additional indexes on page_id in various tables.
The characteristics of the dataset are summarized in Figure 7.
The total size of the tables is 1.2GB.Queries: We experimented with 20 keyword queries that we designed (Figure 8), in addition to the open queries that the users came up with during user study (Section 6.2).
Parameters in algorithms: Each query was sent to Google with site constraint site:en.wikipedia.org to get the top 200 (񮽙=200) English Wikipedia target articles.
The relevant category hierarchy ℛℋ was then generated by applying Algorithm 1 on the aforementioned MySQL database.
By default, Algorithm 2 returns top 200 (񮽙=200) facets and Algorithm 4 generates 10 facets (񮽙=10).
The value of in Definition 7 was set as 7.
It was empirically selected by investigating the relationship between the number of unreachable target articles (| − 񮽙|) and the total navigational costs of reachable targets ( 񮽙 񮽙∈񮽙 (ℱ񮽙, )).
We conducted user studies to evaluate the effectiveness of Facetedpedia, and to compare the quality of the faceted interfaces gener- ated by Facetedpedia and Castanet [16].
We obtained the implementation of Castanet from its authors.
Note that Castanet is intended for static, short, and domain-specific documents with limited vocabularies.
Nevertheless, we applied Castanet on the dynamic keyword search results.
Although not originally designed for such purposes, Castanet still appears to be possibly the closest related work.
We use the same graphical user interface for both systems, to make the comparison irrelevant to interface design.
The user studies were conducted online.
The users all have college degrees or are in college, including university students, faculty, staff, and financial and IT company workers.
We believe these users are experienced with Web search and comfortable with more sophisticated access mechanisms, matching the target users of our system.
To reduce the overhead of the user, we partitioned the 20 queries in Figure 8 into 4 equal-size groups and asked each user to only participate in the 5 queries of one group.
For each query group, we sent user-study invitations to roughly equal number of people.
Ultimately we were able to collect opinions from totally 36 users, 8 each for 2 groups, and 10 each for the other 2 groups.For each query, we showed the query keywords and objective description to the user, and asked the user to explore two interfaces pre-generated by Facetedpedia and Castanet, respectively.
At the end of each query, the user was asked to provide response to 3 questions, namely 񮽙1-񮽙3 in Figure 9.
The available choices for 񮽙1 and 񮽙2 are ratings from 1:"useless" to 5:"very useful".
The choices for 񮽙3 are "Facetedpedia" and "Castanet".
The same process iterated through the 5 queries in the group assigned to the user.
After the 5 queries were done, the user was also provided opportunity to try arbitrary open queries on Facetedpedia, and provided answers to questions 񮽙4-񮽙6 in Figure 9.
The available choices are ratings from 1:"strongly disagree" to 5:"strongly agree".
The same open query study, however, was not possible for Castanet because the implementation we obtained from the authors takes about 5 minutes to process each query and therefore could not be used for dynamic queries.
The reason is that it checks WordNet for each word in constructing category hierarchy.
(Remember it was designed for static collection of short texts.)
In Figure 10, column 2 and column 3 records average user ratings per query on questions 񮽙1 and 񮽙2 respectively.
Column 4 and 5 represent user's absolute preference on one system over the other.
Clearly, from the results, Facetedpedia receives much stronger feedback than Castanet on 񮽙1 and 񮽙2.
Also, for absolute preference, user prefers Facetedpedia over Castanet almost unanimously.
FigChoices-1: useless; 2: not very useful; 3: useful to some extent; 4: useful; 5: very useful R1 My rating about usefulness of Facetedpedia.
R2 My rating about usefulness of Castanet.Choices-Facetedpedia; Castanet R3 Which interface is better than the other?
Choices-1: strongly disagree; 2: disagree; 3: neutral; 4: agree; 5: strongly agree R4 The facets in Facetedpedia conveys important concepts regarding the articles related to the query.
R5 Facetedpedia is useful for browsing and exploration purposes.
R6 I look forward to use this interface even in the future for exploratory browsing purposes.
Figure 10: Usefulness of Facetedpedia and Castanet.ure 11 records average user ratings per group for 񮽙4, 񮽙5 and 񮽙6.
As it can be seen, majority of the groups provide strong positive opinion the about usefulness of facets and the interface generated by Facetedpedia and they believe Facetedpedia interface is effective for exploration purposes.
Our experiments compared the effectiveness of three algorithms: hill-climbing (Algorithm 4), top-񮽙-selecting the top 񮽙 facets ranked by Algorithm 2, and random-񮽙-randomly choosing 񮽙 facets.
Fig- ure 13 shows the average characteristics of the faceted interfaces generated by these methods.
Although hill-climbing had a slightly worse target article coverage than the other two (5% less), it outperformed them in pair-wise similarity which means the 񮽙 facets selected have smaller overlap of navigational paths.
The detailed tracing results show that hill-climbing started from choosing top-񮽙 facets and gradually replaced similar facets by less similar ones.
The final 񮽙 facets selected by hill-climbing usually were still within the top 30%, while the ones selected by random-񮽙 were evenly distributed among the results from single-facet ranking.
The average width and height of the facets generated by the three methods were about the same, except that random-񮽙 occasionally chose some much wider facets.
Their average width and height were usually around 10 and 6, respectively.
Therefore the fanout of internal nodes and the length of navigational paths are within a reasonable range for the users.
Overall, hill-climbing helps us reducing overlapping facets without losing much coverage of target articles.
We evaluated the scalability of our approach by measuring the average execution time of discovering 񮽙=10 facets for varying number of target articles (񮽙 from 50 to 500).
As can be seen from Figure 12, Facetedpedia scales well since the execution time increases linearly by the number of target articles.
It also shows that Facetedpedia already achieved fairly fast response without much performance optimization.
In average it took 3 seconds to discover the facets for 50 target articles, and 5 seconds for 200 target articles.
The faceted interfaces generated by Facetedpedia are certainly not perfect and could be improved on many aspects.
The pitfalls and drawbacks of our system pose several open challenges which could possibly form new research directions.
It is our plan to forward our investigation along the following lines:First, hyperlinks in Wikipedia articles are not always good features of the target articles.
In many cases the hyperlinked articles are important attribute articles that are strongly related to the target articles.
However, there are also cases in which the authors of an article make hyperlinks to other articles not because they have strong relationships with the target articles.
The author may believe that the readers would not be familiar with an entity mentioned in an article, therefore decides to make that mention an anchor text linking to the article describing the entity.
The hyperlinked article is not necessarily highly related to the target article.
For example, in Wikipedia article Independence_Day_(film), hyperlinked articles such as Will_Smith and 20th_Century_Fox are certainly valid attribute articles, while Moon and Mexico may not be.
To assure the quality of the discovered facets, we plan to investigate data mining methods and NLP techniques in finding truly related articles.Second, we found through experiments that a category hierarchy based on both rich semantics and strong IS-A relationships will provide more accurate facets than the current Wikipedia category system.
This "grass-roots" folksonomy in Wikipedia, albeit containing user-generated categories with richer semantics than a thesaurus such as WordNet , is not always organized by rigorous IS-A relationships.
For instance, it includes subcategories such as People_from_Texas and History_of_Texas under category Texas, which can be misleading to a user who plans to navigate through geographical concepts by choosing Texas.
We plan to refine the category hierarchy for strong IS-A relationships.Third, we need to design methods to improve the diversity of the top ranked facets generated by Facetedpedia.
Since our ranking metric penalizes the facets that have small coverage, the top ranked ones may tend to come from relatively large concept domains such as people, organizations, etc.
To avoid missing useful facets from small concept domains, one idea is to first cluster the attribute articles into several groups and then make sure that each group has at least a number of facets in the final results.
In this paper we proposed Facetedpedia, a faceted search system over Wikipedia.
This system provides a dynamic and automated faceted search interface for users to browse the articles that are the result of a keyword search query.
Given the sheer size and complexity of Wikipedia and the large space of possible faceted interfaces, we proposed metrics for ranking faceted interfaces as well as efficient algorithms for discovering them.
Our experimental evaluation and user study verify the effectiveness of our methods in generating useful faceted interfaces.
Moreover, our findings pose several open problems for future study.
It would also be interesting to further investigate if the proposed framework and methods can be applied to other applications, or even the generic Web.
