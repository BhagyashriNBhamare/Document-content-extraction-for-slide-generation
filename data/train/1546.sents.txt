We present techniques for privacy-preserving computation of mul-tidimensional aggregates on data partitioned across multiple clients.
Data from different clients is perturbed (randomized) in order to preserve privacy before it is integrated at the server.
We develop formal notions of privacy obtained from data perturbation and show that our perturbation provides guarantees against privacy breaches.We develop and analyze algorithms for reconstructing counts of sub-cubes over perturbed data.
We also evaluate the tradeoff between privacy guarantees and reconstruction accuracy and show the prac-ticality of our approach.
On-line analytical processing (OLAP) is a key technology employed in business-intelligence systems.
The computation of multidimensional aggregates is the essence of on-line analytical processing.
We present techniques for computing multidimensional count aggregates in a privacy-preserving way.We consider a setting in which clients C 1 , C 2 , . . . C n are connected to a server S .
The server has a We take the randomization approach to preserving privacy.
The basic idea is that every client C i perturbs its row r i before sending it to the server S .
The randomness used in perturbing the values ensures information-theoretic row-level privacy.
Figure 1 gives the * Supported in part by NSF Grant ITR-0331640Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage, and that copies bear this notice and the full citation on the first page.
To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.
SIGMOD 2005June 14-16, 2005 schematic of our approach.
S runs queries on the resultant perturbed table T ′ .
The query meant for the original table T is translated into a set of queries on the perturbed table T ′ .
The answers to these queries are then reconstructed to obtain the result to the original query with bounded error.
We show that our techniques are safe against privacy breaches.
The perturbation algorithm is publicly known; the actual random numbers used in the perturbation, however, are hidden.
To allow clients to operate independently, we use local perturbations so that the perturbed value of a data element depends only on its initial value and not on those of the other data elements.
Different columns of a row are perturbed independently.
We use retention replacement schemes where an element is decided to be retained with probability p or replaced with an element selected from a probability distribution function (p.d.f.) on the domain of elements.The proposed techniques can also be used for database tables in which some of the columns are categorical.
They are also applicable in the settings in which the database tables are partitioned horizontally or vertically.The organization of the rest of the paper is as follows.
We start off with a discussion of related work in Section 2.
Section 3 formally defines the retention replacement perturbation.
Section 4 presents the reconstruction algorithms.
Section 5 presents the guarantees against privacy breaches offered by our techniques.
In Section 6, we discuss how our techniques can be extended to categorical data.
We also discuss some additional perturbation techniques and describe how our techniques can be used in data mining by showing how to build a decision tree classifier.
Section 7 presents an empirical evaluation of our techniques.
We conclude with a summary and directions for future work in Section 8.
The proofs of our results have been collected in the Appendix.
The techniques for preserving privacy while answering statistical queries developed in the statistical database literature can be classified into query restriction, input perturbation and output perturbation [1].
Both query restriction and output perturbation are applicable when the entire original unperturbed data is available in a single central repository, which is not true in our setting, where clients randomize their data before providing it to the server.
Our scenario fits in the framework of input perturbation, where the goal is to create a version of the database that can be publicly released (e.g. census data), yet the individual rows should not be recoverable.
Local perturbation for a single column has been studied in [24].
However most previous work (e.g., [20]) assume that during perturbation the entire database is available at a single site, while we require local perturbations at each client.The use of local perturbation techniques to preserve privacy of individual rows while allowing the computation of data mining models at the aggregate level was proposed in [4].
They used an additive perturbation technique, in which a random perturbation is added to the original value of the row, where the perturbation is picked from another probability distribution function (e.g. Gaussian).
They showed that it was possible to build accurate decision tree classification models on the perturbed data.However, it is difficult to provide guarantees against privacy breaches when using additive perturbation.
For instance, if we add a Gaussian random variable with a mean 0 and variance 20 to age, and for a specific row the randomized value happens to be −60, one can estimate with high confidence that the original value of age was (say) less than 20.
Additive schemes are also restricted to numeric data.
Finally, the algorithms in [4] reconstruct each column independently.
Since OLAP requires queries over multiple columns, it is essential to be able to reconstruct them together.The problem of privacy-preserving association-rule mining was studied in [9,10,21].
The randomization schemes used in these works are similar to the retention replacement schemes we consider.
However these studies are restricted to boolean data.Formal definitions of privacy breaches were proposed in [9], and an alternate approach to defining privacy guarantees was proposed in [6].
We adapt the definitions from [9] to allow more accurate reconstruction while still providing strong privacy guarantees.
As our notion of privacy encompasses multiple correlated columns over vertically partitioned tables, it extends to privacy breaches (called disclosure risk) considering row linkage, studied in statistical disclosure control methods and [11].
There has been recent work [22,23] to specify authorization and control inferences for OLAP data cubes.
However the model assumes that the data resides at a single server, unlike our problem, where private data is integrated from multiple clients.Another related area is that of secure multiparty computation [13,25], that allows any function, whose inputs are shared between multiple clients to be evaluated, such that nothing other than the result is revealed.
Since the general protocols are expensive, efficient protocols have been proposed for specific database and data mining operations, e.g. [3,8,12,16,19].
However, these protocols are designed for a small number of clients.
A single record of the table is referred to as a row, while an attribute is referred to as a column.
A single column from a single row is the granularity of perturbation and is referred to as a data element.
so that | f ′ − f | < max(ǫ, ǫ f ) withprobability greater than (1 − δ) whenever the table T has more than n rows.
The probability is over the random choices made by α.For boolean functions, (n, δ) reconstructability needs f and f ′ to agree exactly with probability greater than (1 − δ).
Referring to Figure 1, to answer the aggregate query count(P 1 ∧ P 2 ∧. . . P k ) on k columns of the original table, T , a set of 2 k queries,count(P 1 ∧ P 2 ∧ . . . P k ), count(¬P 1 ∧ P 2 ∧ . . . P k ), count(P 1 ∧ ¬P 2 ∧ . . . P k ), count(¬P 1 ∧¬P 2 ∧. . . P k ) . . . count(¬P 1 ∧¬P 2 ∧. . . ¬P k ) are generated.These queries are evaluated on the perturbed table T ′ .
The answers on T ′ are reconstructed into estimated answers for the same queries on T , which include the answer to the original query.
Without loss of generality, assume that the predicates are only over perturbed columns.
We present reconstruction algorithms for numeric columns.
These algorithms can be extended to categorical columns too as shown in Section 6.
Consider the uniform retention replacement perturbation with retention probability p applied on a database with n rows and a single column, C, with domain [min, max].
Consider the predicate P = C [low, high].
Given the perturbed n o = 1 p (n r − n(1 − p)b) , where b = high − low max − min .
The intuition is that out of the n rows in table T , the expected number of rows that get perturbed is n(1 − p).
For uniform perturbation, a b fraction of these rows, i.e. n(1 − p)b rows, will be expected to lie within the [low, high] range.
The total number of rows observed in range [low, high] in T ′ , n r , can be seen as the sum of those rows that were decided to be perturbed into [low, high] (from outside, or perturbed and retained within the interval) and those rows that were unperturbed in the original interval.
Subtracting the n(1 − p)b perturbed rows from n r , we get an estimate for the number of unperturbed rows, with values in [low, high] in T .
This is scaled up by 1/p to get the total number of original rows in T in [low, high], as only a p fraction of rows were retained.
The fraction f of rows originally in [low, high] is therefore estimated asf ′ = n o n = n r pn − (1 − p)(high − low) p(max − min) .
Not only is the above estimator a Maximum Likelihood Estimator (MLE) as shown in Section 4.2, it reconstructs an approximate answer with high probability.
THEOREM 1.
Let the fraction of rows in [low, high] in the original table f be estimated by f′ , then f ′ is a (n, ǫ, δ) estimator for f if n ≥ 4 log( 2 δ )(pǫ) −2 .
We now formalize the above reconstruction procedure.
This formalization provides the basis for the reconstruction of multiple columns in Section 4.2.
As only table T ′ is available, x is estimated using the constraint xA = y, which gives the estimator x = yA −1 .
Here A is the following transition matrixLet vector y = [y 0 , y 1 ] = [count(¬P), count(P)](1 − p)a + p (1 − p)b (1 − p)a (1 − p)b + p .
The element in the first row and first column of A, a 00 = (1− p)a+ p is the probability that an element originally satisfying ¬P in T after perturbation satisfies ¬P in T ′ .
This probability was calculated as the sum of the probabilities of two disjoint events.
The first being that the element is retained, which occurs with probability p.
The second being that the element is perturbed and after perturbation satisfies ¬P, which together has probability (1 − p)a.
The element a 01 is the probability that an element satisfying ¬P in T after perturbation satisfies P in T ′ .
The element a 10 is the probability that an element satisfying P in T after perturbation satisfies ¬P in T ′ .
The element a 11 is the probability that an element satisfying P in T after perturbation satisfies P in T ′ .
Their values were similarly derived.If y = [n − n r , n r ] and x = [n − n o , n o ], the solution to the equation below gives the same estimator as derived earlier:n − n o n o (1 − p)a + p (1 − p)b (1 − p)a (1 − p)b + p = n − n r n r .
Assume now that the uniform retention replacement perturbation, with retention probability p, has been applied to each of k columns of a table, T .
Consider the aggregate query count(P 1 ∧ P 2 ∧ ...P k ) on table T .
In practice k is small.We create a k × 2 matrix, R, with k rows and 2 columns, having 1 row for each query column.
R i,1 gives the probability that a number randomly selected from the replacing p.d.f. for column i will satisfy predicate P i , while R i,0 is the probability of the complementary event, that a number selected from the replacing p.d.f. will satisfy ¬P i .
Take for instance the query, Q=count(age [30][31][32][33][34][35][36][37][38][39][40][41][42][43][44][45] ∧ salary[50k-120k] ∧ house-rent ) with the domains for age, salary and house-rent being , [25k-200k], [500-2500].
Then R will be [[0.85, 0.15], [0.6, 0.4], [0.65, 0.35]], since the first column being age [30][31][32][33][34][35][36][37][38][39][40][41][42][43][44][45] implies R 1,1 = (45 − 30)/(100 − 0) = 0.15, while R 1,0 = 1 − 0.15 = 0.85, etc.As stated earlier, to answer the query count(P 1 ∧ P 2 . . . P k ), we ask 2 k aggregate queries on the perturbed table, T ′ .
The 2 k answers on perturbed table T ′ are converted into estimated answers to these 2 k aggregate queries on the original table T, which includes the estimated answer to the original query.Let y be a row vector of size 2 k that has the answers to the above queries on perturbed table T ′ , and let x be a row vector of size 2 k that has the reconstructed estimated answers to the queries on original table T .
We order the answers to the 2 k queries in vectors x, y using the bit representation of the vector index as shown in Figure 2.
Let Q(r, 1) denote the predicate(P r ) on the r th column of query Q, and Q(r, 0) its negation (¬P r ).
Let bit(i, r) denote the r thQuery Estimated on T Evaluated on T ′ count(¬P 1 ∧ ¬P 2 ) x 0 y 0 count(¬P 1 ∧ P 2 ) x 1 y 1 count(P 1 ∧ ¬P 2 ) x 2 y 2 count(P 1 ∧ P 2 ) x 3 y 3Figure 2: Answering query count(P 1 ∧ P 2 )bit from the left in the binary representation of the number i using k bits.
Then,x i = count(∧ k r=1 Q(r, bit(i, r))) in T , for 0 ≤ i ≤ 2 k − 1; y i = count(∧ k r=1 Q(r, bit(i, r))) in T ′ , for 0 ≤ i ≤ 2 k − 1.
For example, for the query count(age [30][31][32][33][34][35][36][37][38][39][40][41][42][43][44][45] ∧ salary[50k-120k] ∧ house-rent[700-1400]), y[6 10 ] = y[110 2 ] = count(age[30-45] ∧ salary[50k-120k] ∧ ¬ house-rent[700 − 1400])By a single scan through the perturbed table T ′ vector y can be calculated.
Vector x is reconstructed from vector y using the matrix inversion technique or the iterative Bayesian technique described below.
The data analyst may either be interested only in the component x 2 k −1 , which is the answer to the count(∧ k r=1 P r ) query on T , or she may be interested in the entire vector x.
If p r is the retention probability for the r th column, we calculate vector x from vector y as x = yA −1 .
The transition matrix, A, with 2 k rows and 2 k columns, can be calculated as the tensor product [15] of matricesA = A 1 ⊗ A 2 ⊗ A 3 .... ⊗ A kwhere the matrix A r , for 1 ≤ r ≤ k is the transition matrix for column r (see Section 4.1).
A r = (1 − p r )a r + p r (1 − p r )b r (1 − p r )a r (1 − p r )b r + p rwhere b r = R r,1 and a r = R r,0 = 1 − R r,1 .
The entries of the tensor product matrix, A, can be explicitly calculated to bea i j = k r=1 ((1 − p r ) × R r,bit( j,r) + p r × δ (bit(i,r),bit( j,r)) ), ∀0 ≤ i < 2 k , 0 ≤ j < 2 k where δ (c,d) = 1 if c = d, and 0 if c d, for c, d ∈ {0, 1}.
We split the space of possible evaluations of a row into 2 k states, according to which of the 2 k mutually exclusive predicate combinations the row satisfies.
We say a row is said to belong to state i if it satisfies the predicate ∧ k r=1 Q ( r, bit(i, r)).
For example, from Figure 2, a row in state 0 satisfies ¬P 1 ∧ ¬P 2 while a row in state 1 satisfies ¬P 1 ∧ P 2 etc.The entry a i j of matrix A above represents the probability that a row belonging to state i in T , after perturbation belongs to state j in T ′ .
As each column was independently perturbed the probability of transition from state i to state j is the product of the probabilities for the transitions on all columns.
The contribution from the r th column to the transition probability is the sum of (1 − p r ) × R r,bit( j,r) , if the element was decided to be perturbed, and p r × δ (bit(i,r),bit( j,r)) , if the element was decided to be retained.
The term δ (bit(i,r),bit( j,r)) ensures that the retention probability p r adds up only if the source and destination predicates on the r th column are the same for states i and j. Thus the probability of transition from state i to state j on the r th column is (1− p r )×R r,bit( j,r) + p r ×δ (bit(i,r),bit( j,r)) .
The product of this probability over all columns gives the probability of transition from state i to state j, a i j .
THEOREM 2.
The vector x calculated as A −1 y is the maximum likelihood estimator (MLE) of the relaxed a priori distribution ( i x i = n and 0 ≤ x i ≤ n are the exact constraints, the relaxed constraint only ensures i x i = n) on the states that generated the perturbed table.The multiple column aggregate is (n, ǫ, δ) reconstructible, is shown by applying the Chernoff bound, to bound the error in y, and then bounding the error added during inversion.
Let vectors x and y of size 2 k be the a priori distribution on states of the original rows, and posteriori distribution on states of perturbed rows, as introduced above.
Let the original states of rows in T selected from the a priori distribution be given by random variables U 1 , U 2 , ....U n , while the states of the n perturbed rows in T ′ be given by the random variables V 1 , V 2 , ...V n .
Then for 0 ≤ p, q ≤ t = (2 k − 1) and 1 ≤ i ≤ n, we have Pr(V i = q) = y q /n, and Pr(U i = p) = x p /n. Also Pr(V i = q|U i = p) = a pq is the transition probability from state p to q. From Bayes rule, we get We iteratively update x using the equationPr(U i = p|V i = q) = P(V i = q|U i = p)P(U i = p) P(V i = q) = P(V i = q|U i = p)P(U i = p) t r=0 P(V i = q|U i = r)P(U i = r) = aPr(U i = p) = t q=0 Pr(V i = q)Pr(U i = p|V i = q).
This gives us the update rule,x T +1 p = t q=0 y q a pq x T p t r=0 a rq x T r ,where vector x T denotes the iterate at step T , and vector x T +1 the iterate at step T + 1.
We initialize the vector, x 0 = y, and iterate until two consecutive x iterates do not differ much.
This fixed point is the estimated a priori distribution.
This algorithm is similar to the iterative procedure proposed in [4] for additive perturbation and shown in [2] to be the Expectation Maximization (EM) algorithm converging to the Maximum Likelihood Estimator (MLE).
We provide here a brief analysis of the error in the reconstruction procedures.
A quantitative analysis of the magnitude of error is easy for the inversion method, but such an analysis is much harder for the iterative method.
Due to the randomization in the perturbation algorithm there are errors in the transition probabilities in matrix A.
This causes y, the posteriori distribution after perturbation calculated from T ′ , to have errors.
Hence the reconstructed x will have errors.The error decreases as the number of rows, n, increases.
Let a ′ i j denote the actual fraction of original rows of state i that were converted to state j.
Then as n increases, a i j will be a closer approximation to a ′ i j .
The error decreases as n −0.5 as indicated by Theorem 1, and verified empirically in Section 7.
The error in reconstruction increases as the number of reconstructed columns, k, increases, and the probability of retention, p, decreases.
The largest and smallest eigenvalues of A can be shown to be 1 and p k respectively and the condition number of the matrix A grows roughly as p −k (see Section 7).
The condition number of a matrix is a good indicator of the error introduced during inversion [14].
Private data from multiple clients is perturbed before being integrated at the server.
In this section, we formalize the privacy obtained by this perturbation.The notion of a (ρ 1 , ρ 2 ) privacy breach was introduced in [9].
We extend this to introduce a new privacy metric, called the (s, ρ 1 , ρ 2 ) privacy breach.
Consider a database of purchases made by individuals.
It is quite likely that many people buy bread, but not many buy the same prescription medicine.
The new metric is more concerned about whether an adversary can infer from the randomized row which medicine a person bought, and is less concerned about the adversary determining with high probability that the original row had bread, as most individuals buy bread and it does not distinguish the individual from the rest of the crowd.Assume that the adversary has access to the entire perturbed table T ′ at the server, and the exact a priori distribution on the unperturbed data (which can be reconstructed [4]) 1 .
Also assume that any external information is already incorporated into the database.
Consider a data element of domain V X perturbed by a perturbation algorithm into another domain V Y .
DEFINITION 4.
(ρ 1 , ρ 2 ) Privacy Breach [9]: Let Y denote the random variable corresponding to the perturbed value and X that corresponding to the original value obtained from the a priori distribution.
We say that there is a (ρ 1 , ρ 2 ) privacy breach with re-spect to Q ⊆ V X if for some S ⊆ V Y P[X ∈ Q] ≤ ρ 1 and P[X ∈ Q|Y ∈ S ] ≥ ρ 2 where 0 < ρ 1 < ρ 2 < 1 and P[Y ∈ S ] > 0.
In retention replacement perturbations, which are of interest to us, the column is perturbed back into the same domain, and hence V X = V Y .
Let S ⊆ V X , with P[X ∈ S ] = p s , for X ∈ o V X where ∈ o represents selecting an element from V X according to the a priori distribution on V X .
Let P[Y ∈ S ] = m s , for Y ∈ r V X , where ∈ r represents selecting an element from V X according to the replacing distribution, which is different from the distribution of the perturbed table.
The ratio p s /m s is called the relative a priori probability of the set S .
The relative a priori probability is a dimensionless quantity that represents how frequent a set is according to its a priori probability as compared to the replacing p.d.f. (the uniform p.d.f.).
In a database of purchases, medicines will have low relative a priori probability since different people take different medicines, while bread will have high relative a priori probability.
Let S ⊆ V X , we say that there is a (s, ρ 1 , ρ 2 ) privacy breach with respect to S if the relative a priori probability of S , p s /m s < s, and if P[X ∈ S ] = p s ≤ ρ 1 and P[X ∈ S |Y ∈ S ] ≥ ρ 2 where 0 < ρ 1 < ρ 2 < 1 and P[Y ∈ S ] > 0.
The value of s in the privacy breach is addressed by the next result.
We define rare sets as those that have relative a priori probability smaller than 1.
We next show that privacy breaches do not happen for rare sets.
THEOREM 4.
Let p be the probability of retention, then uniform perturbation applied to a single column is secure against a (s, ρ 1 , ρ 2 ) breach, ifs < (ρ 2 − ρ 1 )(1 − p) (1 − ρ 2 )p .
As a concrete example, for uniform perturbation, with p=0.2, there are no (68, 0.1, 0.95) breaches.
This means for any set S , if ρ 2 > 0.95 with uniform perturbation, ρ 1 will be large (> 0.1) when p s /m s < 68.
In fact, for a rare set, with s < 1, there will be no (0.937, 0.95) privacy breaches in the original (ρ 1 , ρ 2 ) model for this perturbation.
≤ i ≤ k. Let S = S 1 × S 2 × . . . S k , then S ⊆ D. Let P[S ] = p S 1 ×S 2 ×...S k = p s (say) be the a priori probability of S .
Let P[Y i ∈ S i ] = m S i , for Y i ∈ α i D i ,≤ i ≤ k.
Then P[Y ∈ S ] = m S 1 m S 2 .
.
m S k = m s (say) for Y = (Y 1 , Y 2 , . . . Y k ) ∈ α D,where ∈ α denotes selecting randomly from the replacing p.d.f. for each column independently.
p s /m s , the relative a priori probability, is the ratio of the a priori probability to the replacing probability, of the combination of values for the columns together.
Correlated columns with higher a priori probabilities have larger values of p s /m s .
THEOREM 5.
There will not be a (ρ 1 , ρ 2 ) privacy breach with respect to (S 1 × S 2 × . . .S k ) = S ⊆ D, if p s m s < ρ 2 (1 − ρ 1 )(1 − p) k (1 − ρ 2 ) k i=1 ((1 − p)m S i + p).
S i denotes the subset on column i within which the original value must be identified for the privacy breach.
In the case, S i denotes a single value or a small range within the domain of a continuous column, hence (1 − p)m S i ≪ p.
We approximate (1 − p)m S i + p by p to getρ 2 (1 − ρ 1 )(1 − p) k (1 − ρ 2 ) k i=1 ((1 − p)m S i + p) ≥ ρ 2 (1 − ρ 1 )(1 − p) k (1 − ρ 2 )p k (1 − ǫ)for some small constant ǫ.
Thus for some small constant ǫ, uniform perturbation applied individually to k columns is secure against (s, ρ 1 , ρ 2 ) breaches fors < ρ 2 (1 − ρ 1 )(1 − p) k (1 − ρ 2 )p k (1 − ǫ).
As an example, for uniform perturbation with p=0.2 applied independently to two columns, there are no (273,0.1,0.95) breaches for joint events on the columns (when m S i are small).
Consider a categorical column, C, having discrete domain D. Let S ⊆ D.
A predicate P, on column C, using S is defined asP(x) = true if x ∈ S f alse otherwise.Given the a priori and replacing p.d.f. on D, the reconstruction algorithms in Section 4 and the privacy guarantees in Section 5 can be directly applied to the categorical data by computing the probability of the predicate, P, being true.
Our analysis so far considered retention replacement perturbations where the replacing p.d.f is the uniform distribution.
We now discuss some other interesting retention replacement schemes:1 Identity perturbation: If the original data element is decided to be perturbed, the data element is replaced by a random element selected uniformly among all data elements [18] (i.e. the replacing p.d.f. is the same as the a priori distribution).2 Swapping: Swapping is closely related to identity perturbation.
In swapping with probability p we retain a data element, and with probability (1 − p) we decide to replace it.
Numbers decided to be replaced are then randomly permuted amongst themselves.
Identity perturbation and swapping are different from uniform perturbation which is a local perturbation.
Identity perturbation can be local if there is knowledge of the a priori distribution before perturbation.
Swapping is not a local perturbation and requires multiple rows at the client.
Identity perturbation and swapping do not affect the answers to single column aggregate queries, i.e. answers to single column aggregate queries on the perturbed table, T ′ , are returned directly as answers to those queries on the original table, T .
The difference in multi-column reconstruction for identity perturbation and swapping as compared to uniform perturbation is in the evaluation of vector R in Section 4.2.
Recall that R i,1 is the probability that an element selected from the replacing p.d.f. on column i satisfies the predicate on the i th column, P i .
The replacing p.d.f. (which is the original p.d.f. for identity perturbation and swapping) is required for reconstruction.
This requires the server to have the original p.d.f. for each column.
This requirement is however obviated by the observation in the previous paragraph, that the fraction of elements satisfying P i in T is the same as the fraction of elements satisfying P i in T ′ .
Hence R i,1 can be calculated from T ′ .
R i,0 as before is calculated as 1 − R i,1 .
The reconstruction error after identity perturbation and swapping will be smaller than that compared to uniform perturbation for sets, S , with small relative a priori probability.
This is because in uniform perturbation the noise due to the perturbed data elements that now belong to S , but did not before perturbation, exceeds significantly the number of data elements that were in S originally and retained during perturbation.
The guarantees for identity perturbation and swapping can be obtained using m S i = p S i in Theorems 4 and 5.
As an example we restate Theorem 4 for identity perturbation.
LEMMA 1.
For a single column, identity perturbation is secure against (s, ρ 1 , ρ 2 ) privacy breaches forρ 1 < ρ 2 − p 1 − p .
PROOF: For identity perturbation, m s = p s , hence p s /m s = 1 ∀S .
Repeating the argument in Theorem 4 we get (ρ 2 − ρ 1 )(1 − p) > (1 − ρ 2 )p, which implies the result.
The above (ρ 1 , ρ 2 ) guarantee for identity perturbation is independent of the subset S .
Uniform perturbation gives better (ρ 1 , ρ 2 ) guarantees for a set of rare data elements, i.e. a set with p s /m s < 1 and worse for sets with p s /m s > 1.
Identity perturbation and swapping have a privacy breach in the presence of external knowledge about rare values (eg.
the largest or smallest value).
Rare values need to be suppressed (i.e. blanked out) [17] for privacy with these perturbations.
We show how aggregate queries on multiple columns can be used for privacy preserving construction of decision trees [4].
Consider the tree in Figure 3 Now consider the third split, on age once again, but this time (age < 21), is decided after the queries count(age ∧ salary[25k- 100k] ∧ ¬ Q ), count(age[21-30] ∧ salary[25k-100k] ∧ ¬ Q ) count(age[0-21] ∧ salary[25k-100k] ∧ Q ) and count(age[21-30] ∧ salary[25k-100k] ∧ Q ) are reconstructed for T .
The number of columns in the count query did not increase at this split on age, which was already present among the original set of queried columns.
We next present an empirical evaluation of our algorithms on real as well as synthetic data.
For real data, we used the Adult dataset, from the UCI Machine Learning Repository [5], which has census information.
The Adult dataset contains about 32,000 rows with 4 numerical columns.
The columns and their ranges are: age [17 - 90], fnlwgt [10000 -1500000], hrsweek [1 -100] and edunum [1 - 16].
For synthetic data, we used uncorrelated columns of data having Zipfian distribution with zipf parameter 0.5.
We create three such tables with different number of rows.
The number of rows is varied in factors of 10 from 10 3 to 10 5 .
The frequencies of occurrences are such that the least frequent element occurs 5 times.
This results in the number of distinct values to be approximately one tenth of the number of rows in the table.
In this Section we assume that the vectors, x, y described in Section 4.2 have been normalized, i.e. all elements have been divided by n, the number of rows, so that the sum of the elements of each vector is 1.
These vectors will also be referred to as probability density function ( Reconstruction algorithms: We first study the reconstruction error while reconstructing multiple columns of the Adult dataset for varying retention probabilities.
The predicates being reconstructed are age , fnlwgt and hrsweek [30- 60].
Figure 4 shows the errors on first two among the above predicates while Figure 5 shows the errors on all three predicates.
The retention probability, p, plotted on the x-axis, is the same for all columns.
The reconstruction error is plotted on the y axis.
There are three curves in each figure.
The curve randomized, shows the l 1 norm of the difference between the perturbed p.d.f. vector y and the original p.d.f. vector x ′ .
It serves as a baseline to study the reduction in error after reconstruction of y to x.
The other two curves represent the reconstruction errors after the iterative and the inversion algorithms.
The iterative procedure gives smaller errors than the inversion procedure, especially when a larger number of columns are reconstructed together, and the probability of retention, p, is small.
This is reconfirmed later by Figures 7 and 8, and similar experiments on synthetic data (which we do not show for the lack of space).
This may seem unintuitive as the inversion algorithm was shown to give the MLE estimator for x, satisfying i x i = 1 (after normalization).
This can be explained by noting that the iterative algorithm gives the MLE estimator in the constrained space, i.e. for the subspace of i x i = 1 that satisfies 0 ≤ x i ≤ 1 ∀i.
Since the number of rows are always non-negative, this is the subspace that contains the exact original p.d.f. vector x ′ .
When the retention probability decreases, and the number of columns to be reconstructed increases, the error during randomization and reconstruction increases, and the inversion algorithm may return a point outside the constrained space.
The reconstruction error by the inversion method can grow arbitrarily.
However, the iterative algorithm being constrained, will have a reconstruction error of at most two.
Condition number: Figure 6 shows the condition number [14] of the transition matrix using a logarithmic scale on the y axis, and the number of columns reconstructed on the x axis, for different retention probabilities (p= 0.2, 0.5 etc.).
The selectivity of each predicate is set to 0.5.
The condition number (which is independent of the dataset) increases as the retention probability decreases and increases exponentially as the number of columns reconstructed increase.
The condition number is a good indicator of the reconstruction error by the inversion algorithm [14], and by the iterative Bayesian algorithm at small error values.
Unlike the continuous exponential growth in error as the number of reconstructed columns increases for the inversion algorithm, the error flattens out for the iterative algorithm, as it is bounded above by two as discussed earlier.
Next we study, how the reconstruction error varies as the number of columns reconstructed, retention probability, number of rows, and selectivity of the predicates vary.
Number of columns and retention probability: We study the reconstruction errors for varying number of columns and retention probabilities on the Adult dataset by the iterative and inversion algorithms.
The predicates being reconstructed are age [ 25 -45], fnlwgt [ 100000 -1000000], hrsweek [ 30 -60] and edulevel [ 5 - 10].
For the i ( 1 ≤ i ≤ 4 ) column experiment, the first i among the above predicates are selected in the query.
Figure 7 shows the reconstruction errors with the iterative algorithm, while Figure 8 shows the reconstruction errors with the inversion algorithm.
Both iterative and inversion algorithms show an exponential increase in the error as the number of columns increases and as the probability of retention decreases.
For smaller number of columns and higher retention probabilities both algorithms give comparable reconstruction errors.
However for larger number of columns and lower retention probabilities the iterative algorithm gives smaller errors than the inversion algorithm.
As explained in Section 7.1, unlike the iterative method, the reconstruction error by the inversion method can grow arbitrarily, whereas the error by the iterative method flattens out after an initial exponential increase.
For all experiments on the Zipfian dataset, the predicate on each column has an independent selectivity of 0.5.
Figure 9 shows the reconstruction error after the iterative algorithm is applied to the perturbed Zipfian dataset of size 10 5 .
The figure shows the increase in the reconstruction error, plotted on the y axis, for increasing number of columns, plotted on the x axis, for different retention probabilities.
After an initial exponential increase, the reconstruction error flattens out.
Number of rows in the table: Figure 10 shows how the reconstruction error decreases as the number of perturbed rows available for reconstruction increase, for the the iterative reconstruction algorithm.
In Figure 10 the retention probabilities are varied while the number of columns remains fixed at 8.
For large values of n the reconstruction error decreases as n −0.5 as suggested by Theorem 1.
This is also ratified by the factor 10 displacement between the reconstruction error lines for 10 3 and 10 5 rows in Figures 11 and 12.
As the number of rows increases, it is possible to reconstruct more columns together at smaller retention probabilities.
We study privacy breaches possible after perturbation on the Adult dataset.
Figure 13 and Figure 14 show the maximum retention probability that avoids breaches for varying values of ρ 1 for fixed ρ 2 = 0.95, according to Theorem 5.
To compute the values of s for sample predicates (subsets) of this dataset, we divide each column into 10 equiwidth intervals and consider predicates that are subsets formed by the cross product of the intervals.
Thus for two columns we consider 10 2 subsets and for three columns we consider 10 3 subsets.
The maximum values of s were observed to be 15 and 30 for two and three columns respectively.
The median value of s has been shown to be one in Theorem 3.
The two figures plot the maximum retention probability, p, that would avoid a (s, ρ 1 , ρ 2 ) breach, on the y axis against the a priori probability, ρ 1 , on the x axis for different values of relative a priori probability, s.
The values of s used are the maximum value of s, the median value s = 1, and s = 0.1 for a rare set.
Both figures show that if it suffices to just hide rare properties (i.e., with s ≤ 0.1), then for ρ 1 > 0.5, the retention probability p can be as high as 0.8.
If we need to hide all the above properties, i.e. even for the largest s (the most common property), then for ρ 1 > 0.5 the retention probability can be selected to be as high as p = 0.3.
For p = 0.3 both Figure 4 and Figure 5 show low reconstruction error.
Thus reconstructability of 2 and 3 aggregates together, and privacy of data elements, are both achieved by perturbation for the Adult dataset, with p = 0.3.
Thus our experiments indicate (s, ρ 1 , ρ 2 )-privacy as well as multi-column aggregate reconstructability.
The contributions of the paper are:• We introduce the problem of privacy preserving OLAP in a distributed environment.
• We introduce the formalism for reconstructible functions on a perturbed table, and develop algorithms to reconstruct multiple columns together.
We provide privacy guarantees that take into account correlations between any combination of categorical and numeric columns.
• We provide two reconstruction algorithms to work with retention replacement perturbation: an iterative Bayesian algorithm, and a matrix inversion algorithm that also yields the maximum likelihood estimator.
These algorithms can reconstruct count aggregates over subcubes without assuming independence between columns.
• We evaluate proposed reconstruction algorithms both analytically and empirically.
We study the privacy guarantees we get for different levels of reconstruction accuracy and show the practicality of our techniques.
• We show the use of our techniques to related applications like classification.
Future work includes extending this work to other aggregates over subcubes.by analyzing the Hessian matrix, H, of l(x, λ) Theorem 3.
The median value of relative a priori probability, over all subsets S , S ⊆ V X , is 1.
PROOF: Consider, any subset S ⊆ V X , and S = V X − S .
Using notation as in Definition 5 we have p s + p s = 1 and m s + m s = 1.
Hence if p s /m s ≥ 1 , we have p s /m s ≤ 1 and if p s /m s < 1 we have p s /m s > 1 Since this is true for any pair of complementary subsets, among all subsets of V X , half the subsets have relative a priori probability ≥ 1 and half ≤ 1.
Hence the median value of s over all subsets of V X will be 1, if the median is not constrained to be one of the values attained.
Let R denote the event that X was replaced and R c it being retained.
For a (ρ 1 , ρ 2 ) privacy breach with respect to S we need P[X ∈ S ] ≤ ρ 1 .
Also P[(X ∈ S )|(Y ∈ S )]= P[(X ∈ S ) ∩ (Y ∈ S ) ∩ R] + P[(X ∈ S ) ∩ (Y ∈ S ) ∩ R c ] P[Y ∈ S ] ≤ ρ 1 (1 − p)m s + pp s (1 − p)m s + pp s We thank Rajeev Motwani and Rajat Raina for discussions on identity perturbation and maximum likelihood estimators.
We also thank Alexandre Evfimievski and an anonymous reviewer for insightful comments on the paper.
XTheorem 1.
Let the fraction of rows in [low, high] in the original table, f be estimated by f ′ , then f ′ is a (n, ǫ, δ) estimator for f if n ≥ 4 log( 2 δ )(pǫ) −2 PROOF: Let Y i be the indicator variable for the event that the i th row (1 ≤ i ≤ n) is perturbed and the perturbed value falls within [low, high].
Let Z i be the indicator variable for the event that the i th randomized row falls in [low, high].
We have Z i = X i +Y i , and Pr[Z i = 1] = q+r = t (say), and Pr[Z i = 0] = 1−t. Let Z = n i=1 Z i = n r , the number of randomized values in range [low, high].
Since Z i 's are independent Bernoulli random variables, 0 ≤ t ≤ 1 and n ≥ 4 log( 2 δ )(pǫ) −2 × t, applying Chernoff bounds [7] we getThus with probability > 1 − δ, we have −npǫTheorem 2.
The vector x calculated as A −1 y is the maximum likelihood estimator (MLE) of the relaxed a priori distribution 2 on the states that generated the perturbed table.is the likelihood of the observations, V, given a probability distribution on the states,x j a ji )) subject to the constraint t j=0 x j = n.
This is equivalent towhere λ is the Lagrangian multiplier.
If t j=0 x j −n > 0 then setting λ to arbitrarily large positive value, you can minimize the term −λ( t j=0 x j − n) to an arbitrarily small negative number, similarly when t j=0 x j − n < 0, as λ tends to −∞ the term becomes arbitrarily small.
So the optimum ensures that the constraint t j=0 x j = n is satisfied.
To maximize the expression, setting the partial derivatives to be zero we get, Thus at x, given by x = yA −1 , and λ = 1 we get a local maximum of l(x, λ).
We show that the local maximum is the global maximum,Hence for a (ρ 1 , ρ 2 ) privacy breach with respect to S , we needTheorem 5.
There will not be a (ρ 1 , ρ 2 ) privacy breach for (.
.
, X k ) be the random variable corresponding to the original value of the k column row from the a priori distribution on table T , and Y = (Y 1 , Y 2 , ....Y k ) that corresponding to the perturbed row, where each column is perturbed independently by a retention replacement perturbation.
ForSuppose there is a (ρ 1 , ρ 2 ) privacy breach with respect to S , we need P[X ∈ S ] ≤ ρ 1 , and P[(X ∈ S )|(Y ∈ S )] ≥ ρ 2 ThusSubstituting values of U S , L S and noting that p s ≤ ρ 1 hence 1− p s ≥ 1 − ρ 1 , we get Theorem 1.
Let the fraction of rows in [low, high] in the original table, f be estimated by f ′ , then f ′ is a (n, ǫ, δ) estimator for f if n ≥ 4 log( 2 δ )(pǫ) −2 PROOF: Let Y i be the indicator variable for the event that the i th row (1 ≤ i ≤ n) is perturbed and the perturbed value falls within [low, high].
Let Z i be the indicator variable for the event that the i th randomized row falls in [low, high].
We have Z i = X i +Y i , and Pr[Z i = 1] = q+r = t (say), and Pr[Z i = 0] = 1−t. Let Z = n i=1 Z i = n r , the number of randomized values in range [low, high].
Since Z i 's are independent Bernoulli random variables, 0 ≤ t ≤ 1 and n ≥ 4 log( 2 δ )(pǫ) −2 × t, applying Chernoff bounds [7] we getThus with probability > 1 − δ, we have −npǫTheorem 2.
The vector x calculated as A −1 y is the maximum likelihood estimator (MLE) of the relaxed a priori distribution 2 on the states that generated the perturbed table.is the likelihood of the observations, V, given a probability distribution on the states,x j a ji )) subject to the constraint t j=0 x j = n.
This is equivalent towhere λ is the Lagrangian multiplier.
If t j=0 x j −n > 0 then setting λ to arbitrarily large positive value, you can minimize the term −λ( t j=0 x j − n) to an arbitrarily small negative number, similarly when t j=0 x j − n < 0, as λ tends to −∞ the term becomes arbitrarily small.
So the optimum ensures that the constraint t j=0 x j = n is satisfied.
To maximize the expression, setting the partial derivatives to be zero we get, Thus at x, given by x = yA −1 , and λ = 1 we get a local maximum of l(x, λ).
We show that the local maximum is the global maximum,Hence for a (ρ 1 , ρ 2 ) privacy breach with respect to S , we needTheorem 5.
There will not be a (ρ 1 , ρ 2 ) privacy breach for (.
.
, X k ) be the random variable corresponding to the original value of the k column row from the a priori distribution on table T , and Y = (Y 1 , Y 2 , ....Y k ) that corresponding to the perturbed row, where each column is perturbed independently by a retention replacement perturbation.
ForSuppose there is a (ρ 1 , ρ 2 ) privacy breach with respect to S , we need P[X ∈ S ] ≤ ρ 1 , and P[(X ∈ S )|(Y ∈ S )] ≥ ρ 2 ThusSubstituting values of U S , L S and noting that p s ≤ ρ 1 hence 1− p s ≥ 1 − ρ 1 , we get
