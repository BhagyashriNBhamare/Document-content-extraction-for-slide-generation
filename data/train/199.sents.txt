We introduce an efficient algorithm for the exact analysis of closed multiclass product-form queueing network models with large population sizes.
We adopt a novel approach, based on linear systems of equations, which significantly reduces the cost of computing normalizing constants.
With the proposed algorithm, the analysis of a model with N circulating jobs of multiple classes requires essentially the solution of N linear systems with order independent of population sizes.
A distinguishing feature of our approach is that we can immediately apply theorems, solution techniques, and de-compositions for linear systems to queueing network analysis.
Following this idea, we propose a block triangular form of the linear system that further reduces the requirements, in terms of both time and storage, of an exact analysis.
An example illustrates the efficiency of the resulting algorithm in presence of large populations.
Analytical performance modeling of computer and communication systems is often carried out using queueing network models.
For historical reasons, closed product-form networks [2] have been the focus of the field for over twenty Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.
SIGMetrics/Performance'06, June 26-30, 2006 years [28].
Using these models, classic performance problems as the capacity planning of computer systems can be easily tackled, typically with much less computational effort than simulation (see, e.g., [17] for an overview of applications).
Moreover, computational algorithms for models with product-form solution have largely inspired further research.
For instance, queueing networks with extended features that are successfully applied in several areas including software performance evaluation, parallel system analysis, and modeling of networks with priorities or blocking (e.g., [1,4,14,35,37]), can be solved by means of modified versions of the algorithms proposed for product-form networks.The distinguishing feature of product-form models is that simple closed-form expressions are known for the equilibrium distribution of network state probabilities.
The challenge is to efficiently compute the normalizing constant that assures that state probabilities sum to one.
Excellent developments in the field [3,5,9,10,12,13,16,23,24,33,34] have shown that exact solution methods are computationally feasible in several cases of interest.
However, the computational requirements usually become prohibitive when a large multiclass population is present in the network.
This has led to the well-known conclusion that typically multiclass queueing networks are intractable for large population sizes.
This is a severe difficulty of the theory that has been addressed for practical purposes only by approximation techniques as local iterative methods (e.g., [8,15,36]), bounds and asymptotic expansions (e.g., [32,39]), or with the truncation of Euler summations when numerically inverting the generating function of the normalizing constant [10].
The results presented in this paper indicate that efficient exact algorithms for multiclass models with large populations are possible.
In the following sections, we introduce a novel approach for computing normalizing constants that is efficient even in this difficult case.
The algorithm is based on the solution of systems of linear equations involving normalizing constants, and follows from a simple consideration.
Several recurrence equations for normalizing constants have been proposed in previous works [5,9,13,23,32,33].
Clearly, each of them gives an alternative description of the structure of the normalizing constant.
We propose to use the simultaneous information of a set of recurrence equations to reduce the cost of computing normalizing constants.In particular, the proposed algorithm has the following structure.
We consider a set of networks derived from the model to be solved, and defined in such a way that all normalizing constants can be related by a system of linear equations.
Then, we increase in a linear fashion, and simultaneously for all networks, the total population from 1 to N , being N the sum of class populations in the original model.
After each increase, we compute normalizing constants using the linear system.
Finally, we determine performance measures of interest for the original model.
In this way, an exact analysis requires essentially the solution of N linear systems.
Moreover, despite the composition of the set of networks, and hence linear system structure, may change while increasing populations, linear system order is always independent of population sizes.
As a consequence, we show that the computational cost is mostly determined by the number of queues and classes, rather than by the total population, which is usually the largest of the three parameters.There are benefits and drawbacks connected to the introduction of linear systems of equations into queueing network analysis.
Besides the significant reduction of computational complexity, that is anyway a fundamental motivation, there are other significant advantages.
For instance, the new approach promotes the application of linear algebra techniques to the analysis of product-form networks.
We show an application of this idea by defining a block triangular form of the linear system coefficient matrix that significantly reduces time and storage requirements.
Moreover, the diffusion of specialized software for linear algebra, like computer algebra systems (e.g., [38]), may reduce implementation efforts.We found instead two drawbacks regarding uniqueness and numerical accuracy of solutions achievable with standard (inexact) linear system solvers.
Concerning the latter, we believe that the new algorithm, besides the related theoretical results, is also of practical interest due to its efficiency.
Thus, granting result correctness is a fundamental objective of the present analysis.
A simple and definitive solution to numerical accuracy problems follows by adopting an exact linear system solver in implementations (e.g., [6]).
This has a limited impact on the asymptotic complexity of the algorithm that remains, also in the worst case, the exact technique of choice for multiclass models with large population sizes.
Further, an exact solution let us avoid floating-point range exceptions that frequently arise in normalizing constant algorithms.
Concerning uniqueness, we discuss some cases where the linear system does not have a unique solution due to a singular coefficient matrix.
We propose strategies to address the problem.The paper is organized as follows.
In Section 2 we give preliminary definitions.
Related work is critically analyzed in Section 3, where we also introduce the solution approach based on linear systems.
Section 4 defines the algorithm that is further examined in Section 5 using linear algebra techniques.
Computational requirements are discussed in Section 6.
A numerical example is presented in Section 7.
Finally, Section 8 gives conclusions and outlines future work.
Theorem proofs are reported in the final appendix.
Let us consider a closed product-form model composed by M load-independent queues, R job classes and an arbitrary number of delays.
The population size for class s is Ns, and the population vector is N ≡ (N1, . . . , Ns, . . . , NR).
We denote by N = È R s=1 Ns the total population.
The loading ρ ks (also called in the literature service demand) is the product between the mean service time per visit and the mean number of visits of class s at queue k.
We denote by ρ0s the sum of delays for class s.Exact algorithms considered in the following sections perform recursions on the number of jobs and queues in the model.
Without loss of generality, we indicate the population currently processed by the recursion with the Rdimensional vector n ≡ (n1, . . . , ns, . . . , nr, 0, . . . , 0), where ns > 0, 1 ≤ s ≤ r. Hence r, r ≤ R, is the number of non-empty classes of the current population.
We denote by n = È r s=1 ns the total population of n. Let 0 be the zero vector, and let es be a vector of all zeros except for the s-th element that is one.
In several algorithms, e.g., Convolution [5,33], LBANC [9], and MVA [34], n spans the population setprod(N) = {n | 0 ≤ n ≤ N} ,(1)with cardinality card(prod(N)) = É R s=1 (Ns + 1).
As we show later in the paper, a class recursion algorithm as RE-CAL [13] may be instead reformulated as a recursion onlin(N) = {0, e1, 2e1, . . . , N1e1, N1e1 + e2, N1e1 + 2e2, . . . , N1e1 + N2e2, . . . , N}, (2)where card(lin(N)) = N + 1.
A graphical comparison of the two sets is given in Figure 1.
Note that for large multiclass populations card(lin(N)) << card(prod(N)).
While recurring, several intermediate models are solved for each population n.
We denote by j ≡ j(n) the population of an intermediate model solved when the current population is n.
The related network structure is specified by a multiplicity vector m ≡ (m1, . . . , m k , . . . , mq) such that, for each queue type k, 1 ≤ k ≤ q, the intermediate model contains m k ≥ 1 queues of that type [3,10,23,24].
Here q, q ≤ M , is the number of queue types for the current population.
The total number of queues is m = È q k=1 m k .
All m k queues of type k have identical loadings for the r nonempty classes.
With a slight abuse of notation, we denote by ρ ks the loading of class s jobs at queues of type k.
If not otherwise stated, we assume that for two queue types k and k 񮽙 such that k 񮽙 = k 񮽙 there exists at least one class s, 1 ≤ s ≤ r, such that ρ ks 񮽙 = ρ k 񮽙 s .
Hence, each queue type defines a balanced subnetwork of maximum size.
Note that by this definition q ≡ q(r), and q is non-decreasing with r.We call input network a network that has the same M queues of the model that we want to solve recursively, but with population not necessarily equal to N.
The structure of the input network for the current population n is denoted by M ≡ (M1, . . . , M k , . . . , Mq), where È q k=1 M k = M .
Very often, intermediate model structure will be specified using M. For instance, an intermediate model with multiplicity vector m = M + eq can be obtained by adding to the input network with population n a queue of type q.For the rest of the paper, if not otherwise stated, k, s, c, 1 ≤ k ≤ q, 1 ≤ s ≤ r, 1 ≤ c ≤ r − 1, will index queue types and non-empty classes.
As a summarizing example, let us assume that we want to solve recursively a model with M = 3, R = 2, N = (8, 13), delays ρ01 = 3, ρ02 = 7, and loadings ρ11 = 10, ρ12 = 5,(1,0) (0,1) (1,1) (2,0) (0,2) (2,1) (0,3) (1,2) (2,2) (2,3) (1,3) (0,0) a) prod(N) (0,0) (1,0) (2,0) (2,1) (2,2) (2,3)b) lin(N) Figure 1: Population sets for N = (2, 3) ρ21 = 10, ρ22 = 9, ρ31 = 10, ρ32 = 9.
For illustration purposes, we recursively process, for each n ∈ lin(N), a set of 2(q + 1) intermediate models (m, j) with multiplicitym ∈ {M, M + e1, . . . , M + eq},(3)and populationj ∈ {n, n − er}.
(4)By the definitions, we have the following cases:• if 1 ≤ n1 ≤ 8 and n2 = 0 then r = 1.
In this case all queues have identical loadings, thus q = 1, ρ01= 3, ρ11 = 10, M = 3e1, (m, j) ∈ {(3e1, n1e1), (3e1, n1e1 − e1), (4e1, n1e1), (4e1, n1e1 − e1)}.
• If 1 ≤ n1 ≤ 8 and 1 ≤ n2 ≤ 13 then r = 2, q = 2, ρ01 = 3, ρ02 = 7, ρ11 = 10, ρ12 = 5, ρ21 = 10, ρ22 = 9,M = e1 + 2e2, (m, j) ∈ {(e1 + 2e2, n1e1 + n2e2), (e1 + 2e2, n1e1 + n2e2 − e2), (2e1 + 2e2, n1e1 + n2e2), (2e1 + 2e2, n1e1 + n2e2 − e2), (e1 + 3e2, n1e1 + n2e2), (e1 + 3e2, n1e1 + n2e2 − e2)}.
Models for n = 0 are solved using termination conditions specified later.
Thus, we do not define a specific notation.
We denote by G ≡ G(m, j) the normalizing constant of a model with multiplicity m and j = (j1, . . . , js, . . . , jr, 0, . . . , 0) jobs.
From the BCMP theorem [2], it follows thatG = 񮽙 m 񮽙 i=0 fi(ji),(5)where the summation is taken on the state-spacé(j0, . . . , ji, . . . , jm) | m 񮽙 i=0 jis = js, jis ≥ 0, 1 ≤ s ≤ r µ ,where ji = (ji1, . . . , jis, . . . , jir), is the population at station i, and the product-form factors fi for queues and delays (the latter is associated to the index i = 0) are defined asfi(ji) = ´ É s ρ j 0s 0s /j0s!
, if i = 0, ( È s jis)!
É s ρ j is is /jis!
, if 1 ≤ i ≤ m.(6)Note that the number of operations required by (5) Throughout the paper, we consider the following normalizing constant recurrence equations.
The convolution expressions [5,33] for G, i.e.,G = G −k + r 񮽙 s=1 ρ ks Gs, 1 ≤ k ≤ q,(7)and for G +k , i.e.,G +k = G + r 񮽙 s=1 ρ ks G +k s , 1 ≤ k ≤ q.(8)Note that, without loss of generality, we consider only q convolution expressions among the m possible, referring to the removal of any of the identical queues of type k.We also introduce the network population constraints for the models with j = n, i.e.,nsG = ρ0sGs + q 񮽙 k=1 m k ρ ks G +k s , 1 ≤ s ≤ r.(9)which are an application of Little's Law [30], and generalize to the case m k > 1 a similar set of equations presented in [32].
A straightforward proof of (9) is given at the end of this section.
Termination conditions for recursions based on (7)-(9) are G = f0(j), for normalizing constants of models with m = 0, and G = 1, for normalizing constants of models with j = 0.
The conditions are consistent assuming 0 0 = 1.
Performance measures can be computed using the following formulas [33] for the mean throughput of class s Xs(m, j) = Gs/G,and for the mean class s queue length for queues of type kQ ks (m, j) = ρ ks G +k s /G.(11)Related measures, as utilizations or response times, can be easily obtained from the above measures (e.g., [29]).
Note that a straightforward proof of (9) follows by inserting (10) and (11) for j = n into the population constraint for a closed model [25], given by ns = ρ0sXs(m, n) + È k m k Q ks (m, n).
This motivates the choice of the name for (9).
This section introduces the new solution approach based on linear systems of normalizing constant recurrence equations.
In order to prepare background for the new algorithm, we reformulate popular computational algorithms for closed networks as linear systems of normalizing constant recurrence equations.
Most exact algorithms for product-form networks compute normalizing constants using the linear recurrence equations (7)-(9).
In general, a solution can be obtained by different techniques.
We propose a novel approach where, for each population n considered by the recursion, a vector g ≡ g(n) of normalizing constants of intermediate models is computed using a linear system of equations (7)-(9).
The elements of g change with the considered algorithm, and will be described later.
Due to the linearity of (7)- (9), the technique takes the form of a sequence of linear systemsAg = r 񮽙 s=1 Bsgs,(12)where the matrix A ≡ A(n) describes the linear dependencies between the variables in g, the gs ≡ g(n − es) vectors are computed recursively, and the Bs ≡ Bs(n) matrices determine the linear system known terms from the gs vectors.In general, if n ∈ lin(N), then Bs is the zero matrix for 1 ≤ s ≤ r − 1.
Therefore, from (12) it follows that the recursive solution of queueing network models using a sequence of linear systems requires to select:1.
the set of processed populations n, typically either lin(N) or prod(N),2.
the elements of the g vector for all processed n,3.
the mix of equations (7)- (9) such that A is an invertible matrix and hence (12) has a unique solution.In the next sections, we show how to reformulate popular computational algorithms in the form (12).
We begin with an analysis of the Convolution algorithm.
In the convolution approach, (7) is considered for an arbitrary queue k, and recursively applied to the constants G −k and Gs in the right hand side until the network contains queues or jobs.
Hence, a linear system reformulation may consider, for all n ∈ prod(N), a vector g composed by the normalizing constants of intermediate models (m, j) with population j = n and multiplicitym ∈ {M, M − eq, M − 2eq, . . . , M − Mqeq, M − Mqeq − eq−1, M − Mqeq − 2eq−1, . . . , e1, 0}.
The number of intermediate models considered for each n is thus card(g) = M + 1.
For each n ∈ prod(N), the mix of equations for (12) is񮽙 G − G −k = r È s=1 ρ ks Gs,(13)that is the set of all possible equations (7) such that1.
the unknown normalizing constants in the left hand side are all elements of the g vector, 2.
the normalizing constants in the right hand side are known terms belonging to the gs vectors, which are recursively computed.Thus, looking at (12), the A matrix is defined by the coefficients of the normalizing constants in the left hand sides, while the Bs matrices depend on the right hand sides only.
This notation will be used throughout the rest of the paper.As an example, a model with M = 3 queues, q = 3 queue types, and no delays can be solved by means of the following linear system¾ 񮽙 񮽙 1 −1 0 0 0 1 −1 0 0 0 1 −1 0 0 0 1 ¿ 񮽙 񮽙 ¾ 񮽙 񮽙 G G −3 G −2,3 G −1,2,3 ¿ 񮽙 񮽙 = r 񮽙 s=1 ¾ 񮽙 񮽙 ρ 3s Gs ρ 2s G −3 s ρ 1s G −2,3 s 0 ¿ 񮽙 񮽙,where we used the termination condition for m = 0 in the last equation.
It is clear from the example that the Convolution algorithm has a coefficient matrix independent of both population and loadings, and that is always invertible.
We now show a first application of linear systems of normalizing constant recurrence equations.
We modify the Convolution algorithm by introducing new equations.
We consequently modify the linear system and the recursive structure of the algorithm to account for the new unknowns.In general, it is quite difficult to integrate, at least in an efficient manner, (8) and (9) within (13), since they introduce several new G +k unknowns.
Instead, it may be helpful to include additional convolution expressions (7) for different choices of k.We consider a system of equations (7) for all 1 ≤ k ≤ q.
In this case, the normalizing constants in g are of intermediate models (m, j) with population j = n and multiplicity{m | 0 ≤ m ≤ M}.
(14)Thus card(g) = É q k=1 (m k + 1).
Considering the same example seen before, and omitting G −1,2,3 = 0, we have now ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 1 −1 0 0 0 0 0 1 0 −1 0 0 0 0 1 0 0 −1 0 0 0 0 1 0 0 −1 0 0 0 1 0 0 0 −1 0 0 0 1 0 −1 0 0 0 0 1 0 0 0 −1 0 0 0 1 0 −1 0 0 0 0 1 0 0 −1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G G −1 G −2 G −3 G −1,2 G −1,3 G −2,ρ 3s G −1 s ρ 1s G −2 s ρ 3s G −2 s ρ 1s G −3 s ρ 2s G −3 s ρ 3s G −1,2 s ρ 2s G −1,3 s ρ 1s G −2,3 s ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ,which is an overdetermined linear system with 12 equations and just 7 unknowns.
Therefore, using the additional equations, and provided that the resulting matrix is invertible, we may avoid to recursively evaluate some terms of the right hand side by moving them into the vector of unknowns.
For instance, let us assume r = 2 and observe that the constants G −1,2 , G −1, 3 and G −2,3 are the normalizing constants of networks with a single queue and no delays, thus equal to the product-form factors f3, f2 and f1, respectively.
Considering as new unknowns the normalizing constants G1 and G −k 1 , 1 ≤ k ≤ 2, and reducing the matrix to square by dropping unnecessary variables and equations, we get ¾ 񮽙 񮽙 񮽙 񮽙 񮽙1 −ρ 11 −1 0 0 0 1 −ρ 21 0 0 −1 0 0 0 1 −ρ 21 0 0 0 0 1 −ρ 31 0 0 0 0 0 0 1 −ρ 11 0 0 0 0 1 −ρ 31 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 G G 1 G −1 G −1 1 G −2 G −2 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 = ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 ρ 12 G 2 ρ 22 G 2 f 3 + ρ 22 G −1 2 f 2 + ρ 32 G −1 2 f 3 + ρ 12 G −2 2 f 1 + ρ 32 G −2 2 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 ,which has a unique solution if all loadings of class 1 are distinct.
Thus, with the inclusion of additional convolution expressions we found a way to avoid the recursion on classthe original algorithm to the just N1 + N2 + 1 of the new formulation.
This clearly leads to significant computational savings for models with large population sizes.
Nevertheless, new overheads are introduced for linear system solution (e.g., the cost of LU factorization [20]).
However, the main problem is that, even if the result generalizes easily to models with a larger number of queues, for r > 2 the increased number of unknowns typically makes impossible to process a lin(N) population set, and this is intrinsically related to the use of (7) in the linear system.
Since the scope of the present paper is to develop a general lin(N) recursion, we shall not consider the proposed variant of the Convolution algorithm in the following sections, as well as the inclusion of (7) in linear systems.
In this section, we discuss the relation between RECAL [13] and a lin(N) recursion based on (9) for s = r.
We begin by first reviewing RECAL.
In this algorithm, each queue is univocally associated to a special class, called selflooping class, composed by jobs looping indefinitely through the station.
Queues have to be changed into load-dependent stations in order to serve self-looping jobs.
The advantage is that the normalizing constant can then be computed using the following efficient class recursion.
Let (15) be the set of combinations with repetition of k elements among n, which has cardinality card(D n k = {(d1, . . . , dn) | 񮽙 t dt = k, dt ≥ 0, 1 ≤ t ≤ n}D n k ) = n+k−1 k ¡ .
Then, the normalizing constant h(v, j) of a network with M queues, a delay server, population vector v for the M self-looping classes, and current population j = n for the remaining r classes, satisfies the following recurrence equationh(v, n) = 񮽙 d∈D M +1 nr c(v, d)h(v + d, n − nrer),(16)whered ≡ (d0, d1, . . . , d k , . . . , dM ), c(v, d) = ρ d 0 0r d0!
M 񮽙 k=1 񮽙 v k + d k v k 񮽙 ρ d k kr ,(17)and with termination condition h(v, 0) = 1 for all v. Note that the normalizing constant of the input network with population N and no self-looping classes is immediately obtained by computing h(0, N) with (16).
Furthermore, if ρ0r = 0, then the summation is on (d1, . . . , dM ) ∈ D M nr .
We remark that we did not mention the m vector since RECAL assumes that the number of queues in a model is always equal to M , and that intermediate models differ only for the number of self-looping jobs and non-empty classes.
Hence, RECAL has no queue recursions.
However, we show that a different interpretation of (16) is possible, as proved by the following theorem.
Theorem 1.
Let q ≡ M for all populations, and let each type k, 1 ≤ k ≤ M , be composed by m k identical queues with loadings equal to those of queue k, 1 ≤ k ≤ M , of the input network.
Then, the recursive insertion nr − 1 times of (9) for class r into all its right hand side normalizing constants gives (16) by setting v k = m k − 1, 1 ≤ k ≤ M .
Informally, Theorem 1 states that (16) is equivalent to the class-r population constraint, provided that the M queues in the input network are never aggregated into the same queue type.
Furthermore, the theorem has the important consequence of showing that, from the relation v k = m k − 1, the addition of self-looping jobs at queue k is equivalent to the insertion of new queues into the balanced subnetwork k. Therefore, two very different physical interpretations of RECAL may be considered.Moreover, Theorem 1 shows that the definition of queue types implicitly assumed in RECAL differs from that adopted in Section 2.1.
But since our queue type definition, which aggregates maximal balanced subnetworks into a single type, is indeed the most efficient for models with a large number of identical queues, we conclude that RECAL can be largely improved in this case, as recently shown by [24].
A possible approach to address the problem consists in recursively solving (9) for class r using the queue type definition that aggregates maximal balanced subnetworks.
Note that the artifice of considering single-job classes in order to reduce computational costs may also be applied to (9).
From the above observations, we have the following linear system reformulation of RECALÒ nrG = ρ0rGr + È q k=1 m k ρ kr G +k r ,(18)for a set of populations n ∈ lin(N), and where the left hand side unknowns refer to intermediate models (m, j) having population j = n and multiplicitym ∈ ¨ M + (d1, . . . , dq) | (d0, d1, . . . , dq) ∈ D q+1 N−n © , with card(g) = q+N−n N−n ¡.
Thus, the cardinality of g increases while recurring on populations.
The extension of (18) by including (8) into the linear system leads us to consider the LBANC algorithm.
The LBANC algorithm [9] has been shown in [27] to be the unnormalized version of the MVA algorithm [34].
The computational requirements of the two methods are very similar, and the main difference is that LBANC uses normalizing constants, while MVA works directly with mean performance indices.Concerning linear systems of normalizing constant recurrence equations, LBANC illustrates a simultaneous use of (8) and (9).
The population recursion is n ∈ prod(N), and the formulation of LBANC discussed in [27] can be reformulated as the following linear system´Gsystem´ system´G +k − G = È s ρ ks G +k s , 1 ≤ k ≤ q, nrG = ρ0rGr + È k m k ρ kr G +k r ,(19)where the left hand side unknowns have population j = n and multiplicitym ∈ {M, M + e1, . . . , M + eq}.
(20)Therefore, LBANC computes card(g) = q + 1 constants at each population, and it is substantially more efficient than convolution when q << M, an advantage that has not been previously pointed out in the literature.
Another advantage of LBANC is the direct availability of the terms G +k s for (11), which are instead computed in the Convolution algorithm with additional recursions.
Nevertheless, the main source of complexity in both LBANC and Convolution remains the prod(N) population recursion.
The inclusion of new equations into the linear system (19) in order to reduce computational costs is addressed in the next section.
We initially assume that ρ0s = 0, 1 ≤ s ≤ r − 1.
The definition of the new algorithm starts by observing that the inclusion of the r − 1 population constraints for the non-empty classes s 񮽙 = r into (19) does not introduce new unknowns and may increase the number of independent equations in the linear system.
Thus, these additional equations have the potential to significantly reduce the cost of computing normalizing constants.
In particular, as we prove later, if a certain set of equations (8)- (9) is considered, and provided that the resulting linear system is non-singular, then we can solve models using an efficient lin(N) recursion with very different computational tradeoffs with respect to existing algorithms.We can show that the above observations hold true also for the general case where we drop the ρ0s = 0 conditions.
Despite now the additional population constraints introduce new unknowns into the linear system, i.e., the Gc constants for 1 ≤ c ≤ r − 1, we can always exploit the fact that these constants refer to models with jr = nr jobs of class r.
This allows us to include into the system also the class r population constraints for the models with j = n − ec, i.e.,nrGc = ρ0rGc,r + q 񮽙 k=1 m k ρ kr G +k c,r , 1 ≤ c ≤ r − 1,(21)which allow to compute the new unknowns directly from gr.
Hence, the inclusion of the new Gc unknowns is compensated by the availability of additional class r population constraints.Finally, we point out that in general the considered linear systems may not have necessarily full rank, but for the sake of simplicity in presenting, we initially take this assumption.
Singularity conditions will be discussed in Section 5.2.2, as well as strategies to address the problem.
We now illustrate some difficulties arising when including (8) and (9) into a linear system with the aim of defining a lin(N) recursion.
We consider a linear system relating normalizing constants of models with multiplicity m ∈ {M, M+e1, M+e2} and population j ∈ {n, n−e1}.
Assume that the current population n is such that r = 2 and q = 2.
We have that the linear system defined by (8), 1 ≤ k ≤ q, and (9), 1 ≤ s ≤ r, for a lin(N) recursion isAg = B2g2,(22)whereAg ≡ ¾ 񮽙 񮽙 񮽙 1 −ρ 11 0 0 −1 0 0 0 1 −ρ 21 −1 0 0 −M 1 ρ 11 0 −M 2 ρ 21 n 1 −ρ 01 0 0 0 0 n 2 0 0 0 0 0 0 n 2 ¿ 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 G +1 G +1 1 G +2 G +2 1 G G 1 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 , B2g2 ≡ ¾ 񮽙 񮽙 񮽙 (22) is underdetermined, having more unknowns than equations.
This indicates that the considered system of equations (8)-(9) may be insufficient for a population recursion in lin(N).
Thus, a different approach is required to take full advantage of the additional population constraints.ρ 12 0 0 0 0 0 0 0 ρ 22 0 0 0 0 0 0 0 0 0 M 1 ρ 12 0 M 2 ρ 22 0 ρ 02 0 0 M 1 ρ 12 0 M 2 ρ 22 0 ρ 02 ¿ 񮽙 񮽙 񮽙 ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G +1 2 G +1 1,2 G +2 2 G +2 1,2 G 2 G 1,2 ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 , Note that We propose to solve closed multiclass product-form networks using a population recursion in lin(N).
For each recursively processed n ∈ lin(N), we compute the following vector of unknownsg = 񮽙 G + G 񮽙 ,(23)where G is a vector of normalizing constants of intermediate models (m, j) having population j ∈ {n, n−e1, . . . , n−er−1} and multiplicitym ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ D q r−1 }.
(24)Instead, G + includes all normalizing constants that can be obtained by adding a queue k, 1 ≤ k ≤ q, to the normalizing constants in G, i.e.:G + ≡ {G +k , G +k 1 , . . . , G +k r−1 | 1 ≤ k ≤ q, {G, G1, . . . , Gr−1} ⊆ G}.
(25)Thus, G + includes constants of intermediate models (m + , j) with population j ∈ {n, n−e1, . . . , n−er−1} and multiplicitym + ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ D q r }.
(26)We denote by G + r and Gr the components of gr.
Note that by the definitions, g has cardinalitycard(g) = card(G + ) + card(G) = 񮽙 q + r − 1 r 񮽙 r + 񮽙 q + r − 2 r − 1 񮽙 r,(27)which is independent of population sizes.
Thus, for fixed r and q, g and gr have identical cardinality, and the linear system order does not increase with n.For the current population n, g is computed from gr by the following linear system: 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙G +k − G − r−1 È c=1 ρ kc G +k c = ρ kr G +k r , 1 ≤ k ≤ q ncG − ρ0cGc − q È k=1 m k ρ kc G +k c = 0, 1 ≤ c ≤ r − 1 nrG = ρ0rGr + q È k=1 m k ρ kr G +k r , nrGc = ρ0rGc,r + q È k=1 m k ρ kr G +k c,r , 1 ≤ c ≤ r − 1(28)where{G +k , G +k c } ⊆ G + , {G, Gc} ⊆ G, {G +k r , G +k c,r } ⊆ G +r , and {Gr, Gc,r} ⊆ Gr.
We denote the four groups of equations, from the top, by (28a), (28b), (28c) and (28d).
We motivate the linear system by the following two observations:• for each n, we can directly compute all normalizing constants in G from gr by (28c)-(28d).
• Once that G has been computed, we can determine G + by solving the subsystem (28a)-(28b).
Thus, the solution of (28) As a consequence of this result, if the coefficient matrix A is non-singular, the system is never underdetermined and (28) has a unique solution.
It is important to point out that (24)-(26) define the smallest cardinality vectors for which the above theorem holds, but other definitions of G and G +k may also be considered.
Numerical conditioning, singularity, and block triangular form of the coefficient matrix of (28) are discussed in Section 5.
We now show a small example of (28).
We consider the same model of Section 4.1.1.
We have q = 2 and r = 2, and so g depends onD q r−1 = D 2 1 = {(1, 0), (0, 1)} and D q r = D 2 2 = {(2, 0), (1, 1), (0, 2)}.
In particular, we have g = ¢ G + G £ T with G + = ¢ G +1,1 G +1,1 1 G +1,2 G +1,2 1 G +2,2 G +2,2 1 £ T , (29) G = ¢ G +1 G +1 1 G +2 G +2 1 £ T ,(30)and similarly gr = g2 = ¢ G + 2 G2£ T whereG + 2 = ¢ G +1,1 2 G +1,1 1,2 G +1,2 2 G +1,2 1,2 G +2,2 2 G +2,2 1,2 £ T ,(31)G2 = ¢ G +1 2 G +1 1,2 G +2 2 G +2 1,2 £ T .
(32)Let Compared to the linear system of Section 4.1.1, the coefficient matrix A is now square, and provided that it is nonsingular, we have a unique solution to the linear system.
Hence, a lin(N) recursion is now possible.t zks ≡ (M k + z)ρ ks , then (28) is Ag = B2g2,(33)G +1,1 G +1,1 1 G +1,2 G +1,2 1 G +2,2 G +2,2 1 G +1 G +1 1 G +2 G+2 The new algorithm has the following structure:1: Compute g(N 1 , 0, . . . , 0) 2: for r = 2 to R do 3:Initialize g(N 1 , . . . , N r−1 , 0, . . . , 0) for nr = 1 to Nr do Setup and solve (28) for n = (N 1 , . . . , N r−1 , nr, 0, . . . , 0)6: end for Computation of g(N1, 0, . . . , 0).
The recursion on the first class can be performed using single-class algorithms proposed in previous works (e.g., [5,9]).
Furthermore, under certain assumptions, single class normalizing constants can be computed using closed-form formulas (see, e.g., [3,22]), but exact arithmetic may be required to avoid numerical instabilities.Initialization of g(N1, . . . , Nr−1, 0, . . . , 0).
At each change of the value of r, also (23)- (28) change.
In particular, the order of the coefficient matrix grows with r, and this has the following implications:1.
the solution of the linear system becomes more expensive as r increases.
Hence, it is better to process the classes with the largest populations first, since they require the largest number of iterations.2.
At the first population processed after a r change, the vector G + (N1, . . . , Nr−1, 0, . . . , 0) is not available.
For instance, when r = 3 the first linear system solved requires G + (N1, N2, 0, . . . , 0) with multiplicity depending on the set D q 3 , but during recursion for r = 2 only intermediate models defined on D q 2 and D q 1 were solved.The second issue can be addressed as follows.
Let r be the new class to be processed, and assume nr = 1.
Note that the constants in G(n − er) = G(N1, . . . , Nr−1, 0, . . . , 0) are known from the recursion on class r − 1.
We compute the required G + (n − er) = G + (N1, . . . , Nr−1, 0, . . . , 0) from G(n − er) using the following linear system:񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 G +k − r−1 È c=1 ρ kc G +k c = G, 1 ≤ k ≤ q, − q È k=1 m k ρ kc G +k c = −ncG + ρ0cGc, 1 ≤ c ≤ r − 1(34)where {G, Gc} ∈ G(n − er), {G +k , G +k c } ∈ G + (n − er).
We point out that the matrix of coefficient of (34) is the coefficient matrix C for class r that we will introduce in the next section.Performance measures.
In order to compute performance measures by (10) and (11), we need to compute G, Gs, 1 ≤ s ≤ R, and G +k s , 1 ≤ k ≤ q, 1 ≤ s ≤ R, for the input network with population N. Note that the intermediate models solved by the linear system for n = N have multiplicity m ≥ M, thus computing performance measures requires to remove the queues added by (24)-(26).
This task has to be performed in different ways depending on network structure.
We have the following two cases: all delays ρ0s, 1 ≤ s ≤ R, are strictly positive; or there exist one or more classes with zero delay.
In the first case, we can recursively remove the queues added by (24)-(26) from the linear system solution for n = N using 񮽙 񮽙 񮽙 񮽙 񮽙G = G +k − È R s=1 ρ ks G +k s , 1 ≤ k ≤ q, Gs − Ns ρ0s G = − q 񮽙 k=1 m k ρ ks ρ0s G +k s , 1 ≤ s ≤ R.(35)Instead, in the second case we permute class indices so to process last all classes with ρ0s = 0.
Then if NR ≥ R, the required normalizing constants can be computed from g(N1, . . . , NR−1, NR − R) by recursive application of (9) for class R.
This also let us skip the solution of the last R linear systems (28).
Otherwise, the recursive solution of (9) comes to a point where the problem is recursively reduced to removing queues in the normalizing constants computed for class R − 1.
Thus, a recursive procedure can be used to compute performance measures in this case.
We now apply linear algebra techniques to simplify (28).
We begin by expressing the linear system in the form (12)A(nr)g = Brgr,(36)where A(nr) indicates that only the nr coefficients change in A while recurring on class r populations.
The main limitation of this dependence is that we cannot reuse the same LU factorization for linear systems depending on the same r. Nevertheless, we show that (23) implicitly defines A(nr) into an upper block triangular form that suggests a straightforward solution to the problem.
Note that in (28) the population nr multiplies all and only the constants in G. Therefore, (36) can be expressed using only population-independent matrices as񮽙 C A12 0 nrI 񮽙 񮽙 G + G 񮽙 = 񮽙 B1r B2r 񮽙 gr,(37)where I is the identity matrix of order G = n −1 r B2rgr,(38)and we only need to solve the linear systemCG + = B1rgr − A12G.
(39)The last two formulas prove that we can recursively solve (28) using matrices that in no way depend on nr.
In particular, only C requires a LU factorization, which can anyway be reused for all class r populations.
Furthermore, by inserting (38) into (39) we getCG + = B1r − n −1 r A12B2r ¡ gr,(40)and definingF1r ≡ 񮽙 C −1 B1r 0 񮽙 , F2r ≡ 񮽙 −C −1 A12B2r B2r 񮽙 ,where the zero matrix in F1r has size card(G) x card(gr), we may compactly reformulate (28) asg = F1r + n −1 r F2r ¡ gr, nr = 1, . . . , Nr.
(41)which is a set of recurrence equations in the nr variable.Despite that a block Gaussian elimination is typically more efficient than a recursive solution of (41), because F1r and F2r may not preserve the sparsity of C, this compact formulation may be of interest for theoretical reasons due to its simplicity.We also point out that an advantage deriving from the above results is that, if loadings and delays are all strictly positive, then the number and the placement of the non-zero coefficients in linear system matrices are fixed for all models with same q and r. Thus, it is possible to optimize the related data structures and algorithms by precomputation.
For instance, the position of the non-zeros in C may be easily precomputed.
Then, the matrix can be instantiated in an array of minimum size that can be accessed efficiently using hashing.
We also remark that linear system solvers perform the same operations and memory accesses for fixed q and r, and this may also be used to optimize implementations.
Direct solution methods for linear systems, e.g., Gaussian elimination, require a computational effort that is typically cubic with the order of the coefficient matrix [20].
Starting from this fact, we propose a decomposition of the coefficient matrix C into block triangular form that allows significant computational savings by reducing the order of linear systems.
Despite this is not required to grant the correctness of the results, it is useful to limit growth of time and storage requirements.The decomposition depends on a partitioning of the set D q r , which immediately implies by (24) a partitioning of G + and thus a decomposition of C.
We partition D q r so that combinations (d1, . . . , dq) with same position of nonzero elements are included into the same partition.
We denote by P ht the t-th partition composed by combinations with h non-zeros in the same position.
For example, D 3 3 can be partitioned into the sets P11 = {(3, 0, 0)}, P12 = {(0, 3, 0)}, P13 = {(0, 0, 3)}, P21 = {(1, 2, 0), (2, 1, 0)}, P22 = {(1, 0, 2), (2, 0, 1)}, P23 = {(0, 2, 1), (0, 1, 2)}, P31 = { (1, 1, 1)}.
So G + becomesG + = G + (P11) ∪ G + (P12) ∪ . . . ∪ G + (P31).
(42)where each subset G + (P ht ) contains normalizing constants of intermediate models (m ht , j) with population j ∈ {n, n − e1, . . . , n − er−1} and multiplicitym ht ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ P ht }.
(43)Note that, by definition of D q r , the number of non-zeros elements h must range in 1 ≤ h ≤ H whereH ≡ min{q, r}.
(44)Further, note that the number of possible choices for the positions of the h non-zero elements is which is an application of Vandermonde's convolution [11], and summarizes the effects of the partitioning.
We also remark that in (28) two normalizing constants in G + appear in the same equation only if they refer to models differing by at most one queue assigned to different types.
This means that non-zero coefficients in C can relate either normalizing constants of the same G + (P ht ), or constants depending on P ht and P h 񮽙 t with |h − h 񮽙 | = 1.
Thus, permuting the columns of C to reflect the partitioning of G + , and in particular sorting columns according to the number of non-zeros, we get the block triangular formC ≡ ¾ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 C1 C12 0 . . . 0 0 0 C2 C23 . . . 0 0 0 0 C3 . . . 0 0 . . . . . . . . . . . . . . . . . . 0 0 0 . . . CH−1 CH−1,H 0 0 0 . . . 0 CH ¿ 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 񮽙 ,(48)whereC h ≡ diag(c h1 , c h2 , . . . , c ht , . . .), 1 ≤ h ≤ H,(49)is a diagonal matrix of Preliminary implementations of the proposed algorithm suggest that roundoff errors tend to accumulate while iterating on populations [19].
Even on models where C is numerically well conditioned (i.e., has a low condition number [20]), the computation typically fails if the network contains more than few tens of jobs.In order to address the problem in a simple and effective way, we propose to exactly solve (e.g., [6]) all linear systems (28).
This means that exact arithmetic has to be adopted throughout all computations.
If this is implemented using rational multiprecision arithmetic libraries (e.g., [18,21]) all digits of operands are kept, and no roundoff is performed.
Despite the additional digits introduce some overheads, exact rational arithmetic does not suffer any kind of numerical instability.
So we also avoid underflow or overflow problems that typically affect normalizing constant evaluations.
Moreover, nowadays multiprecision libraries (e.g., GMP [21]) offer very good performance for operands with thousands of digits, as we expect in normalizing constants of large models.
Other techniques for exact linear algebra may also be adopted, e.g. modular arithmetic [31] that also provides a natural way for parallelizing linear system solution.
We point to Section 6 for a discussion on the cost of adopting exact multiprecision arithmetic.
We now consider conditions that produce a singular C matrix, and discuss possible solutions.
Noting that the loadings for class R are never included in C, we identify the following critical cases:1.
there exist one or more queue types k with ρ kc = 0 for some c 񮽙 = R.
This condition yields columns of all zeros in C. Thus, some unknowns of g are not included into any equation.2.
There exist linear relations between loadings that let some C h blocks become singular.The first case can be easily addressed by removing the unknowns in G + associated with the zero columns.
The resulting system is overdetermined and still admits a unique solution.The second case is more difficult, because dependencies between loadings may result in a singular C matrix.
For instance, there exist singular diagonal blocks if two queue types k1 and k2 have ρ k 1 c = ρ k 2 c for some 1 ≤ c ≤ r−1.
Singularity conditions can be enumerated by a symbolic computation of the determinants of the C h blocks.
For instance, the C3 diagonal block for q = 3, r = 3 isC 3 = ¾ 񮽙 1 −ρ 11 −ρ 12 1 −ρ 21 −ρ 22 1 −ρ 31 −ρ 32 ¿ 񮽙 , (50)which has determinant det(C3) = ρ21ρ32 +ρ12ρ31 +ρ22ρ11 −ρ22ρ31 −ρ11ρ32 −ρ12ρ21.Considering ρ11, we see that for ρ22 񮽙 = ρ32 the valueρ11 = ρ22ρ31 − ρ21ρ32 + ρ12ρ21 − ρ12ρ31 ρ22 − ρ32 (51)gives a zero determinant.
Note that the complexity of singularity conditions grows quickly with block order (e.g., the determinant of the C4 block for q = 4 and r = 4 includes over 60 product terms).
So, a numerical diagnosis of singularity is recommended in implementations.
We propose to address singularity by moving back into the vector of known terms the unknowns responsible for the singularity of (28).
This means that an hybrid population recursion has to be performed, where some normalizing constants are computed from linear systems, while the remaining ones are recursively evaluated.
For instance, if the normalizing constants G +k c and G +k c of the last t classes are moved back to the right hand side of (28), then we can solve the model for all populations in prod(NR−t+1, . . . , NR) using lin(N1, . . . , NR−t) recursions.
In this way, the new normalizing constants in the right hand side are directly available from previous recursions.
Finally, the recursion for the last population (NR−t+1, . . . , NR) solves the input network with population N.
The computational cost in presence of a singular coefficient matrix is thus an intermediate case between that for non-singular systems and that of existing prod(N) recursions.
Finally, we discuss the computational requirements of the proposed algorithm.
In particular, we consider the cost of solving the sequence of systems (39).
This task is typically several orders of magnitude slower than all other operations, e.g., (38) and the computation of performance measures.
Throughout this section, we assume to use LU factorization, forward and back substitution [20] to solve (39).
Since the additional complexity due to numerical stabilization is not a theoretical limit to the performance of the proposed algorithm, but rather characterizes the best currently available stable implementation, we first quantify the cost of solving the sequence of linear system regardless of accuracy of solutions.
Then, we discuss the asymptotic cost of adopting an exact linear system solver in implementations.
Let LU t(θ) 񮽙 (2/3)θ 3 and LU s(θ) 񮽙 θ 2 be respectively the number of operations and the storage required by a LU factorization of a full-rank square matrix of order θ.
Similarly, let BSt(θ) 񮽙 2θ 2 be the total number of operations of forward and back substitution.
Assume that C is in the form (48), and denote by θ rh ≡ r−1 r−h ¡ r the order of the diagonal blocks c ht when there are r non-empty classes.
Then, from the consideration in Section 5.1.1, the time requirement is of the order ofR 񮽙 r=1 H 񮽙 h=1 񮽙 q h 񮽙 񮽙 LU t(θrh) + Nr 񮽙 nr =0 BSt(θ rh ) 񮽙 񮽙 2 R 񮽙 r=1 H 񮽙 h=1 񮽙 q h r − 1 r − h 񮽙 r 񮽙 2 񮽙 1 3 񮽙 r − 1 r − h 񮽙 r + Nr + 1 񮽙 < 2 R 񮽙 r=1 H 񮽙 h=1 q h h! 񮽙
r h (h − 1)! 񮽙
2 񮽙 r h (h − 1)!
+ Nr + 1 񮽙 ,(52)where the case nr = 0 accounts for the initialization of g after a r change, and H ≡ min{q, r}.
Note that the formula is typically an upper bound, because it does not account for the computational savings due to the sparsity of C. Moreover, assuming to keep in memory only the LU factorizations for the current value of r, storage requirement is maximum for r = R, and it is of the order ofH 񮽙 h=1 񮽙 q h 񮽙 LSs(θ Rh ) 񮽙 H 񮽙 h=1 񮽙 q h R − 1 R − h 񮽙 R 񮽙 2 < H 񮽙 h=1 q h h! 񮽙
R h (h − 1)! 񮽙
2 , (53)which is independent of population sizes.
If we adopt in implementations an exact solver based on rational multiprecision arithmetic, then we have to account also for the increasing costs of arithmetic operations.
Thus, we have in general that the time and storage requirements have to be specified as LU t(θ) ≡ LU t(θ, n), LU s(θ) ≡ LU s(θ, n), and BSt ≡ BSt(θ, n).
The exact number of operations required by multiprecision arithmetic strongly depends with implementations, thus we limit to study asymptotic behaviors.
Because the number of digits of the coefficients in C is constant, operations required to solve (39) have computational requirements that grow with the number of digits of the unknowns in g and gr.
Let us assume all loadings to be scaled to integers [26], and let us assume to keep with small overheads a common denominator between the variables, e.g., n1!
· · · nr!
for the normalizing constants in g, and n1!
· · · nr−1!
(nr − 1)!
for those in gr.
Then, the time cost of rational arithmetic operations grows linearly with the number of digits of the numerator, while storage depends by both the size of numerators and of the common denominator.
Taking the logarithm of (5) in the worst-case of a model with balanced m 񮽙 queues, integer loadings all equal to ρ ≡ max k,s {ρ ks }, 0 ≤ k ≤ q, and population n, we get the following expression log G = log n!m 񮽙 +n−1 n ¡ ρ n n1!
· · · nr!
< log (m 񮽙 + n − 1) n ρ n n1!
· · · nr!
,(54)where both numerators and denominators of the logarithm argument are integers.
Thus, we see that the growth of the number of digits of the numerator of G is O(n log(m 񮽙 + n)).
Thus, for the constants in g, which have m 񮽙 ≤ M + r + 1 accounting also the product-form factor of the delay, the time and storage overhead of exact arithmetic grows at most as O(n log(M + r + n)), which may be regarded as a scale factor for the computational cost in the case without stabilization.
Time and storage complexity formulas prove that the presented algorithm is very efficient for large population sizes, even accounting for stabilization.
In particular, assuming constant q, M and R, and considering Ns = κ for all classes, we have that the time requirements grow for κ → +∞ as O(κ), or O(κ 2 log κ) accounting also for numerical stabilization, while under the same conditions the Convolution, LBANC, and the MVA algorithms are approximately O(κ R ).
Similarly, RECAL and other efficient class recursions (e.g, [16,23,24]) require for large population sizes approximately O(κ M ) or O(κ q ) time.
Similarly, accounting for stabilization, the storage requirement of the algorithm, grows as O(κ log κ), that is typically several orders of magnitude smaller than existing algorithms.
Therefore, the proposed approach may provide substantial computational savings for models with large populations.
Finally, we compare the efficiency of the proposed algorithm with respect to existing techniques by a numerical example.
We solve a model with N = 6000 jobs, M = 25 queues, q = 3 queue types for all populations, and R = 6 classes.
The loadings ρ ks for the considered model are given in Table 1.
In the example, the multiplicities M k never change during recursions.
Since complexity formulas for RE-CAL are available only for the case with no delays [13], for the purpose of comparison we set ρ0s = 0 for all classes.We used a preliminary implementation of the algorithm written in C, and based on the exact rational arithmetic routines of the GMP library [21] version 4.1.4.
The algorithm was run on a AMD Athlon64 3000+ processor using the 32-bit mode.
The solution of the linear system in block triangular form was performed by reusing the same LU factorization for all populations of class r.
The computed normalizing constant was G(N) = 1.21173 × 10 11328 .
Since we used exact arithmetic, all digits of G were available at the end of the computation.
We also determined throughputs and queue-lengths for all classes and queues.
For instance, the throughput of class 2 is X2(N) = 1.45435 × 10 −2 jobs per second, while the average class 1 queue-length at queues of type 1 is Q11(N) = 2.45426 jobs.Accounting multiprecision overheads and all operations not modeled by (52), the solution was obtained in 173s.
On the considered architecture this is approximately 10 11 operations.
During execution, the amount of allocated memory was always less than 20 MBytes, also thanks to the use of specialized data structures for sparse matrices.
For the same model, the theoretical number of operations of LBANC is 񮽙 10 19 , 񮽙 10 20 for Convolution, and 񮽙 10 71 for RECAL.
Therefore, compared to the other methods, the proposed algorithm is the only computationally feasible on the considered example.
We presented a new efficient exact algorithm for computing normalizing constants of closed multiclass product-form networks.
The method is based on the new powerful concept of linear systems of normalizing constant recurrence equations, which may indicate further research developments in the area.An example presented in the paper shows that the new algorithm can be several orders of magnitude faster than existing techniques on models with large populations.
A comparison on non-asymptotic populations, as well as on models with large number of queue types and classes, is left as future work.It is currently not clear whether the results presented in the paper may be extended to the load-dependent case.
Lack of results concerning the generalization of (8)-(9) to the loaddependent case makes it difficult to establish whether such extension is possible.
In particular, the lack of a suitable generalization of (11) to the load-dependent case seems to be the main issue.
Additional material of interest for this work can be found in [7].
I wish to thank my advisor, prof. G. Serazzi, for his help and continuous support of my research.
I thank J. Anselmi and the anonymous SIGMetrics reviewers for suggestions that substantially helped in increasing the quality of the paper.
I am also in debt with prof. P. Cremonesi for useful discussions.
I thank D. Ardagna, M. Roveri, C. Spelta and S. Zanero for constructive comments.
X Proof of Theorem 1We show that the recursive unfolding of (9) where G(m + d, n − nrer) refers to a model with class r less,is the number of recursions that terminate with G(m + d, n − nrer) in the right hand side, and mis the rising factorial.
We get (16) noting that (d0 + . . . + dM )!
= nr!
, and setting Proof of Theorem 2Note that we can compute from gr each constant in G using a class r population constraint of (28).
Therefore, we only need to prove that the number of equations (28a) and ( Proof of Theorem 3By definition, each block c ht ⊆ C h has coefficients of constants in G + (P ht ).
Thus, the number of columns of c ht isNote that we can remove at most h stations from m ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ P ht } so that the resulting model is in (24).
Hence, the number of convolution expressions is card(P ht )h = We show that the recursive unfolding of (9) where G(m + d, n − nrer) refers to a model with class r less,is the number of recursions that terminate with G(m + d, n − nrer) in the right hand side, and mis the rising factorial.
We get (16) noting that (d0 + . . . + dM )!
= nr!
, and setting Note that we can compute from gr each constant in G using a class r population constraint of (28).
Therefore, we only need to prove that the number of equations (28a) and ( By definition, each block c ht ⊆ C h has coefficients of constants in G + (P ht ).
Thus, the number of columns of c ht isNote that we can remove at most h stations from m ∈ {M + (d1, . . . , dq) | (d1, . . . , dq) ∈ P ht } so that the resulting model is in (24).
Hence, the number of convolution expressions is card(P ht )h =
