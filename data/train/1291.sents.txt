Firewalls are critical components of network security and have been widely deployed for protecting private networks.
A firewall determines whether to accept or discard a packet that passes through it based on its policy.
However, most real-life firewalls have been plagued with policy faults, which either allow malicious traffic or block legitimate traffic.
Due to the complexity of fire-wall policies, manually locating the faults of a firewall policy and further correcting them are difficult.
Automatically correcting the faults of a firewall policy is an important and challenging problem.
In this paper, we make three major contributions.
First, we propose the first comprehensive fault model for firewall policies including five types of faults.
For each type of fault, we present an automatic correction technique.
Second, we propose the first systematic approach that employs these five techniques to automatically correct all or part of the misclassified packets of a faulty firewall policy.
Third, we conducted extensive experiments to evaluate the effectiveness of our approach.
Experimental results show that our approach is effective to correct a faulty firewall policy with three of these types of faults.
Firewalls serve as critical components for securing the private networks of business, institutions, and home networks.
A firewall is often placed at the entrance between a private network and the outside Internet so that it can check all incoming and outgoing packets and decide whether to accept or discard a packet based on its policy.
A firewall policy is usually specified as a sequence of rules that follow the first-match semantics where the decision for a packet is the decision of the first rule that the packet matches.
However, most real-life firewall policies are poorly configured and contain faults (i.e., misconfigurations) [21].
A policy fault either creates security holes that allow malicious traffic to sneak into a private network or blocks legitimate traffic and disrupts normal business processes.
In other words, a faulty firewall policy evaluates some packets to unexpected decisions.
We call such packets misclassified packets of a faulty firewall policy.
Therefore, it is important to develop an approach that can assist firewall administrators to automatically correct firewall faults.
There are three key challenges for automatic correction of firewall policy faults.
First, it is difficult to determine the number of policy faults and the type of each fault in a faulty firewall.
The reason is that a set of misclassified packets can be caused by different types of faults and different number of faults.
Second, it is difficult to correct a firewall fault.
A firewall policy may consist of a large number of rules (e.g., thousands of rules) and each rule has a predicate over multi-dimensional fields.
Locating a fault in a large number of rules and further correcting it by checking the field of each dimension are two difficult tasks.
Third, it is difficult to correct a fault without introducing other faults Due to the first-match semantics of firewall policies, correcting a fault in a firewall rule affects the functionality of all the subsequent rules, and hence may introduce other faults into the firewall policy.
To the best of our knowledge, no approach has been proposed for automatic correction of firewall policy faults.
The closest work to us is the technique of firewall fault localization proposed by Marmorstein et al. [17].
Their technique first finds failed tests that violate some security requirements and further uses the failed tests to locate two or three faulty rules in a firewall policy.
However, many types of faults cannot be located by their technique, e.g., wrong order of firewall rules, which is a common type of fault in firewall policies [21].
Furthermore, even if a faulty rule is located, it may not be corrected by just changing the faulty rule.
For example, if a firewall policy misses one rule, we cannot single out a faulty rule in the policy to correct.Another piece of related work is fault localization/fixing, which has been studied in software engineering for years (e.g., [1,10,19,23]).
The state-of-the-art techniques in that field focus on locating/fixing a single fault in a program.
While the proposed approach in this paper can effectively correct multiple faults in a faulty firewall policy for three types of faults.
Our work serves as a good starting point towards policy-fault fixing.
To correct a faulty firewall policy, essentially we need to correct all misclassified packets of the policy such that all these packets will be evaluated to expected decisions.
However, it is not practical to manually find every misclassified packet and then correct it due to the large number of misclassified packets of the faulty policy.The idea of our approach is that we first find some samples of all the misclassified packets and then use these samples to correct all or part of the misclassified packets of the faulty policy.
We propose the first comprehensive fault model for firewall policies.
The proposed fault model includes five types of faults, wrong order, missing rules, wrong decisions, wrong predicates, and wrong extra rules.
For each type of fault, we propose a correction technique based on the passed and failed tests of a firewall policy.
Passed tests are packets that are evaluated to expected decisions.
Failed tests are packets that are evaluated to unexpected decisions.
Note that the failed tests are samples of all misclassified packets.To generate passed and failed tests, we first employ automated packet generation techniques [8] to generate test packets for a faulty firewall policy.
The generated packets can achieve high structural coverage, i.e., covering all or most rules [8].
Second, administrators classify these packets into passed and failed tests by checking whether their evaluated decisions are correct.
Identifying passed/failed tests can be automated in some situations, e.g., when policy properties are written, or multiple implementations of the policy are available.
Even if this operation cannot be done automatically, manual inspection of passed/failed tests is also common practice for ensuring network security in industry.
For example, applying some existing vulnerability testing tools, such as Nessus [18] and Satan [20], does need manual inspection.
In this paper, our goal is to automatically correct policies after we have passed/failed packets.
Identifying passed/failed tests is out of scope of this paper.Given passed and failed tests, correcting a faulty firewall policy is still difficult because it is hard to identify the number of faults and the type and the location of each fault in the firewall policy.
To address this problem, we propose a greedy algorithm.
In each step of the greedy algorithm, we try every correction technique and choose one technique that can maximize the number of passed tests (or minimize the number of failed tests).
We then repeat this step until there are no failed tests.Our proposed approach cannot guarantee to correct all faults in a firewall policy because it is practically impossible unless the formal representation of the policy is available.
However, in practice, most administrators do not have such formal representations of their firewall policies.
To correct a faulty firewall policy without its formal representation, administrators need to examine the decisions of all 2 104 packets 1 and manually correct each of misclassified packets; doing so is practically impossible.
This paper represents the first step towards automatic correction of firewall policy faults.
We hope to attract more attention from the research community on this important and challenging problem.
Our major contributions can be summarized as below:1.
We propose the first comprehensive fault model for firewall polices, including five types of faults, wrong order, missing rules, wrong decisions, wrong predicates, and wrong extra rules.2.
We propose the first systematic approach that can automatically correct all or part of the misclassified packets of a faulty firewall policy.3.
We conduct extensive experiments on real-life firewall policies to evaluate the effectiveness of our approach.
We generated a large number of faulty firewall policies from 40 real-life firewalls, and then applied our approach over each faulty policy and produced the fixed policy.
Faulty policies with k faults (1≤k≤5) were tested.
These faults in a faulty policy were of the same type.
The experimental results show that for three types of faults, wrong order, wrong decisions, and wrong extra rules, our approach can effectively correct misclassified packets.
When k≤4, our approach can correct all misclassified packets for over 53.2% faulty policies.
This result is certainly encouraging and we hope that this paper will attract more attention from the research community to this important problem.
For two other types of faults, missing rules and wrong predicates, our approach does not achieve satisfactory results, deserving further study.
Fault localization for firewall policies has drawn attention recently [9,17].
Marmorstein et al. proposed a technique to find failed tests that violate the security requirement of a firewall policy and further use the failed tests to locate two or three faulty rules in a firewall policy [17].
However, they did not provide a systematic methodology to identify faulty rules according to different types of firewall faults, e.g., wrong order of firewall rules.
Furthermore, they applied their approach only to a simple firewall policy (with 5 rules), which cannot strongly demonstrate the effectiveness of their approach.Our previous work proposed a technique to locate a fault in a firewall policy [9].
The approach first analyzes a faulty firewall policy and its failed tests and then finds the potential faulty rules based on structural coverage metrics 2 .
However, this work has three limitations: (1) it considers only two types of faults, which are wrong decisions and wrong predicates, while a firewall policy may contain other types of faults; (2) it considers only a firewall policy with a single fault, while a firewall policy may contain multiple faults; (3) it does not propose a technique to correct the faults in a firewall policy.
Firewall policy analysis tools have been proposed in prior work (e.g., [2,3,7,12,22]).
Tools for detecting potential firewall policy faults by conflict detection were proposed in [3,7].
Similar to conflict detection, some other tools were proposed for detecting anomalies in a firewall policy [2,22].
Detecting conflicts or anomalies is helpful for finding faults in a firewall policy.
However, the number of conflicts or anomalies could be too large to be manually inspected.
Therefore, correcting a faulty policy is difficult by using these firewall policy analysis tools.
Change impact analysis of firewall policies has also been studied [12].
Such tools are helpful to analyze the impact after changing a firewall policy, but no algorithm has been presented for correcting a faulty firewall policy.Firewall policy testing tools have also been explored in prior work (e.g., [4,11,14,16]).
Such tools focus on injecting packets as tests into a firewall to detect faults in the firewall policy.
If the evaluated decision of a packet is not as expected, faults in the firewall policy are exposed.
However, because a firewall policy may have a large number of rules and the rules often conflict, it is difficult to manually locate faults and correct them based on the passed and failed tests.
Fault localization and fixing have been studied for years in the software engineering and programming language communities (e.g., [1,10,19,23]).
Such research focuses on locating and fixing a fault in a software program.
Four main techniques have been proposed for locating/fixing faults in software programs: dynamic program slicing [1], delta debugging [23], nearest neighbor [19], and statistical techniques [10].
These techniques typically analyze likely fault locations based on dynamic information collected from running the faulty program.
Firewall polices and general programs are fundamentally different in terms of structure, semantics, and functionality, etc.
Therefore, fault localization and fixing techniques of software programs are not suitable for locating faults in firewall policies.
A firewall policy is a sequence of rules r 1 , · · · , r n and each rule is composed of a predicate over d f ields, F 1 , · · · , F d and a decision for the packets that match the predicate.
Figure 1 shows a firewall policy, whose format follows Cisco Access Control Lists [5].
A field F i is a variable of finite length (i.e., of a finite number of bits).
The domain of field F i of w bits, denoted as D( A packet p over the d fieldsF 1 , · · · , F d is a d-tuple (x 1 , · · · , x d ) where each x i (1 ≤ i ≤ d) is an element of D(F i ).
An example packet over these five fields is (1.2.3.5, 192.168.1.1, 78, 25, TCP).
A predicate defines a set of packets over the fields F 1 , · · · , F d , and is specified as [0100,0111].
F 1 ∈ S 1 ∧ · · · ∧ F d ∈ S d .
Each S i is a subset of D(F i ) andA decision is an action for the packets that match the predicate of the rule.
For firewalls, the typical decisions include accept and discard.A packet (x 1 , · · · , x d ) matches a rule F 1 ∈ S 1 ∧ · · · ∧ F d ∈ S d → decision if and only if the condition x 1 ∈ S 1 ∧ · · · ∧ x d ∈ S d holds.For example, the packet (1.2.3.5, 192.168.1.1, 78, 25, TCP) matches the rule r 1 in Figure 1.
A rule Figure 1: An example firewall A firewall policy r 1 , · · · , r n is complete if and only if for any packet p, there is at least one rule that p matches.
To ensure that a firewall policy is complete, the predicate of the last rule is usually specified asF 1 ∈ S 1 ∧ · · · ∧ F d ∈ S d → decisionF 1 ∈ D(F 1 ) ∧ · · · ∧ F d ∈ D(F d ), i.e., the last rule r 2 in Figure 1.
Two rules in a firewall policy may overlap; that is, there exists at least one packet that matches both rules.
Two rules may conflict; that is, the two rules not only overlap but also have different decisions.
For example, in Figure 1, two rules r 1 , r 2 overlap and conflict because the packet (1.2.3.5, 192.168.1.1, 78, 25, TCP) matches r 1 and r 2 , and the decisions of r 1 and r 2 are different.
Firewalls typically resolve conflicts by employing the first-match semantics where the decision for a packet p is the decision of the first (i.e., highest priority) rule that p matches in the firewall policy.
Thus, for the packet (1.2.3.5, 192.168.1.1, 78, 25, TCP), the decision of the firewall policy in Figure 1 is accept.
To check the correctness or detect faults in a firewall policy, administrators need to generate test packets to evaluate that each entity (e.g., each rule) is correct.
In our previous work [8], we developed automated packet generation techniques to achieve high structural coverage.
One cost-effective technique is packet generation based on local constraint solving.
In this paper, we use this technique to generate packets for firewall policies.
This technique statically analyzes rules to generate test packets.
Given a policy, the packet generator analyzes the predicate in an individual rule and generates packets to evaluate the constraints (i.e., rule fields) to be true or false.
The generator first constructs constraints to evaluate each field in a rule to be either false or true, and then it generates a packet based on the concrete values derived by constraint solving.
For example, given rule r 1 in Fig- ure 1, the generator analyzes r 1 and generates a packet (e.g., packet (1.2.3.5, 192.168.1.1, 23447, 25, TCP)) to cover r 1 ; this packet evaluates each of r 1 's fields to be true during evaluation.
Then, the generator analyzes r 2 and generates a packet (e.g., packet (2.2.3.5, 192.168.1.1, 23447, 26, UDP)) to cover r 2 ; this packet evaluates each of r 2 's fields to be true during evaluation.
When firewall policies do not include many conflicts, this technique can effectively generate packets to achieve high structural coverage.
A fault model of firewall policies is an explicit hypothesis about potential faults in firewall policies.
Our proposed fault model includes five types of faults.1.
Wrong order.
This type of fault indicates that the order of rules is wrong.
Recall that the rules in a firewall policy follow the first-match semantics due to conflicts between rules.
Misordering firewall rules can misconfigure a firewall policy.
Wrong order of rules is a common fault caused by adding a new rule at the beginning of a firewall policy without carefully considering the order between the new rule and the original rules.
For example, if we misorder r 1 and r 2 in Figure 1, all packets will be discarded.2.
Missing rules.
This type of fault indicates that administrators need to add new rules to the original policy.
Usually, administrators add a new rule regarding a new security concern.
However, sometimes they may forget to add the rule to the original firewall policy.3.
Wrong predicates.
This type of fault indicates that predicates of some rules are wrong.
When configuring a firewall policy, administrators define the predicates of rules based on security requirements.
However, some special cases may be overlooked.4.
Wrong decisions.
This type of fault indicates that the decisions of some rules are wrong.5.
Wrong extra rules.
This type of fault indicates that administrators need to delete some rules from the original policy.
When administrators make some changes to a firewall policy, they may add a new rule but sometimes forget to delete old rules that filter a similar set of packets as the new rule does.In this paper, we consider faults in a firewall policy that can be represented as a set of misclassified packets.
Under this assumption, given a set of misclassified packets, we can always find one or multiple faults in our fault model that can generate the same set of misclassified packets.
One simple way to find such faults is that for each misclassified packet, we consider that the faulty policy misses a singleton rule for this misclassified packet.
Therefore, we can always find multiple missing rules faults that can generate the same set of misclassified packets.The correction techniques for these five types of faults are called order fixing, rule addition, predicate fixing, decision fixing, and rule deletion, respectively.
Each operation in these five techniques is called a modification.
Normally, a faulty firewall policy is detected when administrators find that the policy allows some malicious packets or blocks some legitimate packets.
Because the number of these observed malicious packets or legitimate packets is typically small, these packets cannot provide enough information about the faults in the firewall policy, and hence correcting the policy with these packets is difficult.
Therefore, after finding a faulty firewall policy, we first employ the automated packet generation techniques [9], which can achieve high structural coverage, to generate test packets for the faulty policy.
Second, administrators identify passed/failed tests automatically or manually.
According to security requirements for the firewall policy, if the decision of a packet is correct, administrators classify it as a passed test; otherwise, administrators classify it as a failed test.
In some situations, e.g., when policy properties are written, or multiple implementations of the policy are available, this operation can be automated.
Manual inspection is also a common practice for ensuring network security in industry.
For example, applying some existing vulnerability testing tools, such as Nessus [18] and Satan [20], does need manual inspection.
Our goal is to automatically correct policies after we have passed/failed packets.
Identifying passed/failed tests is out of the scope of this paper.
Figure 2 shows a faulty firewall policy and its passed and failed tests.
This policy includes 5 rules over two fields F 1 and F 2 , where the domain of each field is [1,10].
The rule r 1 means that accept packets whose value of the first field is in the range [1,5] and whose value of the second field is in the range [1,10].
We use a as a shorthand for "accept" and d as a shorthand for "discard".
For the passed and failed tests, we use a and d to denote expected decisions.
We assign each test a distinct ID p i (1≤i≤8).
Given passed and failed tests, it is difficult to automatically correct a faulty firewall policy for three reasons.
First, it is difficult to locate the faults because a firewall policy may consist of a large number of rules, and the rules often conflict.
Second, before correcting a fault, we need to first determine the type of the fault and then use the corresponding correction technique to fix this fault.
However, it is difficult to determine the type of a fault because the same misbehavior of a firewall policy, i.e., the same set of misclassified packets, can be caused by different types of faults.
Third, it is difficult to correct a In this paper, we formalize the problem of correcting a faulty firewall policy as follows:r 1 : F 1 ∈ [1, 5] ∧ F 2 ∈ [1, 10] → a r 2 : F 1 ∈ [1, 6] ∧ F 2 ∈ [3, 10] → a r 3 : F 1 ∈ [6, 10] ∧ F 2 ∈ [1, 3] → d r 4 : F 1 ∈ [7, 10] ∧ F 2 ∈ [4, 8] → a r 5 : F 1 ∈ [1, 10] ∧ F 2 ∈ [1, 10] → d(Given a faulty firewall policy F W , a set of passed tests P T , and a set of failed tests F T , where |P T |≥0 and |F T |>0, find a sequence of modifications M 1 , · · · , M m , where M j (1≤j≤m) denotes one modification, such that the following two conditions hold:1.
After applying M 1 , · · · , M m to F W , all tests in P T ∪ F T become passed tests.
Correcting a faulty firewall policy with the minimum number of modifications is a global optimization problem and hard to solve because the policy may consist of a large number of rules, and different combinations of modifications can be made.
We propose a greedy algorithm to address this problem.
For each step, we correct one fault in the policy such that the number of passed tests increases (or the number of failed tests decreases).
To determine which correction technique should be used at each step, we try the five correction techniques.
Then, we calculate the number of passed tests for each type of modifications and choose the correction technique that corresponds to the maximum number of passed tests.
We then repeat the preceding step until there are no failed tests.
Figure 3 illustrates our approach for automatic correction of firewall policy faults.Our greedy algorithm can guarantee to find a sequence of modifications that satisfies the first condition.
For each step, the greedy algorithm can increase at least one passed test because of the rule addition technique.
Using this technique, we can at least convert each failed test - gleton rule F 1 ∈ [6, 6] ∧ F 2 ∈ [3, 3] → d.However, the greedy algorithm cannot guarantee to find the global optimization solution that satisfies the second condition.
Note that administrators can supervise this process.
For each step, administrators can choose their preferred technique for correcting a fault in the policy.
If administrators do not want to supervise the process, our greedy algorithm can automatically produce the fixed policy.Further note that without any restriction, our automatic approach for correcting firewall policy faults could introduce potential faults in the firewall policy.
However, an administrator typically has some critical requirements when he/she designs the firewall policy.
These critical requirements define that some packets should be accepted or discarded.
The administrator can restrict the proposed approach not to violate the critical requirements.
Consider a critical requirement that a data server in an organization should not be accessed by any outside connection.
For each step of our greedy algorithm, if the modification generated in this step violates the requirement, the approach can simply choose the next modification that does not violate the requirement.In the next five sections, we discuss our scheme for each correction technique, respectively.
Recall that the last rule of a firewall policy is usually specified asF 1 ∈D(F 1 ) ∧ · · · ∧ F d ∈D(F d ) → decision.Checking whether the last rule is correct is trivial.
Therefore, we assume that the last rule of a firewall policy is correct in our discussion.
Due to the first-match semantics, changing the order of two rules in a firewall policy (i.e., swapping two rules) affects its functionality.
Therefore, after swapping two rules of a firewall policy, we need to test and reclassify all passed tests and failed tests.
It is computationally expensive to directly swap every two rules in a faulty firewall policy and then find the two rules such that swapping them can maximize the increased number of passed tests.
Given a firewall policy with n rules, without considering the last rule, there are (n − 1)(n − 2)/2 pairs of rules that can be swapped.
Furthermore, for each swapping, we need to reclassify all passed and failed tests.
Assume that the number of passed tests is m 1 and the number of failed tests is m 2 .
The computational cost of this brute-force way is (n − 1)(n − 2)(m 1 + m 2 )/2.
To address this challenge, we use all-match firewall decision diagrams (all-match FDDs) [15] as the core data structure.
An all-match FDD is a canonical representation of a firewall policy such that any firewall policy can be converted to an equivalent all-match FDD.
Figure 4 shows the all-match FDD converted from the faulty firewall policy in Figure 2.
An all-match FDD for a firewall policy F W :r 1 , · · · , r n over attributes F 1 , · · · , F d is an acyclic and directed graph that has the following five properties:1.
There is exactly one node that has no incoming edges.
This node is called the root.
The nodes that have no outgoing edges are called terminal nodes.2.
Each node v has a label, denoted asF (v).
If v is a nonterminal node, then F (v) ∈ {F 1 , · · · , F d }.
If v is a terminal node, then F (v) is a list of integer values i 1 , · · · , i k where 1≤i 1 <· · ·<i k ≤ n.3.
Each edge e:u→v is labeled with a nonempty set of integers, denoted as I(e), where I(e) is a subset of the domain of u's label (i.e., I(e)⊆D(F (u))).
The set of all outgoing edges of a node v, denoted as E(v), satisfies two conditions: (1) consistency: I(e)∩I(e ′ )=∅ for any two distinct edges e and e ′ in E(v); (2) completeness:e∈E(v) I(e)=D(F (v)).4.
A directed path from the root to a terminal node is called a decision path.
No two nodes on a decision path have the same label.
Given a decision path P:(v 1 e 1 · · · v d e d v d+1 ), the matching set of P is defined as the set of all packets that satisfyF (v 1 )∈I(e 1 )∧· · ·∧F (v d )∈I(e d ).
We use C(P) to denote the matching set of P.5.
For any decision path P :(v 1 e 1 · · · v d e d v d+1 )whereF (v d+1 ) = i 1 , · · · , i k , if C(P) ∩ C(r j ) 񮽙 = ∅, C(P) ⊆ C(r j ) and j ∈ {i 1 , · · · , i k }.
For ease of presentation, we use {P 1 , · · · , P h } to denote the all-match FDD of the firewall policy F W .
Based on this definition, we can draw the following theorem, the proof of which is in Appendix A. , · · · , P 1 h1 } = {P 2 1 , · · · , P 2 h2 }.
According to Theorem 6.1, for swapping two rules, we only need to swap the sequence numbers of the two rules in the terminal nodes of the all-match FDD.
For finding two rules such that swapping them maximizes the number of passed tests, our correction technique includes five steps:(1) Convert the policy to an equivalent all-match FDD.
(2) For each failed test p, we find the decision path P:(v 1 e 1 · · · v d e d v d+1 ) that matches p (i.e., p ∈ C(P)).
Let i 1 , · · · , i k (1≤i 1 <· · ·<i k ≤n) denote F (v d+1 ).
Note that the decision of r i1 is not the expected decision for the failed test p; otherwise, p should be a passed test.
(3) Find the rules in {r i2 , · · · , r i k } whose decisions are the expected decision of p. Suppose {r j1 , · · · , r jg } are those rules that we find for p, where {r j1 , · · · , r jg } ⊆ {r i2 , · · · , r i k }.
Because the decision of rules in {r j1 , · · · , r jg } is the expected decision for p, swapping r i1 with any rule in {r j1 , · · · , r jg } changes p to a passed test.
Note that because the last rule of a firewall is a default rule, we cannot swap it with any preceding rule.
If r jg is the last rule of the faulty firewall (i.e., j g = n), we delete r jg from {r j1 , · · · , r jg }.
(4) For all failed tests, we find out all rule pairs such that swapping two rules in a rule pair may increase the number of passed tests.
Then we swap two rules in each rule pair.
Note that swapping two rules in a rule pair changes the corresponding failed test to a passed test.
However, this modification may change some passed tests to failed tests.
Therefore, after swapping two rules in each rule pair, we reclassify all tests and calculate the number of passed tests.
(5) Find a rule pair such that swapping the two rules in this pair can maximize the number of passed tests.Note that if there are more than one rule pair such that swapping two rules in each pair can maximize the increased number of passed tests, we choose the rule pair that affects the functionality of the minimum number of original firewall rules.
Let (r i1 , r j1 ), · · · , (r ig , r jg ) denote these rule pairs, where i k ≤j k (1≤k≤g).
Due to the first-match semantics, we choose the rule pair (r i , r j ) where i is the maximum integer in {i 1 , · · · , i g }.
[ Figure 4: All-match FDD converted from the faulty firewall policy in Figure 2 For the faulty firewall policy in Figure 2, we first convert the faulty firewall policy to an all-match FDD, which is shown in Figure 4.
Second, for each failed test, we find the corresponding rule pairs.
In the example, we find only one rule pair (r 2 , r 3 ) for the failed test (6, 3) → d. Third, after swapping r 2 and r 3 , (6, 2) → d becomes a passed test and no passed test changes to a failed test.
Therefore, swapping r 2 and r 3 increases the number of passed tests by 1.
There are two challenges for adding a rule to a faulty firewall policy.
First, given a faulty firewall policy with n rules, there are n positions where we can add a rule.
Determining which position is the best for adding a rule is a challenge.
Second, because the predicate of a firewall rule is composed of multiple fields and the number of possible values in each field is typically large, bruteforce addition of every possible rule for each position is computationally expensive.
Considering a firewall rule with five fields (i.e., 32-bit source IP, 32-bit destination IP, 16-bit source port, 16-bit destination port, and 8-bit protocol type) and two possible decisions (i.e., accept and discard), the number of possible firewall rules that we can add for each position is O(2 204 ), because for each field with d-bit length, the number of possible ranges is ( 2 2 d )=O(2 2d−1 ).
Furthermore, after adding a rule, we still need to reclassify all passed and failed tests.The basic idea of our solution is that for each position, we first find all possible failed tests that can be corrected by adding a rule at this position, and then compute a rule that matches the maximum number of failed tests.
To avoid changing a passed test to a failed test, the rule that we compute does not match any possible passed test.
More formally, given a faulty firewall policy with n rules r 1 , · · · , r n , let position i (1≤i≤n) denote the position between r i−1 and r i .
Note that we cannot add a rule after r n because r n is the default rule.
Our correction technique for adding a rule includes five steps:(1) For each position i, find a set of passed tests P T (i) and a set of failed tests F T (i) such that any test p in P T (i) ∪ F T (i) does not match any rule r j (1 ≤ j ≤ i − 1).
Note that when i = 1, r j does not exist.
In such case, P T (1) = P T and F T (1) = F T .
Due to the first-match semantics, if a failed test p matches a rule r i , adding a rule after rule r i cannot change the decision of p and hence cannot correct p. Therefore, the set F T (i) includes all possible failed tests that we can correct by adding a rule at position i.(2) Based on the expected decisions of tests, divide P T (i) into two sets P T (i) a and P T (i) d where P T (i) a consists of all passed tests with expected decision accept and P T (i) d consists of all passed tests with discard.Similarly, we divide F T (i) into two sets F T (i) a and to position j.F T (i) d .
Note that if there is more than one rule that can correct the maximum number of failed tests, we choose rule r ′ j, decision where j is the maximum integer among these rules such that adding this rule affects the functionality of the smallest number of original rules in a firewall policy.For the faulty policy in Figure 2, Figure 5 shows the four sets P T (i) a , P T (i) d , F T (i) a , and F T (i) d for each rule of the policy.
Without loss of generality, in this section, we discuss the algorithm for computing r ′ i,a based on a set of failed tests F T (i) a and a set of passed tests P T (i) d .
First, we generate a rule that can match all failed tests in F T (i) a .
Suppose that the predicate of a firewall rule is composed of d fields.
For each field j (1≤j≤d), assume that x j is the minimum value of all failed tests in F T (i) a and y j is the maximum value.
Therefore, the rule r:P T (i) a P T (i) d F T (i) a F T (i) d r 1 p 1 , p 2 , p 3 p 4 , p 5 p 7 p 6 , p 8 r 2 p 3 p 4 , p 5 p 7 p 6 , p 8 r 3 - p 4 , p 5 p 7 p 8 r 4 - p 5 p 7 p 8 r 5 - p 5 p 7 -F 1 ∈[x 1 , y 1 ]∧· · ·∧F d ∈[x d , y d ]→a matches all failed tests in F T (i) a .
Second, we use the passed tests in P T (i) d to split the rule to multiple rules, each of which does not match any passed test.
Let (z 1 , · · · , z d )→d denote the first passed test p in P T (i) d .
If rule r matches p, for each field j, we generate two rules by usingz j to split [x j , y j ] into two ranges [x j , z j − 1] and [z j + 1, y j ].
The resulting two rules for field j are as follows.F1∈[x1, y1]∧· · ·∧Fj−1∈[xj−1, yj−1]∧Fj∈[xj, zj − 1] ∧Fj+1∈[xj+1, yj+1]∧· · ·∧F d ∈[x d , y d ]→a F1∈[x1, y1]∧· · ·∧Fj−1∈[xj−1, yj−1]∧Fj∈[zj + 1, yj] ∧Fj+1∈[xj+1, yj+1]∧· · ·∧F d ∈[x d , y d ]→aNote that if x j >z j −1 (or z j +1>y j ), the rule that in-cludes [x j , z j − 1] (or [z j + 1, y j ]) is meaningless and it should be deleted from the resulting rules.
If rule r does not match p, p cannot split r. Then, we use the second test in P T (i) d to split the resulting rules generated from p. Repeat this step until we check all the passed tests in P T (i) d .
Finally, we choose one rule that matches the maximum number of failed tests.
Take two sets P T (2) a and F T (2) d in Figure 5 as an example, rule r ′ 2,d can be computed as F 1 ∈ [6, 8]∧F 2 ∈ [3, 5] → d, which can correct two failed tests p 6 and p 8 .
There are two challenges for fixing a predicate in a faulty firewall policy.
First, for a faulty firewall policy with n rules, there are n−1 possible predicates that we can correct.
Note that the last rule r n is the default rule.
Second, similar to adding rules, brute-force fixing of the predicate for each rule is computationally expensive.
The number of possible predicates for each rule is O (2 203 ).
The basic idea for predicate fixing is similar to adding rules.
We first find all possible failed tests that can be corrected by fixing a predicate, and then compute a rule that matches the maximum number of failed tests.
However, there are two major differences.
First, for fixing the predicate of r i , we compute only a rule with the same decision of r i .
Second, after fixing the predicate of rule r i , the original rule r i does not exist in the firewall policy.
Therefore, the passed tests whose first-matching rule is r i may become failed tests.
The set of these passed tests for r i can be computed as P T (i)−P T (i + 1) (shown in Figure 7).
The passed tests whose first-matching rule is not r i should be prevented from changing to failed tests.
Therefore, the set of all possible failed tests that we can correct by fixing r i 's predicate is F T (i)∪(P T (i)−P T (i + 1)).
Our correction technique for predicate fixing includes five steps:(1) For each position i (1≤i≤n), find a set of passed tests P T (i) and a set of failed tests F T (i) such that any test p in P T (i)∪F T (i) does not match any rule r j (1≤j≤i − 1).
(2) For each rule r i (1≤i≤n−1), compute the set of all possible failed tests F T (i)∪(P T (i)−P T (i + 1)) that we can correct by fixing r i 's predicate.
Let F T (i) denote F T (i)∪(P T (i)−P T (i + 1)).
The complementary set of F T (i)∪(P T (i)−P T (i + 1)) is P T (i + 1), which is the set of passed tests that we cannot change to failed tests by fixing r i 's predicate.
The algorithm for computing rule r ′′ i,a based on F T (i) a and P T (i + 1) d is the same as that in Section 7.1.
Let r ′′ i denote the resulting rule.
(5) Find a rule r ′′ j (1≤j≤n−1) that can correct the maximum number of failed tests and then replace rule r j .
Note that if there is more than one rule that can correct the maximum number of failed tests, we choose rule r ′′ j where j is the maximum integer among these rules.For the faulty policy in Figure 2, Figure 6 shows the four sets P T (i + 1) a , P T (i + 1) d , F T (i) a , and F T (i) d for each rule.
Rule r ′′ 2,a can be computed asF 1 ∈ [6, 7] ∧ F 2 ∈ [7, 9] → a, which can correct one failed test p 7 .
P T (i + 1) a P T (i + 1) d F T (i) a F T (i) d r 1 p 3 p 4 , p 5 p 1 , p 2 , p 7 p 6 , p 8 r 2 - p 4 , p 5 p 3 , p 7 p 6 , p 8 r 3 - p 5 p 7 p 4 , p 8 r 4 - p 5 p 7 p 8 Figure 6: P T (i+1) a , P T (i+1) d , F T (i) a , The idea of fixing a decision is that for each rule r i , we first find the passed tests and failed tests whose firstmatching rule is r i .
The set of the passed tests for r i can be computed as P T (i)−P T (i+1) and the set of the failed tests for r i can be computed as F T (i)−F T (i+1).
If we change the decision of r i , the passed tests in P T (i)−P T (i+1) become failed tests and the failed tests in F T (i)−F T (i+1) become passed tests.
Then, we can calculate the increased number of passed tests by fixing r i 's decision.
Finally, we fix the decision of the rule that corresponds to the maximum increased number of passed tests.
Our correction technique for fixing a decision includes three steps:(1) For each rule r i (1 ≤ i ≤ n − 1), compute two sets P T (i) − P T (i + 1) and F T (i) − F T (i + 1).
Note that if there is more than one rule such that fixing the decision of each of them can maximize the increased number of passed tests, we choose the rule with the maximum sequence number.
For the faulty policy in Figure 2, Figure 7 shows the two sets P T (i) − P T (i + 1) and F T (i) − F T (i + 1) for each rule.
Clearly, fixing the decision of r 4 can change the failed test p 8 to a passed test.P T (i) − P T (i + 1) F T (i) − F T (i + 1) r 1 p 1 , p 2 - r 2 p 3 p 6 r 3 p 4 - r 4 - p 8Figure 7: P T (i)−P T (i+1) and F T (i)−F T (i+1) for each rule in Figure 2 10 Rule DeletionThe idea of deleting a firewall rule is that we use the allmatch FDD to calculate the increased number of passed packets by deleting each rule, and then delete the rule that can maximize the increased number of passed packets.
Given a faulty policy with n rules and its all-match FDD, our correction technique for deleting a rule includes three steps:(1) For each rule r i (1≤i≤n−1), find every decision path P:(v 1 e 1 · · · v d e d v d+1) such that C(P)⊆C(r i ) and i is the first rule id in F (v d+1 ).
Let {P i 1 , · · · , P i h } denote the set of such decision paths.
(2) For each decision path P i g :(v 1 e 1 · · · v d e d v d+1 ) (1 ≤ g ≤ h), find the set of passed tests P T (P i g ) and the set of failed tests F T (P i g ), where any test inP T (P i g ) or F T (P i g ) matches P i g .
Let i 1 , · · · , i k (1≤i 1 <· · ·<i k ≤n) denote F (v d+1).
Note that i 1 = i because of the first-match semantics.
Let l g denote the increased number of passed tests that match P i g after deleting rule r i .
To calculate l g , we need to check whether r i and r i2 have the same decision.
If r i and r i2 have the same decision, deleting r i does not change two sets P T (P i g ) and F T (P i g ).
In this case, l g =0.
Otherwise, the passed tests in P T (P i g ) become failed tests and the failed tests in F T (P i g ) become passed tests.
In this case, l g = |F T (P i g )| − |P T (P i g )|.
Therefore, the increased number of passed packets after deleting rule r i can be computed as h g=1 l g .
(3) Delete the rule that can maximize the number of passed packets.Note that if rule r i is not the first-matching rule for any failed test, |F T (P i g )|=0 (1≤g≤h) and hence h g=1 l g ≤ 0.
In this case, deleting r i cannot increase the number of passed packets.
We can easily find such rules by computing the set F T (i)−F T (i + 1) for each rule r i .
Further note that if there is more than one rule such that deleting each of them can maximize the increased number of passed tests, we choose the rule with the maximum sequence number.For the faulty firewall policy in Figure 2, by checking F T (i)−F T (i+1) in Figure 7, we find that deleting rule r 1 or r 3 cannot increase the number of passed packets.
In the all-match FDD of the faulty policy (shown in Figure 4), for rule r 2 , there are two paths, F 1 ∈[6, 6]∧F 2 ∈ [3,3] and F 1 ∈[6, 6]∧F 2 ∈ [4,10], where 2 is the first integer in their terminal nodes.
Because the failed test p 6 matches the first path, and r 2 and r 3 have different decisions, deleting r 2 changes p 6 to a passed test.
Because the passed test p 3 matches the second path, and r 2 and r 5 have different decisions, deleting r 2 changes p 3 to a failed test.
Therefore, deleting r 2 does not increase the number of passed tests.
Similarly, deleting r 4 changes p 8 to a passed test, and hence increases the number of passed tests by 1.
In our experiments, faulty firewall policies were generated from 40 real-life firewall policies that we collected from universities, ISPs, and network device manufacturers.
The 40 real-life policies were considered as correct policies with respect to these faulty policies.
Each firewall examines five fields, source IP, destination IP, source port, destination port, and protocol type.
The number of rules for each policy ranges from dozens to thousands.To evaluate the effectiveness and efficiency of our approach, we first employed the technique of mutation testing [6] to create faulty firewall policies.
The technique for injecting synthetic faults with mutation testing is a well-accepted mechanism for carrying out testing experiments in both testing academia and industry.
Particularly, each faulty policy contains one type of fault, and the number of faults in a faulty firewall policy ranges from 1 to 5.
Given a real-life firewall with n rules, for each type of fault and each number of faults, we created n−1 faulty policies.
Note that we did not change the last rule of a real-life policy.
For example, to create a faulty firewall policy with k wrong decisions faults, we randomly chose k rules in a real-life firewall policy and then changed the decisions of the k rules.
For each type of fault and each number of faults, we generated 35618 faulty firewall policies.
Second, for each faulty policy, we employed a firewall testing tool [8] to generate test packets.
Note that we generated test packets based on the faulty policy rather than its corresponding real-life policy.
For each faulty policy, on average, the total number of passed and failed tests is about 3n, where n is the number of rules in the policy.
Third, we classified them into passed and failed tests.
For each test packet, we compared two decisions evaluated by the faulty policy and its corresponding real-life policy.
If the two decisions were the same, we classified the test packet as a passed test; otherwise, we classified it as a failed test.
Note that in practice this step should be done by administrators.
Finally, we implemented and applied our greedy algorithm over the faulty firewall policy and produced the fixed policy.
For each step of the greedy algorithm, if different techniques increase the same number of passed tests, we randomly choose one technique.
In this section, we define the metrics to measure the effectiveness of our approach.
First, we define the difference between two firewall policies.
Given two policies F W 1 and F W 2 , the difference between F W 1 andF W 2 , denoted as ∆(F W 1 , F W 2 ), is the total number of packets each of which has different decisions evaluated byF W 1 and F W 2 .
To compute ∆(F W 1 , F W 2 ),we first use a firewall comparison algorithm [13] to find the functional discrepancies between F W 1 and F W 2 , where each discrepancy denotes a set of packets and each packet has different decisions evaluated by the two policies.
Then, we compute the number of packets included by all discrepancies.
Let F W real denote a real-life firewall policy and F W f aulty denote a faulty policy created from F W real .
Let F W f ixed denote the fixed policy by correcting F W f aulty and m(F W f aulty ) denote the number of modifications.
Let S(t, k) denote a set of faulty policies, where t denotes the type of fault and k denotes the number of faults in each faulty policy.
We define two metrics for evaluating the effectiveness of our approach:1.
The difference ratio over F W real , F W f aulty , and F W f ixed :∆(F W real , F W f ixed ) ∆(F W real , F W f aulty )2.
The average number of modifications over S(t, k):F W f aulty ∈S(t,k) m(F W f aulty ) |S(t, k)| Note that ∆(F W real , F W f aulty )is the total number of misclassified packets in the faulty firewall policy.
For the example policy in Figure 1, if we generate a faulty firewall policy by changing r 1 's decision to discard, the difference between these two policies is 2 8 ×2 16 =2 24 .
Hence, the total number of packets that are misclassified by the faulty firewall policy is 2 24 .
In fact, for a faulty policy, one failed test is a misclassified packet.
But the number of failed tests is typically much smaller than the number of misclassified packets.
For example, we may generate only one failed test (1.2.3.5, 192.168.1.1, 23447, 25, TCP)→accept for the preceding faulty policy.
After applying our approach over a faulty policy, the fixed policy F W f ixed not only corrects all failed tests, but also may correct other misclassified packets.
The difference ratio∆(F W real ,F W f ixed ) ∆(F W real ,F W f aulty ) measures the percent- age of misclassified packets after correcting F W f aulty .
If ∆(F W real ,F W f ixed ) ∆(F W real ,F W f aulty ) = 0, F W f ixedcorrects all misclassified packets, which means that F W f ixed is equivalent to F W real in terms of functionality.
, we use "One Fault", · · ·, "Five Faults" to denote the number of faults in faulty firewall policies.
We observe that for three types of faults, wrong order, wrong decisions, and wrong extra rules, fixed policies can significantly reduce the number of misclassified packets.
For faulty policies with k faults, where k faults are one of these three types and k ≤ 4, over 53.2% fixed policies are equivalent to their corresponding real-life policies.
For faulty policies with 1 to 5 wrong decisions faults, the percentages of fixed policies that are equivalent to their corresponding real-life policies are 73.5%, 68.8%, 63.7%, 59.3%, and 53.8%, respectively.
For faulty policies with 1 to 5 wrong order faults, the percentages of fixed policies that are equivalent to their corresponding real-life policies are 69.7%, 64.2%, 59.7%, 54.3%, and 48.9%, respectively.
For faulty policies with 1 to 5 wrong extra rules faults, the percentages of fixed policies that are equivalent to their corresponding real-life policies are 68.3%, 63.5%, 59.3%, 53.2%, and 47.3%, respectively.
We also observe that fixed policies can reduce only a small number of misclassified packets for two types of faults, missing rules and wrong predicates.
For faulty policies with 1 to 2 missing rules faults, the percentages of fixed policies that have 50% difference ratio with their corresponding real-life policies are 15.7% and 8.32%, respectively.
For faulty policies with 1 to 2 wrong predicates faults, the percentages of fixed policies that have 50% difference ratio with their corresponding real-life policies are 17.3% and 9.1%, respectively.
The reason is that in most cases, the information provided by failed tests is not enough to recover the missing rule (or correct predicate).
A firewall rule (or predicate) with 5 fields can be denoted as a hyperrectangle over a 5-dimensional space, and failed tests are only some points in the hyperrectangle.
To recover the missing rule (or correct the Figure 8: Cumulative distribution of difference ratio and average number of modifications for each type of firewall policy faults wrong predicate), for each surface of the hyperrectangle, there should be at least one point on it.
However, the chance of such a case is very small.
Figure 8(f) shows the average number of modifications for each type of firewall faults.
We observe that for faulty firewall policies with k faults, where k ≤ 5, the ratio between the average number of modifications and the number of faults is less than 2.
Note that to correct a faulty firewall policy with k faults, k is the minimum number of modifications.
Therefore, the number of modifications of our approach is close to the minimum number.
We implemented our approach using Java 1.6.0.
In our experiments, for a faulty firewall policy, we measure the total processing time of generating test packets, classifying packets into passed and failed tests, and fixing the policy to evaluate the efficiency of our approach.
Note that classifying test packets is automatically done in our experiments by comparing two decisions evaluated by the faulty firewall and its corresponding real-life firewall for test packets.
In practice, this step should be done by administrators.
Our experiments were carried out on a desktop PC running Linux with 2 quad-core Intel Xeon at 2.3GHz and 16GB of memory.
Our experimental results show that for the faulty firewall policy with 7652 rules, the total processing time for fixing this faulty policy is less than 10 minutes.
In this section, we applied our automatic correction tool for firewall policy faults to a real-life faulty firewall policy with 87 rules and demonstrated that our tool can help the administrator to correct the misconfiguration in the firewall policy.
The real-life firewall policy is shown in the Appendix B where the policy is anonymized due to the privacy and security concern.We first employed the automated packet generation techniques [9] to generate test packets for the firewall policy and then asked the administrator to identify passed/failed tests.
Among these test packets, we obtained seven failed tests, which are shown in Table 1.
Second, we applied our proposed solution to this firewall policy and generated a sequence of modifications to correct the seven failed tests in Table 1.
The resulting sequence includes four modifications: swapping rule 6 and rule 38, deleting rules 48, 49, and 50, which suggest that the firewall policy has one wrong-order fault and three wrong-extra-rule faults.
We confirmed these faults with the administrator and he admitted that the resulting sequence of modifications generated by our tool can correct these faults automatically.p1 : (157.96.252.36, 157.96.252.66, 13249, 25341, IP ) → a p2 : (67.
48.121.156, 157.96.139.10, 4537, 109, T CP ) → a p3 : (35.121.47.232, 157.96.139.10, 21374, 109, T CP ) → a p4 : (25.35.113.153, 157.96.139.10, 7546, 110, T CP ) → a p5 : (154.182.56.79, 157.96.139.10, 16734, 110, T CP ) → a p6 : (193.21.135.85, 157.96.139.10, 19678, 143, T CP ) → a p7 : (213.174.191.25, 157.96.139.10, 24131, 143, T CP ) → a Table 1: Seven failed tests for the real-life firewall policy We make three key contributions in this paper.
First, we propose the first comprehensive fault model for firewall policies, including five types of faults.
For each type of fault, we present an automatic correction technique.
Second, we propose the systematic approach that can automatically correct all or part of the misclassified packets of a faulty firewall policy.
To the best of our knowledge, our paper is the first one for automatic correction of firewall policy faults.
Last, we implemented our approach and evaluated its effectiveness on real-life firewalls.
To measure the effectiveness of our approach, we propose two metrics, which we believe are general metrics for measuring the effectiveness of firewall policy correction tools.
The experimental results demonstrated that our approach is effective to correct a faulty firewall policy with three types of faults: wrong order, wrong decisions, and wrong extra rules.Proof : Suppose there exists another one set of path {P ′ i1 , · · · , P ′ i l }, which is different from P ∈ {P i1 , · · · , P im }.
Thus, there exists at least one P ′ is ∈ {P i1 , · · · , P im } (1 ≤ s ≤ l).
According to the consistency and completeness properties of all-match FDDs, for any P it (1 ≤ t ≤ m), P it ∩ P ′ is = ∅.
Thus, ∪ m t=1 C(P it ) 񮽙 = ∪ l s=1 C(P ′ is ), which contradicts with our assumption.Next we can prove Theorem 6.1 based on Lemma 13.1 and Lemma 13.2.
Proof of Theorem 6.1: Based on Lemma 13.2, for each rule r 1 i ∈ {r 1 1 , · · · , r 1 n } (1 ≤ i ≤ n), we can find only one set of paths P ∈ {P 1 1 ,· · ·, P 1 h1 } such that C(r 1 i ) = ∪ m t=1 C(P 1 it ).
Because {r 1 1 ,· · ·,r 1 n } = {r 2 1 ,· · ·,r 2 n }, there exists r 2 j (1 ≤ j ≤ n) such that r 2 j = r 1 i .
Thus, for each rule r 1 i and its corresponding rule r 2 j , we have C(r 1 i ) = C(r 2 j ) = ∪ m t=1 C(P 1 it )We also know that for the all-match FDD {P 1 1 ,· · ·, P 1 h1 } generated from F W 1 :r 1 1 ,· · ·,r 1 n , the following condition holds:∪ n i=1 (∪ m t=1 P 1 it ) = {P 1 1 , · · · , P 1 h1 }Similarly, for the all-match FDD {P 2 1 , · · · , P 2 h2 } generated from F W 2 :r 2 1 , · · · , r 2 n , we have ∪ n i=1 (∪ m t=1 P 1 it ) = {P 2 1 , · · · , P 2 h2 } Thus, {P 1 1 , · · · , P 1 h1 } = {P 2 1 , · · · , P 2 h2 }.
This work is supported in part by NSF grant CNS-0716579, NSF grant CNS-0716407, an MSU IRGP Grant, and an NIST grant.
ABefore we prove Theorem 6.1, we first prove the following two lemmas.Lemma 13.1 Given a firewall policy F W :r 1 ,· · ·,r n and its all-match FDD {P 1 ,· · ·,P h }, for any rule r i in F W , if P i1 ,· · ·,P im are all the decision paths whose terminal node contains r i , the following condition holds: C(r i ) = ∪ m t=1 C(P it ).
Proof : According to property 5 in the definition of allmatch FDDs, we have ∪ m t=1 C(P it ) ⊆ C(r i ).
Consider a packet p in C(r i ).
According to the consistency and completeness properties of all-match FDDs, there exists one and only one decision path that p matches.
Let P denote this path.
Thus, we have p ∈ C(r i ) ∩ C(P).
According to property 5, i is in the label of P's terminal node.
Thus, we have P ∈ {P i1 , · · · , P im }.
Therefore, p ∈ ∪ m t=1 C(P it ).
Thus, we have ∪ m t=1 C(P it ) ⊇ C(r i ).
Lemma 13.2 Given a firewall policy F W :r 1 ,· · ·,r n and its all-match FDD {P 1 ,· · ·,P h }, for any rule r i in F W , there exists only one set of paths P ∈ {P i1 , · · · , P im } such that C(r i ) = ∪ m t=1 C(P it ).
Appendix BThe real-life firewall policy with 87 rules is shown as follows.
Before we prove Theorem 6.1, we first prove the following two lemmas.Lemma 13.1 Given a firewall policy F W :r 1 ,· · ·,r n and its all-match FDD {P 1 ,· · ·,P h }, for any rule r i in F W , if P i1 ,· · ·,P im are all the decision paths whose terminal node contains r i , the following condition holds: C(r i ) = ∪ m t=1 C(P it ).
Proof : According to property 5 in the definition of allmatch FDDs, we have ∪ m t=1 C(P it ) ⊆ C(r i ).
Consider a packet p in C(r i ).
According to the consistency and completeness properties of all-match FDDs, there exists one and only one decision path that p matches.
Let P denote this path.
Thus, we have p ∈ C(r i ) ∩ C(P).
According to property 5, i is in the label of P's terminal node.
Thus, we have P ∈ {P i1 , · · · , P im }.
Therefore, p ∈ ∪ m t=1 C(P it ).
Thus, we have ∪ m t=1 C(P it ) ⊇ C(r i ).
Lemma 13.2 Given a firewall policy F W :r 1 ,· · ·,r n and its all-match FDD {P 1 ,· · ·,P h }, for any rule r i in F W , there exists only one set of paths P ∈ {P i1 , · · · , P im } such that C(r i ) = ∪ m t=1 C(P it ).
The real-life firewall policy with 87 rules is shown as follows.
