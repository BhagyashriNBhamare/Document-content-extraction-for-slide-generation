While the fault repair capability of Evolvable Hardware (EH) approaches have been previously demonstrated, further improvements to fault handling capability can be achieved by exploiting population diversity during all phases of the fault handling process.
A new paradigm for online EH regeneration using Genetic Algorithms (GAs) called Consensus Based Evaluation (CBE) is developed where the performance of individuals is assessed based on broad consensus of the population instead of a conventional fitness function.
Adoption of CBE enables information contained in the population to not only enrich the evolutionary process, but also support fault detection and isolation.
On-line regeneration of functionality is achieved without additional test vectors by using the results of competitions between individuals in the population.
Relative fitness measures support adaptation of the fitness evaluation procedure to support graceful degredation even in the presence of unpredictable changes in the operational environment, inputs, or the FPGA application.
Application of CBE to FPGA-based multipliers demonstrates 100% isolation of randomly injected stuck-at faults and evolution of a complete regeneration within 135 repair iterations while precluding the propagation of any discrepant output.
The throughput of the system is maintained at 85.35% throughout the repair process.
Evolutionary mechanisms can actively restore mission-critical functionality in SRAM-based reprogrammable devices such as Field Programmable Gate Arrays (FPGAs).
They provide an alternative to device redundancy for dealing with permanent degradation due to radiation-induced stuck-at-faults, thermal fatigue, oxide breakdown, electromigration, and other local permanent damage without the increased weight and size normally associated with spares.
Hence, recent research has focused on employing the capability for reconfiguration inherent in field programmable devices to increase reliability and autonomy [1], [2], [3], [4], [5].
In these experiments, fault-tolerance is evolved at design time, or achieved at repair-time using evolution after taking a detected failed unit offline.
In both cases, GAs provided a population-based optimization algorithm with the objective of producing a single best-fit individual as the final product.
They rely on a pre-determined static fitness function that does not consider an individual's utility relative to the rest of the population.
The evaluation mechanisms used in previous approaches depend on the application of exhaustive test vectors to determine the individual with the best response to all possible inputs.
However, given that partially complete repairs are often the best attainable [4], [2], other individuals may outperform the best-fit individual over the range of inputs of interest.
In particular, there is no guarantee that the individual with the best absolute fitness measure for an exhaustive set of test inputs will correspond to the individual within the population that has the best performance among individuals under the subset of inputs actually applied.
Thus, exhaustive evaluation of regenerated alternatives is computationally expensive, yet not necessarily indicative of the optimal performing individual among a population of partially correct repairs.
Hence, two innovations are developed herein for self-adaptive EH regeneration:1) Elimination of additional test vectors, and 2) Temporal Assessment based on aging and outlier identification In Consensus-based Evaluation (CBE), an initial population of functionally identical (same inputoutput behavior), yet physically distinct (alternative design or place-and-route realization) FPGA configurations is produced at design time.
During runtime, these individuals compete for selection based on discrepancy favoring fault-free behavior.
Discrepant behaviour, where the outputs of two competing individuals do not agree on a bit-by-bit basis, is used as the basis for the performance evaluation process.
Any operationally visible fault will decrease the fitness of just those configurations that use it.
Over a period of time, as the result of successive comparisons, a consensus emerges from the population regarding the relative fitness of all individuals.
This allows the classification of configurations into ranges of relative reliabilities based on their observed performance during online operation.
Adaptive regeneration has been investigated as an alternative to using pre-determined spares.
Most researchers [2], [3], [5], [6] focus on using traditional GAs to identify a single best-fit individual at the termination of the evolutionary computation.
Keymeulen, Stoica, and Zebulum [1] use a designtime emphasis to improve fault tolerance.
They develop evolutionary techniques so that a circuit is initially designed to remain functional even in presence of various faults.
Their population-based fault tolerant design method evolves diverse circuits and then selects the most fault-insensitive individual.
In this paper we propose a system that achieves improved fault tolerance by using a runtime adaptive algorithm that emphasizes the utilization of responses observed during the actual operation of the device.
While their population-based fault tolerance approach provides passive runtime tolerance, CBE is dynamic and actively improves the fault tolerance of the system according to environmental demands.Yao and Liu [7] emphasize that in evolutionary systems, the population contains more information than any one individual.
They develop two examples to demonstrate the use of the information contained in the population in the domains of artificial neural networks and rule based systems respectively.
The last population is used efficiently and out-performs the single best-fit individual in these two examples.
[8] presents four methods for combining the different individuals in the final population to generate the solution.
They provide results for three data sets, namely the Australian credit card assessment problem, the heart disease problem and the diabetes problem, which show that solutions obtained by combining individuals outperform any single individual.
While the authors devise a method to utilize the information contained in the population to improve the final solution, they fail to use the information in the population to improve the learning and optimization process itself.
Also, the authors emphasize that learning systems are different from optimization problems, and that information contained in the population is only useful in learning systems.
The proposed approach clearly indicates that even optimization and repair problems can benefit from population information.
More recently, in [9] the authors describe using fitness sharing and negative correlation to create a diverse population of solutions.
A combined solution is then obtained using a gating algorithm that ensures the best response to the observed stimuli.
In EHW, it may not always be possible to combine solutions without additional physical resources that may be fault-prone.
In our approach, all individuals in the population are recognized as possible solutions, with the best emerging candidate being selected based on their runtime response and performance track record.
The authors also claim that applying the described techniques to EHW should be a straightforward matter, but do not describe any applications or examples.
They state the absence of an optimal way of predicting the future performance of evolved circuits in unseen environments.
We show that it is possible for an adaptive system to keep track of the relative performances of individuals and implicitly build a consensus.Layzell and Thompson [10] identify Populational Fault Tolerance (PFT) as an inherent quality of EHW.
They state that due to the incremental nature of evolutionary algorithms, the solution changes along the course of evolution to adapt to faults.
The evolutionary history of the evolved circuit was used to arrive at the conclusion that PFT is an inherent quality in evolutionary design due to the incremental incorporation of additional components into a prototype depending on conditions.
They speculate that PFT is less likely to occur for online evolution in varying environments.
An evolutionary process that uses absolute fitness measures and exhaustive tests may not be able to provide adaptive fault tolerance.Previous research has not focused on leveraging the robustness of a population to improve the detection and isolation phases, or to achieve an online evolution process.
Problems related to fault tolerance in online evolution identified by the existing approaches are addressed by the new Consensus-based Evaluation scheme.
Online evolution defines an essentially different problem from a traditional GA optimization problem.
To address the problem effectively, a new fitness evaluation paradigm is required.
With relative fitness measures based on competition, a running consensus is produced regarding the fitness of individuals in repsonse to the actual environmental stimuli.
This can be used by the regeneration process to adapt to runtime requirements and improve the fault tolerance of the population.
The CBE approach presents a new online adaptive repair mechanism that fully exploits the advantages of population-based evolutionary methods.
It utilizes a temporal voting approach whereby the outputs of two competing instances are compared at any instant and alternative pairings are considered over time.
The presence or absence of a discrepancy is used to adjust the discrepancy values (DVs) of both individuals without rendering any judgment at that instant on which individual is actually faulty.
The faulty, or later exonerated, configuration is determined over time through other pairings of competing configurations.
The competitive process is applied repeatedly to form a strong consensus across the diverse pool of alternatives.
The fitness of individuals is determined through this continuing runtime process by evaluating the real time performance of individuals in comparison to others in the population.
Instead of using an absolute fitness function, with the concomitant exhaustive testing, relative discrepancy values are used as the threshold to identify faulty individuals.
Also, the system actively selects individuals that perform the best, given the current environment.
Healthy individuals are used to achieve the repair of individuals affected by faults.
The proposed approach makes full use of the fact that repair complexity is far less than design complexity.
CBE achieves improved fault tolerance by making extensive use of the information contained in the population -both as raw material for creating new individuals, and as information that enables faster and more accurate fault isolation.
Any improvement in the fault isolation process speeds up the regeneration process by directing the GA search in the proper direction.
The use of a relative fitness measure and temporal consensus improves the fault tolerance and adaptability of the population.
A GA performs a multi-directional search by maintaining a population of potential solutions and encouraging information formation and exchange along these directions.
By encouraging direct competition between individuals in the population, a relative fitness measure based on consensus can be generated.
The objective fitness function used in traditional GAs can be effectively replaced by the emergent consensus and relative fitness measure.
The relative fitness measure is inherently dynamic, and by using an Evaluation Window for the individuals, an accurate reflection of the environmental conditions and changes can be achieved.
Multiple potential directions for future exploration can be created and utilized depending on the conditions prevalent during the evolutionary process.In the CBE approach, an initial population of Pristine individuals is created by manual design.
These primordial configurations are functionally-identical (same input-output behavior), yet they utilize physically-distinct resources (alternative design or place-and-route implementations).
For puposes of illustration, assume two competing half-configurations labeled Functional Logic Left ("L") and Functional Logic Right ("R") are loaded in tandem on the physical FPGA platform.
The half-configurations occupy mutually exclusive physical resources to implement identical functionality.
This realizes a conventional Concurrent Error Detection (CED) arrangement to identify at least any single resource fault with certainty [11].
As in traditional CED approaches, comparison of the outputs of the two resident half-configurations will produce either discrepant or matching outputs which will indicate the presence or absence of faulty resources in the FPGA hardware platform respectively.Under CBE, whenever two half-configurations disagree, the Discrepancy Value (DV) of both halfconfigurations are incremented.
By repeated pairing over a period of time, only those halfconfigurations which do not use faulty resources will eventually become preferred.
This is because the DV of a faulty half-configuration is always increased regardless of its pairing, yet the DV of faultfree half-configurations which are paired together do not increase.
This process occurs as part of the normal processing throughput of the FPGA without additional test vectors or other diagnostic routines.
The determination of a configuration's health state is based on its cumulative DV relative to DV of the other individuals in the population evaluated over a period called the Evaluation Window, denoted by E W .
The procedure begins with pre-designed individuals that are fault-free.
These individuals are divided into two groups, L and R, where each group of individuals uses mutually exclusive physical resources.
This is essential to ensure that one individual each form both groups can reside and compete in tandem on the FPGA.
In addition, every individual can belong to one of four statesPristine, Suspect, Under-repair or Refurbished.
In the beginning, all individual are pristine.
At any given point of time, one individual each from the L and R groups compete with each other.
State transistions occur according to the result of pairwise output comparison.
A comparison can lead to two results -"L=R" and "L≠R" indicating whether the two resident half-configurations produce either matching or discrepant outputs, respectively.
When L=R occurs then both individuals retain their Pristine state.
However when their outputs disagree then both the configurations are demoted to the Suspect pool and the DV of both individuals is increased.
Whenever such a transition occurs, a Fault Alert indicator is issued because two functionally-identical circuits disagree.
Hence at least one resource fault must have occurred.More formally, the i-th half configuration remains in the Suspect pool until its DV f i evaluated over the preceding E W pairings rises above the Repair Discrepancy Value (f i < DV R ) which is defined as average DV of entire population accumulated over E W .
The i-th half-configuration is then marked as Under Repair until its DV drops below the Operational Discrepancy Value (f i ≥ DV O ) which is defined as average DV of the healthy individuals among the population (Pristine, Suspect and Refurbished) accumulated over E W .
Under the fault-free circumstance, DV O = DV R until the faulty individuals appear in the population as a result of emergent hardware faults.
Thereafter, f OT is modified such that DV O ≤ DV R which provides dithering immunity such that the configuration is indeed Refurbished.Over a period of time the DV of an individual could increase further and complete regeneration becomes possible though not necessarily externally distinguishable from partial regeneration.
Competing half-configurations remain Refurbished unless their DV rises above the Repair DV, at which time they again demoted to the Under Repair state.
The procedural flow of the CBE algorithm that calculates the health state transitions is depicted in Figure 1.
After initialization, Selection of the L and R half-configurations occurs which are then loaded into the FPGA.
The Detection process is conducted when the normal data processing inputs are applied to the FPGA.
Based on agreement or disagreement among the outputs of the two competing L and R half-configurations, Discrepancy Value Adjustment for both individuals occurs.
The central PRIMARY LOOP representing discrepancy-free behavior can repeat indefinitely without any reconfiguration of the FPGA.
Only when outputs disagree do alternate configurations need to be loaded.
For Under Repair individuals, if f i > DV R then Genetic Operators are invoked only once on the resident configurations.
The modified configuration is then immediately returned to the pool of competing configurations and the Selection step is resumed under normal FPGA throughput processing operations.
The Selection and Detection processes are shown in Figure 2.
The usual flow is for Pristine, Suspect, and then Refurbished individuals to be preferred in that order for one half-configuration.
On the other hand, the other half-configuration is selected based on a stochastic process determined by the Reintroduction Rate (λ R ).
In particular, Under Repair individuals are selected as one of the competing half-configurations on average at a rate equal to λ R. Henceforth, this now genetically-modified configuration will be re-introduced into the operational throughput flow as a new competitor to potentially exhibit fault-free behavior against the larger pool of configurations not currently undergoing repair.An additional innovation is that λ R is not only a continuous variable, but can be adapted under autonomous control.
In particular, we strive for Mean-Time-To-Repair (MTTR) < Mean-TimeBetween-Failures (MTBF) by monitoring the ratio of the number of computations elapsed between and adjusting λ R accordingly.The Detection process is presented in the lower right corner of Figure 2.
If a discrepancy is observed as a result of output comparison, the FPGA is reconfigured with a different pair of competing configurations and the output of the device is temporarily held to be recalculated by the newly selected L and R half-configurations.
These repeated computations and comparisons imply no additional cost since the device remains online and operational and the normal data throughput continues uninterrupted.
Figure 3 depicts the Fitness State Adjustment Process in CBE.
Whenever a discrepancy is detected, the discrepancy values of the individuals involved are updated.
The new discrepancy values are then compared to the Repair Discrepancy Value DV R and Operational Discrepancy Value DV O to determine whether the individuals move from one fitness state to another.
Ideally, the repair and operational discrepancy values are computed over E W comparisons for the population.
As soon as the all the individuals in the population have completed at least E W comparisons, new values of these thresholds are obtained.
Since it may be impractical to wait for all individuals to complete the requisite iterations, an individual can undergo a state transition after it finishes E W iterations.
A Sliding window is defined, which reduces the latency involved in updating DV R and DV O by considering a subset of individuals instead of the whole population.
With a sliding window, the values of these thresholds are updated upon the completion of the requisite number of iterations by the number of individuals defined by the sliding window.
For Under Repair individuals, GA operators are invoked once every E W iterations.
The hypothetical FPGA structure used in the CBE approach is the same as that in Miller, Thomson [12].
The feed-forward combinational logic digital circuit uses a rectangular array of nodes with two inputs and one output.
Each node represents a Look-up Table (LUT) in the FGPA device, and a Configurable Logic Block (CLB) is composed of four LUTs.
In the array, each CLB will be a row of the array and two LUTs are represented as four columns of the array.
There are five dyadic functions --OR, AND, XOR, NOR, NAND --and one unary-function NOT, each of which can be assigned to an LUT.
The LUTs in the CLB array are indexed from 1 to n. Array routing is defined by the internal connectivity and the inputs/outputs of the array.
Internal connectivity is specified by the connections between the array cells.
The inputs of the cells can only be the outputs of cells with lower row numbers.
Thus, the linear labelling and connection restrictions impose a feed-forward structure on the combinational circuit.A 3×3 Multiplier is implemented using the above FPGA structure.
XOR gates are purposely excluded from the initial designs which leads to designs with a higher number of the gates than conventional 3×3 Multiplier designs to increase the design space.
The entire configuration needs 21 CLBs.
The population of competing alternatives is then divided into two groups, L and R, where each group uses an exclusive set of physical resources.
For crossover to occur such that offspring are guaranteed to utilize only mutually-exclusive physical resources with other resident halfconfigurations, a two-point crossover operation is carried out with another randomly selected Pristine, Suspect or Refurbished individual belonging to the same group.
By enforcing speciation breeding occurs exclusively in L or R, and non-interfering resource use is maintained.
The random crossover points are chosen along the boundary of CLBs so that intra-CLB crossover is not possible.
The mutation operator randomly changes the LUT's functionality or reconnects one input of the LUT to a new randomly selected output inside the CLB.
An initial population of 20 fault-free configurations was partitioned into mutually exclusive subpopulations L and R, each containing 10 configurations.
Varying stuck-at faults were injected into the architecture that represents permanent physical faults.
Several fault isolation and regeneration experiments were carried out using a software simulator.
The E W used in the experiment is 600, which can statistically guarantee that all of 64 input combinations appear at the inputs at least once with probablity of 99.5%, when input combinations are selected at random.
For the 3×3 multiplier, the total possible number of input combinations is 2 6 =64.
Thus n = 64 represents the total number of unique input combinations to the simulated FPGA.
In the simulation, m (0≤m≤64) is defined as the number of input combinations for which a fault is manifested at the output of the simulated circuit.
The number of input combinations for which the output does not match the desired value measures the impact of a fault on an individual.
Fault isolation characteristics are analyzed first without considering the regeneration processThe second set of regenerative experiments investigates the regeneration of functionality using CBE.
The GA uses a two-point crossover, with a crossover rate of 0.05 and the mutation rate is 0.8.
The re-introduction rate is 10%.
With the simulated FPGA remaining partially online, all of the regeneration experiments achieved full fault recovery within a few hundred repair operations with normal functional data input.
During the regeneration period, data throughput is average 87.94.
That is, only 13.16% of the total computations had to be recalculated in order to preclude propagation of discrepant outputs.
Pairs of individuals, one each from the L and the R groups are loaded on the FPGA in a repetitive random process.
The outputs are compared to check for discrepancies.
Judgment on the fault characteristics of an individual is reserved till it completes E W pairings, and an Observation Interval is complete.
A Sliding Window of evaluation is defined as five E W , after which one observation interval is complete and individuals who have completed an E W are evaluated to identify outliers.
The DV of a faulty configuration will increase each time it is compared to another individual.
A fault-free individual will see increases in its DV only when it is compared to a faulty individual.
Individuals with a DV that exceeds the observed arithmetic mean by one standard deviation are identified as faulty.
For example, if 1-out-of-64 outputs are affected in one L individual due to a fault, the expected DV of this individual after E W pairings is DV L = 1/64* E W =9.375, assuming equal likelihoods for inputs.
A faulty individual can be expected to be identified once every two observation intervals, since the width of each observation interval is defined by 5*E W .
The average DV of the R individuals that this is paired with be DV R =1/64* E W /10=0.9375, assuming equal selection likelihoods.Two metrics Operational DV (DV O ) and Repair DV (DV R ) are calculated and used in the CBA evaluation.
DV O is defined as arithmetic mean of the observed DV of all healthy individuals over a sliding winodw and the DV R is defined as arithmetic mean of the DV of all individuals considered in the sliding window, including any that may be faulty.
If no faulty individuals have been detected, DV O will equal DV R , otherwise the DV O < DV R as the faulty individuals substantially increase the mean DV.
DV O and DV R are subsequently used in the CBE fault repair mechanism to define the state transitions of individuals.
If an individual has a DV < DV O , it is probably fault-free and can be used for fault-free computation.
If the DV of an individual exceeds DV R, then the individual is placed in the Under-Repair group.In the first experiment, only one individual is affected by a failure in the physical resource, which causes a 1-out-of-64 fault in the individual.
Before the fault occurs, the system operates with a 100% throughput, and all individuals have a DV equal to zero.
As shown in Figure 4, the fault occurs at time t = 0 and the faulty individual is repeatedly detected and identified at various observation intervals.
DV O = DV R whenever no faulty individual have been detected over a sliding window.
The faulty individual is always detected, but since it has not completed E W pairing, judgment is reserved, as shown in the plot.
When a faulty individual is isolated, the DV O will be less than DV R and the faulty DV will be located outside of the DV R +DV σ , where DV σ represents the standard deviation of the discrepancy values.
Figure 5 shows that the isolated individual's DV deviates by 1σ or more, typically 3σ.
This shows error-free isolation and that faults are never incorrectly identified.
Also, 100% of the faulty individuals are identified within statistically acceptable values for their discrepancies.
The average DV of individuals will increase proportionately with fault impact.
This leads to increased isolation latency, as shown in Figure 6, for the second experiment, where the characteristics of isolating a single faulty individual with a 10-out-of-64 fault impact are shown.
Since there are more faults, the faulty individual is expected to show a discrepancy (10/64)*600 = 93.75 times over its evaluation window.
To complete these iterations, it will therefore require (93.75/5) = 18.75 observation intervals, as opposed to 1.88 previously, which leads to both increased discrepancy values for the isolated individuals and an increased time between successive isolations as compared to Figure 4.
The detection latency remains unaffected.
Figure 7 shows that for a single faulty L individual, with a 10-out-of-64 fault impact, isolation always succeeds when expected.
However, when more than one individual is affected by a resource fault, isolation is more timeconsuming and difficult as shown in Figure 8, which depicts the isolation characteristics when 4 L and 4 R individuals are affected by 1-out-of-64 faults.
Expected isolations do not occur approximately 40% of the time, as the average discrepancy value of the population is higher, making outlier isolation difficult.
The faulty individuals are always detected, but the higher number of discrepancies prevents them from completing E W iterations within an observation interval.
However, a fault-free individual is never incorrectly identified as being faulty.
CBE-based regeneration experiments were performed on a simulated FPGA platform for the 3x3 multiplier application.
Starting with an initial population of 20 viable configurations, random stuck-at faults were injected randomly into one of the 21 CLBs that were utilized to implement the multiplier.
The fault reduced the number of correct outputs from 64-out-of-64 to 54-out-of-64.
Regeneration was performed using a fitness-state adjustment process that utilized the results of the isolation process described in previous sections.
A re-introduction rate of 10% was selected for selecting individuals under repair for performance evaluation.
Higher re-introduction rates would lower the throughput whereas if the re-introduction rate is too low, the repair process will be unduly slowed down due to the decreased opportunities to evaluate the performance of the individuals under repair.
A low crossover rate of 0.05 was used to ensure that the diversity in the population is preserved.
The initial seeding population consists entirely of diverse hand-designed individuals.
The mutation rate of 0.8 is required to ensure that the algorithm can explore alternatives by changing the logical functionality of LUTs and the interconnections between them.While the simulated FPGA remained partially online, regeneration improved correctness to 64-out-of-64 possible outputs.
Including iterations that produced functional outputs, the process concluded after a total of 218076 iterations.
Complete repair was achieved after only 135 repair iterations when starting with a highly diverse initial population.
The fault-affected individual was loaded on the FPGA for a total of 31636 iterations.
During the regeneration period, data throughput was 85.54%.
Hence, only 14.46% of the total computations needed to be redundant in order to preclude propagation of any discrepant outputs, even when candidate repairs were being reintroduced to refurbish the impacted FPGA configuration without additional test vectors.
The throughput will be significantly higher when the system starts from a fault-free situation, since a large number of the initial iterations before the occurrence of the fault will contribute to improving the throughput.
Fault isolation using consensus-based evaluation improved the performance of the repair process eliminating the use of an absolute fitness function.
The diversity of the initial population provides for increased fault tolerance and also the raw material for realizing the repair.
Online EH regeneration essentially defines a problem that is different from offline EH design.
CBE leverages the fact that a failed system's Repair Complexity can often be much more computationally tractable than either its original Design Complexity or its Re-Design Complexity, both of which operate in the absence of a diverse population of previously completely correct alternatives.
In particular, "repair" implies working design(s) being available before the occurrence of a resource failure.
A population of working designs can thus facilitate repair by providing diverse alternates.
Conventional fitness evaluation associates a rigid individual-centric fitness measure defined at design-time.
CBE uses instead, a self-adapting population-centric assessment method at run-time.
Population-centric assessment methods such as CBE can provide an additional degree of adaptability and autonomy.
Finally, an additional benefit of CBE is that fitness evaluation becomes independent of the application running on the FPGA enabling model-free assessment during evolutionary repair.
This research was supported in part by NASA Intelligent Systems NRA Contract NNA04CL07A.
