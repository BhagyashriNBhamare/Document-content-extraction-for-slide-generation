Peer-to-peer systems rely on scalable overlay networks that enable efficient routing between its members.
Hypercubic topologies facilitate such operations while each node only needs to connect to a small number of other nodes.
In contrast to static communication networks, peer-to-peer networks allow nodes to adapt their neighbor set over time in order to react to join and leave events and failures.
This paper shows how to maintain such networks in a robust manner.
Concretely, we present a distributed and self-stabilizing algorithm that constructs a (variant of the) skip graph in polylogarithmic time from any initial state in which the overlay network is still weakly connected.
This is an exponential improvement compared to previously known self-stabilizing algorithms for overlay networks.
In addition, individual joins and leaves are handled locally and require little work.
Peer-to-peer computing is one of the most intriguing networking paradigms of the last decade.
Numerous Internet applications make use of peer-to-peer technology, including file sharing, streaming and gaming tools.
A distinguishing feature of these networks is that they typically have an open clientele, allowing machines to join and leave at any time and concurrently.
If no countermeasures are taken, the dynamic membership changes can degenerate the network, rendering central operations such as routing inefficient.
In an effort to gain deeper insights into (and deal with) these dynamics, researchers have studied different approaches.
In theory, the dominating approach has been to make sure that an overlay network never leaves a certain set of legal states so that at any time, information can be efficiently exchanged between its members.
This is mostly achieved through redundancy in the overlay network topology, which can significantly increase its maintenance overhead, so the rate of changes such networks can sustain might be rather limited.
However, a high change rate can happen due to heavy churn or join-leave attacks.
Also, partitions of the underlying physical network or DoS attacks may push the overlay network into some illegal state.
In this case, the overlay network may get into a state in which it is highly vulnerable to further changes, so proper recovery mechanisms are needed to get it back into a legal state as quickly as possible.
Some results are known in this direction, but most of the proposed protocols only manage to recover the network from a restricted class of illegal states (e.g., [2,5,34]).
Those few results known for truly self-stabilizing networks either just show eventual self-stabilization (e.g., [12]) or do not provide sublinear bounds on the convergence time (e.g., [19,31]).
Our work is the first that demonstrates that sublinear, in fact, polylogarithmic recovery time is possible.
More precisely, we present a self-stabilizing algorithm for a proper extension of the skip graph [3] (as the original skip graph is not locally checkable).
Skip graphs are very useful for scalable overlay networks.
They have logarithmic diameter and degree and constant expansion w.h.p. [4].
Also, like in hypercubic networks, no extra routing tables have to be maintained for fast, low congestion routing.
Before we delve into the details of our solution, we discuss related work and present our model.
There is a large body of literature on how to maintain peer-topeer networks efficiently, e.g., [3,8,10,18,22,28,30,32,34].
Recently, the first structured overlay networks have also found their way into the practical world; for instance, the Kademlia [29] overlay is used in the popular Kad network which can be accessed with eMule clients.
An interesting and flexible overlay structure are skip graphs [3,7,20,21,22].
These networks are based on the classical skip list data structure and allow for efficient, low-congestion routing while requiring a small node degree only.
Due to the typically very dynamic nature of peer-to-peer systems, there is a need to maintain the overlay topology or-in case of catastrophic eventsrecover it from arbitrary connected states.
While many results are already known on how to keep an overlay network in a legal state, not much is known about self-stabilizing overlay networks.In the field of self-stabilization, researchers are interested in algorithms that are guaranteed to eventually converge to a desirable system state from any initial configuration.
The idea of selfstabilization in distributed computing first appeared in a classical paper by E.W. Dijkstra in 1974 [15] in which he looked at the problem of self-stabilization in a token ring.
Since Dijkstra's paper, selfstabilization has been studied in many contexts, including communication protocols, graph theory problems, termination detection, clock synchronization, and fault containment.
For a survey see, e.g., [11,16,24].
Also general techniques for self-stabilization have been considered.
Awerbuch and Varghese [9] showed that every local algorithm can be made self-stabilizing if all nodes keep a log of the state transitions until the current state.
Since then several other methods have emerged including various local and global checking and correction techniques [6,13,25,35,36].
Also so-called time-adaptive techniques [23,26,27] as well as local stabilizers [1] have been presented which can recover any distributed algorithm in O(f ) time depending only on the number f of faults.
This, however, does not hold any more if faults include changes in the topology.
In this case, a single fault may require the involvement of all nodes in the system and is therefore quite expensive to fix.
Thus, people have also looked at so-called superstabilizing protocols, which are protocols that can handle a single topology change as well as arbitrary state faults with low overhead (e.g., [17]).
Interestingly, though much attention has been given to selfstabilizing distributed computing, even in the context of dynamic networks, the problem of designing self-stabilizing networks has only been given very little attention.
The general techniques mentioned above are not applicable here as they have not been designed to actively perform local topology changes (network changes are only considered as faults or dynamics not under the control of the algorithm).
Even though logging techniques such as [9] to convert non-self-stabilizing algorithms into self-stabilizing algorithms can also be applied to self-stabilizing networks, they usually need some non-local knowledge of the network (such as its size) to bound the state space which can make self-stabilization very expensive.
Our goal instead was to find dedicated, much more light-weight algorithms for self-stabilizing networks.Some preliminary work in this direction has already been done.
In the technical report of the Chord network [34], protocols are described which allow the topology to recover from certain degenerate states.
Similarly, it is also known how to repair skip graphs from certain degenerate states [3] but the problem of recovering them from an arbitrary connected state has remained open.
This is not surprising as the neighborhood information alone is not sufficient for the Chord network as well as skip graphs to locally verify the correctness of the topology.
Hence, additional information would be needed, which significantly complicates the self-stabilization process.In order to recover scalable overlays from any initial graph, researchers have started with simple non-scalable line and ring networks.
The Iterative Successor Pointer Rewiring Protocol [14] and the Ring Network [33] organize the nodes in a sorted ring.
However, the runtime of both protocols is rather large.
Aspnes et al. [2] describe an asynchronous protocol which turns an initially weakly connected graph into a sorted list.
Unfortunately, their algorithm is not self-stabilizing.
In a follow-up paper [5], a self-stabilizing algorithm is given for the case that nodes initially have out-degree 1.
In [31], Onus et al. present a local-control strategy called linearization for converting an arbitrary connected graph into a sorted list.
However, the algorithm is only studied in a synchronous environment, and the strategy may need a linear number of communication rounds.
Clouser et al. [12] formulated a variant of the linearization technique for asynchronous systems in order to design a selfstabilizing skip list.
Gall et al. [19] combined the ideas from [12,31] and introduced a model that captures the parallel time complexity of a distributed execution that avoids bottlenecks and contention.
Two algorithms are presented together with an analysis of their distributed runtime in different settings.
No sublinear time bounds are shown there either.To the best of our knowledge, this is the first paper to describe a self-stabilizing algorithm for a scalable overlay network (in our case, skip graphs) in sublinear time.
In fact, the skip graph construction terminates in a polylogarithmic number of communication rounds.
In addition to being able to recover quickly from an arbitrary connected state, we also show that when the network forms the desired topology, our algorithm efficiently supports join and leave events, which incur only a polylogarithmic amount of work to fix.
This means (in contrast to considering a completely new starting situation and recovering the structure in polylogarithmic time) that only a small part of the nodes are involved in repairing the overlay topology.
We represent an overlay network as a directed graph G = (V, E), where |V | = n. Each node is assumed to have a unique identifier (or short: ID) v.id ∈ U that is immutable, where U is the (ordered) universe of all identifiers.
At any time, each node can inspect its own state and the state of its current neighbors.
Beyond that, a node does not know anything, including the current size n of the overlay network.
Only local topology changes are allowed, i.e., a node may decide to cut a link to a neighbor or ask two of its neighbors to establish a link.
The view and the influence of a node are essentially local.
The decisions to cut or establish links are controlled through actions (which we will also call rules).
An action has the form label : guard → commands where guard is a Boolean predicate over the state of the executing node and its neighbors and commands is a sequence of commands that may affect the state of the executing node or request a new edge between two neighbors.
This is done via an insert(v, w) request by which a node asks its neighbor v to establish an edge to neighbor w.
An action is called enabled if and only if its guard is true.For simplicity, we assume that time proceeds in rounds, and all requests generated in round i are delivered simultaneously at the beginning of round i + 1.
In other words, we assume the standard synchronous message-passing model with the restriction that a node can only communicate with nodes that it has currently links to.
In each round, all actions that are enabled are executed by the nodes.
If two actions executed by the same node are in conflict with each other, any one of them may win and the other is discarded.
Our goal is to minimize the number of rounds needed in the worst case (over all initial states in which the network is weakly connected) until the overlay network has reached its desired structure.
We make this a bit more precise by defining what we mean by self-stabilization.
When using the synchronous message-passing model, the global state of the system at the beginning of each round is well-defined.
A computation is a sequence of states such that for each state si at the beginning of round i, the next state si+1 is obtained after executing all actions that were fired in round i.
In our context, we call a distributed algorithm self-stabilizing if from any initial state (from which a legal state is still reachable) it eventually reaches a legal state in which no more actions are enabled, i.e., once the overlay network reaches its desired topology, it does not change anymore.
Our goal will be to find a self-stabilizing algorithm that needs as few rounds as possible for this.
We present a variant of the skip graph, called SKIP + , that can be locally checked for the correct structure.
For this graph, we present a distributed self-stabilizing algorithm that arrives at SKIP + for any initial state in which the nodes are weakly connected in O(log 2 n) rounds.
This is an exponential improvement over all previous results on the number of communication rounds needed to arrive at a scalable overlay network.
We also show that a single join event (i.e., a new node connects to an arbitrary node in the system) or leave event (i.e., a node just leaves without prior notice) can be handled by our algorithm with polylogarithmic work, demonstrating that our algorithm is not just useful for the worst case but also for the case where the overlay network is already forming the desired topology (which is the standard case in the literature).
In the rest of this paper we present and analyze our self-stabilizing algorithm for SKIP + graphs.
The paper ends with a conclusion.
We first introduce the skip graph SKIP + we want to construct and then present our algorithm ALG + .
We start with the definition of the skip graph.
In skip graphs, the identity of a node v consists of two components: v.id , a unique but otherwise arbitrarily chosen identifier, and v.rs, a (pseudo-)random bit string of sufficient length that was uniformly chosen at random when the node entered the system.
Both parts are assumed to be immutable.For a node v and a subset W ⊆ V of nodes define the predecessor of v in W pred(v, W ) to be the node u ∈ W such that u.id = max{w.id | w ∈ W and w.id < v.id }.
By the assumption that no two nodes share the same id , this is well defined.
If such a u does not exist, set pred(v, W ) := ⊥ and define ⊥.
id = −∞.
Similarly define the successor of v in W succ(v, W ) to be u ∈ W such that u.id = min{w.id | w ∈ W and w.id > v.id }, or if this does not exist succ(v, U ) := and define .
id = ∞.
Here, −∞ and +∞ are resp.
the lowest and largest elements in the identifier space U not allowed as identifiers of real nodes.The definitions needed for the ideal skip graph are marked by a superscript * to distinguish them from analogous definitions used in the algorithm, which are all based on the current local views of the nodes.For any i ≥ 0, let pre i (v) denote the first i bits of v.rs (i.e., the prefix of v.rs of length i) and v.rs [i] represent the ith bit of v.rs.
Now define the level-i predecessor of v by pred * i (v) := pred(v, {w | pre i (w) = pre i (v)}), and the level-i successor of v by succ * i (v) := succ(v, {w | pre i (w) = pre i (v)}).
DEFINITION 2.1 (SKIP GRAPH).
Assume we are given a set of nodes together with associated IDs and random strings.
In the corresponding skip graph, every node v is connected exactly to pred * i (v) and succ * i (v) for every i ≥ 0 (except for the case of ⊥ and ).
Given unique node identifiers, the skip graph is uniquely defined.
It is not difficult to see that the skip graph has logarithmic diameter and maximum degree and allows hypercubic-style routing between any pair of nodes in O(log n) time, w.h.p. However, the nodes cannot locally verify the correctness of the skip graph topology.
Therefore, we propose a slight extension of the skip graph that we call SKIP + .
The definition of SKIP + requires us to also define (extended) predecessors and successors on level i with a specific value in the next bit.
For any i ≥ 0 and x ∈ {0, 1} define pred * i (v, x) = pred(v, {w | pre i+1 (w) = pre i (v)•x}) and similarly succ * i (v, x) (where operator • means concatenation of bit strings).
Letlow * i (v) = min{pred * i (v, 0).
id , pred * i (v, 1).
id } and high * i (v) = max{succ * i (v, 0).
id , succ * i (v, 1).
id }, and let v.range * [i] ⊆ U be defined as [low * i (v), high * i (v)].
With this, the SKIP + graph has the neighbor set N * i (v) of v at level i as the set of all nodes w withpre i (w) = pre i (v) and w.id ∈ v.range * [i].
DEFINITION 2.2 (SKIP + GRAPH).
Assume we are given a set of nodes together with associated IDs and random strings.
In the corresponding SKIP + graph every node v is connected to exactly the nodes in Since the skip graph is a subgraph of SKIP + (on the same set of nodes), SKIP + has a logarithmic diameter and constant expansion.
Also, it is not too difficult to see that the maximum degree remains logarithmic w.h.p. DEFINITION 2.3 (HEIGHT H ).
The height HG of a SKIP + graph G is defined as the maximal number of non-trivial levels.
A non-trivial level is a level which consists of more than one node, that is, HG = max{|ρ| : |Vρ| ≥ 2} whereN * i (v) for all i ≥ 0, i.e., N (v) = i≥0 N * i (v).
Vρ = {v ∈ V | ρ = pre |ρ| (v)}.
It is straightforward to show that H SKIP + is in O(log n) w.h.p.The goal is to establish the SKIP + graph as the target topology using bi-directed edges (this is why the edges in Figure 1 are undirected), but during the construction, the network has to deal with directed edges.
In the description and analysis of our algorithm, we will make use of the following definitions.DEFINITION 2.4 (GRAPH Gρ).
Given any directed graph G = (V, E) currently formed by the nodes and any prefix ρ, the graph Gρ = (Vρ, Eρ) is a subgraph of G where Eρ = {(u, v) ∈ E : u, v ∈ Vρ}.
The nodes in Vρ are called ρ-nodes and the edges in Eρ are called ρ-edges.
DEFINITION 2.5 (CONNECTED ρ-COMPONENT).
Given a prefix ρ, we will refer to a weakly connected component of nodes in Gρ as a connected ρ-component.
A pair of nodes in such a component is called ρ-connected.
For any node v let N (v) be its current outgoing neighborhood and v.range[i] be its current range at level i, which is based on its current view of pred i (v, x) and succi (v, x), where pred i (v, x) is the node such that pred i (v, x).
id = max{w.id | w ∈ N (v) and w.id < v.id and pre i+1 (w) = pre i (v) • x} and succi(v, x) is the node such that succi (v, x).
id = min{w.id | w ∈ N (v) and w.id > v.id andpre i+1 (w) = pre i (v) • x}.
For each level i, v.range[i] ⊇ v.range * [i], i.e, the current range will always be a superset of the desired range in the target topology (as defined in SKIP + ).
We will see that as long as no faults or adversarial changes happen during the self-stabilization process, ALG + monotonically converges to the desired ranges for every i.ALG + distinguishes between stable edges and temporary edges.
Node v considers an edge (v, w) to be temporary if from v's point of view (v, w) does not belong to SKIP + and so v will try to forward it to some of its neighbors for which the edge would be more relevant.
Otherwise, v considers (v, w) to be a stable edge and will make sure that the connection is bi-directed, i.e., it will propose (w, v) to w.
There is a binary flag v.F (w) for each neighbor w that states whether the edge to it is stable.
The flag turns out to be important when a stable edge destabilizes (i.e., converts into a temporary edge) because this triggers the introduction of several temporary edges that are needed for our proofs to go through.
The other conversion, from temporary to stable, essentially boils down to introducing also the other direction of the edge.
More details will be given later.The intuition behind the ALG + algorithm is as follows.
The algorithm has two main phases: The first phase proceeds in a bottom-up (i.e., from level 0 upwards) fashion, forming connected ρ-components for every prefix ρ.
This will be accomplished by letting each node v find another node w of the opposite color, i.e., such that pre i (w) = pre i (v) and v.rs[i + 1] = w.rs [i + 1] for all levels i ≥ 0 (we will call w a buddy of v).
We can show that once all nodes in Vρ have formed a single connected component and have found a buddy, then connecting all nodes which are at most three hops away in the ρ-component results in a single connected ρ0-and ρ1-component.
This will be accomplished by Rules 1 (where new nodes in the range of a node are discovered and where ranges may be refined) and Rules 3 (where an efficient variation of a local transitive closure is performed) below.Once the connected ρ-components are formed, the second phase of the algorithm will form a sorted list out of each ρ-component.
This is accomplished in a top-down fashion by merging the two already sorted ρ0-and ρ1-components into a sorted ρ-component until all nodes in the bottom level form a sorted list.Of course, this "division into phases"-intuition oversimplifies what is really going on in our algorithm.
Whereas for the sake of simplicity, we can think of the execution of the phases of the algorithm as being perfectly synchronized, with all nodes waiting for the connected components at level i to converge before the components at level i+1 are formed in the first phase, and with the sorting of the components at level i only starting after we have successfully sorted the components at level i+1 in the second phase (and of course with the second phase only kicking in after the first phase is completed), all actions in our algorithm may be enabled at any time, causing the phases to be intertwined in the real execution.
Hence, the main challenge in this paper is to show that nevertheless the actions transform any initially connected graph into SKIP + in O(log 2 n) rounds.
Now we are ready to present ALG + .
The local state of a node v consists of v.id , v.rs, N (v) (which imply the edges and ranges of v) and its flags.
We assume that every node v knows (besides its own local state) the current local state of all nodes w ∈ N (v).
Hence, the actions of a node v may be based on any local state information of v or its neighbors.
Recall that we assume the synchronous messagepassing model.
At the beginning of a round i, every node receives all the requests to establish an edge that were generated in the previous round.
After a preprocessing step in which each node updates its neighborhood and the state information about its neighborhood, a set of three types of actions is processed, which we also call rules here.
For readability, we will present the rules in words, but transforming them into the formal terminology of our model is straightforward.
We note that the preprocessing step is separated from the actions to ensure a deterministic state transition in the synchronous message-passing model.
In an asynchronous model, the preprocessing step would be continuously performed in the background at any time.
For each node u we do the following in a round:Preprocessing.First, a node u processes all insert(u, v) requests from the previous round where v ∈ V \ ({u} ∪ N (u)) (the others would be thrown away, but our algorithm avoids issuing such requests in the first place).
This is done by adding v to N (u) and setting its flag u.F (v) to 0 (temporary).
Then u makes sure that its state is valid, i.e., the flags carry binary values and N (u) is a set of nodes v = u that are all alive (otherwise, u removes that node from N (u)).
Now u determines for every i its current predecessors pred i (u, 0) and pred i (u, 1) and its current successors succi(u, 0) and succi(u, 1) (within N (u)).
This allows u to update its range information.
The updated local state is exchanged between the nodes so that the rules below are based on up-to-date information.DEFINITION 2.6 (STABLE EDGES).
Every edge (u, v) is con- sidered stable, if• its endpoints mutually fall on each other's range at some levelpre i (u) = pre i (v), i.e., v.id ∈ u.range[i] and u.id ∈ v.range[i], for some i.
In this case (u, v) is defined to be stable on all levels j ≥ i with pre j (u) = pre j (v).
Or• v = pred i (u, x) or u = pred i (v, x), or v = succi(u, x) or u = succi(v, x), for some level i and bit x ∈ {0, 1}.
In this case (u, v) is stable only on level i.This second kind of stable edges is needed to stay in touch with a "buddy" (see below), in order to forward temporary edges.
Our algorithm guarantees that once a node has a buddy to the left (or to the right), it will always have such a buddy in the future.
DEFINITION 2.7 (LEVEL OF TEMPORARY EDGE).
We define the level of a temporary edge (u, v) as the length of the longest common prefix of u and v.All of the rules below are only activated if the resulting action changes the graph or the state, i.e., if the to be inserted edge does not already exist or the flag changes its value.
For every stable edge (u, v), u sets F (v) = 1 (if it has not already done so) and initiates an insert(v, u) request.
For every stable neighbor v (the edge (u, v) is considered stable as defined in Preprocessing) of a node u, for every i ≥ 0 and every node w ∈ N (u), w = v with pre i (v) = pre i (w) and w.id ∈ v.range [i], node u initiates insert(v, w) (Rule 1b) and insert(w, v) (Rule 1c).
Every temporary edge (u, v) is forwarded to a stable neighbor of u that has the largest common prefix with v.rs.
(Such an edge exists because otherwise (u, v) would be a stable edge.)
Rule 3a: Introduce All.For all nodes u ∈ V whose set of stable neighbors is different from the previous round, u initiates insert(v, w) for all neighbors w of u. (In particular, if an edge destabilizes, both incident nodes will introduce their neighbors.)
Rule 3b: Linearize.For every level i, u identifies the stable neighbors v1, . . . , v k with v1.id < v2.id < . . . < v k .
id that have exactly the first i bits in common with u.rs and initiates insert(v1, v2), insert(v2, v3),. . ., insert(v k−1 , v k ) for them.
We first analyze the bottom-up phase and then tackle the topdown phase.
LEMMA 3.1.
Consider any bit string ρ ∈ {0, 1} * .
Suppose that nodes a and b are ρ-connected at time t0.
Then a and b are also ρ-connected at any time t ≥ t0.PROOF.
We prove the lemma by induction over the time steps.
Consider any edge e = (u, v) (temporary or stable) at time t ≥ t0 with u, v ∈ Vρ.
The only rule that may remove this edge is Rule 2, all other rules only create edges.
If the edge e is forwarded by Rule 2 to a node w, node w must have a shared prefix with u that extends ρ, and all three nodes u, v, w remain connected in Gρ at the next time step.In the following lemma, an edge (u, v) is said to be to the right (resp.
left) if u.id < v.id (resp.
u.id > v.id ).
LEMMA 3.2.
Assume a node u has a stable ρ-edge to the right (left) at time t0.
Then at any time t > t0, node u will have a stable ρ-edge to the right (left).
PROOF.
By induction over time.
A stable ρ-edge (u, v) only destabilizes because the |ρ|-range of u has become smaller, and there now is another ρ-node w stably connected to u, and w is between u and v.A ρ-buddy of a node u is a stable neighbor v (the edge (u, v) exists and is considered stable) with pre |ρ| (u) = pre |ρ| (v) = ρ and u.rs[|ρ| + 1] = v.rs [|ρ| + 1].
Our algorithm ensures that once a node has a left (or right) buddy at time t, then it will also have a left (or right) buddy at all times t ≥ t.
In the following, the V in V-linked does not refer to a set V but to the V-shaped situation of two nodes being linked indirectly via precisely two edges to a third node.
LEMMA 3.4.
Assume that u and v are σ-V-linked via w at time t. Then, at time t + 1 the nodes u and v are σ-connected, i.e., in the same connected component of Gσ.PROOF.
Assume (w.l.o.g.) that u, v have label σ = ρ1, and w has label ρ0.
By Rule 3b, all stable ρ1-neighbors of w are in the same ρ1-component C at time t + 1.
If (w, u) is a temporary edge, this is forwarded to one of the stable ρ1 neighbors of w, and hence u is also in the ρ1-component C. By the same reasoning v is also in C at time t + 1, which proves the lemma.LEMMA 3.5.
Consider any ρ ∈ {0, 1} * and x ∈ {0, 1}.
Let node a with label ρx be a ρ-buddy of u at time t and b a ρ-buddy of u at time t ≥ t.
Then a and b are in the same ρx-component at time t + 1.
PROOF.
If than t = t , this follows from Lemma 3.4.
Otherwise the proof is an induction over time.
Let a = at, at+1, . . . , a t = b be ρ-buddies of u at the respective times.
With Lemma 3.1, it suffices to show that ai−1 and ai are in the same ρx-component at time i + 1.
Because no rule deletes or forwards stable edges, the edge (u, ai−1) exists at time i and Lemma 3.4 can be applied.Note that the σ in "σ-V-linked" refers to the nodes that are linked, not the node that is providing the link.
Similarly, we define a bridge by the prefix of the nodes that are connected by this bridge, not by the nodes that provide the bridge.
The following definition is needed to show connectedness moving up the levels by the rules.
It is central to the bottom-up proof that eventually for all prefixes ρ we have that Gρ consists of only one connected component.
In the process where the connectedness of Gρ0 follows from Gρ being connected, the bridges play an important role.
First, as long as a bridge is temporary, the level increases in every step, but then, once it becomes a stable bridge, the level of the used bridges decreases.
DEFINITION 3.7 ((σ, k)-PRE-COMPONENT).
Two nodes a and b, both with prefix σ = ρx for some x ∈ {0, 1}, are (directly) (σ, k)-pre-connected if (1) Gρ is connected, if (2) every node in Gρx knows at least one node from Gρx and vice versa, 1 and if (3) there is an edge (irrespective of this being temporary or stable), between a and b, or if they are σ-V-linked, or if there exists a stable (σ, k )-bridge with k ≤ k between them.
The transitive closure of this (undirected) relation defines the (σ, k)-pre-component.
Requirements (1) and (2) will be made precise in the subsequent analysis and especially Lemma 3.14 where the connectivity of Gρ is proved by induction.
Note that for k = 0, the σ-links and the (σ, 0)-pre-component (but without stable bridges) yield the transitive hull of the σ-V-links.
Figure 2 illustrates the situation.
PROOF.
Assume w.l.o.g. σ = ρ1.
By induction over time, and the definition of the pre-component being a transitive closure, it is sufficient to argue that nodes a, b with prefix ρ1 that are directly (σ, k)-pre-connected at time t are in the same (σ, k)-pre-component at time t + 1.
If a, b are directly linked, we can employ Lemma 3.1, and the case that they are σ-V-linked is due to Lemma 3.4.
The remaining (and only interesting) case is that a and b have a (σ, k)-bridge via a stable edge e = (u, v) (then there are also stable edges (u, a) and (v, b)) at time t. Let a and b be σ-nodes that are stable neighbors of u and v respectively.
Then a and a are σ-V-linked and are in the same σ-component at time t+1 by Lemma 3.4.
The same reasoning shows that b and b are in the same σ-component at time t + 1.
If e remains stable, a and b have a (σ, k)-stable bridge also at time t + 1.
Otherwise e destabilizes and by Rule 3a a temporary edge (v, a ) or (u, b ) is present at time t + 1, so a and b are σ-V-linked via v or u, and hence in the same (σ, k)-pre-component at time t + 1.
PROOF.
If a and b are in the same (σ, k)-pre-component (assume again that σ = ρx for some x ∈ {0, 1}), there must exist a path a = p1 p2 ... p = b where pj is connected to pj+1 either directly, via a σ-V-link, or via a stable (σ, k)-bridge.
We only allow a bridge between pj and pj+1 if these two nodes are not in the same (σ, 0)-pre-component.
Consider this path and assume pj and pj+1 are connected by a bridge over an edge e = (u, v) of length λ (w.r.t. node identifiers, u and v having prefixes of the form ρxτ y where |τ | = k − 1 and y ∈ {0, 1}).
Then, whenever possible, we replace e by two edges via an intermediate node w if for the lengths it holds that |(u, w)| < λ and |(w, v)| < λ.
Thus, in our path, a new node p * -w's buddyis inserted, maintaining our "path property".
Note that this process terminates (the number of "turning points"-the local extrema of the identifiers along the path-does not increase).
Consider a bridge edge (u, v) on this path with shortest bridges.
First, consider the case that (u, v) is unilaterally stable because of the nearest neighborhoods.
That is, w.l.o.g. assume v is u's nearest neighbor but for some level, u is not in v's range.
Then, it holds that v must know two closer nodes than u (due to the range definition), one of which will be proposed to u in the next round (hence (u, v) will no longer be stable), triggering Rule 3a at t + 2, from which the claim follows.From now on it remains to consider the case where u and v mutually include each other in their ranges on some level.
First assume that (u, v) is stable on a level > |σ|-the other case where (u, v) is stable on level |σ| is treated later.
Let us refer to the lowest level where (u, v) is stable as i+1, that is, where pre i+1 (u) = pre i+1 (v) but either u.id / ∈ v.range [i] or v.id / ∈ u.range[i] (or both, cf Definition 2.6), so |σ| + k ≥ i + 1 > |σ|.
W.l.o.g., assume that u.id / ∈ v.range [i].
Due to the definition of the ranges, v must have both a stable predecessor (relatively to the current neighborhood) with last bit 0 and a predecessor with last bit 1 that lie between u and v: w0 = pred i (v, 0) and w1 = pred i (v, 1).
Let w ∈ {w0, w1} such that pre i+1 (u) = pre i+1 (w) = pre i+1 (v).
See Figure 3.
However, (w, u) ∈ E at time t, due to our selection of the shortest bridge path: (u, w) and (w, v) would imply a path (see your "path property" described before) with shorter bridges.
Thus, at time t + 1, (u, w) is created by Rule 1b.
Now, we will show that this triggers u to fire Rule 3a at t+2, either because (u, w) becomes stable or because (u, v) becomes instable.
(Note that (u, v) must be stable at time t, since the edge forms a bridge.)
Observe that it is not possible that (u, v) remains stable and (u, w) is instable, since both are within u's range on level i + 1, as u and w have a common prefix ρ = pre i+1 (w).
Thus, at time t + 1, Rule 3a is triggered at u, and thus, at t + 2, a and b are σ-V-linked and connected in round t + 3.
Observe that if w has a buddy w closer to u, see Figure 3, the same arguments apply, as w will be introduced to v, which triggers Rule 3a at v.It remains to study the case where (u, v) is stable on level i = |σ| (see Figure 4).
Assume u is stably connected to pj and v is stably connected to pj+1 (u, v ∈ Gρx).
We distinguish two cases: Either there is a node c ∈ Gρx between u and v or not.
First, assume there is such a node c, and w.l.o.g., assume c is stably connected to v on level |ρ|.
(Observe that due to our path selection, c / ∈ Gρx, and hence it holds that c ∈ Gρx.)
We will show that in this case, a new connection (u, c) is proposed.
Thus, there cannot be both edges (u, c) and (c, v), otherwise the bridge would not be necessary, as the nodes must be in the same (σ, 0)-pre-component.
Therefore, either (u, v) destabilizes at time t + 1, triggering Rule 3a at t + 2, or (u, c) or (c, v) must be proposed according to Rule 1b.
By the same reasoning as above, the claim follows for time t + 4 in this case.If there is no such node c, consider the buddy of u or v closest to position µ = (u.id + v.id )/2.
That is, let B denote the set of all buddies of u and v on level i, i.e., B = (N (u) ∪ N (v)) ∩ Gρx.
Let w ∈ B be the buddy which minimizes |µ − w|.
Without loss of generality, assume w is the buddy of u.
Now let w be the buddy of v which is located on the same side of µ as w. Observe that v.range [i] is defined by w due to our assumption that c does not exist and since w is further away from µ and hence also from v. Therefore, w ∈ v.range [i].
On the other hand, if no such w exists, then v.range [i] is not bounded, and the claim follows trivially.
Thus, a and b are σ-V-linked in round t + 2.
Therefore, the claim also follows for the case i + 1 = |σ|, which concludes the proof.
LEMMA 3.10.
A temporary edge (u, v) of level at time t is either transformed into a stable edge or forwarded and changed by this into a temporary edge of level at least + 1.
PROOF.
Let ρ be the common prefix of u and v with |ρ| = , and assume w.l.o.g. that u has label ρ0 and v has label ρ1.
If (u, v) is temporary, it either becomes stable by Rule 1a or there must be a stable ρ1-node w ∈ N (u) between u and v In this case, Rule 2 replaces (u, v) with (w, v) for such a w, which is a temporary edge of level at least + 1.
The following lemma follows from the previous one because no temporary edge has a level higher than the height H.LEMMA 3.11.
Every temporary edge becomes stable after H time steps.Next, the case of temporary bridges is investigated.LEMMA 3.12.
Assume two ρx-nodes a, b for some x ∈ {0, 1} are directly connected by a temporary ρx-bridge, i.e., there is a temporary edge (u, v) and stable edges (u, a) and (v, b).
Then, for k = H − |ρ|, a and b are (ρx, k)-pre-connected at time t + k.PROOF.
W.l.o.g. let x = 1.
By the rules of temporary edges, the destination v never changes.
Let bi be a ρ-buddy of v, i.e., the stable edge (v, bi) exists at time t + i, b0 = b.
At time t + i + 1, there is at least the temporary edge (v, bi), and bi and bi+1 are ρ1-V-linked, and hence, by Lemma 3.8, bi is (ρ1, k)-pre-connected with b also at time t + k.Let ui be the starting point of the temporary edge at time t + i, i.e. (ui, v) be the temporary edge, and let ai (with a0 = a) be some stable neighbor of ui at that time, i.e., the stable edge (ui, ai) exists at time t + i.
At time t + i the stable edge (ui, ui+1) exists (because the temporary edge was forwarded along this edge).
Further, let ci be some stable neighbor of ui+1 at time t + i.
If this does not exist, set ci = ai, and note that at time t + i + 1 the stable edge (ui+1, ai) must exist because of Rule 1b.
By definition, ai and ci have a stable (ρ1, k )-bridge for k ≤ k and are hence (ρ1, k)-pre-connected.
At time t + i + 1 at least the temporary edge (ui+1, ci) exists, and hence ci and ai+1 are ρ1-V-linked, so by Lemma 3.8 ai is (ρ1, k)-pre-connected with a at time t + k.By Lemma 3.10 the level of (ui, v) is at least |ρ| + i. Hence for some j ≤ k the stable edge (uj, v) exists at level smaller than H at time t + j. Hence, at time t + j the nodes aj and bj are (ρ1, k)-preconnected, and we can conclude from Lemma 3.8 that a and b are (ρ1, k)-pre-connected at time t + k.LEMMA 3.13.
Consider any bit string ρ ∈ {0, 1} * .
Suppose that Gρ is weakly connected at time t0.
Then every node u ∈ Vρ will have a neighbor in Vρ0 and Vρ1 within O(log n) rounds.PROOF.
Consider any node u that does not have a neighbor in Vρ0 or Vρ1.
In this case, u.range [i] = U for i = |ρ|, which implies together with Rule 1b and Rule 1c that every node v ∈ N (u) ∩ Vρ with missing ρ-buddy will introduce every node w ∈ N (v) ∩ Vρ to u. Suppose w.l.o.g. that u is still missing a node in Vρ0.
Then the neighbor introduction of Rule 1b and Rule 1c implies that the distance of u in Gρ to the closest node in Vρ0 is cut in half in each round.
Thus, it takes at most O(log n) rounds into a node in Vρ0 is a direct neighbor of u, which implies the lemma.Lemma 3.13 can also be proved by observing that in every round, due to the "pointer doubling" operations, the diameter of the connected component formed by nodes without a buddy is cut in half.LEMMA 3.14.
Assume Gρ is connected at time t. Then, at time t + (H − |ρ|) + O(log n) the graph Gρ0 is connected and so is Gρ1.PROOF.
Define k = H − |ρ|.
At time t0 = t + O(log n), by Lemma 3.13, every ρ0 node has a stable connection to a ρ1 node and vice versa.
Let a and b be two ρ1 nodes.
Because Gρ is connected at time t, it is so at time t0, and there is a path a = u1, u2, . . . , um = b in Gρ at time t0.
If ui is a ρ0 node, define vi to be one of its ρ1 buddies, otherwise set vi = ui.
Then, by definition, at time t0 the nodes vi and vi+1 are either directly connected, or connected by a temporary (ρ1, k)-bridge.
Hence, by Lemma 3.12 (or Lemma 3.1), at time t0 + k the nodes vi and vi+1 are in the same (ρ1, k)-precomponent, and by Lemma 3.9, Lemma 3.8, and Lemma 3.1 vi and vi+1 are in the same connected component of Gρ1 at time t0 + k + O(1).
With this and the symmetric argument for Gρ0 the claim of the lemma follows.
In the previous section, it has been shown that in O(log 2 n) rounds, all nodes sharing a given prefix ρ have discovered each other and are connected (via other nodes with prefix ρ).
In addition, each node is connected-on each level-to at least one "buddy" having the opposite last bit of the corresponding prefix.
We now prove that after these properties have been achieved, the final SKIP + topology is established in only O(log n) rounds.The analysis of the top-down phase is done by induction overloading.
For our induction step, we need the concept of finished levels.
DEFINITION 3.15 (i-FINISHED).
We say that a graph is ifinished if and only if 1.
∀ρ with |ρ| = i, it holds that Gρ contains all edges of the SKIP + -graph as stable edges;2.
∀u ∈ V let ρ = pre i (u) and ∀j < i: if v is a level j rightbuddy of u (current closest node on the right with pre j (v) = pre j (u) and v.rs[j + 1] = u.rs[j + 1]), then for all ∀w with pre i (w) = ρ (i.e., w ∈ Gρ) and w lying between u and v, i.e., w.id ∈ [u.id , v.id ], it holds that u and w are connected by a stable edge.
If there is no such buddy v, then u is connected to all nodes to the right of u in Gρ; and similarly to the left.
Figure 5 shows an example.Observe that after the bottom-up phase, the "top label" is finished trivially: This label forms a graph Gρ with more than one node, whereas Gρ1 and Gρ0 are trivial, i.e., consist of a single node.
Clearly, for a top label ρ the graph Gρ consists of precisely two nodes.
In addition, once the graph Gρ is connected, it contains all edges of the SKIP + -graph as stable edges.The following reasoning shows that the levels will finish one after the other starting from the highest level (hence this phase's name), where each level takes constant time only.LEMMA 3.16.
Assume at time t the graph is i-finished.
Then, at time t + 3, the graph is (i − 1)-finished PROOF.
Figure 6 illustrates the situation.
We consider a node u.
We will show that at time t + 1, u knows its closest level-i neighbor w in the direction of the old buddy (that must exist due In order to prove that u knows its closest neighbor w at time t+1, we distinguish three cases.
From the bottom-up phase, we know that u already has a buddy on one side.
Without loss of generality, assume this buddy is on the right of u. Let this buddy node be denoted by v.Case I: If v is already the closest node to the right, the claim holds trivially (v = w).
We know that w also has a buddy, which can either be on the right (Case II) or on the left (Case III) of w (and hence also u).
Let w's buddy (take any if w has two) be denoted by w .
Case II: Assume w is also on the right of w.
We distinguish two cases: Either v is left of w or right of w .
If v is left of w , by our induction hypothesis, w must have a stable edge to node v. By Rule 1b and Rule 1c, v will introduce w to u at t + 1 (edge (w, u)), and the claim follows.
The case where v is right of w is analogue: the roles of v and w are simply switched.Case III: Now assume w has a buddy w on the left.
We distinguish two cases.
If u has another buddy u on the left as well, the same arguments as in Case II show that either u or w will introduce the corresponding neighbors at time t + 1.
If, on the other hand, u does not have a buddy on the left, then by our induction hypothesis, w must have a stable edge to u, over which u is introduced to w in the next round as well.Finally, observe that after all levels are finished, all non-SKIP + edges must be temporary.
They will be forwarded towards the highest level and disappear in logarithmic time (in H rounds).
Therefore, we conclude that the top-down phase takes logarithmic time only.
From the previous discussion, we can draw the following conclusions.
From Lemma 3.14, by summing up over all levels, it follows that the bottom-up phase lasts for at most O(log 2 n) rounds w.h.p.
The subsequent top-down phase takes time O(log n) (cf Lemma 3.16) w.h.p. Thus, we have derived the following theorem.
THEOREM 3.17.
Given an arbitrary weakly connected graph, the self-stabilizing algorithm ALG + constructs SKIP + in O(log 2 n) rounds, w.h.p.
In this section we study the amount of work it takes to handle a node departure (leave) or the inclusion of a new node (join).
We show that once we reach a valid SKIP + graph, our algorithm can efficiently support any single join or leave operation in O(log 4 n) work and O(log n) rounds w.h.p. For proving this result, we first need to bound the degree of a node in SKIP + .
LEMMA 4.1.
The degree of a node v in SKIP + is O(log n) w.h.p.PROOF.
Recall the definition of a SKIP + graph and consider any node v. For any level i, let the random variable X R i be defined asX R i = max{|{w ∈ N * i (v) | w.id > v.id}| − 1, 0}.
In order to bound the probability that X R i = k for some k > 0, = H i=1 X R i, where H = Θ(log n) is an upper bound on the number of levels that holds w.h.p., it follows thatPr[XR = d] ≤ d H 1 2 d−H .
If d = c · H, we get d H 1 2 d−H ≤ (ec) H 2 cH−H ≤ 1 n cfor some constant c that can be made arbitrarily large if the constant c is sufficiently large.
Hence, the number of v's neighbors to the right is at most O(log n) w.h.p.
A similar argument applies to the left neighbors of v, which implies the claim.
THEOREM 4.2.
When a node v leaves the system, it takes O(log n) rounds of the algorithm and O(log 4 n) total work w.h.p. for the graph to converge back to a valid SKIP + structure.PROOF.
Certainly, only the nodes that were directly connected to node v will need to adapt their current set of neighbors upon the departure of v (since the departure of v could not possibly alter the neighborhoods or ranges of other nodes, given that v is directly connected to all nodes in its range for all levels).
By Lemma 4.1, the size of the entire neighborhood of node v (across all levels) is O(log n) w.h.p., so only O(log n) nodes need to change their neighborhood.In order to show that these O(log n) nodes can quickly adapt their neighborhoods, we distinguish between several cases for every level i.
In these cases, let V l (resp.
Vr) be the set of all left (resp.
right) neighbors w ∈ N * i (v) with w.rs[i + 1] = v.rs [i + 1] and let W l (resp.
Wr) be the set of all left (resp.
right) neighbors w ∈ N * i (v) with w.rs[i + 1] = v.rs[i + 1].
Certainly, V l ∪ Vr ∪ W l ∪ Wr = N * i (v).
Let v l , vr, w l and wr be the closest neighbors in V l , Vr, W l and Wr to v. Let us assume for now that v l , vr, w l and wr exist.Case 1: w l .
id < v l .
id < vr.id < wr.id.
In this case, all neighborhoods are correct once v has been removed, so no further edges are needed by the nodes.Case 2: v l .
id < w l .
id < vr.id < wr.id.
In this case, all nodes in {v l } ∪ W l \ {w l } have to learn about vr and vice versa to update the neighborhoods.
The other nodes just have to remove v from their neighborhood.
Since w l has edges to all nodes in {v l , vr} ∪ W l , a single round of applying Rule 3a suffices to update all neighborhoods correctly.Case 3: w l .
id < v l .
id < wr.id < vr.id.
This case is just the reverse of Case 2.
Case 4: v l .
id < w l .
id < wr.id < vr.id.
In this case, all nodes in {v l } ∪ W l have to learn about Wr ∪ {vr} and vice versa.
Since w l knows {v l } ∪ W l ∪ {wr} and wr knows {w l } ∪ Wr ∪ {vr}, after one round of applying Rule 3a, all nodes in {v l } ∪ W l learn about wr and all nodes in Wr ∪ {vr} learn about w l .
Since the stable neighborhoods of w l and wr just got updated, w l and wr will trigger another round of "introduce all" by Rule 3a, son nodes in {v l ∪ W l ∪ Wr ∪ {vr} will have updated their neighborhoods by the second round.The other cases when some of the nodes v l , vr, w l and wr do not exist are very similar and dropped here.
Hence, after at most two rounds, all (stable) neighborhoods have been updated.
Since only O(log n) nodes need to change their neighborhood, and each of these nodes inserts at most O(log 2 n) edges due to Rule 3a in each round, at most O(log 3 n) edges are inserted in total.
These either merge with stable edges, become a new stable edge or become a temporary edge.
Each of the temporary edges will need at most O(log n) applications of Rule 2 until it merges with a stable edge.
Hence, altogether the time is bounded by O(log n) and the work is bounded by O(log 4 n).
THEOREM 4.3.
Assume a new node v joins the system by establishing an edge to a node u which is currently in SKIP + .
It will take O(log n) rounds of the algorithm and O(log 4 n) total work w.h.p. for the graph to converge back to a valid SKIP + structure.PROOF.
Upon learning about node u, node v immediately considers edge (v, u) as stable (since u is currently the only predecessor or successor node v knows).
That will prompt the insertion of edge (u, v) by Rule 1a.
If u considers (u, v) as a temporary edge, then it forwards the edge via Rule 2 to a node u with a longer prefix match with v than u.
This leads, after at most H steps, to a stable edge (w, v).
Till then, v keeps inserting the edge (u, v) in each round (as it considers u to be a stable neighbor), so there will be a string of temporary edges moving upwards from u. Besides Rule 2, no other rule will be applied at this point by the old nodes in SKIP + .
Suppose that w is the first node that considers the edge (w, v) to be stable.
Let i be the maximum level such that pre i (v) = pre i (w).
Let V l (resp.
Vr) be the set of all nodes to the left (resp.
right) of v in SKIP + of maximum cardinality so that for all w ∈ V l (resp.
w ∈ Vr), pre i+1 (w ) = pre i+1 (v) and there is no node w in between the nodes of V l (resp.
Vr) with maximum common prefix equal to i with v. Moreover, let W l (resp.
Wr) be the set of all nodes to the left (resp.
right) of v of maximum cardinality so that for all w ∈ W l (resp.
w ∈ Wr), the maximum common prefix with v is equal to i and there is no node w in between the nodes of W l (resp.
Wr) with maximum common prefix more than i with v. Let v l , vr, w l and wr be the closest neighbors in V l , Vr, W l and Wr to v. Let us assume for now that v l , vr, w l and wr exist.
Recall that w considers v to be a stable neighbor.
Suppose w.l.o.g. that v is to the right of w.
We distinguish between the following cases.Case 1: w l .
id < v l .
id < vr.id < wr.id.
In this case, all nodes in {w l } ∪ V l ∪ Vr ∪ {wr} have to connect to v and vice versa, and besides these, no other connections are needed to fully integrate v into level i.
Since w = w l and w therefore knows all nodes in V l ∪ Vr ∪ {wr} by the SKIP + definition, one round of applying Rule 3a (which is caused by (w, v)) suffices to fully integrate node v into level i.Case 2: v l .
id < w l .
id < vr.id < wr.id.
In this case, all nodes in {v l } ∪ W l ∪ Vr ∪ {wr} have to learn about v and vice versa to fully integrate v into level i.
Since w is a node in W l , w has links to all nodes in {v l } ∪ W l ∪ Vr ∪ {wr}, so again one round of applying Rule 3a suffices to fully integrate node v into level i.Case 3: w l .
id < v l .
id < wr.id < vr.id.
In this case, all nodes in {w l }∪V l ∪Wr ∪{vr} have to learn about v and vice versa to fully integrate v into level i.
Since w = w l , w has links to all nodes in V l ∪{wr}.
Hence, one round of Rule 3a introduces v to the nodes in V l ∪ {wr} and vice versa.
Afterwards, wr will apply Rule 3a since its stable neighborhood changed due to v, so wr will introduce v to Wr ∪ {vr} and vice versa, which completes the integration of v into level i.Case 4: v l .
id < w l .
id < wr.id < vr.id.
In this case, all nodes in {v l } ∪ W l ∪ Wr ∪ {vr} have to learn about v and vice versa to fully integrate v into level i.
As w is any node in W l , w knows about {v l } ∪ W l ∪ Wr ∪ {vr}, so one round of applying Rule 3a suffices to fully integrate node v into level i.The remaining cases in which v l , vr or wr do not exist are similar and dropped here.
Hence, it takes at most two rounds to fully integrate v into level i.Once v is fully integrated into a level i, it knows the closest predecessor and successor w in SKIP + with maximum prefix match at least i + 1 (if it exists).
Since each of these nodes will consider v to be a stable neighbor in level i + 1, we can use similar case distinctions as above to show that v will be fully integrated into level i + 1 in at most two further rounds.
Node v also knows its closest predecessor and successor w in SKIP + with maximum prefix match at least i.
Since each of these nodes will consider v to be a stable neighbor in level i − 1, we can also use similar case distinctions as above to show that v will be fully integrated into level i−1 in at most two further rounds.
Using these arguments inductively implies that v will be fully integrated into the SKIP + graph in O(log n) time.
It remains to bound the work.
The first part (creating and forwarding temporary edges), 2 just consumes O(log 2 n) work.
Each time a node destabilizes, O(log 2 n) new edges are created.
Certainly, only nodes that will consider v to be their stable neighbor (and vice versa) will destabilize, and we know from Lemma 4.1 that the degree of v in SKIP + will be O(log n) in the end w.h.p. Hence, altogether at most O(log 3 n) new edges are created.
These either merge with stable edges, become a new stable edge or become a temporary edge.
Each of the temporary edges will need at most O(log n) applications of Rule 2 until it merges with a stable edge.
This yields the claim.
This paper described the first self-stabilizing algorithm that quickly establishes a scalable peer-to-peer topology out of any state in which this is in principle possible.
Our work opens many important directions for future research.
In particular, so far, we do not have a polylogarithmic bound on the enabled actions per node and round.
Hence, we want to explore the corresponding complexities further and come up with the necessary algorithmic modifications.
