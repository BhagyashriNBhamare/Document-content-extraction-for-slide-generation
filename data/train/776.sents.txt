Given a database instance and a corresponding view instance , we address the view definitions problem (VDP): Find the most succinct and accurate view definition, when the view query is restricted to a specific family of queries.
We study the tradeoffs among succintness, level of approximation , and the family of queries through algorithms and complexity results.
For each family of queries, we address three variants of the VDP: (1) Does there exist an exact view definition , and if so find it.
(2) Find the best view definition, i.e., one as close to the input view instance as possible, and as succinct as possible.
(3) Find an approximate view definition that satisfies an input approximation threshold, and is as succinct as possible.
Our work can be differentiated from related work in two ways: the scope of the problem addressed, and the evaluation metrics.Related to scope, we address a narrower problem than others but with more depth.
For example, decision trees [12] are used to classify items.
Our VDP can be viewed as a classification problem with only two classes: tuples in V and those not in V .
Thus, VDP is narrower since only two classes are considered.
However, we go deeper into this subproblem by considering multiple query families and multiple optimization criteria.
Similarly, Query By Output (QBO) [15] is a more general problem than ours.
In QBO, we are given V and R1, R2, . . . , Rn, and asked to return Q such that Q(R1, R2, . . . , Rn) = V .
Thus, VDP is the special case where n = 1 and there are no joins nor projections.
However, as mentioned above, we thoroughly study the VDP subproblem by considering different classes of selection queries and multiple optimization criteria.The second differentiator for our work is the metrics we use: succinctness and level of approximation.
Most classification work, on the other hand, relies on experimental generality, mentioned earlier.
When generality is a goal, we are given, in addition to D and V (the training sets), two test data sets, DT and VT .
Query Q is determined without seeing the test sets, only using the training sets.
However, Q is evaluated by the level of approximation of Q(DT ) to VT .
Generality is an experimental measure, although one can study generality by assuming that D and DT (and V and VT ) have "similar" statistical properties.
On the other hand, our notion of succinctness is an intrinsic property of a query.
Intuitively, a succinct query will be more general than a less succinct query that overfits the data.
In addition, succinctness is also desirable because it yields more readable (and more maintainable) queries.
When succinctness is a goal (as it is in this paper), we can obtain theoretical guarantees, e.g., an algorithm can find the most succinct Q within a family of queries in quadratic time.Next we present some additional details about decision trees and QBO.Classification: Decision trees are used to classify items into n ≥ 2 classes.
A decision tree is simply a binary tree with each tree node annotated with a predicate.
One child of the node corresponds to the predicate evaluating to true, and the other child corresponds to the predicate evaluating to false.
Each leaf node is labeled with a class label from C1, . . . , Cn.
For VDP, we restrict n = 2 (tuple present in the view, or not present in the view).
Thus a decision tree for n = 2 corresponds to a query of the following form: Q = (p1 ∧ Q ) ∨ (¬p1 ∧ Q ), where p1 is the splitting predicate, and Q and Q are recursively of the same form.
However, note that some queries may not be directly expressible using decision trees.
For example, the query (((A = 3) ∧ (B = 4)) ∨ (B = 5)), which may be the query with the smallest number of predicates cannot be directly expressed as a decision tree (since each node in a decision tree divides/splits the items into two mutually exclusive sets).
In our work we not only consider more general queries, but we also provide a taxonomy of different query families, showing how complexity of VDP relates to the query family.
In addition, as mentioned earlier, we do not use experimental generality, but focus on metrics that do not need test data.Query by Output: In [15], QBO is cast as a classification problem (into two classes: tuples in V , and tuples not in V ) and decision trees are used to find a compact query.
A decision tree is constructed in a greedy fashion by determining a "good" predicate to split the tuples into two classes.
These two classes form the root nodes of two decision trees (each of which is constructed in a recursive fashion).
The "goodness" of a predicate is assessed using a metric called Gini's index [14], and the best predicate is the one that reduces the Gini's index the most.
Reference [15] does not explicitly try to optimize our metrics of succinctness or level or approximation, nor does it study the tradeoff between these metrics.
Also, it does not consider the different families of queries that we do.
In this paper, we assume that database D is a single relation R.
We additionally assume that the relation R and the view V have the same schema.
For V to be a meaningful view of R, it is necessary that V ⊆ R.
We assume set semantics throughout the paper.Since we deal with single table relations with both V and R having the same schema, any query Q can be represented as a selection condition.
Any selection condition can be expressed as a DNF (Disjunctive Normal Form) formula, i.e., Q ≡ c1 ∨ c2 ∨ . . . ∨ cn.
Each ci, called a conjunctive clause, is of the form pi1 ∧ pi2 ∧ . . . pim i , where each pij is a predicate.
We restrict our predicates to be equalities (e.g., a = 5), inequalities (e.g., a = 5) or ranges (a ∈ [5,10]).
If Q ≡ c1, i.e., if Q contains a single conjunctive clause, then Q is a conjunctive query (CQ).
A DNF selection condition is therefore equivalent to a union of conjunctive queries (UCQ).
For each family of queries that we consider, we are interested in obtaining Q such that: (1) Q(R) is as close to V as possible (i.e., as accurate as possible): Intuitively, Q(R) should miss out on few tuples from V , and should include few tuples not in V .
(2) Q is as succinct as possible.
Next we introduce a difference measure to quantify the closeness between V and Q(R) (Section 2.1) and a metric of succinctness for queries (Section 2.2).
Then, we formally define the specific problems addressed in this paper (Section 2.3), and the families of queries we consider (Section 2.4).
Finally, in Section 2.5, we present a summary of our results.
We use the following running example throughout the paper.Example 2.1.
Consider a relation Rmov giving information about movies, shown in Table 1.
Also consider a relation Vmov in Table 2, obtained from Rmov through manual selection of tuples.
Henceforth, we use R and V to abbreviate Rmov and Vmov respectively.
Given relations R, V , and a query Q, we say that Q(R) is close to V if Q(R) has few incorrect or missing tuples.
The difference between two relations of the same schema (in this case Q(R) and V ) is captured by their symmetric set difference:Definition 2.2 (Difference).
Given two relations R1 and R2, we say that the difference between R1 and R2 is given by d(R1, R2) = |R1 − R2| + |R2 − R1|.
Note that the definition above can also be interpreted as the total number of tuples that need to be deleted or added to convert relation R1 into relation R2 (or vice versa).
The smaller the difference d(Q(R), V ), the closer Q(R) is to V .
There are situations when we may have an additional constraint that one of either |V − Q(R)| or |Q(R) − V | should be 0, i.e., we require Q(R) to be either a superset or a subset of V .
For instance, suppose the result of finding a view definition is given to a human for manual pruning.
In such a case it may be critical to capture all result tuples in V , but extra tuples in Q(R) can be removed manually.
We consider difference metrics incorporating these additional constraints in Section 6.
We first introduce the notion of size, for conjunctive queries and unions of conjunctive queries, and then define succinctness in terms of size.
We measure the size of a conjunctive query (CQ) as its number of predicates.
We measure the size of a union of conjunctive queries (UCQ) as its number of unions.
For UCQs, an alternative metric would include both number of unions and number of predicates in each clause.
We studied this alternative metric as well for each of the problems we discuss in this paper, and the algorithms and complexity are similar.
Additionally, if the average size of each conjunctive clause is similar, the number of unions is a good measure of the complexity of the queries.
We mention differences whenever appropriate, but primarily use the metric based on number of unions.
Thus we have: Definition 2.3 (Size).
The size of a conjunctive query Q, size(Q), is the number of predicates in Q.
The size of a union of conjunctive queries Q, size(Q), is the number of unions appearing in Q.Given two queries from the same family Q and Q , we say that Q is more succinct than Q if Q has a smaller size.Definition 2.4 (Relative-Succinctness).
Given two queries Q and Q from a family Q of queries, we say that Q Q , i.e., Q is at least as succinct as Q , if size(Q)≤size(Q ).
We say that Q is more succinct than Q if Q Q but not Q Q. Next we enumerate the problems we study in the rest of the paper.
The first problem considers whether given R and V , there is an exact view definition in a certain query family.
Definition 2.6 (Exact View Def.
(EVD)).
Given relation R, view V , and a query family Q, return a Q ∈ Q such that V = Q(R), if such a Q exists.There may be several queries Q such that V = Q(R), as we've seen in Example 2.5.
Our next problem addresses the case when EVD doesn't have a unique solution, or when it has no solution at all.
When EVD has multiple solutions, we want the most succinct one.
When there is no exact view definition at all, as a first priority we want the closest query, and as a second priority we want the most succinct one.
Definition 2.7 (Best View Def.
(BVD)).
Given relation R, view V , and a family of queries Q, find and return any Q ∈ Q such that:(1) there is noQ ∈ Q with d(V, Q (R)) < d(V, Q(R)) (2) ∀ Q ∈ Q with d(V, Q (R)) = d(V, Q(R)), Q Q .
In some cases, minimizing the difference may be less critical than obtaining a succinct view definition.
For instance, an approximate view definition that gets close to V may suffice, but we would like the most succinct view definition that achieves the required approximation.
The next problem finds the most succinct view definition that satisfies a minimum level of approximation specified by a threshold on the difference metric.Definition 2.8 (Approximate View Def.
(AVD)).
Given relation R, view V , approximation threshold τ , and a family of queries Q, check if ∃Q ∈ Q such that:(1) d(V, Q(R)) ≤ τ (2) if for any Q ∈ Q, d(V, Q (R)) ≤ τ , then Q Q .
and return any such Q if one exists.For all three problems, we use the difference metric from Definition 2.2.
Also recall from Section 2.1 the alternative difference metrics that require either |V − Q(R)| = 0 or |Q(R) − V | = 0, i.e., seeking view definitions that result in supersets or subsets of V respectively.
In Section 6 we consider two variants of BVD: (1) BVD-Sup, equivalent to BVD but restricted to view definitions Q satisfying Q(R) ⊇ V ; (2) BVD-Sub, equivalent to BVD but restricted to view definitions Q satisfying Q(R) ⊆ V .
Definition 2.9 (Approximation Ratio).
Given relation R, view V , a family of queries Q (and τ in the case of AVD), we say that a solution Q ∈ Q gives an α-approximation to BVD (AVD resp.)
if Q satisfies (1) Condition-1 of Definition 2.7 (Definition 2.8 resp.)
; and (2) Condition-2 of Definition 2.7 (Definition 2.8 resp.)
by replacing "Q Q " with "size(Q)≤ α.size(Q )".
We consider the following families of queries:• CQ 1 = :A conjunctive query with a single equality predicate A = a.• CQ 1 : A conjunctive query with a single range predicate, i.e., A = a or A = a or A ∈ [a1, a2].
• CQ = : A conjunctive query with any number of equality predicates, but at most one predicate per attribute.
• CQ: A conjunctive query with any number of range predicates, but at most one predicate per attribute.
• UCQ = : Unions of CQ = queries.
• UCQ: Unions of CQ queries.
• UCQ k = : Union of at most k CQ = queries (k ≥ 1).
• UCQ k : Union of at most k CQ queries (k ≥ 1).
Consider the EVD, BVD, and AVD problems for a relation R with M attributes and N tuples.
Table 3 summarizes the results we have obtained for all the problems specified in Section 2.3, showing worst-case complexity and approximation ratios.
(Some results from Table 3 are relatively straightforward, but still included in the paper for completeness.)
For UCQ k = and UCQ k , since the size of the query is fixed (to k unions), we use an approximation metric different from Definition 2.9, requiring different techniques and analysis (discussed in Section 5).
Note that for some of the problems listed here, we analyze data complexity, i.e., the complexity on keeping schema size fixed and varying the size of the data (the number of tuples in R) as well as combined complexity, i.e., the complexity when neither schema size nor data size is fixed.
We analyze these two cases separately because the data complexity may be different from the combined complexity for some problems, e.g., BVD for CQ, where the data complexity is PTIME(N ), while the combined complexity is NPComplete (denoted as NP-Complete(N, M )).
Similar notions were first introduced in [17].
Family EVD BVD AVD BVD-Sup BVD-Sub CQ 1 = O(M N ) O(M N ) O(M N ) O(M N ) O(M N ) CQ 1 O(M N 2 ) O(M N 2 ) O(M N 2 ) O(M N ) O(M N 2 ) CQ = O(M N ) O(M N M +1 ) O(M N M +1 ) O(M N.2 M ) O(M.N M +1 ) NP-Hard(N,M ) NP-complete(N,M ) O(M N 2 ) log N -approx O(M N τ +2 ) log N -approx CQ O(M N ) O(M N 2M +1 ) O(M N 2M +1 ) O(M N.2 M ) O(M.N 2M +1 ) NP-Hard(N,M ) NP-complete(N,M ) NP-Hard(N,M ) NP-Hard(N,M ) O(M N 3 ) log N -approx O(M N τ +3 ) log N -approx U CQ = O(M N ) NP-complete(N,M ) NP-complete(N,M ) N/A N/A P T IM E(N M ) log N -approx.
U CQ O(M N ) NP-complete(N,M ) NP-complete(N,M ) N/A N/A P T IM E(N 2M ) log N -approx.
U CQ k = O(M N M k+2 ) O(M N M k+2 ) N/A O(M N M k+2 ) O(M N M k+2 ) NP-complete(N,M,k) NP-complete(N,M,k) NP-complete(N,M,k) NP-complete(N,M,k) PTIME 2k-approx U CQ k O(M N 2M k+2 ) O(M N 2M k+2 ) N/A O(M N 2M k+2 ) O(M N 2M k+2 ) NP-complete(N,M,k) NP-complete(N,M,k) NP-complete(N,M,k) NP-complete(N,M,k) PTIME 2k-approxNote that we don't separately consider the BVD-Sup and BVD-Sub problems for UCQ = and UCQ (marked N/A in Table 3), as there is always a solution to EVD, and hence BVD's solution directly applies to BVD-Sup and BVD-Sub.
Also note that the NP-Completeness results for UCQ k = and UCQ k for EVD, BVD and BVD-Sup/Sub only hold if we allow the parameter k and the schema size M to vary along with N , the data size.
If not, the problems are solvable in PTIME in N .
Further, we don't consider AVD for UCQ k = and U CQ k since the size of all these queries is fixed (k clauses), therefore, the solution to AVD is no different from the solution to BVD.
The approximation result for AVD for CQ and CQ = only holds for the special case when the view definition is required to give a superset of V , i.e., the analog of BVD-Sup for AVD.In the remainder of the paper, we present details for all the results from Table 3, organized as follows.
Section 3.1 considers the families of queries CQ 1 = and CQ 1 .
Section 3.2 considers the families CQ = and CQ.
Section 4 considers the families U CQ = and UCQ.
Section 5 considers the families UCQ k = and U CQ k .
The BVD-Sup and BVD-Sub problems are studied in Section 6.
We first consider the families of conjunctive queries with single predicates, i.e., CQ 1 = and CQ 1 (Section 3.1).
We then consider the families CQ = and CQ of conjunctive queries with multiple predicates (Section 3.2).
Since the results for single-predicate queries are simple in comparison to the other families of queries, we only state our main results, in the next two theorems.
Details are presented in Appendix A.Theorem 3.1.
Given a relation instance R with M attributes and N tuples, and a view instance V , each of EVD, BVD, and AVD can be solved in O(M N ) for CQ 1 = .
Theorem 3.2.
Given a relation instance R with M attributes and N tuples, and a view instance V , each of EVD, BVD, and AVD can be solved in O(M N 2 ) for CQ 1 .
Intuitively, for each of these problems, d(V, Q(R)) for all possible queries Q in the given family of queries needs to be computed.
This computation is significantly aided by hashing, allowing all counts to be obtained in O(M N ).
Next we consider the view definition problems for conjunctive queries, i.e., families CQ and CQ = .
First, we present a connection between our problems and a set cover formulation, which is used in the rest of the section (Section 3.2.1).
We then study EVD (Section 3.2.2), BVD (Section 3.2.3) and AVD (Section 3.2.4) problems respectively.
Given a relation R, and a view V , we create an instance of the set cover problem as follows: Construct the universal set U = R − V .
Consider the set of single-attribute predicates P such that P ∈ P iff P (R) ⊇ V .
For each P ∈ P we define a setSP = U − (P (R) ∩ (R − V )).
Intuitively, our aim is to cover all the elements of U , thereby eliminating all the incorrect tuples.
We perform this cover by selecting a set of predicates T ⊆ P such that ∪P ∈T SP = U .
In other words, a cover of U gives a solution to the EVD for R and V : Since every element of U is covered, the corresponding set of predicates in conjunction does not select any tuple in R−V .
Moreover, each predicate selects all tuples of V .
We first consider EVD for the family of queries CQ = .
We will handle CQ subsequently.
Theorem 3.3.
Given a relation R and a view instance V , Algorithm 2 checks if there exists a solution to EVD for the query family CQ = and finds one if there exists in O(M N ).
The proof of this result may be found in Appendix Sec.B.1.
The result above can be easily extended for CQ with time complexity still O(M N ).
For each attribute, we first pick the smallest superset range in the view as a predicate.
We further check if there is a single value in the range present in the relation but missing in the view.
(If so, we replace the range predicate with one predicate involving = for the missing value.
Note that if there are multiple values missing within the range, then there is no EVD.)
This check can be done in O(N ) per attribute (O(M N ) overall) by using hashing to count the number of distinct values.
We then check if the conjunctive clause thus formed is an EVD.Require: A 1 , A 2 , . . . , An ← attributes of relation and viewRequire: b 1 , b 2 , . . . , bn ← sizes of view attribute domains Require: V ← view instance, R ← relation instance 1: Q ← NULL 2: for i ∈ 1 . . . n do 3: if b i == 1 then 4: v i ← value of A i in view 5: Q ← Q ∧ (A i = v i ) 6: end if 7: end for 8: if |Q(R)| == |V | then 9: return Q 10: else 11: return No EVD 12: end ifAlgorithm 2: Algorithm to solve EVD for CQ=.
We start this section by a straightforward upper bound for BVD.
We then present a lower bound, followed by an approximation algorithm.
Let us consider the BVD problem for input R with N tuples and M attributes, and view V .
To obtain an upper bound for BVD, we simply consider all possible conjunctive queries over R and pick the best possible one.
R has O(N M ) or O(N 2M ) queries depending on whether our family of queries is CQ = or CQ.
In O(M N ) we can compute d(Q(R), V ) for each query.
If we assume the schema size M to be a fixed parameter and vary N , the size of the data, BVD's data complexity is PTIME, established by the following theorem.
(We note that if R and V are cross-products of sets of values for attributes, BVD can be solved in O(M N ).
Details of this special case appear in Appendix B.2.)
Theorem 3.4.
Given a relation R, view instance V , the BVD problem has a data complexity of O(M N M +1 ) and O(M N 2M +1 ) for the family of queries CQ = and CQ respectively.Example 3.5.
For Example 2.1, the BVD query for CQ= is (Director = Q.Tarantino ∧ Box Office = Hit), which has d = 2 due to two missing tuples.
We have seen an upper bound on the complexity of BVD.
Our next result shows an exponential lower bound in terms of combined data and schema complexity of R. Recall that on fixing the number of attributes, the data complexity is polynomial in N .
However, if we allow the number of attributes and the number of tuples in R to both vary, we show intractability.
Our proof uses a relation R where the number of tuples and number of attributes are polynomials of each other.Theorem 3.6.
Given R and V , the BVD problem is NPHard in N and M , for CQ = and CQ.Proof.
We give a reverse construction based on the idea from Section 3.2.1.
That is, for each instance of the set cover problem, we construct an instance of the BVD problem such that the solution of the BVD instance yields a solution to the set cover problem.
Given an instance of the set cover problem consisting of the universal set U = {1, . . . , n}, and subsets S1, . . . , Sm, we construct an input to BVD as follows (Note that the set cover problem is NP-hard even when the number of sets m is restricted to a polynomial of n): R(A1, . . . , Am) contains a tuple ti corresponding to each element i ∈ U .
ti.Aj = 0 if i ∈ Sj.
For every attribute value in R not assigned 0 based on the rule above, a distinct attribute value is assigned.
(Note that there is no tuple marked with 0 in all attribute values, since we can assume without loss of generality that every element i ∈ U appears in some subset Sj.)
Add a special tuple t0 to R where ∀j, t0.Aj = 0.
Let V = {t0}.
Since V has a single tuple with all attribute values being 0, for BVD, we only need to consider queries with predicates of the form Aj = 0.
Every such predicate corresponds to picking a set Sj for the set cover.
Our goal reduces to finding the fewest such predicates such that each of the tuples t1, . . . , tn is not picked by at least one predicate, which is equivalent to finding the smallest cover for U .
The size of our constructed relation R is O(mn), where the set cover problem has n elements and m attributes.
Hence, BVD is NP-hard in combined data and schema size.
Now that we've established a lower bound on the complexity of BVD, we next study PTIME (in schema and data of R) approximation algorithms for solving the problem.
We distinguish two cases: (1) When there is no solution to EVD; (2) When there exists a solution to EVD.For Case (1), we employ the algorithm used for Theorem 3.4, i.e., looking at all possible queries and picking the best one.
Our next result is an efficient approximation algorithm for Case (2).
Given inputs R and V , we reduce BVD to the set cover problem based on the construction in Section 3.2.1.
We then use Set Cover's greedy approximation algorithm [18].
Since the constructed set cover formulation has O(N ) elements, and O(M N ) sets (a predicate corresponding to each value of each attribute) for CQ = and O(M N 2 ) sets for CQ, we have the following result.Theorem 3.7.
Given relations R and V such that EVD has a solution for CQ = (CQ resp.)
, there is an O(M N 2 )-time (O(M N 3 )-time resp.)
log N -factor approximation algorithm for BVD.
We consider the AVD problem for CQ = and CQ.
The worst-case upper bound result of BVD for these families of queries carries over for AVD as well.
First we state the complexity of AVD, in the following theorem, and then present an approximation algorithm.Theorem 3.8.
Given R and V , the AVD problem is NPcomplete in N and M , for CQ = and CQ.Proof.
NP-hardness of AVD follows from the reduction in the proof of Theorem 3.6, which also applies when τ = 0.
AVD is in NP because, given a query Q, in PTIME we can check whether d(V, Q(R)) ≤ τ , and then we check if any more succinct query Q also has d(V, Q (R)) ≤ τ .
Next we present an approximation algorithm for AVD, under the superset special case described in Section 2.
Suppose we are given a threshold τ along with R and V , and we want the most succinct query Q that guarantees d(Q(R), V ) ≤ τ .
We can approximately solve AVD using our set cover construction when we impose the condition that Q(R) ⊇ V , which we call the AVD-Sup problem: Given R and V , we construct an instance of the set cover problem as in Section 3.2.1.
We are then interested in a solution that covers at least δ = (|R − V | − τ ) elements.
Once again, we can use set cover's greedy approximation algorithm.
However, we must solve the set cover for all possible choices of δ elements from the |R − V | elements.
We solve these |R−V | δ ≤ N τ set cover problems and pick the best, i.e., smallest, query among all of them.
Theorem 3.9.
Given relations R and V , and threshold τ , there is an O(M N τ +2 )-time (O(M N τ +3 )-time resp.)
log Nfactor approximation algorithm for the AVD-sup problem for CQ = (CQ resp.)
.
We now study VDP for a union of conjunctive queries, i.e., query families UCQ and UCQ = .
The following straightforward theorem, proved in Appendix C, establishes the result for EVD.Theorem 4.1.
Given R, V , there exists a solution to EVD for U CQ and UCQ = if and only if V ⊆ R.Therefore, EVD can be solved in O(M N ) time.
Note that while the above theorem says that EVD always has a solution for V ⊆ R, the next example shows that the solution may not be unique.
Since there is a query Q such that Q (R) = V , the BVD query Q has to satisfy Q(R) = V as well.
Hence, BVD reduces to finding the most succinct Q such that Q(R) = V .
In this section we focus on the family UCQ = , but the algorithms for U CQ are similar.Require: t 1 , t 2 , . . . , tv ← tuples in the view 1: /* Generate */ 2: S ← ∅, T ← {t 1 , t 2 , . . . , tv}, f ← f alse 3: while f == f alse do 4: S ← S ∪ T (use the Exclusion Criterion) 5: R ← ∅ 6: for i ∈ T do 7:R ← R ∪ (sub-clauses of i on dropping 1 predicate)8: end for 9: discard conjunctive clauses containing incorrect tuples from R (use the Pruning Criterion) 10: T ← R 11: f ← (R == ∅) 12: end while 13: /* Cover */ 14: for all Q such that Q ⊆ S, |Q| = 1.
.
v do 15: if d(Q(R), V ) == 0 then 16: return Q 17: end if 18: end forAlgorithm 3: Algorithm to solve the BVD.
We now prove that finding a BVD is N P -Complete, by using a reduction from the Vertex Cover problem.Theorem 4.3.
Given R, V , finding a solution to BVD is N P -complete in the size of R's schema and data for U CQ = and UCQ.Proof.
We give a reduction from the NP-complete Vertex Cover problem [18]: Given an undirected graph G(V, E), V = {v1, . . . , vm} and E = {e1, . . . , en}, determine the smallest set Vcov ⊆ V such that all edges in E have at least one endpoint in Vcov.
The vertex cover problem is NPcomplete in N , when m and n are poly(N ).
(Specifically, m 2 ≥ 2n ≥ m is sufficient for NP-hardness.)
Given an instance of the vertex cover problem, we construct an instance of BVD as follows: Create a relation R(A1, . . . , Am) consisting of n tuples t1, . . . , tn.
ti.Aj = 0 if and only if vertex vj is an endpoint of edge ei.
All other entries in R are assigned distinct values.
Further, let the view V = R. Now, to construct a solution to BVD, the only useful conjunctive clauses are of the form (Aj = 0), which corresponds to selecting vertex vj in the vertex cover.
Any vertex cover can be represented as a union of conjunctive clauses corresponding to each vertex.
Hence, there exists a vertex cover of size k if and only if there is a UCQ with k conjunctive clauses solving BVD.
It is easy to see that the decision version of the problem is in NP, hence BVD is NP-complete in the size of the data and schema.Note that the same hardness proof above holds even if the metric for succinctness is not the number of unions, but is instead the total number of predicates in the DNF formula.
The proof holds because only conjunctive clauses of size 1 are useful in the above reduction.
As a result, both the metrics are equivalent (i.e., the total number of predicates = total number of clauses).
Although BVD is NP-complete in general, Algorithm 3 describes a two-phase algorithm for an exhaustive search.
Further, we can apply certain criteria to reduce the search space, as described shortly.
1 Our algorithm operates in two 1 The worst-case guarantees don't change.
phases: Generate and Cover.
The Generate phase generates all the potentical candidate conjunctive clauses in a top-down fashion (conjunctive clauses with m predicates, then m − 1 predicates, and so on), starting with the tuples themselves as conjunctive clauses (line 2), and removing one predicate at a time to form smaller conjunctive clauses (line 7).
(T is the set of conjunctive clauses generated in the previous iteration, S contains all the clauses generated so far, and R is the candidate set of clauses to be added in the next iteration.)
These conjunctive clauses should not select any tuples not in the view (i.e., incorrect tuples) -this condition is checked in line 9.
Instead, we could also use the following condition to directly prune good conjunctive clauses from bad ones.
However, for this condition to be applied, we need to incur the cost of maintaining conjunctive clauses containing incorrect elements.
Note that the pruning condition is remniscent of the pruning found in other domains, including finding all functional dependencies [6] and association rule mining [1].
The number of conjunctive clauses generated and added to S is governed by the size of the view, which may be much smaller than the relation.
We could use the following criterion to further reduce the size of S.Lemma 4.5 (Exclusion Criterion).
If a conjunctive clause with s predicates has been selected, then all conjunctive clauses with the same s predicates and r, r ≥ 1 additional predicates can be removed from S.The Cover phase picks k conjunctive clauses (where k goes from 1.
.
n) from the candidate conjunctive clauses such that all tuples in V are covered/selected.
All combinations of k conjunctive clauses from the set of candidate conjunctive clauses are tried for this purpose until one is found with d = 0 (line 15).
The returned query is simply the union of those conjunctive clauses.
Note that if we were to use the metric counting number of predicates in the DNF, then we would need to try all combinations of conjunctive clauses, and return the one with the smallest number of predicates.Note that this phase is expensive computationally (even though we mentioned several methods to reduce the size of the candidate set S), so we describe an approximation algorithm to reduce the complexity in the next section.Also note that the BVD algorithm is remniscent of the Quine-McCluskey procedure for finding minimal DNF for a boolean function [10] (and more generally other boolean formula minimization techniques [4]).
The problem in that case is Σ p 2 -complete [16].
As an aside, note that we can use database properties to simplify the input to BVD, such as using the following rule.
Our paper doesn't delve into exploring more such properties.Lemma 4.6 (Func.
Dependency Pruning).
Given R, V input to BVD/AVD, if R satisfies the FD X → Y , then we can drop attributes Y − X from R and V to get an equivalent formulation of the problem.
We now describe an approximation algorithm for the Cover phase of the BVD algorithm.Theorem 4.7.
Given R with N tuples and M attributes, a view V , there exists a PTIME (in N ) algorithm that finds a log N -approximation to the optimal solution: If the optimal solution has k unions, our algorithm produces at most k log N unions.Proof.
In the following, we give an L-reduction from BVD to the set cover problem.
We can then use the greedy algorithm for set cover that guarantees a log N factor approximation ratio [18].
There are a polynomial (in N ) number of CQ = queries over R: There are at most N possible predicates over each attribute, and hence at most (N + 1) M conjunctive queries.
Create an instance of set cover where the universe U is the set of all tuples in R. Each conjunctive query C forms a subset S ⊆ U containing precisely the tuples selected by C.
The optimal solution to the set cover problem gives the optimal UCQ containing the conjunctive queries selected in the set cover's solution.At each stage the greedy algorithm picks the best conjunctive clause, i.e., one that covers maximum number of tuples from the view.
The algorithm terminates when all the tuples in the view have been selected.Note that for the metric that counts the total number of predicates in the DNF formula, we can describe a similar approximation algorithm using a reduction to the weighted set cover problem [18], where the cost of each set corresponding to a conjunctive clause is the number of predicates present in the conjunctive clause.
In this case at each stage the greedy algorithm picks the conjunctive clause that has the largest ratio of the number of new tuples from the view covered to the cost of the clause.
We first present the complexity of finding an AVD, then explain how we can adapt Algorithm 3 for AVD.
Corollary 4.8.
Finding a solution to AVD for U CQ = and UCQ is N P -complete in the schema size and the data size.The hardness proof is easy to see on setting τ = 0 for the reduction in Theorem 4.3.
Additionally, AVD is in NP because given a solution Q to the AVD which has k unions, we can test all possible UCQs Q of size upto k (a polynomial in n) and check if d(Q(R), V ) < d(Q (R), V ), all in PTIME.
We now describe a modification of Algorithm 3 for AVD.
As before, the algorithm has two phases, Generate and Cover.
In the Generate phase, we can apply a natural generalization of the pruning criterion.
In addition, we can apply the following criteria, which are different from the criteria used for BVD.
Lemma 4.10 (Exclusion Criterion).
If a conjunctive clause Q with s predicates has been selected, then all conjunctive clauses with Q the same s predicates and r, r ≥ 1 additional predicates that have d(Q (R), V ) = d(Q(R), V ) can be removed from S.
In this section we consider the families of queries where the number of unions is bounded by k, i.e., the families UCQ k = and U CQ k .
Section 5.1 considers the case when k is not fixed and Section 5.2 considers the case when k is a fixed parameter.
Recall, since the AVD problem reduces to the BVD problem when the query size is fixed, we do not separately consider the AVD problem.
The following theorem establishes the complexity of solving EVD and BVD when k is a variable parameter.Theorem 5.1.
Given input relation R with N tuples and M attributes, and a view instance V , the EVD and BVD problems are NP-complete in N, M and k for UCQ k = and UCQ k .
Proof.
The problem is clearly in NP: Given a UCQ k = or UCQ k query Q, we can check in PTIME whether Q is a solution to EVD or if there are any queries with a smaller difference.
The hardness result follows from the hardness of BVD for U CQ = and UCQ (Theorem 4.3).
In the proof of Theorem 4.3, we constructed an input instance R and V where checking if there was a BVD UCQ (or UCQ = ) with at most k unions was NP-hard.
This instance can be reduced to checking if there is an EVD for UCQ k or if there is a BVD for U CQ k with difference 0.
If k is fixed, we have the following theorem.Theorem 5.2.
Given a relation R and a view V , the BVD and EVD problem can be solved in O(M N M k+2 ) for UCQ k = and in O(M N 2M k+2 ) for UCQ k .
The theorem follows from the fact that all candidate queries in U CQ k = (in U CQ k resp.)
can be enumerated inN M k ( N 2Mk resp.)
and it takes at most O(M N 2 ) to calculate the difference for each of these queries.Since the approach above is exponential in M and k, we look for an approximate solution that is more tractable for the BVD problem.
There are two main results in this section: a greedy approximation algorithm for BVD (Section 5.2.1), and an inapproximability result on a family of greedy algorithms (Section 5.2.2).
As explained next, our greedy algorithm gives an approximation ratio under a weaker notion than approximating the difference metric.
However, the inapproximability result from Section 5.2.2 shows that no greedy algorithm can achieve a good approximation ratio under the stronger notion.Given input R, V , our result shows that the greedy algorithm gives a query Q algo with a good approximation ratio for one of two metrics: (i) the difference metric between Q algo and V , and (ii) the good-bad metric, i.e., the total number of tuples in V produced by Q algo minus the number of tuples not in V produced by Q algo .
Define:d algo = min{|V |, |V − Q algo (R)| + |Q algo (R) − V |} gb algo = |V | − d algoThe metrics for the optimal solution, dopt and gbopt, are defined similarly.
Intuitively, d measures the difference, while gb measures the total number of "good tuples" (tuples in V ) returned by the query minus the number of "bad tuples" (tuples not in V ) returned by the query.
Let the approximation ratios based on d and gb be r d and r gb respectively.
That is,r d = d algo dopt and r gb = gbopt gb algoIdeally, for any algorithm, we want r d and r gb to be as small as possible, but Section 5.2.2 shows that greedy algorithms cannot guarantee good approximations under any of these metrics independently.
Next, in Section 5.2.1 we consider approximating α = min{r d , r gb }.
Given input R and V , we employ the following greedy algorithm, GreedyKUCQ, to solve BVD for U CQ k = and UCQ k : GreedyKUCQ iteratively picks the best conjunctive query until k conjunctive queries are picked.
At each step, the best conjunctive query is the one that maximizes the gain in the gb metric, i.e., reduces the difference metric by the most.
That is, we pick the conjunctive query that gives the largest number of new good tuples (tuples in V ) minus the number of new bad tuples (tuples not in V ).
The algorithm terminates when k conjunctive clauses have been picked or when there is no query with gain > 0.
When R has N tuples and M attributes, GreedyKUCQ runs in polynomial-time in N and k: There are O(N M ) conjunctive queries in CQ= (O(N 2M ) for CQ resp.)
, and at each iteration it takes time ∼ O(N M ) (O(N 2M ) resp.)
to pick the next best conjunctive clause, and we have at most k iterations.
The following theorem establishes an approximation guarantee for GreedyKUCQ.Theorem 5.3.
Given input R, V , GreedyKUCQ gives a solution to the BVD problem satisfying α = min{r d , r gb } ≤ (2k − 1), for UCQ k = and UCQ k .
Proof.
Suppose Vopt = Qopt(R), where Qopt is the optimal solution to the BVD.
Let y = |V ∩ Vopt|, x = |Vopt − V |, and z = |V − Vopt|.
Therefore, we have:dopt = (x + z)(1)gbopt = (y − x)(2)Since k conjunctive queries put together give y good tuples (i.e., tuples in V , and x bad tuples (i.e., tuples not in V ), there must exist a conjunctive query Q * that gives at least y k good tuples and at most x bad tuples.
We show that our result holds for the query Q * , and since Q algo is at least as good as Q * , our result follows.d * ≤ (z + y − y k ) + x = (z + x + y(1 − 1 k )) (3) gb * ≥ ( y k − x)(4)Using Equations 1 and 3, we have:r d ≤ (z + x + y(1 − 1 k )) x + z(5)Using Equation 2 and 4, we have:r gb ≤ y − x y k − x(6)Suppose for some parameter β:(y − x) y k − x = β(7)Then, we have( y k − x) = y − x β ⇒ y x = k(β − 1) β − k(8)Substituting the above in Equation 5, we get:r d ≤ z+x+x(1− 1 k )( k(β−1) β−k ) z+x = z+x+ x(k−1)(β−1) β−k z+x ≤ (1 + (k − 1)(β − 1) β − k ) (9)Therefore, from Equations 6, 7, and 9, we have:(r gb ≤ β) and (r d ≤ (1 + (k − 1)(β − 1) β − k ))(10)Therefore,α ≤ min{β, (1 + (k − 1)(β − 1) β − k )} (11)The minimum of the two expressions above is always ≤ 2k.
This follows from the fact that the second expression is monotonically decreasing for β ≥ k, and we get β = (2k − 1) by solving the following:β = (1 + (k − 1)(β − 1) β − k ) The following theorem states the straightforward result that GreedyKUCQ gives the optimal solution to BVD for k = 1 for both the d metric as well as the gb metric.Theorem 5.4.
Given inputs R, V , GreedyKUCQ gives the optimal solution to the BVD problem for UCQ 1 = and UCQ 1 , under the difference metric d as well as the "goodbad" metric gb.Our next result, proved in Appendix D, shows that for k > 1, GreedyKUCQ can independently perform poorly for the gb and the d metrics, thus justifying the approximation metric of α for GreedyKUCQ.Theorem 5.5.
GreedyKUCQ can give an arbitrarily bad approximation ratio when the gb and d metrics are considered independently.
• There exists an input R gb and view instance V gb with N tuples, such that for the BVD problem for U CQ k = and UCQ k , for k > 1, using GreedyKUCQ, we have gbopt ∼ N , gb greedy = 0, and therefore get an approximation ratio r gb → ∞.
• There exists an input R d and view instance V d with N tuples, such that for the BVD problem for U CQ k = and UCQ k , for k > 1, using GreedyKUCQ, we get an approximation ratior d = N (1 − 1 k ).
We now prove that we can perform arbitrarily bad if we use any greedy algorithm with a greedy function from a large class of functions.
Consider a family of algorithms GreedyLin with linear greedy functions : f (g, b) = αg −βb, where g is the number of tuples in V returned by a conjunctive query Q, b is the number of tuples not in V returned by Q, and α, β are positive constants.
Also, we assume that at each step the function only evaluates conjunctive clauses based on the "new" tuples, i.e., the ones that have not been selected by the conjunctive clauses picked already.Additionally, the algorithm could stop (before k unions are picked) if the conjunctive clause that is selected by the algorithm has no gain (i.e., number of new good tuplesnumber of new bad tuples < 0), could be constrained to always return k unions or could stop when there are no tuples left in V that have not been covered by the conjunctive clauses picked.
(Our next result applies to all the aforementioned stopping conditions.)
Also, note that GreedyKUCQ ∈ GreedyLin.Theorem 5.6.
Given inputs R with N tuples and M attributes, V , for the BVD problem for UCQ k = and U CQ k , for k > 1, for any GreedyLin algorithm G using a greedy function f (g, b) = αg − βb, (1) There is a case for which r gb → ∞.
α · N − β · α β (N − N k ) > α N k − βIf the GreedyLin algorithm picks no clause, d greedy = N .
If it picks just one clause (from Set I),d greedy = N − (N − α β (N − N k )) = α β N (1− 1 k ).
On picking additional conjunctive clauses, d greedy is strictly greater, since the same good tuples would be covered, but additional bad tuples get covered.
Thus in any case, we have d greedy = O(N ).
However, the optimal algorithm would pick k unions from Set II, givingrise to dopt = N − k N k + 1 = 1.
Thus, r d = O(N ).
Note that these results would also hold for a much more general class of functions.
In particular, any greedy algorithm that uses a function that satisfies f (γ, γ) > f (γ − 1, γ) or f (γ, γ) > f (γ, γ + 1) for any γ = αN < N k would have gbopt = O(N ) and r gb = ∞.
Note that the BVD problem for UCQ k = is reminiscent of the red-blue cover problem [5] and the partial set cover problem [11].
Both these problems define a collection of elements with some positive elements and some negative elements, and a collection of sets each of which cover some positive and some negative elements.
Sets need to be chosen such that the positive elements are covered without too many negative elements.
However, both of these problems do not have a constraint on the number of sets that can be picked, and therefore represent slightly different problems involving different techniques and approximations.
In this section, we consider variants of the BVD problem with certain additional constraints, for the different families of queries.
The first problem we consider is that of the best query that results in a subset of the given view instance.
This case is especially important if we cannot afford to have any extraneous tuples in our query result as compared to the view instance (i.e., no false positives), but we are allowed to miss a few tuples.
Definition 6.1 (best subset view def.
(bvd-sub)).
Given relation R, view V , and a family of queries Q, find Q ∈ Q such that all three of the following hold1.
Q(R) ⊆ V 2.
there is no Q ∈ Q, Q (R) ⊆ V with d(V, Q (R)) < d(V, Q(R)) 3.
for all Q ∈ Q, Q (R) ⊆ V with d(V, Q (R)) = d(V, Q(R)), Q Q .
The second problem we consider is that of the best query that is a superset of the given view instance.
This case is especially important if we cannot afford to have miss any tuples from the view instance (i.e., no false negatives).
Definition 6.2 (best superset view def.
(bvd-sup)).
Given relation R, view V , and a family of queries Q, findQ ∈ Q such that 1.
V ⊆ Q(R) 2.
there is no Q ∈ Q, V ⊆ Q (R) with d(V, Q (R)) < d(V, Q(R)) 3.
for all Q ∈ Q, V ⊆ Q (R) with d(V, Q (R)) = d(V, Q(R)), Q Q .
We state the following theorem without proof:Theorem 6.3.
If a relation instance R and a view instance V have an EVD for a family of queries Q (i.e., ∃Q ∈ Q such that Q(R) = V ), then the solutions of the problems BVD, BVD-Sup and BVD-Sub are the same.Based on the above theorem, we don't need to separately study BVD-Sup and BVD-Sub for UCQ = and U CQ.
Also note that the same approach used for EVD and BVD in Theorem 5.1 may be used for solving BVD-Sup and BVD-Sub for UCQ k and UCQ k = .
Next we describe algorithms to solve the BVD-Sup and BVD-Sup problems for each conjunctive query family.
BVD-Sup Problem: We first consider the BVD-Sup problem.
For conjunctive queries with only equalities, we simply consider the attributes that are constants in the view and form CQs out of them.
We have the following theorem.Theorem 6.4.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sup over queries in CQ 1 = in O(M N ).
Full details of how clauses corresponding to each value of each attribute are evaluated and the proof of the theorem above are in Appendix E.1.
Instead, we give details for queries in CQ 1 , which subsume the results for CQ 1 = .
For CQ 1 = , we consider the smallest superset ranges of attribute values in the view V .
If we were to include ranges, then for any attribute Ai, we could have the conjunctive clause Q = j ≤ Ai ≤ k. However, we restrict j = minA i ∈V {Ai} and k = maxA i ∈V {Ai}, because any range that does not include all of [j, k] would not satisfy the condition of Q(R) ⊆ V , and any range that contains other elements cannot be better because it can only include tuples that are not in V .
Let the proportion of tuples with values in [j, k] for attribute Ai be pi in the relation R. Thus, we would haved(V, Q(R)) = di = pi * |R| − |V |The conjunctive clause that minimizes di above over all 1 ≤ i ≤ n is the BVD-Sup if we include range queries.The procedure above makes one pass of each column to compute the min and the max (O(M N )), plus one pass per attribute to compute pi (O(M N )), thus the complexity of the procedure is O(M N ).
Extending the procedure for = is also O(M N ): For each attribute, count the number of values of the attribute in R that hash to the same location as a value for the same attribute in V .
We can count this number in O(M N ).
The difference between this number and the size of V is the difference when we have an = predicate with that attribute.Theorem 6.5.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sup over queries inCQ 1 in O(M N ).
BVD-Sub Problem: All queries Q in CQ = for which the number of tuples in V that are selected by Q is the same as the number of tuples in R that are selected by Q are potential candidates for the BVD-Sub problem.
We have the following theorem.
Theorem 6.6.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sub over queries in CQ 1 = in O(M N ).
The details of the potential candidate solutions for the BVDSub problem and the proof of the theorem are in Appendix F.For ranges, we have a similar check of cardinalities to shortlist potential queries: Queries corresponding to ranges for any given attribute are considered for which the number of tuples in the relation R with the attribute having a value in that range is the same as the number of tuples in the view V with the attribute having a value in the same range.For ranges, for any attribute Ai, we could have the conjunctive clause Q = j ≤ Ai ≤ k. Let the proportion of tuples with values in [j, k] for all attribute value pairs.
The statistics can be collected in O(M N ) using hashing, and in O(M N 2 ) we can compute d j,k i for all i, j, k and also make sure that the number of tuples in V and R for that attribute value pair is the same.
Thus, we have a complexity of O(M N 2 ).
Note that the complexity of adding = predicates is O(M N ) as well.Theorem 6.7.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sub over queries inCQ 1 = in O(M N 2 ).
Note that we can speed up the procedure by noticing that if the number of tuples in range [j, k] are the same in R and V , then we do not need to consider any sub-range [j +δ1, k−δ2].
Example 6.8.
The BVD-Sup query in CQ 1 = for our movies example is (Box Office = Hit), while the BVD-Sub query is one of many queries, including (Movie = Snatch) or (Director = Guy Ritchie).
Note that the BVD-Sup in this case has d = 3, while the BVD-Sub has d = 3 as well.
The NP-hardness of BVD-Sup and BVD-Sub follows from the result of Theorem 3.6, since our reduction to BVD had an EVD.
Next we consider upper bounds for each of these problems.BVD-Sup: If we assume that size is the same for all conjunctive queries, we can find the BVD-Sup over queries in CQ and CQ = in O(M N ).
We omit the details here -they may be found in Appendix E.2.
Example 6.9.
The BVD-Sup query in CQ = for the Movies example is not the same as the BVD (and therefore has a larger difference from the view V ), but is in fact, the same as the BVD-Sup query in CQ 1 = : (Box Office = Hit).
To find the BVD-Sup for our original definition of size (based on number of attributes in the query), we first construct a conjunctive query formed by selecting all predicates corresponding to attributes that are constants in the view.
We then enumerate all its subsets of predicates, and select the best one.
In practice, we can perform a "smarter" topdown search eliminating predicates from the query one at a time and terminating the search when any subset of attributes is not a solution to BVD-Sup.
The top-down search, however, does not improve the worst-case complexity.
BVD-Sub: For finding the BVD-Sub query in the family CQ = and CQ, we enumerate all candidate queries that are subsets of the view V and pick the one with the smallest difference.
Note also that if we are evaluating queries in a top down fashion, we can use the following lemmas.Lemma 6.11 (Stopping Criterion).
If there is no query Q with k predicates that satisfies Q(R) ⊆ V , then there are no queries Q with < k that satisfies Q(R) ⊆ V .
Lemma 6.12 (Pruning Criterion).
The only queries Q with k predicates that need to be considered are those that are formed from those in k + 1 by eliminating one predicate.
This paper addressed the view definitions problem (VDP), considering succinctness and approximation constraints and a variety of query families.
We identified three subproblems, EVD, BVD and AVD, and studied the complexity of solving each of the three subproblems for each query family.
We provided polynomial-time optimal algorithms for the tractable cases and approximation algorithms for the intractable cases.
Table 3 in Section 2.5 summarizes our findings for all the problems.Some specific open problems remain, such as an approximation algorithm for AVD for unions of conjunctive queries.
More generally, in this paper we considered only views derived by selection predicates over a single relation.
Extending our results to arbitrary select-project-join (or beyond) queries is an important avenue of future work.
Consider the problem of finding a query with a selection condition consisting of a single conjunctive clause containing one predicate, i.e., query families CQ 1 = and CQ 1 .
In this case all queries are of the same size, and therefore are all equally desirable.
Therefore, we try to find the query Q in each of these query families that minimizes d(Q(R), V ).
This query would then be the BVD for this family.
If in fact the BVD query Q is such that d(Q(R), V ) = 0, then Q is also an EVD.
Additionally, if d(Q(R), V ) ≤ τ , then Q is also an AVD -Note that the second condition in the AVD problem definition is trivially true because Q1 Q2 is true for all queries (since all queries are equivalent).
Thus, we now proceed to give algorithms to find the BVD for each subfamily of the family of Single Predicate Conjunctive Queries.We now introduce some notation.
Let the attributes of R be A1, A2, . . . , Am.
Without loss of generality, for any attribute Ai, let the domain Ai be {1, 2, . . . mi}.
We first consider the BVD problem for CQ 1 = .
Let the proportion of tuples with value j for attribute Ai be p j i in the relation R and q j i in the view V .
Then, if we were to pick (Ai = j) as the selection condition for query Q, then d(V, Q(R)) would be:d j i = p j i * |R| − q j i * |V | + (1 − q j i )* |V | We simply pick the attribute Ai and value j that minimizes d j i above.
Let this value d j i be dmin.While collecting statistics for each value in {1, 2, . . . , mi} corresponding to attribute Ai, we scan the ith column of both R and V .
If we assume hashing is an O(1) operation, we get statistics per column in O(N ), where N is the number of tuples.
There are M such columns.
Computing values d j i for all i, j is another O(M N ) operation.
Thus the complexity is O(M N ).
On the other hand, if we do not assume hashing is an O(1) operation, we can sort the column in O (N log N ), giving a complexity of O(M N log N ).
Theorem A.1.
Given a relation instance R and a view instance V , the procedure above finds the EVD/BVD/AVD over queries inCQ 1 = in O(M N ).
This entry is listed in Table 3 We now consider the BVD problem for CQ 1 , by picking the best query from queries of the form Ai op j, for each op in {=, =}.
We then also consider ranges, for predicates of the form Ai ∈ [j, k].
Consider inequality predicates, i.e., for any attribute Ai, we could have the query Q ≡ (Ai = j).
Thus d(V, Q(R)) = d =j i = (1 − p j i ) * |R| − (1 − q j i ) * |V | + (q j i ) * |V | Leti ≤ n, 1 ≤ j ≤ k ≤ mi.
Let this value d j,k i be d [] min .
Statistics for a given range [a, b] can be simply computed using the difference of two sumsb k=1 p k i − a−1 k=1 p k i .
The values j k=1 p k ican be computed for all j in one pass for each i, i.e., after collecting statistics p j i for each column i, we use one additional pass to sum the statistics.
Thus, all the sums for a column can be computed in O(N ), if hashing is O(1).
Thus the necessary statistics (i.e., the sums) are collected in O(M N ).
However, we need to compute d j,k i , for all i, j, k, which takes O(M N 2 ) to obtain d Theorem A.2.
Given a relation instance R and a view instance V , the procedure above finds the EVD/BVD/AVD over queries in CQ 1 in O(M N 2 ) overall.
If CQ 1 does not contain range queries, then the procedure is O(M N ).
This entry is listed in Table 3 in the first 3 columns of the second row.
Proof of Theorem 3.3: Let us assume that an EVD query Q ∈ CQ = exists.
If the cardinality of attribute Ai in the view V is 1 (i.e., Ai = vi for some vi for all tuples in V ), then we can add Ai = vi as a predicate to Q (i.e., Q ← Q ∧ (Ai = vi)), if it is not already present, without changing Q(R).
Also note that if cardinality of Ai in V > 1, then Q cannot have Ai = v for any v, because then Q(R) = V since some tuples in V are not selected by Q. Thus any EVD Q can be converted into one of the form Q = ∧i(Ai = vi) over all Ai that have cardinality 1 in the view.
In Algorithm 2, the constructed query Q is precisely Q above.
Now all that is remaining is to check if Q (R) = V for existence of an EVD, because any other EVD Q, if it exists, can be converted into Q with Q(R) = Q (R).
Checking if each attribute is a constant in the view can be done in O(N ) and for all attributes in O(M N ).
Computing Q(R) is O(M N ).
Thus overall, we have O(M N ) complexity.2 Next we examine the special case when both the relation R and the view V are formed as cross products of sets of attributes.
For example, the relation could be all tuples of the form {1, 2} × {1, 2}, and the view could be the tuples {1, 2} × {1}.
Formally, let A1, A2, . . . , An be the attributes of R.
If Ai takes values from the set Ai, then R = A1 × A2 × . . . × An.
Additionally, we assume that the view is a cross product as well: V = B1 × B2 × . . . × Bn, where Ai in the view takes its values from the set Bi ⊆ Ai.
Additionally, assume that |A1| =|A2| = . . .= |An| = m. Let |Bi| = bi.
WLOG, assume that b1 ≥ b2 ≥ . . . ≥ bn.
We have the following theorem:Theorem B.1.
If R and V are both cross products as described above, and if the size of the sets Ai are all equal to m, then Algorithm 4 returns a solution to the BVD for CQ = in O(M N ).
Proof.
In a conjunctive query Q, for each attribute Ai, there are two possible cases: either the attribute is given a value, or the attribute is not present in the conjunctive clause.
If the attribute is given a value v, we let Ci = {v}, else let Ci = Ai.
Clearly, Q(R) = C1 × C2 × . . . × Cn.For each attribute Ai, consider three numbers fi, gi and hi, where fi = |Bi − Ci|, gi = |Ci − Bi|, and hi = |Bi ∩ Ci|.
The difference d(V, Q(R)) would then be the following:d = extra + missing = (Πi(fi + hi) − Πihi) + (Πi(gi + hi) − Πihi) = c + Πi(gi + hi) − 2Πihiwhere c is a constant independent of the conjunctive clause chosen.We now wish to find the optimal set of gi, hi to minimize the number above.
Clearly, for each attribute i, we either have (1) gi +hi = m, and hi = bi (2) gi +hi = 1, and hi = 1.
If we choose k attributes to give values to in the conjunctive clause, Πi(gi + hi) will be m k , but Πihi will be atmost b1 · b2 · . . . · b k .
Thus our candidates for the best conjunctive clause are precisely those which select a value (1) for An from Bn, or (2) for An from Bn and for An−1 from Bn−1, or (3) . . ., or (n) for An from Bn and for An−1 from Bn−1 and . . . and for A1 from B1.
These are precisely the conjunctive clauses considered in Algorithm 4.
Proof of Theorem 4.1: If V ⊆ R, then there is no query that can select the tuples in V − R, and hence no EVD.
Now, let V ⊆ R. Let tuples t1, t2, . . . , tn be the only tuples in the view, where ti = (ai1, ai2, . . . , aim).
Consider the query corresponding to the selection condition: ∨ n i=1 (A1 = ai1 ∧ . . . ∧ Am = aim).
This query selects only the tuples t1, t2, . . . , tn and none other.2 Proof of Theorem 5.5: (1) Construct an input such that no conjunctive query has gb ≥ 0, therefore GreedyKUCQ doesn't pick any conjunctive query, which is equivalent to the predicate false.
Therefore, gb greedy = 0.
However, suppose there are at least k conjunctive queries Q1, . . . , Q k , each with ( In this section, we describe how to find the BVD-Sup for the family of queries CQ 1 = .
For any attribute Ai that is a constant in the view V , let the domain Ai be {1, 2, . . . mi}.
Let the proportion of tuples with value j for attribute Ai be p j i in the relation R. Let Ai = j for all tuples in the view.
Then, if we were to pick Ai = j as the conjunctive clause Q, then d(V, Q(R)) would be: di = p j i * |R| − |V | We simply pick the conjunctive clause corresponding to attribute Ai that minimizes di above.
Let this value di be dmin.
If there is no such conjunctive clause, we return the conjunctive clause true.
We have the following theorem:Theorem E.1.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sup over queries in CQ 1 = in O(M N ).
Proof.
Since all queries in CQ 1 = have atmost one attribute given one value, we need to consider all single-attribute queries that are supersets of the view V .
If an attribute Ai has more than one value in the view V , then no conjunctive clause of the form Ai = vi would be permissible, because they would not include all the tuples in the view V .
Thus we can only consider queries formed from attributes that are constants in the view V .
Those are precisely the queries considered above.The procedure above makes one pass of each column to check if the attribute values are the same O(M N ), plus one pass per attribute to compute p j i , O(M N ), thus we have a time complexity of O(M N ).
The results in this section assume that the size is the same for all conjunctive queries.We find the solution to the BVD-Sup problem for queries in CQ = by picking all attributes that have a single value in the view V , and taking their conjunction.
That is, if Ai = vi for all tuples in the view V , we add (Ai = vi) as a predicate to the conjunctive query.
We add all such predicates to the BVD-Sup query Q.Theorem E.2.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sup over queries in CQ = in O(M N ).
Proof.
Let the best query be Q.
We can only make Q "better" by adding additional predicates (thereby constraining it further) as long as we maintain V ⊆ Q(R).
Thus, if we add the predicate Ai = vi for all i where Ai has a single value vi for all tuples in the view, then we make Q only better.
Also note that no predicate corresponding to Aj for which there are multiple values in the tuples in the view V can appear in Q, because otherwise V ⊆ Q(R) would be violated (since some tuples would be missed).
Thus the best query will contain Ai = vi for all attributes with a single value in the V , and no predicates corresponding to other attributes, since all attributes are covered, and since a conjunctive clause can have at most one predicate per attribute.The procedure above makes one pass of each column to check if the attribute values are the same, so we have a complexity of O(M N ).
For the BVD-Sup queries in CQ, we form a conjunctive clause with one range corresponding to each attribute, where the range is between the values that are the minimum and maximum values for the given attribute in the view.Theorem E.3.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sup over queries in CQ = in O(M N ).
Proof.
Trivially, the conjunctive clause described above covers all the tuples in the view V .
We need to prove that there is no other query that is smaller that covers all the tuples in the view V .
If in a new "smaller" query if there is an attribute that is assigned a range that excludes some elements from the range [min, max], then it would be missing some tuples from V .
Thus the query selected above is the best possible.The procedure above makes one pass of each column to find the min and the max attribute values for each attribute, so we have a complexity of O(M N ).
We now describe the procedure to solve the BVD-Sub problem for CQ = in detail.
First let us characterize the kind of queries in CQ = that could be potential solutions of the BVD-Sub problem.We can only pick conjunctive clauses of the form Ai = j where the number of tuples in V with value j for attribute Ai is the same as the number of tuples in R with value j for Ai.
For all such conjunctive clauses, we compute the difference d, as follows:For any attribute Ai, let the domain Ai be {1, 2, . . . mi}.
Let the proportion of tuples with value j for attribute Ai be p j i in the relation R and q j i in the view V .
Note that p j i * |R| = q j i * |V |, using our condition above.
Then, if we were to pick Ai = j as the conjunctive clause Q, then d(V, Q(R)) would be: d j i = (1 − q j i ) * |V | We simply pick the conjunctive clause corresponding to the attribute Ai being set the value j that minimizes d j i above.
Let this value d j i be dmin.Theorem F.1.
Given a relation instance R and a view instance V , the procedure above finds the BVD-Sub over queries in CQ 1 = in O(M N ).
Proof.
The only conjunctive clauses that are candidate solutions for the BVD-Sub problem are those for which Q(R) ⊆ V .
Thus the query Q does not contain any tuples not in V .
Such queries (Ai = vi) in CQ 1 = are precisely the ones for which there are no extraneous tuples corresponding to Ai having value vi in the relation but not present in the view V .
Thus the queries should have the same number of tuples in the view V with value j as are present in the relation R.
These are the queries we consider above.The procedure above makes 1 pass of each column to compute q j i for each attribute value, and 1 pass also making sure that the number of tuples in V and R for each attribute value is the same.
All of these statistics can be computed in O(M N ) using hashing.
X
