In this paper, we propose a method of constructing a virtual coordinate system (ABVCap) in wireless sensor networks where location information is not available.
A routing protocol based on ABVCap virtual coordinates is also introduced.
Our routing protocol guarantees packet delivery and does not require computing and storing of the global topological features.
Using simulations, we evaluate the performance of the proposed routing protocol (ABVCap routing), the greedy routing protocol based on VCap virtual coordinates (VCap routing), the greedy routing protocol based on physical coordinates (Euclidean routing), greedy perimeter stateless routing (GPSR routing), and geometric spanner routing (GSR routing).
The simulations show that our method guarantees packet delivery while ensuring moderate routing path length overhead costs.
A wireless sensor network is composed of multiple wireless sensors.
Each sensor is able to collect, process, and store environmental information as well as communicate with others via inter-sensor communication.
The rapid development of wireless communications and embedded micro-sensing technologies facilitate the use of wireless sensor networks in our daily lives; a wide range of applications exist for wireless sensor networks, including environmental monitoring, battlefield surveillance, health care, nuclear, biological, and chemical (NBC) attack detection, intruder detection, etc.
Recently, studies of wireless sensor networks have received considerable attention [1], [2], [3].
Routing is an important issue that affects wireless sensor networks.
In geographic routing [4], [5], [6], [7], [8], [9], the physical location is used as the node address.
The source node determines the destination address by looking it up from the location server [10], or by computing it using a hash function in a data-centric storage scheme [11].
The node usually forwards the packet to a neighbor closer to the destination.
This, however, may bring the packet to a deadend node, a node with no neighbor closer to the destination.
GPSR [4] and GFG [5] routing use the FACE algorithm on a planar graph to deal with the dead-end node problem.
In addition, GSR routing [6] and a combination of the FACE algorithm and the shortcut-based procedure [7] are proposed to improve routing efficiency.
GSR routing builds a planar routing subgraph RDG (Restricted Delaunay Graph) so that there exists a path whose distance, in terms of Euclidean distance or hop distance, in RDG is only the constant times to the minimum distance between any pair of nodes.
In Fang et al. [8] and Kuhn et al. [9], methods for mapping holes and routing around holes are proposed.
Geographic routing protocols require nodes to have geographic information that is obtained with difficulty because GPS devices are expensive and do not work indoors.Routing protocols based on virtual coordinates are proposed in wireless sensor networks without GPS assistance.
Through an iterative procedure, a relaxation algorithm [12] assigns virtual coordinates to nodes that are close to their physical locations, consuming, in the process, a great deal of message broadcast overhead.
This method does not guarantee packet delivery because the FACE algorithm cannot be used to solve the dead-end node problem due to the local error of the virtual coordinate assignment [13].
A survey of methods for assigning virtual coordinates to nodes similar to the real ones can be found in [14].
GLIDER [15] is a landmark-based routing scheme, in which all nodes are divided into cells by the landmark Voronoi complex.
The connections between neighboring cells are represented as combinatorial Delaunay triangulation (CDT) on landmarks.
A packet is routed via the shortest path from the source cell to the destination cell in CDT identified by the source node.
A good set of landmarks greatly impacts the efficiency of GLIDER.
However, no theoretical methods are capable of selecting a good set of landmarks.
MAP [16] uses a medial axis graph (MAG) as the guide for routing without the need for the selection of landmarks.
In GLIDER and MAP, each node is required to memorize a graph having the global topological features, which is demanding in terms of message communication and memory overhead.GREENWIS [17] first establishes a number of meridians, and then assigns each node a 4-tuple virtual coordinate according to the meridians.
In VCap [18], three anchor nodes are first selected.
The shortest hop counts to the three anchors are used as the virtual coordinates of the node.
GREENWIS and VCap rapidly construct the virtual coordinates of the node, and route a packet to the destination without computation and storage of the global topological features.
However, neither protocol guarantees packet delivery.In this paper, we propose a delivery-guaranteed routing protocol that does not require GPS assistance and computation and storage of the global topological features.
The remainder of this paper is organized as follows.
Research related to VCap is presented in Section II.
In Section III, an Axis-Based Virtual Coordinate assignment protocol (ABVCap) is proposed for assigning virtual coordinates to nodes.
In Section IV, the delivery-guaranteed routing protocol based on ABVCap virtual coordinates is introduced.
In Section V, we establish the properties of ABVCap and analyze the message communication, memory, and routing overhead encountered using this protocol.
In Section VI, we compare, by simulations, the performance of ABVCap routing with well-known routing protocols.
Finally, we conclude this paper with a discussion of future research in Section VII.
In VCap, nodes are assumed to be static or quasi-static.
All nodes have the same transmission range.
Each node is assumed to have a unique identifier (ID), which is used to break ties and can be easily removed by allowing each node to choose a random number in a large enough interval.
VCap selects three anchors X, Y , and Z, and assigns each node a 3-tuple virtual coordinate (x, y, z), where x, y, and z coordinates denote the hop distance from anchors X, Y , and Z, respectively.W is the sink node, X is the node that has the maximum hop distance from W , Y is the node that has the maximum hop distance from X, and Z is the node that has the maximum hop distance from W among all nodes whose x and y coordinates each satisfy the relationship, x = y ± 1.
In case of parity, the node that has the maximum ID value is selected.VCap assigns x coordinates to all nodes in two steps.
Firstly, each node is assigned a w coordinate that denotes the hop distance of the node from W by the following method.
Once the network is deployed, W assigns its w coordinate to 0 and generates a W SET message containing a hop counter that is initially set to 1 and advanced in increments by the forwarding nodes.
The other node locally broadcasts the W SET message and assigns its w coordinate to the hop counter contained in the W SET message received.
If a node receives more than one W SET message, the node assigns the w coordinate to the smallest hop counter and locally broadcasts the message containing the smallest hop counter.
Secondly, each node that has the maximum w coordinate, or, in case of parity, the node having the maximum ID value in the 2-hop neighborhood assigns its x coordinate to 0 and generates an X SET message containing its ID, its w coordinate, and a hop counter that is initially set to 1 and advanced in increments by the forwarding nodes.
The node locally broadcasts the X SET message and assigns its x coordinate to the hop counter contained in the X SET message received that was generated by the node having the maximum w coordinate, or, in case of two nodes having the same w coordinate, the node having the larger ID value.
If a node receives more than one X SET message generated by the node having the maximum w coordinate (or the node having the larger ID value in the case of identical w coordinates), the node assigns the x coordinate to the smallest hop counter and locally broadcasts the message containing the smallest hop counter.
The y and z coordinates are assigned in a manner analogous to that for the x coordinate.
ASSIGNMENT PROTOCOL (ABVCAP)Similarly to VCap, each node in ABVCap is assumed to be static or quasi-static, and has a unique ID and the same transmission range.
In ABVCap, each node, u, is assigned at least one 5-tuple virtual coordinate (u.lo, u.la, u.rp, u.up, u.dn) in a four-phase process, where u.lo, u.la, u.rp, u.up, and u.dn denote the longitude, latitude, ripple, up, and down coordinates, respectively.
In the first phase, four anchor nodes X, Y , Z, and Z 񮽙 are selected.
Axes, including a parallel of latitude and a number of meridians, are established in the second phase.
The longitude, latitude, and ripple coordinates of the nodes located on axes (called axis nodes) are also assigned in this phase.
In the third phase, the longitude, latitude, and ripple coordinates of all the other nodes are assigned.
Finally, all nodes are assigned the up and down coordinates in the fourth phase.
In this paper, a node with multiple 5-tuple virtual coordinates is perceived as multiple virtual nodes located in the same location, and each virtual node has exactly one 5-tuple virtual coordinate.
Anchors X, Y , and Z are first selected by the same method used in VCap.
The node that has the maximum hop distance from Z among all nodes whose x and y coordinates each satisfy the relationship x = y ± 1 is selected to be anchor Z 񮽙 .
In case of parity, the node having the maximum ID value is selected.
By the conclusion of this phase, each node has x, y, z, and z 񮽙 coordinates, where the z 񮽙 coordinate denotes the hop distance of the node from anchor Z 񮽙 .
The parallel of latitude consists of the nodes in one of the shortest paths from anchor Y to anchor X.
The i-th meridian consists of the node u in the parallel of latitude whose x coordinate is equal to i, the nodes in one of the shortest paths from node u to anchor Z, and the nodes in one of the shortest paths from node u to anchor Z 񮽙 .
The establishment of axes is implemented as follows.
Anchor Y generates a Parallel SET message, which is forwarded by a node to another node whose x coordinate is smaller by 1 until anchor X is reached.
Each node that receives the Parallel SET message is located in the parallel of latitude.
If the node whose x coordinate is equal to i receives the Parallel SET message, the node generates a Meridian i+ SET message containing its z coordinate, and a Meridian i-SET message containing its z 񮽙 coordinate.
The Meridian i+ SET (or correspondingly the Meridian i-SET) message is forwarded by a node to another node whose z (or z 񮽙 ) coordinate is smaller by 1 until anchor Z (or Z 񮽙 ) is reached.
If more than one node is eligible to be forwarded, the node having the minimum distance to the node that generates the message is selected, where the distance between two nodes u and v is defined as |u.x − v.x| + |u.y − v.y|, where u.x, u.y, v.x, and v.y denote the x coordinate of u, the y coordinate of u, the x coordinate of v, and the y coordinate of v, respectively.
Each node that receives the Meridian i+ SET or the Meridian i-SET message is located in the i-th meridian.
Fig. 1 illustrates a snapshot of the establishment of axes.When a node receives the Parallel SET message, the longitude, latitude, and ripple coordinates are assigned to the x coordinate, 0, and 0, respectively.
If a node receives the Meridian i+ SET message, the longitude coordinate is assigned to i, the latitude coordinate to the z coordinate of the node that generates the Meridian i+ SET message minus its z coordinate, and the ripple coordinate to 0.
If a node receives the Meridian i-SET message, the longitude coordinate is assigned to i, the latitude coordinate to its z 񮽙 coordinate minus the z 񮽙 coordinate of the node that generates the Meridian i-SET message, and the ripple coordinate to 0.
A new phase initiates after all axis nodes have been assigned longitude, latitude, and ripple coordinates.
Every axis node generates a 3COOR SET message containing the corresponding longitude and latitude coordinates and a hop counter initially set to 1 and advanced in increments by the forwarding nodes.
If a non-axis node receives a 3COOR SET message, the node locally broadcasts the message, assigns the longitude and latitude coordinates to the longitude and latitude coordinates of the node that generates the message, and assigns the ripple coordinate to the hop counter.
If more than one 3COOR SET message is received, the non-axis node locally broadcasts the message that contains the smallest hop counter and assigns the longitude, latitude, and ripple coordinates according to the message.
After the longitude, latitude, and ripple coordinates have been designated for all nodes, the next phase involves the assignment of up and down coordinates.
Every virtual node that has one neighbor having longitude coordinate larger (or, correspondingly smaller) by 1 assigns the up (or down) coordinate to 0 and generates an UP SET (or DOWN SET) message containing the longitude coordinate and a hop counter initially set to 1.
If a virtual node that does not generate an UP SET (or, correspondingly a DOWN SET) message receives an UP SET (or DOWN SET) message generated by the virtual node having the same longitude coordinate, the up (or down) coordinate is assigned to the hop counter and the UP SET (or DOWN SET) message is locally broadcast with the hop counter increased incrementally by 1.
If more than one UP SET (or DOWN SET) message generated by the virtual node having the same longitude coordinate is received, the up (or down) coordinate is assigned and the message is locally broadcast with the minimum hop counter.
In addition, if u.lo = Y.lo (or u.lo = 0), the virtual node u assigns the up (or down) coordinate to 0, where Y.lo denotes the longitude coordinate of anchor Y .
A virtual node u knows whether u.lo = Y.lo by the following method.
In the phase in which the axes were established (Section III.
B.), the Meridian i+ SET or Meridian i-SET message is marked if it is generated by anchor Y .
And, in the phase in which the longitude, latitude, and ripple coordinates were assigned (Section III.
C.), the 3COOR SET message is marked if it is generated by the axis node with the same longitude coordinate as anchor Y .
Thus, u.lo = Y.lo if u.lo is assigned due to the receipt of a marked 3COOR SET message.
An example of the assignment of 5-tuple virtual coordinates is presented in Fig. 2.
In the first phase, node 16 is anchor W .
Node 19 is selected to be anchor X since node 19 has the maximum hop distance from node 16, or, in case of parity, it has the maximum ID value.
Nodes 18, 17, 16 are selected as anchors Y , Z, and Z 񮽙 , respectively.
In the second phase, the longitude, latitude, and ripple coordinates are assigned to each axis node.
For example, the longitude, latitude, and ripple coordinates of node 6 are assigned to 2, 0, and 0, respectively, because node 6 receives the Parallel SET message and the x coordinate is equal to 2.
The longitude, latitude, and ripple coordinates of node 3 are assigned to 2, -1, and 0, respectively, because node 3 receives the Meridian 2-SET message generated by node 6 and the z 񮽙 coordinates of nodes 3 and 6 are 1 and 2, respectively.
In the third phase, the longitude, latitude, and ripple coordinates are assigned to all non-axis nodes.
For example, the longitude, latitude, and ripple coordinates of node 15 are assigned to 2, -1, and 1, respectively, because node 15 receives the 3COOR SET message generated by node 3 and the minimum hop count Fig. 2.
Example of ABVCap.
The number inside the circle denotes the node ID.
The 1 st , 2 nd , 3 rd , 4 th , and 5 th entries in the parentheses denote the longitude, latitude, ripple, up, and down coordinates, respectively.
from node 3 is equal to 1.
In the fourth phase, the up and down coordinates are assigned to all nodes.
For example, the up coordinate of node 3 is assigned to 0 because node 3 has a neighbor, node 2, with a longitude coordinate larger by 1.
The up coordinate of node 15 is assigned to 1 because node 15 receives an UP SET message from node 3 whose up coordinate is 0.
In our method, the routed packet contains the longitude and latitude coordinates of the destination and a routing direction bit that is set to 1 if the longitude coordinate of the source (s.lo) is less than the longitude coordinate of the destination (d.lo).
We assume that a node receives all multiple virtual coordinates of all 1-hop neighbors.
We also assume that the virtual coordinate of the destination received by the source is unique [10], [11].
In addition, if the source has multiple virtual coordinates, the one for which the difference between the longitude coordinate and d.lo is least is chosen to be the virtual coordinate.
Once the source has the chosen virtual coordinate, the routing direction bit is set.
Two phases are required for one node, u, to route the packet.
In the first phase, node u chooses a virtual coordinate among multiple virtual coordinates for itself and its neighbors.
In the second phase, node u routes the packet received based on the virtual coordinates chosen.
Once node u receives a packet, the node chooses a virtual coordinate (if it has multiple virtual coordinates) by the following strategies: 1) if s.lo < d.lo, the one for which the difference between the longitude coordinate and d.lo is least among all the virtual coordinates whose longitude coordinates are not larger than d.lo is the chosen virtual coordinate, and 2) if s.lo ≥ d.lo, the one for which the difference between the longitude coordinate and d.lo is least among all the virtual coordinates whose longitude coordinates are not smaller than d.lo is the chosen virtual coordinate.
Repeating this strategy, node u chooses a virtual coordinate for each neighbor that has multiple virtual coordinates.
If node u fails to choose a virtual coordinate for a neighbor using the above strategies, a virtual coordinate is chosen at random for the neighbor.
Any neighbor for which node u fails to choose a virtual coordinate will not be used to forward the packet, as will be discussed later.
In our method, if u.lo 񮽙 = d.lo, node u forwards the packet to the node for which the distance to the destination is least among all longitude candidates (longitude routing); otherwise, if u.la 񮽙 = d.la, node u forwards the packet to the node for which the distance to the destination is least among all latitude candidates (latitude routing); otherwise, proactive routing in the nodes with the same longitude and latitude coordinates as the destination is used.
Here, the distance between two nodes u, v is defined as񮽙 (u.lo − v.lo) 2 + (u.la − v.la) 2 .
A neighbor v of node u is a longitude candidate if it satisfies one of the following conditions: c1)u.lo < v.lo ≤ d.lo, c2)u.lo > v.lo ≥ d.lo, c3)v.lo = u. Consider the packet routed by ABVCap routing from node 15 to node 19 in Fig. 2.
Firstly, node 15 proceeds with longitude routing since the longitude coordinates of nodes 15 and 19 are different.
Nodes 4 and 3 are longitude candidates for node 15 because they each meet Condition c4.
The packet is forwarded to node 4 because node 4 has a smaller distance to node 19 compared to node 3.
Then, node 4 chooses the virtual coordinate (0, −2, 0, 0, 0) for node 5 because the virtual coordinate (0, −2, 0, 0, 0) has a smaller difference, in terms of the longitude coordinate, to the virtual coordinate of node 19 compared to the virtual coordinate (1, −1, 0, 0, 0).
Node 5 having virtual coordinate (0, −2, 0, 0, 0) is a longitude candidate for node 4 because it meets Condition c2.
Thus, the packet is forwarded to node 5.
Node 5 first chooses (0, −2, 0, 0, 0) as its virtual coordinate and proceeds with latitude routing because nodes 5 and 19 have the same longitude coordinates and different latitude coordinates.
Nodes 12 and 13 are latitude candidates for node 5 since they each meet Condition c5.
The packet is forwarded to node 12 because node 12 has a smaller distance to node 19 compared to node 13.
Finally, proactive routing delivers the packet to node 19.
We first examine the message communication, memory, and routing overhead of ABVCap.
Then we show that ABVCap assigns at least one 5-tuple virtual coordinate to each node.
Finally, we show that ABVCap routing guarantees packet delivery.
Selected notations are necessary for the proofs of the following theorems.
Definition 1.
A virtual node is said to be in longitude region M if the virtual node's longitude coordinate is equal to M .
NET (M ) denotes the subnetwork induced by the virtual nodes in longitude region M .
Definition 2.
A virtual node is said to be in cell region (M, N ) if the virtual node's longitude coordinate is equal to M and its latitude coordinate is equal to N .
NET (M, N ) denotes the subnetwork induced by the virtual nodes in cell region (M, N ).
In the phase in which the anchors X, Y , Z, and Z 񮽙 were selected (Section III.
A.), the sink node first broadcasts a W SET message to assign the w coordinate to each node.
Subsequently, every node that has the maximum w coordinate, or, in case of parity, the node having the maximum ID value in the 2-hop neighborhood broadcasts an X SET message to assign the x coordinate to each node.
In [18], a well-known technique on trading time for communication is used so that only one X SET message is required to be broadcast in the network.
The y, z, z' coordinate assignment is analogous to the x coordinate assignment.
Thus, five messages are broadcast in the network in this phase.In the phase in which the axes were established (Section III.
B.), Y is required to send a message to anchor X, and each node in the parallel of latitude is required to send a message to anchors Z and Z 񮽙 .
In the phase in which the longitude, latitude, and ripple coordinates were assigned (Section III.
C.), each node must locally broadcast at least one 3COOR SET message.
Each node locally broadcasts the 3COOR SET message approximately once if the axis nodes broadcast 3COOR SET messages at approximately the same time, and each packet travels at approximately the same speed [16].
In the phase in which the up and down coordinates were assigned (Section III.
D.), each virtual node u must locally broadcast at least one UP SET (DOWN SET) message in its longitude region if the virtual node is not in the longitude region of anchor Y (X).
Each virtual node locally broadcasts the UP SET (DOWN SET) message approximately once if the UP SET (DOWN SET) messages in a longitude region are broadcast at approximately the same time, and each packet travels at approximately the same speed [16].
Let k denote the average number of virtual coordinates per node.
Then, the message overhead of UP SET and DOWN SET messages is approximately 2k messages broadcast in the network in this phase.To sum up, in ABVCap, the total message overhead is approximately 2k + 6 messages broadcast in the network.
Each node stores multiple 5-tuple coordinates and a routing table used for proactive routing.
The routing table in a node consists of n entries, where n denotes the number of nodes in the cell region of the node.
ABVCap routing is stateless, and the routed packet needs to carry only the longitude and latitude coordinates of the destination and a direction bit.
Proof: First note that a unique axis virtual node exists in cell region (M, N ), denoted by CH (M, N ).
It suffices to show there exists a path in NET (M, N ) between u and CH(M, N ) for each virtual node u in cell region (M, N ).
Suppose that u assigns its longitude, latitude, and ripple coordinates when it receives the 3COOR SET message m generated by CH(M, N ).
Let P (P = v 1 , v 2 , ..., v k ) be the path traversed by message m fromv 1 = CH(M, N ) to v k = u.
We show all virtual nodes v 1 , v 2 , ..., v k are in cell region (M, N ).
Suppose a virtual node exists, say v i (1 < i < k), that is not in cell region (M, N ).
This implies that v i receives the 3COOR SET message m 1 generated by CH(M 1 , N 1 ) (M 1 񮽙 = M or N 1 񮽙 = N ) after v i receives the 3COOR SET message m and the hop counter contained in message m 1 is less than the one contained in message m.
In this case, u must update the longitude and latitude coordinates to M 1 and N 1 , respectively, after u receives the 3COOR SET message m 1 .
This implies that u is in cell region (M 1 , N 1 ), constituting a contradiction.
This completes the proof.
Proof: Let u and v be two virtual nodes in longitude region M .
Suppose that u and v are in cell regions (M, N 1 ) and (M, N 2 ), respectively.
By Lemma 1, there is a path in NET (M, N 1 ) between u and CH(M, N 1 ), and there is a path in NET (M, N 2 ) between v and CH(M, N 2 ).
Because there exists a path in NET (M ) between CH(M, N 1 ) and CH(M, N 2 ), there exists a path in NET (M ) between u and v.
This completes the proof.
The packet loss and other realistic failures are not considered here.
The following definition is used in the proof of Theorem 2.
Next, we show that latitude routing can always forward the packet to a virtual node in the cell region of the destination.
Let u be the forwarding virtual node.
Only the case u.la < d.la is considered.
The case u.la > d.la can be proved by a similar argument.
We claim: 3) at least one latitude candidate exists in order for u to forward the packet, and 4) (|d.la − v.la|, v.rp) < (|d.la − u.la|, u.rp) and v.lo = d.lo for all latitude candidates v.
If u.rp = 0, u is in an axis and has a neighboring virtual node u 񮽙 such that u 񮽙 .
lo = u.lo and u 񮽙 .
la = In our simulation, 100 connected networks were generated to produce a given density by randomly deploying sensors in square regions with side length equal to 25.
The network density denotes the average number of neighbors per node.
Network behaviors such as packet loss, packet delay, and so on were not taken into consideration.
The transmission range of nodes is a circle of radius 1.
To evaluate the performance of the routing protocols, we investigated the average routing path length and the average delivery rate of ABVCap routing, VCap routing, and Euclidean routing in the networks with and without obstacles.
The obstacles were circles of radius 2 and were deployed randomly.
Two obstacles could be overlapped.
The local detour rule with c = 1, 2 [18], which is used to improve the delivery rate, was also implemented, where c denoted the maximum number of allowed local detours per packet.
We also compared ABVCap routing with two deliveryguaranteed routing, GPSR routing [4] and GSR routing [6], in terms of average routing path length.
For each network, the simulator randomly selected 500 source-destination pairs.
The empirical data were obtained by averaging the data of 500 source-destination pairs of 100 networks.
In addition, to study the communication and memory overhead, we investigated the average number of virtual coordinates assigned to each node by ABVCap and the average number of routing table entries stored in each node.
The empirical data were obtained by averaging the data of 100 networks.
Fig. 3 illustrates the simulation results concerning the average delivery rate in the networks having density ranging from 10 to 40.
ABVCap routing successfully sets a path for every source-destination pair.
With VCap or Euclidean routing, the higher the network density, the higher the delivery rate.
This is reasonable because there are more dead-end nodes in a lowerdensity network due to the occurrence of more holes.
In a high-density network, the delivery rate approaches 100%.
The delivery rate is approximately 57%-80% with VCap routing and is approximately 65%-77% with Euclidean routing in the networks having density equal to 10.
With VCap or Euclidean routing, the local detour rule has a minor effect on the delivery rate in a high-density network.
In a low-density network with VCap routing, many dead-end nodes are induced because multiple nodes share the same virtual coordinate.
Conversely, VCap routing has fewer deadend nodes induced by holes compared to Euclidean routing because the virtual coordinates assigned by VCap propagate through the available paths and may circumvent the holes.
Because the detour rule causes the packet to detour at the dead-end nodes induced by holes with difficulty, it appears to have a more significant impact on the delivery rate with VCap routing than with Euclidean routing.
Fig. 4 illustrates the simulation results for the average routing path length in the networks having density ranging from 10 to 40.
In our simulation, when a packet is routed to a node in the zone of the destination in VCap routing, the packet is routed to the destination via the shortest path, and when a packet is routed to a node in the cell region of the destination in ABVCap routing, the packet is routed to the destination via the shortest path in the cell region of the destination by proactive routing.
The higher the network density, the shorter the routing path.
Euclidean routing has the shortest routing path because physical coordinates contain more information about the distance between the source and the destination compared to virtual coordinates.
By contrast, ABVCap routing has the longest routing path for two reasons: 1) it selects fewer neighbors of the forwarding node as the candidates of next hop in order to guarantee packet delivery compared to VCap and Euclidean routing, and 2) it has the longest average distance of source-destination pairs because with VCap and Euclidean routing the longer the distance of the source-destination pair, the lower the possibility of setting a path.With VCap or Euclidean routing, the local detour rule has a minor effect on the routing path length in a highdensity network.
In a low-density network, the local detour rule increases the routing path length because the detour rule sets paths for some source-destination pairs separated by long distances, which are unreachable unless the detour rule is used.
Fig .
5 shows the simulation results concerning the average delivery rate in low-density (the network density = 10), moderate-density (the network density = 25), and high-density (the network density = 40) networks having 0-5, 10, 20, and 30 obstacles.
ABVCap routing guarantees packet delivery in all networks.
With VCap or Euclidean routing, the larger the number of obstacles, the lower the delivery rate.
This observation results from the increased number of dead-end nodes in the networks having more obstacles.
As the number of obstacles increases, the delivery rate with Euclidean routing decreases more quickly than that with VCap routing, especially in low-density network.
The delivery rate is approximately 28% and 42% with Euclidean routing and VCap routing, respectively, when there are 30 obstacles in low-density network.
This is because the virtual coordinates assigned by VCap could circumvent obstacles, making VCap routing have less dead-end nodes induced by obstacles compared to Euclidean routing.
Fig. 6 illustrates the simulation results about the average routing path length in low-density, moderate-density, and highdensity networks having 0-5, 10, 20, and 30 obstacles.
In the presence of a source-destination pair, the larger the number of obstacles, the longer the routing path because the longer path is set to bypass obstacles.
However, the larger the number of obstacles, the shorter the routing path using Euclidean routing because more paths are not set for source-destination pairs with long distance as the number of obstacles increases.
Fig. 7 illustrates the simulation results for the average routing path length with ABVCap routing, GPSR routing, and GSR routing.
As can be seen, the lower the network density, the larger the routing path length.
We also note that if no obstacle exists in the network, the difference, in terms of the routing path length, among ABVCap, GPSR, and GSR routing is negligible.
In the network having 30 obstacles, ABVCap routing has a far shorter routing path on average compared to GPSR and GSR routing because GPSR and GSR routing set very long routing paths for some source-destination pairs that have long distance or have many obstacles between because GPSR and GSR routing route the packet in the wrong direction to bypass obstacles.
Fig. 8 illustrates the simulation results for the average number of virtual coordinates assigned to each node by ABVCap in low-density, moderate-density, and high-density networks having 0-5, 10, 20, and 30 obstacles.
The lower the network density and the larger the number of obstacles, the larger the average number of virtual coordinates per node because more axes overlap as the network density decreases and as the number of obstacles increases.
Fig .
9 illustrates the simulation results for the average number of routing table entries in ABVCap in low-density, moderate-density, and high-density networks having 0-5, 10, 20 and 30 obstacles.
The higher the network density, the larger the number of routing table entries because more nodes exist in a cell region in higher-density networks.
In addition, the larger the number of the obstacles, the larger the number of routing table entries because there exist more cell regions having a large number of nodes in the networks having more obstacles.
In this paper, we introduce the Axis-Based Virtual Coordinate assignment protocol to construct a virtual coordinate system and propose a routing protocol based on ABVCap virtual coordinates in wireless sensor networks in which location information is not available.
ABVCap establishes a parallel of latitude and a number of meridians using four anchors and assigns at least one virtual coordinate to each node.
A virtual coordinate contains five entries: longitude, latitude, ripple, up, and down.
The longitude and latitude coordinates denote the location of the node in the network, and the other three coordinates assist the node in routing packets.
ABVCap has no need for computing and storing the global topological features, and thus has few requirements in terms of message communication and memory overhead.
ABVCap routing guarantees packet delivery, in which case the routed packet only needs to carry the longitude and latitude coordinates of the destination and a direction bit that ensures the packet is routed in an increasing or decreasing order of longitude coordinates.We evaluate using simulations the delivery rate and the routing path length of ABVCap routing, VCap routing, and Euclidean routing in low-density (the network density = 10), moderate-density (the network density = 25), and high-density (the network density = 40) networks having 0-5, 10, 20, and 30 obstacles.
The simulations show that in VCap or Euclidean routing, the lower the network density, the lower the delivery rate.
In a network without obstacles, the delivery rate is approximately 65%-99.94% and 57%-99.85% with Euclidean routing and VCap routing, respectively.
In terms of the routing path length, ABVCap routing is larger than VCap routing and Euclidean routing by approximately 27%-41% and 44%-46%, respectively, when no obstacle exists in the network.
The simulations also show that with VCap or Euclidean routing, the larger the number of obstacles, the lower the delivery rate.
The delivery rate is approximately 28% and 42% with Euclidean routing and VCap routing, respectively, when there are 30 obstacles in low-density network.
In addition, we also compare ABVCap routing with two delivery-guaranteed routing, GPSR routing [4] and GSR routing [6], in terms of routing path length.
GPSR and GSR routing require that each node has geographic information.
The simulations show that if there are obstacles in the network, ABVCap routing has a much shorter routing path compared to GPSR and GSR routing.Future research includes the study of extending our method to the wireless sensor network in a three-dimensional space.
Another research direction is to study how to guarantee packet delivery in a component of the network that becomes disconnected due to switch-off or mobility of sensors.
