Software transactional memory (STM) is a promising approach for programming concurrent applications; STM guarantees that a transaction, consisting of a sequence of operations on the memory, appears to execute atomically.
In practice, however, it is important to be able to run transactions together with nontransactional legacy code accessing the same memory locations, by supporting privatization of shared data.
Privatization should be provided without sacrificing the parallelism offered by today's multicore systems and multiprocessors.
This paper proves an inherent cost for supporting privatization, which is linear in the number of privatized items.
Specifically, we show that a transaction privatizing k items must have a data set of size at least k, in an STM with invisible reads, which is oblivious to different non-conflicting executions and guarantees progress in such executions.
When reads are visible, it is shown that r memory locations must be accessed by a privatizing transaction, where r is the minimum between k, the number of privatized items, and the number of concurrent transactions guaranteed to make progress.
This captures, in a concrete and quantitative manner, the tradeoff between the cost of privatization and the level of parallelism offered by the STM.
Software transactional memory (STM) is an attractive paradigm for programming parallel applications for multicore systems.
Inspired by classical database transactions [36], general-purpose STM aims to simplify the design of parallel systems, as well as improve their performance with respect to sequential code by exploiting the scalability opportunities offered by multicore systems.
An STM supports transactions, each encapsulating a sequence of operations on a set of data items and guarantees that if any operation takes place, they all do, and that if they do, they appear to do so atomically, as one indivisible computation.In practice, some operations cannot, or simply are preferred not to be executed within the context of a transaction.
For example, an application may be required to invoke irrevocable operations, e.g., I/O operations, or use library functions that cannot be instrumented to execute within a transaction.Strong atomicity [22], [25], [31] guarantees isolation and consistent ordering of transactions in the presence of non-transactional memory accesses.
Supporting strong atomicity is crucial both for interoperability with legacy code and in order to improve performance.
A simple solution is to make each nontransactional operation a (degenerate) transaction, but this means that nontransactional operations incur the overhead associated with a transaction.
Although compiler optimizations can reduce this cost in some situations [3], [30], they do not alleviate it completely.
Thus, STMs aim to support uninstrumented nontransactional operations [15], [33], which are executed as is, typically as a single access to the shared memory.
Many recent STMs [8], [9], [11], [14], [23], [24], [26], [27], [34] provide strong atomicity by supporting privatization [31], [33], thereby allowing to "isolate" some items and make them private to a single process; the process can thereafter access them nontransactionally by simple memory accesses, without interference by other processes.Ideally, privatizing a set of items would simply involve disabling all shared references to the items [9], [23], [34], e.g., by nullifying these references.
Consider, for example, the linked-list of Figure 1, in which every node points to the root item to a disjoint subgraph, such as a tree, and is the only path to items in the subgraph.
A process privatizes all root items and their subgraphs, so it can afterwards access all items in the rooted trees with simple (uninstrumented) reads and writes to the shared memory, avoiding the overhead of transactions and thereby dramatically increasing the efficiency.What happens, however, when another transaction reads all the nodes of the linked list but writes only to one root item that is pointed from the list?
It has been suggested that it suffices for the privatizing transaction to conflict with the other transaction accessing the privatized region; for example, the privatizing transaction writes to the head of the linked list, and any updating transaction reads the head.This paper shows, under assumptions that hold for many STMs, that a constant amount of work, e.g., nullifying the head of the linked list, does not suffice for privatizing the whole linked list.
For many important workloads, including the linked-list example, the hope to combine efficient privatizing transactions with uninstrumented nontransactional reads, cannot be realized unless transactional reads are visible or the STM is overly sequential.
Specifically, the privatizing transaction must incur an inherent cost, linear in the number of data items that are privatized and later accessed with uninstrumented reads.
This holds even if the read set of writing transactions is arbitrary large.
1 Our lower bounds do not hold for overly sequential STMs, which achieve efficient privatization by using a single global lock and allowing only one transaction to make progress at each time [8], [27], thereby significantly reducing the throughput.
Our progress assumption (Property 1, defined in Section 2), requires the STM to allow concurrent progress of nonconflicting transactions: a transaction can abort or block only due to a conflicting pending transaction.
This condition holds for weakly progressive [17] and obstruction-free [18] STMs.Our lower bounds only assume that after a transaction privatizes a data item, no other transaction can write to it (Property 4 in Section 2.2).
This property is common to all interpretations of privatization, e.g., it follows from strong atomicity, implying that our lower bounds hold for all of them.A key factor in many efficient STMs is not having to track the data sets of other transactions, especially if they are not conflicting.
We capture this feature by assuming that the STM is oblivious, namely, a transaction does not distinguish between nonconflicting transactions (Property 2, defined in Section 2).
A simple example is provided by STMs using a global clock or counter [10], [28], [29], or a decentralized clock [5]: The clock or the counter increases whenever a transaction T writes to some data item; however, another transaction T cannot tell whether T wrote to item x or item y, unless T has an operation on either x or y.
A less-obvious example is the behavior of TLRW [11] for so-called slotted threads (see 1.
It can be easily shown that if the read set of every writing transaction is empty, then the privatizing transaction must have operations on all the items it privatizes.
Otherwise, a transaction writing to this item executed after the privatizing transaction completes, is unaware of the privatization and may access private locations.
(This relies on a weak progress assumption.)
Section 2.1).
Several other STMs [8], [9], [14], [26], [34] are also oblivious.
(See detailed discussion in Section 6.)
Our first main result (Theorem 2 in Section 3) further assumes that reads do not write to the memory (invisible reads) and shows that a transaction privatizing k items must have a data set of size Ω(k).
In an oblivious STM with invisible reads, transactions are unaware of, and hence, unaffected by, trivial read-read conflicts.
In the linked-list example, this means that, for every process, the execution of other transactions appears only to write to a single item (either the head of the list or an item pointed by the links).
Our second main result (Theorem 4 in Section 4) removes the assumption of invisible reads.
It shows an Ω(r) lower bound on the number of shared memory accesses performed by a privatizing transaction, where r is the minimum between k, the number of privatized items, and the level of parallelism, i.e., the number of transactions guaranteed to make progress concurrently.
This lower bound captures the tradeoff between the cost of privatization and the parallelism offered by the STM-it explains why the quiescence mechanism [9], [26], [33], for example, compromises parallelism in order to support efficient privatization.We sketch VisibleRingSTM, demonstrating how the cost of privatization can be reduced by limiting the parallelism offered by the STM.
This shows that our lower bound on the tradeoff between the cost of privatization and the level of parallelism is tight (Section 4.3).
Our results are aligned with observations that privatization leads to an unavoidable overhead for STMs [37], and that efficient support for uninstrumented nontransactional operations comes at the cost of reduced parallelism [7].
Section 5 explains how obliviousness generalizes disjoint-access parallelism [21], and derives the lower bounds also for disjoint-access parallel STMs.The rest of the paper is organized as follows: we start in Section 2, with basic definitions and description of various STM properties needed for our results; we show that eager STMs, in which a transaction may update the memory before it is guaranteed to commit cannot support privatization (Theorem 1 in Section 2.2).
Section 3 includes the lower bound on the size of the data set of privatizing transactions in STMs with invisible reads.
In Section 4, we bound the cost of privatization with visible reads, and outline an STM that matches the lower bound.
Section 5 presents the results for disjoint-access parallel STMs.
In Section 6, we review in detail related work, and in particular, the cost incurred by STMs supporting privatization.
Section 7 conclude with a discussion of the results and directions for further work.
A transaction is a sequence of operations executed by a single process on a set of data items shared with other transactions; each item is initialized to some initial value.An operation is a triple: an item, an indication whether the operation is a read or a write, and the value written or read by the operation.
In addition, there are three special operations: start, commit and abort.
A transaction begins with the start operation, followed by a sequence of read and write operations.
If the last operation of a transaction is commit or abort, then the transaction is complete, and said to be committed or aborted, respectively; otherwise, the transaction is pending.The collection of data items in the operations of a transaction is the transaction's data set; in particular, the items written by the transaction are its write set, and the items read by the transaction are its read set.
A writing transaction is a transaction with a nonempty write set.Two operations conflict if they are on the same data item; the conflict is trivial if both are read operations, and nontrivial otherwise.
Two transactions conflict if they include conflicting operations; the conflict is trivial or nontrivial, depending on the type of conflict between the operations.A software implementation of transactional memory (STM) provides data representation for transactions and data items using base objects, and algorithms, specified as primitive operations (abbreviated primitives) on the base objects, which asynchronous processes have to follow in order to execute the operations of transactions.
In addition to ordinary read and write primitives, we allow arbitrary read-modify-write primitives, like CAS and kCAS.
A primitive is nontrivial if it may change the value of the object, e.g., a write or CAS; otherwise, it is trivial, e.g., a read.
An access to base object o is the application of a primitive to o.An event is a computation step by a process consisting of local computation and the application of a primitive to one or more base objects, followed by a change to the process's state, according to the results of the primitive.A configuration is a complete description of the system at some point in time, i.e., the state of each process and the state of each base object.
In the unique initial configuration, every process is in its initial state and every base object contains its initial value.An execution interval α is a finite or infinite alternating sequence C 0 , φ 0 , C 1 , φ 1 , C 2 , . . ., where C k is a configuration, φ k is an event and the application of φ k to C k results in C k+1 , for every k = 0, 1, . . ..
An execution is an execution interval in which C 0 is the initial configuration.A solo execution of process p is an execution interval in which all steps are taken by process p.
A transaction eventually executes solo if a suffix of the transaction is a solo execution.Two executions α 1 and α 2 are indistinguishable to a process p, if p goes through the same sequence of state changes in α 1 and in α 2 ; in particular, p goes through the same sequence of events.
A transaction T is logically committed in a configuration C if T does not abort in any infinite extension from C.Our progress condition requires a transaction to commit if it has no nontrivial conflict with a pending transaction; that is, a transaction can abort or block (take an infinite number of steps without completing) only due to a nontrivial conflict with another transaction.
The next property captures the degree of parallelism provided by an STM, in the absence of nontrivial conflicts.Property 1 (l-progressive STM): An STM is l-progressive, l ≥ 0, if a transaction T that eventually executes solo, after an execution α containing ≤ l pending transactions, commits unless it has nontrivial conflict with a pending logically-committed transaction.Note that a transaction that must commit according to this definition becomes logically committed at some point, e.g., right before it commits.Property 1 (for any l ≥ 1) is satisfied by weakly progressive STMs [17], in which a transaction must commit if it does not encounter nontrivial conflicts, and by obstruction-free STMs [18], in which a transaction commits when it runs by itself for long enough, implying that it must commit if it runs solo after an execution without nontrivial conflicts.To increase efficiency, it is desirable that transactions do not observe operations of other transactions without nontrivial conflicts, whether or not these operations leave a mark on the memory.
This is captured by the notion of obliviousness, which implies that a solo execution of one transaction can be replaced with a solo execution of another transaction, but other transactions without nontrivial conflicts cannot observe this change.The formal definition (Property 2) generalizes this concept to a sequence of solo executions of several transactions.
An independent execution contains transactions on data sets without nontrivial conflicts, each executed by a different process, running solo until it is logically committed.
Intuitively, an STM is oblivious if a transaction running solo after an independent execution of transactions, without nontrivial conflicts with the pending transactions, behaves in a manner that is independent of the data sets of the pending transactions.Property 2 (Oblivious STM): Let α 1 and α 2 be a pair of independent executions with the same number of writing transactions.
Let p be a process that has no steps in α 1 and α 2 , and let T be a transaction by p, without nontrivial conflicts with neither the transactions in α 1 nor the transactions in α 2 .
An STM is oblivious if α 1 T and α 2 T are indistinguishable to p.An STM has invisible reads, if an execution of any transaction is indistinguishable from the execution of a transaction writing the same values to the same items without any read operations.
More formally:Property 3 (STM with invisible reads): Consider an execution α that includes a transaction T of process p with write set W and read set R, and consider a transaction T of process p writing the same values to W in the same order as in T, but with an empty read set.
An STM has invisible reads if there is an execution α that includes T instead of T, such that α is indistinguishable to all other processes from α.Example 1: We demonstrate the definitions by considering TLRW [11].
This is a lock-based STM, in which each item has an associated lock, containing a byte for each slotted reader, and a reader-count that is modified by other, unslotted readers.
Slotted readers only write to their slot when reading, so they are unaware of other reads, making TLRW oblivious when restricted to slotted readers.
On the other hand, unslotted threads read and write to the reader-count, and their execution is affected by other reads to the same item (trivial, readread conflict), making TLRW non-oblivious when taking into account non-slotted readers.To acquire a lock for writing, thread i sets the owner field of the item's lock from ⊥ to i, and then spins until all readers have completed, i.e., all the bytes (slots) and the reader count are 0.
To acquire a lock for reading, a slotted thread stores 1 in its slot, and verifies that the owner field is ⊥.
If the owner field is non-⊥, the reader stores 0 into its slot, and repeats until no owner is detected.
Unslotted readers follow a similar procedure, but instead of setting a slot they increment and decrement the reader count.
Clearly, TLRW has visible reads.A transaction aborts only due to a timeout by the thread, while it is trying to acquire a lock; therefore, there is a nontrivial conflict implying that TLRW is nprogressive.
However, since a transaction acquires locks as the items are accessed, committing only involves writing the new values to the items, before releasing the locks.Finally, note that a transaction is logically committed after it has acquired the last lock, since it will not abort later; nevertheless, the transaction is not committed yet, and still has to apply its writes.
Instead of attempting to formally define privatization, we only state a property that is naturally expected out of any notion of privatization.We assume a process p j can execute a transaction T that privatizes a set of items {t 1 , . . . , t k }.
After the privatizing transaction commits, we assume that p j owns t 1 , . . . , t k , and say that either process p j or transaction T privatizes them; intuitively, this means that no other process can write to them.
Let m j i be the private base object that process p j associates with a data item t i , after privatizing it; the formal requirement is:Property 4 (Privatization-safe STM): An STM is privatization safe if after process p j privatizes item t i , no process p h 񮽙 = p j applies a nontrivial primitive to the base object m j i .
Assume that outside a transaction, read operations to a privatized data item are uninstrumented, namely, they are simply a primitive read of the private base object associated with the data item.We assume a weak safety property that only requires a nontransactional read of a data item, without a preceding nontransactional write, to return the value written by an earlier committed transaction, or the initial value, if no such transaction commits.
No additional consistency property is used in our proofs.We now consider whether a privatization-safe STM can be eager, that is, have transactions that apply a nontrivial primitive (e.g., a write) to a base object associated with a privatized item, before it is logically committed.
For the purpose of this paper, we say that an STM is eager if there is a configuration C such that in C, a transaction T executed by process p is not logically committed, and p applies a nontrivial primitive to a base object associated with an item that another process privatizes.The following simple theorem shows that a 1-progressive eager STM is not privatization safe.
This is claimed to be a known flaw in eager STMs that are not strongly atomic [13], but was never proved formally, and Proposition 1 highlights the assumptions needed for proving it.
Note that assuming uninstrumented nontransactional reads implies that the mapping of each privatized item to the corresponding base object is independent of the execution, and is known in advance.Proposition 1: An uninstrumented 1-progressive eager STM is not privatization safe.
Proof: Let m 0 i be the private base object which process p 0 associates with an item t i .
Assume another process p 1 executing a transaction T 1 applies a nontrivial primitive to m 0 i in some configuration C, where only T 1 is pending and before it is logically committed; call this event τ .
Consider a transaction T 0 of p 0 privatizing the item t i , executed from C.Since only T 1 is pending in C, α, the execution leading to C, has no pending logically committed transaction that has a nontrivial conflict with T 0 .
Since the STM is 1-progressive, T 0 completes successfully when executed after α, and since the STM is uninstrumented, m 0 i is private to p 0 after αT 0 .
However, τ can be applied to m 0 i , even after T 0 , in contradiction to privatization safety.Below, we assume that the implementations are uninstrumented and (at least) 1-progressive, therefore, Proposition 1 holds, and a privatization-safe STM is not eager.
We show that when a privatization-safe STM is oblivious and has invisible reads, the data set of a privatizing transaction must contain all privatized items.
The proof proceeds by creating a scenario in which a privatizing transaction misses the up-to-date value of a privatized item; some care is needed in order to argue about each item separately.Theorem 2: For any privatization-safe STM that is 1-progressive, oblivious and with invisible reads, there is a workload including a transaction T 0 , privatizing k items, in which transactions have nonempty read sets, for which there is an execution where the size of the data set of T 0 is Ω(k).
p 1 executing T 1 I 1 p 0 executing T 0 (a) The execution α : T 1 writes to u. p 1 executing T 1 I 1 p 0 executing T 0 (b) The execution α :T 1 writes to u, with empty read set.p 1 executing T 1 I 1 p 0 executing T 0 (c)The execution α: T 1 writes to t i .
p 1 executing T 1 I 1 p 0 executing T 0 (d) The execution α:T 1 writes to t i , with empty read set.p 1 executing T 1 I 1 p 0 executing T 0 J 1 p 1 completing T 1 (e)The execution α extended with the suffix of T 1 .
Proof: Consider a workload in which process p 0 executes a transaction T 0 that privatizes the items t 1 , . . . t k , while process p 1 executes a transaction T 1 writing u, an unrelated data item, 2 and reading an arbitrary set.Consider the execution α = I 1 T 0 , such that in I 1 , p 1 executes a prefix of the transaction T 1 until it is logically committed (Figure 2(a)), and then p 0 executes T 0 .
Assume by way of contradiction that the data set of T 0 in α does not include some privatized item t i .
Since reads are invisible, α is indistinguishable to p 0 from an executionα = I 1 T 0 , in which p 1 executes a prefix I 1 of a transaction T 1with an empty read set that writes to u the same value as T 1 , until T 1 is logically committed (Figure 2(b)), followed by T 0 .
After I 1 , there is no pending transaction that has a nontrivial conflict with T 0 , and since the STM is 1-progressive, T 0 commits when executed in α (Figure 2(b)); by indistinguishability, T 0 also commits when executed in α (Figure 2(a)).
Consider now the execution α = I 1 T 0 , such that in I 1 , p 1 executes a prefix of a transaction T 1 writing to the item t i a value different than its initial value, and T 1 is logically committed after I 1 (see Figure 2(c)).
Since reads are invisible, α is indistinguishable to p 0 from an execution α = I 1 T 0 , in which p 1 executes a prefix I 1 of a transaction T 1 with an empty read set writing to t i the same value as T 1 until T 1 is logically committed (see Figure 2(d)), followed by T 0 .
The item t i is not in the data set of T 0 when executed in α or α.
This is clear when the data set of T 0 is static; the dynamic case is handled in [20].
Since the STM is oblivious, T 0 commits when executed after I 1 in α (Figure 2(d)), as it does after I 1 in α (Figure 2(b)).
By indistinguishability, T 0 also commits 2.
This can be done since STM is targeted towards generic, arbitrary concurrent applications and not only for custom-tailored concurrent data structures.
In particular, STM should allow to compose transactions on more than a single data structure into an atomic computation; e.g., when removing a node from one linked list and reinserting it into another linked list.
Therefore, it is reasonable to assume that data items are not all contained in a single data structure and that additional transactions and data items can always be introduced.
when executed after I 1 (Figure 2(c)).
Let m 0 1 , . . . , m 0 k be the base objects that are private to p 0 after α.
Since the STM is 1-progressive, T 1 commits when completed after α.
Consider the execution I 1 T 0 J 1 , such that J 1 is the suffix of the execution of T 1 until it commits (Figure 2(e)).
Claim 3:p 1 modifies m 0 i in J 1 .
Proof: Since the STM is not eager, p 1 does not modify m 0 i in I 1 .
Process p 0 does not modify m 0 i in α .
Otherwise, a nontransactional, uninstrumented read of t i of p 0 after α returns a value that is not the initial value of m 0 i , whereas no committed transaction writes to t i in α , contradicting our weak safety property.The executions α and α are indistinguishable to p 0 , since the STM is oblivious and since u or t i are not in the data set of T 0 .
Therefore, the executions α and α are indistinguishable to p 0 and hence, p 0 does not modify m 0 i also in α.It remains to show that p 1 modifies m 0 i in J 1 .
Otherwise, a nontransactional read of t i by p 0 after I 1 T 0 J 1 returns the initial value of m 0 i , since nontransactional reads are uninstrumented.
This contradicts privatization safety, since T 1 , which writes to t i a value that is different from the initial value of m 0 i , commits before the nontransactional read of p 0 .
Therefore, p 1 applies a nontrivial primitive to m 0 i in J 1 after the execution of T 0 , in contradiction to privatization safety, which proves the lemma.We emphasize that in this theorem, the read sets of T 1 and T 1 are not empty, and thus, p 1 reads from the memory and may observe values written by p 0 .
However, because the STM has invisible reads, this looks to p 0 as if T 1 and T 1 have empty read sets, which suffices for the proof.
A corresponding lower bound can be shown for STMs with visible reads, assuming they ensure some degree of parallelism.
The cost is stated in terms of low-level primitives by the privatizing transaction, rather than in terms of size of the privatizing transaction's data set.
The result holds for any workload satisfying the condition specified in the theorem.Theorem 4: For any privatization-safe STM that is lprogressive and oblivious, and every workload including a transaction T 0 privatizing items t 1 , . . . t k and k updating transactions T 1 , . . . T k , such that transaction T i writes to t i and does not read from any item t j , j 񮽙 = i (it may read any other item), there is an execution in which T 0 accesses r = min{l, k} base objects.While there are some similarities between the proof of this theorem and the proof of Theorem 2, the details are more involved, in order to accommodate visible reads.
Therefore, before presenting the formal proof, we describe a high-level outline for a workload similar to the linked list of Figure 1, and then show how this counterexample plays out for TLRW [11].
Consider the scenario described on the left side of Figure 3: R 0 , R 1 , . . . , R k are linked-list nodes (R 0 is the head node); each node R i , 1 ≤ i ≤ k, points to an item t i .
We have k updating transactions traversing the nodes of a linked list (R 0 , R 1 , . . . , R k ), while each transaction writes to a different item pointed by the list (i.e., the i-th transaction writes to t i ); each transaction writes to an item that is not read by other transactions, so these transactions do not have nontrivial conflicts.
Later, a transaction by another process, privatizing all items pointed by the linked list (t 1 , . . . t k ), is shown to miss the up-to-date value of the privatized items, unless it accesses many base objects.Since reads are visible, however, it is difficult to hide the updating transactions from the privatizing transaction.
The challenge is to create an execution in which an updating transaction runs long enough to guarantee that it will commit-even after the privatizing transaction commits, and even if the privatizing transaction writes to an item it reads-but not long enough to become visible to the privatizing transaction.The privatizing transaction may write to an item in the read set of an updating transaction (e.g., the head of the list), thus invalidating its read set.
Hence, to guarantee that an updating transaction eventually commits in the execution constructed, the updating transaction runs until it is logically committed, before the privatizing transaction even starts.It may seem that, at this point, the privatizing transaction does not need to have operations on many objects to observe a nontrivial conflict with the updating transactions, and it can abort or at least block until the situation is resolved.
However, the obliviousness and non-eagerness of the STM can be used to "hide" the updating transactions from the privatizing transaction.To employ obliviousness, we create a copy of the linked list, having exactly the same structure, which is not connected to the first list in any way.
3 It contains k + 1 nodes R 0 , R 1 , . . . , R k and k items t 1 , . . . , t k .
The privatizing transaction does not have operations on this list at all; however, shadow transactions, without nontrivial conflicts, have operations on this completely disjoint linked list.
Due to obliviousness, these transactions are indistinguishable from-and therefore can be swapped with-the original updating transactions.We start with an execution in which the shadow transactions run one after the other.
Then, we swap shadow transactions with updating transactions.
Swapping is done inductively: Each iteration of our inductive construction swaps one shadow transaction with an updating transaction by the same process; that is, at each inductive iteration, one additional process executes an updating transaction instead of a shadow transaction, and causes an access to at least one additional base object by the privatizing transaction.
This eventually yields an execution in which the privatizing transaction accesses many base objects, implying the lower bound.A key technical challenge in the proof is in deciding which transaction to swap next, so as not to lose the events by the privatizing transaction that appear in the execution we have created so far.
Specifically, we need to pick a shadow transaction T such that swapping T with the corresponding updating transaction T is invisible to the privatizing transaction in its execution prefix, at least during the events incurred due to previous iterations of the construction.
This is done by choosing T to be the last transaction to modify the next location seen by the privatizing transaction, so that future swaps will not overwrite locations T writes to and that are read by the privatizing transaction in its execution prefix.
(This is the purpose of Item 6 maintained by the inductive construction in the proof.)
Progressiveness is used to ensure that if at some point the privatizing transaction observes a nontrivial conflict, the updating transaction causing the conflict may run to completion.
The progressiveness level should be high enough to enforce each updating transaction to complete, leading to a lower bound that is the minimum between the progressiveness and the number of privatized items.
Progressiveness also ensures that the privatizing transaction runs to completion.Consider this workload under TLRW, which is oblivious, as explained in Example 1 We consider a TLRW implementation with n = k + 1 slotted threads, to be consistent with the prior discussion; in this example, one thread executes a privatizing transaction by setting the value of R 0 to null, and k threads execute transactions that write to a single item either in the left linked list or the right one.In the initial execution E 0 , all updating transactions write to items in the shadow copy of the linked list (right).
Each transaction, at its turn, traverses the shadow 7 -- copy, reading the items in the path leading to the item on which the transaction acquires a write lock.
More specifically, T i acquires the read lock on the root R 0 by storing 1 in the i-th slot of this item, similarly T i acquires read locks on the items in the path to t i , and finally, T i sets the owner field of t i from ⊥ to i, thus acquiring the write lock on it.
At this point T i is logically committed, as it acquired all its locks, and since in TLRW transactions abort only due to time outs while attempting to acquire a lock.
Note that T i has not completed yet, as it still needs to update the new value of t i .
The suffix of E 0 is an execution of the privatizing transaction, writing null to R 0 .
T 0 sets the owner field of R 0 from ⊥ to 0, then it spins until all the slots are 0.
Since they are all zero, T 0 writes null to R 0 releases the lock and completes.t k -R 1 R 2 R k R 0 t 1 t 2 - - t k -R 1 R 2 R k R 0 t 1 t 2Next, we show what would happen if T 0 were not to read all k slots of the updating threads.
For simplicity, assume that T 0 accesses slots in increasing order.Let p l be the thread with minimal identifier amongst the threads whose slots are not read by T 0 in E 0 .
We perturb E 0 to E l 0 so that, instead of executing T l in its turn, p l executes the transaction T l that traverses the left linked list and updates t l , until p l acquires the write lock on t l and T l is logically committed.
This "swap" of T l with T l is possible since the updating threads are oblivious to each other, and do not change their execution regardless of which linked list the other threads are updating.
Note that in E l 0 T l sets p l 's slot in R 0 to 1, so it is logically committed, but it has not completed yet, as it still needs to set a new value to t l .
At this point, it should be clear why T 0 must read p l 's slot in R 0 in E l 0 and abort after spinning is timed out.
Otherwise, T 0 commits also in E l 0 , privatizing all items in the linked list, including t l .
T l , however, is still pending and will change t l 's value when it is permitted to resume its execution, thus violating privatization safety.
To allow T 0 to commit (so we can continue with the proof) we further perturb E l 0 to E 1 , such that during the execution of T 0 , and immediately before T 0 accesses p l 's slot in R 0 , T l is permitted to be executed to completion, including setting p l 's slot in R 0 to 0.
We repeat this construction, selecting a thread from the threads whose slots are not read by T 0 in E 1 .
The assumption that T 0 accesses the slots in increasing order, and choosing the thread with minimal identifier, guarantee that the prefix of the execution of T 0 in E 1 (until it accesses p l 's slot in R 0 ) does not change during the following perturbations.
In general, the prefix of T 0 that is constructed at a given iteration does not change in any of the following perturbations.In this way, we show an execution in which T 0 must access all k slots of the updating transactions in R 0 , otherwise privatization safety is violated.
We now present the formal proof.Consider r + 1 processes p 0 , . . . , p r , such that p 0 executes T 0 , and p i executes T i for every i, 1 ≤ i ≤ r. and T 0 do not have nontrivial conflicts, for every i.A process p reads from a process q via a base object o in an execution α if p accesses on o, and o was last modified by q. Process p reads from a set of processes P in an execution α if for every process q ∈ P , there is a base object o such that p reads from q via o in α.Consider the following execution α 0 β 0 γ 0 : α 0 is I 1 . . . I r , such that in I i , p i executes a prefix of the transaction T i and T i is logically committed after I i ; β 0 is the empty execution interval; and γ 0 is a solo execution of T 0 by p 0 to completion (see Figure 4(a)).
For every , 0 < ≤ r, we show how to perturb α −1 β −1 γ −1 to obtain an execution α β γ , such that 1) α is a r-independent execution.2) p 0 executes T 0 to successful completion in β γ .3) p 0 reads from all processes in P , a subset of {p 1 , . . . , p r } of size (at least) , in α β .
4) There is a subset Q of P , where every process p j ∈ Q executes I j , a prefix of the transaction T j , in α , such that T j is logically committed after I j , and p j completes T j in β .
5) Every process p j , {p 1 , . . . , p r } \ Q , executes I j in α .
6) For every process p j from which p 0 does not read in α β γ , α j is a r-independent execution, in which p j executes I j instead of I j , and all other processesp 1 executing T 1 I 1 I i p 0 executing T 0 p i executing T i I r p r executing T r α 0 γ 0 (a) The execution α 0 β 0 γ 0 : α 0 is I 1 . . . Ir ; β 0 is the empty execution interval; and γ 0 is a solo execution of T 0 .
p 1 executing T 1 I 1 I i p 0 executing T 0 p i executing T i I r p r executing T r p i completing T i p 0 completing T 0 α 1 β 1 γ 1 (b)The execution α 1 β 1 γ 1 : p i executes I i instead of I i in α 1 ; in β 1 , p 0 starts executing T 0 and p i completes T i ; p 0 completes T 0 in γ 1 .
take the same steps as in α ; in α j , p j does not modify any base object o, such that in α β , p 0 reads o from a process p h , h < j, and in α j β , p 0 does not read from p j .
For = r, we get an execution α β γ , such that p 0 reads from r different processes in P r (Condition 3), and hence, accesses r different base objects, implying the theorem.The proof is by induction on .
We first show that all conditions hold for = 0: 1) α 0 is a r-independent execution, by construction.2) Since all the transactions in α 0 do not have nontrivial conflicts with T 0 , and since the STM is rprogressive (r ≤ l), T 0 completes successfully in γ 0 .
3) β 0 is an empty execution interval and p 0 does not take any step in α 0 β 0 .
Hence, p 0 does not read from any process in α 0 β 0 and P 0 is empty.
4) Q 0 is empty, and the condition vacuously holds.
5) Every process p j ∈ {p 1 , . . . , p r } \ Q 0 = {p 1 , . . . , p r } executes T j ; there are no nontrivial conflicts in this workload and since the STM is r-progressive, α 0 = I 1 . . . I r , such that p i executes in I i , a prefix of the transaction T i and T i is logically committed after I i , is an execution interval.
6) For every process p j from which p 0 does not read, α j 0 is a r-independent execution, as all the transactions do not have nontrivial conflicts, and since the STM is oblivious, α j 0 is an execution interval.
Furthermore, β 0 is empty, thus, for every j, p j does not modify in α j 0 any base object o that is accessed by p 0 in β 0 , and in α j 0 β 0 p 0 does not read from p j since β 0 is empty.
For the induction step, assume an execution α −1 β −1 γ −1 satisfies the above conditions.
Consider the subset V −1 of {p 1 , . . . , p r } \ P −1 from which p 0 does not read in α −1 β −1 γ −1 .
If V −1 is empty then p 0 reads from all the processes and the theorem holds.
Otherwise, we pick a process from V −1 and swap its shadow transaction with its updating transaction, in order to construct the next step.
For example, for = 1, Figure 4(b) shows what happens if p i is chosen from V 0 , and its transaction is swapped to construct α 1 β 1 γ 1 .
Some care is needed when choosing the next process whose transaction is swapped, so as not to lose previous accesses by p 0 (accumulated in Condition 3); this is done by considering each process p j still executing a shadow transaction, and choosing the first one that p 0 reads from.In more detail, for any process p j ∈ V −1 , consider the execution α j −1 , in which p j executes I j instead of I j , and other processes take the same steps as in α .
The execution α j −1 is r-independent, by construction and since the transactions do not have nontrivial conflicts.
Since the STM is r-progressive, I j (the prefix until T j is logically committed) is a finite execution interval in α j −1 .
Since the STM is oblivious, α j −1 is an execution that is indistinguishable from α −1 to every process in {p 1 , . . . , p r } \ {p j }.
Furthermore, by the inductive assumption (Condition 6), p j does not modify in α j −1 any base object o, if in α −1 β −1 , p 0 reads o from a process p h , h < j, and p 0 does not read from p j .
Thus, p 0 reads the same values as in the execution of β −1 , and the execution α j −1 β −1 is indistinguishable to p 0 from α −1 β −1 .
Consider the execution α j −1 β −1 γ j −1 , where p 0 runs solo in γ j −1 .
Assume by way of contradiction that p 0 does not read from p j also in α j −1 β −1 γ j −1 , then p 0 takes the same steps in γ j −1 and γ −1 and T 0 is committed in α j −1 β −1 γ j −1 .
Let m 1 , . . . , m r be base objects corresponding to the items t 1 , . . . , t r that are private to p 0 after α j −1 β −1 γ j −1 (we omit the superscript 0).
The pending transactions in the execution α j −1 β −1 γ j −1 do not have nontrivial conflicts.
Since the STM is r-progressive and T j is logically committed after I j , T j commits (writing to t j ) when executed solo after α j −1 β −1 γ j −1 .
Consider the execution α j −1 β −1 γ j −1 J j , such that J j is the execution of T j until it commits (see Figure 2(e)).
In a manner similar to Claim 3, we show that p j must modify m j in J j .
Claim 5: p j modifies m j in J j .
Proof: Since the STM is not eager, p j does not apply nontrivial primitive to m j in α j −1 or in α −1 .
If p 0 modifies m j in α −1 β −1 γ −1 , then a nontransactional read of t j of p 0 after α −1 β −1 γ −1 returns a value that is not the initial value of m j , whereas no committed transaction writes to t j in α −1 β −1 γ −1 , contradicting privatization safety.Process p 0 does not read from p j also in α j −1 β −1 γ j −1 , and it has the same steps in β −1 γ j −1 as in β −1 γ −1 .
Thus, p 0 does not modify m j also in α j −1 β −1 γ j −1 .
It remains to show that p j modifies m j in J j .
Otherwise, a nontransactional read of t j by p 0 after α j −1 β −1 γ j −1 J j returns the initial value of m j , since reads are uninstrumented.
This contradicts privatization safety since T j , which writes to t j a value that is different from the initial value of m j , commits before the nontransactional read by p 0 .
Therefore, p j applies a nontrivial primitive to m j in some step in J j , after the execution of T 0 , in contradiction to privatization safety.
Thus, p 0 must read from p j in α j −1 β −1 γ j −1 .
Let s j be the number of steps until p 0 reads from p j for the first time in γ j −1 .
Let j = j such that s j is the smallest, i.e., p 0 reads from p j the earliest; if s j = s h , i.e., p 0 reads from p j and p h after the same number of steps, then assume that j > h, i.e., p j appears after p h in the execution interval α .
Let the execution interval α be α j −1 .
The execution interval β is β −1 extended with the first s j − 1 steps of p 0 in γ j −1 , then a solo execution of p j completing T j , and finally, the s j -th step of p 0 from γ j −1 , which reads from p j .
Since T j is logically committed in α , and the STM is r-progressive, T j commits in β .
The execution interval γ is the solo execution of p 0 completing T 0 .
It remains to verify that the conditions hold for α β γ .1) α is a r-independent execution, by construction.
2) T 0 completes successfully since there is no pending transaction with a nontrivial conflict after α β , and the STM is r-progressive.
3) By the inductive assumption (Condition 3), p 0 reads from at least − 1 processes, P −1 , in α −1 β −1 , not including p j that was chosen in the last iteration.
The executions α −1 and α are indistinguishable to every processes p h , if h < j .
Furthermore, since the STM is oblivious, α −1 and α are indistinguishable to every process p h , if h > j .
Hence, p 0 reads from at least the same − 1 processes in α β −1 .
In addition, p 0 reads from p j in α β .
Thus, P ⊇ P −1 .
∪ {p j }, and |P | ≥ |P −1 | + 1 ≥ .
4) By the inductive assumption (Condition 4), Q −1 is a subset of P −1 , such that every process p h ∈ Q −1 executes I h in α −1 , and completes T h in β −1 .
Only p j is in Q \ Q −1 , and it executes I j in α and completes T j in β .
Since α −1 and α are indistinguishable to all processes in {p 1 , . . . , p r } \ {p j }, and only p j switched from I j in α −1 to I j in α , every process p h ∈ Q \ {p j } executes I h in α and completes T h in β −1 , which is a prefix of β .
5) By the induction assumption (Condition 5), every process p h ∈ {p 1 , . . . , p r }\Q −1 executes I h in α −1 .
Hence, every process p h ∈ {p 1 , . . . , p r }\Q executes I h in α , since only p j / ∈ {p 1 , . . . , p r } \ Q switched from I j in α −1 to I j in α .
6) Assume, by way of contradiction, that for some j, p j modifies in α j the base object o, which in α β p 0 reads from p h , h < j, in step σ.
Consider iteration h in which the transaction executed by p h is switched from the shadow transaction T h to the updating transaction T h .
Since the STM is oblivious, the executions α h and α are indistinguishable to p j .
Therefore, p j modifies the base object o also in α j h , and in α j h β h , p 0 reads from p j no later than step σ.
But this is a contradiction, since the rule for choosing the transaction to switch dictates that p j should have been chosen instead of p h , because in iteration h , s j ≤ s h and j > h.
This also implies that in α j β , p 0 reads the same values in the same base objects from the same processes as in α β , and in particular, p 0 does not read from p j in α j β .
The previous lower bound, stated as the minimum between the number of privatized items and the level of parallelism, points out a way to reduce the cost of privatization, namely, to limit the parallelism offered by the STM.
We next show how this tradeoff is indeed tight, by sketching a "counter-example" STM, a variant of RingSTM [34] called VisibleRingSTM, which reduces the cost of privatization by limiting parallelism.
RingSTM is oblivious and privatization safe, but not progressive; privatizing k items requires O(c) steps, where c is the number of concurrent transactions.
RingSTM represents transactions' read and write sets as Bloom filters [6].
Transactions commit by enqueuing a Bloom filter onto a global ring; the Bloom filter representing the read set of a transaction is used only locally by the transaction.
On validation, a transaction T checks for intersections between the read set of T and the write sets of other logically committed transactions in the ring, and aborts in case of a nontrivial conflict.
In the commit phase, T ensures that a write-after-write ordering is preserved.
This is done by checking for intersections between the write set of T and the write sets of other logically committed transactions in the ring.
In RingSTM, a transaction blocks until all concurrent logically committed transactions are completed, therefore RingSTM is not l-progressive, for any l ≥ 1.
In VisibleRingSTM, we make the read set Bloom filter also visible to other transactions, just like the write set filter.
In the commit phase, T ensures that a write-afterread ordering is preserved, in addition to the write-afterwrite ordering, as in RingSTM.
This is done by checking for intersections between the write set of T and the (visible) read sets of other logically committed transactions in the ring.
In addition, it checks for intersections with the write sets of these transactions, like RingSTM.
Intersection between the read set of T and the write set of another transaction is checked by validation.
There is no need to check for intersection between read sets, as these are trivial conflicts that should not interfere.
Finally, waiting for all logically committed transactions to complete (at the end of the commit phase) is removed in VisibleRingSTM, as the write-after-read and write-afterwrite ordering ensure that all the concurrent conflicting transactions have completed.The steps of the commit operation of a transaction T in VisibleRingSTM are:1) Check intersection of the read set filter with the write set filters of concurrent transactions preceding T in the ring (validating the read set), 2) If there is a read-after-write conflict, then abort.
3) Commit T in the ring; if not successful start again from 1 (otherwise, T is logically committed).
4) Check intersection of the write set filter with the write set and read set filters of concurrent transactions preceding T in the ring, 5) Wait until all preceding transactions with writeafter-write and write-after-read conflicts are completed, and then complete T.
In VisibleRingSTM, a transaction aborts only due to read-after-write conflicts with other logically committed transactions, and blocks after it is logically committed only due to write-after-write or write-after-read conflicts with other logically committed transactions.
A privatizing transaction reads the c ring entries of concurrent logically committed transactions, the items in its data set and the global ring index.Using a ring of size c 0 can bound the cost of a privatizing transaction by O(c 0 ), for any c 0 > 1, since it has to read at most c 0 ring entries.
In order to commit, a transaction scans the ring for an empty entry.
When there are at most c 0 concurrent transactions, it finds an empty entry, becomes logically committed, and continues as in VisibleRingSTM.
This variant is (c 0 − 1)-progressive, but a transaction blocks in executions with more than c 0 concurrent transactions (even if they are not conflicting).
Thus, privatization cost is reduced by limiting the progress of concurrent transactions.
Disjoint-access parallelism [21] is a property that captures the intuition that transactions operating on disjoint parts of the data should not interfere with each other [19].
This section discusses the relationship between oblivious and disjoint-access parallel STMs.To define disjoint-access parallelism somewhat more precisely (cf. [4]), we represent (trivial and nontrivial) conflicts between overlapping transactions in some execution interval, with a conflict graph: The vertices represent transactions and there is an edge between two overlapping transactions that have operations on the same item; these could be two read operations.
Two transactions T 1 and T 2 are disjoint access if there is no path between them in the conflict graph of the minimal execution interval containing the intervals of T 1 and T 2 .
We say that two transactions contend if they have pending primitives, at least one of which is nontrivial, on the same base object at some configuration.
An STM is (weakly) disjoint-access parallel if two processes executing transactions T 1 and T 2 contend only if T 1 and T 2 are not disjoint access.We argue that with invisible reads, disjoint-access parallel STMs are oblivious.
Disjoint-access parallelism ensures that transactions that are not connected in the conflict graph do not concurrently contend on a (or even access the same) base object.
Note that obliviousness enforces a certain behavior of a transaction T only after a k-independent execution without nontrivial conflicts with T. To show that disjoint-access parallel STMs with invisible reads are oblivious, we only need to consider these particular executions.Consider a transaction T by process p 0 and two kindependent executions, α 1 and α 2 , in which none of the transactions has a nontrivial conflict with T. Consider a perturbation of the execution α 1 in which all write operations write the same values, however all transactions have empty read sets; call this execution α 1 .
Reads invisibility implies that the execution α 1 T is indistinguishable to p 0 from the execution α 1 T.
The same is true for α 2 T and α 2 T, in which all transactions have empty read sets.
Next, consider the conflict graphs of T in the executions α 1 T and α 2 T.
In both executions, the data set of T does not intersect with any of the data sets of the transactions preceding it, therefore T is isolated in both conflict graphs.
Disjoint-access parallelism implies that in both executions T does not access any base object to which the transactions preceding it has accessed, and therefore the execution interval of T in both executions is the same.
This means that α 1 T and α 2 T are indistinguishable to p 0 , and by the invisibility of reads, α 1 T and α 2 T are indistinguishable to p 0 .
Going back to the definition of obliviousness, and since we considered an arbitrary pair of k-independent executions, this implies the implementation is oblivious.
Hence, Theorem 2 implies:Corollary 6: For any privatization-safe STM that is 1-progressive, disjoint-access parallel and with invisible reads, there are privatization workloads, for which there is an execution where the size of the data set of a transaction privatizing k items is Ω(k).
The specific workloads that incur the cost stated in Corollary 6 are defined in the proof of Theorem 2.
In these workloads transactions have nonempty read sets.Some clock-based STMs [10], [28], [29] are not disjointaccess parallel, but they are oblivious and have invisible reads, so our lower bound holds for them.
This shows the importance of proving the lower bound under the weaker condition of obliviousness, rather than disjointaccess parallelism as in most prior lower bounds.When reads are visible, α 1 T and α 1 T cannot be swapped, and we need a notion of disjoint-access parallelism that takes into account only nontrivial con-flicts.
An edge in a nontrivial conflict graph connects two overlapping transactions only if they have a nontrivial conflict.
An STM is nontrivial disjoint-access parallel if two processes executing transactions T 1 and T 2 contend, only if there is a path between T 1 and T 2 in their nontrivial conflict graph.To show that nontrivial disjoint-access parallel STMs are oblivious we consider again an arbitrary pair of kindependent executions α 1 and α 2 , followed by a nonconflicting transaction T. Instead of swapping α 1 and α 2 with executions with empty read sets, we note that T is isolated in the nontrivial conflict graphs of the executions α 1 T and α 2 T. By nontrivial disjoint-access parallelism, the execution interval of T in both executions is the same, and the implementation is oblivious.
By Theorem 4:Corollary 7: For any privatization-safe STM that is lprogressive and nontrivial disjoint-access parallel there are privatization workloads (defined in Theorem 4) in which update transactions have nonempty read sets, for which there is an execution where a transaction privatizing k items accesses min{l, k} base objects.
Lower bounds, like those proved in this paper, usually rely on certain assumptions, and hence, a common way to circumvent the lower bounds is not to satisfy these assumptions.
This section discusses recent STMs supporting privatization, relating them to our lower bounds and the assumptions they rely on-obliviousness, visibility of reads and progressiveness; this is summarized in Table 1.
Later in this section, we discuss other approaches to combining transactional and nontransactional accesses.As we show in detail below, many STMs supporting privatization are oblivious, due to the cost of tracking the read sets of other, non-conflicting transactions.
As we can see from Table 1, most of these STMs avoid the lower bounds by limiting parallelism, being 0-progressiveness.
An interesting exception is TLRW [11], which is oblivious when restricted to slotted readers (see Example 1).
In accordance with our lower bound, the number of locations read by a privatizing transaction is linear in the number of slotted readers.
Although these locations are packed together, they may generate a lot of cache traffic when updated by many threads, depending on the cache consistency protocol and the workload.Some oblivious STMs have invisible reads [8], [26], [34], making their read set transparent for other transactions; others, e.g., [9], have partially visible reads [24], meaning that other transactions cannot determine which transaction is reading the item; there are also oblivious STMs with visible reads, e.g., [14], however, their execution is unaffected by trivial, read-read conflicts.Many oblivious STMs with visible reads, which support privatization, e.g., [8], [14], [24], [26], [27], [34], are 0-progressive.
Studying these STMs, as we do next, reveals that despite different implementations mechanisms, they all sacrifice parallelism by using global synchronization mechanisms.
These mechanisms force the order by which transactions commit, while preventing other transactions to make progress and commit.JudoSTM [27] transforms code to support transactional execution on-the-fly at run-time.
The coarse-grained commit variant uses single lock; when a transaction commits its changes, no concurrent transaction can commit and complete.
NOrec [8], like JudoSTM, uses a single sequence lock yet it is livelock-free-a transaction aborts only due to a nontrivial conflict with concurrent, logically committed transaction.As described in Section 4.3, RingSTM [34] uses Bloom filters to represent the read and write sets of transactions.
Appending an entry to a global ring effects a logical commit of a writing transaction.
A logically committed transaction may block due to nonconflicting concurrent logically committed (write) transactions.
The default variant of RingSTM is livelock-free, permitting concurrent disjoint transactions to commit their changes in parallel.
The single-writer variant forbids committing the changes of concurrent transactions in parallel, even of disjoint transactions.Menon et al. [26] suggest two STMs that provide privatization safety.
The first uses a global linearization timestamp.
It enforces start and commit linearization, meaning the start, commit, and completion order of transactions are the same.
Alternatively, ordering is imposed only among conflicting transactions, however, the completion order is similar to the commit order in all transactions.
In both cases, this is done by iterating over other processes with concurrent transactions, waiting for their completion.Marathe et al. [24] use a globally synchronized clock and a linked list containing all active transactions to guarantee transaction consistency.
If a transaction identifies a nontrivial conflict with a concurrent transaction it blocks until all active transactions complete.InvalSTM [14] invalidates at commit time: a transaction invalidates all concurrent transactions with which it has nontrivial conflicts.
Like RingSTM, Bloom filters are used to compress the read and write sets of a transaction.
To commit, a transaction acquires global locks preventing o ther transactions from committing or making any progress or new transactions to begin.Other STMs [11], [23] are progressive, but they are not oblivious.
SkySTM [23] is designed to work in hybrid transactional memory systems, combining software and hardware.
It is not oblivious, as it uses a global counter to indicate when a writing transaction, which has a nontrivial conflict with a reader, commits.
It also has partially visible reads.
A transaction blocks only due to conflicting transactions and aborts only due to a nontrivial, read-write conflict with another transaction.
TLRW [11], when considering non-slotted readers, is a lock-based STM, in which a transaction aborts only due to a conflict with another transaction and blocks only while waiting for a lock on an item.All the STMs discussed so far, support implicit privatization [24], meaning that the implementation is re-Oblivious Visible reads Progressiveness Cost JudoSTM: Olszewski et al. [27] yes no 0 O(1) RingSTM: Spear et al. [34] yes no 0 O(1) Menon et al. [26] yes quired to handle all transactions as if they are potentially privatizing items; this incurs excessive overhead for all transactions.
In explicit privatization [32], the application explicitly annotates privatizing transactions, and the STM implementation can be optimized to handle such transactions efficiently; this approach is error-prone and places additional burden on the programmer, which STM tries to avoid in the first place [23].
Some experiments [12], [32], [37] tested techniques for implicit privatization in implementations with invisible reads.
The results show a significant impact on the scalability and performance relative to STMs supporting explicit privatization; in some cases, the performance degrades to be even worse than in sequential code.Guerraoui et al. [15] define parameterized opacity, a framework, extending opacity [16], for modeling the interaction between transactions and nontransactional operations.
The model is parameterized with a memory model, capturing the semantics of nontransactional operations.
Roughly, every transaction appears as if it is executed instantaneously with respect to other transactions and nontransactional operations, and nontransactional operations obey the underlying memory model.
They prove that parameterized opacity cannot be achieved if the memory model restricts the order of read or write operations to different variables.
Furthermore, parameterized opacity requires either instrumenting nontransactional operations or using RMW primitives when writing inside a transaction, if the memory model allows reordering operations to different variables.
They also present an uninstrumented STM that guarantees parameterized opacity with respect to memory models that do not restrict the order of any pair of read or write operations; this STM uses a global lock, and is not weakly progressive.
It can be shown [20] that an oblivious uninstrumented STM, that is 1-progressive, i.e., allows more than one transaction to proceed concurrently, does not provide opacity parameterized with respect to any memory model.
These results assume that items are accessed nontransactionally without a preceding privatization transaction, and show the implications of not privatizing, while our results complete the picture by showing the cost of privatization.The consistency condition assumed by all our results is that if a transaction writing to an item t a value other than the initial value, commits, then a later nontransactional read of t returns a value that is different from the initial value; vice versa, if no transaction writing to t commits and no nontransactional write changes t then a nontransactional read of t returns the initial value.
This property follows from parameterized opacity [16], regardless of the memory model imposed on nontransactional reads and writes.Private transactions [9] attempt to combine the ease of use of implicit privatization with the efficiency benefits of explicit privatization.
A private transaction inserts a quiescing barrier that waits until all active transactions are completed; thus other, non-privatizing transactions avoid the overhead of privatization.
The barrier reads an array whose size is proportional to the maximal parallelism, demonstrating again the inherent tradeoff we have proved between parallelism and privatization cost, in oblivious STMs.
As in VisibleRingSTM, the size of the active transactions array can be bounded, thereby reducing the overhead of the barrier, but at the cost of limiting the level of parallelism.An alternative way to provide strong atomicity is thorough static separation [2].
This is a discipline in which transactional and nontransactional accesses are not mixed on the same data item.
To access items nontransactionally, a transaction copies them to a private buffer, trivially incurring the cost predicted by our lower bound.
Dynamic separation [1] allows data to change modes without being copied, simply by setting a protection mode in the item.
Dynamic separation requires to modify the protection mode of all items to become privatized, in accordance with our lower bound.
This paper studies the theoretical complexity of privatization with uninstrumented nontransactional reads, and shows an inherent cost, linear in the number of privatized items.
In STMs with invisible reads, a transaction privatizing k items must have a data set of size k.
A more involved proof shows that even when the STM has visible reads, the privatizing transaction must access r memory locations, where r is now the minimum between k, the number of privatized items and the number of concurrent transactions that make progress.
Both results assume that the STM is oblivious to different non-conflicting executions and guarantees progress in such executions.
The specific assumptions needed to prove the bounds indicate that limiting parallelism or tracking the data sets of other transactions are the price to pay for efficient privatization.The privatization problem is informally characterized by two subproblems: The delayed cleanup problem [22], in which transactional writes interfere with nontransactional accesses, and the doomed transaction problem [35], in which transactional reads of private data lead to inconsistent state.
Our definition of privatization safety (Property 4) formalizes the first problem; our results show that this problem by itself is an impediment to the desire to provide efficient privatization.As discussed in Section 6, some STMs maintain visible reads, yet they are oblivious [9], [14].
SkySTM [23] has visible reads, and avoids the cost of the privatizing transaction by not being oblivious; it makes transactions with trivial, read-read conflicts visible to each other.
Since SkySTM is not oblivious, our lower bounds do not hold for it.
SkySTM, however, demonstrates the alternative cost of not being oblivious, because any writing transaction-not only privatizing transactions-writes to a number of base objects that is linear in the size of its data set, not just the write set.
It remains an interesting open question whether this is an inherent tradeoff, or whether there is an STM such that a privatizing transaction takes O(1) steps, and any writing transaction writes to a number of base objects that is linear in the size of its write set.Strong privatization safety [23] further guarantees that no primitive (including a read) is applied to a private location of a process that completed a privatizing transaction.
It formalizes the other problem with privatization, of doomed transactions, and it would be interesting to investigate the cost of supporting it.
