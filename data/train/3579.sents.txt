Realtime network verification ensures the correctness of network by incrementally checking data plane updates in real time (e.g., < 1ms per rule update).
Even state-of-the-art methods can already achieve sub-millisecond verification time, such speed is achieved mostly for pure IP forwarding devices, and is unrealistic for real-world networks, due to two reasons.
(1) Their network models cannot express the forwarding behavior of real devices, which have various functions including IP forwarding, ACL, NAT, policy-based routing, etc. (2) Their update algorithms do not scale in space and/or time: multi-field rules (e.g., ACL rules) can make these tools run out of memory and/or incur long verification time.
To scale real-time verification to real networks, we propose APKeep based on a new modular network model that is expressive for real devices, and propose new algorithms that can achieve low memory cost and fast update speed at the same time.
Our experiments show that for real-world update traces consisting of IP forwarding rules and ACL rules, existing methods either run out of memory or incur a prohibitively long verification time, while APKeep still achieves a sub-millisecond verification time.
We also show that APKeep can verify an update of NAT rule mostly in less than 1 millisecond.
Computer networks are prone to faults due to protocol misconfigurations, software bugs, and hardware failures [7,17,26,35].
Manually troubleshooting the faults often costs a network downtime up to several hours [7].
How to prevent network faults by ensuring network correctness becomes a fundamental problem posed to network operators and researchers.Network verification seeks to automatically check network correctness at both control plane [9,12,13,16,18,19,30] and data plane [10, 15, 20, 22-24, 27, 36-40].
Compared to control plane verification which focuses on detecting protocol misconfigurations, data plane verification directly checks the data plane, which is closer to the actual forwarding behaviors of packets, and thus can catch a broader range of faults due to switch software bugs and hardware failures.More recently, realtime data plane verification allows operators to check the correctness of data plane as it updates in realtime [20,22,24,[37][38][39].
To achieve this, realtime data plane verifiers often partition packets into equivalence classes (ECs), and maintain a model of forwarding behavior for these ECs.
When the data plane updates, they incrementally update the model, and check the updated model against correctness properties.State-of-the-art realtime data plane verifiers have already achieved sub-millisecond verification time [20,24].
However, such speed is mostly achieved for pure forwarding devices.
For real devices consisting of various functions other than forwarding, these verifiers exhibit two fundamental limitations.Network model is not expressive for real devices.
Apart from IP forwarding, real devices have many other functions including access control list (ACL), network address translation (NAT), etc., which are composed in specific orders to implement various processing logic.
For example, inside a typical router, multiple ACLs can be chained and applied at multiple ports to filter inbound and/or outbound packets [1].
Some routers may perform NAT on packets matching an ACL.
Tools like VeriFlow [24] and Delta-net [20] assume simple models which only express forwarding functions.
Models of NetPlumber [22] and AP Verifier [38,39] can express more functions, but are hard to extend.
For example, most vendors provide variants of policy-based routing [8], and adding such a feature requires heavy modification of their models.
Even for the same set of functions, different devices may also have different pipelines, and writing a model for each of them is clearly not scalable.Verification algorithms are not scalable for real devices.
Range EC-based methods like VeriFlow and Delta-net represent each EC as a range of packet headers, thereby achieving a fast verification speed for IP forwarding rules.
For example, Delta-net can check an update of IP forwarding rule in tens of microseconds on average.
However, when there are multi-field rules, e.g., ACL rules, range EC-based methods may suffer from the problem of EC explosion, where the number of ECs grows exponentially with the number of multi-field rules.
We find that for a real-world dataset consisting of only 686 ACL rules, an open-source version of VeriFlow and our multi-field extension of Delta-net can create up to 15 million ECs, causing either prohibitively long verification times or memory overflows.AP Verifier computes the minimum number of ECs with respect to the network behavior.
The downside, however, is that the update of ECs is more difficult, and can cost up to 10 milliseconds [37].
To overcome the above limitations and bring realtime network verification closer to the real world, this paper presents APKeep, a new realtime data plane verifier.APKeep builds on a new network model that is modular and expressive.
It models networks in a granularity of logical functions instead of physical devices.
Each function, e.g., forwarding, filtering, rewriting, is modeled as a logicallyindependent element, which holds a set of logical ports corresponding to different actions on packets.
APKeep views packets forwarded to the same port (i.e., undergoing the same actions) at each element as an EC, and encodes each EC with a logical predicate.
The modularity of our model makes it easy to support common functions and vendor-specific compositions of functions in real devices.
In addition, it also reduces the update scope and makes the update more efficient.APKeep uses novel algorithms to compute and maintain the minimum number of ECs in realtime.
A key reason for EC explosion of existing methods is that they create ECs based on the match fields of rules, resulting in a lot of unnecessary ECs with the same forwarding behavior.
In addition, they cannot compress these ECs after creation.
APKeep significantly reduces the number of ECs based on two principles.
(1) Creating ECs only when necessary.
APKeep creates ECs only when it needs more ECs to express new forwarding behaviors.
(2) Merging ECs when possible.
APKeep tracks the forwarding behavior of each EC, and merges multiple ECs with the same forwarding behavior.
We proved that by applying the above principles, APKeep always maintains the minimum number of ECs during update.In summary, our contribution is three-fold:• We introduce a new network model that is modular and expressive for modeling real network devices.
• We design APKeep, which uses novel algorithms to fast update the network model for realtime verification.
• We show APKeep achieves a sub-millisecond verification time for update traces consisting of IP forwarding rules, ACL rules, and NAT rules.Roadmap.
We present the design overview ( § 2) and details ( § 3) of APKeep, followed by a case study ( § 4).
Then, we show the experiment results ( § 5).
After discussing related work ( § 6) and potential issues ( § 7), we conclude ( § 8).
This section overviews the design of APKeep.
We will first introduce the network model that APKeep builds on, and then show how APKeep can fast update the model.
To achieve realtime network verification for real networks, the network model should satisfy three key requirements: (1) expressive for common functions in real devices, e.g., IP forwarding, ACL, NAT, policy-based routing, etc.; (2) extensible for different devices with different vendor-specific implementations of these functions; (3) efficient to update for achieving realtime verification.
We propose Port-Predicate Map (PPM), a new network model that meets all the above requirements.
To demonstrate how PPM works, we use the example network shown at the top-left corner of Figure 1.
In this network, switch C has four functions or modules (two ACLs, one forwarding, and one NAT), each having its own rules.
If packets arrive at port1, two ACLs ACL1 and ACL2 are applied in sequence; if they arrive at port2, only ACL1 is applied.
Then, the packets will be sent to an output port according to the forwarding rules.
If the output port is port5, packets will go through an NAT.As an alternative, we could model a device as a monolithic box.
This approach has the following drawbacks.
First, it will be difficult to extend the model for new functionalities.
For example, a device from another vendor may have a different chaining of modules (e.g., NAT before IP forwarding), or a new function (e.g., overriding IP forwarding with user policies).
Then, we need to compose another device model.
In addition, it will also make the update inefficient.
For example, suppose a rule is inserted into ACL1, then we need to update the ECs allowed by the two input ports.Element.
Instead of modeling a network as a set of devices, PPM models at a granularity of element, defined as a logicallyindependent function (e.g., IP forwarding, ACL, or NAT).
Each element has its own set of rules, and holds a set of logical ports.
Different from physical ports, i.e., interfaces, logical ports represent generic actions including "output to VLAN 10", "permit SSH traffic", "rewrite dstIP to 10.0.0.1".
This allows elements to express a broad range of functions other than IP forwarding.
In specific, an element holds one port for each distinct action of rules in the element, and a special port for the default action is reserved for packets not matching any rules.
When a packet arrives at an element, it will be "forwarded to" to exactly one port of the element, i.e., taking the actions of that port.
Currently, PPM supports three types of elements, and more types can be added in the future.
• A forwarding element has rules that match IP prefixes and whose actions are "output packets to a specific set of interfaces".
A forwarding element holds one port for each distinct set of interfaces, and a de f ault port for the default action, e.g., dropping packets.
• A filtering element has rules that match 5-tuples and whose actions are either "permit" or "deny".
A filtering element holds exactly two ports: permit and deny.
• A rewriting element has rules which match 5-tuples and whose actions are "rewrite a specific header field to a specific value".
A rewriting element holds one port for each distinct rewriting action, and an id port corresponding to no packet rewrite.
When a device has multiple functions, we break it into multiple elements.
As shown in the left bottom of Figure 1, device C breaks into a forwarding element FW-C, two filtering elements ACL1-C, ACL2-C, and a rewriting element NAT-C.
Equivalence Class.
Let E be the set of all elements in the network, and H be the set of all packet headers.
For each header h ∈ H and element e ∈ E, let Port e (h) be the port that h would be "forwarded to", assuming h has been received by e. Then, we have the following definition for equivalence class (EC).
Definition 1.
We say C = {c 1 , c 2 , . . . , c n } is a set of equivalence classes (ECs) with respect to element set E and header set H if:(1) c i ∧ c j = / 0, i = j; (2) ∨ n i=1 c i = H ; (3) ∀h 1 , h 2 ∈ H , h 1 = h 2 : ∃c ∈ C , h 1 , h 2 ∈ c ⇒ ∀e ∈ E,Port e (h 1 ) = Port e (h 2 ) 1 .
We say C is the minimum set of ECs if it is the smallest set satisfying the above conditions.APKeep encodes an EC with a logical predicate, i.e., Boolean formula.
The reason to use predicate instead of range as in [20,24] is that a predicate can encode an arbitrary set of packet headers, such that multiple range-based ECs having the same forwarding behavior can be represented as a single predicate.
This allows APKeep to merge ECs with the same forwarding behavior, thereby avoiding explosion of ECs ( § 2.2).
Port-Predicate Map.
For each predicate c and each element e, let Port e (c) = Port e (h), ∀h ∈ c. Suppose p = Port e (c), then we say port p holds predicate c. Define the predicate set of 1 Condition (3) says that for each h 1 and h 2 in H such that h 1 = h 2 , we have: if there exists an c in C such that h 1 and h 2 both belong to c, then for each element e in E, Port e (h 1 ) = Port e (h 2 ) port p as: Pred(p) = {c ∈ C |Port e (c) = p, e ∈ E}.
We can see that Pred is a map from port to predicates, which encodes the network forwarding behavior: given a packet h at element e, suppose it belongs to predicate c, then h will be forwarded by e to the port p satisfying c ∈ Pred(p).
Element Topology.
PPM uses the element topology to describe how elements are chained to process packets in the network.
The right of Figure 1 shows the element topology of the example.
First, each node represents an "application" of the corresponding element.
For example, since ACL1-C is applied to port1 and port2, there are two nodes ACL1-C-Port1-in and ACL1-C-Port2-in.
The forwarding element FW-C is applied once, and thus it corresponds to a single node.
Creating a separate node for each application allows elements to be agnostic of input ports where packets are received.
Second, each node has a set of ports, each holding a set of predicates, in the same way as its corresponding element.
Thus, we only need to update a single element rather than all its nodes.
For example, when a rule is inserted into ACL1, we only update the element ACL1, rather than its two nodes.
Third, nodes are connected based on the physical topology, and how the elements are applied inside devices.
For example, a port of A is connected to port1 of C in the network topology.
Then, in the element topology, the port of A connects to the in port of ACL1-C-Port1-in, whose permit port connects to the in port of ACL2-C-Port1-in, and its permit port connects to the port1 of FW-C.
The element topology will be used to construct forwarding graphs for verification ( § 3.3).
As shown above, PPM achieves modularity by breaking the composite functions inside a device into logicallyindependent elements.
This brings the following benefits.Expressiveness.
Using the three types of elements as building blocks, PPM can express the forwarding, ACL, and NAT functions.
Besides that, we will show how PPM can express the policy-based routing function offered by a major device vendor ( § 4).
Extensibility.
Even most devices share roughly the same set of functions, the implementations and compositions of these functions are often vendor-specific.
Writing a model for each different device wastes time and effort.
PPM models each device at the function level with elements, therefore it is relatively easy to model devices with vendor-specific compositions of functions by properly chaining the elements.Reduced update scope.
First, updates of multiple elements are decoupled, and when a rule is updated, we only need to update the element where the rule is updated, without affecting other elements.
For example, multiple ACLs may be chained and applied to an interface.
If a rule is inserted to one ACL, we only need to update the element of that ACL.
Secondly, the application of elements is decoupled away from the elements themselves.
For example, an ACL can be applied to multiple interfaces, and we only need to update the element of the ACL once, instead of updating all these interfaces.
As another example, an operator may activate/deactivate an existing ACL on a port, or even migrate an ACL from a port to another [33].
In this case, we do not need to update the element of the ACL, as the forwarding behavior of the element is not affected.
In the following, we show how APKeep updates the network model using a simple example in Figure 2.
As shown in (a), the device has an ACL applied to its input port, followed by a forwarding module.
For simplicity, we assume there are two match fields: dstIP represented with 2 bits x 1 , x 2 , and dstPort represented with 2 bits y 1 , y 2 .
The forwarding module matches only dstIP with longest prefix match, and the ACL matches both dstIP and dstPort according to priorities (larger number means higher priority).
We assume that by default, the ACL denies all packets and the forwarding module forwards all packets to port1.
Initially, we have one EC a, which appears at the port port1 of element FW, and the port deny of element ACL.
We will insert two ACL rules R1 and R2 shown in (b), and two forwarding rules R3 and R4 shown in (c).
First, we insert an ACL rule R1, whose match fields are x 1 x 2 = 0 * , y 1 y 2 = 00, as shown at the top of (d).
APKeep analyzes how R1 will affect the behaviors of element ACL.
Specifically, APKeep finds R1 overrides the default deny rule in the red dashed rectangle.
However, since R1 also has a deny action, packets in the rectangle will not change.
Thus, APKeep does not update the EC a, which still appears at port1 of FW and deny of ACL, as shown at the bottom of (d).
In contrast, if we create range-based ECs based on match fields, we will split EC a into three ECs, each of which is a rectangle in the header space.Suppose another ACL rule R2 is inserted.
Since R2 has a lower priority than R1, APKeep finds R2 can match only the shaded area, where it overrides default deny rule.
As a result, packets matching the shaded area will change their behavior from deny to permit.
To reflect that change, APKeep decides to transfer those packets from port deny to port permit.
Since the packets are a portion of EC a, it splits a into two ECs, i.e., b for the shaded area, and another one by subtracting b from a.Then, APKeep transfers b to port permit, as shown at the bottom of (e).
The reason that the EC b can be a non-rectangle area is that ECs are encoded with predicates.
Specifically, the match fields of R1 and R2 can be represented as predicates ¯ x 1 ¯ y 1 ¯ y 2 and ¯ y 1 , respectively.
Then, b can be calculated by logical operations asb = ¯ y 1 ∧ ¬( ¯ x 1 ¯ y 1 ¯ y 2 ) = ( ¯ y 1 x 1 ) ∨ ( ¯ y 1 y 2 ).
Suppose a forwarding rule R3 is inserted.
R3 overrides the default rule in the red dashed rectangle, which changes its port from port1 to port2.
APKeep creates two new EC c and d by splitting a and b, respectively, and transfers them to port2, as shown in (f).
The insertion of another forwarding rule R4 is similar and shown in (g).
At this time, APKeep finds two ECs d and f appear at the same port at both elements, meaning that they have the same forwarding behavior -permitted by the ACL and forwarded to port2.
Thus, APKeep merges d and f into a single EC.
Similarly, APKeep merges c and e into a single EC, as shown in (h).
The merging of ECs translates into logical disjunction of predicates.
For example, d and f are merged into an EC represented by ( ¯x 1 ¯ x 2 ¯ y 1 y 2 ) ∨ (x 1 ¯ x 2 ¯ y 1 ).
Finally, after inserting R1 through R4, APKeep creates 4 ECs.
In contrast, if we create range-based ECs based on match fields, we will need 10 ECs, one for each rectangle of (h).
The above is just an over-simplified example with only two fields which have 3-4 values.
In real scenarios, the reduction rate can be as high as 99.99% (see Table 3).
Actually, we prove that APKeep always maintains the minimum number of ECs during update (see Theorem 1).
The reason that APKeep can update such a small number of ECs is two-fold: (1) Creating new ECs only when necessary.
APKeep creates a new EC only when part of an existing EC changes its forwarding behavior and the EC needs to be split into two ECs.
In contrast, creating new ECs whenever the match fields of the new rule split some existing ECs will result in many redundant ECs.
(2) Merging ECs whenever possible.
APKeep tracks the forwarding behaviors of ECs, and merges multiple ECs if they have the same forwarding behavior.
In contrast, range-based EC presentation mostly does not allow ECs to be merged.The update of ECs in APKeep is much faster compared to AP Verifier due to the following reason.
APKeep can quickly identify the changes of forwarding behaviors, and incrementally update predicates instead of re-computing them ( § 3.2).
In contrast, AP Verifier maintains a port predicate for each device port, and computes atomic predicates (minimum number of ECs) based on all port predicates.
When a rule is updated, it needs to first update the port predicates, and if new port predicates are created, it re-computes the atomic predicates based on the updated port predicates.
We observe an up to 200× speedup in our experiments.
This section presents the design of APKeep.
Figure 3 shows the architecture of APKeep, which consists of three layers: The driver layer serves as the interface between network data plane and the model layer.
In the bootstrap stage, the config parser reads in the network topology and configuration files, and generates the vendor-neutral data plane config, describing the configuration of interfaces, VLANs, ACLs, etc. for each device.
The update parser fetches the FIB/ACL/NAT (changes) from each device and generates data plane updates, including insertion/deletion/modification of rules.
For each device, APKeep constructs a device model based on its configuration of interfaces, ACLs, NAT, etc., and decomposes the device model into a set of elements.
Currently, APKeep offers three types of elements, i.e., forwarding element, filtering element, and rewriting element.
Initially without any rules, a forwarding element has a de f ault port; a filtering element has a permit port and a deny port; a rewriting element has an id port.
For forwarding and rewriting elements, more ports can be created on-the-fly during rule insertions.After creating elements, APKeep constructs the element topology by augmenting the physical topology with intradevice element connections, based on how elements are composed inside the device.
For example, if an ACL ACL1 is declared to filter inbound traffic at port port1, then there is a connection from the permit port of ACL1 to the port1 port of the forwarding element.Initially there is only one True predicate, standing for the set of all possible packets.
For each element, the True predicate is held by its de f ault, deny, or id port, depending on the element type.
APKeep initializes the predicate set Pred(p) ( § 2.1) to {True} if p is de f ault, deny, or id port, and to empty set otherwise.
For each rule update, APKeep updates the PPM using three steps: (1) encoding the match fields of the rule, (2) identifying the changes of forwarding behavior, and (3) updating the predicates and the map from port to predicates.
The following only shows the case for rule insertion, and rule deletion differs only slightly in Step (2).
Rule modification can be seen as a pair of rule deletion and insertion.Let r be the rule to be inserted, specified as a 3-tuple (priority, match, action), and let e be the element where r Algorithm 1: IdentifyChangesInsert(r, R ) Input: r: the newly inserted rule; R : the list of existing rules, sorted by decreasing priorities.
Output: C: the set of changes due to the insertion of rule r. 1 C ← {}; 2 r.hit ← r.match; r .
hit ← r .
hit ∧ ¬r.hit;10 Insert r into R ;11 return C;is inserted.Step 1.
Encoding match fields.
Assume each packet header has h bits, each of which can be represented as a Boolean variable.
Then, the match field of a rule corresponds to a set of packet headers, and can be represented as Boolean formula of h variables.
For example, an IP match field of 128.0.0.
* can be represented asx 1 ∧ ¯ x 2 ∧· · ·∧ ¯ x 24 .
We adopt the methods of [37] to encode the Boolean formulas of match fields based on Binary Decision Diagram (BDD [11]).
BDD is a data structure that can canonically represent Boolean formulas, and it allows efficient logical operations including conjunction (∧), disjunction (∨), and negation (¬).
By encoding the match fields with BDDs, we can efficiently compute and update predicates leveraging these logical operations.
We use r.match to denote the match fields of r, encoded with BDD.Step 2.
Identifying changes.
This step identifies the changes of forwarding behavior at element e, by analyzing how the insertion of r affects existing rules of e. Here, a behavior change takes the form of (δ, f rom,to), meaning packets satisfying predicate δ, which are originally forwarded to port f rom, will now be forwarded to port to.
Note that this step is locally performed at e.Before introducing the algorithm, we define the hit and port fields for each rule.
First, note that multiple rules may have overlapping match fields, and packets will take the action of the rule with the highest priority.
Thus, some headers in r.match may not "hit" rule r due to the presence of some higher-priority rules.
To represent the headers that actually "hit" a rule, we define the hit field for each rule r as:r.hit ¬(∨ r .
prio>r.prio r .
match) ∧ r.match(1)If h ∈ r.hit, we know that h will take the action of r. Initially when there is only one default rule, the hit field of the default rule is equal to its match field, i.e., True.
Second, recall that each element has a port corresponding to each distinct action of rules in the element.
We use r.port to denote the port corresponding to the action field of r.
As an example, if r is a forwarding rule whose action field is "output to interface eth0/0", then r.port = eth0/0.
Algorithm 1 summarizes the procedure to identify the set of all behavior changes when a rule is inserted.
It calculates the hit field r.hit by subtracting the match fields of higherpriority rules from r.match (Line 3-5), and identifies all behavior changes by analyzing how r.hit "overrides" lower-priority rules with different ports (Line 6-9).
The algorithm for rule deletion differs only slightly and is not given here.Step 3.
Updating predicates.
In this stage, APKeep takes the set of behavior changes caused by the inserted rule, denoted by C, and computes the set of transferred predicates, denoted by D.
The process is summarized in Algorithm 2.
In order to track which ports hold a given predicate, the algorithm maintains a map Port from each predicate c to the set of ports holding c, defined as Port(c) = {Port e (c)|e ∈ E}.
We term Port(c) as the port set of predicate c.Initially, the set of transferred predicates D is set to empty (Line 1).
For each change (δ, f rom,to), we iterate over each predicate p in the predicate set of f rom, and check whether p overlaps with δ (Lines 2-4).
If so, we further perform the following three steps (Lines 5-10).
(1) Splitting predicates.
In this step, we check whether p belongs to δ (Line 5).
If not so, we need to split p into two new predicates p ∧ δ and p ∧ ¬δ.
by invoking the Split function (Line 6).
As shown in Lines 11-17, the function Split(p, p1, p2) first updates the predicate set of each port in Port(p), by replacing p with p1 and p2 (Lines 12-13).
Then, it initializes the port set of p1 and p2 with that of p (Lines 14-15).
Finally, it updates the set of transferred predicates if needed ( Lines 16-17).
(2) Transferring predicates.
This step transfers the predicate p ∧ δ from port f rom to port to by invoking the Transfer function (Line 7), as shown in Lines 18-22.
(3) Merging predicates.
This step checks whether each predicate p held by port to has the same port set with p (Line 8).
If so, p and p have the same forwarding behavior, and we merge them into a new predicate p ∨ p , by invoking the Merge function (Line 9), as shown in Lines 23-28.
After the above three steps, we update δ by subtracting p from it, and proceed to the next predicate of port f rom (Line 10).
Theorem 1.
APKeep maintains the minimum set of equivalence classes after each rule update.The proof is given in Appendix A. Checking Invariants.
APKeep can check network invariants including loop-freedom and blackhole-freedom, which are defined as follows.
Transfer(p ∧ δ, f rom,to);8 if ∃p = p, Port(p ) = Port(p) then 9 Merge(p, p , p ∨ p ); 10 δ ← δ ∧ ¬p;11 Function Split(p, p1, p2):12 foreach port ∈ Port(p) do 13 Pred(port) ← Pred(port) ∪ {p1, p2}\{p}; 14 Port(p1) ← Port(p); 15 Port(p2) ← Port(p); 16 if p ∈ D then 17 D ← D ∪ {p1, p2}\{p};18 Function Transfer(p, f rom,to): • Loop.
A packet traverses the same device for the second time, without being modified.
• Blackhole.
A packet arrives at a device but does not match any forwarding rule.
Similar to Delta-net, APKeep checks invariants by constructing and traversing a delta forwarding graph (DFG), a graph with each edge labeled with the ECs allowed on the edge.
The difference is that APKeep updates the PPM model rather than DFG, and only constructs DFG based on the PPM model when checking invariants.
Specifically, given a set of transferred predicates, APKeep constructs the DFG by adding the transferred predicates and the corresponding edges on the element topology.
Then, APKeep traverses the DFG with a set of predicates P, which is initialized to the transferred predicates.
When an edge is visited, P is intersected with the set of predicates on that edge.
The traversal terminates when P becomes empty, reaching an edge with no next hop (blackhole detected), or the same node is visited twice (loop detected).
The construction and traversal algorithms of DFG are given in Appendix B.Checking policies.
Operators may need to check user-defined policies such as hosts in a specific prefix can or cannot access a web server, traffic from subnet1 to subnet2 should pass the firewall, etc.
We show how APKeep can support this task.
Here, we define a policy as a pair of match condition and path constraint, where the match condition can be specified by header fields (e.g., 5-tuple), and a path constraint can be specified by a regular expression.
Given a policy, APKeep can convert its match condition into a policy predicate, i.e., a BDD denoted as q, and its path constraint into an automata denoted as A. APKeep can check whether the policy is satisfied after an update as follows.Let D be the transferred predicates after an update.
APKeep computes a new set of predicates D q ← {δ ∈ D|δ∧q = f alse}, and constructs the DFG G q based on D q .
Then, APKeep traverses G q while updating an instance of automata A for each p i ∈ D q , denoted as A i .
Specifically, APKeep updates the automata A i if the predicate p i visits a new node in DFG.
The policy is satisfied if after traversal, all the automata enter the absorbing states; otherwise, the policy is violated.
Note here multiple policies can be checked in parallel, and for each policy, the updating of each automata can also be parallelized.What-if analysis.
Operators can use APKeep to conduct "what-if analysis", e.g., will the invariants break if a specific link fails?
APKeep answers such a query by retrieving all the predicates traversing the link, constructing a DFG using these predicates, and traversing the DFG to check invariants.
The time to answer such a query heavily depends on the total number of ECs.
We will show APKeep achieves a much shorter running time than Delta-net ( § 5.4).
APKeep supports packet rewrites with rewriting elements.
A rewriting element consists of a list T of rewrite rules, where each T ∈ T matches on 5-tuples, and rewrites the header to a specific value.
APKeep creates a port for each rule in the rewriting element.Based on the match fields of rewrite rules, we can compute predicates, and assign them to each port of the rewriting element, just as the forwarding and filtering element.
The different part is: (1) how to encode packet rewrites using logical operations; (2) how to update predicates in the presence of rewrites.Encoding packet rewrites.
we adopt the methods in [39] to encode packet rewrites with logical operations as follows.
First, it uses the existential quantification on predicate.
Let p be a predicate, and x be one of the Boolean variables that p is defined on.
The existential quantification of x is defined as:∃x.p = p| x=true ∧ p| x= f alse(2), where p| x=true sets the value of variable x in p as true.Suppose the header has two bits x 1 , x 2 , then an NAT rule T that rewrites it to x 1 = 1, x 2 = 0 can be encoded as a logical function:T (p) = (∃x 1 ∃x 2 .
p) ∧ (x 1 ∧ ¯ x 2 )(3)The existential quantification operation is supported by BDD.Updating predicates in the presence of rewrites.
Recall that for verification, we need to traverse a DFG which is constructed based on PPM.
When there are only forwarding and filtering elements, we only need to perform intersections on predicate sets during traversal.
However, when there are rewriting elements, predicates need to be transformed, and we need to ensure two conditions:(1) Each predicate should be unambiguously transformed, i.e., the transformation should be defined for each predicate in PPM.
For example, suppose p is split into p1 and p2, we should know how to transform each of them; otherwise, when traversing with only p1 or p2 in the predicate set, the rewriting element does not know how to transform it.
(2) The result of transformation should be represented by a set of predicates in PPM such that the traversal can proceed.
For example, suppose a predicate p is held by the port of rewrite rule T , and T (p) = p .
If p cannot be represented by a set of predicates in PPM, the traversal cannot continue since p is not "recognized" by other elements.In order to satisfy these two conditions, we apply the following two operations: (1) when a predicate p of a rewriting port is split into p1 and p2, we compute p1 = T (p1) and p2 = T (p2), and apply operation (2).
(2) if the transformation result p cannot be represented as a set of predicates, we create new predicates to represent p. Note that this may split a predicate of some rewriting port and trigger operation (1).
Algorithm 3 summarizes how APKeep handles rule updates for rewriting elements.
First, it updates the predicates with Algorithm 2 (Line 1).
The difference lies in that the algorithm also maintains a rewrite table, where for each entry (k, v), k is a predicate before rewrite, and v is a set of predicates after rewrite.
After transferring one predicate p to the port of another rule r , we need to apply the rewrite rule r on p, and ensure the values in the rewrite table are still predicates (Lines 2-12).
Delayed predicate merging.
In Algorithm 2, APKeep merges two predicates instantly if they have the same port set.
However, for some datasets, we find that some predicates are repeatedly merged and split, resulting in a waste of time.
Thus, we adopt a delayed predicate merging: when a predicate can be merged, we record it, and when the total number of predicates exceeds a threshold (500 by default), we merge all the recorded predicates.
To fast determine whether a predicate can be merged, we maintain a hash table where the key is an 13 Function SplitRW(p, p1, p2): Split(p, p1, p2);15 foreach (k, v) ∈ R T do 16 if p ∈ v then 17 v ← v ∪ {p1, p2}\{p}; 18 R T .
remove(p); 19 R T .
add(p1, {T (p1)}); 20 R T .
add(p2, {T (p2)}); 21 return D;ordered list of ports, and the value is a set of predicates that appear at all these ports.Separate update for different types of elements.
Updating both forwarding rules and ACL rules may result in a large number of predicates.
For example, suppose there are n ECs generated by forwarding rules, and an ACL rule matching a destination port range will create n new ECs.
AP Verifier [37] proposed to compute the atomic predicates for forwarding and ACL rules, separately.
We adopt this approach and update two sets of predicates, one for forwarding elements, and one for ACL elements.
When traversing the forwarding graph, we need to carry two sets of predicates, and set intersection only happen between the same set of predicates.
Different from [37], our algorithm avoids false positives when verifying invariants.
For example, when a node is visited twice, we evaluate whether there exist two predicates, one from each set, that have non-empty conjunction.
If so, the loop exists; otherwise, the loop is a false positive.
We study the expressiveness of our PPM model by showing how to model a vendor-specific function with the three built-in element types.Policy-Based Routing (PBR) is a function commonly available in many routers and switches.
It allows operators to override the IP forwarding rules such that packets are forwarded based on criteria other than destination IP address.
Different vendors may implement their own version of PBR, and here we study one such implementation offered by a large device vendor.The vendor offers a function named traffic policy, defined as a set of classifier-behavior pairs.
The following shows a traffic policy p1 applied to inbound traffic of interface eth0/0 at switch C. p1 is defined by a classifier c1 and a behavior b1, meaning that packets satisfying c1 will be forwarded according to b1.
c1 is defined using an ACL ACL1, and the behavior is redirecting traffic to interface eth1/1.
The topleft and top-right of Figure 4 show the processing logic of switch C and the network topology, respectively.
In our PPM model, the above traffic policy can be easily modeled by creating an ACL element ACL1-C, and properly chaining it into the forwarding graph, as shown in the bottom of Figure 4: (1) connecting its in port to the upstream port originally connected to eth0/0, (2) connecting its permit port to the downstream port originally connected to eth1/1, (3) connecting its deny port to the eth0/0 port of FW-C.
The above is just the simplest form of traffic policy, and in a more general case, a policy can contain multiple classifierbehavior pairs, and each classifier can contain multiple ACLs.
Then, we need to create multiple elements, one for each ACL, and cascade them together.In addition to 5-tuples, a traffic policy also matches various information including VLAN ID, layer-3 packet length, time ranges, etc.
Since the predicate-based EC representation has no restriction on the match fields, we can encode these match conditions by adding more fields.
For example, we can add a 16-bit field to encode the packet length from 0 to 65535, and a 5-bit field to encode the hour-level time range.
Note since PPM models the packet forwarding behaviors of symbolic packets, the fields to add do not have to be packet headers.
Apart from PBR, the traffic policy function also supports other behaviors including traffic statistics, flow mirroring, etc., which do not change the forwarding behaviors, and rate limiting, congestion avoidance, which selectively drop packets.
As all previous data plane verifiers, PPM cannot model these features.
Implementation.
We implemented APKeep with around 5K lines of Java code.
Currently, we have implemented config parsers for three different vendors, which translate vendorspecific configuration files into a unified representation in JSON format.
We also implemented an update parser for one vendor, whose devices support fetching data plane state including FIBs and ACLs.
For verification, we implemented an invariant checker that can detect loop and blackhole, and a what-if analyzer that can reason about the possible impact of link failures.
For BDD operations, we use JDD, a BDD library for Java [34].
Dataset.
Table 1 shows the datasets we use.
The first six consist of updates of IPv4 forwarding rules, and the last two consist of updates of both IPv4 forwarding rules and ACL rules.
The first three datasets are generated by Delta-net [20] using the ONOS SDN-IP application [6], and the Internet2 dataset is from [5].
The Stanford dataset [2] consists of both IPv4 forwarding rules and ACL rules, and the original Purdue dataset [32] consists of only ACL rules.
We generate forwarding rules for the Purdue dataset, using shortest path routing.
Finally, we remove the ACL rules from these two datasets, and obtain another two pure-IP datasets Stanford * and Purdue * .
Since the last five datasets are snapshots of rules, we generate a sequence of updates from each of them as follows.
First, we add all the ACL rules (if any), one rule per ACL each time, and then all the forwarding rules, one rule per device each time.
After that we delete these rules in the reverse order as they are inserted.
Methods to compare.
We compare APKeep with four data plane verification tools.
AP Verifier [37].
We use its open-source implementation in Java [4], and also the authors' implementation of incremental update algorithms [3].
We modify it to process our rule updates, and implement an incremental loop checker for it.
Delta-net [20].
We implement an extended version of Deltanet using C++, referred to as Delta-net MF .
It handles singlefield IP forwarding rules in the same way as Delta-net, and handles multi-field ACL rules using a multi-layered tree approach as in VeriFlow.
Note, Delta-net MF may not be the best approach for extending Delta-net so that it can apply to multiple fields.
VeriFlow [24].
We use its open-source implementation in C.
Since VeriFlow only supports match fields expressed with prefixes, an ACL rule matching port ranges may be split into multiple ones which match prefixes.
NetPlumber [22].
We use its open-source implementation in C++ [2].
Since NetPlumber takes transfer function (TF) rule as input, we translate our rule updates into equivalent TF rule updates.
Prior to update, we insert all the default rules created by NetPlumber since the insertion and deletion of them take a long time, as confirmed by the paper.
We attach one source node to each device for NetPlumber to inject "flows" in the network model.
Apart from the above four methods, we also consider APKeep − , standing for APKeep without merging predicates.
For benchmark purpose, we let each method check loops after each update.
All the experiments run on a Linux desktop with a 3.0GHz Intel Core i5 CPU and 32GB RAM.
Figure 5 shows the verification time of APKeep.
We can see for all datasets, the verification time is less than 250µs for 90% of updates.
Table 2 compares the average running time of APKeep with the other methods.
For datasets with only IP forwarding rules, the running time of APKeep is comparable to Delta-net MF , and much shorter than the other methods.
For the 4Switch dataset, APKeep is 253×, 128×, and 937× faster than AP Verifier and VeriFlow, and NetPlumber, respectively.
Note that NetPlumber is relatively slow since it models each rule as a node, and computes all the flows through these rules.
Thus, its model is more fine-grained than APKeep, but incurs a relatively high cost.
Surprisingly, APKeep − is even faster than APKeep on some datasets.
The reason is that these datasets have a rather small number of ECs (see Table 3), and therefore merging ECs incurs additional overhead without paying off.
However, for the 4Switch dataset, APKeep − is much slower as it has 271,793 ECs, while APKeep has only 557 ECs.
For datasets with multiple match fields, all other methods including APKeep − either incur a prohibitively long running time or run out of memory.
For the Purdue dataset, only APKeep runs to completion, with an average running time of 13µs; all other methods either time out or run out of memory.
This demonstrates existing methods can hardly meet the realtime requirement when the rules to update match multiple fields.
We observe that the number of ECs heavily impacts the running time of realtime data plane verifiers.
To confirm this, we report the number of ECs maintained by APKeep, APKeep − , and Delta-net MF in Table 3.
We can see that when there is a single match field, APKeep − computes slightly fewer ECs than Delta-net MF .
The reduction is due to the fact that predicates can encode arbitrary packet sets, rather than ranges.
By merging predicates, APKeep computes much fewer ECs than APKeep − .
This indicates that using predicates alone cannot efficiently reduce the number of ECs.The number of ECs computed by Delta-net MF grows from 2283 to 15 million after only 686 ACL rules are inserted in the Stanford dataset, and reaches over 100 million after 2,707 ACL rules are inserted in the Purdue dataset.
Note that Delta-net MF actually does not run to completion for Stanford and Purdue datasets, and the numbers are counted by running only the functions related to the creation of ECs.
In contrast, APKeep computes only 515 and 4,160 ECs for these two datasets, a 99.99% reduction compared with Delta-net MF .
The above results show that range-based EC representation easily leads to an explosion of ECs when there are only a small number of rules with multiple match fields.
On the other hand, by representing ECs with predicates, and updating the minimum number predicates, APKeep can dramatically reduce the total number of ECs, thereby achieving a fast verification speed with small memory footprint.
Figure 6 shows the number of ECs maintained by APKeep and Delta-net MF during the updates.
The Airtel1 dataset consists of rule insertions and deletions which are generated to react to link failures.
Thus, the number of rules is small during update, and the total number of ECs is also quite small.
The 4Switch dataset only has rule insertions; and the last three datasets insert all rules and remove them later.
Thus, for Internet2 and Stanford, APKeep finally has only one and two predicates, respectively.
For the Purdue dataset, since both We evaluate the running time for APKeep to answer "what if" queries.
In particular, we consider the query "what is the fate of packets that use a link if the link fails?"
.
To answer this query, Delta-net constructs a forwarding graph using those ECs on that link, and is reported to be 10× faster than VeriFlow.
Thus, we only compare our results to those of Delta-net.
In We evaluate the time for APKeep to handle updates of rewrite rules.
We use the Stanford * and Purdue * dataset, and add NAT rules into the network as follows.
First, for each dataset, we find all the edge ports: an edge port holds a non-empty set of predicates, and is not connected to any other switches.
Then, for each edge port, we randomly select a predicate associated with it, and compute an IP prefix that satisfies the predicate.
Finally, for each IP prefix, we generate 25 NAT rules, each of which translates an IP address to another address belonging to a different IP prefix.
We place the updates of NAT rules after the updates of forwarding rules.
Figure 7 shows the running time of APKeep for different numbers of NATs ranging from 0 to 20.
Since each NAT has 25 rules, the number of NAT rules ranges from 0 to 1000.
We can see that the running time of APKeep is mostly less than 1ms, and scales well with the number of NAT rules.
Offline data plane verification was originally studied by Xie et al. [36], and later advanced by FlowChecker [10], Anteater [27], HSA [23], and NoD [25].
These tools take a snapshot of the data plane state, and check whether it satisfies network invariants like blackhole-freedom, loop-freedom, etc.
AP Verifier [37][38][39] uses Binary Decision Diagraph (BDD) to compute a predicate for each port, and uses all port predicates to generate atomic predicates, which are the minimum set of ECs.
APKeep differs in that it builds on a modular elementlevel model that is much more expressive than the monolithic model used by AP Verifier.
In addition, APKeep incrementally updates the ECs instead of re-computing them from scratch, thereby achieving up to 200× speedup compared to the incremental version of AP Verifier (Table 2).
To scale verification to large networks, Libra [40] uses MapReduce to parallelize verification.
Plotkin et al. [29] propose to transform large networks into smaller ones for scalable verification, based on network surgery and symmetry.
APKeep can leverage this technique to reduce network size, thereby scaling to larger networks.
RCDC [15] decomposes data plane verification into the validation of local contracts.
However, RCDC assumes structured datacenter networks so as to track the topology and address locality, while APKeep targets general networks.
SymNet [31] and VMN [28] focus on verifying stateful data planes with middleboxes.Realtime data plane verification incrementally checks the network data plane for each update in real time.
NetPlumber [22] builds on the plumbing graph model, where each node is a rule and a flow is a set of packets traversing the same sequence of rules.
Thus, the model has a finer grain than PPM, while the downside is that updating the model is relatively slow (Table 2).
VeriFlow [24] achieves a smaller verification time (< 1ms) by computing the equivalence classes (ECs) affected by an update, and checking the forwarding graph of each affected EC.
Delta-net [20] further reduces the verification time by incrementally maintaining a single EC-labelled graph, rather than constructing multiple graphs for each update.
VeriFlow and Delta-net can achieve submillisecond verification time for updates of single-field IP forwarding rules.
Howerver, they may suffer from the problem of EC explosion when there are multi-field rules, and cannot handle updates of rewriting rules.Representation of ECs.
Bjørner et al. propose ddNF [14], a new data structure for representing ECs, and show it outperforms BDD on datasets consisting of forwarding rules.
However, the set of ECs represented using ddNF may not be minimal.
#PEC [21] introduces a new lattice-theoretic method which can construct the minimum number of ECs, faster than using BDD.
#PEC may serve as a better foundation for multifield extension of Delta-net, and it would also be interesting to study how to leverage #PEC to further speed up APKeep.Control plane verification checks whether protocol configurations are correct [9,12,13,16,18,19,30].
They are orthogonal to APKeep, while tools like Batfish [18] may use APKeep to speed up the verification of generated data planes.
Model modularity vs. number of ECs.
Modeling the network at a fine granularity can make the update more efficient, while may also increase the number of ECs.
The reason is that the model may have more different forwarding behaviors, which need to be represented with more ECs.
For example, even two packets behave the same at a device level, their behaviors may differ in the intra-device processing, and thus should be represented with different ECs.
Thus, there is a tradeoff between the model granularity and the number of ECs.
It will be interesting to further navigate such tradeoff in the future.Fetching data plane state.
APKeep fetches the whole data plane state only once in the bootstrap stage, and only fetches data plane updates afterwards, whose cost can be much less compared to fetching the whole data plane.
To ensure timeliness, APKeep needs to fetch the updates from devices at a sufficient frequency.
We are aware some new devices have already provided APIs for fetching FIB updates, and we expect this feature will be supported by more devices in the future.Ensuring update consistency.
Since the data plane state is in continuous transition, a violation can be falsely triggered by a transient state.
APKeep can be made robust to such inconsistency as follows.
If an update fails the verification of an invariant, APKeep flags it as suspicious without raising an alarm.
After a configured time window, APKeep checks the invariant again to confirm whether the update is a true violation.
Detailed design is left as one of our future work.Why microsecond-level verification.
One major purpose of speeding up incremental verification is to ensure the network model, which verification is based on, can keep up with fast network updates.
For example, in a large datacenter with 1k devices, a 1ms model update time only allows the verifier to keep up with an average network update rate of 1 update per device every second.
Thus, further speeding up data plane verifiers can scale the verification to larger network size and higher data plane update rate.
This paper presented APKeep, a new realtime data plane verifier.
APKeep builds atop PPM, a modular network model that is expressive for real devices, and incrementally maintains the minimum number of equivalence classes in realtime.
We showed that for real updates consisting of both forwarding and ACL rules, all other methods either ran out of memory or incurred a prohibitively long verification time, while APKeep still achieved a sub-millisecond verification time.
MO 3 or the next hop is de f ault (Line 12-14), meaning packets in pset match no forwarding rule in the corresponding device, i.e., a blackhole is detected.
Otherwise, the algorithm updates pset and history and traverses the next hop (Line 15).
We compare the memory cost of APKeep with the other four methods.
Not surprisingly, for single-field datasets, the memory cost of APKeep is comparable to Delta-net MF , and both of them have smaller memory footprint than others.
For the multi-field Stanford dataset, Delta-net MF runs out of 32GB memory.
For the multi-field Purdue dataset, AP Verifier and VeriFlow do not run to completion within 24 hours; NetPlumber and Delta-net MF run out of 32GB memory.
APKeep still maintains a small memory footprint for these two multifield datasets.
1Proof.
According to Definition 1, it is easy to see that a set of ECs is minimum if the other direction of condition (3) also holds, i.e., if two packets are forwarded to the same port at each element, then they must belong to the same EC.
Therefore, define (3)' by replacing "⇒" with "⇔" in (3), and we need to prove that conditions (1)(2)(3)' hold for all predicates in the PPM model.
Clearly, these conditions hold initially when there are no updates: each element has a single default rule, and there is only one True predicate, which is assigned to the default/deny/id port depending on element type.
We prove the theorem by induction: if the conditions hold before an update, then they still hold after the update.Let e be the element whose rule is updated.
For condition (1)(2), it is clear that transfer operations do not modify predicates, and thus have no effect on these conditions.
Also, since split and merge only move part of one predicate into another one, they will not break these conditions, either.
In the following, we show both directions of (3)' hold.
⇒: Suppose h 1 , h 2 ∈ c after update, we show they appear in the same set of ports.
There are two cases.
(1) h 1 and h 2 belong to the same predicate before update.
Then, we know Port s (h 1 ) = Port s (h 2 ), ∀s, and the update only changes Port e (h 1 ) and Port e (h 2 ).
Then, we only need to show Port e (h 1 ) = Port e (h 2 ) after update.
Clearly this holds if neither h 1 or h 2 changes its port at e. Suppose at least one of them changes its port at e, and let Port e (h 1 ) = Port e (h 2 ) = p a before update.
Without loss of generality, suppose h 1 changes its port to p b = p a , we prove by contradiction that h 2 must have also changed its port to p b .
Assume h 2 either keeps its port unchanged or changes its port to p c = p b .
Suppose h 1 ∈ c 1 and h 2 ∈ c 2 after transferring predicates, then c 1 appears at port p b , and c 2 appears at port p a or p c .
Since c 1 and c 2 appear in different ports at e, they cannot be merged, contradicting our assumption that h 1 , h 2 ∈ c after update.
(2) h 1 and h 2 belong to different predicates before update.
Let h 1 ∈ c 1 and h 2 ∈ c 2 before update, then c 1 and c 2 must have been merged into c.
That is, c 1 and/or c 2 must have been transferred to the same port after update, which implies that h 1 and h 2 must have changed their ports to the same one at e. ⇐: Suppose Port s (h 1 ) = Port s (h 2 ), ∀s after update, there are two cases.
(1) h 1 , h 2 ∈ c before update.
Then, Port s (h 1 ) = Port s (h 2 ), ∀s before update, implying that both h 1 and h 2 do not change their ports or change to the same port.
If they do not change their ports, then they will still belong to the same predicate (either c if c is not split or c ∧ ¬δ if c is split).
If they change their ports, then a predicate including h 1 , h 2 (either c if c is not split or c ∧ δ if c is split) will be transferred to a new port, and they will still belong to the same predicate, no matter whether the transferred predicate is merged or not.
(2) h 1 ∈ c 1 , h 2 ∈ c 2 before update, then we know Port e (h 1 ) = Port e (h 2 ) before update, and thus at least one of them must have changed its port.
Without loss of generality, suppose h 1 has changed its port such that Port s (h 1 ) = Port s (h 2 ) after the change, and let c be the transferred predicate satisfying h 1 ∈ c .
This will trigger our algorithm to merge c and c 2 .
B Algorithms for Constructing Delta Forwarding Graphs and Checking InvariantsConstructing delta forwarding graphs.
Algorithm 4 summarizes the process of constructing delta forwarding graphs.
It takes the set of transferred predicates, denoted as D, computed by Algorithm 2, and returns a delta forwarding graph, denoted as G(V, E, A).
Here, V is the set of nodes, E is the set of edges, and A : E → 2 C is a map from each edge to the set of predicates allowed on that edge (C denotes the set of all predicates).
That is, A(s1, s2) is the set of predicates that can be sent from switch s1 to switch s2.
First, V , E, and A are initialized (Line 1).
For each predicate δ in D, APKeep iterates over each port in the port set of δ (Lines 2-3).
If the node s1 holding port is not in the node set V , then s1 is added into V (Lines 4-6).
Similarly, if the node directly connected to port is not in V , then s2 is also added into V (Lines 7-9).
Note here if the port is "default", we assume it is connected to a virtual node named "default".
If the edge (s1, s2) is not in the edge set E, then it is added into E, and the mapping A(s1, s2) is initialized to empty set (Lines 10-12).
Finally, the transferred predicate δ is added into the set A(s1, s2) (Line 13).
Checking invariants.
With the delta forwarding graph G, operators can check network invariants by traversing G. Algorithm 5 shows an example program for checking blackholefreedom and loop-freedom (defined in § 3.3).
The algorithm starts the traversal from each node s ∈ V .
Here V includes all nodes corresponding to the element where the rule is updated.
Before each traversal, the algorithm initializes pset, the current set of predicates, to D, and history, the nodes that have been visited, to empty set (Lines 2-3).
The traversal stops when pset becomes empty (Line 6-7) or the visited node is already in history (Line 8-10), meaning a loop is detected, Proof.
According to Definition 1, it is easy to see that a set of ECs is minimum if the other direction of condition (3) also holds, i.e., if two packets are forwarded to the same port at each element, then they must belong to the same EC.
Therefore, define (3)' by replacing "⇒" with "⇔" in (3), and we need to prove that conditions (1)(2)(3)' hold for all predicates in the PPM model.
Clearly, these conditions hold initially when there are no updates: each element has a single default rule, and there is only one True predicate, which is assigned to the default/deny/id port depending on element type.
We prove the theorem by induction: if the conditions hold before an update, then they still hold after the update.Let e be the element whose rule is updated.
For condition (1)(2), it is clear that transfer operations do not modify predicates, and thus have no effect on these conditions.
Also, since split and merge only move part of one predicate into another one, they will not break these conditions, either.
In the following, we show both directions of (3)' hold.
⇒: Suppose h 1 , h 2 ∈ c after update, we show they appear in the same set of ports.
There are two cases.
(1) h 1 and h 2 belong to the same predicate before update.
Then, we know Port s (h 1 ) = Port s (h 2 ), ∀s, and the update only changes Port e (h 1 ) and Port e (h 2 ).
Then, we only need to show Port e (h 1 ) = Port e (h 2 ) after update.
Clearly this holds if neither h 1 or h 2 changes its port at e. Suppose at least one of them changes its port at e, and let Port e (h 1 ) = Port e (h 2 ) = p a before update.
Without loss of generality, suppose h 1 changes its port to p b = p a , we prove by contradiction that h 2 must have also changed its port to p b .
Assume h 2 either keeps its port unchanged or changes its port to p c = p b .
Suppose h 1 ∈ c 1 and h 2 ∈ c 2 after transferring predicates, then c 1 appears at port p b , and c 2 appears at port p a or p c .
Since c 1 and c 2 appear in different ports at e, they cannot be merged, contradicting our assumption that h 1 , h 2 ∈ c after update.
(2) h 1 and h 2 belong to different predicates before update.
Let h 1 ∈ c 1 and h 2 ∈ c 2 before update, then c 1 and c 2 must have been merged into c.
That is, c 1 and/or c 2 must have been transferred to the same port after update, which implies that h 1 and h 2 must have changed their ports to the same one at e. ⇐: Suppose Port s (h 1 ) = Port s (h 2 ), ∀s after update, there are two cases.
(1) h 1 , h 2 ∈ c before update.
Then, Port s (h 1 ) = Port s (h 2 ), ∀s before update, implying that both h 1 and h 2 do not change their ports or change to the same port.
If they do not change their ports, then they will still belong to the same predicate (either c if c is not split or c ∧ ¬δ if c is split).
If they change their ports, then a predicate including h 1 , h 2 (either c if c is not split or c ∧ δ if c is split) will be transferred to a new port, and they will still belong to the same predicate, no matter whether the transferred predicate is merged or not.
(2) h 1 ∈ c 1 , h 2 ∈ c 2 before update, then we know Port e (h 1 ) = Port e (h 2 ) before update, and thus at least one of them must have changed its port.
Without loss of generality, suppose h 1 has changed its port such that Port s (h 1 ) = Port s (h 2 ) after the change, and let c be the transferred predicate satisfying h 1 ∈ c .
This will trigger our algorithm to merge c and c 2 .
Constructing delta forwarding graphs.
Algorithm 4 summarizes the process of constructing delta forwarding graphs.
It takes the set of transferred predicates, denoted as D, computed by Algorithm 2, and returns a delta forwarding graph, denoted as G(V, E, A).
Here, V is the set of nodes, E is the set of edges, and A : E → 2 C is a map from each edge to the set of predicates allowed on that edge (C denotes the set of all predicates).
That is, A(s1, s2) is the set of predicates that can be sent from switch s1 to switch s2.
First, V , E, and A are initialized (Line 1).
For each predicate δ in D, APKeep iterates over each port in the port set of δ (Lines 2-3).
If the node s1 holding port is not in the node set V , then s1 is added into V (Lines 4-6).
Similarly, if the node directly connected to port is not in V , then s2 is also added into V (Lines 7-9).
Note here if the port is "default", we assume it is connected to a virtual node named "default".
If the edge (s1, s2) is not in the edge set E, then it is added into E, and the mapping A(s1, s2) is initialized to empty set (Lines 10-12).
Finally, the transferred predicate δ is added into the set A(s1, s2) (Line 13).
Checking invariants.
With the delta forwarding graph G, operators can check network invariants by traversing G. Algorithm 5 shows an example program for checking blackholefreedom and loop-freedom (defined in § 3.3).
The algorithm starts the traversal from each node s ∈ V .
Here V includes all nodes corresponding to the element where the rule is updated.
Before each traversal, the algorithm initializes pset, the current set of predicates, to D, and history, the nodes that have been visited, to empty set (Lines 2-3).
The traversal stops when pset becomes empty (Line 6-7) or the visited node is already in history (Line 8-10), meaning a loop is detected,
