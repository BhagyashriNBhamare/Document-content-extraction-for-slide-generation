This paper introduces X-Force, a novel binary analysis engine.
Given a potentially malicious binary executable, X-Force can force the binary to execute requiring no inputs or proper environment.
It also explores different execution paths inside the binary by systematically forcing the branch outcomes of a very small set of conditional control transfer instructions.
X-Force features a crash-free execution model that can detect and recover from exceptions.
In particular, it can fix invalid memory accesses by allocating memory on-demand and setting the offending pointers to the allocated memory.
We have applied X-Force to three security applications.
The first is to construct control flow graphs and call graphs for stripped binaries.
The second is to expose hidden behaviors of malware, including packed and obfuscated APT malware.
X-Force is able to reveal hidden malicious behaviors that had been missed by manual inspection.
In the third application, X-Force substantially improves analysis coverage in dynamic type reconstruction for stripped binaries.
Binary analysis has many security applications.
For example, given an unknown, potentially malicious executable, binary analysis helps construct its human inspectable representations such as control flow graph (CFG) and call graph (CG), with which security analysts can study its behavior [40,23,50,46,6,33].
Binary analysis also helps identify and patch security vulnerabilities in COTS binaries [10,14,31,51,11].
Valuable information can be reverse-engineered from executables through binary analyses.
Such information includes network protocols [44,12,7,47,28,32], input formats [27,29,13], variable types, and data structure definitions [30,25,39].
They can support network sniffing, exploit generation, VM introspection, and forensic analysis.Existing binary analysis can be roughly classified into static, dynamic, and symbolic (concolic) analysis.
Static analysis analyzes an executable directly without executing it; dynamic analysis acquires analysis results by executing the subject binary; symbolic (concolic) analysis is able to generate inputs to explore different paths of a binary.
These different styles of analyses have their respective strengths and limitations.
Static analysis has difficulty in handling packed and obfuscated binaries.
Memory disambiguation and indirect jump/call target analysis are known to be very challenging for static analysis.Dynamic binary analysis is based on executing the binary on a set of inputs.
It is widely used in analyzing malware.
However, dynamic analysis is incomplete by nature.
The quality of analysis results heavily relies on coverage of the test inputs.
Moreover, modern malware [16,26,19] has become highly sophisticated, posing many new challenges for binary analysis: (1) For a zeroday binary malware, we typically do not have any knowledge about it, especially the nature of its input, making traditional execution-based analysis [15,50,4,43,49] difficult; (2) Malware binaries are increasingly equipped with anti-analysis logic [37,5,17,18,35] and hence may refuse to run even if given valid input; (3) Malware binaries may contain multi-staged, condition-guarded, and environment-specific malicious payloads, making it difficult to reveal all payloads, even if one manages to execute them.Symbolic [8] and concolic analysis [38,20,40,10] has seen much progress in recent years.
Some handle binary programs [40,10,33,6] and can explore various paths in a binary.
However, difficulties exist when scaling them to complex, real-world binaries, as they operate by modeling individual instructions as symbolic constraints and using SMT/SAT solvers to resolve the generated constraints.
Despite recent impressive progress, SMT/SAT remains expensive.
While symbolic and concrete executions can be performed simultaneously so that concrete execution may help when symbolic analysis encounters difficulties, the user needs to provide concrete inputs, called seed inputs, and the quality of seed inputs is critical to the execution paths that can be explored.
With no or little knowledge about malware input, creating such seed inputs is difficult.
Moreover, many existing techniques cannot handle obfuscated or self-modifying binaries.In this paper, we propose a new, practical execution engine called X-Force.
The core enabling technique behind X-Force is forced execution which, as its name suggests, forces an arbitrary binary to execute along different paths without any input or environment setup.
More specifically, X-Force monitors the execution of a binary through dynamic binary instrumentation, systematically forcing a small set of instructions that may affect the execution path (e.g., predicates and jump table ac-cesses) to have specific values, regardless of their computed values, and supplying random values when inputs are needed.
As such, the concrete program state of the binary can be systematically explored.
For instance, a packed/obfuscated malware can be forced to unpack/deobfuscate itself by setting the branch outcomes of selfprotection checks, which terminate execution in the presence of debugger or virtual machine.
X-Force is able to tolerate invalid memory accesses by performing ondemand memory allocations.
Furthermore, by exploring the reachable state of a binary, X-Force is able to explore different aspects or stages of the binary behavior.
For example, we can expose malware's data exfiltration operations, without the presence of the real data asset being targeted.Compared to manual inspection and static analysis, X-Force is more accurate as many difficulties for static analysis, such as handling indirect jumps/calls and obfuscated/packed code, can be substantially mitigated by the concrete execution of X-Force.
Compared to symbolic/concolic analysis, X-Force trades precision slightly for practicality and extensibility.
Note that X-Force may explore infeasible paths as it forces predicate outcomes; whereas symbolic analysis attempts to respect path feasibility through constraint solving 1 .
The essence of XForce will be discussed later in Section 6.
Furthermore, executions in X-Force are all concrete.
Without the need for modeling and solving constraints, X-Force is more likely to scale to large programs and long executions.
The concrete execution of X-Force makes it suitable for analyzing packed and obfuscated binaries.
It also makes it easy to port existing dynamic analysis to X-Force to leverage the large number of executions, which will mitigate the incompleteness of dynamic analyses.Our main contributions are summarized as follows:• We propose X-Force, a system that can force a binary to execute requiring no inputs or any environment setup.
• We develop a crash-free execution model that could detect and recover from exceptions properly.
We have also developed various execution path exploration algorithms.
• We have overcome a large number of technical challenges in making the technique work on real world binaries including packed and obfuscated malware binaries.
• We have developed three applications of X-Force.
The first is to construct CFG and CG of stripped binaries, featuring high quality indirect jump and call target identification; the second is to study hidden behavior of advanced malwares; the third one is to apply X-Force in reverse engineering variable types and data structure definitions of executables.
Our results show that X-Force substantially advances the state-of-the-arts.
Consider the snippet in Figure 1.
It shows a hidden malicious payload that hijacks the name resolution for a specific domain (line 14), which varies according to the current date (in function genName()).
In particular, it receives some integer input at line 2.
If the input satisfies condition C at line 3, a DNSentry object will be allocated.
In lines 5-8, if the input has the CODE RED bit set, it populates the object by calling genName() and stores the input and the generated name as a (key, value) pair into a hash This example illustrates some of the challenges faced by both static and symbolic/concolic analysis.
In static analysis, it is difficult to determine that the object retrieved at line 12 is the one inserted at line 7 because the abstract domain has to precisely model the behavior of the hash table put/get operations and the condition that y==x, which requires context-sensitive and path-sensitive analysis, and disambiguating the memory bucket [i] and bucket [i+4] in table get() and table put().
The approximations made by many static analysis techniques often determine the object at line 12 could be the one put at line 7 or 10.
Performed solely at the binary level, such an analysis is actually much more challenging than described here.
In symbolic/concolic analysis, one can model the input at line 2 as a symbolic variable such that, by solving the symbolic constraints corresponding to path conditions, the hidden payload might be reached.
However, the dictionary read at line 21 will be difficult to handle if the file is unavailable.
Modeling the file as symbolic often causes scalability issues if it has nontrivial format and size, because the generated symbolic constraints are often complex and the search space for acquiring syntactically correct inputs may be extremely large.In X-Force, the binary is first executed as usual by providing random inputs.
Note that X-Force does not need to know the input format a priori as its exception recovery mechanism prevents any crashes/exceptions.
In other words, the supply of random input values is merely to allow the execution to proceed, not to drive the execution along different paths.
In the first normal run, assume that the false branches of the conditionals at lines 3, 5 and 13 are taken, yielding an uninteresting execu- Figure 1: Motivating Example.
tion.
X-Force will then try to force-set branch outcomes at a small number (say, 1 or 2) of predicates by performing systematic search.
Assume that the branch outcome at line 5 is force-set to "true".
The malicious payload will be forced to activate.
Note that pointer p has a null value at line 6, which will normally crash the execution at line 22.
X-Force tolerates such invalid accesses by allocating memory on demand, right before line 22.
Also, even if the dictionary file at line 21 is absent, X-Force will force it through by supplying random input values.
As such, some random integer and domain are inserted into the table (line 7) and retrieved later (line 12).
Eventually, the random domain name is redirected at line 14, exposing the DNS hijacking operation.
We argue that the domain name itself is not important as long as the hidden hijacking logic is exposed.
This section explains the basics of how a single forced execution proceeds.
The goal is to have a non-crashable execution.
For readability, we focus on explaining how to detect and recover from memory errors in this subsection, and then gradually introduce the other aspects of forced execution such as path exploration and handling libraries and threads in later sections.
Language.
Due to the complexity of the x86 instruction set, we introduce a simple low-level language that models x86 binary executables to facilitate discussion.
We only model a subset that is sufficient to illustrate the key ideas.
Fig. 2 shows the syntax.
Memory reads and writes are modeled by R(r a ) and W(r a , r v ) with r a holding the address and r v the value.
Since it is a low-level language, we do not model conditional or loop statements, but rather guarded jumps; malloc() and free() represent heap allocation and deallocation.
Function invocations and returns are modeled by call() and ret.
In our language, stack/heap memory addresses are modeled as a range of integers and a special value 0 to denote the null pointer value.
Program counters (or instruction addresses) are explicitly modeled by the PC set.
Observe that each instruction is labeled with a PC, denoting its instruction address.
Direct jumps/calls are parameterized with explicit PC values whereas indirect jumps/calls are parameterized with a register.
In X-Force, we ensure that an execution is not crash- Program P ::= s Stmt s ::= s 1 ; s 2 | nop | r := 񮽙 e | r := 񮽙 R(r a ) | W 񮽙 (r a , r v ) | jmp 񮽙 (񮽙 1 ) | if (r 񮽙 ) then jmp(񮽙 1 ) | jmp 񮽙 (r) | r := malloc 񮽙 (r s ) | free 񮽙 (r) | call 񮽙 (񮽙 1 ) | call 񮽙 (r) | ret 񮽙 Operator op ::= + | − | * | / | > | < | ...(global address t) L-INIT if (isAddr( * t)) SM(t) = {t}; r := R(r a ) SR("r") → nil; L-READ if(SM(r a )) SR("r") → SM(r a ); W(r a , r v ) if (SM(r a )) SM(r a ) = SM(r a ) − {r a } L-WRITE SM(r a ) → nil; if (SR("r v ")) SR("r v ") = SR("r v ") ∪ {r a }; SM(r a ) → SR("r v "); r := a SR("r") → {} L-ADDR r := c SR("r") → nil L-CONST /*!
isAddr(c)*/ r := r 1 + / − r 2 if (!
(isAddr(r 1 )&&isAddr(r 2 ))) L-LINEAR SR("r") → nil if (isAddr(r 1 )) SR("r") → SR("r 1 "); if (isAddr(r 2 )) SR("r") → SR("r 2 "); r := r 1 * /... r 2 SR("r") → nil L-NON-LNR free(r) t = r; L-FREE while (accessible(t))if (SM(t)) SM(t) = SM(t) − {t}; t + +; 1.
The occurrence"r" denotes the symbolic name of register r, the occurrence of r denotes the value stored in r. 2.
Operator "=" means set update, "→" means pointer update.able by allocating memory on-demand.
However, when we replace a pointer pointing to an invalid address a with the allocated memory, we need to update all the other pointer variables that have the same address value or a value denoting an offset from the address.
We achieve this through the linear set tracing semantics, which is also the basic semantics for forced executions 2 .
Its goal is to identify the set of variables (i.e. memory locations and registers at the binary level), whose values have linear correlations.
In this paper, we say two variables are linearly correlated if the value of one variable is computed from the value of the other variable by adding or subtracting a value.
Note that it is simpler than the traditional definition of linear correlation, which also allows a scaling multiplier.
It is however sufficient in this work as the goal of linear set tracing is to identify correlated pointer variables, which are induced by address offsettings that are exclusively additions and subtractions.The semantics is presented in Table 1.
The corresponding definitions are presented in Fig 3.
Particularly, linear set LSet denotes a set of addresses such that the values stored in these addresses are linearly correlated.
Mapping SR maps a register to the reference of a LSet.
Intuitively, one could interpret that it maps a register to a pointer pointing to a set of addresses such that the values stored in the register and those addresses are linearly correlated.
Two registers map to the same reference (of a LSet) implies that the values of the two registers are also linearly correlated.
Similarly, mapping SM maps an address to the reference of a LSet such that the values in the address and all the addresses in LSet are linearly corre- for (i = r to r + r 1 − 1) M-ALLOC accessible(i) = true free(r) t = r; M-FREE while (accessible(t)) accessible(t) = false t + +; r := R(r a ) if (!
accessible(r a )) M-READ recovery(r a ); W(r a , r v ) if (!
accessible(r a )) M-WRITE recovery(r a );lated.
The essence of linear set tracing is to maintain the SR and SM mappings for all registers and addresses that have been accessed so that at any execution point, we can query the set of linearly correlated variables of any given variable.Before execution, the SM mapping of all global variables that have an address value is set to the address itself, meaning the variable is only linearly correlated with itself initially (rule L-INIT).
Function isAddr(v) determines if a value v could be an address.
X-Force monitors all memory allocations and the image loading process.
Thus, given a value, X-Force treats it as a pointer if it falls into static, heap, or stack memory regions.
Note that we do not need to be sure that the value is indeed an address.
Over-approximations only cause some additional linear set tracing.
For a memory read operation, the SR mapping of the destination register points to the SM set of the value in the address register if the SM set exists, which implies the value is an address, otherwise it is set to nil (rule L-READ).
Note that in the rule we use "r" to denote the symbolic name of r and r a to denote the value stored in r a .
SR("r") → SM(r a ) means that we set SR("r") to point to the SM(r a ) set.
For a memory write, we first eliminate the destination address from its linear set.
Then, the address is added to the linear set of the value register as the address essentially denotes a new linearly correlated variable.
Finally, the SM mapping of the address is updated (rule L-WRITE).
Note that operation "=" means set update, which is different from "→" meaning set reference update.
For a simple address assignment, the SR set is set to pointing to an empty linear set, which is different from a nil value (rule L-ADDR).
The empty set is essentially an LSet object that could be pointed to by multiple registers to denote their linear correlation.
A nil value cannot serve this purpose.
For a linear operator, the SR mapping of the destination register is set to pointing to the SR mapping of the register holding an address value (rule L-LINEAR).
Intuitively, this is because we are only interested in the linear correlation between address values (for the purpose of memory error recovery).
For heap de-allocation, we have to remove each de-allocated address from its linear set (rule L-FREE).
Table 2 presents the set of memory error detection and recovery rules.
The relevant definitions are in Fig. 3.
An auxiliary mapping accessible() is introduced to denote if an address has been allocated and hence accessible.
The M-ALLOC and M-FREE rules are standard.
Upon reading or writing an un-accessible address, XForce calls function recovery () with the register holding the invalid address to perform recovery.
In the function, we first acquire the values of all the variables in the linear set and identify the minimal and maximum values (lines 1-6).
Note that the values may be different (through address offsetting operations).
We then allocate a piece of memory on demand according to the range of the values and a pre-defined default memory block size.
Then in lines 9-12, the variables in the linear set are updated according to their offsets in the block.
We want to point out that on-demand allocation may not allocate enough space.
However, such insufficiency will be detected when out-of-bound accesses occur and further ondemand re-allocation will be performed.
We also want to point out that a correctly developed program would first write to an address before it reads.
As such, the ondemand allocation is often triggered by the first write to an invalid buffer such that the value could be correctly written and later read.
In other words, we do not need to recover values in the on-demand allocated buffers.In our real implementation, we also update all the registers that are linearly correlated, which can be determined by identifying the registers pointing to the same set.
Furthermore, the rules only describe how we ensure heap memory safety whereas X-Force protects critical stack addresses such as return addresses and parameters, which we will discuss later.Example.
Fig. 4 presents part of a sample execution with the linear set tracing and memory safety semantics.
The program is from the motivation example ( Fig. 1).
In the execution, the else branch of line 3 is taken but the true branch of line 5 is forced.
As such, pointer p has a null value when it is passed to function genName(), which would cause an exception at line 22.
In Fig. 4, we focus on the executions of lines 6, 22 and 7.
The second column shows the binary code (in our simplified language).
The third column shows the corresponding linear set computation and memory exception detection and recovery.
Initially, SM(&p = 0x8004c0) is set to pointing to the set {0x8004c0} according to rule L-INIT.
At binary code line 2, SR(eax) is set to pointing to the set of SM(&p).
At line 3, since the value is further copied to a stack address 0xce0080, eax, &p and the stack address all point to the same linear set containing &p and the stack address.
Intuitively, these are the three variables that are linearly correlated.
At lines 9 and 10, edi further points to the same linear set.
At line 12, when the program tries to access the address denoted by edi = 4, the memory safety component detects the exception and performs on demand allocation.
According to the linear set, &p and the stack address 0xce0080 are set to the newly allocated address 0xd34780 while edi is updated to 0xd34784 according to its offset.
While it is not presented in the table, the program further initializes the newly allocated data structure.
As a result, when pointer p is later passed to table put(), it points to a valid data structure.
2 Output:Ex -the set of executions (each denoted by a sequence of switched predicates) achieving a certain given goal (e.g. maximum coverage)Definition switches: the set of switched predicates in a forced execution, denoted by a sequence of integers.
For example, 1 · 3 · 5 means that the 1st, 3rd, and 5th predicates are switched Execute the program and switch branch outcomes according to switches, update fitness functionF 7: preds ← the sequence of executed predicates 8: t ← the last integer in switches 9: preds ← remove the first t elements in preds 10: for each (p, b) ∈ preds do 11: In the early stage of the project, we tried a much simpler strategy that is to terminate a forced execution when an exception is observed.
However, we observed that since we do not provide any real inputs, exceptions are very common.
Furthermore, simply skipping instructions that cause exceptions did not work either because that would have cascading effects on program state corruption.
Finally, a crash-proof execution model as proposed turned out to be the most effective one.WL : P (Int) -aif eval(F , p,X-Force also automatically recovers from other exceptions such as division-by-zero, by skipping those instructions that cause exceptions.
Details are omitted.
One important functionality of X-Force is the capability of exploring different execution paths of a given binary to expose its behavior and acquire complete analysis results.
In this subsection, we explain the path exploration algorithm and strategies.To simplify discussion, we first assume a binary only performs control transfer through simple predicates (i.e. predicates with constant control transfer targets).
We will introduce how to extend the algorithms in realistic settings, e.g., supporting exploration of indirect jumps in later section.Algorithm 1 describes a general path exploration algorithm, which generates a pool of forced executions that are supposed to meet our goal specified by a configurable fitness function.
It is a work list algorithm.
The work list stores a list of (forced) executions that may be further explored by switching more predicates.
Each execution is denoted by a sequence of integer numbers that specify the executed predicate instances to switch.
Note that X-Force only force-sets the branch outcome of a small set of predicate instances.
It lets the other predicate instances run as usual.
Initially (line 1), the work list is a singleton set with a nil sequence, representing an execution without switching any predicate.
Note that the work list is not empty initially.
At the end of a forced execution, we update the fitness function that indicates the remaining space to explore (line 6), e.g., coverage.
Then in lines 7-16, we try to determine if it would be of interest to further switch more predicate instances.
Lines 7-9 compute the sequence of predicate instances eligible for switching.
Note that it cannot be a predicate before the last switched predicate specified in switches as switching such a predicate may change the control flow such that the specification in switches becomes invalid.
In lines 10-16, for each eligible predicate and its current branch outcome, we query the fitness function to determine if we should further switch it to generate a new forced execution.
If so, we add it to the work list and update the fitness function.
Note that in each new forced execution, we essentially switch one more predicate.Different Fitness Functions.
The search space of all possible paths is usually prohibitively large for realworld binaries.
Different applications may define different fitness functions to control the scope they want to explore.
In the following, we introduce three fitness functions that we use.
Other more complex functions can be similarly developed.
• Linear Search.
In certain applications, such as constructing control flow graphs and dynamic type reverse engineering (Section 5), the goal may be just to cover each instruction.
The fitness function F could be defined as a mapping covered :Predicate × boolean 񮽙 → boolean that determines if a branch of a predicate has been covered.
The evaluation in the box in line 11 of Algorithm 1 is hence defined as !
covered(p, ¬b), which means we will switch the predicate if the other branch has not been covered.
Once we decide to switch an additional predicate, the fitness function is updated to reflect the new coverage (line 12).
The number of executions needed is hence O(n) with n the number instructions in the binary.
• Quadratic Search.
In applications such as identifying indirect call targets, which is a very important challenge in binary analysis, simply covering all instructions may not be sufficient, we may need to cover paths that may lead to indirect calls or generate different indirect call targets.
We hence define F as a set icalls to keep the set of the indirect call sites and potential indirect call targets that have been discovered by all the explored paths.
The evaluation in line 11 is hence to test if cardinality of icall grows with the currently explored path.
If so, the execution is considered important and all eligible unique predicates (not instances) in the execution are further explored.
The complexity is O(n 2 ) with n the number of instructions.
X-Force can also limit the quadratic search within a function.
• Exponential Search.
If we simply set the evaluation in the line 12 to true, the algorithm performs exponential search because it will explore each possible combination.
In practice, we cannot afford such search.
However, X-Force provides the capability for the user to limit such exponential search within a sub-range of the binary.
Taint Analysis to Reduce Search Space.
An observation is that we do not have to force-set predicates in lowlevel utility methods, because their branch outcomes are usually not affected by any input.
Hence in X-Force, we use taint analysis to track if a predicate is related to program input.
X-Force will only force branch outcomes of those tainted predicates.
Since this is a standard technique, we omit its details.
In this section, we discuss how we address some prominent challenges in handling real world executables.
Jump Tables.
In our previous discussion, we assume control transfer is only through simple predicates.
In reality, jump tables allow a jump instruction to have more than two branches.
Jump tables are widely used.
They are usually generated from switch statements in the source code level.
In X-Force, we leverage existing jump table reverse engineering techniques [21] to recover the jump table for each indirect jump.
Our exploration algorithm then tries to explore all possible targets in the table.Handling Loops and Recursions.
Since X-Force may corrupt variables, if a loop bound or loop index is corrupted, an (incorrect) infinite loop may result.
Similarly, if X-Force forces the predicate that guards the termination of some recursive function call, infinite recursion may result.
To handle infinite loops, X-Force leverages taint analysis to determine if a loop bound or loop index is computed from input.
If so, it resets the loop bound/index value to a pre-defined constant.
To handle infinite recursion, X-Force constantly monitors the call stack.
If the stack becomes too deep, X-Force further checks if there are cyclic call paths within the call stack.
If cyclic paths are detected, X-Force skips calling into that function by simulating a "ret" instruction.
Protecting Stack Memory.
Our early discussion on memory safety focused on protecting heap memory.
However, it is equally important to protect stack memory.
Particularly, the return address of a function invocation and the stack frame base address of the caller are stored on stack upon the invocation.
They are restored when the callee returns.
Since X-Force may corrupt variable values that affect stack accesses, such critical data could be undesirably over-written.
We hence need to protect stack memory as well.
However, we cannot simply prevent any stack write beyond the current frame.
The strategy of X-Force is to prevent any stack writes that originate in the current stack-frame to go beyond the current frame.
Specifically, when a stack write attempts to over-write the return address, the write is skipped.
Furthermore, the instruction is flagged.
Any later instances of the instruction that access a stack address beyond the current stack-frame are also skipped.
The flags are cleared when the callee returns.
Handling Library Function Calls.
The default strategy of X-Force is to avoid switching predicates inside library calls as our interest falls in user code.
X-Force handles the following library functions in some special ways.
• • Memory manipulation functions.
To support memory safety, X-Force wraps memory allocation and de-allocation.
For memory copy functions such as memcpy() and strcpy(), the X-Force wrappers first determine the validity of the copy operation, e.g., the source and target address ranges must have been allocated, must not overlap with any critical stack addresses.
If necessary, on-demand allocation is performed before calling the real function.
This eliminates the need of memory safety monitoring, linear set tracing, and memory error recovery inside these functions, which could be quite heavyweight due to the special structure of these functions.
For example, memcpy() copies individual addresses one by one and these addresses are linearly correlated as they are computed through pointer manipulation, leading to very large linear sets.For statically linked executables, X-Force relies on IDAPro to recognize library functions in a pre-processing step.
IDA leverages a large signature dictionary to recognize library functions with very good accuracy.
For functions that are not recognized by IDA, X-Force executes them as user code.Handling Threads.
Some programs spawn additional threads during their execution.
It is difficult for X-Force to model multiple threads into a single execution since the order of their execution is nondeterministic.
If we simply skip the thread creation library functions such as CreateThread() and beginthread(), the functions in the thread could not be covered.
To solve this problem, we adopt a simple yet effective approach of serializing the execution of threads.
The calls to thread creation library functions are replaced with direct function calls to the starting functions of threads, which avoid creating multiple threads and guarantees code coverage at the same time.
Note that as a result, X-Force is incapable of analyzing behavior that is sensitive to schedules.
We will leave it to our future work.
X-Force is implemented in PIN.
It supports WIN32 executables.
In this section, we use three application case studies to demonstrate the power of X-Force.
Construction of CFG and CG is a basic but highly challenging task for binary analysis, especially the identification of indirect call targets.
In the first case study, we apply X-Force to construct CFGs and CGs for stripped SPECINT 2000 binaries.
We also evaluate the performance of X-Force in this study.
To construct CFGs and CGs, we use X-Force to explore execution paths and record all the instructions, control flow edges, and call edges, including indirect jump and indirect call edges.
The exploration algorithm is a combination of linear search and quadratic search (Section 3.2).
Quadratic search is limited to functions that contain indirect calls or encounter values that look like function pointers.
We compare X-Force results with four other approaches: (1) IDA-Pro; (2) Execute all the test cases provided in SPEC and union the CFGs and CGs observed for each program (i.e., dynamic analysis); (3) Static CG construction using LLVM on SPEC source code (i.e., static analysis) 3 .
(4) Dynamic CFG construction using a symbolic execution system S2E [10].
We could not compare with CodeSurfer-X86 [2], which can also generate CFG/CG for executables based on static analysis, because it is not available through commercial or academic license.Part of the results is presented in Table 3.
Columns 2-4 present the instructions that are covered by the different approaches.
Particularly, the second column shows the number of instructions recognized by IDA.
The third column shows those that are executed by concrete input runs.
Columns 5-8 show the indirect call edges recognized by the different approaches 4 .
The last five columns show internal data of X-Force.
From the coverage data, we observe that X-Force could cover a lot more instructions than dynamic analysis except 253.
perlbmk.
Note that the dynamic analysis results are acquired using all the test, training and reference inputs in SPEC, which are supposed to provide good coverage.
Table 4 presents more detailed coverage comparison with dynamic analysis.
Observe that X-Force covers all the instructions that are covered by natural runs for all benchmarks except 253.
perlbmk, which we will explain later.
X-Force could cover most of the instructions identified by IDA except 252.
eon and 253.
perlbmk.
We have manually inspected the differences between the IDA and X-Force coverage.
For most programs except 253.
perlbmk, the differences are caused by part of the code in those binaries being unreachable.
In other words, they are dead code that cannot be executed by any input.
Since IDA simply scans the code body to construct CFG and CG, it reports all instructions it could find including the unreachable ones.
Indirect call edge identification is very challenging in binary analysis as a call site may have multiple call targets depending on execution states, which are usually difficult to cover or abstract.
Some of them are dependent on states related to multiple procedures.
Note that there does not exist an oracle that can provide the ground truth for the set of real indirect call edges.
From the results, we could observe that LLVM's indirect call identification algorithm generates a large number of edges, much more than X-Force.
However, we confirm that most of them are bogus because the LLVM algorithm simply relies on method signatures to identify possible targets and hence is too conservative.
X-Force could recognize a lot more indirect call edges than dynamic analysis.
The detailed comparison in Table 5 shows that the X-Force results cover all the dynamic results and have many more edges, except 253.
perlbmk.
We have manually inspected a random set of the selected edges that are reported by X-Force but not the dynamic analysis and confirmed that they are feasible.
From the results in Table 3, IDA can hardly resolve any indirect call edges.
We also use S2E to analyze the six SPECINT 2000 programs that contain indirect calls.
The four programs other than 252.
eon and 255.
vortex read input from stdin, so we use the s2ecmd utility tool provided by S2E to write 64 bytes to stdout and pipe the symbolic bytes into these programs.
We run each program in S2E and use the ExecutionTracer plugin to record the execution trace.
We use the IDA scripts provided by S2E to extract information of basic blocks and functions from the binaries, and then use the coverage tool provided by S2E to calculate the result.The result is shown in Table 6.
The columns show the following metrics from left to right: (1) coverage of basic blocks; (2) coverage of basic blocks when excluding the basic blocks in those functions that are not executed; (3) coverage of functions; (4) percentage of fully-covered functions; (5) the number of different paths that S2E explored.
Observe that the coverage is much lower than XForce in general.
176.
gcc, 253.
perlbmk and 254.
gap are parsers/compilers.
They have poor coverage on S2E because they get stuck in the parsing loops/automatas, whose termination conditions are dependent on the symbolic input.
Regarding 255.
vortex, S2E fails to solve the constraints when an indirect jump uses the symbolic variable as the index of jump table.
As a result, S2E fails to identify most of the indirect call edges due to the failure of creating different objects.
In 252.
eon, S2E fails to solve the constraints of the input file format, which must contain a specific string as header.
The program throws exception and terminates quickly, which leads to poor coverage.253.
perlbmk is a difficult case for X-Force.
It parses perl source code to generate syntax trees.
The indirect call targets are stored in the nodes of syntax trees.
However, since the syntax tree construction is driven by finite automata, path coverage does not seem to be able to cover enough states in the automata to generate enough syntax trees of various forms.
A few other benchmarks such as 176.
gcc and 254.
gap also leverage automata based parsers, however their indirect call targets are not so closely-coupled with the state of the automata and hence X-Force can still get good coverage.
We will leave it to our future work to address this problem.The last five columns show some statistics of X-Force.
The run time and the number of explorations are largely linear regarding the number of instructions except for a small number of functions on which quadratic search is performed.
Some take a long time (e.g., close to 50 hours for 176.
gcc) due to their complexity.
The average number of exceptions is the number of exceptions encountered and recovered from in each execution (e.g. memory exceptions, division by zero).
The numbers are smaller than we expected given that we execute these programs without any inputs and switch branch outcomes.
It shows that our exception recovery could effectively prevent cascading exceptions.
The linear set sizes are manageable.
The last column shows the average number of switched predicates versus the average number of predicate instances in total in an execution.
It shows that X-Force may violate path feasibility only in a very small part of execution.
The performance overhead of X-Force compared to the vanilla PIN is 473 times on average.
It is measured by comparing the number of instructions that could be executed by X-Force and the vanilla PIN within the same amount of time.
One common approach to understanding the behavior of an unknown malware sample is by looking at the library calls it makes.
This could be done by static, dynamic or symbolic analysis; however, they all have limitations.
Static analysis could not obtain the parameters of library calls that are dynamically computed and is infeasible when the sample is packed or obfuscated.
Traditional dynamic analysis can obtain parameters and is immune to packing and obfuscation, however, it could only explore some of the execution paths depending on the input and the environment.
Unfortunately, the input is usually unknown for malware.
Symbolic analysis, while being able to construct input according to path conditions, has difficulty in handling complex or packed binaries.
X-Force overcomes these problems as traditional dynamic analysis could be built upon X-Force to explore various execution paths without providing any inputs or the environment.
In this case study, we demonstrate the use of a library call analysis system we built on top of X-Force to analyze real-world malware samples.When we implement library call analysis on top of X-Force, we slightly adjust X-Force to make it suitable for handling malware: (1) We enable the concrete execution of most library functions including output functions because many packers use output functions (e.g. RtlDecompressBuffer()) to unpack code.
We continue to skip some library calls such as Sleep() and DeleteFile(); (2) We intercept a few functions that allocate memory and change page attributes, such as VirtualAlloc() and VirtualProtect().
This is for tracking the memory areas of code and data which keep changing at runtime due to self-modifying and dynamically generated code.Given a malware sample, we use X-Force to explore its paths.
We use the linear search algorithm (Section 3.2) as it provides a good balance between efficiency and coverage.
During each execution, we record a trace of function calls.
For library calls, we also record the parameter values.
The trace is then transformed into an interprocedural flow graph that has control transfer instructions, including jumps and calls, as its nodes, and control-flow/call edges as its edges.
The parameters of library calls are also annotated on the graph.
The graphs generated in multiple executions are unioned to produce the final graph.
We then manually inspect the final graphs to understand malware behavior.
We evaluate our system on 10 real-world malware samples which are either wild-captured virus/trojan or APT samples described in [9].
Since our analysis focuses on library calls, we choose the number of identified library functions and the total number of their call sites as the evaluation metric 5 .
We also compare our results with IDA-Pro and the native run.
In IDA, library functions are identified from the import table; the call sites are identified by scanning the disassemblies.
In the native run, we execute the malware without any arguments and record the library calls using a PIN tool.The results are shown in Table 7.
We can see that for packed or obfuscated samples such as dg003.exe, Win32/PWSteal.
F, APT1.DAIRY, and APT1.BOUNCER, IDA gets fewer library functions and call sites compared to X-Force.
For other samples that are not packed or obfuscated, since the executables could be properly disassembled, the metrics obtained in IDA and X-Force are very close.
However, even in such cases, static analysis is insufficient to understand the malicious behavior because it does not show the values of the library function parameters.
Compared to the native run method, X-Force can identify more library functions and call sites.Next, we present detailed analysis for two representative samples.
Dg003.exe.
This is a typical APT malware sample that features multi-staged, condition-guarded and environment-specific payload.
In the first stage, the malware extracts a DLL which it carries as its resource, packs the DLL in memory using a proprietary algorithm and writes the packed DLL to the disk.
In the second stage, the packed DLL is loaded, unpacks itself in memory and executes the main payload.There is a previous report [26] in which the analysts used both static and dynamic analyses to analyze this sample.
To perform static analysis using IDA Pro, they manually extract and unpack the DLL.
This requires reverse engineering the unpacking algorithm, which could be both time consuming and difficult.
Our system avoids such trouble by concretely executing the unpacking routine which performs the unpacking for us.
Compared with their dynamic analysis, it takes X-Force about 5 hours to finish 800 executions to explore all paths in both the first and second stages of the malware.
After that, the traces are transformed into a flow graph containing 378 functions.
Our system is able to discover a set of malicious behaviors that are NOT mentioned in the previous report.
As shown in Fig. 5, each highlighted function call in the graph corresponds to a previously unrevealed malicious behavior.
Each behavior is identified using the library calls made in the corresponding function.
For example, as shown in Fig. 6, the library calls and the parameters in the function at 0x10009b50 show that it recursively enumerates and deletes files and directories starting from the root directory, which indicates its behavior is to delete all files on the disk.In Fig. 5 we can see that the common dominator of all these function calls (highlighted in red color) determines if the value of eax register is larger than 0x196.
With taint analysis in X-Force, we find that the value of the eax register is related to an input which is a buffer in a previous recv library function call.
This indicates it represents the command ID sent by the C&C server, which leads to the execution of different malicious behaviors.
Hence, we suspect that the previous analysts missed some behaviors because the C&C server only sent part of the possible commands at the time they ran the malware.
We also find that the buffer in the recv function call is translated to the command ID using a private decryption algorithm, so it would be infeasible for symbolic analysis to solve the constraints and construct a valid input.
We also want to point out that at the time we perform the analysis, the C&C server of this malware is already inactive; we would not be able to discover these malicious behaviors, had we not used X-Force.
Win32/PWSteal.
F. Before trying X-Force on this sample, we first try static analysis using IDA-Pro.
Surprisingly, this sample does not import any suspicious library function; not even a function that could perform I/O (e.g. read/write file, registry or network socket).
The LoadLibrary() and GetProcAddress() functions are not imported either, which means the common approach of dynamically loading libraries is not used.
The strings in the executable do not contain any DLL name or library function name either.
This indicates the sample is equipped with advanced API obfuscation technique to thwart static analysis.Since static analysis is infeasible, we submit the sample to the Anubis malware analysis platform for dynamic analysis.
The result shows the malware does read some registry entries and files, however, none of them seems malicious.
Hence, we feed the sample to our system in hopes of revealing its real intent.
X-Force achieves full coverage after exploring 30 paths and generates a graph with 15 functions.
By traversing the graph, we find that this malware aims at stealing the password that is stored by IE and Firefox in the victim's machine.
It enumerates the registry entry that stores the encrypted auto-complete password for IE and calls library functions such as CryptUnprotectData() to decrypt the stored password.
This is very similar to the attack mentioned in [1].
Regarding Firefox, it first gets the user name from profiles.ini under the Firefox application data directory, and then steals the password that is stored in the signons*.
txt under the directory of the user name.
The password is then uploaded to a remote FTP server using the file name [Computer Name].
[IP Address].
txt.
Clearly, this sample finds the entry addresses of these library functions at runtime using some obfuscation techniques.
X-Force allows us to identify the malicious behavior without spending unnecessary time on reverse-engineering the API obfuscation.Moreover, the flow graph also reveals the reason why Anubis missed the malicious behavior: the malware performs environment checks to make sure the targets exist before trying to attack.
For example, in the function where the malware steals password from IE, it will try to open the registry entry that contains the auto-complete password; if such entry does not exist or is empty, the malware will cease its operation and return from that function.
Also, before it tries to steal password stored by Firefox, it will first try querying the installation directory of Firefox from registry to make sure the target program exists in the system.
Such "prerequisites" are unlikely to be fulfilled in automated analysis systems as they are unpredictable.
However, by force-executing through different paths, X-Force is able to get through these checks to reveal the real intent of the malware.
Researchers have proposed techniques to reverse engineer variable and data structure types for stripped binaries [30,39,25].
The reverse engineered types can be used in forensic analysis and vulnerability detection.
There are two common approaches.
REWARDS [30] and HOWARD [39] leverage dynamic analysis.
They can produce highly precise results but incompleteness is a prominent limitation -they cannot reverse engineer types of variables if such variables are not covered by executions.
TIE [25] leverages static analysis and abstract interpretation such that it provides good coverage.
However, it is challenging to apply the technique to large and complex binaries due to the cost of analysis.
One advantage of X-Force is that the forced executions are essentially concrete executions such that existing dynamic analyses could be easily ported to X-Force to benefit from the good coverage.
Therefore in the third case study, we port the implementation of REWARDS to X-Force.
Given a binary executable and a few test inputs, REWARDS executes it while monitoring dataflow during execution.
When execution reaches system or library calls, the types of the parameters of these calls are known.
Such execution points are called type sinks.
Through the dynamic dataflow during execution, such types could be propagated to variables that (transitively) contributed to the parameters in the past and to variables that are (transitively) dependent on these parameters.Consider the example in Fig. 7.
Assume func1 is executed.
After line 1, the type of arg1 and var1 get resolved using the interface of strlen().
So TYPE 2 is char *, and TYPE 4 is unsigned int.
In line 2, arg2 is compared with var1, implying they have the same type.
Thus TYPE 3 gets resolved as unsigned int.
Later when line 4 gets executed, it returns TYPE 1 which is resolved as char since arg1 is of char *.
Porting REWARDS to X-Force requires very little modification of either the REWARDS or the X-Force systems as they only interface through the (forced) concrete executions.
Facilitated by X-Force, REWARDS is able to run legacy binaries and COTS binaries without any inputs.
In our experiment, we run the new system on the 12 SPEC2000 INT binaries.
They are a lot more complex than the Linux core-util programs used in the original paper [30].
To acquire the ground truth, we compile the programs with the option of generating debugging symbols as PDB files, and use DIA SDK to read the type information from the PDB files.We evaluate the system in terms of both coverage and accuracy.
Coverage means the percentage of variables in the program that have been executed by our system.
Accuracy is the percentage of the covered variables whose types are correctly reverse engineered.
From Fig. 8, the average coverage is around 84%.
The coverage heavily relies on the code coverage of X-Force.
Recall that these programs have non-trivial portion of unreachable code.
The variables in those code regions cannot be reverse engineered by our system.
From Fig.9, the average accuracy is about 90%.
The majority of type inference failures is caused by the fact that the variables are not related to any type sink.We also compare with IDA and the original RE-WARDS.
IDA has a static type inference algorithm that works in a similar fashion.
When we run the original REWARDS, we have two configurations: (1) use the test input only (1 input per program) and (2) use both the test and the reference inputs (around 4 inputs per program).
From Fig. 8 and Fig. 9, our system has much better accuracy than IDA (90% vs. 55% on average) and better coverage than the original REWARDS, i.e., 84% vs. 57% (test+reference) or 34% (test input only).
The better accuracy than IDA is achieved by the more precise modeling of behavior difficult for static analysis, such as heap accesses and indirect calls and jumps.
X-Force is intended to be a practical solution for analyzing unknown (malicious) binaries without requiring any source code or inputs.
Hence, X-Force trades soundness and completeness for practicality.
It is unsound as it could explore infeasible paths.
It is incomplete as it cannot afford exploring all paths.
Figure 10 shows how X-Force compares with static and dynamic analysis: The "Reachable Program State" oval denotes all states that can be reached through possible program inputsthe ideal coverage for program analysis.
Static analyses often make conservative approximations such that they yield over-approximate coverage.
Dynamic analyses analyze a number of real executions and hence yield underapproximate results.
X-Force explores a larger set of executions than dynamic analyses.
Since X-Force makes unsound approximations, its results may be invalid (i.e., outside the ideal oval).
Furthermore, it is incomplete as its results may not cover the ideal ones.However, we argue that X-Force is still of importance in practice: (1) There are many security applications whose analysis results are not so sensitive to paths, such as the three studies in this paper.
As such, path infeasibility may not affect the results much.
However, having concrete states in path exploration is still critical in these applications such that an execution based approach like X-Force is suitable; (2) Only a very small percentage of predicates are switched (Section 5.1) in X-Force.
Execution is allowed to proceed naturally in most predicates, respecting path feasibility.
According to our observations, most of the predicates that got switched in linear search are those checking if the program has been provided the needed parameters, if files are properly opened, and if certain environmental configurations are correctly set-up; (3) In X-Force, taint analysis is used to identify predicates that are affected by inputs and only such predicates are eligible for switching.Moreover, X-Force allows users to (1) rapidly explore the behaviors of any (unknown) binary as it simply executes the binary (without solving constraints); (2) handle binaries in a much broader spectrum (e.g., large, packed, or obfuscated binaries); (3) easily port or develop dynamic analysis on X-Force as the executions in X-Force are no different from regular concrete executions.Future Work.
We believe this paper is just an initial step in developing a unique type of program analysis different from the traditional static, dynamic, and symbolic analysis.
We have a number of tasks in our future research agenda.
• While X-Force simply forces the branch outcomes of a few predicates without considering their feasibility, we suspect that there is a chance in practice the forced paths are indeed feasible in many cases.Note that the likelihood of infeasibility is not high if the forced predicates are not closely correlated.
We plan to use a symbolic analysis engine that models the path conditions along the forced paths to observe how often they are infeasible.
• We develop 3 exploration algorithms in this paper.
From the evaluation data on the SPECINT2000 programs, there are cases (e.g., perlbmk) that the current exploration algorithms cannot handle well.
More effective algorithms, for example, based on modeling functions behaviors and caching previous exploration choices, will be developed.
• We currently handle multi-threaded programs by serializing their executions.
In the future, we will explore forcing real concurrent executions.
We envision this has to be integrated with flipping schedule decisions, which is a standard technique in exploring concurrent execution state.
How to handle the enlarged state space and the potentially introduced infeasible thread schedules will be the new challenges.
• The current system is implemented as a tool on top of PIN.
To build a tool that makes use of XForce, for example REWARDS, the implementation of the additional tool is currently mixed with XForce.
They are compiled together to a single PINtool.
We aim to make X-Force transparent to dynamic analysis developers by providing an PIN-like interface.
Ideally, existing PIN-tools can be easily ported to X-Force to benefit from the large number of executions provided by the X-Force engine.
• We also plan to port the core X-Force engine to other platforms such as mobile and HTML5 platforms.
Researchers proposed to force branch outcomes for patching software failures in [51].
Hardware support was proposed to facilitate path forcing in [31].
Both require source code and concrete program inputs.
Branch outcomes are forced to explore paths of binary programs in [48] to construct control flow graphs.
The technique does not model any heap behavior.
Moreover, it skips all library calls.
Similar techniques are proposed to expose hidden behavior in Android apps [22,45].
These techniques randomly determine each branch's outcome, posing the challenge of excessive infeasible paths.
Forced execution was also proposed to identify kernel-level rootkits [46].
It completely disregards branch outcomes during execution and performs simple depth-first search.
None of these techniques performs exception recovery and instead simply terminates executions when exceptions arise.
Constraint solving was used in exploring execution paths to expose malware behavior in [33,6].
They require concrete inputs to begin with and then mutate such inputs to explore different paths.
X-Force is related to static binary analysis [21,3,25,42,41], dynamic binary analysis [30,39,24] and symbolic binary analysis [10,40].
We have discussed their differences from X-Force in Section 6, which are also supported by our empirical results in Section 5.
X-Force is also related to failure oblivious computing [36] and on-the-fly exception recovery [34], which are used for failure tolerance and debugging and require source code.
We develop a novel binary analysis engine X-Force, which forces a binary to execute without any inputs or the needed environment.
It systematically forces the branch outcomes at a small number of predicates to explore different paths.
It can recover from exceptions by allocating memory on-demand and fixing correlated pointers accordingly.
Our experiments on three security applications show that X-Force has similar precision as dynamic analysis but much better coverage due to the capability of exploring many paths with any inputs.
We would like to thank the anonymous reviewers for their insightful comments.
This work was motivated in part by the earlier research of Dr. Vinod Yegneswaran on brute-force malware execution and analysis.
His influence and support is gratefully acknowledged.
This research has been supported, in part, by DARPA under Contract 12011593 and by a gift from Cisco Systems.
Any opinions, findings, and conclusions in this paper are those of the authors only and do not necessarily reflect the views of the sponsors.
