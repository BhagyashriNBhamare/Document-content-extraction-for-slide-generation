This paper describes the design, implementation, and evaluation of a system for performing verifiable outsourced computation.
It has long been known that (1) this problem can be solved in theory using probabilistically checkable proofs (PCPs) coupled with modern cryptographic tools, and (2) these solutions have wholly impractical performance, according to the conventional (and well-founded) wisdom.
Our goal is to challenge (2), with a built system that implements an argument system based on PCPs.
We describe a general-purpose system that builds on work of Ishai et al. (CCC '07) and incorporates new theoretical work to improve performance by 20 orders of magnitude.
The system is (arguably) practical in some cases, suggesting that, as a tool for building secure systems, PCPs are not a lost cause.
This paper describes progress toward the goal of practical and general-purpose verifiable outsourced computation.
This broad area has seen renewed interest, owing to cloud computing (a computationally limited device offloads processing to the cloud but does not assume the cloud's correctness [36]), volunteer computing (some 30 projects on the BOINC [1] software platform use volunteers' spare cycles, but some "volunteers" return wrong answers [6]), peer-topeer computing, and high assurance computing (in the latter cases, remote peers or components are likely to be untrusted).
Research has resulted in practical solutions, which depend on various conditions particular to the operating regime (e.g., they require trusted hardware [27,62], or assume independent failures and replicate [6,25,42,52,56]), and theoretical solutions, which tend toward specialized algorithms for the computation at hand.
There is, however, a strand of theory that is unconditional and general-purpose.
Unfortunately, this theory has so far been totally impractical, which leads to the question: can we incorporate this powerful and enticing theory into a built system?Our focus is on argument systems, which are interactive protocols with two actors, a prover and a verifier.
Assuming that the prover is computationally bounded, such protocols can convince the verifier that the prover executed a given computation correctly and that the prover holds a proof to that effect.
This theory dates to the 1980s [24,39], and starting with Kilian [48,49] efficient argument systems [45] have been based on probabilistically checkable proofs (PCPs)-which themselves are astonishing.
Informally, the central result is that a verifier can-with a suitably encoded proof and with a negligible chance of regarding a wrong answer as correct-check an answer's correctness by probing a constant number of locations in a proof [8,9].
Unfortunately, PCPs and hence arguments are wildly impractical: traditional PCPs are too expensive to instantiate at the prover or query from the verifier.
While state-of-the-art PCP schemes are asymptotically efficient [15][16][17]30], the constants on their running times are large, and they seem too intricate to be implemented easily.This brings us to our animating question: can we construct an argument system for outsourced computation that has practical performance and is simple?
Specifically, we require, first, that the verifier do less work than if it executed the outsourced computation locally.
Some of the theoretical schemes meet this requirement asymptotically, but we want to meet it for reasonable computation sizes.
Second, we require that the prover not do much more work than it would without verification.
Last, we strongly favor protocols that are simple for both verifier and prover: a simple protocol is easier to implement, check for correctness, and optimize for performance.Our starting point in answering the above question is a powerful and elegant insight of Ishai, Kushilevitz, and Ostrovsky [45]: some PCPs, though hopelessly impractical to materialize explicitly, are linear functions for which evaluation at any given point is inexpensive.
Ishai et al. use such linear PCPs to build argument systems, via a novel linear commitment protocol: the prover commits to a linear function (the PCP), after which the verifier can inexpensively "query the proof" by asking the prover to evaluate the linear function at a verifier-chosen point.
Since linear PCPs are simple (as PCPs go), the resulting argument systems are too.
Nonetheless, they are still not practical.
For example, for m × m matrix multiplication, the verifier would have to do 10 9 · m 6 work-a factor of 10 9 · m 3 more than executing the computation locally.
This overhead comes from the encoding of the computation, a large number of cryptographic commitments, and substantial setup costs.This paper describes a built system, called PEPPER, that goes a long way toward making argument systems practical.
PEPPER refines the protocol of Ishai et al. to shrink program encoding (via a concise representation that generalizes arithmetic circuits), reduce the cost of commitment (via a stronger and streamlined commitment primitive), and amortize the verifier's costs (via batching).
We prove the soundness of these refinements.
The result is a simple constant-round protocol that gains a factor of over 10 17 (no joke) versus a naive implementation of [45].
Much (but not all) of PEPPER's remaining costs stem from the computational complexity of the prover's work.
This problem is shared by all PCP schemes, so a protocol in which the prover's total work is not much greater than the cost of executing the computation would be a major improvement.
In fact, a key innovation in PEPPER is to meet this goal for computations of real interest (matrix multiplication, polynomial evaluation, etc.) by tailoring the PCP encoding to reduce overhead.
The result is roughly three more orders of magnitude saved, for a total of 20.
We note that the tailoring is systematic, and we believe that it will lend itself to automation (see §3.6, §4.2, and §6).
The tailored protocols for our examples are close to practical: at problem sizes of m = 500 variables, for instance, the verifier benefits from outsourcing degree-2 polynomial evaluation when working over 25, 000 batched computations, and the verification takes minutes.
And with two heuristic optimizations, we can get these numbers down to a batch size of 118 and sub-second verification time.Of course, PEPPER is not yet ready for production deployment, but its remaining obstacles, while significant, do not seem insurmountable.
Modular exponentiation is a bottleneck, but this primitive occurs in many cryptographic protocols and will benefit as researchers optimize it.
Another obstacle is the computation encoding.
One might guess that arithmetic circuits are too inefficient to be useful, but we discovered that we could tailor circuits until they imposed no overhead above a C++ program ( §3.3).
Of course, in the real world, people perform computations besides selfcontained numerical functions.
However, our work suggests that it will be possible to build a compiler that transforms a broader class of computations to efficient tailored protocols.
Also, we had to start somewhere, to move PCPs from theory to technology.
Our hope now is that PEPPER opens the door to an exciting area of systems research.To explain this paper's organization, we note that there is a contrast between the "what" and the "why" of PEP-PER.
The "what" is surprisingly simple: the verifier submits vectors to the prover and expects dot products in return.
The "why", however, requires some notation and time to explain, as PEPPER builds on the theory of PCPs, which is subtle and counter-intuitive.
For this reason, Section 2 is a fairly technical overview of the underlying machinery.
While this background is necessary for the precise specification of our protocols, the trusting reader can probably skip to Section 3, where we discuss the innovations and details of PEPPER.
We experimentally evaluate PEPPER in Section 4.
We survey related work in Section 5.
Here, we just note that while there has been much theoretical work on unconditional, general-purpose verifiable computation, these works are not yet practical, and there have been few concerted efforts to make them so.We originally proposed this research program in a position paper [64].
However, that paper gave only a high-level sketch that we have since heavily modified; it did not give a concrete protocol, proofs, an implementation, or an evaluation.
The specific contributions of this paper are (1) a built PCP-based system that is near practical; (2) a series of refinements, with proofs, to the protocol of Ishai et al. [45] that save 20 orders of magnitude; (3) tailored PCP protocols that result in a prover whose overhead is only a constant factor; and (4) the implementation and experimental evaluation of our system, PEPPER.
Consider a verifier V that wishes to be convinced that a given problem instance X (e.g., a given 3-CNF logical formula) is in an NP language L (e.g., the set of satisfiable 3-CNF formulas).
By definition of NP, if X is in L, then there is some witness z that V can check in polynomial time to be convinced of X's membership in L. Remarkably, there also exists a proof π that convinces V of X's membership but only needs to be inspected in a constant number of placesyet if X is not in L, then for any purported proof, the probability that V is wrongly convinced of X's membership can be arbitrarily close to zero.
This remarkable statement is the rough content of the PCP theorem [8,9], and the rest of this subsection describes the machinery from this theorem that is relevant to PEPPER.Following [8], we take L to be Boolean circuit satisfiability: the question of whether the input wires of a given Boolean circuit C can be set to make C evaluate to 1.
1 It suffices to consider this problem because L is NP-complete; any other problem in NP can be reduced to it.
Of course, a satisfying assignment z-a setting of all wires in C such that C evaluates to 1-constitutes an (obvious) proof that C is satisfiable: V could check z against every gate in C. Note that this check requires inspecting all of z.
In contrast, the PCP theorem yields a V that makes only a constant number of queries to an oracle π and satisfies:• Completeness.
If C is satisfiable, then there exists a linear function π (called a proof oracle) such that, after V queries π, Pr{V accepts C as satisfiable} = 1, where the probability is over V's random choices.
• Soundness.
If C is not satisfiable, then Pr{V accepts C as satisfiable} < for all purported proof functions˜πfunctions˜ functions˜π.
Here, is a constant that can be driven arbitrarily low.Note that we are requiring a correct proof π to be a linear function over finite fields.
2 Following [45], we call such proofs linear PCPs.
By linear function, we mean that π(q 1 + q 2 ) = π(q 1 ) + π(q 2 ).
A linear function π : F n → F b can be regarded as a b × n matrix M, where π(q) = M · q; in the case b = 1, π returns a dot product with the input.
Below we describe a linear PCP that is used by [8] as a building block; this linear PCP is also presented in [16,45], and we borrow some of our notation from these three sources.To motivate this linear PCP-that is, the encoding of π, and how V interacts with it-recall that we must avoid V's having to check a purported assignment, z, against every gate, as that would be equivalent to the polynomial-time check of membership.
Instead, V will construct a polynomial P(Z) that represents C, and π will be carefully constructed to allow evaluation of this polynomial.
For each of the s gates, V creates a variable Z i ∈ {0, 1} that represents the output of gate i. V also creates a set of arithmetic constraints, as follows.
If gate i is the AND of Z j and Z k , then V adds the constraintZ i − Z j · Z k = 0; if gate i is the NOT of Z j , then V adds the constraint 1 − (Z i + Z j ) = 0;if gate i is an input gate for the jth input, V adds the constraint Z i −in j = 0; and finally, for the last gate, representing the output of the circuit, we also have Z s − 1 = 0.
V then obtains the polynomial P(Z) by combining all of the constraints:P(Z) = i v i · Q i (Z), where Z = (Z 1 , . . . , Z s ), each Q i (Z)is given by a constraint (e.g., Z i − Z j Z k ), and V chooses each v i uniformly and independently at random from a finite field F.
The reason for the randomness is given immediately below.Notice that P(z) detects whether z is a satisfying assignment: (1) if z is a satisfying assignment to the circuit, then it also satisfies all of the {Q i (Z)}, yielding P(z) = 0; but (2) if z is not a satisfying assignment to the circuit, then the randomness of the {v i } makes P(z) unlikely to equal 0 (as illustrated in the next paragraph).
Thus, the proof oracle π must encode a purported assignment z in such a way that V can quickly evaluate P(z) by making a few queries to π.
To explain the encoding, let x, y represent the inner (dot) product between two vectors x and y, and x⊗y represent the outer product x · y T (that is, all pairs of components from the two vectors).
Observe that V can writeP(Z) = γ 2 , Z ⊗ Z + γ 1 , Z + γ 0 .
The {γ 0 , γ 1 , γ 2 } are determined by the {Q i (Z)} and the choice of {v i }, with γ 2 ∈ F s 2 , γ 1 ∈ F s , and γ 0 ∈ F.
The reason that V can write P(Z) this way is that all of the {Q i (Z)} are degree-2 functions.Given this representation of P(Z), V can compute P(z) by asking for γ 2 , z ⊗ z and γ 1 , z.
This motivates the form of a correct proof, π.
We write π = (z, z ⊗ z), by which we mean π = (π (1) , π (2) ), where π (1) (·) = ·, z and π (2) (·) = ·, z ⊗ z.
At this point, we have our first set of queries: V checks whether π (2) (γ 2 ) + π (1) (γ 1 ) + γ 0 = 0.
If z is a satisfying assignment and π is correctly computed, the check passes.
Just as important, if z is not a satisfying assignment-which is always the case if C is not satisfiable-then V is not likely to be convinced.
To see this, first assume that V is given a syntactically correct but non-satisfying π ; that is, π = (z , z ⊗ z ), where z is a non-satisfying assignment.
The test above-that is, checking whether π (2) (γ 2 )+π (1) (γ 1 )+γ 0 = 0-checks whether P(z ) = 0.
However, there must be at least one i for which Q i (z ) is not 0, which means that the test passes if and onlyif v i · Q i (z ) = − i =i v i · Q i (z ).
But the {v i } are conceptually chosen after z , so the probability of this event is upper-bounded by 1/|F|.
The above test is called the circuit test, and it has so far been based on an assumption: that if π is invalid, it encodes some (non-satisfying) assignment.
In other words, we have been assuming that π (1) and π (2) are linear functions that are consistent with each other.
But of course a malevolently constructed oracle might not adhere to this requirement.
To relax the assumption, we need two other checks.
First, with linearity tests [12,21], V makes three queries to π (1) and three to π (2) , and checks the responses.
If the checks pass, V develops a reasonable confidence that π (1) and π (2) are linear functions, which is another way of saying that π (1) (·) is returning ·, z for some z and that π (2) (·) is returning ·, u for some u ∈ F s 2 .
In the second test, the quadratic correction test, V makes four queries total and checks their responses; if the checks pass, V develops reasonable confidence that these two linear functions have the required relationship, meaning that u = z ⊗ z.
Once these tests have passed, the circuit test above is valid.In all, V makes = 14 queries.
The details of the queries and tests, and a formal statement of their completeness and soundness, are in [8] and Appendix A. Here, we just informally state that if C is satisfiable, then V will always be convinced by π, and if C is not satisfiable, then V's probability of passing the tests is upper bounded by a constant κ (for any˜πany˜ any˜π).
If the scheme is repeated ρ times, for µ = · ρ total queries, the error probability becomes = κ ρ .
The theory above says that V can be convinced of a circuit's satisfiability by making only a constant number of queries to the proof oracle π.
But how does V query π?
Clearly, π cannot be available for direct inspection by V because it is tremendous: written out, π would be a list of the function's values at every point in an exponentially-sized domain.
The idea of an efficient argument (due to Kilian [48,49]) is to use a PCP in an interactive protocol: a separate prover P computes a PCP and responds to V's queries.
However, P must be forced to "act like" a fixed proof-P must be prevented from adjusting answers to later queries based on earlier answers.
Kilian's observation is that this can be done with cryptographic commitments.In the sections ahead, we build on an elegant scheme by Ishai, Kushilevitz, and Ostrovsky [45].
They (1) observe that π is a linear function (determined by z and z ⊗ z) and (2) develop a commitment to a linear function primitive.
In this primitive, P commits to a linear function by preevaluating the function at a point chosen by V and hidden from P; then, V submits one query, and the response must be consistent with the pre-evaluation.
Roughly speaking, V can now proceed as if P's responses are given by an oracle π.
(More accurately, V can proceed as if P's responses are given by a set of non-colluding oracles, one per PCP query.)
In more detail, V obtains a commitment from P by homomorphically encrypting a random vector r and asking P to compute Enc(π(r)); P can do this without seeing r, by the linearity of π and the homomorphic properties of the encryption function (we do not need or assume fully homomorphic encryption [37]).
V can then apply the decryption function to recover π(r).
To submit a PCP query q and obtain π(q), V asks P for π(q) and π(r + αq), for α randomly chosen from F. V then requires that π(r + αq) = π(r)+απ(q), or else V rejects π(q).
By running parallel instances of the commitment protocol (one for each time that V wants to inspect π), Ishai et al. convert any PCP protocol that uses linear functions into an argument system [24,39].
Arguments are defined as follows; we borrow some of our notation and phrasing from [45], and we restrict the definition to Boolean circuits.
An argument (P, V) with soundness error comprises two probabilistic polynomial time entities, P and V, that take a Boolean circuit C as input and meet two properties:• Completeness.
If C is satisfiable and P has access to the satisfying assignment z, then the interaction of V(C) and P(C, z) always makes V(C) accept C's satisfiability.
• Soundness.
If C is not satisfiable, then for every efficient malicious P * , the probability (over V's random choices) that the interaction of V(C) and P * (C) makes V(C) accept C as satisfiable is < .
Problem statement and threat model.
We wish to implement the following protocol.
A computer that we control, the verifier, sends a program Ψ and an input x to a remote computer, the prover.
The prover returns a result y, and the verifier issues queries over a small number of interaction rounds to the prover, whose responses either establish for the verifier that Ψ was run correctly and that y is the result of running Ψ on x, or else cause the verifier to reject.
If y is incorrect, the verifier should reject with high probability.
We do not provide the converse; that is, rejection in our context implies only that the prover has not given a correct proof, not that y = Ψ(x).
We require the following: (1) this protocol should be cheaper for the verifier, in computational resources, than computing y locally, and (2) the guarantee that the protocol provides to the verifier should make no assumptions about the prover, other than standard cryptographic ones.
That is, the prover can subvert the protocol, can choose not to follow it, can return wrong answers, etc.
In principle, the problem above can be solved with PCPs.
In practice, a number of severe obstacles arise, as can be seen by the following attempt to use PCPs.
There is a Boolean circuit C (which depends on Ψ, x, and y) such that C is satisfiable (that is, evaluates to 1) if and only if y is the correct output of Ψ run on x. Assume that the prover and verifier can efficiently derive C, given Ψ, x, and y. Then, the prover can issue a PCP (as in §2.1) of C's satisfiability.
At that point, if y is the correct output, the verifier can efficiently inspect the PCP to be convinced both that Ψ was executed correctly and that Ψ produces y when run on x; if y is not the correct output, the probability that the verifier accepts C as satisfiable is upper-bounded by a negligible constantfor any purported PCP.
This approach sounds promising; unfortunately, it is totally impractical:• The proof is too long.
It is much too large for the verifier to handle or for the prover to write out in full.
• The protocol is too complicated.
State-of-the-art PCP protocols [15][16][17]30] partially address the concern about proof length, but they are intricate to the point of making a bug-free implementation difficult.
Unfortunately, in this context, even small bugs can be security-critical.
Complexity also hinders optimization.
• The phrasing of the computation is too primitive.
Even if they have simple control flow, most general-purpose computations are far longer when expressed as Boolean circuits than in, say, C++.
• The preparatory work is too high for the verifier.
Deriving C and generating queries to the proof take at least as much work for the verifier as executing the computation.
• The prover's overhead is too high.
In the base PCP protocol ( §2.1), the prover's work is at least quadratic in the number of circuit wires.
While this overhead can be reduced to a polylogarithmic factor [15][16][17]30] (at the cost of intricacy, as noted above), we ideally want to limit the prover's overhead to a small constant factor.The first two obstacles above can be addressed by the argument system of Ishai et al. [45].
As discussed in Section 2.2, their approach addresses proof length (since the proof is not materialized) and proof complexity (since the proof is siminput to the computat ion: PCP verification checks ( linear commitment (Fig. 3, §3.4) π(q 1 )+π(q 2 )=π(q 3 ), π(q 7 )·π(q 8 )= π(q 9 )−π(q 10 ), ....?
?
π(t) = π(r) + α 1 ·π(q 1 ) +񮽙+ α µ ·π(q µ ) ? ))
FIGURE 1-High-level depiction of PEPPER, a PCP-based argument system for verified outsourced computation between a verifier and a prover.
We formalize this picture and prove its soundness in the appendices.ply a linear function to which the prover commits).
Proof length and proof complexity in exchange for commitment: this is a great trade!
However, it brings another obstacle:• The parallel commitments are too expensive.
Commitment requires cryptographic operations and hence multiprecision arithmetic, and the scheme of [45] invokes these operations far too much (by several orders of magnitude) to be practical.We now turn to our system, PEPPER, which builds on [45] and addresses all of the items above.
Figure 1 depicts PEPPER.
In the computation phase, V selects a computation 3 Ψ and different inputs x 1 , . . . , x β , and P returns outputs y 1 , . . . , y β .
These computations can happen iteratively or in a batch.
For each computation, P creates and stores a proof oracle π i establishing that Ψ(x i ) = y i .
In the proof commitment phase, V asks P to commit to all of its proofs.
Then V moves to the proof verification phase and issues PCP queries to P, whose responses must be consistent with the commitment phase.
Then, V runs the PCP verification checks on P's responses.
At that point, V outputs accept or reject for each computation.
An output of accept on y i means that y i = Ψ(x i ), with high probability.
The rest of this section describes how PEPPER overcomes the obstacles mentioned in Section 3.1.
PEPPER addresses proof length and complexity by inheriting from [45]; it shrinks the program encoding by using arithmetic circuits instead of Boolean circuits ( §3.3); it reduces commitment costs by requiring fewer commitments while offering better security ( §3.4); it uses batching to reduce V's costs ( §3.5); 3 Our implementation supports both preconfiguring computations and uploading binaries online for P to execute.
and it reduces P's overhead for some problems by reducing redundancy in the PCP encoding ( §3.6).
Figure 2 summarizes the costs under these refinements; we explain this figure over the course of the section.
To address the concern about the encoding of the computation, PEPPER uses arithmetic circuits, instead of Boolean circuits.
In a traditional arithmetic circuit, the input and output wires take values from a large set (e.g., a finite field or the integers).
This extension is a natural one, as the PCP machinery is already expressed as arithmetic versions of Boolean circuits.
However, we observe that the machinery also works with what we call concise gates, each of which encapsulates a function of many inputs (e.g., a dot product between two large vectors).
Note that a gate here does not represent a low-level hardware element but rather a modular piece of the computation that enters the verification algorithm as an algebraic constraint.
This simple refinement is critical to practicality.
First, it is vastly more compact to represent, say, multiplication with a single gate than as a Boolean circuit.
Beyond that, for certain computations (e.g., parallelizable numerical ones, such as matrix multiplication), the circuit model imposes no overhead; that is, the "circuit" is the same as a C++ program, so the only overhead comes from proving and verifying (as demonstrated in §4.3).
However, this model has known limitations; for example, comparison operations require relatively large circuits.
Future work is to address this problem, perhaps using tailored PCP encodings ( §3.6).
Details and an example.
Using arithmetic circuits requires only minor modifications to the PCP scheme described in Section 2.1.
Here, V produces a set of constraints (there, V op naive impl.
of [45] batching ( FIGURE 2-High-order costs under our refinements, cumulatively applied, compared to naive local execution and a naive implementation of [45], for our running example of m × m matrix multiplication.
Rows for V and P contain operation counts, except for the "op" field, which includes a parameter denoting the cost of the operations in that row.
Section 4.5 quantifies d, e, f , h and c; Section 4.6 quantifies β.The "PCP" rows include the consistency queries and checks ( Fig. 3, steps 4-6).
transforms a Boolean circuit into a set of constraints) over s variables from a finite field F (there, over binary variables) that can be satisfied if and only if y is the correct output of Ψ(x) (there, if and only if the circuit is satisfiable); V then combines those constraints to form a polynomial over s values in the field F (there, in the field GF(2)).
One way to look at this use of arithmetic circuits is that it represents the computation as a set of constraints directly.To illustrate the above, we use the example of m × m matrix multiplication.
We choose this example because it is both a good initial test (it is efficiently encodable as an arithmetic circuit) and a core primitive in many applications: image processing (e.g., filtering, rotation, scaling), signal processing (e.g., Kalman filtering), data mining, etc.In this example computation, let A, B, C be m × m matrices over a finite field F, with subscripts denoting entries, so A = (A 1,1 , . . . , A m,m ) ∈ F m 2 (for F sufficiently large we can represent negative numbers and integer arithmetic; see §4.1).
The verifier V sends A and B to the prover P, who returns C; V wants to check that A · B = C. Matrix C equals A · B if and only if the following constraints over variablesZ = (Z a 1,1 , . . . , Z a m,m , Z b 1,1 , . . . , Z b m,m ) ∈ F 2m 2 can be satisfied: Z a i,j − A i,j = 0, for i, j ∈ [m] ; Z b i,j − B i,j = 0, for i, j ∈ [m] ; C i,j − m k=1 Z a i,k · Z b k,j = 0, for i, j ∈ [m].
Note that the third type of constraint, which captures the dot product, is an example of a concise gate.
V is interested in whether the above constraints can be met for some setting Z = z (if so, the output of the computation is correct; if not, it is not).
Thus, V proceeds as in Section 2.1 and Appendix A. V constructs a polynomial P(Z) by combining the constraints:P(Z) = i,j v a i,j · (Z a i,j − A i,j ) + i,j v b i,j · (Z b i,j − B i,j ) + i,j v c i,j · (C i,j − m k=1 Z a i,k · Z b k,j ), where V chooses the variables {v} randomly from F.
As before, V regards the prover P as holding linear proof oracles π = (π (1) , π (2) ), where π (1) (·) = ·, z and π (2) (·) = ·, z ⊗ z for some z ∈ F 2m 2 .
And as before, V issues linearity test queries, quadratic correction test queries, and circuit test queries (the randomly chosen {v} feed into this latter test), repeating the tests ρ times.
We address V's cost of constructing P(Z) and issuing queries in Section 3.5.
The completeness and soundness of the above scheme follows from the completeness and soundness of the base protocol.
Thus, if C = A · B (more generally, if the claimed output y equals Ψ(x)), then V can be convinced of that fact; if the output is not correct, P has no more than = κ ρ probability of passing verification.Savings.
Moving from a Boolean to a non-concise arithmetic circuit saves, for a fixed m, an estimated four orders of magnitude in the number of circuit "wires" (the "wires" being {Z}) and thus eight orders of magnitude in the query size and the prover's work (which are quadratic in the number of wires).
The dot product gates decrease these quantities by another factor of m 2 (since they reduce the number of "wires" from m 3 + 2m 2 to 2m 2 ).
In Figure 2, the arithmetic circuit column reflects these two reductions, the first being reflected in the elimination of the 10 9 factor and the second in the move from the m 6 to the m 4 term.
The protocol assumes an additive homomorphic encryption scheme (Gen, Enc, Dec) over a finite field, F. Commit phase Input: Prover holds a vector w ∈ F n , which defines a linear function π : F n → F, where π(q) = w, q. 1.
Verifier does the following:• Generates public and secret keys (pk, sk) ← Gen(1 k ), where k is a security parameter.
• Generates vector r ∈R F n and encrypts r component-wise, so Enc(pk, r) = (Enc(pk, r1), . . . , Enc(pk, rn)).
• Sends Enc(pk, r) and pk to the prover.
2.
Using the homomorphism in the encryption scheme, the prover computes e ← Enc(pk, π(r)) without learning r.
The prover sends e to the verifier.
3.
The verifier computes s ← Dec(sk, e), retaining s and r. Input: the verifier holds q1, . . . , qµ ∈ F n and wants to obtain π(q1), . . . , π(qµ).
4.
The verifier picks µ secrets α1, . . . , αµ ∈R F and sends to the prover (q1, . . . , qµ, t), where t = r + α1q1 + · · · + αµqµ ∈ F n .
5.
The prover returns (a1, a2, . . . , aµ, b), where ai, b ∈ F.
If the prover behaved, then ai = π(qi) for all i ∈ [µ], and b = π(t).
?
= s + α1a1 + · · · + αµaµ.
If so, it outputs (a1, a2, . . . , aµ).
If not, it rejects, outputting ⊥.
FIGURE 3-PEPPER's commitment protocol.
V decommits queries q1, . . . , qµ for the price of a single commitment query, Enc(r).
This protocol strengthens one by Ishai et al. [45] and makes only minor changes to their notation and phrasing.
The intent is that the µ queries be the PCP queries and that n be the size of the proof encoding (s 2 + s, until §3.6).
The protocol assumes an additive homomorphic encryption scheme but can be modified to work with a multiplicative homomorphic scheme (such as ElGamal [32]); see Appendix E.
The commitment protocol in the base scheme of Ishai et al. [45] relies on an additive homomorphic encryption operation.
4 If executed once, this operation is reasonably efficient (hundreds of microseconds; see Section 4.5); however, the number of times that the base scheme invokes it is proportional to at least the square of the input size times µ, the number of PCP queries (roughly 1000).
For the example of m × m matrix multiplication with m = 1000, the base scheme would thus require at least (1000) 4 · 1000 · 100 µs: over 3000 years, and that's after the concise representation given by the previous refinement!
While we would be thrilled to eliminate homomorphic encryptions, we think that doing so is unlikely to work in this context.
Instead, in this section we modify the commitment protocol to perform three orders of magnitude fewer encryptions; Appendix B proves the soundness of this modification by reducing its security to the semantic security of the homomorphic encryption scheme.
Moreover, our reduction is more direct than in the base scheme, which translates into further cost reductions.Details.
In the base scheme [45], each PCP query by V (meaning each of the µ queries, as described in §2.1, §3.3, and Appendix A) requires V and P to run a separate instance of commitment.
Thus, to check one computation Ψ, V homomorphically encrypts µ ≈ 1000 (see Figure 2) vectors, and P works over all of these ciphertexts.
This factor of 1000 is an issue because the vectors are encrypted compo- Despite the optimizations so far, the verifier's work remains unacceptable.
First, V must materialize a set of constraints that represent the computation, yet writing these down is as much work as executing the computation.
Second, V must generate queries that are larger than the circuit.
For example, for m×m matrix multiplication ( §3.3), the commitment query has 4m 4 + 2m 2 components (matching the number of components in the vector representation of the proof), in contrast to the O(m 3 ) operations needed to execute the computation.
A similar obstacle holds for many of the PCP queries.
To amortize these costs, we modify the protocols to work over multiple computation instances and to verify computations in batch; we also rigorously justify these modifications.
Note that the modifications do not reduce V's checking work, only V's cost to issue queries; however, this is acceptable since checking is fast.Details.
We assume that the computation Ψ (or equivalently, C) is fixed; V and P will work over β instances of Ψ, with each instance having distinct input.
We refer to β as the batch size.
The prover P formulates β proof oracles (linear functions): π 1 , . . . , π β .
Note that the prover can stack these to create a linear function π : F s 2 +s → F β (one can visualize this as a matrix whose rows are π 1 , . . . , π β ).
To summarize the protocol, V now generates one set of commitment and PCP queries, and submits them to all of the oracles in the batch.
5 The prover now responds to queries q with π(q) ∈ F β , instead of with π(q) ∈ F. By way of comparison, the previous refinement ( §3.4) encrypts a single r for a set of queries q 1 , . . . , q µ to a proof π.
This one issues a single r and a single set of queries q 1 , . . . , q µ to multiple proofs π 1 , . . . , π β .
Appendix C details the protocol and proof-sketches its soundness.
We note that each of the β PCPs has the same soundness error () as if it were queried individually.
However, the errors for the β PCPs in a batch are correlated.Savings.
The most significant benefit is qualitative: without batching, V cannot gain from outsourcing, as the query costs are roughly the same as executing the computation.
The quantitative benefit of this refinement is, as depicted in Figure 2, to reduce the per-instance cost of commitment and PCP queries by a factor of β.
In some cases, we can address the obstacle of prover overhead by tailoring the PCP encoding.
The key observations are that (1) the basic protocol does not require a particular PCP encoding, as long as the encoding is a linear function, and (2) some circuits permit a much more streamlined en-5 Early in their paper Ishai et al. briefly mention such an approach, but they do not specify it.
Later in their paper [45, §6.1], in a more general context, they reuse PCP queries but not commitment queries.coding.
Specifically, we can tailor the prover's linear function so that it contains only terms that the prover had to compute anyway to return the result of the computation.
(In essence, we are reducing the redundancy in the PCP.)
The result for some computations, such as the examples given below, is protocols in which the prover's work is only a constant factor above simply executing the computation.Details and examples.
Under the linear PCPs in Sections 2.1 and 3.3, the prover computes z ⊗ z, where z is a satisfying assignment to the circuit (or constraint set).
However, for some computations V's circuit test ( §2.1) interrogates only a subset of z ⊗ z. Loosely speaking, P thus needs to compute only that subset to produce the proof oracle.Matrix multiplication.
As in Section 3.3, V again combines constraints that represent the computation, again picks random {v} to be coefficients of those constraints, again obtains a polynomial (which we will write as P (Z)), and again submits queries to the prover's oracle to get P (Z) evaluated and to test that the prover is holding an oracle of the correct form.
There are two modifications to the approach presented in Section 3.3.
First, in combining the constraints to construct P (Z), V does not include the degree-1constraints (meaning Z a i,j − A i,j = 0, etc.).
Thus, V obtains P (Z) = i,j v c i,j ·(C i,j − m k=1 Z a i,k ·Z b k,j ), which, using our notation from before, can be written P (Z) = γ 2 , Z ⊗ Z+γ 0 .
However, we will write P (Z) differently.
In Sections 2.1 and 3.3, the form above motivated the definition of π (2) (q) as q, z ⊗ z, for q ∈ F s 2 = F m 4 .
There, answering queries to π (2) required the prover to do work proportional to m 4 .
This is not only more than we would like to pay, given the O(m 3 ) naive algorithm, but also more than we have to pay: P (Z) includes only a subset of Z ⊗ Z. Specifically, observe that the degree-2 terms in P (Z) all have the form Z a i,k · Z b k,j .
The above suggests the following notation: for x, y ∈ F m 2 , x y consists of {x i,k · y k,j } for all i, j, k.
The cardinality of x y is m 3 .
Thus, letting Z a = (Z a 1,1 , . . . , Z a m,m ) andZ b = (Z b 1,1 , . . . , Z b m,m ), we write:P (Z) = γ 2 , Z a Z b + γ 0 ,where γ 2 ∈ F m 3 has the same non-zero components as γ 2 .
As in the base protocols, V wants to evaluate P (z) since P (z) is a bellwhether that indicates whether Z = z meets all constraints (here, z is the satisfying assignment that is purportedly encoded in the oracle π).
This brings us to the second modification: the PCP encoding is now π = π (c) (·) ·, z a z b , where z a = A and z b = B. To evaluate P (z), then, V asks for π (c) (γ 2 ), and V tests whether π (c) (γ 2 ) + γ 0 = 0.
This is our new circuit test; observe that it is O(m 3 ) for the prover to answer, and for V to formulate a query.
Like the base PCP protocols, this one requires two other types of tests.
The first is again a linearity test, to ensure that π (c) is (nearly) linear.
The second is again a consistency test, to ensure that π (c) indeed represents A B; this test is modified from the base scheme.
The details of the queries and tests, and proofs of their correctness, are in Appendix D. Finally, note that π (c) is a linear function, so it fits into the commit protocol ( §3.4).
Low-degree polynomial evaluation.
Suppose that we wish to evaluate a degree-D polynomial A over the variables X = {X 1 , X 2 , . . . , X m }.
If we let A k denote the vector of coefficients for the degree-k terms in A, then the evaluation of A at X = x can be writtenA(x) = A D , D i=1 x + · · · + A 2 , x ⊗ x + A 1 , x + A 0 .
For D = 2, we can represent the evaluation of A with a single degree-2 concise gate ( §3.3), where the "assignment" z is simply x itself; then, computing π (2) in the base PCP encoding requires computing x ⊗ x. Thus, if A is dense (meaning that it has Ω(m 2 ) monomials), the PCP encoding adds little prover overhead over computing A(x).
However, for D = 3, a naive application of the base protocol would include only degree-2 and degree-1 constraints, requiring prover work and query size of O(m 4 )-higher complexity than the O(m 3 ) computation.We can remove this overhead, if A is dense.
We modify the encoding so that the prover holds not only π (1) and π (2) (as in §2.1 and §3.3) but also π (3) : F m 3 → F, where π (3) (·) ·, z ⊗ z ⊗ z.
As above, the "assignment" z is simply x itself.
At this point, V must add several PCP queries to establish the (near) linearity of π (3) and the consistency of π (3) with (π (1) ,π (2) ).
For details of the queries and tests, see [58, §7.8], which describes a similar construction.
An analogous approach applies for D > 3 when D is odd; if D is even, there are "circuits" that add no overhead.Savings and discussion.
For matrix multiplication and degree-3 polynomial evaluation, the tailored PCP encoding reduces the prover's work and the query size from O(m 4 ) to O(m 3 ).
In our domain of interest, m is hundreds or thousands, so the savings in V's querying costs are two or three orders of magnitude.
The same factor is saved in the prover's costs.
In fact, if the relevant objects (the matrices or polynomials) are dense, the prover's work to create the PCP is the same complexity as executing the computation.There is a caveat, however.
Though the prover is linear, the constant is not ideal.
With matrix multiplication, for example, the prover's work is roughly (h + f · µ) · m 3 (as depicted in the prover's rows in Figure 2).
Meanwhile, there is an approach that costs the prover f · m 3 , namely Freivalds's randomized algorithm for verifying matrix multiplication [58, §7.1]: this algorithm requires O(m 2 ) time for the verifier and no overhead for the "prover".
More generally, we know that many computations admit specialpurpose verification protocols (see §5).
However, we believe that the work of this subsection is interesting because it refines the general-purpose PCP encodings and so might work for a broad class of other circuits.
We assess our work by answering three high-level questions, which correspond to the three goals for PEPPER that we stated in the introduction: (1) Is PEPPER simple enough to be easily implementable and optimizable?
(2) For what values of the batch size, β, and the input size does PEPPER's verifier gain from outsourcing?
(3) At these values, how much does PEPPER cost the prover?
We answer these questions in the context of three model computations: matrix multiplication, degree-2 polynomial evaluation, and degree-3 polynomial evaluation.
We chose these because they are self-contained test cases and core primitives in many applications.
The rest of this section describes our implementation, parameter choices, and further optimizations ( §4.1); then addresses the first question ( §4.2); and then answers the latter two with experiments and analysis ( §4.3- §4.7).
Implementation.
Although PEPPER requires that computations be expressed over a finite field F, we want to simulate computations over the integers (which requires simulating signed values and unbounded magnitudes).
To that end, we use the standard technique of working in F p (the integers modulo p), where p is a prime far larger than the actual input domain of the computation (e.g., see [22,70]).
In particular, we require the inputs (e.g., the matrix entries) to be 32-bit quantities and choose p to be either a 128-bit prime (for matrix multiplication and degree-2 polynomial evaluation) or a 192-bit prime (for degree-3 polynomial evaluation).
To implement field operations (as needed for verification and the computations themselves), PEPPER uses multiprecision arithmetic, as implemented by the GNU MP library.The core of the verifier and prover are implemented in C++.
The prover can run as a Web service, with its interfaces exposed via HTTP URLs: we run the C++ prover core and helper PHP utilities as persistent FastCGI processes [2] to which the Apache Web server delegates HTTP requests.Currently, our implementation parallelizes only the prover's commit phase, using OpenMP [3].
Parallelizing the verifier and the rest of the prover, and distributing the prover over multiple machines, are works in progress.We implemented both Paillier [59] and ElGamal [32] homomorphic encryption.
Because the ElGamal homomorphism is multiplicative, not additive, ElGamal requires minor modifications to the commitment protocol ( Figure 3); these are described in Appendix E. Where the algorithms call for random numbers, we use pseudorandom numbers, as generated by the ChaCha/8 stream cipher [19], specifically the amd64-xmm6 variant in its default configuration.Parameter choices.
PEPPER has three security parameters, which drive its total error of < + c (as given by Theorem B.1).
The first parameter is ρ, the number of PCP repetitions, which determines the PCP soundness error through the bound < κ ρ .
(Per Appendix A, κ = 7/9.)
We usually take ρ = 70, yielding < 2.3 · 10 −8 for the PCP error.
The second two parameters determine c , the commitment soundness error.
They are (a) |F|, the size of the field for the PCP and commitment machinery, and (b) the homomorphic encryption scheme's key size, which determines S , the error from encryption.
From Appendix B, we have c < 2 14 · (1/|F| + S ) 1/3 .
We take |F| ≈ 2 128 (we discussed field size above) and disregard S (we discuss key size below), yielding c < 2 −28 .
We performed all of our experiments with both encryption schemes but report results only from ElGamal because its performance is better by almost a factor of 10 (as others have also observed [35]).
By default, we take the prime modulus to be 704 bits, though we experiment with other sizes.
Of course, 704 bits is not industrial strength for usual cryptographic applications.
However, homomorphic encryptions ( Figure 3) are a bottleneck for PEPPER, so we make a considered choice to use this key size.
We believe that this choice is acceptable in our context, as the key need hold up only for one run of the protocol.
Our choice is based on the RSA factoring challenge.
6 Further optimizations: HABANERO.
We report results from both PEPPER, whose design we have treated rigorously, and HABANERO, a PEPPER variant that has two performance improvements.
First, under HABANERO, V precomputes and installs on P the commitment query, Enc(pk, r).
Under this modification, we use an industrialstrength key length-1280 bits-as we intend to amortize this offline step over a long time.
The soundness of this modification is counterintuitive; since we don't have space for a proof, we call it a heuristic.
For intuition, we note that this modification generalizes the way that a single r is used for the entire batch (Appendix C).
The second modification is to lower ρ from 70 to 1.
This allows a prover to cheat with probability as high as κ = 7/9.
However, if V and P interact repeatedly, a cheating prover would be detected.
PEPPER is built on PCP theory, which requires a lot of detail to explain.
At the same time, that theory results in a system whose mechanics are surprisingly simple.
The verifier doesn't do much more than generate and encrypt some pseudorandomness (Section 3.4), ask the prover to multiply some vectors with a matrix that it holds (Sections 3.3 and 3.6), and perform basic operations on the returned vectors (Appendices A and D).
Likewise, the prover doesn't need to do much more than determine the assignment z to 6 In Nov. 2005 a 640-bit key was factored using "approximately 30 2.2GHz-Opteron-CPU years" and in Dec. 2009 a 768-bit key was factored using "almost 2000 2.2GHz-Opteron-CPU years" [4].
"gates" (which it does anyway as a result of executing the algorithm), and return dot products.
Our sense of PEPPER's simplicity is buttressed by three things.
The first is its small code size.
Figure 4 tabulates the lines of code in our implementation (using [71]); the computation-independent modules require only 1727 lines.Second, applying PEPPER to new computations has proved easy, in part because the "circuit" model of the computation is not very far from an imperative statement of the computation in C++ ( §3.3).
In fact, once our software architecture was in place, a single graduate student was able to implement new computations in less than an hour per computation.
While this is obviously longer than it would take to code the computation with no verification, it is not a ridiculous amount of time.
Moreover, a compiler could perform this step automatically.Third, optimizing the implementation has so far been relatively easy.
For example, parallelizing the prover's commitment phase required only three compiler directives and one C++ statement; this simple change gives a substantial speedup on multi-core hardware (as quantified below).
In the sections ahead, we will determine the input sizes (which we loosely refer to as m) and batch sizes (β) at which V gains from outsourcing versus computing locally, and we will report CPU and network costs at these points.
We first run experiments to illuminate the prototype's performance ( §4.4); then use this performance plus microbenchmarks to calibrate our CPU cost model from Figure 2 ( §4.5); and then use the model to estimate break-even points under PEPPER, under HABANERO, and under the refinements that lead to them ( §4.6).
We treat network costs in §4.7.
Our baseline is local computation, which we assume uses multiprecision arithmetic.
While this assumption deprives the baseline of native operations and hence may be an overly optimistic comparison for PEPPER, we note that it is not totally ridiculous: multiprecision arithmetic is a standard approach for avoiding overflow and roundoff concerns when multiplying and adding many large numbers.To measure CPU usage at prover and verifier, we use FIGURE 5-Measured CPU cost of one instance (β = 1) of PEPPER, compared to local execution, circuit execution, and under different security parameters (k is the key size, and ρ is the number of PCP repetitions), for verifier (V) and prover (P).
For all computations, m = 100.
Much of PEPPER's overhead is fixed-cost, so it amortizes under batching (see Figure 6).
getrusage(); to measure network costs, we record the amount of application-level data (not including network headers) exchanged between the prover and the verifier.
We run our experiments on Utah Emulab's [72] d710s, which are 2.4 GHz 64-bit Intel Quad Core Xeon E5530 with 12 GB of memory; they run 64-bit Ubuntu 11.04 Linux.
Beyond illustrating PEPPER's overhead, the experiments in this section are intended to assess the cost of the circuit representation; to indicate how the security parameters ( §4.1) affect costs; and to illustrate how PEPPER's overhead can be mitigated by batching and parallelizing.In the first set of experiments, our baseline is the CPU cost of local execution for matrix multiplication and polynomial evaluation (degrees 2 and 3), with m = 100 in all cases.
We compare these baselines to executing the computation as a "circuit" but without verification.
We also measure PEPPER, configured with smaller (512 bits) and larger (1024 bits) key sizes than our target (704 bits); these keys are not suitable for PEPPER (owing to insecurity and inefficiency, respectively), but they give a sense of what PEPPER pays for its cryptographic guarantees.
Finally, we configure PEPPER to run with a single repetition (ρ = 1) and with multiple ones (ρ = 70).
We do not depict HABANERO here.We measure the CPU time at the verifier and prover consumed by PEPPER, end-to-end; this includes originating the queries, transferring them through the HTTP interface, handling responses, etc.
The prover runs with one thread.
For each configuration, we run 5 experiments, reporting average CPU time in seconds; standard deviations are within 5% of the means.
Figure 5 depicts the results.
As shown in the figure, the circuit representation imposes no overhead.
(Verification and proving are another matter-more on that soon.)
The effect of PEPPER's security parameters is as follows.
For matrix multiplication, PEPPER with 512-bit keys and 1024-bit keys costs, respectively, 1.7 times less and 1.9 times more than PEPPER with 704-bit keys (this holds for both prover and verifier); results for the other computations are similar.
Interestingly, ρ has far less effect, since the cryptographic commitment amortizes over the ρ repetitions ( §3.4).
Verification and proving clearly impose high overhead: for example, with degree-2 polynomial evaluation, the overhead over local computation is a factor of 3 · 10 4 for V and 10 4 for P. However, much of this cost is fixed and amortizes under batching ( §3.5), as we demonstrate next.Batching.
We run HABANERO with multiple instances.
We run 3 experiments for each computation, reporting mean CPU time (standard deviations are again within 5% of means).
The prover runs with four threads; we report its cost as the sum of the CPU times taken by all four cores.
Figure 6 depicts the results.
In these experiments, the verifier's cost is below the cost of local computation.
(We will investigate break-even points systematically in Section 4.6.)
The prover's cost is still high, but as we show next, parallelizing mitigates its latency.Parallelizing.
Here, we experiment with HABANERO, varying the number of threads (and hence cores) used.
In each of the prover's two phases, we measure the wall clock time taken by the phase.
We report the speedup with N cores as the ratio of total time taken (the sum of the two phases, over three trials) when one core is active to the time taken when N cores are active (again, over three trials).
Figure 2 equal to the cost of computing locally (also in Figure 2) and then (2) using the estimates of e, d, h, f , c (from Figure 7) to solve for β * .
Batching is required to make outsourcing profitable for V; without our refinements, the batch size is astronomical.
Solving for m * using more reasonable values of β also yields extremely large results.
Our refinements bring these numbers into the realm of the conceivable.
Both V and P can be parallelized to reduce latency; Section 4.4 describes the effect of parallelizing P. (Figure 2), for the field and key sizes in our experiments.For N = 2, the speedups are 1.99 in all three cases (the ideal is 2).
For N = 4, the prover's end-to-end latency reduces by a factor of 3.7 for matrix multiplication, a factor of 3.7 for degree-3 polynomial evaluation, and a factor of 3.1 for degree-2 polynomial evaluation (the ideal is 4).
We hypothesize that the latter computation sees smaller speedup because the computation is far smaller, so fixed setup costs are comparatively larger.
These results suggest that there is profit in distributing the prover over multiple machines.
We use a cost model for each of our computations; Figure 2 depicts the one for matrix multiplication.
7 When making predictions about HABANERO (versus PEPPER), we adjust the models to remove the cost of issuing commit queries and to set ρ = 1.
Note that, for simplicity, the models include field multiplication (f ) but not field addition.
Nevertheless, for the purposes of estimating break-even points, the models are pessimistic for PEPPER.
First, not counting additions underestimates the number of operations in the baseline computation.
Second, the models overestimate PEPPER's opera- tions.
Specifically, the models more than compensate for the omitted field additions (which PEPPER performs in equal number to field multiplications) by double-counting field multiplications (which are more expensive).
8 To estimate the parameters, we run a program that executes each operation at least 5000 times, using 704-bit and 1280-bit keys.
Figure 7 shows the means (standard deviations are within 5% of the means).
The two field sizes yield different parameter values because in the cryptographic operations, field entries appear in exponents.How well do our models predict the end-to-end empirical results ( §4.4)?
The prover's costs are at most 8% above the model's prediction.
The verifier's costs are at most 50% above what the model predicts.
However, much of this difference can be explained by the cost of I/O operations (to files and the network); subtracting this cost from the verifier's measured performance yields an estimate that is at most 10% above the model's prediction.
Finally, the base-line's empirical costs range between 20% and 100% more than the model's predictions.
We hypothesize that this divergence results from the model's omitting field additions (as discussed above) and from adverse caching behavior.
Given the model's rough accuracy, it can systematically (if roughly) make predictions about break-even points-that is, about PEPPER's regime of applicability.
We set V's costs in the (now parameterized) models equal to the cost of local computation, and solve for β * , the batch size at which V gains from outsourcing under PEPPER.
We do not account for the cost of serialization (this part of our implementation is unoptimized) so may slightly underestimate β * (by a factor nearly equal to the overhead of serialization).
Figure 8 depicts the estimated break-even points.
Under PEPPER (the column marked "new PCPs"), the numbers are sometimes reasonable for V.
The latency from P is, ahem, somewhat larger.
However, we would ask the reader to look leftward on this table to see what the numbers used to look like.
Under HABANERO, we do not need to appeal to relativism quite as much: V gains from outsourcing at reasonable batch sizes, and while P's latency is surely high, the work can be parallelized and distributed (see §4.4).
For example, if P used 128 cores, we would expect its latency to be on the order of hours or less for all but one of the rows.
The main network expense is from issuing queries (see Fig- ure 3).
To assess this cost, we estimate the sizes of the queries and responses, applying this simple model to the computations at the break-even points in Figure 8.
(For HA-BANERO, we count only PCP queries; commitment queries are assumed to be pre-installed.)
We separately validate by comparing to predictions with various experimental runs, finding that the model is within 3% of the measured traffic.
Figure 9 depicts the estimates, under HABANERO.
These costs are obviously significant.
However, compared to the prover's running time, the latency from network costs is not high.
Moreover, PEPPER's network overhead amortizes, as the query cost stays fixed with increasing β.
By contrast, some plausible baselines (for example, replicating the computation to multiple workers) have network overhead in proportion to β.
There has been a lot of work on verified computation, and the motivation of outsourcing to the cloud has given a new impetus to this area.
In this section we try to situate our work in this landscape.
We note that our work is concerned only with verifying computations, not hiding their content or input; thus, even though some of the works that we cite below achieve such hiding, our comparison will be silent about this property.
Also, we do not summarize work that adopts a different threat model, such as multiple provers [10,43] or assumptions about the difficulty of mimicking valid program counter values [67].
General-purpose approaches intended for practice.
Perhaps the most basic technique, replication [6,25,42,52,56], relies on assumptions about the independence of the workers, in contrast to our goal of unconditional verification.
Trusted computing [27,62] assumes that the hardware or a hypervisor works properly.
Some attestation work, though powerful, gives assurance that a remote application has desired properties but not that it is implemented correctly [26,53,63,66].
Other attestation work requires a trusted base [5,54].
Auditing and spot-checking [31,42,46,50,57] focus directly on the output, but unless the audit coverage is nearly perfect (which degenerates to executing the computation), a worker that alters a key bit (e.g., in an intermediate step) is unlikely to be detected, in contrast to the properties of PCPs ( §2.1).
Special-purpose approaches from theory and practice.
Recent work by Benabbas et al. [18] and Boneh and Freeman [22] outsources polynomial evaluation, which inspired our use of this computation ( §3.6, §4).
Ergun et al. [33] study efficient approximate property testing protocols for polynomials and related computations.
Golle [40] outsources the inversion of one-way functions, and Karame et al. [47] apply this to detect cheating in a distributed sequential computation.
Sion [65] and Thompson et al. [68] outsource database operations.
Wang et al. outsource linear programming [69] and approximating systems of linear equations [70].
Atallah has protocols for linear algebra (see [10] and citations therein).
Other work [34,61] handles aggregate statistics computed from distributed sensors.
While some of these works inspired our choice of particular computations, our focus is on general-purpose approaches.Homomorphic encryption and secure multiparty protocols.
Homomorphic encryption is a powerful building block, as it lets the prover compute over ciphertext.
Groth uses homomorphic encryption to produce a zero-knowledge argument protocol [41]; unfortunately, a preliminary feasibility study that we performed indicated that this was not efficient enough for our purposes.
Gentry's recent breakthrough construction of a fully homomorphic encryption scheme [37] has led to new protocols for verifiable noninteractive computation [28,36] with input hiding.
However, fully homomorphic encryption is completely infeasible on today's computers.Closely related are secure multi-party protocols.
In such protocols, parties compute an agreed-upon function of private data, revealing only the result [73].
In fact, the scheme of [36] builds such a protocol based on fully homomorphic encryption.
Other general-purpose protocols for computation on hidden data using homomorphic encryption include the work of [7] and the circuit application of the Boneh-Goh-Nissim cryptosystem [23].
However, in general, because of the input hiding requirements, the costs for the verifier are proportional to the size of the circuit; such protocols are not really suitable in our context.
Moreover, while general-purpose compilers for such protocols exist [13,44,51], they are not yet practical, despite the striking improvements reported in [44].
PCPs, argument systems, and efficient interactive protocols.
The potential of PCPs and efficient arguments to serve as a foundation for verified computations has long been known to theorists [8,9,11,14,20,39,48,49,55].
We borrow from this theory, guided by our goals.
We turn to argument systems because advances in short (non-interactive) PCPs [15-17, 30, 60] seem too intricate to be implemented easily; e.g., they require recursive application of their own machinery.
And among interactive approaches, we build upon the scheme of [45], which is simple, instead of upon an interactive protocol that is asymptotically more efficient but far more intricate [38].
We now review recent work that makes the opposite decision.Following our position paper [64], Cormode, Mitzenmacher, and Thaler have a recent publication [29] with similar positioning.
As with our system, they obtain a lot of mileage from the observation that arithmetic circuits and concise gates are compatible with the protocols and result in substantially more efficient encodings.
Some of their focus is on specialized algorithms for linear problems in the streaming model.
However, they also describe a generalpurpose implementation, based on [38] instead of [45].
On the one hand, the protocol of [38] does not require publickey cryptography and has better asymptotic overhead than that of [45].
On the other hand, the protocol of [45] has better round complexity and does not require uniformity assumptions on the circuit families in question.
A more detailed comparison using measurements on benchmark problems is work in progress.
This work began from the intuition that the protocol of Ishai et al. [45] might lead to a simple and potentially practical built system, and PEPPER appears to have fulfilled that promise: the verifier is relatively inexpensive, the prover is much better than we expected, the protocol is simple, and the tailored scheme is not so far from true practicality.
A deployable system is plausibly within view.Nonetheless, there is still much work to do to get PEP-PER ready for prime time.
Its protocols are still not cheap enough, particularly for the prover.
Its model of computation is restrictive: we studied problems that admit concise expressions with arithmetic circuits performing multiprecision arithmetic ( §3.3, §4.1), with a focus on problems that allow decomposition into identical parallel modules ( §3.5) or permit tailored PCPs ( §3.6).
And while for arbitrary computations, one can theoretically apply PEP-PER-by compiling the computation to a circuit with, say, the compiler developed as part of the Fairplay system [13,44,51]-our estimates indicate that this approach is unlikely to achieve acceptable performance and that a more specialized compiler is necessary.The good news is that substantial further improvements seem possible.
In the short term, there is much to be gained from engineering: a move to elliptic curve cryptography will allow us to improve the security parameters while decreasing overhead, and we plan to explore special-purpose hardware for modular exponentiation.
We are working on compilers to automate the manual process described in Section 4.2; the goal is to output our non-tailored protocol for suitable computations and (when applicable) to generate the tailored PCPs that produce the most practical scheme ( §3.6).
More broadly, the key challenge for this area is to expand the approach beyond computations that are naturally specified as arithmetic circuits over finite fields.
For instance, a basic issue is handling floating point numerics efficiently.
More generally, handling computations with interesting control flow is a central problem.
Satisfactory answers to these questions will help realize the vision of making efficient arguments (and PCPs) truly practical.
We state the queries, then the tests, then the statement of correctness of the PCP in [8, §5-6].
We use ∈ R to mean a uniformly random selection.
The purpose of q 10 , q 12 , q 14 below is self-correction; see [8, §5] or [58, §7.8.3] for details.
• Generate linearity queries: Select q 1 , q 2 ∈ R F s and q 4 , q 5 ∈ R F s 2 .
Take q 3 ← q 1 + q 2 and q 6 ← q 4 + q 5 .
• Generate quadratic correction queries: Select q 7 , q 8 ∈ R F s and q 10 ∈ R F s 2 .
Take q 9 ← (q 7 ⊗ q 8 + q 10 ).
• Generate circuit queries: Select q 12 ∈ R F s and q 14 ∈ R F s 2 .
Take q 11 ← γ 1 + q 12 and q 13 ← γ 2 + q 14 .
• Issue queries.
Send queries q 1 , . . . , q 14 to oracle π, getting back π(q 1 ), . . . , π(q 14 ).
• Linearity tests: Check that π(q 1 ) + π(q 2 ) = π(q 3 ) and that π(q 4 ) + π(q 5 ) = π(q 6 ).
If not, reject.
• Quadratic correction test: Check that π(q 7 ) · π(q 8 ) = π(q 9 ) − π(q 10 ).
If not, reject.
• Circuit test: Check that (π(q 11 ) − π(q 12 )) + (π(q 13 ) − π(q 14 )) = −γ 0 .
If so, accept.
The γ 0 , γ 1 , γ 2 above are described in §2.1.
The following lemmas rephrase Lemmas 6.2 and 6.3 from [8]:Lemma A.1 (Completeness [8]).
Assume V is given a satisfiable circuit C.
If π is constructed as in Section 2.1, and if V proceeds as above, then Pr{V accepts C} = 1.
The probability is over V's random choices.Lemma A.2 (Soundness [8]).
There exists a constant κ < 1 such that if some proof oracle π passes all of the tests above on C with probability > κ, then C is satisfiable.Applying the analysis in [8], we can take κ > max{7/9, 4δ + 2/|F|, 4δ + 1/|F|} for some δ such that 3δ − 6δ 2 > 2/9.
This ensures soundness for all three tests.
Here, δ relates to linearity testing [21]; to justify the constraint on δ and its connection to the 7/9 floor on κ, see [12] and citations therein.
Taking δ = 1 10 , we can take κ = 7/9+neg, where neg can be ignored; thus, for convenience, we assume κ = 7/9.
Applying the lemma, we have that if the protocol is run ρ = 70 times and C is not satisfiable, V wrongly accepts with probability < κ ρ < 2.3 · 10 −8 .
This section first reduces PCPs to arguments directly, using Commit+Multidecommit ( Figure 3); this will formalize Figure 1.
The soundness of the reduction relies on Commit+Multidecommit actually binding the prover after the commit phase.
Thus, the second (bulkier) part of the section defines a new and strengthened commitment protocol (Defn.
B.1), proves that Commit+Multidecommit implements this protocol (Lemma B.1), and proves that any such protocol binds the prover in the way required by the reduction (Lemma B.2).
The reduction composes a PCP (such as the one in Appendix A) with Commit+Multidecommit.
The protocol, theorem, and proof immediately below are almost entirely a syntactic substitution in [45, §4], replacing "MIP" with "PCP".
Given a linear PCP with soundness , the following is an argument system (P , V ).
Assume that (P , V ) get a Boolean circuit C and that P has a satisfying assignment.
1.
P and V run Commit+Multidecommit's commit phase, causing P to commit to a function, π.
2.
V runs the PCP verifier V on C to obtain µ = ·ρ queries q 1 , . . . , q µ .
3.
P and V run the decommit phase of Commit+Multidecommit.
V uses q 1 , . . . , q µ as the queries.
V either rejects the decommitted output, or it treats the output as π(q 1 ), . . . , π(q µ ).
To these outputs, V applies the PCP verifier V. V outputs accept or reject depending on what V would do.Theorem B.1.
Suppose (P, V) is a linear PCP with soundness .
Then (P , V ) described above is an argument protocol with soundness ≤ + c .
( c represents the error from the commitment protocol and will be filled in by Lemma B.2.)
Proof.
Completeness follows from the PCP and the definition of Commit+Multidecommit.
For soundness, Lemma B.2 below states that at the end of step 1 above, there is an extractor function that defines a single (possibly incorrect) oracle functioñ π such that, if V didn't reject during decommit, then with all but probability c , the answers that V gets in step 3 are˜πare˜ are˜π(q 1 ), . . . , ˜ π(q µ ).
But (P, V) has soundness , so the probability that V accepts a non-satisfiable C is bounded by + c .
We now strengthen the commitment primitive in Ishai et al. [45], borrowing their framework.
We define a protocol: commitment to a function with multiple decommitments (CFMD).
The sender is assumed to have a linear function, π, given by a vector, w ∈ F n ; that is, π(q) = w, q.
In our context, w is normally (z, z ⊗ z).
The receiver has µ queries, q 1 , q 2 , . . . , q µ ∈ F n .
For each query q i , the receiver expects π(q i ) = w, q i ∈ F.Definition B.1 (Commitment to a function with multiple decommitments (CFMD)).
Define a two-phase experiment between two probabilistic polynomial time actors (S, R) (a sender and receiver, which correspond to our prover and verifier) in an environment E that generates F, w and Q = (q 1 , . . . , q µ ).
In the first phase, the commit phase, S has w, and S and R interact, based on their random inputs.
In the decommit phase, E gives Q to R, and S and R interact again, based on further random inputs.
At the end of this second phase, R outputs A = (a 1 , . . . , a µ ) ∈ F µ or ⊥.
A CFMD meets the following properties:• Correctness.
At the end of the decommit phase, R outputs π(q i ) = w, q i (for all i), if S is honest.
• B -Binding.
Consider the following experiment.
The environment E produces two (possibly distinct) µ-tuples of queries: Q = (q 1 , . . . , q µ ) andˆQandˆ andˆQ = (ˆ q 1 , . . . , ˆ q µ ).
R and a cheating S * run the commit phase once and two independent instances of the decommit phase.
In the two instances R presents the queries as Q andˆQandˆ andˆQ, respectively.
We say that S * wins if R's outputs at the end of the respective decommit phases are A = (a 1 , . . . , a µ ) andˆA andˆ andˆA = (ˆ a 1 , . . . , ˆ a µ ), and for some i, j, we have q i = ˆ q j but a i = ˆ a j .
We say that the protocol meets the B -Binding property if for all E and for all efficient S * , the probability of S * winning is less than B .
The probability is taken over three sets of independent randomness: the commit phase and the two runnings of the decommit phase.
Informally, binding means that after the sender commits, it is very likely bound to a function from queries to answers.Lemma B.1.
Commit+Multidecommit (Figure 3, Section 3.4) is a CFMD protocol with B = 1/|F| + S , where S comes from the semantic security of the homomorphic encryption scheme.Proof.
Correctness: for an honest sender,b = π(t) = π(r)+ µ i=1 π(α i ·q i ) = s+ µ i=1 α i ·π(q i ) = s+ µ i=1 α i ·a i , which implies that b = s + µ i=1 α i · a i, and so verification passes, with the receiver outputting π(q 1 ), . . . , π(q µ ).
To show B -binding, we will show that if S * can systematically cheat, then an adversary A could use S * to break the semantic security of the encryption scheme.
Assume that Commit+Multidecommit does not meet B -binding.
Then there exists an efficient cheating sender S * and an environment E producing Q, ˆ Q, i, j such that q q i = ˆ q j and S * can make R output a i = ˆ a j with probability > B .
We will construct an algorithm A that differentiates between α, α ∈ R F with probability more than 1/|F| + S when given as input the following: a public key, pk; the encryption, Enc(pk, r), of r for a random vector r ∈ F n ; r+αq; and r+α q.
This will contradict the semantic security of the encryption scheme.
A has Q, q, i, j hard-wired (because A is working under environment E) and works as follows:(a) A gives S * the input (pk, Enc(pk, r)); A gets back e from S * and ignores it.
(b) A randomly chooses α 1 , . . . , α i−1 , α i+1 , . . . , α µ .
It also randomly choosesˆαchoosesˆ choosesˆα 1 , . . . , ˆ α j−1 , ˆ α j+1 , . . . , ˆ α µ .
(c) A now leverages Q, q, i, j.
A was given r + αq, so it can construct r + αq + k∈[µ]\i α k q k = r + Q · α, where α = (α 1 , . . . , α i−1 , α, α i+1 , . . . , α µ ).
A gives S * the input (Q, r + Q · α); that is, A invokes S * in the decommit phase.
A gets back (A, b).
(d) Likewise, A constructs r + α q + k∈[µ]\jˆα\jˆ \jˆα k ˆ q k = r + ˆ Q · ˆ α, wherê α = ( ˆ α 1 , . . . , ˆ α j−1 , α , ˆ α j+1 , . . . , ˆ α µ ).
A gives S * ( ˆ Q, r + ˆ Q · ˆ α), invoking S * in the decommit phase again.
A gets back ( ˆ A, ˆ b).
When S * wins (which it does with probability greater than B = 1/|F| + S ), b = s + α · A andˆbandˆandˆb = s + ˆ α · ˆ A, but a i = ˆ a j (here, · represents the dot product).
Now we will get two linear equations in two unknowns.
The first isˆbisˆisˆb − b = ˆ α · ˆ A − α · A, which can be rewritten as:K 1 = α ˆ a j − αa i , where A can derive K 1 = ˆ b − b − k =jˆα=jˆ =jˆα k ˆ a k + k =i α k a k .
Now, let t = r + Q · α and letˆt letˆletˆt = r + ˆ Q · ˆ α.To get the second equation, we start withˆt withˆwithˆt− t = k∈[µ]\jˆα\jˆ \jˆα k ˆ q k − k∈[µ]\i α k q k + α q − αq.This equation concerns a vector.
We choose an index in the vector where q is not zero (if q is zero everywhere, then r is revealed).
At that index, we have the following equation in scalars:K 2 = α − α , where A can derive K 2 = ( ˆ t () − t () − k =jˆα=jˆ =jˆα k ˆ q () k + k =i α k q ()k )/q () .
Now A can solve for α (since the contrary hypothesis gave a i = ˆ a j ).
We now prove that after the commit phase, the prover is effectively bound to a single function.
Our articulation again follows [45], specifically their Lemmas 3.2 and 3.6.
Lemma B.2 (Existence of an extractor function).
Let (S, R) be a CFMD protocol with binding error B .
Letc = µ · 2 · (2 3 9/2 + 1) · 3 √ B .
Let v = (v S * , v R ) representthe views of S * and R after the commit phase (v captures the randomness of the commit phase).
For every efficient S * and for every v, there exists a functioñ f v : F n → F such that the following holds.
For any environment E, the output of R at the end of the decommit phase is, except with probability c , either ⊥ or satisfies a i = ˜ f v (q i ) for all i ∈ [µ], where (q 1 , . . . , q µ ) are the decommitment queries generated by E, and the probability is over the random inputs of S * and R in both phases.Proof.
We will reuse the ideas in the proof of Lemma 3.2 in [45], but we must also ensure that q yields the same answer independent of its position and the other queries in the tuple.
We begin with a definition: let Ext(v, q, i, q) argmax a A v (q, i, q, a), where A v (q, i, q, a) equals, in view v = (v S * , v R ), the probability over the randomness of the decommit phase that R's ith output is a when the query tuple is q; note that q is the ith component of q and is included in Ext(·) and A v (·) for convenience.
In other words, Ext(·) is the most likely a i value to be output by R, if the full tuple of queries is q and if q appears in the ith position.
Note that, after the commit phase, Ext(·) is given deterministically.Claim B.3.
Define 2 = ( 3 9/2 + 1) · 3 √ B .
For all E producing (q, i, j, q 1 , q 2 ), where q 1 's ith component is q and q 2 's jth component is also q, we have the following with probability > 1 − 2 over the commit phase: either Ext(v, q, i, q 1 ) = Ext(v, q, j, q 2 ), or else the probability over the decommit phase of outputting ⊥ is greater than 1 − 2 .
Proof.
Assume otherwise.
Then there is an environment E producing (q, i, j, q 1 , q 2 ) such that with probability > 2 over the commit phase, Ext(v, q, i, q 1 ) = Ext(v, q, j, q 2 ) and with probability > 2 over the decommit phase, R outputs something other than ⊥.
Define 1 = 3 B 9/2.
We will show below that with probability > 1 − 1 over the commit phase, a∈F\Ext(v,q,i, q1) A v (q, i, q 1 , a) is < 1 .
Thus, with probability > 2 − 1 over the commit phase, we have (1) the probability over the decommit phase is > 2 − 1 that R outputs Ext(v, q, i, q 1 ) in the ith position (since R outputs something other than ⊥ with probability > 2 , yet the probability of outputting anything other than Ext(v, q, i, q 1 ) is < 1 ); and (2) likewise, the probability of outputting Ext(v, q, j, q 2 ) in the jth position is > 2 − 1 .
If we now take Q = q 1 andˆQ andˆ andˆQ = q 2 , we have a contradiction to the definition of CFMD because with probability > ( 2 − 1 ) 3 = B over all three phases, a i = ˆ a j , which generates a contradiction because the definition of B -Binding says that this was supposed to happen with probability < B .
We must now show that, with probability > 1 − 1 over the commit phase, a∈F\Ext(v,q,i, q1) A v (q, i, q 1 , a) is < 1 .
If not, then with probability > 1 over the commit phase, a∈F\Ext(v,q,i, q1) A v (q, i, q 1 , a) ≥ 1 .
Now, following Lemma 3.2 in [45], we can partition F into two sets T 1 , T 2 such that a∈T1 A v (q, i, q 1 , a) and a∈T2 A v (q, i, q 1 , a) are each greater than 1 /3.
(There are two cases; consider a * = Ext(v, q, i, q 1 ).
Either A v (q, i, q 1 , a * ) is greater than 1 /3, or it is not.
If so, then the partition is (a * , F \ a * ).
If not, then there is still a partition because the sum of the A v (·) is greater than 1 /3.)
This implies that, in the binding experiment, R outputs values from the two partitions with probability > (2/9) · ( 1 ) 3 = B over all three phases, which contradicts the definition of a CFMD protocol.
Now define Ext(v, q) = Ext(v, q, i * , q * ), where i * and q * are designated (any choice with q in the i * position of q * will do).
The next claim says that the response to q is independent of its position and the other queries.Claim B.4.
Let 3 = 2 + 1 .
For all q, i, where q is in the ith position of q, we have that with probability > 1− 3 over the commit phase, either R's ith output is Ext(v, q), or else the probability over the decommit phase of outputting ⊥ is > 1 − 3 .
Proof.
Assume otherwise.
Then there are q, i such that with probability > 3 over the commit phase, the probability of outputting something (non-⊥) besides Ext(v, q, i * , q * ) is > 3 .
But with probability > 1 − 1 over the commit phase, a∈F\Ext(v,q,i, q) A v (q, i, q, a) < 1 (by the partitioning argument given in the proof of Claim B.3).
Thus, with probability > 3 − 1 over the commit phase, the probability of outputting something (non-⊥) besides Ext(v, q, i * , q * ) is > 3 and a∈F\Ext(v,q,i, q) A v (q, i, q, a) < 1 .
Thus, with probability > 3 − 1 = 2 over the commit phase, Ext(v, q, i * , q * ) = Ext(v, q, i, q) and R has > 3 > 2 probability of outputting something other than ⊥.
This contradicts Claim B.3.
To complete the proof of the lemma, define˜fdefine˜define˜f v (q) Ext(v, q).
Consider the probability c , over both phases, that the output A = ( ˜ f v (q 1 ), . . . , ˜ f v (q µ )), i.e., that at least one of a i = ˜ f v (q i ).
By the union bound, c < µ i=1 Pr{a i = ˜ f v (q i )}.
By Claim B.4, Pr{a i = ˜ f v (q i )} < 3 + 3 , since this bounds the probability that either of the two phases goes badly.
Thus, c < µ · 2 · 3 , as was to be shown.To compute c , we ignore S (the homomorphic encryption error); i.e., we set B = 1/|F|.
We then get c < 2000 · (7 3 √ B ) < 2 14 · 3 1/|F|.
For |F| = 2 128 , c < 2 −28 .
Under batching, V submits the same queries to β different proofs.
Below, we sketch the mechanics and then proofs of correctness.
First, we modify Commit+Multidecommit (Figure 3) to obtain a new protocol, called BatchedCommit+Multidecommit.
The changes are as follows:• P is regarded as holding a linear function π : F n → F β , so π(q) = (π 1 (q), . . . , π β (q)).
One can visualize π as an β × n matrix, each of whose rows is an oracle, π i .
Thus, P returns vectors instead of scalars.
• Commit phase, steps 2 and 3: instead of receiving from P the scalar Enc(pk, π(r)), V in fact receives a vector e = (Enc(pk, π 1 (r)), . . . , Enc(pk, π β (r))) and decrypts to get s = (π 1 (r), . . . , π β (r)).
• Decommit phase, steps 5 and 6: P returns a 1 , . . . , a µ , b, where a i is supposed to equal (π 1 (q i ), . . . , π β (q i )) and b is supposed to equal (π 1 (t), . . . , π β (t)); V checks thatb = s + α 1 a 1 + · · · + α µ a µ .
Second, we modify the compilation in Appendix B as follows.
P creates β linear proof oracles, and V and P run BatchedCommit+Multidecommit, causing P to commit to a linear function π : F n → F β .
V then submits the µ PCP queries and receives vectors π(q 1 ), . . . , π(q µ ) in response.
Then V runs the PCP verifier on each instance separately (e.g., for the kth instance, V looks at the kth component of each of π(q 1 ), . . . , π(q µ )).
V thus returns a vector of β accept or reject outputs.
To argue correctness, we use a theorem analogous to Theorem B.1: Theorem C.1.
Under (P , V ) as described above, each of the β instances is an argument protocol with soundness≤ + c .
( c is defined in Appendix B.)Proof.
(Sketch.)
Nearly the same as for Theorem B.1.
We need an analog of Lemma B.2, described below.This theorem says that if any of the β instances tries to encode a "proof" for an incorrect output, the probability that V outputs accept for that instance is bounded by .
This makes intuitive sense because if we fix a given instance, the probabilities should be unaffected by "extra" instances.To formalize this intuition, we need BatchedCommit+Multidecommit to yield an extractor function for each of the β instances.
To get there, we define a general protocol: batch-CFMD.
This protocol has a binding property modified from the one in Definition B.1.
In the new one, R gives stacked output A = (a 1 , . . . , a µ ) andˆAandˆ andˆA = (ˆ a 1 , . . . , ˆ a µ ).
The entries of A are denoted a k i ; that is,a i = (a 1 i , . . . , a β i ).
We allow a k i ∈ {F ∪ ⊥} but require that (a k 1 , . . . , a k µ ) ∈ F µ or a k i = ⊥ for all i ∈ [µ].
We now say that S * wins if for some i, j, k, we have q i = ˆ q j and a k i , ˆ a k j ∈ F but a k i = ˆ a k j .
We again say that the protocol meets B -Binding if for all E and efficient S * , S * has less than B probability of winning.We can show that BatchedCommit+Multidecommit is a batch-CFMD protocol by rerunning Lemma B.1, nearly unmodified.
To complete the argument, we can establish an analog of Lemma B.2.
The analog replaces a single extractor functioñ f v with β functions˜ffunctions˜functions˜f 1 v , . . . , ˜ f β v , one per instance.
The analog says that, viewing each instance k separately, we have with probability > 1 − c that either R's output for that instance is ⊥ or else a ki = ˜ f k v (q i ) for all i ∈ [µ].
The proof is nearly the same as for Lemma B.2; the main difference is that Ext(·) and A v (·) receive a per-instance parameter k.
This section expands on the tailored PCP construction for matrix multiplication, introduced in Section 3.6.
Recall that V wants to verify that C equals A · B, where A, B, C ∈ F m 2 .
Further recall that V constructs a polynomial P (Z) from the constraints in Section 3.3, but V drops the degree-1 constraints.
Loosely speaking, V is justified in doing so because (a) V knows what z a i,j and z b i,j should be, namely the values of A and B; and (b) the resulting circuit test is still likely to catch an incorrect output C. Further recall that the modified PCP encoding is π = π (c) (·) ·, A B, where x y = {x i,k · y k,j } for all i, j, k.After stating the queries and tests below, we give proofs of correctness and estimate costs.
• Generate linearity queries: Select q 1 , q 2 ∈ R F m 3 .
Take q 3 ← q 1 + q 2 .
• Generate quadratic correction queries: select q 4 , q 5 ∈ R F m 2 and q 7 ∈ R F m 3 .
Take q 6 ← (q 4 q 5 + q 7 )• Generate circuit test queries: select q 9 ∈ R F m 3 and q 8 ← γ 2 + q 9 .
(γ 2 is defined in Section 3.6.)
• Issue queries.
Send q 1 , q 2 , q 3 and q 6 , . . . , q 9 to π, getting back π(q 1 ), π(q 2 ), π(q 3 ), π(q 6 ), π(q 7 ), π(q 8 ), π(q 9 ).
• Linearity test: Check that π(q 1 ) + π(q 2 ) = π(q 3 ).
If not, reject.
• Quadratic correction test: Check that π(q 6 ) − π(q 7 ) = m k=1 A * ,k , q 4 * ,k · B k, * , q 5 k, * , where M * ,k ∈ F m denotes the kth column of matrix M, and M k, * ∈ F m denotes the kth row of matrix M.
If not, reject.
• Circuit test: Check that π(q 8 ) − π(q 9 ) = −γ 0 .
(γ 0 is defined in Section 3.6.)
If so, accept.Lemma D.1 (Completeness).
If V is given C = A · B, if π = π (c) is constructed as above, and if V proceeds as above, then Pr{V accepts} = 1.
The probability is over V's random choices.Proof.
If π = π (c) is constructed as above, then the linearity test passes because π (c) is a linear function.
The quadratic correction test also passes because π (c) (q 6 ) − π (c) (q 7 ) = π (c) (q 4 q 5 ) = q 4 q 5 , A B, which indeed equals m k=1 A * ,k , q 4 * ,k · B k, * , q 5 k, * .
Finally, the circuit test passes because π (c) (q 8 ) − π (c) (q 9 ) = π (c) (γ 2 ) = γ 2 , A B, and γ 2 and γ 0 are constructed so that if C = A · B, then γ 2 , A B + γ 0 = 0.
Lemma D.2 (Soundness).
There exists a constant κ < 1 such that if some proof oracle π passes all of the tests above with probability > κ, then C = A · B.Proof.
Choose δ such that 3δ − 6δ 2 > 2/9, and take κ > max{ 7 9 , 2δ + 2/F|, 2δ + 1/|F|}; with δ = 0.1, we can take any κ > 7/9.
We establish soundness by going through each of the tests in turn.
(This is the same proof flow as in [8] though the details differ for the quadratic correction test and circuit test.)
First, from the given, we have that Pr{π passes the linearity test} > 7/9.
This, together with our choice of δ, implies (see [12]) that π (c) is δ-close to some linear function φ(·) (meaning that the fraction of inputs on which π (c) and φ(·) disagree is < δ).
Second, we also have from the given that the probability of passing both the quadratic correction test and the linearity test is > 2δ + 2/|F|, so we can apply the following claim:Claim D.3.
If π (c) is δ-close to some linear function φ(·) and if Pr{π (c) passes the quadratic correction test} > 2δ + 2/|F|, then φ(·) is exactly ·, A B.Proof.
We begin with notation.
Let N A,B (x, y) = m k=1 A * ,k , x * ,k · B k, * , y k, * , where x, y ∈ F m 3 .
We write the (i, k) element of q 4 and the (k, j) element of q 5 as q 4 ik and q 5 kj respectively.
Let φ ijk refer to the (i, j, k) element of the vector that corresponds to φ.
Let σ ijk = φ ijk − A i,k B k,j .
Finally, let η be the event {φ(q 4 q 5 ) = N A,B (q 4 , q 5 )}.
Now, assume toward a contradiction that φ(·) = ·, A B.
Then ∃i , j , k such that σ i j k = 0.
Let ν be the event {q 5 k j = 0}.
We can write Pr {η} < Pr {η|ν} + Pr {ν} = Pr {η|ν} + 1/|F|.
To get an expression for Pr {η|ν}, note that if ν occurs, then (q 5 k j ) −1 is defined.
Also, (σ i j k ) −1 is defined, by contrary assumption.
Noting that η can be written { i,j,k q 4 ik q 5 kj σ ijk = 0}, we have Pr{η|ν} = Pr{q 4 i k = −( i,j,k\(i ,j ,k ) q 4 ik q 5 kj σ ijk ) · (q 5 k j ) −1 · σ −1 i j k } = 1/|F|, since we can regard q 4 i k as being chosen after the right-hand side of the equality.
Thus, Pr{η} < 2/|F|.
We now use the given, to derive a contradiction: 2δ + 2/|F| < Pr{π(q 6 ) − π(q 7 ) = N A,B (q 4 , q 5 )} < Pr{φ(q 6 ) − φ(q 7 ) = N A,B (q 4 , q 5 )} + Pr{π(q 6 ) = φ(q 6 )} + Pr{π(q 7 ) = φ(q 7 )} < Pr{φ(q 4 q 5 ) = N A,B (q 4 , q 5 )} + 2δ, so Pr{η} > 2/|F|.
Contradiction.Third, the probability of passing all three tests is > 2δ + 1/|F| (again from the given), so we can apply the following claim to complete the lemma.
The PCP encoding is m 3 work to produce.
V constructs 8 queries and submits 7 of them to π; this is the same as the number of queries to π (2) in the baseline PCP (Appendix A).
V requires 2m 2 field multiplications for the quadratic correction test plus m 2 multiplications in the circuit test (to construct γ 0 ), for a total of 3m 2 per repetition.
By comparison, the baseline PCP requires 2 operations for the quadratic correction test and 3m 2 for the circuit test.
Since ElGamal encryption is multiplicatively homomorphic (rather than additively homomorphic), small modifications to Commit+Multidecommit (Figure 3) and the soundness arguments are necessary.
Below, we describe these modifications and establish that the results of Appendix B still hold.Fix the ElGamal group G, choose a generator g (known to both parties), and assume for now that |F p | = |G| (we revisit this assumption below).
Define the map ψ : F p → G by x → g x .
The map ψ is a group homomorphism and in fact an isomorphism; furthermore, ψ induces a ring structure on G. By composing ψ with ElGamal encryption, we get an additive homomorphism: Enc(pk, g x )Enc(pk, g y ) = Enc(pk, g x+y ).
Of course, the verifier cannot recover x + y explicitly from g x+y , but this does not matter for Commit+Multidecommit.
Also, given Enc(pk, g x ) and a ∈ F p , the properties of the ElGamal protocol imply that one can compute Enc(pk, g ax ).
Thus, given (Enc(pk, g r1 ), . . . , Enc(pk, g rn )), one can compute Enc(pk, g π((r1,...,rn)) ), where π is a linear function.Therefore, we can modify Figure 3 as follows.
First, during step 1, the verifier componentwise sends Enc(pk, g r ) rather than Enc(pk, r) to the prover.
Next, in step 2, the prover computes Enc(pk, g π(r) ) (without learning g r ), as described above.
Then in step 3, V decrypts to get g s .
Finally, in step 6, the verifier checks that g b = g s+α1a1+···+αµaµ .
We now need to check that Lemma B.1 still holds.
Correctness applies, by inspection.
Binding applies because the semantic security of the encryption scheme can be formulated in terms of A(pk, Enc(pk, g r ), r + αq, r + α q) and because g x = g y if and only if x = y (since ψ is injective).
Note that when |G| > |F p |, the same approach works, via modular arithmetic.
Specifically, although ψ is no longer a group isomorphism, it is injective.
Provided that the computations never overflow, i.e., result in values in the exponent larger than |G|, the protocol remains correct.
Nikhil Panpalia created the parallel prover implementation.
For helpful comments, we thank Lorenzo Alvisi, Dan Boneh, Allen Clement, Mike Freedman, Maxwell Krohn, Mike Lee, Josh Leners, Antonio Nicolosi, Bryan Parno, Raluca Popa, Victor Vu, Shabsi Walfish, Ed Wong, Hao Wu, and the anonymous reviewers.
Emulab was helpful as always.
The research was supported by AFOSR grant FA9550-10-1-0073 and by NSF grants 1055057 and 1040083.
Our implementation and experimental configurations are available at: http://www.cs.utexas.edu/pepper
