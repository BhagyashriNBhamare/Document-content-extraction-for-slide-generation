Given a set O of weighted objects, a set S of sites, and a query site s, the bichromatic RNN query computes the influence set of s, or the set of objects in O that consider s as the nearest site among all sites in S.
The influence of a site s can be defined as the total weight of its RNNs.
This paper addresses the new and interesting problem of finding the top-t most influential sites from S, inside a given spatial region Q.
A straightforward approach is to find the sites in Q, and compute the RNNs of every such site.
This approach is not efficient for two reasons.
First, all sites in Q need to be identified whatsoever, and the number may be large.
Second, both the site R-tree and the object R-tree need to be browsed a large number of times.
For each site in Q, the R-tree of sites is browsed to identify the influence region-a polygonal region that may contain RNNs, and then the R-tree of objects is browsed to find the RNN set.
This paper proposes an algorithm called TopInfluential-Sites, which finds the top-t most influential sites by browsing both trees once systematically.
Novel pruning techniques are provided, based on a new metric called minExistDNN.
There is no need to compute the influence for all sites in Q, or even to visit all sites in Q. Experimental results verify that our proposed method outperforms the straightforward approach .
Since its introduction by [KM00], the reverse nearest neighbor (RNN) query has received considerable attention in recent spatial database research field.
The RNN query can be roughly classified into two cases: the (traditional) monochromatic RNN query and the bichromatic RNN query.
In the monochromatic case, there is only one spatial dataset O of objects.
We want to find the objects that are closer to a given location than to other objects.
In the bichromatic case, there is another dataset S of sites.
The RNNs of a given site s are the objects o ∈ O such that ∀s i ∈ S, d(o, s) ≤ d(o, s i ).
Here d() is the Euclidean distance function.
In other words, the RNNs of s are the objects that consider s as the nearest site.
The bichromatic RNN query has many practical applications.
For instance, retrieve the residence buildings that consider a give supermarket as the nearest, or retrieve the mobile users that consider a given wireless station as the closest.
However, the bichromatic case is intrinsically more difficult than the monochromatic case.
For instance, the number of RNNs is limited in the monochromatic case (e.g. at most 6 in the 2D space) [Smi97], but unbounded in the bichromatic case.This paper proposes and solves the problem of finding top-t most influential sites, which is an extension to the bichromatic RNN problem.
There are several differences.
First, instead of taking as input a single site, we take as input a spatial region Q. Second, instead of computing the set of RNNs for a given site, we are interested in the influence, or the total weight of RNNs, of a site.
In particular, we are interested in efficiently identifying the sites in Q with the largest influence.
Example applications are: find the two most influential supermarkets in Boston, or find the most influential wireless station in central USA.Definition 1 Given a set of sites S, a set of weighted objects O, a spatial region Q, and an integer t, the top-t most influential site query retrieves t sites in Q with the largest influences.
Here the influence of a site s ∈ S is the total weight of objects in O that have s as the nearest site.
Figure 1: The most influential site is s 1 , if all objects have weight=1 and Q is the whole space.For example, consider Figure 1.
Let t = 1, and let Q be the whole space.
Further, let the weight of every object be 1.
The most influential site is s 1 , whose influence is 3.
There are three objects o 1 , o 2 and o 3 that have s 1 as the nearest site.One approach to solve this problem is to use precomputation.
Each site stores its influence.
At query time, we find the sites in Q and return the top-t most influential ones.
This approach has two drawbacks.
First, it is time consuming to maintain the pre-computed results upon updates.
Second, the precomputation binds a set of sites closely with a set of objects.
Suppose a set of sites (e.g. supermarkets) may be queried against multiple sets of objects (e.g. the set of all residential buildings, or the set of store members' addresses).
A site needs to maintain multiple influence values.
For these reasons, we focus on algorithms which apply directly to two plain R-trees, one for sites and the other for objects, without any pre-computation.
Another approach, which does not use precomputation, is to extend an existing solution to the bichromatic RNN query [SRAE01].
The idea of [SRAE01] to find the RNNs of a site s, is to dynamically construct the influence region (or Voronoi cell), by examining the R-tree of sites.
Here, an influence region is defined as a polygon in space which encloses the locations that are closer to s than to any other site.
Once the influence region is computed, a range query in the R-tree of objects is performed to locate RNNs of s.To find top-t most influential sites in Q, we can perform a range query on S to find the sites in Q, and then for each located site s, compute its RNNs using [SRAE01].
An optimization is to index the set of objects using an R-tree whose index entries store the total weight of objects in their sub-trees.
If a subtree MBR is contained in an influence region, there is no need to examine the sub-tree.
Nevertheless, this approach is not efficient for the following two reasons.
First, all sites in Q need to be identified whatsoever.
In practice, Q may be large (e.g. "central USA") and thus may contain many sites.
We know that out of the many sites in Q, only t sites (for some small t) are needed.
So, intuitively, pruning techniques should be possible.
That is, without going all the way to the leaf level of the site R-tree, it may be possible to determine that a sub-tree (intersecting with Q) only contains sites with relatively small influences and therefore can be pruned.
A bigger efficiency issue is that the two R-trees need to be browsed many times.
In more detail, for every site in Q, the R-tree of sites is browsed to identify the influence region, and then the R-tree of objects is browsed to compute the corresponding influence.This paper presents an algorithm called TopInfluentialSites, which finds the top-t most influential sites by browsing both R-trees (aR-trees 1 to be more precise) once.
Novel pruning techniques are provided, based on a new metric called minExistDNN.
There is no need to compute the influence for all sites in Q, or even to locate all sites in Q.Here minExistDN N S1 (O 1 ) is a distance defined between two minimum bounding rectangles (MBRs) of R-trees.
It is the smallest distance which is guaranteed to be an upper bound of the distance between any object in O 1 to its nearest site in S 1 .
Here 'DNN' stands for distance to nearest neighbor.
'Exist' represents the fact that from any object in O 1 , within this distance there must exist a site in S 1 .
And 'min' corresponds to the fact that this metric is the smallest upper bound.
It reminds us the metrics minDist, maxDist and minM axDist [RKV95].
One difference is that this new metric is directional.
That is, switching S 1 with O 1 will get a different distance.
This is a useful metric.
We have: if minExistDN N S1 (O 1 ) < minDist(O 1 , S 2 ), no object in O 1 will consider a site in S 2 to be the nearest site.
It can be used to prune the search space for NN and/or RNN related queries, such as the problem of finding top-t most influential sites.
Nevertheless, it is NOT straightforward how to compute it.
In Section 3 we formally define the metric and provide an algorithm to compute it.For the top-t most influential site query, the algorithm and the data structures used are outlined below.
For ease of presentation, let's use O and S to also represent the R-tree of objects in O and the Rtree of sites in S, respectively.
We keep three queues.
One queue, queue SIN (reads Q-ESS-IN), keeps the (index or leaf) entries from S that intersect (or are inside) Q. Each entry keeps a lower bound and an upper bound for the influence of sites in the entry's spatial range.
Another queue keeps the entries from O that affects some entries in queue SIN .
Here an entry O i affects an entry S j , if and only if there does not exist another entry S k in the queues, such that minExistDN N S k (O i ) < minDist(O i , S j ).
Intuitively, if some object in O i considers some site in S j as the closest site, O i affects S j .
The third queue keeps the entries from S that are outside Q, but are affected by some entries in the queue of O. Initially, the entries in the root nodes of O and S are selectively loaded into the three queues.
The metric minExistDN N is used to determine which O i does not affect which S j .
The algorithm then progressively chooses some entries from one of the three queues to expand, and updates the content of the queues.
Here, to expand an index entry means to retrieve the referenced node from disk and visit its content.
It terminates when there are t sites in queue SIN whose lower bounds are no less than the upper bounds of all remaining entries.
These t sites are reported as the most influential sites.What's crucial is: how do we choose the next entry to expand?
It is not a good choice to expand all entries from one queue (e.g. queue SIN ) to the leaf level before expanding other queues.
It is also not a good choice to expand in a round-robin manner.
A good strategy should be to expand according to the actual data, satisfying certain goals.
For example, (a) The lower bound and upper bound estimations should be as accurate as possible.
(b) An O i should affect as few S j as possible, and vice versa.
(c) The expansion should quickly reveal some highly influential sites and work on increasing their lower bounds.The key results of this paper are:• We propose a new metric called minExistDNN, and an algorithm to calculate it.
It can be used to prune search space when computing the topt most influential sites.
In the future we expect this metric to be used in other NN/RNN related spatial database problems.
• We propose and solve the top-t most influential site query.
Our algorithm works directly on the datasets indexed by R-trees, without the need to pre-compute the influence of all sites or the distance from every object to its closest site.
Our algorithm systematically chooses the next entry to expand, according to the actual data distribution.
Experimental results are provided which illustrates the efficiency of our algorithm.The rest of the paper is organized as follows.
Section 2 reviews related work on RNN queries.
Section 3 proposes the metric minExistDN N , with an algorithm to compute it.
Section 4 presents our algorithm to compute top-t most influential sites.
Section 5 presents experimental results.
Finally, Section 6 concludes the paper.
The RNN problem was first studied in [KM00].
The idea is to pre-compute, for each object, the distance dnn to its nearest site.
Thus each object corresponds to a circle, whose center is the object and whose radius is the dnn of it.
Besides the R-tree which indexes the original objects, a separate R-tree is maintained which indexes the set of such circles.
The problem of finding RNNs (influence set) is then reduced to finding the circles that contain the query point.To eliminate the need of storing two R-trees, Yang and Lin [YL01] proposed to store some additional information in the original R-tree, so that it logically stores a circle per object.
The extension is: every leaf record stores dnn, and every index record also stores dnn -the max dnn for all objects in the sub-tree.
They call the extended structure the Rdnn-tree.
The benefit for the RNN search is as follows.
Let an index node be N , and let the query location be l.
If the distance between l and the MBR of N is bigger than N.dnn, there is no need to search the sub-tree rooted by N .
Lin et al. [LNY03] proposed a method to bulk-insert the Rdnn-tree.
The work based on storing circles [KM00, YL01], either physically or logically, can be used to answer both the monochromatic RNN query and the bichromatic RNN query.
However, the pre-computation incurs extra update cost to maintain the correct dnn for each object or index entry.
Furthermore, for the bichromatic RNN case, the solution binds a set of objects closely with a set of sites.
Below we review some algorithms without pre-computation.
For the monochromatic RNN query, there are two approaches without using pre-computation.
An earlier approach [SAE00] divides the space into six 60 • regions centered by the query location l.
It was proved that the only candidates of the RNNs are the six nearest neighbors (NN) of l in each region.
So [SAE00] finds the six NNs, and then check to see if each of them really considers l as NN.
A recent result which is more efficient was introduced by [TPL04].
Given the query location l, we first find its NN, say o 1 .
Consider the bisector of l and o 1 .
All objects on the side of o 1 (except o 1 itself) can be pruned, since their distances to o 1 is no more than the distances to l. Next, in the unpruned space, the NN to l is found, and the space is further pruned.
Finally, the unpruned space does not contain any object.
The only candidates of RNNs are the identified NNs.
The refinement step, which removes false positives, uses the previously pruned MBRs so that no tree node is visited twice throughout the algorithm.An algorithm which computes bichromatic RNNs, without pre-computation, was proposed by [SRAE01].
The idea is to dynamically construct the influence region of the query location l. Here, the influence region is defined as a polygon in space which encloses and only encloses all possible RNNs of l.
This is equivalent to the Voronoi cell enclosing l [BKOS97].
Conceptually, if we draw a bisector line between l and a site s, any object located on the l side of the bisector will have smaller Euclidean distance to l than to s.
The l side of the bisector is a half plane.
If we compare l against all sites and take the intersection of these l-side half planes, we get the Voronoi cell containing l.Of course, to compare with all sites is expensive.
As proved in [SRAE01], we only need to examine sites in a certain rectangle which is computed as follows ( Figure 2).
First, we find the nearest site of l in each quadrant formed by axes parallel to the original axes that pass through l.
This is a constrained NN query [FSAE01].
Let the four NNs be A, B, C and D in the first, second, third and fourth quadrant respectively.
By using the four NNs we form an approximate influence region, mnop ( Figure 2(a)).
Then, we draw four circles.
Each one passes through l and one of the four vertices of the approximate influence region, e.g. m, with diameter being the distance between l and that vertex, e.g. d(l, m) ( Figure 2(b)).
Next, we draw the MBR of the four circles.
Finally, each edge of the MBR is expanded away from l by the same distance from l to the edge.
And we get the rectangle that is guaranteed to contain all sites needed for computing the Voronoi cell of l.
A range query is performed using this rectangle on the R-tree of sites.
The Voronoi cell of l can be computed by only examining these identified sites.An object is located in the Voronoi cell of l if and only if it is closer to l than to any site.
So to find the RNNs of l, a range query using the Voronoi cell is performed on the R-tree of objects.There is some other RNN work as well.
A computational geometry work [MVZ02] on finding RNNs also uses the idea of storing circles.
The method focuses on asymptotic behavior rather than experimental evaluation.
Singh et al. [SFT03] proposed an approximate RNN solution.
The idea is to first find k (for some system parameter k) NNs of the query location l, then eliminate false positives.
The problem is that the method may have false negatives.
The NN query and RNN query for moving objects was discussed in [BJKv02].
Finding RNNs and RNN aggregations over a data stream was proposed by [KMS02].
The RNN aggregation queries they considered are different from our problem.
Finding RNNs in a graph was discussed in [YPMT05].
To find the top-t most influential sites in a query region Q, a reasonable algorithm should start with pushing index entries from the root node of S, that intersect with Q, into a processing queue.
Then the entries should be selectively expanded to reveal the t most influential sites.
Let's name such a queue as queue SIN .
An optimal algorithm should focus on expanding the entries that contain these t sites.To differentiate the entries in queue SIN , we propose to use a priority queue, where the sorting key is some upper bound of the influence for every location in the entry and it can be computed in the following way.
Consider an entry O i in the root node of O, and an entry S j in queue SIN .
If some object in O i may consider some site in S j as NN, we say O i affects S j , and the total weight of objects in O i is added to the upper bound of S j .
(This total weight is maintained along with the index entry which stores O i .)
Here in the affect relationship, one or both entries can be leaf entries (i.e. sites or objects).
For example, an object o affects S j , if it is possible that o's NN is in S j .
Clearly, we should be able to identify the set of MBRs from O that affect each MBR of S.
One intuition is that if O 1 is close to S 1 but is far from S 2 , it is likely that O 1 does not affect S 2 .
To be more precise, O 1 does not affect S 2 if for every location l in O 1 , it is guaranteed that the distance from l to its nearest site in S 1 is smaller than the minimum distance from l to S 2 .
This reminds us the three metrics defined in [RKV95], as shown in Figure 3(a).
Given a point l and a rectangle S 2 , minDist(l, S 2 ) and maxDist(l, S 2 ) are the lower bound and upper bound, respectively, of the distance between l and any possible site in S 2 .
The third metric, minM axDist(l, S 2 ), is the smallest distance which guarantees that, within this distance from l, there exists a site in S 2 .
The computation of minM axDist is as follows.
For each edge of S 2 , compute the maximum distance between l and any point on the edge.
This must be between l and one of the two end point of the edge.
Due to the property of the (R-tree) MBR, each edge of S 2 must contain at least one site, and the maximum distance from l to each edge is an upper bound of the minM axDist(l, S 2 ).
Therefore, out of the four distances, pick the minimum one.
Figure 3(b) shows that the three metrics can be straightforwardly extended to the case of two rectangles.
Theorem 1 An object o does not affect S 2 , if there exists S 1 such thatminM axDist(o, S 1 ) < minDist(o, S 2 )Due to the space limitations, the proofs of theorems and lemmas in this paper are omitted.What we really need is an condition which determines that an MBR O 1 does not affect S 2 , given S 1 .
What if we simply replace o in Theorem 1 with O 1 ?
Well, it does not work.
As shown in Figure 5, although minM axDist(O 1 , S 1 ) < minDist(O 1 , S 2 ), it is still possible that on object o in O 1 considers some site in S 2 as its nearest site.
Instead of using minM axDist(O 1 , S 1 ), the correct condition should use some distance which (i) guarantees that, within this distance, every location in O 1 can reach a site in S 1 ; and (ii) is the smallest one among all distances satisfying (i).
We introduce a metric called minExistDN N which satisfy these two conditions.S 1 S 2 O 1 s 1 1 1 1 2 s 2 o minMaxDist(O , S )=5, minDist(O , S )=6 Definition 2 Given two MBRs O 1 and S 1 , the minimum upper bound of the distance from an object in O 1 to its nearest site in S 1 is defined as:minExistDN N S1 (O 1 ) = max{minM axDist(l, S 1 ) | ∀location l ∈ O 1 }Note that unlike the existing three metrics (minMaxDist, etc.), in minExistDN N we cannot swap the input parameters.
In other words,minExistDN N S1 (O 1 ) 񮽙 = minExistDN N O1 (S 1 ).
This is why we put S 1 as subscript.Let's see why this metric satisfies the two requirement given at the end of the previous sub-section.
(i) For every location l ∈ O 1 , minM axDist(l, S 1 ) is an upper bound of the distance between l and its nearest site in S 1 .
So within minExistDN N S1 (O 1 ), which is the maximum of all such minM axDist, every location in O 1 will meet a site inS 1 .
(ii) Consider any distance d < minExistDN N S1 (O 1 ).
According to Definition 2, there must exist a location l M ∈ O 1 s.t. d < minM axDist(l M , S 1 ).
So d does not satisfy (i).
Theorem 2 An MBR O 1 does not affect S 2 , if there exists S 1 such that Figure 6 illustrates minExistDN N S1 (O 1 ) in two scenarios.
In Figure 6(a), the distance is between a corner point of O 1 and a corner point of S 1 .
The correctness is easy to see.
However, the correctness of minExistDN N S1 (O 1 ) < minDist(O 1 , S 2 ) Let's associate every location l in space with a corner point of S 1 -the corner whose distance to l is equal to minM axDist(l, S 1 ).
If all locations in O 1 were associated with the same corner of S 1 , the computation of minExistDN N S1 (O 1 ) would become an easy task.
That is, we simply compute the maximum distance between that corner of S 1 with O 1 .
However, different locations in O 1 may be associated with different corner points of S 1 .
In Step 1 below, we present a space partitioning scheme such that every location in the same partition is associated with the same corner of S 1 .
This immediately suggests an algorithm for calculating minExistDN N S1 (O 1 ).
That is, we divide O 1 into multiple sub-regions, one in each partition.
Then, for each sub-region, we calculate the maximum distance from the associated corner of S 1 to the sub-region.
In Step 2, based on the space partitioning, we develop a more efficient algorithm which computes minM axDist(l, S 1 ) for up to eight locations in O 1 .
The maximum of these eight distances is the required minExistDN N .
Lemma 1 Given a location l and an MBR S 1 , minM axDist(l, S 1 ) is the distance between l and the second closest corner point of S 1 .
Suppose every location in space is associated with the second closest corner of S 1 .
Figure 7 shows a partitioning of space, such that all locations in the same partition are associated with the same corner.
(Our partitions are different from the Voronoi diagram of order 2 of the four corner points, whose partitions are associated with two closest corner point.
The space partitioning is created by four lines intersecting at the same location: the center of S 1 .
The four lines are the perpendicular bisectors (in short, bisectors) of S 1 's edges and diagonals.
Notice that every two edges, e.g. top and bottom, have the same bisector.
The associated corner for locations in each partition is shown in Figure 7.
For instance, P 1 : b means all locations in partition P 1 are associated with b.Let's see why this partitioning is correct.
Consider a quadrant of space: the union of P 1 and P 2 (Figure 7).
Any location in this quadrant considers the upper-left corner a as the closest corner.
We know the second closest corner is either b or c, but not d.
So if we draw a bisector of diagonal bc, any location on the b side of the bisector (P 1 ) considers b to be closer than c, and thus takes b as the second closest corner.
Similarly, any location in P 2 considers c as the second closest corner.
Same with the other partitions.
We argue that the location in O 1 , whose distance to its associated corner of S 1 is the minExistDN N S1 (O 1 ), is one of, at most, eight candidate locations.
The candidates are the four corners of O 1 plus the (up to four) intersection points between the border of O 1 and the diagonals' bisectors.
Thus the algorithm to compute minExistDN N S1 (O 1 ) is to calculate minM axDist for each candidate location, and return the maximum.We denote the intersections between O 1 and the two diagonal bisectors of S 1 as the intersection points of O 1 , and the number of the intersection points of O 1 is at most 4.
Also, an intersection segment of O 1 is a line segment on one of the diagonal bisectors inside rectangle O 1 .
To prove our claim above, we introduce two lemmas.Lemma 2 For any point p ∈ O 1 , there exists a point, p 񮽙 , either on some border or on some intersection segment of O 1 , such that minM axDist(p 񮽙 , S 1 ) ≥ minM axDist(p, S 1 ).
Lemma 3 For any point p 񮽙 on the borders or the intersection segments of rectangle O 1 , there exists a corner or intersection point p 񮽙񮽙 , such that minM axDist(p 񮽙񮽙 , S 1 ) ≥ minM axDist(p 񮽙 , S 1 ).
An example of Lemma 2 and 3 is illustrated in Figure 8.
For clarity, we only keep the information of partition 1.
Point p is an arbitrary point within O 1 in partition 1.
An illustration of Lemma 2 is, by moving p along the x-axis towards p 񮽙 , minM axDist(p, S 1 ) increases.
Therefore, minM axDist(p 񮽙 , S 1 ) > minM axDist(p, S 1 ).
An illustration of Lemma 3 is, by moving, now, p 񮽙 on the intersection segment towards p 񮽙񮽙 , minM axDist(p 񮽙 , S 1 ) increases,too.
Therefore, minM axDist(p 񮽙񮽙 , S 1 ) > minM axDist(p 񮽙 , S 1 ).
As a corollary of Lemma 2 and 3, we have:Theorem 3 For any point p ∈ O 1 , there exist a corner point or intersection point p 񮽙񮽙 , such that minM axDist(p 񮽙񮽙 , S 1 ) ≥ minM axDist(p, S 1 ).
This section designs an algorithm that computes top-t most influential sites, by examining an R-tree S of sites and an R-tree O of objects.
For each site s in the query result, any correct algorithm needs to visit the R-tree node that stores s, as well as all of its ancestor nodes.
We maintain a priority queue of entries (index entries or sites) from S, that are inside the query region Q.
The queue is called queue SIN .
For clarity, we assume each MBR of any index entry in S is either inside or outside Q.
In Section 4.4 we address the case when an MBR partially intersects Q.For each entry S j in queue SIN , we store two values minInfluence and maxInfluence.
If S j is a single site, these are a lower bound and an upper bound of its influence.
If S j is an index entry, these are a lower bound and an upper bound of the influence of the most influential site in the sub-tree of S j .
The algorithm stops when there are t sites in queue SIN , each of which has a minInfluence no less than the largest maxInfluence of all remaining entries.
The algorithm aims at quickly making the estimates accurate, while focusing on expanding index entries which are highly likely to contain some of top-t most influential sites.
To expand an index entry e, it is replaced by the entries in the R-tree node referenced by e. Clearly, we cannot ignore the entries from S whose MBRs are outside Q, or the entries from O.
We maintain two queues, queue SOU T (reads Q-ESS-OUT) and queue O , for these entries.
Similar to the case of queue SIN , at the beginning of the algorithm these two queues contain some entries in the root nodes of S and O, which may be expanded as the algorithm runs on.There are some challenging issues.
One issue is, how to set and update minInfluence and maxInfluence of entries in queue SIN ?
A crucial sub-issue is how do we determine whether some O i in queue O affects some S j in queue SIN or queue SOU T .
(Recall that O i affects S j , if and only if there does not exist another entry S k in queue SIN or queue SOU T , such that minExistDN N S k (O i ) < minDist(O i , S j ).)
Another issue is, how to choose an index entry to expand?
As mentioned in the introduction, a good expanding strategy should consider the actual data and should satisfy certain goals that increase the efficiency of the algorithm.Section 4.1 formally defines the three queues and discusses how to set minInfluence and maxInfluence.
Section 4.2 presents our algorithm, which embodies the strategy of choosing index entries to expand.
Section 4.3 explores in more detail one step in the algorithm, which is to determine whether it is highly likely that an entry in queue O can be pruned (because it does not affect any entry in queue SIN ).
With the introduction of yet another new metric called minMinExistDNN, we can mathematically measure the probability that some O i in queue O can be pruned by some S j in queue SOU T .
Finally, Section 4.4 extends the solution to the general case when the MBR of an index entry in S may partially intersect Q. To clearly define what we store in each of the three queues, let's introduce two concepts.
An index entry e, from either S or O, is said to be an expanded entry (by our algorithm), if the content of the tree node referenced by e has been examined.
That is, if the node has been retrieved from disk.
All entries in an examined tree node are said to be visited.
The three queues we use can only contain visited but not expanded entries.
A non-visited entry is in some node not yet retrieved from disk.
An expanded entry has been removed from the queues.
We have:• queue SIN = {S j |S j is a visited but not expanded entry in S, whose MBR is inside Q and whose maxInfluence>0}.
• queue O = {O i |O i is a visited but not expanded entry in O, which affects some entry in queue SIN }.
• queue SOU T = {S j |S j is a visited but not expanded entry in S, whose MBR is outside Q and which is affected by some entry in queue O }.
Here the maxInfluence for an entry S j in queue SIN is the total weight of visited but not expanded entries in O that affect S j .
If S j has maxInfluence=0, all sites in S j have influence=0, and there is no need to keep S j in queue SIN .
The only reason we keep queue O and queue SOU T is to compute the minInfluence and maxInfluence of entries in queue SIN .
So queue O only consists of entries from O that affect at least one entry in queue SIN , and queue SOU T only consists of entries from S (but outside Q) that are affected by at least one entry in queue O .
Here the minInfluence for an entry S j in queue SIN is a lower bound of the maximum influence for a site in S j .
It is computed in the following way.
Consider some O i in queue O which only affects S j , i.e. O i does not affect any other entry in queue SIN or queue SOU T .
Every object in O i considers some site in S j as the nearest site.
There must exist a site s 1 in S j whose influence is at least |O i |/|S j |.
Here |O i | is the total weight of objects in the sub-tree of O i , while |S j | is the number of sites in the sub-tree of S j .
If there is another O 񮽙 i which only affects S j , there must exist a site s 񮽙 1 in S j whose influence is at least (|O i | + |O 񮽙 i |)/|S j |.
In general, the minInfluence of an index entry S j in queue SIN is the 񮽙 (|O i |)/|S j | for every O i in queue O that only affects S j .
This is also true in case S j is a site (|S j | = 1).
To maintain the content of the three queues, we need to know which O i affects which S j .
If an algorithm naively considers every MBR in O to affect all MBRs in S, it either fails to identify the most influential sites, or is very inefficient.
We should be able to find the minimum number of entries in queue SIN and queue SOU T affected by each entry in queue O .
We have addressed this issue in Section 3, where we pointed out that O 1 does not affect S 2 , if there existsS 1 such that minExistDN N S1 (O 1 ) > minDist(O 1 , S 2 ).
An implementation detail is that in queue O each O i maintains a list of pointers, one to each affected S j in queue SIN and queue SOU T .
Likewise, each S j keeps a list of pointers, one to each O i that affects it.
Our algorithm which computes top-t most influential sites is shown in Figure 9.
A crucial operation throughout the algorithm is expand.
To expand an index entry from one of the three queues, we remove it as well as the links to it, while trying to insert entries in the referenced node into the same queue.
For instance, suppose we want to expand an index entry S j in queue SIN (expanding an index entry in queue O or queue SOU T is similar).
There must have some entries in queue O which affect S j .
In our data structure, S j keeps a list of pointers, referencing its affecting entries in queue O .
And each O i in queue O also points to S j .
These links should be removed.
When examining the node referenced by S j , we try to insert each child entry into the same queue as S j .
Here to identify the entries in queue O that may affect a child entry, we only need to examine an O i if it used to affect S j .
More formally, we have:Theorem 4 If O i does not affect S j , none of its children will affect S j .
If S j is not affected by O i , none of its children will be affected by O i .
Due to entry expansions, we may need to reevaluate the associations of some queue entries.
Two simple pruning cases are (1) if a queue entry S j is not affected by any O i 's, remove S j from the queue; (2) if O i does not affect any entry in the queue SIN , remove O i from the queue.
There is another more subtle case as follows.
Suppose S j is expanded, and let S k be an entry in the referenced node.
S k is checked for associations against O i that affects S j .
If S k is affected by O i , we need also to examine if any entry originally affected by O i could be pruned from O i using minExistDN N sj (O i ).
Step 1 of the algorithm examines the root nodes of O and S and builds up the three queues.
This step works in the following way.
First, the entries in the root node of S, whose MBRs are inside Q, are pushed into queue SIN .
Then, we select the entries from the root node of O that affect at least one entry in queue SIN , and push them into queue O .
Third, we push into queue SOU T the root entries of S which are affected by some entries in queue O .
Finally, the entries in queue SIN not affected by any entry in queue O are removed.Step 2 is a stopping condition.
The algorithm stops when t most influential sites are identified.
Note that our algorithm can return a site without computing its actual influence.
As long as the minInfluence of a site is big enough, we can report it.
Of course, if we want to find the actual influence, we can keep expanding nodes until its minInfluence and maxInfluence become equal.Step 3 makes sure that queue SIN has at least certain number of entries.
The intuition is that if there are only a few sites in Q, the algorithm should focus on expanding most or all of them before expanding entries in queue O or queue SOU T .
Step 4 picks the set (called topβSIN ) of β entries from queue SIN with maxInfluence.
The rationale is Algorithm TopInfluentialSites(O, S, t, Q).
Input: An R-tree O of objects, an R-tree S of sites, an integer t, and a spatial region Q Action: Return the top-t most influential sites in Q.1.
Push the root entries of O and S into queueSIN , queueO and queueSOUT .2.
If the t entries from queueSIN with maximum maxInfluence are all sites, with minInfluence no less than the maxInfluence of all remaining entries in queueSIN , return these t sites as query result.3.
While |queueSIN | < β (for a given constant β ≥ 1), expand all index entries in queueSIN .4.
Pick and expand β most influential entries in queueSIN .
Let topβSIN be the β entries in queueSIN with maximum influence.5.
Let CO be the set of every Oi in queueO that affects at least one entry in topβSIN .6.
for every Oi in CO 6.1 Compute the largest probability that Oi can be pruned by expanding some Sj in queueSOUT .6.2 If this probability is above γ (for a given constant γ ∈ [0, 1]), expand the corresponding Sj.7.
Let impOi be the most important Oi ∈ CO.8.
While there exists an Sj in queueSIN or queueSOUT whose MBR contains the MBR of impOi, expand that Sj.9.
If there exists an Sj in queueSIN or queueSOUT more important than impOi, expand that Sj .10.
If impOi is an index entry which affects multiple inqueue entries from S, expand Oi.
Step 2.
that we want to focus on expanding the index entries whose corresponding sub-trees may contain some of the top-t most influential sites.
The index entries among them are expanded once.
Then we need to give the related entries from the other two queues a chance.
So Step 5 picks the set (called C O ) of entries from queue O that affect some entries in topβSIN .
At Step 6, we handle the case when some entry in C O has high probability to be pruned by expanding some entry S j in queue SOU T .
In this case, we should expand S j to prune that entry in C O .
This will result in more accurate influence estimation for entries in the picked topβSIN .
This topic, including a mathematical definition of the probability, is discussed in detail below in Section 4.3.
At this step, we want to work on making the minInfluence and maxInfluence estimations of entries in topβSIN as accurate as possible.
That is to say, we need to focus on an entry in C O which, if expanded, will maximally increase the accuracy of the most number of estimations of entries in topβSIN .
Step 7 picks such an entry O i , which is the most important.
Here the importance of O i is defined as:|O i | * (# affected entries in topβSIN ) * area(O i )Intuitively,• If the total weight of objects in O i is large, O i is important.
To know more precisely how this large weight is actually distributed is beneficial.
• If O i affects many entries in topβSIN , O i is important, for its total weight contributes to maxInfluence of all those entries.
• If O i has a large area, it is important.
Suppose some O 񮽙 i has a tiny area.
Even though it may have a large total weight of objects and it may affect many entries in topβSIN , expanding it may not help for every child entry may affect all the entries that O 񮽙 i currently affects.Step 8 shows the case when there exists an entry S j that spatially contains the most important O i .
In this case, however deep we expand O i , all of its descendant entries will affect S j .
So we make sure such an S j does not exist.
Now we want to give a chance to entries in queue SOU T or queue SIN , which are affected by some entry in C O .
Step 9 says we should expand such an S j if it is more important than O i .
Intuitively, if S j is affected by many entries in C O , and if S j has a large area, it is more important.
Our policy is, S j is more important than O i , ifarea(S j ) * (# entries in C O that affect S j ) > α * area(O i ) * (# entries in topβSIN affected by O i )Here we use some chosen constant α to control how likely to expand some entry S j , which is affected by some entries in C O .
A larger α means S j is less likely to be expanded.
in queue O by Expanding An Entry in queue SOU T Step 6 of Algorithm TopInfluentialSites, we expand an entry S j such that by expanding it, the probability of pruning the previously picked O i is above a threshold γ.
Here we consider the probability that there exists a child entry of S j , say child, that satisfies:minExistDN N child (O i ) < minDist(O i , S k ),where S k is the entry in queue SIN with the minimum minDist from O i .
In Figure 10(a), even though S j cannot be used to prune O i , it is very likely that some child entry in S j has a much smaller minExistDN N with O i , and therefore the probability is high.
On the other hand, Figure 10(b) shows a case with a small probability.
Intuitively, in the latter case S j is small, and thus expanding it to its child entries may not reduce the minExistDN N very much.
Our goal in this section is to mathematically define this probability.
To do so, we first introduce a new metric called minM inExistDN N .
Definition 3 Given MBRs O i and S j , the smallest possible minExistDNN of O i with regards to any MBRcontained in S j , is minMinExistDNN S j (O i ) = min rect⊆Sj {minExistDN N rect (O i )} We already know that minDist(O i , S k ) ≤ minExistDN N Sj (O i ), for otherwise O i should have already been pruned by S j .
Definition 3 implies that if minDist(O i , S k ) ≤ minM inExistDN N Sj (O i ), the probability of having O i pruned by expanding S j is 0.
So let's assume that minDist(O i , S k ) is between minM inExistDN N Sj (O i ) and minExistDN N Sj (O i ).
The probability of having O i pruned by expanding S j is formally defined asminDist(O i , S k ) − minM inExistDN N Sj (O i ) minExistDN N Sj (O i ) − minM inExistDN N Sj (O i )To see that this is a reasonable probability, we point out that if minDist(O i , S k ) changes from minM inExistDN N Sj (O i ) to minExistDN N Sj (O i ), the probability increases from 0 to 1, which matches our intuition.The algorithm to compute minM inExistDN N Sj (O i ) is: pick the location l in S j which has minimum distance to the center of O i , and return the maximum distance from l to a corner of O i .
Due to space limitations the proof is omitted.
An illustration of this new metric appears in Figure 11.
May Intersect with Q So far we have assumed that no index entry's MBR, in the R-tree S of sites, intersects with the query region Q.
This unrealistic assumption is only used to simplify the presentation of our algorithm.
We can easily extend our algorithm to handle the general case without this assumption.
The changes that need to be made are as follows.
First, queue SIN also contains index entries from S whose MBRs intersect with Q. Second, to compute the minDist between some O i to an entry S j in queue SIN , use the intersection part between S j 's MBR and Q. Finally, suppose an edge of some S j , whose MBR intersects with Q, is completely outside Q.
This edge should be stored as an entry in queue SOU T so as to increase the chance of pruning entries in queue O .
We compare our algorithm TopInfluentialSites with the Voronoi based method extended from [SRAE01].
In particular, we implement the optimized version of the Voronoi based method, such that if a Voronoi cell fully contains a subtree, we do not expand that subtree.
Both algorithms store sites and objects in Rtrees.
The fan-out of each node in an R-tree is 40% of the capacity.
The node capacity varies from 1KB to 4KB in different experiments.
We also utilize an LRU buffer with capacity varying from 64 disk pages to 512 disk pages, for each R-tree.
All the data structures and algorithms are coded using Java, and ran on a PC with 2.66-GHz Pentium 4 processor.In the experiments, We use real data of the Digital Chart of the World taken from the R-tree-Portal [The03].
One dataset consists of 24,493 populated places in North America, and another dataset contains 9,203 cultural landmarks in North America.
These two data sets form two combinations of sites and objects.
One takes the cultural landmarks (9,203 points) as the sites data and the populated places (24,493 points) as the objects data.
The ratio between # sites and # objects is 1 : 2.5.
Another combination is the reverse case, where the ratio is 2.5 : 1.
Our experiments are performed on both combinations of datasets.
The weight of an object is 1, i.e., the influence of a site is the number of its RNNs.
In our experiments, we choose the value of three parameters α, β and γ experimentally.
Due to space limitations, the experiment charts are omitted, and the results are reported as follows.We choose t = 4 and β = t.
In fact, our preliminary results show that with the increase of t, our algorithm is not affected much.Recall that γ determines whether an entry in queue O should be expanded (Section 4.3).
Intuitively, if γ is small, we may expand many site MBRs, while if γ is large, we may not expand any of the site MBRs.
Our experimental results show that when γ is between 0.5 to 0.7, the performances differ a little.
In the following experiments, we choose γ = 0.5.
Finally, α determines whether S j is more important than O i in step 9 of the algorithm TopInfluentialSites (Figure 9).
Our preliminary results show that in order to make S j and O i comparable, the value of α depends on the ratio between # sites and # objects.
In our algorithm, we choose α to be the ratio.
In our experiments, we compare our method and the Voronoi based method extensively by varying the query size, the page size and the buffer size.
In this section, We denote the algorithm TopInfluentialSites as TIS and the Voronoi based method as Voronoi.
Except otherwise stated, the page size of an R-tree is 1KB and each R-tree uses an LRU buffer with capacity of 128 pages.
Our results are the average of ten runs.
Notice that all figures comparing Voronoi and TIS used logarithmic scales.We first compare the number of disk page accesses by varying the query size, when #sites : #objects = 1 : 2.5.
Figure 12(a) shows the comparison of the total disk I/Os of both site R-tree and object R-tree, and in Figure 12(b), we compare them separately.
Notations of Voronoi (obj), Voronoi (sites), TIS (obj) and TIS (site) represent the disk I/Os on the object Rtree and site R-tree using Voronoi or TIS, respectively.TIS greatly outperforms Voronoi on all query sizes.
As shown in Figure 12(a), when the query size is small (0.001% and 0.01%), Voronoi is barely comparable to TIS.
With the increase of the query size, the disk I/Os of Voronoi increases almost exponentially.
This is because, for every site in the query range, Voronoi based method performs nearest neighbor and range queries on the site R-tree to compute its Voronoi cell, and then performs range query (using the Voronoi cell) on the object R-tree.
When the query size increases, the number of sites inside the query increases dramatically, therefore, the number of range queries performed on both R-trees increases as well.
number of disk I/Os on the site R-tree is comparable to that on the object R-tree.
We also perform range queries by varying the query size, when #sites : #data = 2.5 : 1, as shown in Figure 13.
Similar to the previous experiment charts, Figure 13(a) shows the comparison of total disk I/Os and Figure 13(b) shows the I/Os on the site R-tree and the object R-tree separately.Again TIS outperforms Voronoi in all query sizes.
In this case, the number of sites is much larger than the number of objects, and queries with small sizes contain many sites.
Therefore, compared to the case of site-object ratio being 1 : 2.5, the number of disk I/Os of small queries are much larger.
Especially, as shown in Figure 13(b), the disk I/Os on the site R-tree dominates the total disk I/Os in the Voronoi method.In both cases of Figure 12 and Figure 13, our method (TIS) shows stability to the data sets and the query size, because (1) we examine both trees in only one pass, (2) we visit a node from either trees only if necessary.In the remaining experiments, we use #sites : #objects = 1 : 2.5.
In Figure 14, the page size varies from 1KB to 4KB, and the buffer size (128 pages) is unchanged.
The size of range query is 1% of the whole space.
When the page size is 1KB, the number of entries in each node is around 45.
With the increase of page size, the number of tree nodes decreases.
Therefore, the number of disk I/Os in both methods drops dramatically.
Still, TIS is better than Voronoi by an order of magnitude in all cases.
In Figure 15, the performances are compared under various sizes of the LRU buffer.
The buffer size is changed from 64 pages to 512 pages.
With the page size being 1KB, the total number of nodes of the object R-tree and that of the site R-tree are 1010 and 380, respectively.
It is intuitive that when the size of the LRU buffer increases, the number of disk I/Os decreases.
The number of disk I/Os drop dramatically when the buffer size increases to 512 pages, since most pages could be accommodated in the buffer.
Again, TIS outperforms Voronoi in all cases, while the difference narrows with the increase of the buffer size.Finally, with regard to the algorithm TopInfluentialSites, we also compare our strategy of expanding the entries in the queues with the naive round robin strategy.
In Figure 16, we still denote our strategy as TIS and the round robin strategy as TIS RR.In Figure 16, we perform queries with different sizes using both strategy, and our carefully designed strategy outperforms the naive one in all cases.
With the increase of the query size, the number of entries in three queues increases, and choices of picking an entry to expand become more important as we do not want to expand all entries.
Therefore, the difference of two strategies increases.
This paper addressed the new problem of finding topt most influential spatial sites.
An existing work on finding RNNs [SRAE01] can be extended to solve this problem.
However, the approach is inefficient as it needs to browse both the site R-tree and the object R-tree many times.
We proposed an algorithm called TopInfluentialSites, which solved the problem by browsing both R-trees once.
The algorithm possesses pruning ability based on a novel metric called minExistDNN.
Experimental results on real datasets have revealed more than an order of magnitude improvement on the query performance.
