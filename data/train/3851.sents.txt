Secure two-party computation allows two mutually distrusting parties to jointly compute an arbitrary function on their private inputs without revealing anything but the result.
An interesting target for deploying secure computation protocols are mobile devices as they contain a lot of sensitive user data.
However, their resource restriction makes the deployment of secure computation protocols a challenging task.
In this work, we optimize and implement the secure computation protocol by Goldreich-Micali-Wigderson (GMW) on mobile phones.
To increase performance , we extend the protocol by a trusted hardware token (i.e., a smartcard).
The trusted hardware token allows to pre-compute most of the workload in an initial-ization phase, which is executed locally on one device and can be pre-computed independently of the later communication partner.
We develop and analyze a proof-of-concept implementation of generic secure two-party computation on Android smart phones making use of a microSD smartcard.
Our use cases include private set intersection for finding shared contacts and private scheduling of a meeting with location preferences.
For private set intersection, our token-aided implementation on mobile phones is up to two orders of magnitude faster than previous generic secure two-party computation protocols on mobile phones and even as fast as previous work on desktop computers.
Secure two-party computation allows two parties to process their sensitive data in such a way that its privacy is protected.
In the late eighties, Yao's garbled circuits protocol [Yao86] and the protocol of GoldreichMicali-Wigderson (GMW) [GMW87] showed the feasibility of secure computation.
However, secure computation was considered to be mostly of theoretical interest until the Fairplay framework [MNPS04] demonstrated that it is indeed practical.
Since then, many optimizations have been proposed and several frameworks have implemented Yao's garbled circuits protocol (e.g., FastGC [HEKM11]) and the GMW protocol (e.g., the framework of [CHK + 12]) on desktop PCs.Motivated by the advances of secure computation on desktop PCs, researchers have started to investigate whether secure computation can also be performed in the mobile domain.
Mobile devices, in particular smartphones, are an excellent environment for secure computation, since they accompany users in their daily lives and typically hold contact information, calendars, and photos.
Users also store sensitive data, such as passwords or banking information on their devices.
Moreover, typical smartphones are equipped with a multitude of sensors that collect a lot of sensitive information about their users' contexts.
Therefore, it is of special importance to protect the privacy of data handled in the mobile domain.In contrast to desktop PCs, mobile devices are rather limited in computational power, available memory, communication capabilities, and most notably battery life.
Although mobile phones have seen an increase in processing speed over the past years, they are still about one order of magnitude slower than typical desktop computers when evaluating cryptographic primitives (cf. §5.4).
These differences are due to the CPU architectures having a more restrictive instruction set and being optimized for low power consumption rather than performance, since mobile devices are battery-powered and lack active cooling.
Moreover, the limited size of the main memory requires the programmer to carefully handle data objects in order to avoid costly garbage collections on Java-based Android smartphones.
Network connections of mobile devices are almost exclusively established via wireless connections that have lower bandwidth and higher, often varying latency compared to wired connections.
Tasks that are computationally in-tensive or require long send/receive operations should be avoided when a mobile device is running on battery, as such tasks quickly drain the battery charge and thereby reduce the phone's standby time.
Instead, such operations could be pre-computed when the mobile device is connected to a power source, which usually happens overnight.
These limitations pose a big challenge for efficient secure computation and cause generic secure computation protocols to be several hundred times slower on mobile devices than on desktop PCs [HCE11], even in the semi-honest adversary model.To enable secure two-party computation in the mobile domain, solutions have been developed that outsource secure computation to the cloud, e.g., [KMR12, Hua12, CMTB13].
However, recent events have shown that cloud service providers can be forced to give away data to third parties that are not necessarily trusted, such as foreign government agencies.
Even if the employed protocols ensure that the cloud provider learns no information about the users' sensitive data, he can still learn and hence be forced to reveal meta-information such as the frequency of access, communication partners involved, the computed function, or the size of the inputs.
Moreover, these server-aided approaches require the mobile device to be connected to the Internet which might not be possible in every situation or may cause additional costs.An alternative solution, which we also use in this work, is to outsource expensive operations to a trusted hardware token that has very limited computational resources and is locally held by one of the communication partners.
1 Such hardware tokens are increasingly being adopted in practice, e.g., trusted platform modules (TPMs).
Their adoption is particularly noteworthy on mobile devices in the form of smartcards that are the basis for subscriber identity modules (SIM cards), as well as for mobile payment or ticketing systems.
A first approach for outsourcing Yao's garbled circuits protocol to such a trusted hardware token was proposed in [JKSS10].
However, this protocol requires the function to be known in advance and uses costly symmetric cryptographic operations during the online phase.
We give an alternative solution that removes these drawbacks.
In this work, we introduce a scheme for token-aided adhoc generic secure two-party computation on mobile devices based on the GMW protocol.
After introducing preliminaries ( §2) we detail our setting and trust assumptions that are similar to the ones in a TPM scenario ( §3).
We outline how a trusted hardware token can be used to shift major parts of the workload into an initialization phase that can be pre-computed on the token, independently of the later communication partner ( §4), e.g., while the mobile device is charging.
We thereby obtain a token-aided scheme that is well-suited for efficient and decentralized (ad-hoc) secure computation in the mobile domain.
We implement and evaluate our scheme ( §5) and demonstrate its performance using typical secure computation applications for mobile devices, such as securely scheduling a meeting with location preferences and privacy-preserving set intersection ( §6).
We compare our scheme to related work ( §7) and conclude and present directions for future work ( §8).
More detailed, our contributions are as follows.Token-Aided Ad-Hoc Secure Two-Party Computation on Mobile Devices ( §4) We develop a token-aided secure computation protocol which offloads the main workload of the GMW protocol to a pre-computation phase by introducing a secure hardware token T , held by one party A (cf. §3).
T is issued by a trusted third party and provides correlated randomness [Hua12, Chap.
6] to both parties that is later used in the secure computation protocol.
To prepare the secure computation, the other party B obtains seeds for his part of the correlated randomness from T via an encrypted channel.
To further increase flexibility, we describe how to make the pre-computation independent of the size of the evaluated function | f |, at the cost of a t · log 2 | f | factor communication overhead between T and B, where t is the symmetric security parameter.
In contrast to Yao-based approaches [MNPS04,JKSS10,HCE11,HEK12] and previous realizations of the GMW protocol [CHK + 12, SZ13, ALSZ13], our protocol offers several benefits as summarized in Tab.
1 (cf. §4.5 for details).
Implementation ( §5) We implement our token-aided protocol for semi-honest participants and evaluate its performance using two consumer-grade Android smartphones and an off-the-shelf smartcard.
Thereby, we provide an estimate for the achievable runtime of generic se-cure computation in the mobile domain.
Our implementation enables a developer to specify the functionality as a Boolean circuit, which can, for instance, be generated from a high-level specification language.
We show that the performance of our token-aided pre-computation phase is comparable to interactively generating the correlated randomness using oblivious transfer.Applications ( §6) We demonstrate the practical feasibility of the GMW protocol on mobile devices by performing secure two-party computation on two smartphones using various privacy-preserving applications such as availability scheduling ( §6.1), location-aware scheduling ( §6.2), and set-intersection ( §6.3).
Most notably, for private set-intersection, our token-aided scheme outperforms related work that evaluates generic secure computation schemes on mobile devices [HCE11] by up to two orders of magnitude and has a performance that is comparable with secure computation schemes that are executed in a desktop environment [HEK12].
In the following, we define our notation ( §2.1) and the ad-hoc scenario ( §2.2), and give an overview of oblivious transfer ( §2.3) and the GMW protocol ( §2.4).
We describe Yao's garbled circuits in the full version [DSZ14].
We denote the two parties that participate in the secure computation as A and B.
We use the standard notation for bitwise operations, i.e., x ⊕ y denotes bitwise XOR, x ∧ y bitwise AND, and x||y the concatenation of two bit strings x and y.
We refer to the symmetric security parameter as t and the function to be evaluated as f .
In an ad-hoc secure two-party computation scenario, two parties that do not necessarily know each other in advance want to spontaneously perform secure computation of an arbitrary function f on their private inputs x and y. Traditionally, secure computation protocols consist of two interactive phases: the setup phase (independent of x and y) and the online phase.
We extend this setting by a local init phase as depicted in Fig. 1.
The init phase takes place at any time before the parties have identified each other and is used for preprocessing.
In the setup phase, the parties have determined their communication partner, establish a communication channel, and know an upper bound on the function size | f |.
In the online phase, the parties provide their private inputs x and y to the function f that they want to evaluate and begin the secure computation.
The ad-hoc time is the combined time for setup and online phase.
Oblivious transfer (OT) is a fundamental building block for secure computation.
In an OT protocol [Rab81], the sender inputs two strings (s 0 , s 1 ).
The receiver inputs a bit c ∈ {0, 1} and obtains s c as output without revealing to the sender which of the two messages he chose and without the receiver learning any information about s 1−c .
OT protocols, such as [NP01], require public-key cryptography and make OT a relatively costly operation.OT extension [IKNP03] allows to increase the efficiency of OT by extending a small number of t base OTs to a large number n 񮽙 t of OTs whilst only using O(n) symmetric cryptographic operations.
Optimizations to the OT extension protocol of [IKNP03] were suggested in [ALSZ13], which allow the parties to reduce the amount of data sent per OT.
Moreover, [ALSZ13] describes a more efficient variant of the OT extension protocol for computing random OT, where the sender obtains two random values as output of the OT protocol.
In the GMW protocol [GMW87], two (or more) parties compute a function f , represented as Boolean circuit on their private inputs by secret sharing their inputs using an XOR secret sharing scheme and evaluating f gate by gate.
Each party can evaluate XOR gates locally by computing the XOR of the input shares.
AND gates, on the other hand, require the parties to interact with each other by either evaluating an OT or by using a multiplication triple [Bea91] as shown in the full version [DSZ14].
Finally, all parties send the shares of the output wires to the party that shall obtain the function output.
The main cost factors in GMW are the total number of AND gates in the circuit, called (multiplicative) size | f |, and the highest number of AND gates between any input wire and any output wire, called (multiplicative) depth d( f ).
Because an interactive OT is required for each AND gate, it was believed that GMW is very inefficient compared to Yao's garbled circuits.
However, in [CHK + 12] it was shown that by using OT extension [IKNP03] and OT pre-computation [Bea95] many OTs can be pre-computed efficiently in an interactive setup phase.
Thereby, all use of symmetric cryptographic operations is shifted to the setup phase, leaving only efficient onetime pad operations for the online phase.
Additionally, the setup phase only requires an upper bound on | f | to be known before the secure computation.
Follow-up work of [SZ13] demonstrated that, by using OT to precompute multiplication triples in the setup phase, the online phase can be further sped up.
Multiplication triples are random-looking bits a i , b i , and c i , for i ∈ {A, B}, sat-isfying (c A ⊕ c B ) = (a A ⊕ a B ) ∧ (b A ⊕ b B ), that are held by the respective parties and used to mask private data during the secure computation.
This masking is done very efficiently, since no cryptographic operations are required.
In [ALSZ13] it was shown that multiplication triples can be generated interactively using two random OTs.
[Hua12] proposed to let a trusted server generate the multiplication triples and send (a i , b i , c i ) to party i over a secure channel via the Internet.
In our work, we propose to do this locally, without knowing the communication partner in advance.
In our setting, depicted in Fig. 2, we focus on efficient ad-hoc secure computation between two semihonest (cf. §3.1) parties A and B who each hold a mobile device, which are approximately equally powerful but significantly weaker than typical desktop computer systems.
The parties' devices are connected via a wireless network and are battery-powered.
A holds a general-purpose tamper-proof hardware token T that has very few computational resources.
T is powered by A, and its functionalities are limited to the standard functionalities described in §3.2.
A and T are connected via a physical low-bandwidth connection and communicate via a fixed interface.
B and T communicate via A, i.e., every message that B and T exchange, is seen and relayed by A. Note that this directly requires all communication between B and T to be encrypted such that it cannot be read by A.
We assume that T behaves semi-honestly, and is issued by a third party, external to and trusted by both A and B (cf. §3.2).
We assume that both parties behave semi-honestly in the online phase, i.e., they follow the secure computation protocol, but may try to infer additional information about the other party's inputs from the observed messages.
To the best of our knowledge, all previous work on secure computation between two mobile phones is based on the semi-honest model (cf. §7.1).
The semi-honest model is suitable in scenarios where the parties want to prevent inadvertent information leakage and for devices where the software is controlled by a trusted party (e.g., business phones managed by an IT department) or where code attestation can be applied.
Moreover, this model gives an estimate on the achievable performance of secure computation.
We outline how to extend our protocol to malicious security in the full version [DSZ14].
We use the term trusted hardware token T to refer to a tamper-proof, programmable device, such as a Java smartcard, that offers a restricted set of functionalities.
Such functionalities include, for instance, hashing, symmetric and asymmetric encryption/decryption, secure storage and secure random number generation.
A detailed summary of standard smartcard functionalities is given in [HL08].
The hardware token is passive, i.e., it cannot initiate a communication by itself and only responds to queries from its host.
It contains both persistent and transient memory.
T is physically protected against attacks and is securely erased if it is opened by force.
Each token holds an asymmetric key pair, similar to an endorsement key used in TPMs [TCG13], where the public key is certified by a known trusted third party and allows unique identification of T .
Tiny Trusted Third Party T acts as a tiny trusted third party that behaves semi-honestly.
This assumption is similar to the TPM model that is widely used in desktop environments.
T only provides correlated randomness that is later used in the secure computation and does never receive any of A or B's private inputs.
We assume that only certified code is allowed to be executed on T , and that T can only actively deviate from the protocol if the hardware token's manufacturer programmed it to be malicious.
We assume the code certification was carried out by a trusted third party, and argue that both the manufacturer and the certification authority would face severe reputation loss if it was discovered that they built backdoors into their products.
Moreover, we assume that neither A nor B colludes with the hardware token manufacturer.
This non-collusion assumption is a common requirement for outsourced secure computation schemes such as [Hua12,KMR12,CMTB13] and enables the construction of efficient protocols.
Finally, note that, although T is in A's possession, A cannot easily corrupt T or obtain its internal information, since T is assumed to be tamper-proof and does not reveal internal secrets, i.e., the costs of an attack are higher than the benefits from breaking T 's security.
This assumption also holds if A colludes with or impersonates B.
A malicious adversary could try to break into the hardware token.
If such an attack is successful, the following standard countermeasures can be used to prevent further damage: A binding between token and key pair can be realized by using techniques such as physically uncloneable functions (PUFs), however, we are not aware of solutions that are available in commercial products.
To bind a token to a certain mobile device or person, T 's certificate could be personalized with one or multiple values that are unique per user and that can be verified over an off-band channel, such as the user's telephone number or the ID of the user's passport.
Another line of defense can be certificate revocation lists (CRLs) that allow the users to check if a token is known to be compromised or malicious.
In the following section, we give details on our tokenaided GMW-based protocol on mobile devices.
Our goal is to minimize the ad-hoc time, i.e., the time from establishing the communication channel between A and B until receiving the results of the secure computation.
We consider the init phase to not be time critical, but we try to keep its computational overhead small.
An overview of our protocol is given in Fig. 3.
The general idea is to let the hardware token generate multiplication triples from two (or more) seeds in the init phase that are independent of the later communication partner ( §4.1).
In the setup phase, T then sends one seed to A and the other seed over an encrypted channel to B ( §4.2).
The token thereby replaces the OT protocol in the setup phase and allows pre-computing the multiplication triples independently of the communication partner.
The online phase of the GMW protocol remains unchanged.
In order to overcome the restriction that the function size needs to be known in advance, we describe a method that pre-computes several multiplication triple sequences of different size and only adds a small communication overhead in the setup phase ( §4.3).
Finally, we analyze the security of our protocol ( §4.4) and compare its performance to previous solutions ( §4.5).
In the original GMW protocol, A and B interactively compute their multiplication triples (a n A , b n A , c n A ) and (a n B , b n B , c n B ) in the setup phase using 2n random OT extensions (cf. §2.4).
Instead, we avoid this overhead in the setup phase and let T pre-compute the multiplication triples in the init phase as shown in Fig. 4: T first generates random seeds and then expands these seeds internally into the multiplication triples and sends c n A to A. Seed Generation In the seed generation step, T generates two seeds Due to the limited memory of the hardware token, the sequence c n A is computed block-wise such that T requires only a fixed amount of memory, independently of n, and each block is sent to A, who stores it locally.
Note that the values (a n A , b n A , a n B , b n B , c n B ) do not need to be stored, since they can be expanded from s A and s B , respectively.s A = G k A (d) and s B = G k B (d) In the setup phase, the hardware token sends the seeds s A and s B to A and B, respectively, and the parties generate their multiplication triples as depicted in Fig. 5.
A obtains his seed s A directly from T and can read the sequence c n A , which was obtained in the init phase, from its internal flash storage.
B's seed s B , on the other hand, cannot be sent in plaintext from T to B as the communication between the token and B is relayed over A, which would allow A to intercept s B .
We therefore require the communication between B and T to be encrypted and T to authenticate itself to B with a certificate.
An encrypted and one-way authenticated communication channel can be established using a key agreement protocol from a wide variety of choices (cf. [MvOV96]).
We choose two protocols that allow us to handle different attacker models: For security against a malicious (active) A we use TLS [IET08] (with RSA for publickey crypto, AES for symmetric encryption, and HMAC as message authentication code) and for security against a semi-honest (passive) A we use KAS1-basic [NIS09] (with AES for symmetric encryption), cf. the full version [DSZ14] for details.
Both schemes use T 's publickey certificate that is signed by a trusted third party.
For every new connection this certificate is verified by B and optionally checked against a CRL and/or is checked to be consistent with A's identity over an out-of-band channel to protect against hardware attacks (cf. §3.2).
The multiplication triple generation described until now requires the function size n = | f | to be known beforehand.
While this may be the case for some functions, e.g., for set intersection using bitwise AND (cf. §6.1), the size of other functions depends on the number of inputs, e.g., the number of contacts in the address book (cf. §6.3).
The naive solution to not knowing n in advance would be to generate several multiplication triple sequences of fixed size 񮽙 in the init phase and send their 񮽙n//񮽙 seeds in the setup phase, when n is known.
However, on average this approach wastes 񮽙/2 multiplication triples and requires to send 񮽙n//񮽙 multiplication triple seeds.
Thus, a smaller 񮽙 results in fewer wasted multiplication triples but more communication overhead, while a higher 񮽙 results in more wasted multiplication triples but less communication.
Since typical function sizes in secure computation range from millions [HEKM11] to even a billion AND gates [CMTB13], an appropriate 񮽙 is difficult to choose.Instead of generating fixed-length blocks of multiplication triple sequences, we propose to generate m multiplication triple sequences s 0 , ..., s m−1 in the init phase, where s i contains 2 i (0 ≤ i < m) multiplication triples.
In the setup phase, we then send a set of multiplication triple seeds {s k | n k = 1}, where n k is the k-th bit of n.
This approach requires sending at most 񮽙log 2 n񮽙 seeds.
As communication between T and A is the bottleneck in our implementation, we set the smallest size of a multiplication triple sequence such that it fits into one packet.
In this section, we briefly analyze the security of our protocol for each of the three secure computation phases.Init Phase In the init phase no private inputs are involved and B is unknown.
Therefore, A can only try to manipulate the token, which is hard since the hardware token is tamper-proof.
Moreover, A receives only its c A shares that do not reveal anything about B's shares or T 's internal state, due to the cryptographically strong PRG.
The only attack a malicious A could play in the setup phase, is to impersonate B.
This attack is prevented, since every seed s B can only be queried once (cf. §4.1).
The communication between the hardware token and B is done through an encrypted channel, so that A cannot get access to those messages.
For active security, we use TLS and add a MAC to every packet to prevent modifications and avoid replay attacks.
B cannot actively attack the token since all communication to the hardware token is controlled by A. Obviously, any party can drop or ignore messages, but we exclude this simple denial of service attack from our system model since we assume both parties to be willing to participate in the secure computation.
The seeds that each party obtains from the hardware token do also not reveal any additional information since they are directly output from a cryptographically strong PRG to which the hardware token's internal state is used as seed.Online Phase The security for the online phase directly carries over from the GMW protocol, as we do not introduce any modifications to this phase.
We show that the asymptotic performance of our protocol improves over existing solutions.
A summary is shown in Tab.
1 on page 2 and a more detailed comparison is given in the full version [DSZ14].
An experimental evaluation of our protocol is provided in §5.4 and its performance on applications is evaluated in §6.
Asymptotic Performance The init phase of our protocol is, unlike [JKSS10], independent of a concrete instance of f and can thus be pre-computed without knowing a communication partner.
During the setup phase, the communication complexity of our protocol is only Concrete Performance For 80 bit security, the best known instantiation of Yao's garbled circuits protocol (resp.
the GMW protocol) require per AND gate 240 bit (resp.
164 bit) communication and 4 + 1 (resp.
12 + 0) evaluations of symmetric cryptographic primitives in the setup + online phase.
In comparison, our solution requires only 4 bit communication and 0.04 + 0 fixed-key AES operations per AND gate.O(t) (or O(t · log 2 | f |) if | f | is unknown), This section details the implementation of our scheme.
We introduce the smartcard that we use to instantiate the hardware token ( §5.1), give an overview of our Android implementation ( §5.2), outline our benchmarking environment ( §5.3), and experimentally compare the OT extension-based multiplication triple generation to our hardware token-based protocol ( §5.4).
In our implementation we instantiate the trusted hardware token T with the Giesecke & Devrient (G&D) Mobile Security Card SE 1.0 (MSC).
It is embedded into a microSD card that additionally contains 2 GB of separate flash memory.
The MSC is based on an NXP SmartMX P5CD080 micro-controller that runs at a maximum frequency of 10 MHz, has 6 kB of RAM, 80 kB of persistent EEPROM, and is based on Java Card version 2.2.2.
Note that an applet can only use 1,750 Bytes of the 6 kB RAM for transient storage.
The MSC has co-processors for 3DES, AES and RSA that can be called from a Java Card applet, as well as native routines for MD5, SHA-1 and SHA256.
The MSC runs the operating system G&D Sm@rtCafe Expert 5.0 which manages the installed Java Card applets, personalization data, and communication keys.
The communication between the Android operating system and the MSC is done by a separate service via the SIMalliance Open Mobile API.
The architecture of our implementation is depicted in Fig. 6.
To support flexibility and extensibility, our modular architecture consists of the Application that specifies the functionality, the GMWService that performs secure computation, and the MTService that performs the multiplication triple generation and transfer.
All communication between A and T is done via the MSC Smartcard Service supplied by G&D.
The Application can be implemented by a designer and specifies the desired secure computation functionality as a Boolean circuit that can, for instance, be compiled from a high-level circuit description language such as the Secure Function Definition Language (SFDL) [MNPS04, MLB12] or the Portable Circuit Format (PCF) [KMSB13].
The GMWService implements the GMW protocol and performs the secure computation, given a circuit description and corresponding inputs.
The MTService generates the multiplication triples using either OT extension (OTExt) based on the memory efficient implementation of [HS13] including the optimizations from [ALSZ13] or, if one of the parties holds a hardware token, our token-aided protocol of §4.
If a hardware token is present, the MTService manages the multiplication triple generation during the init phase by querying the token and storing the received c A sequences.
For the MSC, the multiplication triple generation on T is performed via a Java Card applet (MT JC Applet) that implements the functionality in §4.1 and is accessible through the Java Card interface.
Our implementation can be installed as a regular Android app and does not require root access to the smartphone or a custom firmware.
Secure computation is performed by having an Application running on each smartphone, which specifies the function f both parties want to compute securely.
From this function the Application generates a circuit description, which it sends to the GMWService.
The GMWService interprets the circuit and queries the MTService for the required number of multiplication triples | f |.
The MTServices on both smartphones then communicate with each other and check whether one of the smartphones holds a hardware token (A in Fig. 6).
If so, both MTServices perform the seed transfer protocol (cf. §4.2), expand the obtained seeds (A loads the corresponding c A sequences obtained in the init phase), and merge the obtained multiplication triple sequences (cf. §4.3).
If no hardware token is present, the MTServices generate the multiplication triples by invoking OT extension.
The MTService then provides the multiplication triples (a i , b i , c i ) for i ∈ {A, B} to the GMWService.
Finally, the Applications send their inputs x and y, respectively, to the GMWService, which performs the secure computation and returns the output z i = f (x, y).
For our mobile benchmarking environment we use two Samsung Galaxy S3's, which each have a 1.4 GHz ARMCortex-A9 Quad-Core CPU, 1 GB of RAM, 16 GB of internal flash memory, a mircoSD card slot, and run the Android operating system version 4.1.2 (Jelly Bean).
For the communication between the smartphones, we use Wi-Fi direct.
For the evaluation, we put the smartphones next to each other on a table.
The G&D mobile security card is connected to the mircoSD card slot of one of the phones.
We use the short-term security setting recommended by NIST [NIS12], i.e., a symmetric key size of 80 bits and a public key size of 1,024 bit with a 160 bit subgroup.
We instantiated the pseudo-random generator G that is used for seed expansion (cf. §4.1) with AES-128 in CTR mode.
The hardware token generates multiplication triple sequences of size 2 m for 11 ≤ m ≤ 24.
We used m = 11 as lower bound on the size, since 2,048 is the biggest size we can transfer from T to A with a single packet, and m = 24 as upper bound, since it was appropriate for our case studies in §6.
Finally, we point out that our implementation is single-threaded and utilizes only one of the four available cores of our smartphones.
We leave the extension to multiple threads as future work.
First, we want to quantify the runtime differences between the mobile and the desktop environment.
We measure the execution time for AES-128 in ECB mode for an identical single-threaded Java implementation in both domains.
The smartphone version is running with 5.5 MB/s while the desktop version achieves 61.1 MB/s.
The optimized AES-256 implementation of Truecrypt 3 , written in C/C++ and assembly, achieves 143.1 MB/s on the same desktop machine, running without parallelization.
For comparison, the smartcard (cf. §5.1) is running AES-128 at a maximum speed of 16.7 KB/s.
In the following we evaluate the performance of our token-based scheme (cf. §4) on smartphones, using TLS or KAS1-basic as key agreement protocol, and compare it to the OT extension based multiplication triple generation.
In our evaluations we only include the time for init and setup phase, since the online phase is identical for both approaches.
Results for the online phase are given in §6.
All values are averaged over 10 measurements.
Fig. 7 gives an overview over the timings for the generation of 2 m (11 ≤ m ≤ 24) multiplication triples using either OT extension in the setup phase or the hardware token ( §4.1) in the init phase.
Additionally, the setup phase using TLS and KAS1-basic is depicted, which includes the seed transfer and the seed expansion of B.
We always assume the worst case number of seeds to be transferred, i.e., for 2 24 multiplication triples, we transfer 24 − 10 = 14 seeds (cf. §4.3).
Both axes in Fig. 7 are given in a logarithmic scale.
We observe that OT extension on mobile devices is able to generate 2 24 multiplication triples in 1,529 s, corresponding to 10,971 multiplication triples per second.
We ran the same code on two desktop PCs with a 2.5 GHz Intel Core2Quad CPU and 4 GB RAM, connected via Gigabit LAN and were able to compute 2 24 multiplication triples in 139 s, which indicates a performance decrease of factor 11.
While the performance decrease on mobile devices compared to desktop computers was significantly less than the factor of 1000 observed in [HCE11], it is still insufficient for efficiently computing complex functions such as private setintersection, which typically requires millions of OTs.In comparison, the multiplication triple generation of the hardware token during the init phase is able to generate 2 24 multiplication triples in 2,883 s, corresponding to 5,819 multiplication triples per second.
For the hardware token-based protocol we observe that the times for sending the seeds using the TLS and KAS1 key agreement protocols grow very slowly with the number of multiplication triples, since the amount of data to be encrypted and sent grows only with log 2 | f |.
Additionally, the TLSbased key agreement protocol (4.6 s for 2 11 multiplication triples) is around factor 3 slower than the KAS1-based key agreement (1.3 s for 2 11 multiplication triples).
The overall computation and communication workload of OT extension is substantially larger than in our token-based scheme, but its multiplication triple generation rate is not much faster.
This can be explained by the faster processing power of the smartphones compared to that of T and the higher bandwidth of Wi-Fi direct compared to the relatively slow communication channel between A and T .
However, OT extension suffers from high energy consumption, due to the CPU utilization incurred by the symmetric cryptographic operations, as well as the Wi-Fi direct communication [PFW11].
We use PowerTutor 4 to measure the energy consumption of the smartphone's CPU for generating 2 19 multiplication triples and compare the interactive evaluation of random OT extensions with our smartcard solution.
Note that Fig. 8 only displays the CPU's energy consumption whereas the energy consumption of Wi-Fi and the smartcard is not included.
However, we argue that the energy consumption of the smartcard is not a critical factor, since these operations can be performed when the phone is charging.
The Wi-Fi connection, on the other hand, is required for OT during the setup phase, thus increasing the already high battery drain even further.
Moreover, the OT computations have to be done on both devices simultaneously, draining both devices' batteries.
Therefore, our token-based solution is particularly well-suited for the mobile domain, where energy consumption and battery lifetime are critical factors.
To evaluate the performance of our protocols, we use the mobile phones and setting as specified in §5.3 and consider the following privacy-preserving applications: availability scheduling ( §6.1), location-aware scheduling ( §6.2), and set intersection ( §6.3).
We implemented the applications and depict the performance results for an average of 10 iterations.
We use KAS1-basic [NIS09] as key authentication scheme.
We pre-generated the circuits using the framework of [SZ13], wrote them into a file, and read them on the smartphone.
The time for reading the circuit file is included in the setup phase.
Privacy-preserving availability scheduling is a common example for secure computation on mobile devices [HCC + 01, BJH + 11] and enables A and B to find a possible time slot for a meeting without disclosing their schedules to each other.
To schedule a meeting, A and B specify a duration and time frame for the meeting.
Each party i ∈ {A, B} then divides the time frame when the meeting can take place (e.g., a week) into n time slots t n i = (t i,1 , ...,t i,n ) and denotes each time slot t i, j ∈ {0, 1} as either free (t i, j = 1) or occupied (t i, j = 0).
The parties compute their common availability t n Avail by computing the bitwise AND of their time slots, i.e., t n Avail = t n A ∧ t n B .
Overall, this circuit has n AND gates and depth 1.
Note that the bitwise AND circuit performs a general functionality and can, for instance, be used for privacy-preserving set intersection where elements are taken from a small domain [HEK12] or location matching [CADT13].
For our experiments, we set the time frames s.t. meetings can be scheduled between 8 am and 10 pm for one day divided into 15 minute slots (n = 56 slots), one week divided into 15 minute slots (n = 392 slots), and one month divided into 10 minute slots (n = 2,604 slots).
We depict our results in the upper half of Tab.
2.
The multiplication triple generation in the init phase can be performed in several hundred milliseconds, since it requires only one (for 56 and 392 time slots) or two (for 2,604 time slots) packet transfers between T and A.
The setup phase, more detailed the seed transfer protocol, is the main bottleneck in this application, as T has to perform asymmetric and symmetric cryptographic operations.
Finally, the online phase requires only milliseconds but has a high variance, due to the communication over Wi-Fi direct and the small number of communication rounds that are performed in the online phase.For comparison, we evaluated the same circuit using the mobile Yao implementation of [HCE11] on the same phones, which took factor 1.6 (for the day time frame) up to factor 12 (for the month time frame) longer, cf. Tab.
2.
.1 | f | / d( f ) 56 / 1 392 / 1 2,604 / 1 Init [s] 0.37 (±1.6%) 0.37 (±1.6%) 0.73 (±1.0%) Setup [s] 1.3 (±13%) 1.3 (±13%) 1.3 (±13%) Online [s] 0.002 (±150%) 0.003 (±167%) 0.007 (±129%) Ad-Hoc [s] 1.3 (±13%) 1.3 (±13%) 1.3 (±13%) Mobile Yao [HCE11] Ad-Hoc [s] 2.14 (±7.1%) 3.82 (±4.7%) 15.9 (±2.7%) Location-Aware Scheduling §6.2 | f | / d( f ) 39,864 / 69 280,605 / 87 1,872,206 / 106 Init [s] 6.9 (±0.3%) 48.5 (±0.2%) 319.6 (±0.5%) Setup [s] 1.4 (±7.1%) 1.8 (±7.0%) 4.8 (±4.8%) Online [s] 0.16 (±35%) 0.82 (±7.4%) 5.9 (±18%) Ad-Hoc [s]1.5 (±8.4%) 2.6 (±6.5%) 10.7 (±11%) In the following we show that our system can be adapted to compute arbitrary and complex functions.
We introduce the location-aware scheduling functionality which extends the availability scheduling of §6.1, s.t. the distance between the users is considered as well.
The location-aware scheduling functionality takes into account the user's location in a time slot, computes the distance between the users, verifies if a meeting is feasible, and outputs the time slot in which the users have to travel the least distance to meet each other.
We argue that this approach is practical, since such position information are often already included in the users' schedules.In the location-aware scheduling scheme, we assume that the user i ∈ {A, B} also inputs the location of the previous appointment P i and the next appointment N i and the distances that he can reach from his previous appointment p i and from his next appointment n i (cf. Fig. 9 for an example).
Such p i and n i can be computed in plaintext using the distance between P i and N i , the free time until the next appointment and the duration of the meeting.
The minimal distance among all time slots where the reachable ranges for A and B overlap is selected as final result.
If successful, the function outputs the identified time slot and for each user whether he should leave from the location of the previous or next appointment.
A detailed description of the functionality is given in the full version [DSZ14].
We evaluate the scheme on the same number of time slots used in §6.1 (day, week, month) and depict the performance in the lower half of Tab.
2.
Compared to availability scheduling, the locationaware scheduling circuit is significantly bigger and requires more communication rounds.
When performing the scheduling for a month, the circuit consists of 1.8 million instead of 2,604 AND gates for availability schedul-P A p A n A N A N Bn B p B P B Figure 9: Location-aware scheduling for one time slot of A and B with previous locations P A and P B , reachable distances from previous appointments p A and p B , next locations N A and N B and corresponding reachable distances n A and n B .
The meeting can be scheduled between N A and P B as the reachable ranges overlap.ing.
The time for the init phase increases linearly with the number of AND gates and requires 319 s when performing scheduling for a month.
The time for the setup phase is increased less, since the seed transfer grows only logarithmically in | f | and the seed expansion is done efficiently.
The online phase is also slowed down substantially (6 s for a month time frame), but is still practical.
Private set intersection (PSI) is a widely studied problem in secure computation and can be used for example to find common contacts in users' address books [HCE11].
It enables two parties, each holding a set S A and S B with elements represented as σ -bit strings to determine which elements both have in common, i.e., S A ∩ S B , without disclosing any other contents of their sets.
While many special-purpose protocols for PSI exist, e.g., [CT10, CT12, CADT13], generic protocols mostly build on the work of [HEK12], where the Sort-Compare-Shuffle (SCS) circuit was outlined.
The idea is to have both parties locally pre-sort their elements, privately merge them, check adjacent values for equality, and obliviously shuffle the resulting values to hide their order.
We implement the SCS-WN circuit of [HEK12] which uses a Waksman permutation network to randomly shuffle the resulting elements.
We perform the comparison for bit sizes σ ∈ {24, 32, 160} and compare the ad-hoc runtime of our protocol to the implementation of [HCE11] for σ ∈ {24, 32}.
The results from [HEK12] are compared to ours for σ ∈ {32, 160}.
The results are given in Fig. 10 and in Tab.
3.
Note that [HCE11] and [HEK12] implement Yao's garbled circuits protocol using pipelining, whereas we use the GMW protocol.
For a fair comparison, we ran the code from [HCE11] on our Samsung Galaxy S3 smartphones and observed an approximate speedup of factor 2 compared to the measurements from their paper, that were made on older hardware (two Google Nexus One phones).
Note that our performance results, as well as the values for the implementation of [HCE11] are benchmarked on mobile devices connected via Wi-Fi Direct, while [HEK12] is benchmarked on two desktop PCs (two Core2Duo E8400 3GHz PCs connected via 100 Mbps LAN).
From Fig. 10 we observe that, due to the seed transfer in our setup phase (cf. §4.2), the Yao's garbled circuits implementation of [HEK12] is faster for up to 256 inputs.
However, the seed transfer time amortizes for larger inputs and our token-based scheme outperforms the imple- Table 3: Ad-hoc runtime of private set intersection where each party inputs n values of σ bits, measured on identical mobile phones ( §5.3).
[HEK12] results are on PCs and taken from the paper (-indicates that no numbers were given).
2.2 (±8.8%) 2.7 (±16%) 4.0 (±1.9%) 7.0 (±1.9%) 14.3 (±2.9%) 28.7 (±1.4%) [HEK12] [s] - - - - - 51.5mentation of [HEK12], even though our implementation runs on substantially slower mobile phones while theirs is evaluated on two desktop PCs.
From Tab.
3 we observe that our scheme outperforms the Yao's garbled circuits implementation of [HCE11], evaluated on identical mobile phones, by factor 18 for 32 inputs with σ = 24 bit and by up to factor 550 for 1,024 inputs with σ = 32 bit.
Finally, we compare the performance of our protocol to the PSI protocol of [CADT11,CADT13].
We use their reported numbers for pre-computed PSI on 20 input values and set the bit size σ = 160 in our protocol.
5 The protocol of [CADT11, CADT13] needs 3.7 s, while our ad-hoc runtime is only 2.1 s (±4.8%).
Note, however, that their approach has only a constant number of rounds and can be sped up using multiple cores.
We classify related work into three categories: secure function evaluation ( §7.1), server-aided secure function evaluation ( §7.2), and token-based cryptography ( §7.3).
The foundations for secure function evaluation (SFE) were laid by Yao [Yao86] and Goldreich et al. [GMW87] who demonstrated that every function that is efficiently representable as Boolean circuit can be computed securely in polynomial time with multiple parties.
Next to Yao's garbled circuits protocol, the GMW protocol [GMW87] recently received increasing attention.
The work of [CHK + 12] efficiently implemented GMW in a setting with multiple parties.
Subsequently, [SZ13] optimized GMW for the two-party setting and showed that GMW has advantages over Yao's garbled circuits protocol as it allows to pre-compute all symmetric cryptographic operations in a setup phase and that the workload can be split evenly among both parties.SFE on Mobile Devices A recent line of research aims at making SFE available on mobile devices, such as smartphones.
In [HCE11] the authors port the FastGC framework [HEKM11] to smartphones and observe a substantial performance reduction when compared to the desktop environment.
They identify the slower processing speed and the high memory requirements as the main bottlenecks.
Similarly, [CMSA12] ported the Fairplay framework [MNPS04] to smartphones.
A compiler with smaller memory constraints than Fairplay was presented in [MLB12].
We emphasize that previous works on generic SFE on mobile devices use Yao's garbled circuits protocol, whereas our approach is based on GMW.Several special-purpose protocols for mobile devices using homomorphic encryption were proposed in [BJH + 11] (activity scheduling), [CDA11] (scheduling, interest sharing), and [CADT11, CADT13] (comparison, location-based tweets, common friends).
In contrast to generic solutions, such custom-tailored protocols can be more efficient, but are restricted to specific functionalities.
Their extension to new use cases is complex and usually requires new security proofs.
One way to speed up generic secure computations on resource constrained devices is to outsource expensive operations to one or more servers.
In [HS12] a system for fair server-aided secure two-party computation using two servers was introduced.
SALUS [KMR12] is a system for fair SFE among multiple parties using a single server.
A system that allows cloud-aided garbled circuits evaluation between one mobile device and a server was introduced in [CMTB13] and its efficiency was demonstrated on large-scale practical applications, such as a secure path finding algorithm.
Both [CMTB13] and [KMR12] achieve security against malicious adversaries, but require at least one party to be a machine with more computing power than a mobile phone as it evaluates multiple garbled circuits.
[Hua12] proposes that a trusted server generates multiplication triples that are sent to both parties over a secure channel, requiring O(| f |) bits communication.
Instead, we propose to replace the server with a trusted hardware token and show that the communication to one party can be reduced to sub-linear complexity.
Moreover, they achieve security against malicious adversaries based on [NNOB12]; we sketch how to extend our work to malicious security in the full version [DSZ14].
We consider this line of research as orthogonal to ours, since it focuses on outsourcing secure computations to a powerful but untrusted cloud server.
In contrast, we focus on secure computation between two mobile devices where computations are outsourced to a trusted, but resource constrained smartcard locally held by one party.
Another approach is to outsource computations to trusted hardware tokens, such as smartcards.
These tokens are typically resource-constrained, but have the advantage of offering a tamper-proof trusted execution environment.Setup Assumptions for UC Hardware tokens can be used as setup assumption for Canetti's universal composability (UC) framework, as they allow to construct UC commitments, with which in turn any secure computation functionality can be realized, e.g., [Kat07, DNW09, DKMQ11].
These works are mainly feasibility results and have not been implemented yet.SFE in Plaintext As discussed in [HL08], the trivial solution to performing SFE using hardware tokens would be to have each party send its inputs over a secure channel to the token, which evaluates f and returns the output.
A similar approach with multiple tokens, which additionally provides fault tolerance was given in [FFP + 06].
When using the hardware token for plaintext evaluation, the performance of the time-critical online phase is limited by the performance of the token, which is typically very low.
Moreover, this requires the token to hold all input values in memory, which quickly exceeds its very limited resources.
6 Alternatively, the token could use external secure memory to store inputs and intermediate values, e.g., [IS05, IS10], but this would require symmetric cryptographic operations in the online phase.
Additionally, each new functionality would have to be implemented on the token, whereas our scheme is implemented only once and supports arbitrary functionalities.Specific Functionalities An efficient protocol for private set-intersection using smartcards was presented in [HL08].
This protocol was extended to multiple untrusted hardware tokens in [FPS + 11].
An anonymous credential protocol was presented in [BCGS09].
Outsourcing Oblivious Transfer There are several works that use hardware tokens to compute oblivious transfer (OT): [GT08] implemented non-interactive OT using an extension of a TPM, [Kol10] proposed OT secure in the malicious model using a stateless hardware token, and [DSV10] provided non-interactive OT in the malicious model using two hardware tokens.We outsource the setup phase of the GMW protocol, which previously was done via OT, to the hardware token.
Previous works on outsourcing n OTs require the hardware token to evaluate O(n) symmetric (or even asymmetric) cryptographic operations in the ad-hoc phase.
In comparison, our scheme requires T to evaluate O(n/t) symmetric cryptographic operations in the init phase and only O(log 2 n) symmetric cryptographic operations in the setup phase (cf. the full version [DSZ14]).
In this work, we demonstrated that generic ad-hoc secure computation can be performed efficiently on mobile devices when aided by a trusted hardware token.
We showed how to extend the GMW protocol by such a token, similar to a TPM, to which most costly cryptographic operations can be outsourced.
Our scheme pre-computes most of the workload of GMW in an initialization phase, which is performed independently of the later communication partner and without knowing the function or its size in advance.
This is particularly desirable as the pre-computation can happen at any time, e.g., when the device is connected to a power source, which happens regularly with modern smartphones.
The remaining interactive ad-hoc phase is very efficient and can be executed in a few seconds, even for complex functionalities.
We implemented several privacy-preserving applications that are typical for mobile devices (availability scheduling, location-aware scheduling, and set-intersection) on off-the-shelf smartphones using a general-purpose smartcard and showed that their execution times are truly practical.
We found that the performance of our scheme is two orders of magnitude faster than that of other generic secure two-party computation schemes on mobile devices and comparable to the performance of similar schemes in the semi-honest adversary model implemented on desktop PCs.We see several interesting directions for future research.
As our scheme is based on the GMW protocol, it can easily be extended to more than two parties, e.g., for securely scheduling a meeting, cf. [CHK + 12].
Moreover, our scheme can be modified to also provide security against malicious parties, cf.[Hua12] (we provide more details in the full version [DSZ14]).
Another direction might be equipping both mobile devices with a hardware token to further improve efficiency and/or security.
We thank the anonymous reviewers of USENIX Security 2014 for their helpful comments on our paper.
We also thank Giesecke & Devrient for providing us with multiple smartcards and the authors of [HCE11] for sharing their code with us.
This work was supported by the German Federal Ministry of Education and Research (BMBF) within EC SPRIDE, by the Hessian LOEWE excellence initiative within CASED, and by the European Union Seventh Framework Program (FP7/2007 under grant agreement n. 609611 (PRACTICE).
