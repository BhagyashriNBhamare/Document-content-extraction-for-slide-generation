Modern web services rob users of low-level control over cloud storage-a user's single logical data set is scattered across multiple storage silos whose access controls are set by web services, not users.
The consequence is that users lack the ultimate authority to determine how their data is shared with other web services.
In this paper, we introduce Sieve, a new platform which selectively (and securely) exposes user data to web services.
Sieve has a user-centric storage model: each user uploads encrypted data to a single cloud store, and by default, only the user knows the decryption keys.
Given this storage model, Sieve defines an infrastructure to support rich, legacy web applications.
Using attribute-based encryption, Sieve allows users to define intuitively understandable access policies that are cryptographically enforceable.
Using key homomorphism, Sieve can re-encrypt user data on storage providers in situ, revoking decryption keys from web services without revealing new keys to the storage provider.
Using secret sharing and two-factor authentication, Sieve protects cryptographic secrets against the loss of user devices like smartphones and laptops.
The result is that users can enjoy rich, legacy web applications, while benefiting from cryptographically strong controls over which data a web service can access.
A single person often uses multiple web services.
Conceptually, the user has one logical data set, and she selectively exposes a portion of that data to each web service.
In practice, the services control her data: each service keeps a portion of the user's objects in a walled garden which neither the user nor external services can directly access.
Web services often provide user-configurable settings for access control, but the web services (not users) define the semantics of the controls, and users must trust web services to faithfully implement the restrictions.
By ceding control of storage to web services, a user also loses the ability to enumerate all of her data, since that data is scattered across a variety of services which hide raw storage via high-level, curated APIs.Data silos are problematic not only for users, but for applications whose value often scales with the amount of user data that is accessible to the application.
For example, quantified self applications [62], which track a user's health and personal productivity, work best when given data from a variety of sensors and environmental locations.
Similarly, applications which analyze a user's medical records [2] or financial transactions [34] produce the best results when they have access to all of the user's medical or financial data.
Unfortunately, the storage silos of modern web services limit a user's ability to share data outside of a silo.
For example, wearable fitness-tracking sensors typically upload data to vendor-specific cloud storage, and medical records are often bound to storage that belongs to the medical specialist who measured the data.The Challenges of Centralized Data: In a user-centric storage model, a user's entire data set would reside in a single, logically centralized cloud store; the user would selectively disclose portions of that data to individual third party applications.
Systems like Amber [19] and BStore [20] have explored the benefits of decoupling applications from user data.
However, a centralized data store increases the damage that results from a subverted or curious storage provider, because all of a user's data is at risk, instead of a service-specific subset.To protect against untrusted or incompetent storage providers, users can encrypt data before uploading it.
However, the ultimate purpose of uploading data is to share it with third party services.
Thus, users need a way to selectively expose pointers to encrypted objects (and the associated decryption keys).
Protocols exist for sharing cloud data across multiple services, but these protocols have major usability and security problems.
For example, the popular OAuth protocol [37] enables crosssite data sharing via delegated API calls (i.e., API calls that act with the authority of a user).
However, OAuth policies are invariably defined by web services, not by users.
Furthermore, OAuth does not enforce cryptographically strong constraints on the data that delegated APIs can access.
So, even if a user could generate her own OAuth policies, she would lack strong assurances about what those policies mean, and how they are enforced.Given the discussion above, logically centralized storage seems good for users in theory, but difficult to implement in practice.
This paper addresses three challenges The user generates a data policy for a third party web service.
Sieve translates the policy into an ABE decryption key, and sends the key to the web service.3) The web service pulls encrypted data from the storage provider, decrypts it locally, and injects the data into the unmodified application pipeline.that emerge from a logically centralized storage architecture.
The first is security: how do we provide cryptographically strong access controls that protect user data against the compromise of storage providers and user devices?
The second challenge is usability: how can we express access policies in a way that layperson users will understand, but is translatable to cryptographically enforceable mechanisms?
The final challenge is application richness: after we have moved user data out of per-application silos and into user-controlled storage, how can we support the complex applications that users currently enjoy?Our Solution: To address these challenges, we propose Sieve, a new system for delegating access to private cloud data.
Figure 1 depicts Sieve's high-level workflow.
A user generates raw data on her computational devices, and uploads encrypted versions of that data to a single cloud repository; the user manages and pays for the storage.
When a third party web service requests access, e.g., during the first time that a user visits a site, the user generates a high-level access policy ( §3.5) for the service.
Sieve splits the policy into two pieces: the storage provider learns which objects a third party can access (but not the cleartext versions of those objects), and the third party learns the objects that it can access, and the corresponding decryption keys, while learning nothing about the rest of the user's data set.
Once the third party has downloaded the necessary objects and decrypted them, it feeds the cleartext data to a legacy pipeline for handling user content.Sieve leverages three techniques to implement the workflow in Figure 1:• Sieve uses attribute-based encryption (ABE) [29] to implement cryptographically strong access controls.
In ABE, encrypted data is associated with at-(type="Fitness" OR type="Medical") AND (date > 2012) AND (source="FitBit")Figure 2: Example policy for an exercise application.tributes, which are key-value pairs like "date=2012".
Decryption keys are associated with policies like the one shown in Figure 2.
Policies are defined in terms of attributes and attribute operators like equality and less than.
A decryption key can decrypt only ciphertexts whose attributes satisfy the key's policy.
Before a user uploads objects to the storage provider, she (or her local device) tags the objects with attributes like the date, the user's current location, or the object type.
The uploading device encrypts the objects with the relevant attributes before sending the objects to the storage provider.
Later, when a third party web service requests access to the user's data, the user creates a policy for that service.
The user's local device translates the policy into an ABE decryption key, and sends the key to the web service.
Afterwards, the service uses the key to download and decrypt the subset of user objects that are covered by the key's policy.
• To revoke a third party's access to data, the user informs the storage provider that the third party should no longer be able to download encrypted user objects.
However, the third party still possesses a decryption key, and can decrypt leaked ciphertext if the storage server is later compromised.
To prevent this scenario, Sieve uses key homomorphism [15] to implement revocation.
Key homomorphism allows the storage provider to re-encrypt user data without learning the underlying cleartext-the storage provider merely reads the old ciphertext, and overwrites it with the output of a function that accepts the old ciphertext and a user-specified re-keying token as input.
Using this in situ re-encryption, users avoid the need to re-encrypt data on local devices and then re-upload it.
Additionally, if storage providers are honest at the time of key revocation, subsequent storage provider compromises will not reveal data that is encrypted with keys that are revoked (but possibly still in the wild).
To the best of our knowledge, Sieve is the first ABE storage system to support re-keying of both metadata and data.
• ABE uses a master secret key to generate decryption keys.
The loss of this key results in the compromise of the entire cryptosystem.
In standard ABE schemes, the master secret is kept by a single trusted authority.
In the context of Sieve, this would mean keeping the master secret on a single user device.
This is unattractive, since user devices are often lost or stolen.
Thus, Sieve uses secret-sharing and two-factor authentication to partition the master secret across multiple devices, and prevent unauthorized devices from arbitrarily participating in Sieve's cryptographic protocols.
Sieve represents a middle ground between today's web services (which provide weak user control over data access), and proposed systems from the research community which strengthen user control, but greatly restrict server-side computation [57] or eliminate it altogether [13,20,25,40,47].
Sieve explores a different point in the design space, one that provides cryptographically strong, user-centric access controls, while still permitting the server-side computation that popular web services require to add value to user data.To demonstrate Sieve's practicality, we integrated Sieve with two open-source web services.
Open mHealth [66] allows users to store and visualize data series for metrics like blood pressure and heart rate; Piwigo [3] is an online photo manager that is similar to Flickr [72].
Integrating Sieve with Open mHealth and Piwigo was straightforward, requiring approximately 200 and 250 lines of code modifications respectively.
Experimental results show that the modified systems can handle realistic workloads.
We focus on three kinds of principals.
A user is someone who wants to store data online and selectively expose it to a third party web service.
The user keeps her (encrypted) data on a cloud storage provider.
Each user has one storage provider, but potentially many third parties which need delegated access.
Potential storage providers include Amazon S3 and Microsoft Azure.
Potential third party web services are FitBit, Lark, Mint, and any other application that generates new value from sensitive user data.The user has a financial agreement with the storage provider: the user pays for the provider to keep her data and participate in the Sieve protocol on her behalf.
The user places encrypted data on the storage provider, but never reveals the decryption keys to the provider.
This protects the confidentiality of user data if the storage service is malicious or compromised.
Using signatures, Sieve also protects the data's integrity.
However, Sieve cannot guarantee the availability or freshness of the data that the storage provider delivers to a web service.
If desired, Sieve can be layered atop storage systems like CloudProof [55] which do provide those properties.Sieve does not hide access patterns or object metadata (i.e., ABE attributes) from the storage provider.
Thus, a curious provider can learn which encrypted objects a third party has been authorized to read, as well as the attributes that are associated with those objects.
If users are concerned about data leakage via access patterns, they can layer Sieve atop an ORAM protocol [44].
To hide attributes from the storage provider, Sieve could use predicate encryption [38,61].
However, ORAM and predicate encryption incur heavy performance overheads ( §6), so Sieve uses lighter-weight cryptography that reduces service latency at the cost of leaking more metadata.
We believe that this trade-off is reasonable for many users and companies, given the importance of low latencies in modern web services [69,71].
With respect to third party web services, Sieve's goal is to reveal user data only as permitted by the user's disclosure policies.
After Sieve transmits information to a third party server, Sieve cannot restrict what the third party does with the data.
For example, third parties may cache user data locally, even after the user has revoked access to the canonical versions that reside on her storage server.
Third parties can also share decrypted user data with other principals via out-of-band, non-Sieve protocols.
Preventing these behaviors is beyond the scope of this paper.
However, if a web service shares its user-issued ABE key, Sieve can revoke that key, preventing anyone who possesses the key from using it to access user data through the storage provider ( §3.6).
Sieve does not prevent client-side attacks like social engineering [9] or cross-site scripting [54].
Sieve also does not protect against a subverted device that the user believes is functioning properly, e.g., a smartphone that is infected with a rootkit.
However, Sieve uses secret sharing to protect system-wide secrets like the ABE master key from the loss of a single device ( §3.7).
As shown in Figure 1, Sieve consists of three components: a user client, a storage provider daemon, and an import daemon that is run by third party web services.
The Sieve client runs on each user device.
The client provides a GUI for defining high-level access policies, and insulates the user from the low-level management of cryptographic keys and data uploading.
The storage provider daemon communicates with Sieve clients, writing encrypted user data to cloud storage, and using the data's ABE attributes to build an index.
The index allows for fast data retrieval by the import daemons which belong to web services.
An import daemon receives ABE decryption keys from Sieve clients; each key allows the daemon to decrypt a subset of a user's encrypted data.In Sieve, there are five types of cryptographic keys, all of which are automatically managed by a user's Sieve client.
The per-user ABE master key helps to generate the individual ABE decryption keys which are given to web services.
The user's ABE public key encrypts metadata blocks with user-provided attributes; note that a storage provider keeps both data and metadata blocks for a user.
A web service's ABE decryption keys determine which metadata blocks can be decrypted by the service ( §3.4).
Metadata blocks point to data blocks, each of which is signed by a per-user RSA key, and encrypted by a symmetric key that is contained within the associated metadata block.
Importantly, all of these cryptographic operations are hidden from the user.
A user merely tags data and generates access policies; the Sieve client transparently converts those high-level activities into low-level cryptographic operations.From the perspective of a third party, a user's Sieve storage is read-only, i.e., only the user can write new objects and update old ones.
Third parties use their own storage for data that is derived from a user's Sieve objects.
In theory, any web service that imports user data is compatible with Sieve.
In practice, certain kinds of web services and user data are easier to integrate with Sieve.
Sieve works best with• data streams that are tightly bound to a particular user, and • web services that can tolerate those data streams being read-only (and perhaps only partially disclosed).
Examples of Sieve-amenable data streams include demographic information like age and location; financial and medical records; sensor data from quantified self applications; longitudinal, cross-site histories of browsing behavior and e-commerce transactions; and multimedia data streams containing photos, videos, and audio.
Examples of web services that consume such data streams are social media applications like Instagram [1], exercise trackers like Open mHealth [66], and financial analysis sites like Mint [34] that require access to a user's spending habits.Applications like Reddit [4] and StackOverflow [6] are less appropriate for Sieve.
In these applications, user data has less standalone value to the owner; instead, most of the value derives from embedding the data in a larger, service-specific context like a Reddit discussion.
Webbased email is also an awkward fit for the Sieve model, since email services require mutable, per-user state like mailboxes, but Sieve exports read-only storage.
An email service could pull read-only outgoing messages from Sieve storage, and implement the mutable mailbox state on the service's own machines.
However, such an architecture would be awkward, since users would have no way to selectively expose incoming messages to the mail service.
Attribute-based encryption [29] is a public-key encryption scheme in which a cleartext object is associated with at-K type="photo" AND (location="home" OR "work") AND year ≥ 2000 K type="photo" AND location="work" AND year < 2015Encrypted object 0 type="photo", location="home", year=2015type="photo", location="work", year=2014Encrypted object 1 type="medical", location="work", year=2014Encrypted object 2Figure 3: In this example, there are two ABE keys at the top, and three ABE-encrypted objects at the bottom.
An arrow indicates that a key can decrypt a particular object.tributes that govern how the object is encrypted.
Each decryption key has an access control structure (ACS) which enumerates one or more attributes.
An ACS can test an attribute for equality (e.g., location="Paris") or comparative value (e.g., age > 35).
An ACS can also chain those simple tests using ANDs, ORs, and NOTs.
As shown in Figure 3, a key can decrypt an object only if the key's ACS matches the object's attribute values.We use the shorthand notation K a 0 ,...,a N to refer to an ABE key whose ACS contains the attribute tests a 0 ,.
.
.
,a N .
All tests are implicitly joined via ANDs unless we explicitly note otherwise.
Raw user data comes from a variety of sources.
Some of it is directly generated by a user's devices; for example, a user might enter financial information directly into a spreadsheet.
Data might also come from an external source, like an email attachment.
Sieve associates each object, regardless of its provenance, with a set of attributes.Some attributes can be automatically assigned by hardware, like the GPS coordinates for a running route.
Other attributes can be extracted by software, using applicationspecific transducers or semantic file systems [28,39,63].
Users can also manually tag objects.
Sieve is agnostic to the manner in which attributes are assigned, although our implementation of the Sieve client provides a GUI which simplifies manual tag assignment.
The GUI also allows users to retag an object after it has already been encrypted ( §3.9).
Users and web services must agree on data schemas, so that web services can meaningfully aggregate and process information from different users.
In particular, web services need to know a standardized set of attributes which are associated with various data types.
To define this stan-dardized set, Sieve uses FOAF [17] as the schema model for data about human users, and RDF [21] as the schema model for data about user objects.Each Sieve user has a standardized FOAF record which stores basic scalar information like her name, location, and birthday.
Sieve associates each entry in the FOAF record with an ABE attribute; for example, a user's name is associated with the userName attribute.
Sieve does not upload the actual FOAF record to the storage provider, since the only purpose of the FOAF record is to standardize the metadata that is associated with each user.
Instead, Sieve uploads individual FOAF entries, encrypting each one with the associated ABE attribute (e.g., 񮽙"Alice"񮽙 K field=userName , where "Alice" is the encrypted data and K field=userName means that the data can be decrypted only by web services whose ABE keys have access to the userName field attribute).
Sieve associates each data object with a type-specific RDF schema.
For example, a W2 tax record has attributes for the user's pre-tax income, her number of dependents, and so on.
Similar to FOAF records, RDF records are used to define a standard attribute set for each data type.
Sieve uploads individual encrypted RDF entries to the storage provider.Some data objects like images are not decomposable, i.e., each object is disclosed or not disclosed at the granularity of the entire object.
For objects like this, Sieve uploads the entire object, encrypting it using the standardized RDF attributes and any manually added user tags.
For example, a photo has standard attributes like height and width, and may also possess user-defined tags like "Vacation" or "Family.
"As applications evolve, RDF and FOAF schemas may change.
Sieve is compatible with preexisting techniques for synchronizing schema changes across a distributed system [51, 58, 59].
Suppose that a user wishes to upload a file F that has attributes a 0 ,.
.
.
,a N .
Before uploading the file, the Sieve client must encrypt the file such that decryption is possible only with the ABE key whose ACS matches a 0 ,.
.
.
,a N .
The naïve approach is to directly encrypt F with K a 0 ,...,a N .
However, ABE is a form of public key cryptography, and it is significantly slower than symmetric key cryptography.
Thus, Sieve uses a hybrid encryption scheme, encrypting the file data with a symmetric key, and encrypting the symmetric key with ABE.The end-to-end upload protocol is the following.
First, the Sieve client generates a symmetric key k, and uses that key to encrypt F. Sieve uploads the encrypted 񮽙F񮽙 k to the storage provider.
The storage provider responds with a GUID for the file.
Sieve then uploads a metadata block for F.
The metadata block is an encrypted pointer containing 񮽙GUID, k񮽙 K a 0 ,...,a N .
Only principals which possess keys that match a 0 ,.
.
.
,a N can decrypt the pointer, fetch the object, and decrypt the object.In the next section, we describe how web services acquire ABE keys.
For now, we merely say that users do not share ABE keys with storage providers.
Thus, a storage provider cannot inspect the data that it stores.
The provider can try to modify the data or produce fake user data, but Sieve clients sign each object with a user-specific RSA key before encrypting the object; the signatures allow web services to detect tampering.From the perspective of a third party web service, Sieve storage is read-only.
However, a user is free to create new objects, delete old ones, and update objects that reside at preexisting GUIDs.
If a user's device has cached the GUID and the symmetric key for a particular object, the user can update that object directly, without having to fetch the associated metadata block and incur ABE overhead to decrypt it.
In Sieve, all user data is private by default, since users must explicitly share ABE decryption keys that provide access to data.
When a third party requests access permissions, e.g., upon the first time that a user visits a web site, the user generates an access policy for the site.
Policies are defined in terms of attributes, and the Sieve client provides a GUI which makes it easy for users to explore which attributes her data contains, and which objects would be exposed for a given policy.
Policies are simple boolean expressions; for example, a web service used by a physician might receive the policy (fileType="medicalRecord" AND year>2010 AND doctor="John").
After the user defines a policy, her Sieve client assembles the ABE master secret ( §3.7) and generates an ABE key with the appropriate ACS.
The Sieve client then sends the key and the name of the user's storage provider to the remote web service.
The message is protected with TLS [22] to ensure confidentiality and integrity.Later, when the web service desires to access user data, the service does not need to interact with the user.
Instead, the service sends an access request directly to the user's storage provider.
The request contains a list of the attributes which belong to the data of interest.
The storage provider returns the encrypted metadata blocks for the relevant objects.
The web service decrypts the metadata, revealing the GUIDs for the requested objects as well as their symmetric encryption keys.
The web service uses the GUIDs to fetch the encrypted objects.
After decrypting the objects locally, the service feeds the cleartext data into an application-specific data pipeline.Once this happens, Sieve is uninvolved in the application workflow.
Thus, Sieve is compatible with the current web ecosystem which uses third party computation and storage to add value to user data.
However, Sieve provides users with cryptographically strong control over the raw data that each service receives.
Sieve's access policies also have three attractive properties:• The number of policies scales with the number of web services that a user shares data with, not the much larger number of objects that she owns.
• Policy generation is decoupled from object generation.
At object creation time, users do not have to speculate a priori about whom a new object might be shared with.
• Policies safeguard objects using cryptography, but users are insulated from the details of key management.
Given all of this, we believe that Sieve strikes a good balance between security, usability, and backwards compatibility with current web services.
In Sieve, an individual object is encrypted with a symmetric key k; the object's metadata block (which contains k and the object's GUID) is encrypted with ABE attributes a 0 ,.
.
.
,a N .
A web service caches its ABE key, and it may also cache symmetric keys and GUIDs, to avoid repeated fetches and decryptions of metadata blocks.
Caching makes revocation tricky, since a user that wants to revoke a service's access rights cannot force the service to delete cached keys.
An honest storage provider can refuse access requests from deprivileged third parties, but if the storage provider is compromised, it can leak data that is encrypted with ostensibly revoked keys that are still in the wild.To protect against storage server compromise, Sieve revokes keys by re-encrypting user data and metadata with new keys that are not shared with the newly deprivileged third party.
If the storage provider is honest at the time of re-keying, then even if it is compromised later, it will never leak data that is encrypted with revoked keys.
Leveraging homomorphic encryption [27], the storage provider re-encrypts the data locally, using a re-keying token provided by the user.
The storage provider learns nothing about the old encryption key, the new encryption key, or the underlying cleartext; the user avoids the need to download, re-encrypt, and re-upload data from her personal devices.In the rest of this section, we first describe how data is re-encrypted, and then explain how the associated metadata is re-encrypted.
Re-encrypting data: To enable storage providers to reencrypt data in situ, Sieve employs a key homomorphic pseudorandom function [15,50].
We define that function F asF(k, x) = H(x) kwhere H is a hash function and k is the secret key associated with each object.
F is additively key homomorphic, which means that, for two keys k and k 񮽙 ,F(k, x) · F(k 񮽙 , x) = F(k + k 񮽙 , x).
All operations described in this section are done modulo p, where p is a large prime.Using F, we define an encryption scheme whose security is similar to that of AES.
Like AES-CTR, our new encryption scheme operates on blocks of data, and uses a random counter to convert a block cipher into a stream cipher.
In our new scheme, the jth ciphertext block c j is equal toc j = m j · F(k, N + j)where m j is the jth cleartext block, and N is a public nonce that is equivalent to the initialization vector in AES-CTR.
To decrypt, a third party extracts k from a metadata block and performs the following calculation:m j = c j · F(−k, N + j)To revoke the ABE key K a 0 ,...,a N , a user's Sieve client generates a re-keying token for each object that is accessible via K a 0 ,...,a N .
For an object encrypted by k, the re-keying token is δ = −k + k 񮽙 , where k 񮽙 represents the new encryption key for the object.
The client sends δ to the storage provider; this operation is safe because the provider cannot recover k or k 񮽙 from δ .
The storage provider uses δ to compute a new version of each ciphertext block c j :c j,new = c j · F(δ , N + j) = m j · F(k, N + j) · F(−k + k 񮽙 , N + j) = m j · F(k 񮽙 , N + j)In this manner, the storage provider re-encrypts objects without learning the encryption keys or the underlying cleartext.Re-encrypting metadata: Each user device maintains an integer counter called the epoch counter.
The counter is initialized to zero, and represents the number of revocations that the user has performed.
When a user device generates a new ABE key, Sieve automatically tags the key with an epoch attribute that is set to the current value of the epoch counter.
The epoch attribute is a standard ABE attribute; until now, we have elided the epoch attribute in key descriptions, but we explicitly represent it in this section.
Suppose that a web service possesses the ABE key K a 0 ,...,a N ,epoch=i , where i is a whole number.
To remove the service's access permissions, the user first re-encrypts the affected data using homomorphic encryption.
The user then increments the epoch counter to i + 1.
Next, the user generates a new metadata block for each re-encrypted object, inserting the new k.
The user encrypts the new metadata block and uploads it to the storage provider; the metadata is encrypted using the updated ABE key K a 0 ,...,a N ,epoch=i+1 .
Finally, the user sends the new ABE key to any non-revoked web services who possess the old version of the key from epoch i (remember that if the user gives multiple web services access to a 0 ,.
.
.
,a N , those services will receive the same ABE key).
Additional web services may require new ABE keys, depending on how the attributes in ABE keys overlap.
For example, consider two web services: the first possesses K (a 0 OR a 1 ) AND epoch=0 , and the second has K (a 1 OR a 2 ) AND epoch=0 .
Both keys grant access to a metadata block with attributes a 1 AND epoch = 0.
To revoke the first ABE key, Sieve re-encrypts the metadata block using the attributes a 1 AND epoch = 1.
As a result, the second, non-revoked web service loses access to the block.
Thus, Sieve must give an updated key K (a 1 OR a 2 ) AND epoch=1 to the second service.When Sieve re-encrypts a data object, the object's GUID stays the same, but its symmetric key changes.
This invalidates any cached symmetric keys that are held by web services.
So, when a service receives an updated ABE key, the service discards any cached symmetric keys that were decrypted using the old version of the ABE key.
Note that object signatures are unaffected by revocation, because signatures are on cleartext data which is unmodified by the revocation process.Additional details: A Sieve user will often possess multiple devices; for example, a single user might possess a smartphone, a laptop, and a quantified self device like a FitBit.
If a user has multiple devices, then the device which initiates a revocation will broadcast the revoked key and the new epoch counter to the other devices.
This ensures that the other devices do not use an old epoch number to encrypt new metadata blocks.
Network partitions may delay the rate at which devices learn about a revocation, so when a device receives a revocation notice, the device proactively re-keys any data and metadata that it mistakenly encrypted using the revoked key.
Each revocation notice has an issue time, which allows devices to identify which data needs re-keying.
Computationally weak devices like FitBits can delegate re-keying work to more powerful devices like laptops.A revocation message is signed by the public key of the device that issued the message.
Devices learn about each other's public keys at Sieve initialization time, and later, when the user adds a new device.
By signing revocation messages, Sieve prevents arbitrary devices from injecting fraudulent revocation notices.To the best of our knowledge, Sieve is the first ABE system which supports full re-keying of both data and metadata.
Prior ABE systems either cannot revoke keys at all [73], or can revoke access only to metadata [10,52,65]; in the latter case, data remains encrypted with revoked symmetric keys, leaving that data vulnerable to storage server compromise or negligence.
At initialization time, Sieve creates an ABE master secret.
Sieve uses the master secret to derive the ABE decryption keys that are given to web services.
Thus, the entire cryptosystem is compromised if the master secret is lost.In a straightforward implementation of ABE, each user device has a copy of the master secret.
However, portable devices like smartphones and tablets are often lost [70], meaning that a naïve implementation of ABE exposes the master secret to great risk.
Even if users encrypt the master secret with a password-derived key [68], users often pick weak passwords [26], giving the master secret weak protection in practice if a device is lost.To mitigate the impact of lost devices, Sieve uses Shamir secret sharing [60] to partition the master secret across a user's devices.
In a (k, n) sharing scheme, the secret is divided across n devices, and k shares are required to reconstruct the secret.
In the context of Sieve, this means that when a user device needs to generate an ABE key, the device must first gather k − 1 shares from other devices.
Only then can the device assemble the master secret, generate the ABE decryption key, send the key to a web service, and then delete the local copy of the assembled master secret.When the master secret is being assembled, Sieve requires the user to explicitly authorize each participating device to release its local share.
By default, Sieve uses a k of 2, so this authorization scheme is similar to twofactor authentication [7]-a user cannot generate an ABE decryption key unless she controls two separate devices (e.g., a laptop and a smartphone).
This means that, if an attacker finds a single lost device, that device cannot generate the master secret.Sieve also employs secret sharing to protect the user's RSA signature key.
During uploads to the storage provider, the signature key is used to authenticate the client-side of the TLS session.
Thus, the storage provider can reject fraudulent upload attempts from arbitrary devices.Secret sharing protects the ABE master secret and the user's signing key.
However, a lost device possesses a device key that is used to authenticate messages from that device.
An attacker with a lost device can try to use the device key to subvert the revocation protocol ( §3.6).
For example, if a malicious lost device can roll back the epoch to a smaller number, uncompromised devices will upload new data that can be decrypted with revoked keys.
To prevent attacks like this, Sieve relies on the multifactor authentication that is built into the secret sharing protocol-revocation requires a device to assemble the master secret, and assembling the master secret requires the user to possess multiple devices.To add or remove devices from the secret sharing scheme, or to change k, the user must invalidate the old shares.
To do so, the user must find k devices to participate in a new secret sharing exchange that uses the updated k and n.Sieve provides no protections against a subverted device that a user believes is not lost or malfunctioning.
For example, if a user wants to upload data from the smartphone that she is currently using, and the smartphone has a rootkit, the phone can arbitrarily delete the user's data, upload garbage, or improperly revoke keys.
Until now, we have assumed that clients perform two encryptions for every object upload: an ABE encryption for the metadata block, and a symmetric encryption for the data block.
ABE is a public key cryptosystem, so ABE operations are much slower than symmetric ones.
Fortunately, Sieve clients can use several techniques to reduce the frequency of ABE operations.The simplest approach is for clients to store multiple objects inside each data block.
Creating the associated metadata block will still require an ABE encryption, but subsequent writes and reads of the data block will incur only symmetric cryptography costs-clients can update the data block in-place, without changing the metadata, and third parties can cache the data block's symmetric key to use during reads.
For example, a smartphone with a GPS unit might use a single data block to store a month's worth of location data.
The phone appends new location samples to the current month's data block, creating a new data block and metadata block when a new month begins.Clients can also use more complex storage-based data structures.
For example, as shown in Figure 4, a Sieve client can use indirect GUIDS in the same way that a Unix file system uses indirect data pointers.
In this scheme, the top-level GUID for a storage-based data structure refers to a metadata block that points to a GUID map.
The GUID map is just a data block that contains a symmetric key and additional GUIDs; those GUIDs point to raw data blocks that are encrypted with the symmetric key.
Once again, clients eliminate ABE costs by encrypting many objects with the same symmetric key, and caching that key.Having Figure 4: An example of a storage-based data structure.
Using indirect GUIDs, the metadata block at the top points to a data block that contains only GUIDs.
Those GUIDs point to raw data blocks.
Raw data blocks can also embed pointers, as demonstrated by the simple tree structure that links the data blocks.the client to upload at least a block's worth of data).
1 Multiple small blocks are also useful if the symmetric cipher does not allow updates to random offsets in the ciphertext.
2 A raw data block can also embed GUIDs which reference other data blocks.
This allows a client to build more complex data structures than flat arrays of data blocks.
For example, Figure 4 shows a simple tree with a single parent and three children; by convention, the parent of the tree is the first entry in the GUID map.
Each data block can hold multiple items, but when a block fills up, the client creates a new data block, adds the associated GUID to the GUID map, and then updates any internal GUIDs within preexisting data blocks.
A third party whose ABE key decrypts the metadata block can traverse the tree structure without additional ABE operations, since all of the data blocks are encrypted with the same symmetric key.Each storage-based data structure defines a Python API for adding and removing objects, as well as traversing the entire structure.
Sieve clients and web services cache the metadata blocks for storage-based data structures, and use the Python APIs to interact with the structures.
Thus, Sieve clients and web services are insulated from the lowlevel details of GUID maps (although both parties can access raw storage if desired, and if Sieve's ABE policies allow such accesses).
Sieve's revocation protocol ( §3.6) is compatible with storage-based data structures.
When Sieve determines that a metadata block must be re-keyed, Sieve checks whether the metadata refers to a storage-based data structure.
If so, Sieve must traverse the structure, identifying GUIDs and re-keying the associated data blocks.
Note that GUID maps are re-encrypted in place, just like any other data block.
The revocation protocol does not change the GUIDs that are associated with re-keyed data blocks, so embedded GUIDs inside data blocks remain valid after re-keying.
Each data block that is referenced by a particular GUID map is encrypted with the same k. However, Sieve uses counter-mode encryption [42], and employs a different counter for each block.
Thus, if an attacker learns the cleartext for one ciphertext block, the attacker does not have an easier job of decrypting other ciphertext blocks with the same k.
In Sieve, a user may relabel an object.
For example, a user can restrict access by adding an additional attribute to the object.
A user can also remove attributes, or swap one attribute for another.To implement relabeling, a user's Sieve client performs three actions.
First, the client replaces the old metadata block on the storage server with a new one that contains a new symmetric key and is ABE-encrypted using the new attributes.
Second, the client uses homomorphic encryption to re-encrypt the object under the new symmetric key on the storage server.
Finally, the client updates storagebased references to the object, ensuring that the references adhere to the object's new access policy.
The client can locate these references because the client knows the old attributes for the object, the new attributes for the object, and the attributes for all of the user's metadata blocks.
Thus, the client can determine which references must be patched.
For example, suppose that a user has two storage-based data structures S 0 and S 1 ; further suppose that, due to relabeling, an object must move from S 0 to S 1 .
By inspecting the object's old attributes, the client determines that the object was originally referenced by S 0 .
The client homomorphically re-encrypts the object using symmetric key k 񮽙 , traverses S 0 to remove any references to the object, and then adds a 񮽙GUID, k 񮽙 񮽙 reference for the object to S 1 .
Sieve performs the traversals, removals, and additions using the APIs defined by the storage-based data structures.
Alternative policy languages: Attribute-based disclosure policies are easy for users to understand, and these policies naturally map to ABE cryptosystems.
However, ABE cannot express arbitrarily complex policy functions.
Garbled circuits [41] and functional encryption [16] are Turing complete, but they are prohibitively slow.
For example, garbled circuits decrypt AES data at a rate that is four orders of magnitude slower than native AES decryption [12].
Relative to functional encryption and garbled circuits, ABE is several orders of magnitude faster.Paying for storage: In Sieve, each user places her objects in private cloud storage.
Someone must pay for that storage.
One option is for ad networks to pay.
In Sieve, ad networks can be third parties, and they can receive ABE keys to access user data.
Using a micropayment system like FileTeller [35], advertisers could pay for the right to collect longitudinal data about a user, and generate targeted advertisements based on that data.
By deferring user storage costs, advertisers would encourage users to continue to declassify a subset of their data.
Indeed, since each user now stores all of her data in a single place instead of multiple locations, ad networks would gain access to more contextual information than in the current web ecosystem, even if users choose which objects to reveal [67].
Thus, Sieve might enable a happy middle ground in which users gain explicit control over the data seen by third parties, and third parties willingly subsidize private user storage in return for better contextual information.If ad-driven storage subsidies are poorly designed, they may lead to perverse trade-offs between subsidy amounts and the required levels of data disclosure.
A full study of such interactions is beyond the scope of this paper.
For now, we merely observe that some users may opt out of the subsidy system entirely.
These users will have to pay for their own storage, but there is reason to believe that they would do so.
Well-known sites like Pandora, Slashdot, and OkCupid already allow users to pay a small monthly fee to remove advertisements, so there is a preexisting demographic that is willing to pay money in exchange for better privacy.
The popularity of open source applications also demonstrates that developers are willing to make high quality software without the expectation of direct payments from users.
Thus, we believe that Sieve's application model is realistic.Efficient data importing: In the current web ecosystem, users explicitly submit data to web services, making it easy for those services to determine when new information has been created.
In Sieve, users submit new data to the storage provider.
However, user devices know the tags which are associated with both new data items and web service ABE keys; thus, when a device uploads an object of interest to a particular service, the device can proactively notify the service of the upload.Storage-based data structures ( §3.8) also make it easy for services to identify new data.
For example, using a storage-based log, user devices can append new data to the head of the log.
A service can cache the GUID and the symmetric key for the log head, and periodically check the beginning of the log for new objects.Anonymity across services: Some users may not want to be tracked across different web services.
For example, a user might be comfortable sharing data with services X and Y , but uncomfortable with X knowing how she interacts with Y , and vice versa.
Sieve cannot restrict what services do once they possess user data, so Sieve cannot prevent X and Y from pooling their data and trying to correlate user behavior across both services.Users can employ various techniques to make tracking more difficult.
For example, proxies like Tor [23] allow users to hide their IP addresses from web services.
Users can also establish a unique login identity for each web service, or lobby web services to use anonymous credential systems [18].
Unfortunately, Tor and anonymous credential systems rely on network proxies that hurt application responsiveness, and seemingly anonymized data sets can still reveal sensitive user information to machine learning algorithms [24].
Thus, providing anonymity on the web is still an important area for future research.
Our Sieve prototype consists of a Sieve client, a storage provider daemon, and a Sieve import daemon that is run by third parties.
Each component is written in Python, and uses PyCrypto [43] to implement RSA and AES.
For ABE operations, we use the libfenc [30] library with elliptic curves [48] from the Stanford Pairing-Based Cryptography library [45].
To build Sieve's key homomorphic symmetric cipher [15], we use the Ed448-Goldilocks elliptic curve library [31].
The storage provider daemon uses BerkeleyDB [53] to store encrypted data blocks, and MongoDB [49] to store metadata blocks.
For each data block, the key is a GUID, and the value is a symmetrically encrypted object.
For a metadata block, the key is a set of cleartext ABE attributes, and the value is an ABE-encrypted GUID and symmetric key.
Metadata blocks are indexed by their attribute fields, and all metadata blocks for a particular user are stored in a MongoDB collection.The JavaScript code in a web site interacts with the local Sieve client using a small RPC library that we provide.
When a web site initially requests access to a user's data, the site's JavaScript sends an XMLHttpRequest to a localhost webserver run by the Sieve client.
The Sieve client then displays a GUI that allows the user to define an access policy for the site, and send the associated ABE key to the site's web server.
In this section, we explore one high-level question: is Sieve practical?
To answer this question, we integrated Sieve with two applications.
The first was Open mHealth [66], an open-source web service that allows users to analyze their health data.
We also integrated Sieve with Piwigo [3], an open-source online photo manager.
We show that the integrations were straightforward, and that the end-to-end application pipelines can handle realistic workloads.All experiments ran on a 10-core machine with 2.4 GHz Intel Xeon E7-8870 CPUs and 256 GB of RAM.
We ran each experiment 50 times, and we report the average (standard deviations were small).
Sieve used 2048 bit RSA with SHA256 to sign user objects.
ABE operations used 224-bit MNT curves [48].
To symmetrically encrypt objects, Sieve used 128-bit AES in CTR mode, or Ed448-Goldilocks elliptic curves in randomized counter mode.
The latter cipher is key homomorphic, but the former is not; by comparing Sieve's performance with these ciphers, we could measure the cost of supporting key revocation ( §3.6).
All web servers ran on the test machine's loopback interface, to minimize network latency and focus on Sieve's cryptographic overheads.All GUIDs were 64 bits long.
Thus, a metadata block which contained a GUID and an AES key was 24 bytes in size, whereas a metadata block which contained a GUID and an Ed448 key was 64 bytes long.
Open mHealth: Open mHealth allows users to upload medical data to a web server that will analyze the data and provide explanatory visualizations.
To integrate Sieve with Open mHealth, we first modified the Open mHealth client to upload data via the Sieve client instead of directly to the Open mHealth server.
We then ran a Sieve import daemon on the Open mHealth web server, configuring the daemon with the data schema used by the Open mHealth analytics engine.
These modifications required approximately 200 lines of code to be changed in the Open mHealth platform.To test the end-to-end performance of the application pipeline, we used Open mHealth's data generator to create a week's worth of health data.
The data included information like blood pressure, weight, physical activity, and heart rate.
Each day had approximately 14 data points.
For each data point, the Sieve client added attributes like the date that the sample was collected, the name of the associated user, and the type of data represented by the sample.
The Sieve client used a single storage-based data structure to store the samples for an entire week.
Figure 5: Encryption throughput for Sieve, as a function of 1) the size of the data to symmetrically encrypt, 2) the percentage of symmetric data encryptions which also require the ABE encryption of a metadata block, and 3) whether the cipher is AES or key homomorphic Ed448.
All experiments assume that each metadata block has five attributes, and each ABE key has 10 attributes.
Performance trends for decryption are similar.The cost for the user to upload the first data point at the beginning of a week was 0.56 seconds; the cost was dominated by ABE encryption.
Uploading subsequent data points proceeded at the throughput of the symmetric cipher, requiring 17.1 ms per data point for AES, and 38.5 ms for Ed448.The mHealth server used the Sieve import daemon to download user data.
If the server had no cached GUIDs or symmetric keys, then importing a week of data required 0.49 seconds with AES and 0.78 seconds with Ed448.
In this scenario, the server had to download the metadata block, decrypt it with ABE, download the data block, and then decrypt that block using a symmetric cipher.
If the server possessed cached GUIDs and symmetric keys, then importing a week of data took only 135 ms with AES, and 469 ms with Ed448.Piwigo: The standard Piwigo client allows users to upload photos from local storage to the Piwigo web service.
We modified the client to upload data to a Sieve storage provider, and we modified the server-side Piwigo code to fetch user data via the Sieve import daemon.
These modifications required approximately 250 lines of new Piwigo code.To test the end-to-end performance, we uploaded a 375 KB photo which had three tags (location, date, and username).
If the Piwigo client used AES, the upload required 0.57 seconds if a new, ABE-encrypted metadata block had to be generated.
If the client used a storagebased list to avoid the creation of a new metadata block, the upload cost was only 0.06 seconds.As we explain in more detail in Section 5.2, current Ed448 implementations are slower and less optimized than equivalent AES implementations.
Thus, when applications use Ed448, the upload time for a large object is dominated by Ed448 encryption costs, regardless of whether ABE costs are incurred.
If the Piwigo client used Ed448, the upload cost for a 375 KB photo was 6.1 seconds if the client also had to generate a new metadata block.
By using storage-based data structures to avoid ABE operations, the upload cost dropped to 4.2 seconds.
Note that, from the user's perspective, uploads are asynchronous.
Thus, multi-second upload times are not in the critical path of user-facing activities.Download times for the Piwigo server demonstrated similar trends.
With cached GUIDs and symmetric keys, downloading a photo required 0.14 seconds using AES, and 5.9 seconds using Ed448.
Without cached metadata, a download required 0.44 seconds with AES, and 6.3 seconds with Ed448.Server-side per-core throughput: The storage daemon uses BerkeleyDB to store data objects.
The daemon logic is simple, meaning that the daemon can import data at the raw speed of the BerkeleyDB write path.
For Open mHealth, the write speed was roughly 50 MB/s per server core, which represented 16,500 users uploading a week's worth of data every second.
For Piwigo, the write speed was roughly 200 MB/s per core, corresponding to 550 photo uploads per second (assuming a photo size of 375 KB).
Write throughput was better for Piwigo due to BerkeleyDB handling large writes faster than small ones.
Generating 10 attribute key 0.46 sec Generating 20 attribute key 0.64 sec Re-encrypting a metadata block (10 attrs) 0.63 sec Re-encrypting a metadata block (20 attrs) 0.91 sec Re-key 100 KB data block 0.66 sec Figure 6: Computational overheads for key generation and revocation.We also tested per-core throughput for the import daemon.
For Open mHealth using AES, a single core could download and decrypt a week's worth of data for 420 users in one minute; with Ed448, a core could import 70 users' data in one minute.
Given a photo size of 375 KB, Piwigo was able to import 235 AES-encrypted photos or 14 Ed448-encrypted photos in one minute.
In all experiments, 20% of object imports required the download and ABE-decryption of a metadata block.
We believe that 20% is high, since an arbitrary number of objects can be referenced by a single metadata block.
Encryption speed: Sieve requires clients to symmetrically encrypt each data object before uploading it.
Some fraction of uploads will also require clients to ABEencrypt a metadata block.
Figure 5 quantifies the performance of ABE and the symmetric ciphers.
For 10 KB objects, pure ABE encryption throughput is 1.1 KB/s, whereas pure Ed448 throughput is 23.8 KB/s and pure AES throughput is 43.5 KB/s.
Although clients can perform data uploads asynchronously, in the background, the computational costs for ABE are still quite high.
Thus, hybrid encryption ( §3.4) and the optimizations from Section 3.8 are crucial for minimizing the number of ABE operations.For 1 MB objects, the performance gap between AES and Ed448 grows-AES throughput is 12 MB/s, but Ed448 throughput is only 120 KB/s.
However, Ed448 is a new elliptic curve, with immature implementations relative to AES.
We expect Ed448's performance to improve as its implementations receive more optimization effort.Key generation and revocation: Figure 6 describes the costs that Sieve pays for generating new ABE keys, re-encrypting metadata blocks, and re-keying a 100 KB data block.
The creation of new ABE keys is rare, and occurs only when a new service requests access permissions, or an old service receives modified permissions (possibly as the result of an epoch number increasing after a revocation ( §3.6)).
During revocation, the metadata blocks associated with the revoked ABE key must be reencrypted; however, those metadata blocks will typically point to a much larger number of raw data blocks ( §3.8), so the overall re-encryption cost of revocation is governed by the speed with which raw data can be re-keyed.
Attribute matching: When the storage provider receives an access request from a third party, the storage provider must locate the metadata blocks whose attributes match those of the access request.
Sieve makes the matching process fast by storing metadata blocks in a database that indexes those blocks by their attributes.Due to space constraints, we omit a full description of matching performance.
However, the results are unsurprising, since modern databases are good at building indices.
For example, in one experiment, we injected a million metadata blocks into MongoDB; each metadata block had 10 randomly selected attributes from a universe of 35 possible attributes.
Then, we submitted access queries in which each query contained 5 random attributes joined with a random set of ANDs and ORs.
Each query took 0.13 ms to complete on average.Secret-sharing: Sieve partitions the ABE master key and the RSA signing key across multiple devices, ensuring that a lost or stolen device will not store a full copy of sensitive cryptographic information.
The secret sharing protocol is cheap: ignoring network latency, and assuming that k = 2 and n = 5, splitting a 2048 bit object like an RSA key requires 0.04 ms, and reconstructing that key requires 0.09 ms. Untrusted servers: Browser extensions like ShadowCrypt [32] transparently encrypt the data that a browser sends to unmodified cloud servers.
Intentionally encrypted cloud stores like SUNDR [40], Depot [47], and SPORC [25] provide stronger consistency semantics in the face of server-side misbehavior; application logic runs solely on the client-side, over cleartext data, with clients exchanging encrypted data with servers.
Other systems that store encrypted data on servers and run application logic on the client-side include BStore [20] and DepSky [13].
All of these systems prevent data leakage due to server compromise or malice.
However, these systems are incompatible with applications that leverage server-side computation to add value to raw user data.
In contrast, Sieve is totally compatible with server-side computation.In CryptDB [56], a web application consists of clients, an application server, and a back-end database.
The database contains only encrypted data.
Using SQL-aware encryption, the application server can execute queries over the encrypted data without revealing cleartext to the database.
However, the application server does see cleartext, and can leak user data if compromised.
Mylar [57] eliminates the need for an application server, but restricts the encrypted server-side computation to keyword searches.
In both CryptDB and Mylar, applications control how user data is shared.
In Sieve, user data is decoupled from applications, with users selectively disclosing individual objects to third parties.Privly [5] allows users to upload encrypted data to a storage server, and share hyperlinks to that data.
The hyperlinks can be embedded in sites like a Facebook page, but the hyperlinks reveal no cleartext to the owner of the embedding site.
Users register their decryption keys with Privly's browser extension.
Later, when the user visits a page and her extension finds a Privly hyperlink, the extension transparently fetches the encrypted data, decrypts it, and rewrites the page's HTML, replacing the Privly link with the cleartext data.
Privly does not support the server-side computation that is enabled by Sieve.ABE-protected storage: Persona [10], Priv.io [73], and Cachet [52] use ABE to selectively expose encrypted user data.
In Persona and Priv.io, each user keeps her data in private cloud storage; in Cachet, data is stored in a peer-to-peer, distributed hash table.
Unlike Sieve, these systems cannot delegate access to arbitrary third party services.
Persona, Priv.io, and Cachet also trust each device for the lifetime of the system, whereas Sieve can recover from the loss of individual devices.
Finally, Sieve provides a concrete revocation protocol that safeguards user data if storage servers are compromised.
Priv.io has no revocation strategy, and Persona suggests re-keying data, but does not provide a specific mechanism.
Cachet does implement revocation, but requires a trusted proxy which must interpose on all decryption operations, even in the common case that revocation is not underway [36].
Cachet's revocation scheme also does not re-encrypt data on storage providers; thus, objects that are encrypted with revoked keys are vulnerable to subsequent compromises of the storage provider.Predicate encrypted storage: GORAM [46] allows users to selectively share their cloud data with other users.
Clients place encrypted data on servers so that servers cannot inspect it, and clients hide their access patterns from servers using ORAM shuffling techniques [44].
Like Sieve, GORAM tags data objects with attributes; unlike Sieve, GORAM uses attribute-hiding predicate encryption [38,61] to prevent storage servers from learning attribute values.GORAM's use of oblivious RAM and predicate encryption provides stronger security than Sieve, but there is a performance cost.
To hide data access patterns from storage servers, GORAM clients must perform O(polylog(n)) additional accesses.
Hiding attribute values using predicate encryption substantially increases GORAM's ciphertext size, and slows both encryption and decryption.GORAM is also less user-friendly than Sieve.
For example, GORAM forces users to determine a priori the maximum number of principals that can be mentioned in access control lists; if this list changes, a user must reinitialize her database.
GORAM also has no revocation scheme, and no protocol to recover from lost user devices.Access delegation schemes: OAuth [37] is a widely used protocol for sharing cloud data across different web services.
OAuth policies are written by web services, not by users, so users lack true authority over their access controls.
OAuth also does not leverage cryptography to protect user storage or enforce access policies.
As a result, users have no strong assurances about how their data is exposed.
OAuth is also vulnerable to various kinds of data leaks [33,64].
AAuth [65] is an extension of OAuth which uses cryptography to delegate access to encrypted data.
However, AAuth relies on the existence of various trusted parties to enforce access policies.
In Sieve, users generate their own policies and distrust the storage server and third party applications.
Sieve's policy language is also richer than AAuth's fixed policy schemas.The OAuth protocol generates a token that principals use to access sensitive data.
Web services define many other types of "bearer tokens."
HTTP cookies [11] are a classic example.
Macaroons [14] improve upon cookies, using chained HMACs to verify and attenuate capabilities as a macaroon is passed between multiple parties.
Cookies and macaroons vouch for a principal's post-authorization status, whereas Sieve deals with the authorization itself.
Sieve is a new access control system that allows users to selectively expose their private cloud data to third party web services.
Sieve uses attribute-based encryption to translate human-understandable access policies into cryptographically enforceable restrictions.
Unlike prior solutions for encrypted storage, Sieve is compatible with rich, legacy web applications that require server-side computation.
Sieve is also the first ABE system that protects against device loss and supports full revocation of both data and metadata.
As a proof of concept, we integrated Sieve with two open-source web services, demonstrating that Sieve is a practical approach for restricting access to sensitive user data.
We thank our anonymous reviewers and our shepherd Brad Karp for their useful feedback.
This work was partially supported by an NSF Graduate Research Fellowship (Grant No. 2013135952) and by NSF awards CNS-1053143 and CNS-1413920.
