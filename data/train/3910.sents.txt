Conventional cryptographic services such as hardware-security modules and software-based key-management systems offer the ability to apply a pseudorandom function (PRF) such as HMAC to inputs of a client's choosing.
These services are used, for example, to harden stored password hashes against offline brute-force attacks.
We propose a modern PRF service called PYTHIA designed to offer a level of flexibility, security, and ease-of-deployability lacking in prior approaches.
The key-stone of PYTHIA is a new cryptographic primitive called a verifiable partially-oblivious PRF that reveals a portion of an input message to the service but hides the rest.
We give a construction that additionally supports efficient bulk rotation of previously obtained PRF values to new keys.
Performance measurements show that our construction, which relies on bilinear pairings and zero-knowledge proofs, is highly practical.
We also give accompanying formal definitions and proofs of security.
We implement PYTHIA as a multi-tenant, scalable PRF service that can scale up to hundreds of millions of distinct client applications on commodity systems.
In our prototype implementation, query latencies are 15 ms in local-area settings and throughput is within a factor of two of a standard HTTPS server.
We further report on implementations of two applications using PYTHIA, showing how to bring its security benefits to a new enterprise password storage system and a new brainwallet system for Bitcoin.
Security improves in a number of settings when applications can make use of a cryptographic key stored on a remote system.
As an important example, consider the compromise of enterprise password databases.
Best practice dictates that passwords be hashed and salted before storage, but attackers can still mount highly effective brute-force cracking attacks against stolen databases.Well-resourced enterprises such as Facebook [38] have therefore incorporated remote cryptographic operations to harden password databases.
Before a password is stored or verified, it is sent to a PRF service external to the database.
The PRF service applies a cryptographic function such as HMAC to client-selected inputs under a service-held secret key.
Barring compromise of the PRF service, its use ensures that stolen password hashes (due to web server compromise) cannot be cracked using an offline brute-force attack: an attacker must query the PRF service from a compromised server for each password guess.
Such online cracking attempts can be monitored for anomalous volumes or patterns of access and throttled as needed.While PRF services offer compelling security improvements, they are not without problems.
Even large organizations can implement them incorrectly.
For example, Adobe hardened passwords using 3DES but in ECB mode instead of CBC-MAC (or another secure PRF construction) [23], a poor choice that resulted in disclosure of many of its customers' passwords after a breach.
Perhaps more fundamental is that existing PRF services do not offer graceful remediation if a compromise is detected by a client.
Ideally it should be possible to cryptographically erase (i.e., render useless via key deletion) any PRF values previously used by the client, without requiring action by end users and without affecting other clients.
In general, PRF services are so inaccessible and cumbersome today that their use is unfortunately rare.In this paper, we present a next-generation PRF service called PYTHIA to democratize cryptographic hardening.
PYTHIA can be deployed within an enterprise to solve the issues mentioned above, but also as a public, multi-tenant web service suitable for use by any type of organization or even individuals.
PYTHIA offers several security features absent in today's conventional PRF services that are critical to achieving the scaling and flexibil-By using a unique secret key k for each client, PYTHIA supports individual key rotation should the value Y be stolen (or feared to be stolen).
With traditional PRF services and password storage, such key rotation is a headache, and in many settings impractical, because it requires transitioning stored values Y 1 , . . . , Y n (one for each user account) to a new PRF key.
The only way to do so previously was to have all n users re-enter or reset their passwords.
In contrast, the new primitive employed for F k in PYTHIA supports fast key rotation: the server can erase k, replace it with a new key k 񮽙 , and issue a compact (constant-sized) token with which the client can quickly update all of its PRF outputs.
This feature also enables forward-security in the sense that the client can proactively rotate k without disrupting its operation.PYTHIA provides other features as well, but we defer their discussion to Section 2.
Already, those listed above surface some of the challenging cryptographic tensions that PYTHIA resolves.
For example, the most obvious primitive on which to base PYTHIA is an oblivious PRF (OPRF) [27], which provides message privacy.
But for rate-limiting, PYTHIA requires clients to reveal t, and existing OPRFs cannot hide only a portion of a PRF input.
Additionally, the most efficient OPRFs (c.f., [28]) are not amenable to key rotation.
We discuss at length other related concepts (of which there are many) in Section 7.Partially-oblivious PRFs.We introduce partially oblivious PRFs (PO-PRFs) to rectify the above tension between fine-grained key management and bulk key management and achieve a primitive that supports batch key rotation.
We give a PO-PRF protocol in the random oracle model (ROM) similar to the core of the identitybased non-interactive key exchange protocol of Sakai, Ohgishi, and Kasahara [44].
This same construction was also considered as a left-or-right constrained PRF by Boneh and Waters [13].
That said, the functionality achieved by our PO-PRF is distinct from these prior works and new security analyses are required.
Despite relying on pairings, we show that the full primitive is fast even in our prototype implementation.In addition to a lack of well-matched cryptographic primitives, we find no supporting formal definitions that can be adapted for verifiable PO-PRFs.
(Briefly, previous definitions and proofs for fast OPRFs rely on hashing in the ROM before outputting a value [16,28]; in our setting, hashing breaks key rotation.)
We propose a new assumption (a one-more bilinear decisional Diffie-Hellman assumption), give suitable security definitions, and prove the security of the core primitive in PYTHIA under these definitions (in the appendix; complete results in [25]).
Our new definitions and technical approaches may be of independent interest.Using PYTHIA in applications.We implement PYTHIA and show that it offers highly practical performance on Amazon EC2 instances.
Our experiments demonstrate that PYTHIA is practical to deploy using offthe-shelf components, with combined computation cost of client and server under 12 milliseconds.
A single 8-core virtualized server can comfortably support over 1,000 requests per second, which is already within a factor of two of a standard HTTPS server in the same configuration.
(Our PYTHIA implementation performs all communication over TLS.)
We discuss scaling to handle more traffic volume in the body; it is straightforward given current techniques.We demonstrate the benefits and practicality of PYTHIA for use in a diverse set of applications.
First is our running example above: we build a new passworddatabase system using a password "onion" that combines parallelized calls to PYTHIA and a conventional key hashing mechanism.
Our onion supports PYTHIA key rotation, hides back-end latency to PYTHIA during logins (which is particularly important when accessing PYTHIA as a remote third-party service), and achieves high security in a number of compromise scenarios.Finally, we show that PYTHIA provides valuable features for different settings apart from enterprise password storage.
We implement a client that hardens a type of password-protected virtual-currency account called a "brainwallet" [14]; use of PYTHIA here prevents offline brute-force attacks of the type that have been common in Bitcoin.Our prototype implementation of PYTHIA is built with open-source components and itself is open-source.
We have also released Amazon EC2 images to allow companies, individuals, and researchers to spin-up PYTHIA instances for experimentation.
We now give a high-level overview of PYTHIA, the motivations for its features, what prior approaches we investigated, and the threat models we assume.
First we fix some terminology and a high-level conceptual view of what a PRF service would ideally provide.
The service is provisioned with a master secret key msk.
This will be used to build a tree that represents derived sub-keys and, finally, output values.
See Figure 1, which depicts an example derivation tree associated with PYTHIA as well as which portions of the tree are held by the server (within the large box) and which are held by the client (the leaves).
Keys of various kinds are denoted by circles and inputs by squares.From the msk we derive a number of ensemble keys.
Each ensemble key is used by a client for a set of related PRF invocations -the ensemble keys give rise to isolated PRF instances.
We label each ensemble key in the diagram by K[w].
Here w indicates a clientchosen ensemble selector.
An ensemble pre-key K[w] is a large random value chosen and held by the server.
To- gether, msk and K[w] are used to derive the ensemble key k w = HMAC(msk, K [w]).
A table is necessary to support cryptographic erasure of (or updates to) individual ensemble keys, which amounts to deleting (or updating) a table entry.Each ensemble key can be used to obtain PRF outputs of the form F kw (t, m) where F is a (to-be-defined) PRF keyed by k w , and the input is split into two parts.
We call t a tweak following [30] and m the message.
Looking ahead t will be made public to PYTHIA while m will be private.
This is indicated by the shading of the PRF output boxes in the figure.Deployment scenarios.
To motivate our design choices and security goals, we relay several envisioned deployment scenarios for PYTHIA.Enterprise deployment: A single enterprise can deploy PYTHIA internally, giving query access only to other systems they control.
A typical setup is that PYTHIA fields queries from web servers and other public-facing systems that are, unfortunately, at high risk of compromise.
PRF queries to PYTHIA harden values stored on these vulnerable servers.
This is particularly suited to storing check-values for passwords or other low-entropy authentication tokens, where one can store F kw (t, m) where t is a randomly chosen, per-user identifier (a salt) and m is the low-entropy password or authentication token.
Here w can be distinct for each server using PYTHIA.Public cloud service: A public cloud such as Amazon EC2, Google Compute Engine, or Microsoft Azure can deploy PYTHIA as an internal, multi-tenant service for their customers.
Multi-tenant here means that different customers query the same PYTHIA service, and the cloud provider manages the service, ensemble pre-key table, etc.
This enables smaller organizations to obtain the benefits of using PYTHIA for other cloud properties (e.g., web servers running on virtual machine instances) while leaving management of PYTHIA itself to experts.Public Internet service: One can take the public cloud service deployment to the extreme and run PYTHIA instances that can be used from anywhere on the Internet.
This raises additional performance concerns, as one cannot rely on fast intra-datacenter network latencies (submillisecond) but rather on wide-area latencies (tens of milliseconds).
The benefit is that PYTHIA could then be used by arbitrary web clients, for example we will explore this scenario in the context of hardening brainwallets via PYTHIA.One could tailor a PRF service to each of these settings, however it is better to design a single, applicationagnostic service that supports all of these settings simultaneously.
A single design permits reuse of opensource implementations; standardized, secure-by-default configurations; and simplifies the landscape of PRF services.Security and functionality goals.
Providing a single suitable design requires balancing a number of security and functionality goals.
The most obvious requirements are for a service that: provides low-latency protocols (i.e., single round-trip and amenable for implementation as simple web interfaces); scales to hundreds of millions of ensembles; and produces outputs indistinguishable from random values even when adversaries can query the service.
To this list of basic requirements we add:• Message privacy: The PRF service must learn nothing about m. Message privacy supports clients that require sensitive values such as passwords to remain private even if the service is compromised, or to promote psychological acceptability in the case that a separate organization (e.g., a cloud provider) manages the service.
• Tweak visibility: The server must learn tweak t to permit fine-grained rate-limiting of requests.
1 In the password storage example, a distinct tweak is assigned to each user account, allowing the service to detect and limit guessing attempts against individual user accounts.
• Verifiability: A client must be able to verify that a PRF service has correctly computed F kw for a ensemble selector w and tweak/message pair t, m.
This ensures, after first use of an ensemble by a client, that a subsequently compromised server cannot surreptitiously reply to PRF queries with incorrect values.
2• Client-requested ensemble key rotations: A client must be permitted to request a rotation of its ensemble pre-key K[w] to a new one 񮽙 K[w].
The server must be able to provide an update token ∆ w to roll forward PRF outputs under K[w] to become PRF outputs under 񮽙 K [w], meaning that the PRF is keyupdatable with respect to ensemble keys.
Additionally, ∆ w must be compact, i.e., constant in the number of PRF invocations already performed under w. Clients can mandate that rotation requests be authenticated (to prevent malicious key deletion).
A client must additionally be able to transfer an ensemble from one selector w to another selector w 񮽙 .
• Master secret rotations: The server must be able to rotate the master secret key msk with minimal impact on clients.
Specifically, the PRF must be keyupdatable with respect to the master secret key msk so that PRF outputs under msk can be rolled forward to a new master secret 񮽙 msk.
When such a rotation occurs, the server must provide a compact update token δ w for each ensemble w.• Forward security: Rotation of an ensemble key or master secret key results in complete erasure of the old key and the update token.Two sets of challenges arise in designing PYTHIA.
The first is cryptographic.
It turns out that the combination of requirements above are not satisfied by any existing protocols we could find.
Ultimately we realized a new type of cryptographic primitive was needed that proves to be a slight variant of oblivious PRFs and blind signatures.
We discuss the new primitive, and our efficient protocol realizing it, in the next section.
The second set of challenges surrounds building a full-featured service that provides the core cryptographic protocol, which we treat in Section 4.
We introduce the notion of a (verifiable) partiallyoblivious PRF.
This is a two-party protocol that allows the secure computation of F kw (t, m), where F is a PRF with server-held key k w and t, m are the input values.
The client can verify the correctness of F kw (t, m) relative to a public key associated to k w .
Following our terminology, t is a tweak and m is a message.
We say the PRF is partially oblivious because t is revealed to the server, but m is hidden from the server.Partially oblivious PRFs are closely related to, but distinct from, a number of existing primitives.
A standard oblivious PRF [27], or its verifiable version [28], would hide both t and m, but masking both prevents granular rate limiting by the server.
Partially blind signatures [1] allow a client to obtain a signature on a similarly partially blinded input, but these signatures are randomized and the analysis is only for unforgeability which is insufficient for security in all of our applications.We provide more comparisons with related work in Section 7 and a formal definition of the new primitive in Appendix B.
Here we will present the protocol that suffices for PYTHIA.
It uses an admissible bilinear pairing e :G 1 × G 2 → G T over groups G 1 , G 2 , G T of primeorder q, and a pair of hash functions H 1 : {0, 1} * → G 1 and H 2 : {0, 1} * → G 2 (that we will model as random oracles).
More details on pairings are provided in Appendix B.
A secret key k w is an element of p .
The PRF F that the protocol computes is:F kw (t, m) = e 񮽙 H 1 (t), H 2 (m) 񮽙 kw .
This construction coincides with the Sakai, Ohgishi, and Kasahara [44] construction for non-interactive identitybased key exchange, where t and m would be different identities and k w a secret held by a trusted key authority.
Likewise, this construction is equivalent to the left-orright constrained PRF of Boneh and Waters [13].
The PRF-Cl (w, t, m)PRF-Srv (msk) r ←$ q x ← H 2 (m) r w, t, x - ˜ x ← e(H 1 (t), x) kw ← HMAC(msk, K[w]) pw ← g kw y ← ˜ x kw pw, y, π π ←$ ZKP(DLg(pw) = DL˜xDL˜ DL˜x (y))If pw matches & π verifies then Ret y 1/r Else Ret ⊥ Figure 2: The partially-oblivious PRF protocol used in PYTHIA.
The value π is a non-interactive zeroknowledge proof that the indicated discrete logs match.
The client also checks that p w matches ones seen previously when using selector w.contexts of these prior works are distinct from ours and our analyses will necessarily be different, but we note that all three settings similarly exploit the algebraic structure of the bilinear pairing.
See Section 7 for further discussion of related work.The client-server protocol that computes F kw (t, m) in a partially-oblivious manner is given in Figure 2.
There we let g be a generator of G 1 .
We now explain how the protocol achieves our requirements described in the last section.Blinding the message: In our protocol, the client blinds the message m, hiding it from the server, by raising it to a randomly selected exponent r ←$ q .
Ase 񮽙 H 1 (t), H 2 (m) r 񮽙 = e 񮽙 H 1 (t), H 2 (m)񮽙 r , the client can unblind the output y of PRF-Srv by raising it to 1/r.
This protocol hides m unconditionally, as H 2 (m) r is a uniformly random element of G 2 .
Verifiability: The protocol enables a client to verify that the output of PRF-Srv is correct, assuming the client has previously stored p w .
The server accompanies the output y of the PRF with a zero-knowledge proof π of correctness.
Specifically, for a public key p w = g kw , where g is a generator of G 1 , the server proves DL g (p w ) = DL˜xDL˜ DL˜x (y).
Standard techniques (see, e.g., Camenisch and Stadler [17]) permit efficient ZK proofs of this kind in the random oracle model.
3 The notable computational costs for the server are one pairing and one exponentiation in 3 Some details: The prover picks v ←$ q and then computes t 1 = g v and t 2 = ˜x v and c ← H 3 (g, pw, ˜ x, y, t 1 , t 2 ).
Let u = v − c · k.
The proof is π = (c, u).
The verifier computes t 񮽙 1 = g u · p c w and t 񮽙 2 = ˜ x u y c .
It outputs true if c = H 3 (g, pw, ˜ x, y, t 񮽙 1 , t 񮽙 2 ).
G T ; for the client, one pairing and two exponentiations in G T .
4Efficient key updates: The server can quickly and easily update the key k w for a given ensemble selector w by replacing the table entry s = K[w] with a new, randomly selected value s 񮽙 , thereby changing k w = HMAC(msk, s) to k 񮽙 w = HMAC(msk, s 񮽙 ).
It can then transmit to the client an update token of the form∆ w = k 񮽙 w /k w ∈ q .
The client can update any stored PRF valueF kw (t, m) = e 񮽙 H 1 (t), H 2 (m) 񮽙 kw by raising it to ∆ w ;it is easy to see thatF kw (t, m) ∆w = F k 񮽙 w (t, m).
The server can use the same mechanism to update msk, which requires generating a new update token for each w and pushing these tokens to clients as needed.Unblinded variants.
For deployments where obliviousness of messages is unnecessary, we can use a faster, unblinded variant of the PYTHIA protocol that dispenses with pairings.
The only changes are that the client sends m to the server, there is no unblinding of the server's response, and, instead of computing˜xcomputing˜ computing˜x ← e(H 1 (t), x) the server computes˜x computes˜ computes˜x ← H 3 (t 񮽙 m) .
All group operations in this unblinded variant are over a standard elliptic curve group G = 񮽙g񮽙 of order q and we use a hash function H 3 : {0, 1} * → G.An alternative unblinded construction would be to have the server apply the Boneh-Lynn-Shacham short signatures [12] to the client-submitted t 񮽙 m; verification of correctness can be done using the signature verification routine, and we can thereby avoid ZKPs.
This BLS variant may save a small amount of bandwidth.These unblinded variants provide the same services (verifiability and efficient key updates) and security with the obvious exception of the secrecy of the message m.
In some deployment contexts an unblinded protocol may be sufficient, for example when the client can maintain state and submit a salted hash m instead of m directly.
In this context, the salt should be held as a secret on the client and never sent to the server.
Figure 3 gives the high-level API exposed by PYTHIA to a client.
We now describe its functions in terms of the lifecycle of an ensemble key.
We assume a security parameter n specifying symmetric key lengths; a typical choice would be n = 128.
Init ( We defer to later sections the underlying client-server protocols and to Appendix A details on key lifecycle management options, additional API calls for token management and ensemble transfer, and a discussion of master secret key rotation.Ensemble initialization.
To begin using the PYTHIA service, a client creates an ensemble key for selector w by invoking Init(w [, options]).
PYTHIA generates a fresh, random table entryK[w].
Recall that ensemble key k w = HMAC(msk, K[w]).
So Init creates k w as a byproduct.Ideally, w should be an unguessable byte string.
(An easily guessed one may allow attackers to squat on a key selector, thereby mounting a denial-of-service (DoS) attack.)
For some applications, as we explain below, this isn't always possible.
If an ensemble key for w already exists, then the PYTHIA service returns an error to the client.
Otherwise, the client receives a message signifying that initialization is successful.Init includes a number of options we detail in Appendix A.PRF evaluation.
To obtain a PRF value, a client can perform an evaluation query Eval(w, t, m), which returns F kw (t, m).
Here t is a tweak and m is a message.
To compute the PRF output, the client and server perform a one-round cryptographic protocol (meaning a single message from client to server, and one message back).
We present details in Section 3, but remind the reader that t is visible to the server in the client-server protocol invoked by Eval, while m is blinded.The server rate-limits requests based on the tweak t, and can also raise an alert if the rate limit is exceeded.
We give example rate limiting policies in Section 5.Ensemble-key reset.
A client can request that an ensemble key k w be reset by invoking Reset(w).
This reset is accomplished by overwriting K[w] with a fresh, random value.
The name service returns a compact (e.g., 256-bit) update token ∆ w that the client may use to update all PRF outputs for the ensemble.
It stores this token locally, encrypted under a public key specified by the client, as explained below.Note that reset results in erasure of the old value of k w .
Thus a client that wishes to delete an ensemble key k w permanently at the end of its lifecycle can do so with a Reset call.Reset is an authenticated call, and thus requires the following capability.Authentication.
To authenticate itself for API calls, the client must first invoke GetAuth, which has the server transmit an (encrypted) authentication token authtoken to the client out-of-band.
The token expires after a period of time determined by a configuration parameter in PYTHIA.
Our current implementation uses e-mail for this, see Appendix A for more details.
Of course, in some deployments one may want authentication to be performed in other ways, such as tokens dispensed by administrators (for enterprise settings) or simply given out on a first-come-first-serve basis for each ensemble identifier (for public Internet services).
We implemented a prototype PYTHIA PRF service as a web application accessed over HTTPS.
All requests are first handled by an nginx web server with uWsgi as the application server gateway that relays requests to a Django back-end.
The PRF-Srv functionality is implemented as a Django module written in Python.
Storage for the server's key table and rate-limiting information is done in MongoDB.We use the Relic cryptographic library [2] (written in C) with our own Python wrapper.
We use BarretoNaehrig 254-bit prime order curves (BN-254) [4].
These curves provide approximately 128-bits of security.In our experiments the service is run on a single (virtual) machine, but our software stack permits components (web server, application sever, database) to be distributed among multiple machines with updates to configuration files.For the purpose of comparison, we implemented three variants of the PYTHIA service.
The first two are the unblinded protocols described in Section 3.
In these two schemes, the client sends m in the clear (possibly hashed with a secret salt value first) and the server replies with y = H 1 (t 񮽙 m) k .
In the first scheme, denoted UNB, the server provides p = g k 1 and a zero-knowledge proof where g 1 is a generator of G 1 .
The second scheme, denoted BLS, uses a BLS signature for verification.
The server provides p = g k 2 where g 2 is a generator of G 2 and the client verifies the response by computing and comparing the values: e(y, g 2 ) = e(H 1 (t 񮽙 m), p).
Our partially-oblivious scheme is denoted PO.For the evaluation below we use a Python client implementing PRF-Cl for all three schemes using the same libraries indicated above for the server and httplib2 to perform HTTPS requests.
For performance and scalability evaluation we hosted our PYTHIA server implementation on Amazon's Elastic Compute Cloud (EC2) using a c4.xlarge instance which provides 8 virtual CPUs (Intel Xeon third generation, 2.9GHz), 15 GB of main memory, and solid state storage.
The web server, nginx, was configured with basic settings recommended for production deployment including one worker process per CPU.Latency.
We measured client query latency for each protocol using two clients: one within the same Amazon Web Service (AWS) availability zone (also c4.xlarge) and one hosted at the University of Wisconsin-Madison with an Intel Core i7 CPU (3.4 GHz).
We refer to the first as the LAN (local-area network) setting and the second as the WAN (wide-area network) setting.
In the LAN settings we used the AWS internal IP address.
All queries were made over TLS and measurements include the time required for clients to blind messages and unblind results (PO), as well as verify proofs provided by the server (unless indicated otherwise).
All machines used for evaluation were running Ubuntu 14.04.
Microbenchmarks for group operations appear in Figure 4 and Figure 5 shows the timing of individual operations that comprise a single PRF evaluation.
All results are mean values computed over 10,000 operations.
These values were captured on an EC2 c4.xlarge instance using the Python profiling library line profiler.
The most expensive operations, by a large margin, are exponentiation in G t and the pairing operation.
By extension, PO sign, prove, and verify operations become expensive.We measured latencies averaged over 1,000 PRF requests (with 100 warmup requests) for each scheme and the results appear in Figure 6.
Computation time dominates in the LAN setting due to the almost negligible network latency.
The WAN case with cold connections (no HTTP KeepAlive) pays a performance penalty due to the four round-trips required to set up a new TCP and TLS connection.
While even 400 ms latencies are not prohibitive in our applications, straightforward engineering Time (ms) improvements would vastly improve WAN timing: using TLS session resumption, using lower-latency secure protocol like QUIC [43], or even switching to a custom UDP protocol (for an example one for oblivious PRFs, see [5]).
Throughput.
We used the distributed load testing tool autobench to measure maximum throughput for each scheme.
We compare to a static page containing a typical PRF response served over HTTPS as a baseline.
We used two clients in the same AWS region as the server.
All connections were cold: no TLS session resumption or HTTP KeepAlive.
The maximum throughput for a static page is 2,200 connections per second (cps); UNB and BLS 1,400 cps; and PO 1,350 cps.
Thus our PYTHIA implementation can handle a large number of clients on a single EC2 instance.
If needed, the implementation can be scaled with standard techniques (e.g., a larger number of web servers and application servers on the front-end with a distributed key-value store on the back-end).
Storage.
Our implementation stores all ensemble prekey To rate-limit queries, our implementation stores tweak values along with a counter and a timestamp (to expire old entries) in MongoDB.
Tweak values are also hashed using SHA-256 which ensures entries are of constant length.
In our implementation each distinct tweak requires an average of 144 bytes per entry (including overheads and indexes).
Note however that rate limiting entries are purged periodically as counts are only required for one rate-limiting period.
Our implementation imposes rate-limits at hour granularity.
Assuming a maximum throughput of 2,000 requests per second, ratelimiting storage never exceeds 1 GB.All told, with only 20 GB stored data, PYTHIA can serve over 100 M clients and perform rate-limiting at hour granularity.
Thus fielding a database for PYTHIA can be accomplished on commodity hardware.
Web servers and other systems frequently store passwords in hashed form.
A password onion is the result of additionally invoking a PRF service to harden the hash.
In currently suggested onions, one sequentially combines local hashing and application of the PRF service.We now present a service that we have implemented on top of PYTHIA for managing password onions.
First, we describe the limitations of contemporary systems as exemplified by a recently disclosed architecture employed by Facebook [39].
Then we show how our password-onion system, which was easily engineered on top of PYTHIA, can address these limitations.In what follows, we use the term "client" or "web server" to denote the server performing authentication and storing derived values from passwords and "PRF server" to denote the PYTHIA service.
An example of a contemporary system, used by Facebook, is given in Figure 7.
5 Their PRF service applies HMAC using a service-held secret and returns the result.
In this architecture, an adversary that compromises the web server and the password hashes it stores must still mount an online attack against the PRF service to compromise accounts.
This is a big advance on the hashingonly practices that are commonly used.PW-Onion(pw) h 1 ← MD5(pw) sa ←$ {0, 1} 160 h 2 ← HMAC[SHA-1](h 1 , sa) h 3 ← PRF-Cl(h 2 ) = HMAC[SHA-256](h 2 , msk) h 4 ← scrypt(h 3 , sa) h 5 ← HMAC[SHA-256](h 4 ) Ret (sa,hThe Facebook architecture nevertheless has some shortcomings.
It is easy to see from Figure 7 that Facebook's system, like most contemporary PRF services, lacks several important features present in PYTHIA.
One is message privacy: the Facebook PRF service applies HMAC to h 2 .
This is the salted hash of the password, and so learning the salt as well as compromising the PRF service suffices to re-enable offline brute-force attacks.
This threat is avoided by PYTHIA due to blinding.Another feature is batch key updates.
In fact, the Facebook PRF service doesn't permit autonomous key updates at all, in the sense of an update to msk that can be propagated into PRF output updates.
Should the client (password database) be compromised, the only way to reconstitute a hash in an existing password onion is to wait until a user logs in and furnishes pw.
It is not clear whether the Facebook PRF service performs granular rate-limiting, although no such capability is indicated in [38].
PYTHIA, as we shall see, addresses all of these issues by design in our password onion system.The Facebook onion also presents a subtle performance issue.
By applying cryptographic primitives serially, the time to hash a password equals the time for local computations, call it t local , plus the time for the round-trip PRF service call, call it t prf .
An attacker that compromises the web service and PRF service incurs no network latency, and thus may gain a considerable advantage in guessing time over an honest web server.
In our PYTHIA-based password onion service, we address this issue by observing that it is possible to avoid serialization of key derivation functions on the web server and the PRF service call.
That is, we introduce in our PYTHIA-based service the idea of parallelizable password onions.UpParOnion(w, sa, pw) z ← PBKDF(pw, sa) u ← PRF-Cl(w, sa, pw) h ← u z Ret (h, sa)Figure 8: An updatable, parallelizable password onion.
PRF-Cl returns elements of a group G.
The value w is a unique PRF-service identifier for the web server (e.g., a random 256-bit string) and sa is a random per-user salt value.
The onion algorithm we construct for PYTHIA is shown in Figure 8.
For PYTHIA, the output of PRF-Cl is an element of a group G T .
To use this service, a web server stores (h, sa) upon password registration; it verifies a proffered password pw 񮽙 by checking that UpParOnion(w, sa, pw 񮽙 ) = h. Written out we have that:h = u z = e(H 1 (sa), H 2 (pw)) kwz .
This design ensures that the key update functions in the PYTHIA API may be used to update onions as well.
For example, to update an ensemble key k w to k 񮽙 w , the service computes and furnishes to the web server an update token∆ w = k 񮽙 w /k w .
The web server may compute h ∆w for each stored value h.Parallelization.
Password verification here is parallelizable in the sense that z and u may be computed independently and then combined.
Such parallel implementation of the onion achieves a password verification latency of max{t local , t prf } (plus a single exponentiation), as opposed to t local + t prf in a serialized implementation.A web server generally aims to achieve a verification latency equal to some latency target T that is high enough to slow offline brute-force attacks, but low enough not to burden users.
For a parallelized onion a web server can meet its latency target by setting t local , t prf ≈ T .
At the same time an offline attacker that has compromised the web server and PYTHIA must perform about t local +t F > T work to check a single password guess, where t F is the computation time of F kw (i.e., t prf minus network latency).
An attacker can parallelize, but her total work still goes up relative to the serial onion approach for the same latency target T .
We estimate the security improvement of parallel onions over serial onions using our benchmarks from Section 4.2.
We fix a login latency budget of T = 300 ms. 6 The latency costs for a PYTHIA query with hot connections are 12 ms (LAN) and 96 ms (WAN).
If one performs computations serially with a fixed T then PBKDF computations need to be reduced by 4% (LAN) and 32% (WAN) compared to the parallel approach.
In the event that the PYTHIA server and password database are compromised, the serial onion enables speedup of offline dictionary attacks by the same percentages.Rate limiting and logging.
The transparency of tweaks enables the PYTHIA PRF service in this setting to execute any of a wide range of rate-limiting policies with peraccount visibility (in contrast to what may be in Facebook an account-blind PRF service).
As an example demonstrating the flexibility of our architecture, in our implementation PYTHIA performs a tiered rate-limiting: for a given account (t), it limits queries to at most 10 per hour per account, and at most 300 per month.
(In expectation, guessing a random 4-digit PIN would require 1.4 years under this policy.)
It logs violations of these thresholds.
In a production environment, it could also send alerts to security administrators.We emphasize that a wide range of other rate-limiting policies is possible.
We also point out that PYTHIA's rate limiting supplements that normally implemented at the web server for remote login requests.
PYTHIA performs rate limiting and may issue alerts even if the web server is compromised.Key update.
The key update calls in the PYTHIA API, and the ability to rotate either k w or msk efficiently, propagates up to the password onion service.
Key updates instantly invalidate the web server's existing password database-a useful capability in case of compromise.
A compromised database becomes useless to an attacker attempting to recover passwords, even with the ability to query PYTHIA.
Using a key update token, the web server can then recover from compromise by refreshing its database.We created a client simulator with MongoDB and the mongoengine Python module.
With this we benchmarked key updates with 100,000 database entries.
The client requested a key update from PYTHIA, received the update token ∆ w , and updated each database entry.
The complete update required less than 1 ms per entry, and terminated in less than 97 seconds for all 100,000 entries.
For a larger database we assume updates scale linearly, and so an update for 1 million users completes in under 17 minutes.The web server need not need lock the database to perform updates; it can execute them in parallel with normal login operations.
Doing so does require additional versioning information for each entry to indicate the version of k w (in the simplest form, whether or not it has received the latest update).
Brainwallets are a common but dangerous way to secure accounts in the popular cryptocurrency Bitcoin, as well as in less popular cryptocurrencies such as Litecoin.Here we describe how the PYTHIA service can be used directly as a means to harden brainwallets.
This application showcases the ease with which a wide variety of applications can be engineered around PYTHIA.How brainwallets work.
Every Bitcoin account has an associated private / public key pair (sk, pk).
The private key sk is used to produce digital (ECDSA) signatures that authorize payments from the account.
The public key pk permits verification of these signatures.
It also acts as an account identifier; a Bitcoin address is derived by hashing pk (under SHA-256 and RIPEMD-160) and encoding it (in base 58, with a check value).
Knowledge of the private key sk equates with control of the account.
If a user loses a private key, she therefore loses control over her account.
For example, if a high entropy key sk is stored exclusively on a device such as a mobile phone or laptop, and the device is seized or physically destroyed, the account assets become irrecoverable.Brainwallets offer an attractive remedy for such physical risks of key loss.
A brainwallet is simply a password or passphrase P memorized by a Bitcoin account holder.
The private key sk is generated directly from P .
Thus the user's memory serves as the only instrument needed to authorize access to the account.In more detail, the passphrase is typically hashed using SHA-256 to obtain a 256-bit string sk = SHA-256(P ).
Bitcoin employs ECDSA signatures on the secp256k1 elliptic curve; with high probability (≈ 1 − 2 −126 ), sk is less than the group order, and a valid ECDSA private key.
(Some websites employ stronger key derivation functions.
For example, WrapWallet by keybase.io [29] derives sk from an XOR of each of PBKDF2 and scrypt applied to P and permits use of a user-supplied salt.)
Since a brainwallet employs only P as a secret, and does not necessarily use any additional security measures, an attacker that guesses P can seize control of a user's account.
As account addresses are posted publicly in the Bitcoin system (in the "blockchain"), an attacker can easily confirm a correct guess.
Brainwallets are thus vulnerable to brute-force, offline guessing attacks.
Numerous incidents have come to light showing that brainwallet cracking is pandemic [14].
7 PYTHIA offers a simple, powerful means of protecting brainwallets against offline attack.
Hardening P in the same manner as an ordinary password yields a strong key˜P key˜ key˜P that can serve in lieu of P to derive sk.To use PYTHIA, a user chooses a unique identifier id, e.g., her e-mail address, an account identifier acct, and a passphrase P .
The identifier acct might be used to distinguish among Bitcoin accounts for users who wish to use the same password for multiple wallets.
The client then sends (w = id, t = id 񮽙 acct, m = P ) to the PYTHIA service to obtain the hardened value F kw (t, m) = ˜ P .
Here, id is used both as an account identifier and as part of the salt.
Message privacy in PYTHIA ensures that the service learns nothing about P .
Theñ P is hashed with SHA-256 to yield sk.
The corresponding public key pk and address are generated in the standard way from sk [7].
PYTHIA forces a would-be brainwallet attacker to mount an online attack to compromise an account.
Not only is an online attack much slower, but it may be ratelimited by PYTHIA and detected and flagged.
As the PYTHIA service derives˜Pderives˜ derives˜P using a user-specific key, it additionally prevents an attacker from mounting a dictionary attack against multiple accounts.
While in the conventional brainwallet setting, two users who make use of the same secret P will end up controlling the same account, PYTHIA ensures that the same password P produces distinct per-user key pairs.Should an attacker compromise the PYTHIA service and steal msk and K, the attacker must still perform an offline brute-force attack against the user's brainwallet.
So in the worst case, a user obtains security with PYTHIA at least as good as without it.Additional security issues.
A few subtle security issues deserve brief discussion:• Stronger KDFs: To protect against brute-force attack in the event of PYTHIA compromise, a resource-intensive key-derivation function may be desirable, as is normally used in password databases.
This can be achieved by replacing the SHA-256 hash of˜Pof˜ of˜P above with an appropriate KDF computation, or alternatively using an onion approach described in Section 5.
• Denial-of-service: By performing rate-limiting, PYTHIA creates the risk of targeted denial-ofservice attacks against Bitcoin users.
As Bitcoin is pseudonymous, use of an e-mail address as a PYTHIA key-selector suffices to prevent such attacks against users based on their Bitcoin addresses alone.
Users also have the option, of course, of using a semi-secret id.
A general DoS attack against the PYTHIA service is also possible, but of similar concern for Bitcoin itself [8].
• Key rotation: Rotation of an ensemble key k w (or the master key msk) induces a new value of˜Pof˜ of˜P and thus a new (sk, pk) pair and account.
A client can handle such rotations in the na¨ıvena¨ıve way: transfer funds from the old address to the new one.
• Catastrophic failure of PYTHIA: If a PYTHIA service fails catastrophically, e.g., msk or K is lost, then in a typical setting, it is possible simply to reset users' passwords.
In the brainwallet case, the result would be loss of virtual-currency assets protected by the server-a familiar event for Bitcoin users [35].
This problem can be avoided, for instance, using a threshold implementation of PYTHIA, as mentioned in Section 6.2 or storing sk in a secure, offline manner like a safe-deposit box for disaster recovery.
In order to gain both redundancy and security, we give a threshold scheme that can be used with a number of Pythia servers to protect a secret under a single password.
This scheme uses Shamir's secret sharing threshold scheme [45] and gives (k, n) threshold security.
That is, initially, n Pythia servers are contacted and used to protect a secret s, and then any k servers can be used to recover s and any adversary that has compromised fewer than k Pythia servers learns no information about s.Preparation.
The client chooses an ensemble key selector w, tweak t, password P , and contacts n Pythia servers to compute q i = PRF-Cl i (w, t, P ) mod p for 0 < i ≤ n.
The client selects a random polynomial of degree k − 1 with coefficients from * p where p is a suitably large prime: f (x) = 񮽙 k−1 j=0 x j a j .
Let the secret s = a 0 .
Next the client computes the vector Φ = (φ 1 , ..., φ n ) where φ i = f (i) − q i .
The client durably stores the value Φ, but does not need to protect it (it's not secret).
The client also stores public keys p i from each Pythia server to validate proofs when issuing future queries.Recovery.
The client can reconstruct s if she has Φ by querying any k Pythia servers giving k values q i .
These q i values can be applied to the corresponding Φ values to retrieve k distinct points that lie on the curve f (x).
With k points on a degree k − 1 curve, the client can use interpolation to recover the unique polynomial f (x), which includes the curve's intercept a 0 = s.Security.
If an adversary is given Φ, w, t, the public keys p i , a ciphertext based on s, and the secrets from m < k Pythia servers, the adversary has no information that will permit her to verify password guesses offline.
Compared to [45], this scheme reduces the problem of storing n secrets to having access to n secure OPRFs and durable (but non-secret) storage of the values Φ and public keys p i .
Verification.
Verification of server responses occurs within the Pythia protocol.
If a server is detected to be dishonest (or goes out of service), it can be easily replaced by the client without changing the secret s. To replace a Pythia server that is suspected to be compromised or detected as dishonest, the client reconstructs the secret s using any k servers, executes Reset operations on all remaining servers: this effects a cryptographic erasure on the values Φ and f (x).
The client then selects a new, random polynomial, keeping a 0 fixed, and generates and stores an updated Φ 񮽙 that maps to the new polynomial.
We investigated a number of designs based on existing cryptographic primitives in the course of our work, though as mentioned none satisfied all of our design goals.
Conventional PRFs built from block ciphers or hash functions fail to offer message privacy or key rotation.
Consider instead the construction H(t 񮽙 m) kw for H : {0, 1} * → G a cryptographic hash function mapping onto a group G.
This was shown secure as a conventional PRF by Naor, Pinkas, and Reingold assuming decisional Diffie-Hellman (DDH) is hard in G and when modeling H as a random oracle [40].
It supports key rotations (in fact it is key-homomorphic [11]) and verifiability can be handled using non-interactive zeroknowledge proofs (ZKP) as in PYTHIA.
But this approach fails to provide message privacy if we submit both t and m to the server and have it compute the full hash.One can achieve message-hiding by using blinding: have the client submit X = H(t 񮽙 m) r for random r ∈ |G| and the server reply with X kw as well as a ZKP proving this was done correctly.
The resulting scheme is originally due to Chaum and Pedersen [19], and suggested for use by Ford and Kaliski [26] in the context of threshold password-authenticated secret sharing (see also [3,15,20,34]).
There an end user interacts with one or more blind signature servers to derive a secret authentication token.
If G comes equipped with a bilinear pairing, one can dispense with ZKPs.
The resulting scheme is Boldyreva's blinded version [10] of BLS signatures [12].
However, neither approach provides granular rate limiting when blinding is used: the tweak t is hidden from the server.
Even if the client sends t as well, the server cannot verify that it matches the one used to compute X and attackers can thereby bypass rate limits.To fix this, one might use Ford-Kaliski with a sep-arate secret key for each tweak.
This would result in having a different key for each unique w, t pair.
Message privacy is maintained by the blinding, and querying w, t, H(t 񮽙 񮽙 m) r for t 񮽙 = t 񮽙 does not help an attacker circumvent per-tweak rate limiting.
But now the server-side storage grows in the number of unique w, t pairs, a client using a single ensemble w must now track N public keys when they use the service for N different tweaks, and key rotation requires N interactions with the PRF server to get N separate update tokens (one per unique tweak for which a PRF output is stored).
When N is large and the number of ensembles w is small as in our password storage application, these inefficiencies add significant overheads.Another issue with the above suggestions is that their security was only previously analyzed in the context of one-more unforgeability [42] as targeted by blind signatures [18] and partially blind signatures [1].
(Some were analyzed as conventional PRFs, but that is in a model where adversaries do not get access to a blinded server oracle.)
The password onion application requires more than unforgeability because message privacy is needed.
(A signature could be unforgeable but include the entire message in its signature, and this would obviate the benefits of a PRF service for most applications.)
These schemes, however, can be proven to be one-more PRFs, the notion we introduce, under suitable one-more DDH style assumptions using the same proof techniques found in Appendix B.Fully oblivious PRFs [27] and their verifiable versions [28] also do not allow granular rate limiting.
We note that the Jarecki, Kiayias, and Krawczyk constructions of verifiable OPRFs [28] in the RO model are essentially the Ford-Kaliski protocol above, but with an extra hash computation, making the PRF output H 񮽙 (t 񮽙 m 񮽙 H(t 񮽙 m) kw ).
Our notion of one-more unpredictability in the appendix captures the necessary requirements on the inner cryptographic component, and might modularize and simplify their proofs.
Their transform is similar to the unique blind signature to OPRF transformation of Camenisch, Neven, and shelat [16].
None of these efficient oblivious PRF protocols support key rotations (with compact tokens or otherwise) as the final hashing step destroys updatability.The setting of capture-resilient devices shares with ours the use of an off-system key-holding server and the desire to perform cryptographic erasure [32,33].
They only perform protocols for encryption and signing functionalities, however, and not (more broadly useful) PRFs.
They also do not support granular rate limiting and master secret key rotation.Our main construction coincides with prior ones for other contexts.
The Sakai, Ohgishi, and Kasahara [44] identity-based non-interactive key exchange protocol computes a symmetric encryption key as e(H 1 (ID 1 ), H 2 (ID 2 )) k for k a master secret held by a trusted party and ID 1 and ID 2 being the identities of the parties.
See [41] for a formal analysis of their scheme.
Boneh and Waters suggest the same construction as a left-or-right constrained PRF [13].
The settings and their goals are different from ours, and in particular one cannot use either as-is for our applications.
Na¨ıvelyNa¨ıvely one might hope that returning the constrained PRF key H 1 (t) kw to the client suffices for our applications, but in fact this totally breaks rate-limiting.
Security analysis of our protocol requires new techniques, and in particular security must be shown to hold when the adversary has access to a half-blinded oracle -this rules out the techniques used in [13,41].
Key-updatable encryption [11] and proxy reencryption [9] both support key rotation, and could be used to encrypt password hashes in a way supporting compact update tokens and that prevents offline brute-force attacks.
But this would require encryption and decryption to be handled by the hardening service, preventing message privacy.Verifiable PRFs as defined by [21,22,31,36] allow one to verify that a known PRF output is correct relative to a public key.
Previous verifiable PRF constructions are not oblivious, let alone partially oblivious.Threshold and distributed PRFs [21,37,40] as well as distributed key distribution centers [40] enable a sufficiently large subset of servers to compute a PRF output, but previous constructions do not provide the granular rate limiting and key rotation we desire.
However, it is clear that there are situations where applications would benefit from a threshold implementation of PYTHIA, for both redundancy and distribution of trust, as discussed in Section 6.2 for the case of brainwallets.
We presented the design and implementation of PYTHIA, a modern PRF service.
Prior works have explored the use of remote cryptographic services to harden keys derived from passwords or otherwise improve resilience to compromise.
PYTHIA, however, transcends existing designs to simultaneously support granular rate limiting, efficient key rotation, and cryptographic erasure.
This set of features, which stems from practical requirements in applications such as enterprise password storage, proves to require a new cryptographic primitive that we refer to as a partially oblivious PRF.Unlike a (fully) oblivious PRF, a partially oblivious PRF causes one portion of an input to be revealed to the server to enable rate limiting and detection of online brute-force attacks.
We provided a bilinear-pairing based construction for partially oblivious PRFs that is highly efficient and simple to implement (given a pairings library), and also supports efficient key rotations.
A formal proof of security is unobtainable using existing techniques (such as those developed for fully oblivious PRFs).
We thus gave new definitions and proof techniques that may be of independent interest.We implemented PYTHIA and show how it may be easily integrated it into a range of applications.
We designed a new enterprise "password onion" system that improves upon the one recently reported in use at Facebook.
Our system permits fast key rotations, enabling practical reactive and proactive key management, and uses a parallelizable onion design which, for a given authentication latency, imposes more computational effort on attackers after a compromise.
We also explored the use of PYTHIA to harden brainwallets for cryptocurrencies.
Many PYTHIA-dependent services can benefit from additional API features and calls beyond the primary ones discussed in the body of the paper.
(For example, the PYTHIA password onion system in Section 5 uses the Transfer API call.)
We detail these other API features in this appendix.Key-management options.
The client can specify a number of options in the call Init regarding management of the ensemble key k w .
The client can provide a contact email address to which alerts and authentication tokens may be sent.
(If no e-mail is given, no API calls requiring authentication are permitted at present and no alerts are provided.
Later versions of PYTHIA will support other authentication and alerting methods.)
The client can specify whether k w should be resettable (default is "yes").
The client can specify a limit on the total number of F kw queries that should be allowed before resetting K[w] (default is unlimited) and/or an absolute expiration date and time in UTC at which point K[w] is deleted (default is no time-out).
Either of these options overrides the resettable flag.
The client can specify a public key pk cl for a public-key encryption scheme under which to encrypt authentication tokens and update tokens (for Reset, Transfer, as described below, and for master secret key rotations).
Finally, the client can request that alerts be sent to the contact email address in the case of rate limit violations.
This option is ignored if no contact email is provided.
The options are summarized in Figure 9.
PYTHIA also offers some additional API calls, given in Figure 10, which we now describe.Ensemble transfer.
A client can create a new ensemble w 񮽙 (with the same options as in Init) while receiving an update token that allows PRF outputs under ensemble w to be rolled forward to w 񮽙 .
This is useful for importing a password database to a new server.
The PYTHIA service returns an update token ∆ w→w 񮽙 for this purpose and stores it encrypted under pk cl .
For the case w 񮽙 = w, this call also allows option updates on an existing ensemble w.Update-token handling.
The PYTHIA service stores update tokens encrypted under pk cl , with accompanying timestamps for versioning.
The API call SendTokens causes these to be e-mailed to the client, while PurgeTokens causes update-token ciphertexts to be deleted from PYTHIA.Note that once an update token is deleted, old PRF values to which the token was not applied become cryptographically erased -they become random values unrelated to any messages.
A client can therefore delete the key associated with an ensemble by calling Reset and PurgeTokens.Master secret rotations.
PYTHIA can also rotate its master secret key msk to a new key msk 񮽙 .
Recall that ensemble keys are computed as k w = HMAC(msk, K[w]), so rotation of msk results in rotation of all ensemble keys.
To rotate to a new msk 񮽙 , the server computes k w for all ensembles w with entries in K, and stores δ w encrypted under pk cl .
If no encryption key is set, then the token is stored in the clear.
This is a forward-security issue while it remains, but only for that particular key ensemble.
At this point msk is safe to delete.
Clients can be informed of the key rotation via e-mail.
Subsequent SendTokens requests will return the resulting update token, along with any other stored update tokens for the ensemble.
If multiple rotations occur between client requests, then these can be aggregated in the stored update token for each ensemble.
This is trivial if they are stored in the clear (just multiply the new token against the old) and also works if they are encrypted with an appropriately homomorphic encryption scheme such as ElGamal [24].
We provide formal security notions for partially oblivious PRFs, and proofs of security relative to them for our scheme from Section 3.Partially-oblivious PRFs.
A partially oblivious PRF protocol Π = (K, PRF-Cl, PRF-Srv, F ) consists of the following.
The key generation algorithm K outputs a public key and private key pair (pk, sk).
We assume that from sk one can compute pk easily.
The PRF-Srv algorithm takes input the secret key sk and a client request message (a bit string) and returns a server response message (another bit string).
The client algorithm PRF-Cl takes inputs a tweak t and message m, can make a single call to PRF-Srv, and outputs a value.
Finally we associate to the protocol a keyed function F sk : {0, 1} * × {0, 1} * → {0, 1} * .
A scheme is correct if executing PRF-Cl PRF-Srv sk (·) (t, m) with fresh coins matches F sk (t, m) with probability one.
In words, the protocol computes the appropriate function of t, m.Bilinear pairing setups.
Let G 1 , G 2 , G T be groups all of order p that have associated to them an admissible bilinear pairing e :G 1 × G 2 → G T .
Recall that for generators g 1 ∈ G 1 , g 2 ∈ G 2 , there exists a gen- erator g T ∈ G T such that e(g α 1 , g β 2 ) = g αβ Tfor all α, β ∈ p .
As shorthand for below we refer to a pairing setup G = (g 1 , g 2 , g T , G 1 , G 2 , G T , e) and assume some compact description of G as a bit-string where appropriate.The scheme.
The partially-oblivious PRF at the core 8 of our bilinear pairing scheme from Section 3 is as follows for some fixed pairing setup G. Let H 1 : {0, 1} * → G 1 and H 2 : {0, 1} * → G 2 be hash functions that we will later model as random oracles.Key generation K picks a random exponent sk and computes a public key pk = g s 1 k.
The PRF-Cl(t, m) algorithm computes a mask r ←$ p and sends t and x = H 2 (m) r to the server.
The PRF-Srv(sk, t, x) computes y = e(H 1 (t), x) s k and a ZKP π that DL g1 (pk) = DL˜xDL˜ DL˜x (y) where˜xwhere˜ where˜x = e(H 1 (t), x).
It sends pk, y, π to the client, who verifies the ZKP, deletes it, and then outputs y 1/r .
The correctness of the scheme follows from the correctness of the ZKP and the properties of the pairing.The ZKP is used to ensure that a malicious server responds as per the protocol.
In the following security analyses we focus primarily on malicious clients, and for simplicity analyze a simpler version of the protocol that omits the ZKP.
The proofs found below can be extended to the full protocol by applying the zero-knowledge security of the proof systems that we use (i.e., use the zero-knowledge simulator to produce fake, but realisticlooking to the client, proofs).
We define a one-more unpredictability security notion.
It modifies one-more unforgeability [42] to be suitable for the setting of unpredictable functions (as opposed to publicly verifiable signatures).
The game is shown in Figure 11.
We associate to any protocol Π, adversary A, and query number q the one-more-unpredictability advantage defined as Adv om-unp Π,q (A) = Pr 񮽙 om-UNP A Π,q ⇒ true 񮽙 .
The probability here (and for games defined later below) is over all random coins used by the procedures and the adversary.
The event refers to the probability that the value returned by the main procedure is true.
In words, the definition requires that an adversary cannot produce 񮽙 outputs of the PRF using less than 񮽙 queries on partiallyblinded inputs to the server.
One can easily extend this notion to deal with full blinded inputs as well, but we will not need this.
This notion of security is sufficient for PYTHIA in applications where the output of the protocol is not stored, but rather used as an unforgeable credential such as with our hardened Brainwallet application (Section 6).
The security of our scheme is based on the following one-more bilinear computational Diffie-Hellman (BCDH) problem, an extension of the one-more CDH assumption given by Boldyreva [10].
To the best of our knowledge this assumption is new, but it is a straightforward adaptation of previous one-more assumptions [6,10] to our setting.
For a pairing setup G, game om-BCDH G is defined in Figure 12.
In words, the adversary gets a group element g s 1 k ∈ G 1 as well as target oracles Targ 1 , Targ 2 that return random group elements in G 1 , G 2 respectively.
Finally the adversary can query a helper oracle Help that raises G T elements to the k. To win, it must compute 񮽙 values e(X i , Y j ) k for 񮽙 larger than the number of helper queries and each X i , Y j a unique pair of (distinct) values returned by the target oracle.
Let Adv om-cdh G (B) = Pr 񮽙 om-BCDH B G ⇒ true 񮽙 .
We have the following theorem establishing the onemore unpredictability of our scheme The proof is essentially identical to the proof of Boldyreva's blind signatures [10].
Theorem 1 Let Π be the simplified partially oblivious PRF protocol for a pairing setup G and H 1 , H 2 modeled as random oracles.
Then for any one-more unpredictability adversary A making at most q PRF-Srv queries, we give in the proof below a one-more CDH adversary B such that Proof: We assume without loss of generality that A never repeats a query to either random oracle and makes a random oracle H 1 (t i ) and H 2 (m i ) query for each (t i , m i , σ i ) triple it outputs.
The adversary B will work as follows when given inputs G, X and access to oracles Targ Figure 12:Security game for a one-more BCDH assumption for bilinear pairing setting G = (g 1 , g 2 , g t , G 1 , G 2 , G T , e).
an H 1 (t) query, B queries Targ 1 to obtain a G 1 -element that we will denote X[t], sets c t to be the number of H 1 queries so far (including the current), and returns X[t] to A. Whenever A makes an H 2 (m) server query, B queries Targ 2 , obtains a G 2 -element that we will denote Y [m], sets d m to be the number of H 2 queries so far (including the current), and returns Y [m] to A. Whenever A makes a PRF-Srv(t, Y ) query, the adversary B computes Z ← e(H 1 (t), Y ), and then queries Z to its helper oracle Help to obtain a value σ ∈ G T .
It returns σ to A.Eventually A outputs a series of triples (t 1 , m 1 , σ 1 ), . . . , (t q , m q , σ q ).
At this point adversary B outputs the sequence of pairs (c t1 , d m1 , σ 1 ), . . . , (c mq , d mq , σ q ).
Suppose A wins its game.
Then it made at most q − 1 queries to PRF-Srv and so B makes at most q − 1 queries to Help.
It is also the case that all predictions by A are for unique tag, message pairs, meaning that B's output will also be for unique pairs of targets.
Finally, it is clear that correct predictions σ i are also BCDH solutions.
See the full version of this paper [25] for one-more PRF security definitions and associated proofs.
The authors thank Kenny Paterson for feedback on an early draft of this paper.
This work was supported in part by NSF grants CNS-1330308, CNS-1065134, and CNS-1330599, as well as a gift from Microsoft.
