Recently much attention has been directed to extending logic programming with description logic (DL) expressions, so that logic programs have access to DL knowledge bases and thus are able to reason with ontologies in the Semantic Web.
In this paper, we propose a new extension of logic programs with DL expressions, called normal DL logic programs.
In a normal DL logic program arbitrary DL expressions are allowed to appear in rule bodies and atomic DL expressions (i.e., atomic concepts and atomic roles) allowed in rule heads.
We extend the key condition of well-supportedness for normal logic programs under the standard answer set semantics to normal DL logic programs and define an answer set semantics for DL logic programs which satisfies the extended well-supportedness condition.
We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ).
In the development of Semantic Web languages we are concerned with two major components: ontologies and rules.
Ontologies describe terminological knowledge and rules model constraints and exceptions over the ontologies.
Since the two components provide complementary descriptions of the same problem domain, they are supposed to be integrated in some ways (e.g., [2,4,16,18,19]; see [3] for a survey).
The core of the Web ontology language OWL (more recently, OWL 2) [13,9] is description logics (DLs) [1] and thus in this paper we assume an ontology is represented as a knowledge base in DLs.Logic programming under the (standard) answer set semantics [8] is currently a widely used declarative language paradigm for knowledge representation and reasoning.
A normal logic program Π consists of rules of the form H ← A 1 , · · · , A m , not B 1 , · · · , not B n , where H and each A i and B i are atoms.
Such a rule states that if the body A 1 , · · · , A m , not B 1 , · · · , not B n holds, then the head H holds.
The semantics of Π is defined by answer sets, which are Herbrand models of Π satisfying the well-supportedness condition [8,7].
Informally, a Herbrand model I is well-supported if for any H ∈ I, there is a rule as above from Π such that I satisfies the rule body and for no A i the evidence of the truth of A i is circularly dependent on H in I.
It is this well-supportedness condition that lets rules in a logic program differ from formulas (implications) in classical logic and guarantees that answer sets are free of circular justifications.Recently, much attention has been directed to using logic programs to express rules in the Semantic Web by extending logic programming under the answer set semantics with DL expressions [4,16,19].
By allowing DL expressions to appear in rules, logic programs have access to DL knowledge bases and thus are able to reason with ontologies in the Semantic Web.
Major current extensions of logic programs with DL expressions include description logic programs (or dlprograms) [4], DL+log [19] and disjunctive dl-programs [16].
Given an external DL knowledge base L, a dl-program extends a normal logic program Π by adding dl-atoms to rule bodies as an interface to access to L [4].
A dl-atom is of the form DL[S 1 op 1 P 1 , · · · , S m op m P m ; Q](t), where each S i op i P i semantically maps a predicate symbol P i in Π to a concept or role S i in L via a special interface operator op i ∈ { ∪ + , ∪ -, ∩ -}, and Q(t) is a DL expression which will be evaluated against L after the predicate mapping.
For instance, p(a) ← DL[c ∪ + p, b ∩ -q; c 񮽙 ¬b](a) is a rule, where the dl-atom queries L if a is in the concept c but not in the concept b, given the mapping that for any x, if p(x) is true then x is in c and if q(x) is false then x is not in b. Note that predicate symbols in Π must be disjoint from predicate symbols (i.e., atomic concepts and atomic roles) in L. Moreover, DL expressions are not allowed to appear in the head of a rule, thus no conclusion about L can be inferred from Π.It is necessary to allow DL expressions to occur in rule heads because DL knowledge bases (ontologies) define only general terminological knowledge, while additional constraints and exceptions over some DL concepts/roles must be defined by rules.
To avoid predicate mappings between L and Π and allow DL expressions to appear in rule heads, another extension, called DL+log, is introduced [19].
DL+log lets Π and L share some predicate symbols and allows atomic DL expressions (i.e. atomic concepts and atomic roles) to appear either in bodies or heads of rules without using any predicate mapping operators.
One restriction of this extension is that DL expressions are not allowed to appear behind the negation operator not.Disjunctive dl-programs [16] are a third extension of logic programs with DL expressions.
This extension allows atomic DL expressions to appear anywhere in a rule, and has a semantics substantially different from that of DL+log.For dl-programs, three answer set semantics are introduced in [4,5], called the weak, strong, and FLP-reduct based semantics, respectively.
These semantics are proper extensions of the standard answer set semantics, but their answer sets do not satisfy the well-supportedness condition and thus may incur circular justifications by self-supporting loops.
For DL+log, a semantics is defined with a class of first-order models, called NM-models [19].
Such NM-models are not wellsupported models.
For disjunctive dl-programs, an FLP-reduct based answer set semantics is defined [16].
It is a proper extension of the standard answer set semantics, but its answer sets do not satisfy the well-supportedness condition either and thus may also incur circular justifications.Observe that the three major extensions of logic programs with DL expressions have complementary features.
In syntax, dl-programs allow arbitrary DL expressions in rule bodies, while DL+log and disjunctive dl-programs allow atomic DL expressions in rule heads.
In semantics, in dl-programs and DL+log, DL concepts and roles occurring in Π are all interpreted against the external DL knowledge base L under the first-order semantics, while in disjunctive dl-programs, these DL concepts and roles are all included in the Herbrand base of Π and interpreted under the answer set semantics.
These observations suggest that it is desirable to have a new extension of logic programs with DL expressions, which allows arbitrary DL expressions in rule bodies and atomic DL expressions in rule heads, and interprets DL concepts and roles occurring in Π flexibly in either of the above ways.
Moreover, as we mentioned earlier, well-supportedness is a key condition of logic programming under the standard answer set semantics, so it is desirable to extend this condition to logic programs with DL expressions.
In fact, the well-supportedness condition has recently been extended to dl-programs and a new answer set semantics for dl-programs has been developed which satisfies the extended well-supportedness condition [20].
Therefore, in this paper we advance one step further by introducing a fourth extension of logic programs with DL expressions as follows: (1) Given an external DL knowledge base L, we extend a normal logic program Π with DL expressions relative to L by introducing rules of the formH ← A 1 , · · · , A m , not B 1 , · · · , not B n ,where H is an atom or an atomic DL expression, and each A i and B i are either atoms or arbitrary DL expressions.
We call this extension Π relative to L a normal DL logic program.
(2) We allow DL concepts and roles occurring in Π to flexibly choose between first-order interpretations and Herbrand interpretations, as described above.
(3) We extend the well-supportedness condition of the standard answer set semantics from normal logic programs to normal DL logic programs, and define an answer set semantics which satisfies the extended well-supportedness condition and thus whose answer sets are free of circular justifications.
(4) We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ [13,12]).
The paper is arranged as follows.
Section 2 briefly reviews logic programs and DL knowledge bases.
Section 3 defines normal DL logic programs.
Section 4 mentions related approaches, and Section 5 concludes with future work.
Consider a vocabulary Φ = (P, C), where P is a finite set of predicate symbols and C a nonempty finite set of constants.
A term is either a constant from C or a variable.
Predicate symbols begin with a capital letter, and constants with a lower case letter.
We use strings starting with X, Y or Z to denote variables.An atom is of the form P (t 1 , ..., t m ), where P is a predicate symbol from P, and t i is a term.
A rule r is of the formH ← A 1 , · · · , A m , not B 1 , · · · , not B n(1)where H and each A i and B i are atoms.
Each A i is called a positive literal, and each not B i called a negative literal.
We use head(r) and body(r) to denote the head H and the body A 1 , · · · , A m , not B 1 , · · · , not B n , respectively.
We also use pos(r) to denote the positive literals A 1 , · · · , A m , and neg(r) to denote the negative literals not B 1 , · · · , not B n .
Therefore, a rule r can simply be written as head(r) ← body(r) or head(r) ← pos(r), neg(r).
A normal logic program Π consists of a finite set of rules.
A ground instance of a rule r is obtained by replacing every variable in r with a constant from C.
We use ground(Π) to denote the set of all ground instances of rules in Π.
The Herbrand base of Π, denoted HB Π , is the set of all ground atoms P (t 1 , ..., t m ), where P ∈ P occurs in Π and t i is in C. Any subset of HB Π is a Herbrand interpretation (or interpretation for short) of Π.
For an interpretation I, letI − = HB Π \ I and ¬I − = {¬A | A ∈ I − }.
An interpretation I satisfies a ground atom A ∈ HB Π if A ∈ I, and I satisfies not A if A 񮽙 ∈ I. For a rule r in ground(Π), I satisfies body(r) if for each (positive or negative) literal l in body(r), I satisfies l; I satisfies r if I does not satisfy body(r) or I satisfies head(r).
I is a model of Π if I satisfies all r ∈ ground(Π).
A minimal model is a model that is minimal in terms of set inclusion.Let Π I = {A ← pos(r) | A ← pos(r), neg(r) ∈ ground(Π) and I satisfies neg(r)}.
Since Π I has no negative literals in rule bodies, it has a least model.
The standard answer set semantics defines I to be an answer set of Π if I is the least model of Π I [8].
We assume familiarity with the basics of description logics (DLs) [1], and for simplicity consider SHOIN , a DL underlying the Web ontology language OWL DL [13].
The approach presented in this paper can easily be extended to other more expressive DLs such as SROIQ (a logical underpinning for OWL 2) [12,9], and to DLs with datatypes such as SHOIN (D) and SROIQ(D).
Consider a vocabulary Ψ = (A ∪ R, I), where A, R and I are pairwise disjoint (denumerable) sets of atomic concepts, atomic roles and individuals, respectively.
A role is either an atomic role R from R or its inverse, denoted R − .
General concepts C are formed from atomic concepts, roles and individuals, according to the following syntax:C ::= | ⊥ | A | {a} | C 񮽙 C 1 | C 񮽙 C 1 | ¬C | ∃R.C | ∀R.C | ≥ n R | ≤ n Rwhere A is an atomic concept from A, R is a role, a is an individual from I, C and C 1 are concepts, and n is a non-negative integer.
An axiom is of the formC 񮽙 D (concept inclusion axiom), R 񮽙 R 1 (role inclusion axiom), Trans(R) (transitivity axiom), C(a) (concept membership axiom), R(a, b) (role membership axiom), =(a, b) (equality axiom), or 񮽙 =(a, b) (inequality axiom),where C, D are concepts, R, R 1 are atomic roles in R, and a, b are individuals in I.
We use C ≡ D to denote C 񮽙 D and D 񮽙 C.
A DL knowledge base L is a finite set of axioms.
Since DLs are fragments of first-order logic with equality, where atomic concepts (resp.
roles) are unary (resp.
binary) predicate symbols, and individuals are constants, L has the firstorder semantics.
When we say predicate symbols in L, we refer to atomic concepts or atomic roles in L. L is consistent (or satisfiable) if L has a first-order model.
For an axiom F , the entailment relation L |= F is defined as in firstorder logic, i.e., L entails F if all models of L are models of F .
Note that if L is inconsistent, L entails everything.A DL expression, also called a DL query in [4], which is allowed to appear in rules of a logic program, is either (i) a concept inclusion axiom F or its negation ¬F ; or (ii) of the form C(t) or ¬C(t), where C is a concept, and t is a term (i.e., a variable or a constant); or (iii) of the form R(t 1 , t 2 ) or ¬R(t 1 , t 2 ), where R is a role, and t 1 and t 2 are terms; or (iv) of the form =(t 1 , t 2 ) or 񮽙 =(t 1 , t 2 ), where t 1 and t 2 are terms.
An atomic DL expression is either C(t) or R(t 1 , t 2 ), where C is an atomic concept and R an atomic role.
For convenience, we denote a DL expression by Q(t), where t denotes all terms occurring in the expression (e.g., t 1 and t 2 in (iii)), and Q denotes the remaining part of the expression (e.g., R or ¬R in (iii)).
Let L be a DL knowledge base built over a vocabulary Ψ = (A ∪ R, I), and Π be a normal logic program built over Φ = (P, C).
To extend Π with DL expressions relative to L, we first extend Φ such that: (i) all constants in C are individuals in I (i.e., C ⊆ I), so that constants occurring in DL expressions are individuals, and (ii) some atomic concepts and roles in A ∪ R are included in P (as unary and binary predicate symbols, respectively), so that we can make conclusions about them in the same way as other predicate symbols in P. To ensure decidability, we require that P and C be finite.
Let Ω = P ∩ (A ∪ R) denote the set of predicate symbols shared by Π and L. Definition 1.
Let L be a DL knowledge base.
A normal DL logic program Π with DL expressions relative to L consists of a finite set of rules of form (1), where H is an atom, and each A i and B i are either atoms or DL expressions.Note that when the predicate symbol of an atom in Π is in Ω, the atom is also an atomic DL expression.A ground instance of a rule (resp.
a DL expression) in Π is obtained by replacing all variables with constants in C. Let ground(Π) denote the set of ground instances of all rules in Π.
The Herbrand base HB Π of Π relative to L is the set of all ground atoms P (t 1 , ..., t m ), where P ∈ P occurs either in Π or in L and each t i is in C. Any subset of HB Π is a Herbrand interpretation (or simply interpretation) of Π relative to L.
When the context is clear, we omit the phrase "relative to L."For an interpretation I, let I| Ω = {A ∈ I | the predicate symbol of A is inΩ} and I − | Ω = {A ∈ I − | the predicate symbol of A is in Ω}.
We say that I is consistent with L if L ∪ I| Ω ∪¬I − | Ω is consistent.
Note that when I is consistent with L, L must be consistent.Since DL expressions must be evaluated against L, the satisfaction relation for normal logic programs needs to be extended to normal DL logic programs.
In the sequel, by a literal we refer to A or not A, where A is an atom or a DL expression.Definition 2.
Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, I an interpretation, and l a ground literal.
We use I |= L l to denote that I satisfies l under L, which is defined as follows:1.
For a ground atom A ∈ HB Π , which is not an atomic DL expression,I |= L A if A ∈ I. 2.
For a ground DL expression A, I |= L A if L ∪ I| Ω ∪¬I − | Ω |= A. 3.
For a ground atom or a ground DL expression A, I |= L not A if I 񮽙 |= L A. For a rule r in ground(Π), I |= L body(r) if for each (positive or negative) literal l in body(r), I |= L l; I |= L r if I 񮽙 |= L body(r) or I |= L head(r).
I is a model of Π relative to L if I is consistent with L and I |= L r for all r ∈ ground(Π).
Note that when L is inconsistent, Π has no model relative to L. Example 1.
Let L = {¬B(a)} and Π = {A(X) ← not ¬(A 񮽙 B)(X)}.
Let P = {A}, C = {a} and Ω = {A}.
Note that ¬(A񮽙B)(X)is a DL expression, and A(X) is both an atom and an atomic DL expression.
We have HB Π = {A(a)} and ground(Π) = {A(a) ← not ¬(A 񮽙 B)(a)}.
Π has two models relative to L: I 1 = ∅ and I 2 = {A(a)}.
For the rule r in ground(Π), I 1 񮽙 |= L body(r), I 2 |= L body(r), and I 2 |= L head(r).
The notion of well-supportedness in logic programming is defined by Fages in [7] as a key characterization of the standard answer set semantics.
For a normal logic program Π, an interpretation I is well-supported if there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there is a rule A ← body(r) in ground(Π) such that I satisfies body(r) and for every positive literal B in body(r), B ≺ A.
A binary relation ≤ is well-founded if there is no infinite decreasing chain A 0 ≥ A 1 ≥ · · ·.
A well-supported interpretation I guarantees that every A ∈ I is free of circular justifications in I.To extend Fages' well-supportedness condition to normal DL logic programs with DL expressions, we introduce a notion of up to satisfaction.
Definition 3.
Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, I an interpretation consistent with L, and l a ground literal.
For any E ⊆ I, we use (E, I) |= L l to denote that E up to I satisfies l under L, which is defined as follows: For any ground atom or ground DLexpression A, (E, I) |= L A if for every F with E ⊆ F ⊆ I, F |= L A; (E, I) |= L not A if for no F with E ⊆ F ⊆ I, F |= L A. For a rule r in ground(Π), (E, I) |= L body(r) if for every literal l in body(r), (E, I) |= L l.As the phrase "up to" suggests, for any ground (positive or negative) literal l, (E, I) |= L l means that for all interpretations F between E and I, F |= L l.
This implies that the truth of l depends on E and ¬I − and is independent of atoms in I \ E, since for any A ∈ I \ E and any interpretation F with E ⊆ F ⊆ I, whether or not A is in F , F |= L l. E 1 ⊆ E 2 ⊆ I, if (E 1 , I) |= L l then (E 2 , I) |= L l.Proof: Straightforward from Definition 3.񮽙 񮽙
Theorem 1 shows that the up to satisfaction is monotonic.
In addition, it has the following two properties.Proposition 1.
For any ground DL expression A, (E, I) |= L A iff L ∪ E| Ω ∪¬I − | Ω |= A. Proof: (E, I) |= L A means that E ⊆ I and for every F with E ⊆ F ⊆ I, F |= L A. Then, by Definition 2, (E, I) |= L A means that for every F with E ⊆ F ⊆ I, L ∪ F | Ω ∪¬F − | Ω |= A. Note that F = E ∪ (F \ E) and F − = I − ∪ (I \ F ).
So (E, I) |= L A means that for every F with E ⊆ F ⊆ I, L ∪ E | Ω ∪ ¬I − | Ω ∪ (F \ E) | Ω ∪ ¬(I \ F ) | Ω |= A(2)Then, to prove this proposition it suffices to prove that the entailment (2) holds for every F with E ⊆ F ⊆ I iff the following entailment holds:L ∪ E | Ω ∪ ¬I − | Ω |= A(3)Note that for any model M of the left side of the entailment (2) or (3), we have E ⊆ M ⊆ I. Assume that the entailment (2) holds for every F with E ⊆ F ⊆ I. Let M be a model of the left side of the entailment (3).
Since E ⊆ M ⊆ I, M is a model of the left side of the entailment (2), where F = M .
Then, M is a model of A (the right side of the entailment (2)).
This means the entailment (3) holds.Conversely, assume the entailment (3) holds.
Let M be a model of the left side of the entailment (2).
M is also a model of the left side of the entailment (3) and thus M is a model of A (the right side of the entailment (3)).
This means the entailment (2) holds.񮽙 񮽙
Proposition 2.
For any ground atom A ∈ HB Π , which is not an atomic DL expression,(E, I) |= L A iff A ∈ E; (E, I) |= L not A iff A 񮽙 ∈ I. Next we extend the well-supportedness condition for normal logic programs to normal DL logic programs by means of the up to satisfaction.
Definition 4.
Let Π be a normal DL logic program with DL expressions relative to a DL knowledge base L, and I an interpretation consistent with L. I is wellsupported if there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either(i) L ∪ E| Ω ∪¬I − | Ω |= A, or (ii) there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
The above conditions (i) and (ii) imply that the truth of A ∈ I is determined by E and ¬I − .
Since for every B ∈ E, B ≺ A, the truth of A is not circularly dependent on itself.
As a result, a well-supported interpretation I of Π guarantees that every A ∈ I is free of circular justifications in I.Observe in Definition 4 that due to the occurrence of DL expressions, some A ∈ I may be supported by no rule A ← body(r) in ground(Π) such thatI |= L body(r).
Instead, A is supported by L such that L ∪ I| Ω ∪¬I − | Ω |= A.This is a special property of the well-supportedness condition for normal DL logic programs.
The next example further illustrates this property.Example 2.
Let L = {B(a), B 񮽙 A} and Π = {A(X) ← C(X)}.
Let P = {A, C}, C = {a} and Ω = {A}.
We have HB Π = {A(a), C(a)} and ground(Π) = {A(a) ← C(a)}.
Π has two models relative to L: I 1 = {A(a)} and I 2 = {A(a), C(a)}.
Only I 1 is a well-supported model, where for A(a) ∈ I 1 , we have E = ∅ and condition (i) of Definition 4 holds.
Note that there is no rule of the form A(a) ← body(r) in ground(Π) such that I 1 |= L body(r).
The following result shows that Definition 4 is a proper extension to Fages' well-supportedness condition.
Assume that I is a well-supported model of Π relative to L. By Definition 4, there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, and there is a rule r as above in ground(Π) such that (E, I) |= L body(r).
Note that (E, I) |= L body(r) implies E |= L body(r) and I |= L body(r), which implies that both I and E satisfy body(r).
This means that for every positive literal A i in body(r), A i ∈ E and thus A i ≺ A.
As a result, for any A ∈ I, there is a rule r as above in ground(Π) such that I satisfies body(r) and for every positive literal A i in body(r), A i ≺ A.
This shows that I is a well-supported model of Π under Fages' definition.Assume I is a well-supported model of Π under Fages' definition.
There exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there is a rule r as above in ground(Π) such that I satisfies body(r) and for every positive literal A i in body(r), A i ≺ A. Let E ⊂ I and for every A i ∈ body(r), A i ∈ E. Then, E contains no B i in body(r), since no B i is in I. For any F with E ⊆ F ⊆ I, F satisfies body(r) and thus F |= L body(r).
That means (E, I) |= L body(r).
As a result, for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, and there is a rule r as above in ground(Π) such that (E, I) |= L body(r).
This shows that I is a well-supported model of Π relative to L. 񮽙 񮽙 We define an answer set semantics for normal DL logic programs whose answer sets are well-supported models.
We first define an immediate consequence operator.Definition 5.
Let Π be a normal DL logic program relative to a DL knowledge base L, and I an interpretation consistent with L. For E ⊆ I, defineT Π (E, I) ={A | A ← body(r) ∈ ground(Π) and (E, I) |= L body(r)}.
By Theorem 1, when the second argument I is a model of Π, T Π is monotone w.r.t. its first argument E. Proof: For any A ∈ T Π (E 1 , I), there is a rule A ← body(r) in ground(Π) such that (E 1 , I) |= L body(r).
Since E 1 ⊆ E 2 , by Theorem 1, (E 2 , I) |= L body(r), and thus A ∈ T Π (E 2 , I).
This shows T Π (E 1 , I) ⊆ T Π (E 2 , I).
Since E 2 ⊆ I, it follows (I, I) |= L body(r) and A ∈ T Π (I, I).
Therefore, T Π (E 1 , I) ⊆ T Π (E 2 , I) ⊆ T Π (I, I).
Note that (I, I) |= L body(r) means I |= L body(r).
Since I is a model of Π relative to L, I |= L body(r) implies A ∈ I.
This shows that when I is a model of Π relative to L, every A ∈ T Π (I, I) is in I. Hence,T Π (E 1 , I) ⊆ T Π (E 2 , I) ⊆ T Π (I, I) ⊆ I. Therefore, for any model I of Π relative to L, the sequence񮽙T i Π (∅, I)񮽙 ∞ i=0 , where T 0 Π (∅, I) = ∅ and T i+1 Π (∅, I) = T Π (T i Π (∅, I), I), converges to a fixpoint, denoted T α Π (∅, I).
This fixpoint has the following properties.Theorem 4.
Let I be a model of Π relative to L. (1) T α Π (∅, I) ⊆ I. (2) L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω is consistent.
(3) For any model J of Π relative to L with J ⊂ I, T α Π (∅, I) ⊆ T α Π (∅, J) ⊆ J.Proof: (1) It suffices to prove that for any i ≥ 0,T i Π (∅, I) ⊆ I.
It is obvious for i = 0.
Assume T k Π (∅, I) ⊆ I for k ≥ 0.
For i = k + 1, by Theorem 3, T k+1 Π (∅, I) = T Π (T k Π (∅, I), I) ⊆ I. Therefore, T α Π (∅, I) ⊆ I. (2) Since I is a model of Π relative to L, L ∪ I| Ω ∪¬I − | Ω is consistent.
Since T α Π (∅, I) ⊆ I, L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω is also consistent.
(3) By Definition 3, for any rule body body(r) in ground(Π) and any E 1 and E 2 with E 1 ⊆ E 2 ⊆ J, if (E 1 , I) |= L body(r) then (E 2 , J) |= L body(r).
Then, by Definition 5, T Π (E 1 , I) ⊆ T Π (E 2 , J).
Next we prove that for any i ≥ 0,T i Π (∅, I) ⊆ T i Π (∅, J) ⊆ J.
It is obvious for i = 0.
Assume T i Π (∅, I) ⊆ T i Π (∅, J) ⊆ J for any i ≤ k ≥ 0.
For i = k + 1, by Theorem 3, T k+1 Π (∅, I) = T Π (T k Π (∅, I), I) ⊆ T k+1 Π (∅, J) = T Π (T k Π (∅, J), J) ⊂ J. Therefore, T α Π (∅, I) ⊆ T α Π (∅, J) ⊆ J.
We define answer sets for normal DL logic programs using the above fixpoint.Definition 6.
Let Π be a normal DL logic program relative to a DL knowledge base L, and I a model of Π relative to L. I is an answer set of Π relative to L if for everyA ∈ I, either A ∈ T α Π (∅, I) or L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω |= A.It is immediate that when L = ∅, a model I is an answer set of Π relative toL iff I = T α Π (∅, I).
The answer set semantics for Π relative to L is then defined by answer sets of Π.
That is, a ground literal l is credulously (resp.
skeptically) true in Π relative to L if I |= L l for some (resp.
every) answer set I of Π relative to L.Example 3.
Consider Example 1.
For I 1 = ∅, T α Π (∅, I 1 ) = ∅, so I 1 is an answer set of Π relative to L. For I 2 = {A(a)}, T 0 Π (∅, I 2 ) = ∅ and T 1 Π (∅, I 2 ) = T Π (∅, I 2 ) = ∅, so T α Π (∅, I 2 ) = ∅.
For A(a) ∈ I 2 , A(a) 񮽙 ∈ T α Π (∅, I 2 ) and L ∪ T α Π (∅, I 2 )| Ω ∪¬I − 2 | Ω 񮽙 |= A(a).
Thus I 2 is not an answer set of Π relative to L.Consider Example 2.
ForI 1 = {A(a)}, T 0 Π (∅, I 1 ) = ∅ and T 1 Π (∅, I 1 ) = T Π (∅, I 1 ) = ∅, so T α Π (∅, I 1 ) = ∅.
For A(a) ∈ I 1 , A(a) 񮽙 ∈ T α Π (∅, I 1 ), but L ∪ T α Π (∅, I 1 )| Ω ∪¬I − 1 | Ω |= A(a), so I 1 is an answer set of Π relative to L.
It is easy to verify that I 2 = {A(a), C(a)} is not an answer set of Π relative to L.The following result shows that answer sets must be minimal models.
(∅, I) ⊆ T α Π (∅, J) ⊆ J. Let S = I \ J.Note that S is not empty and for any A ∈ S, A 񮽙 ∈ T α Π (∅, I).
Since I is an answer set of Π, for anyA ∈ S, L∪T α Π (∅, I)| Ω ∪¬I − | Ω |= A.
Since J − ⊃ I − , L ∪ J| Ω ∪¬J − | Ω |= A.
Since every A ∈ S is in J − , L ∪ J| Ω ∪¬J − | Ω |= ¬A.This means that L ∪ J| Ω ∪¬J − | Ω is not consistent, and thus J is not a model of Π relative to L.
We then have a contradiction.
Therefore, I is a minimal model of Π relative to L.
The next result shows that answer sets are exactly well-supported models.
Proof: Assume that I is an answer set relative to L.
We can construct a level mapping f : I → N , where N is an integer, as follows: For each A ∈ I, we assign f (A) = i, where i ≥ 0 is the smallest number such that eitherL ∪ T i Π (∅, I)| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (T i Π (∅, I), I) |= L body(r).
We then define a strict well-founded partial order ≺ on I such that for any A, B ∈ I, B ≺ A iff f (B) < f(A).
For each A ∈ I with f (A) = i, we always have E = T i Π (∅, I) ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
By Definition 4, I is a well-supported model relative to L.Conversely, assume that I is a well-supported model relative to L. Then, there exists a strict well-founded partial order ≺ on I such that for any A ∈ I, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
Such a partial order establishes a level mapping f : I → N so that for any A ∈ I, A can be derived from some E ⊂ I at lower levels in the way as above.
Next, we show that for every A ∈ I at level i ≥ 0 we have E = T i Π (∅, I) satisfying the above conditions.
First, each A ∈ I at the lowest level (i = 0) does not depend on any other atom B ∈ I, i.e., there is no B ∈ I with B ≺ A. By the assumption that there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r), we have E = ∅.
Therefore, for each A ∈ I at level 0, we have E = T 0 Π (∅, I) which satisfies the above conditions.As the induction hypothesis, assume that for any i ≤ n and any A ∈ I at level i, we have E = T i Π (∅, I) such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
Then, by Theorem 3, for each A ∈ I at level i ≤ n, we have E = T n Π (∅, I) which satisfies the above conditions.Consider A ∈ I at level n + 1.
Then, there exists E ⊂ I, where for every B ∈ E, B ≺ A, such that either (1) L ∪ E| Ω ∪¬I − | Ω |= A, or (2) there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
Next, we show that when using T n+1 Π (∅, I) to replace E, the conditions (1) and (2) still hold for every A ∈ I at level n + 1.
For every B ∈ E, since B is at a level below n+1, by the induction hypothesis,either (a) L ∪ T n Π (∅, I)| Ω ∪¬I − | Ω |= B, or (b) there is a rule B ← body(r) in ground(Π) such that (T n Π (∅, I), I) |= L body(r).
For case (a), we distinguish between two cases: (i) B ∈ T n Π (∅, I).
In this case, if we replace B in E by T n+1 Π (∅, I), the conditions (1) and (2) above still hold for each A ∈ I at level n + 1.
(ii) B 񮽙 ∈ T n Π (∅, I).
Then, for no i ≤ n, B ∈ T i Π (∅, I); thus B is an atomic DL expression.
In this case, if we replace B in E by T n+1Π (∅, I), the condition (1) above still holds, since L ∪ T n Π (∅, I)| Ω ∪¬I − | Ω |= B. Consider the condition (2).
(E, I) |= L body(r) means that for every F with E ⊆ F ⊆ I, F |= L body(r).
Let us replace B in E by T n+1 Π (∅, I).
Since B is a ground atomic DL expression, by Proposition 1, (E \{B}∪T n+1 Π (∅, I), I) |= L B, because L ∪ (E \ {B} ∪ T n+1 Π (∅, I))| Ω ∪¬I − | Ω |= B.This shows that for any body(r),(E \ {B} ∪ T n+1 Π (∅, I), I) |= L body(r) iff (E ∪ T n+1 Π (∅, I), I) |= L body(r).
Then, when (E, I) |= L body(r), (E ∪ T n+1 Π (∅, I), I) |= L body(r) and thus (E \ {B} ∪ T n+1 Π (∅, I), I) |= L body(r).
This shows that after replacing B in E by T n+1 Π (∅, I), the condition (2) above still holds, Therefore, if we replace B in E by T n+1 Π (∅, I), the conditions (1) and (2) (1) and (2) above still hold.
As a result, if we replace all B ∈ E by T n+1 Π (∅, I), the conditions (1) and (2) above still hold.
Therefore, for every A ∈ I at level n + 1.
we have E = T n+1Π (∅, I) such that either L ∪ E| Ω ∪¬I − | Ω |= A or there is a rule A ← body(r) in ground(Π) such that (E, I) |= L body(r).
Consequently, for every A ∈ I, either L ∪ T α Π (∅, I)| Ω ∪¬I − | Ω |= A or A ∈ T α Π (∅, I).
This shows that I is an answer set of Π relative to L. 񮽙 񮽙 Example 4.
Let L = ∅ and Π : A(g).
B(g) ← C(g).
C(g) ← ((A 񮽙 ¬C) 񮽙 B)(g).
Let P = {A, B, C}, C = {g} and Ω = {A, B, C}.
HB Π = {A(g), B(g), C(g)} and ground(Π) = Π.
Π has only one model relative toL, I = {A(g), B(g), C(g)}.
This model is not an answer set, since it is not a well-supported model of Π relative to L. Note that we can use a fresh DL concept D to replace the DL expression (A 񮽙 ¬C) 񮽙 B and add to L an axiom D ≡ (A 񮽙 ¬C) 񮽙 B.
This yieldsΠ 񮽙 : A(g).
B(g) ← C(g).
C(g) ← D(g).
L 񮽙 : D ≡ (A 񮽙 ¬C) 񮽙 B.Using the same P, C and Ω as above, Π 񮽙 has the same answer sets relative toL 񮽙 as Π relative to L.The following result shows that this answer set semantics is a proper extension to the standard answer set semantics for normal logic programs.Theorem 7.
Let L = ∅ and Π be a normal logic program without DL expressions.
An interpretation I is an answer set of Π relative to L iff I is an answer set of Π under the standard answer set semantics.Proof: By Theorem 6, I is an answer set of Π relative to L iff I is a wellsupported model of Π relative to L. By Theorem 2, I is a well-supported model of Π relative to L iff I is a well-supported model of Π under Fages' definition.
Then as shown in [7], the well-supported models of Π under Fages' definition are exactly the answer sets of Π under the standard answer set semantics. 񮽙 񮽙
For a normal DL logic program Π with DL expressions relative to a DL knowledge base L, the decidability of computing answer sets of Π relative to L depends on the decidability of satisfiability of L.
Since DLs are fragments of first-order logic, the satisfiability of L is undecidable in general cases.
However, if L is built from the description logic SHOIN or SROIQ, its satisfiability is decidable [4,13,12].
Let L be a DL knowledge base built from a decidable description logic such as SHOIN or SROIQ.
Since HB Π and ground(Π) are finite, it is decidable to determine if an interpretation I is a model of Π relative to L. For any E ⊆ I and any ground atom or DL expression A in ground(Π), it is decidable to determine if (E, I) |= L A (resp.
(E, I) |= L not A) holds, and thus it is decidable to determine if (E, I) |= L body(r) holds for each rule r in ground(Π).
Since ground(Π) consists of a finite set of rules, it takes finite time to compute the fixpoint T α Π (∅, I).
As a result, it is decidable to determine if an interpretation I is an answer set of Π relative to L.
Since Π has only a finite set of interpretations, it is decidable to compute all answer sets of Π relative to L. Although many approaches to integrating rules and DLs have been proposed in the literature [2,4,10,11,14,16,18,19], to the best of our knowledge dl-programs [4] are the first framework which extends normal logic programs under the standard answer set semantics to logic programs with arbitrary DL expressions relative to an external DL knowledge base.
Four different answer set semantics have been defined for dl-programs.
The first one, called weak answer set semantics [4], easily incurs circular justifications by self-supporting loops, so a second one, called strong answer set semantics, was introduced [4].
Answer sets under the strong answer set semantics are not minimal models of a dl-program, then a third one, called FLP-reduct based answer set semantics, was proposed [5].
This semantics is based on the concept of FLP-reduct from [6].
It turns out, however, that none of the three answer set semantics extends the key well-supportedness condition of the standard answer set semantics to dl-programs, so that their answer sets may incur circular justifications by self-supporting loops.
To resolve this problem, a fourth semantics, called well-supported answer set semantics, was recently introduced [20], which extends the well-supportedness condition to dl-programs.
Dl-programs differ in fundamental ways from normal DL logic programs.
First, in a dl-program, Π and L share no predicate symbols, so DL expressions Q(t) must occur together with predicate mapping operations S i op i P i .
Note that in dl-programs one cannot use only dl-atoms of the form DL[Q](t) to express all DL expressions Q(t) because that would cut the knowledge flow from Π to L. Second, in a dl-program, DL expressions (dl-atoms) are not allowed to occur in a rule head, so no conclusions about L can be inferred from Π.
Third, in this paper we extend the well-supportedness condition to normal DL logic programs.
The extension process is similar to that in [20] by introducing an up to satisfaction relation (Definition 3), but the formalization of the well-supportedness condition is significantly different.
For dl-programs, since Π and L share no predicate symbols, a model I of Π is well-supported if and only if for each A ∈ I there is a rule A ← body(r) in ground(Π) such that I satisfies body(r) and the evidence of the truth of body(r) is not circularly dependent on A in I. For normal DL logic programs, however, the situation is much more complicated.
As illustrated in Example 2, since Π and L share some predicate symbols, a model I of Π relative to L would be well-supported even if some A ∈ I is not supported by any rule A ← body(r) in ground(Π) such that I satisfies body(r).
This presents additional difficulties in formalizing the well-supportedness condition for normal DL logic programs.DL+log [19] (and its variant such as guarded hybrid knowledge bases [11]) is closely related to but differs significantly from normal DL logic programs.
Syntactically, it divides predicate symbols into Datalog predicates and DL predicates.
The former type can only occur in Π, while the latter is not allowed to occur (as DL expressions) behind the negation operator not.
Semantically, it considers first-order interpretations, instead of Herbrand interpretations, and defines a semantics with a class of first-order models, called NM-models.
In an NM-model, DL predicates can take arbitrary truth values (as in first-order logic), but Datalog predicates take truth values that must be minimal (as in logic programming) when the truth values of all DL predicates are fixed.
Consider a DL+log program with Π = {B(g) ← A(g)} and L = {A 񮽙 C}.
A, C must be DL predicates.
Let B be a Datalog predicate.
This program has at least three NM-models:I 1 = {A(g), B(g)}, I 2 = {A(g), B(g), C(g)} and I 3 = {C(g)}.
In contrast, if we take Π as a normal DL logic program relative to L, where P = {B}, C = {g} and Ω = ∅, Π has a unique well-supported model/answer set ∅ relative to L.Disjunctive dl-programs [16] are closely related to normal DL logic programs, but differ significantly at least in three ways.
Let Π be a disjunctive dl-program relative to L, where Π is built over a vocabulary Φ = (P, C), P is a finite set of predicate symbols, and C is a nonempty finite set of constants.
(1) All concepts and roles occurring in Π are required to be included in P, so that all of them are interpreted over the Herbrand base HB Π of Π.
This strict requirement does not seem to be intuitive in some cases.
For Example 4, since D is a fresh concept of L 񮽙 introduced to represent (A 񮽙 ¬C) 񮽙 B, D is expected to be interpreted against L 񮽙 in first-order logic.
But in a disjunctive dl-program, D must be included in P and thus be interpreted over the Herbrand base HB Π 񮽙 .
(2) The semantics of disjunctive dl-programs is based on FLP-reduct.
Like the FLP-reduct based semantics for dl-programs [5], this FLP-reduct based semantics for disjunctive dl-programs yields answer sets that are minimal but not necessarily well-supported models.
For Example 4, let Π 񮽙 be a disjunctive dl-program.
I = {A(g), B(g), C(g), D(g)} is an answer set of Π 񮽙 relative to L 񮽙 under the FLP-reduct based semantics.
Observe that the evidence of the truth of B(g), C(g), D(g) in the answer set can only be inferred via a self-supporting loop B(g) ⇐ C(g) ⇐ D(g) ⇐ B(g).
(3) Disjunctive dl-programs allow only atomic DL expressions in rule bodies.
We cannot have a disjunctive dl-program with Π = {A ← ¬A} and L = ∅, since ¬A is not an atomic DL expression.
One might think that this issue could be handled by introducing a fresh concept B to represent the DL expression ¬A, which yields a disjunctive dl-program with Π 񮽙 = {A ← B} and L 񮽙 = {B ≡ ¬A}.
However, this would produce an answer set I = {A}, which is not a wellsupported model of Π.Extensions of logic programs with DL expressions, such as dl-programs, DL+log, disjunctive dl-programs, and normal DL logic programs, are different in fundamental ways from embeddings of rules and DLs into some unifying logic formalisms, such as the embedding [2] to first-order autoepistemic logic [17] and the embedding [18] to the logic of Minimal Knowledge and Negation as Failure (MKNF) [15].
The two embeddings employ modal logics and transform rules Π and DL axioms L to autoepistemic (resp.
MKNF) logic formulas Π 񮽙 and L 񮽙 with modal operators.
Then, the semantics of Π and L is defined by the semantics of Π 񮽙 ∪ L 񮽙 under autoepistemic (resp.
MKNF) modal logic.
We have introduced a new extension, called normal DL logic programs, of normal logic programs with DL expressions relative to an external DL knowledge base.
In normal DL logic programs, arbitrary DL expressions are allowed to appear in rule bodies and atomic DL expressions allowed in rule heads.
We extended the key condition of well-supportedness for normal logic programs under the standard answer set semantics to normal DL logic programs and defined an answer set semantics which satisfies the extended condition of well-supportedness.
As a result, answer sets under the well-supported semantics are free of circular justifications.
We show that the answer set semantics for normal DL logic programs is decidable if the underlying description logic is decidable (e.g. SHOIN or SROIQ).
As future work, we will study computational properties of normal DL logic programs w.r.t. different DLs, and extend normal DL logic programs to disjunctive DL logic programs, where the head of a rule is a disjunction of atoms.
