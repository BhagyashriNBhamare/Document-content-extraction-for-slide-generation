We conduct a comprehensive study of file-system code evolution.
By analyzing eight years of Linux file-system changes across 5079 patches, we derive numerous new (and sometimes surprising) insights into the file-system development process; our results should be useful for both the development of file systems themselves as well as the improvement of bug-finding tools.
Open-source local file systems, such as Linux Ext4 [31], XFS [46], and Btrfs [30], remain a critical component in the world of modern storage.
For example, many recent distributed file systems, such as Google GFS [17] and Hadoop DFS [43], all replicate data objects (and associated metadata) across local file systems.
On smart phones, most user data is managed by a local file system; for example, Google Android phones use Ext4 [2,23] and Apple's iOS devices use HFSX [34].
Finally, many desktop users still do not backup their data regularly [21,29]; in this case, the local file system clearly plays a critical role as sole manager of user data.Open-source local file systems remain a moving target.
Developed by different teams with different goals, these file systems evolve rapidly to add new features, fix bugs, and improve performance and reliability, as one might expect in the open-source community [38].
Major new file systems are introduced every few years [12,30,32,39,46]; with recent technology changes (e.g., Flash [11,18]), we can expect even more flux in this domain.However, despite all the activity in local file system development, there is little quantitative understanding of their code bases.
For example, where does the complexity of such systems lie?
What types of bugs are common?
Which performance features exist?
Which reliability features are utilized?
These questions are important to answer for different communities: for developers, so that they can improve current designs and implementations and create better systems; for tool builders, so that they can improve their tools to match reality (e.g., by finding the types of bugs that plague existing systems).
One way to garner insight into these questions is to study the artifacts themselves.
Compared with proprietary software, open source projects provide a rich resource for source code and patch analysis.
The fact that every version of Linux is available online, including a detailed set of patches which describe how one version transforms to the next, enables us to carefully analyze how file systems have changed over time.
A new type of "systems software archeology" is now possible.In this paper, we perform the first comprehensive study of the evolution of Linux file systems, focusing on six major and important ones: Ext3 [47], Ext4 [31], XFS [46], Btrfs [30], ReiserFS [13], and JFS [10].
These file systems represent diverse features, designs, implementations and even groups of developers.
We examine every filesystem patch in the Linux 2.6 series over a period of eight years including 5079 patches.
By carefully studying each patch to understand its intention, and then labeling the patch accordingly along numerous important axes, we can gain deep quantitative insight into the file-system development process.
We can then answer questions such as "what are most patches for?"
, "what types of bugs are common?"
, and in general gain a new level of insight into the common approaches and issues that underlie current file-system development and maintenance.We make the following high-level observations ( §3).
A large number of patches (nearly 50%) are maintenance patches, reflecting the constant refactoring work needed to keep code simple and maintainable.
The remaining dominant category is bugs (just under 40%, about 1800 bugs), showing how much effort is required to slowly inch towards a "correct" implementation; perhaps this hard labor explains why some have found that the quality of open source projects is better than the proprietary software average [1].
Interestingly, the number of bugs does not die down over time (even for stable file systems), rather ebbing and flowing over time.Breaking down the bug category further ( §4), we find that semantic bugs, which require an understanding of file-system semantics to find or fix, are the dominant bug category (over 50% of all bugs).
These types of bugs are vexing, as most of them are hard to detect via generic bug detection tools [9,35]; more complex model checking [52] or formal specification [24] may be needed.
Concurrency bugs are the next most common (about 20% of bugs), more prevalent than in user-level software [26,42,45].
Within this group, atomicity violations and deadlocks dominate.
Kernel deadlocks are common (many caused by incorrectly using blocking kernel functions), hinting that recent research [22,49] might be needed in-kernel.
The remaining bugs are split relatively 1 evenly across memory bugs and improper error-code handling.
In the memory bug category, memory leaks and null-pointer dereferences are common; in the error-code category, most bugs simply drop errors completely [19].
We also categorize bugs along other axes to gain further insight.
For example, when broken down by consequence, we find that most of the bugs we studied lead to crashes or corruption, and hence are quite serious; this result holds across semantic, concurrency, memory, and error code bugs.
When categorized by data structure, we find that B-trees, present in many file systems for scalability, have relatively few bugs per line of code.
When classified by whether bugs occur on normal or failure-handling paths, we make the following important discovery: nearly 40% of all bugs occur on failure-handling paths.
File systems, when trying to react to a failed memory allocation, I/O error, or some other unexpected condition, are highly likely to make further mistakes, such as incorrect state updates and missing resource releases.
These mistakes can lead to corruption, crashes, deadlocks and leaks.
Future system designs need better tool or language support to make these rarely-executed failure paths correct.Finally, while bug patches comprise most of our study, performance and reliability patches are also prevalent, accounting for 8% and 7% of patches respectively ( §5).
The performance techniques used are relatively common and widespread (e.g., removing an unnecessary I/O, or downgrading a write lock to a read lock).
About a quarter of performance patches reduce synchronization overheads; thus, while correctness is important, performance likely justifies the use of more complicated and time saving synchronization schemes.
In contrast to performance techniques, reliability techniques seem to be added in a rather ad hoc fashion (e.g., most file systems apply sanity checks non-uniformly).
Inclusion of a broader set of reliability techniques could harden all file systems.Beyond these results, another outcome of our work is an annotated dataset of file-system patches, which we make publicly available for further study (at this URL: pages.cs.wisc.edu/˜ll/fs-patch) by file-system developers, systems-language designers, and bug-finding tool builders.
We show the utility of PatchDB by performing a case study ( §6); specifically, we search the dataset to find bugs, performance fixes, and reliability techniques that are unusually common across all file systems.
This example brings out one theme of our study, which is that there is a deep underlying similarity in Linux local file systems, even though these file systems are significantly different in nature (e.g., designs, features, and groups of developers).
The commonalities we do find are good news: by studying past bug, performance, and reliability patches, and learning what issues and challenges lie therein, we can greatly improve the next generation of file systems and tools used to build them.
In this section, we first give a brief description of our target file systems.
Then, we illustrate how we analyze patches with a detailed example.
Finally, we discuss the limitations of our methodology.
Our goal in selecting a collection of disk-based file systems is to choose the most popular and important ones.
The selected file systems should include diverse reliability features (e.g., physical journaling, logical journaling, checksumming, copy-on-write), data structures (e.g., hash tables, indirect blocks, extent maps, trees), performance optimizations (e.g., asynchronous thread pools, scalable algorithms, caching, block allocation for SSD devices), advanced features (e.g., pre-allocation, snapshot, resize, volumes), and even a range of maturity (e.g., stable, under development).
For these reasons, we selected six file systems and their related modules: Ext3 with JBD [47], Ext4 with JBD2 [31], XFS [46], Btrfs [30], ReiserFS [13], and JFS [10].
Ext3, JFS, ReiserFS and XFS were all stable and in production use before the Linux 2.6 kernel.
Ext4 was introduced in Linux 2.6.19 and marked stable in Linux 2.6.28.
Btrfs was added into Linux 2.6.29 and is still under active development.
For each file system, we conduct a comprehensive study of its evolution by examining all patches from Linux 2.6.0 (Dec '03) to 2.6.39 (May '11).
These are Linux mainline versions, which are released every three months with aggregate changes included in change logs.
Patches consist of all formal modifications in each new kernel version, including new features, code maintenance, and bug fixes, and usually contain clear descriptions of their purpose and rich diagnostic information.
On the other hand, Linux Bugzilla [3] and mailing lists [4,5] are not as well organized as final patches, and may only contain a subset or superset of final changes merged in kernel.To better understand the evolution of different file systems, we conduct a broad study to answer three categories of fundamental questions:• Overview: What are the common types of patches in file systems and how do patches change as file systems evolve?
Do patches of different types have different sizes?
To answer these questions, we manually analyzed each patch to understand its purpose and functionality, examining 5079 patches from the selected Linux 2.6 file systems.
Each patch contains a patch header, a description body, and source-code changes.
The patch header is a high-level summary of the functionality of the patch (e.g., fixing a bug).
The body contains more detail, such as steps to reproduce the bug, system configuration information, proposed solutions, and so forth.
Given these details and our knowledge of file systems, we categorize each patch along a number of different axes, as described later.
Figure 1 shows a real Ext3 patch.
We can infer from the header that this patch fixes a null-pointer dereference bug.
The body explains the cause of the null-pointer dereference and the location within the code.
The patch also indicates that the bug was detected with Coverity [9].
This patch is classified as a bug (type=bug).
The size is 1 (size=1) as one line of code is added.
From the related source file (super.c), we infer the bug belongs to Ext3's superblock management (data-structure=super).
A nullpointer access is a memory bug (pattern=memory,nullptr) and can lead to a crash (consequence=crash).
However, some patches have less information, making our analysis harder.
In these cases, we sought out other sources of information, including design documents, forum and mailing-list discussions, and source-code analysis.
Most patches are analyzed with high confidence given all the available information and our domain knowledge.
Examples are shown throughout to give more insight as to how the classification is performed.Limitations: Our study is limited by the file systems we chose, which may not reflect the characteristics of other file systems, such as other non-Linux file systems and flash-device file systems.
We only examined kernel patches included in Linux 2.6 mainline versions, thus omitting patches for Ext3, JFS, ReiserFS, and XFS from Linux 2.4.
As for bug representativeness, we only studied the bugs reported and fixed in patches, which is a biased subset; there may be (many) other bugs not yet reported.
A similar study may be needed for user-space utilities, such as mkfs and fsck [33].
File systems evolve through patches.
A large number of patches are discussed and submitted to mailing lists, bugreport websites, and other forums.
Some are used to implement new features, while others fix existing bugs.
In this section, we investigate three general questions regarding file-system patches.
First, what are file-system patch types?
Second, how do patches change over time?
Lastly, what is the distribution of patch sizes?
We classify patches into five categories (Table 1): bug fixes (bug), performance improvements (performance), reliability enhancements (reliability), new features (feature), and maintenance and refactoring (maintenance).
Each patch usually belongs to a single category.
Figure 2(a) shows the number and relative percentages of patch types for each file system.
Note that even though file systems exhibit significantly different levels of patch activity (shown by the total number of patches), the percentage breakdowns of patch types are relatively similar.Maintenance patches are the largest group across all file systems (except Btrfs, a recent and not-yet-stable file system).
These patches include changes to improve readability, simplify structure, and utilize cleaner abstractions; in general, these patches represent the necessary costs of keeping a complex open-source system well-maintained.
Because maintenance patches are relatively uninteresting, we do not examine them further.Bug patches have a significant presence, comprising nearly 40% of patches.
Not surprisingly, the Btrfs has a larger percentage of bug patches than others; however, stable and mature file systems (such as Ext3) also have a sizable percentage of bug patches, indicating that bug fixing is a constant in a file system's lifetime ( Figure 5).
Because this class of patch is critical for developers and tool builders, we characterize them in detail later ( §4).
Both performance and reliability patches occur as well, although with less frequency than maintenance and bug patches.
They reveal a variety of techniques used by different file systems, motivating further study ( §5).
Finally, feature patches account for a small percentage of total patches; as we will see, most of feature patches contain more lines of code than other patches.Summary: Nearly half of total patches are for code maintenance and documentation; a significant number of bugs exist in not only new file systems, but also stable file systems; all file systems make special efforts to improve their performance and reliability; feature patches account for a relatively small percentage of total patches.
File systems change over time, integrating new features, fixing bugs, and enhancing reliability and performance.
Does the percentage of different patch types increase or decrease with time?We studied the changes in patches over time and found few changes (not shown).
While the number of patches per version increased in general, the percentage of maintenance, bug, reliability, performance, and feature patches remained relatively stable.
Although there were a few notable exceptions (e.g., Btrfs had a time where a large number of performance patches were added), the statistics shown in the previous section are relatively good summaries of the behavior at any given time.
Perhaps most interestingly, bug patches do not decrease over time; living code bases constantly incorporate bug fixes (see §4).
Summary: The patch percentages are relatively stable over time; newer file systems (e.g., Btrfs) deviate occasionally; bug patches do not diminish despite stability.
Patch size is one approximate way to quantify the complexity of a patch, and is defined here as the sum of lines of added and deleted by a patch.
Figure 3 displays the size distribution of bug, performance, reliability, and feature patches.
Most bug patches are small; 50% are less than 10 lines of code.
However, more complex file systems tend to have larger bug patches (e.g., Btrfs and XFS) (not shown due to lack of space).
Interestingly, feature patches are significantly larger than other patch types.
Over 50% of these patches have more than 100 lines of code; 5% have over 1000 lines of code.
Summary: Bug patches are generally small; complicated file systems have larger bug patches; reliability and performance patches are medium-sized; feature patches are significantly larger than other patch types.
In this section, we study file-system bugs in detail to understand their patterns and consequences comprehensively.
First, we show the distribution of bugs in filesystem logical components.
Second, we describe our bug pattern classification, bug trends, and bug consequences.
Finally, we analyze each type of bug with a more detailed classification and a number of real examples.
The code complexity of file systems is growing.
able fair comparison, we partition each file system into nine logical components (Table 2).
Figure 4 shows the percentage of bugs versus the percentage of code for each of the logical components across all file systems and versions.
Within a plot, if a point is above the y = x line, it means that a logical component (e.g., inodes) has more than its expected share of bugs, hinting at its complexity; a point below said line indicates a component (e.g., a tree) with relatively few bugs per line of code, thus hinting at its relative ease of implementation.We make the following observations.
First, for all file systems, the file, inode, and super components have a high bug density.
The file component is high in bug density either due to bugs on the fsync path (Ext3) or custom file I/O routines added for higher performance (XFS, Ext4, ReiserFS, JFS), particularly so for XFS, which has a custom buffer cache and I/O manager for scalability [46].
The inode and superblock are core metadata structures with rich and important information for files and file systems, which are widely accessed and updated; thus, it is perhaps unsurprising that a large number of bugs arise therein (e.g., forgetting to update a time field in an inode, or not properly using a superblock configuration flag).
Second, transactional code represents a substantial percentage of each code base (as shown by the relatively high x-axis values) and, for most file systems, has a proportional amount of bugs.
This relationship holds for Ext3 as well, even though Ext3 uses a separate journaling module (JBD); Ext4 (with JBD2) has a slightly lower percentage of bugs because it was built upon a more stable JBD from Linux 2.6.19.
In summary, transactions continue to be a double-edged sword in file systems: while transactions improve data consistency in the presence of crashes, they often add many bugs due to their large code bases.Third, the percentage of bugs in tree components of XFS, Btrfs, ReiserFS, and JFS is surprisingly small compared to code size.
One reason may be the care taken to implement such trees (e.g., the tree code is the only portion of ReiserFS filled with assertions).
File systems should be encouraged to use appropriate data structures, even if they are complex, because they do not induce an inordinate amount of bugs.Although bug patches also relate to feature patches, it is difficult to correlate them precisely.
Code changes partly or totally overlap each other overtime.
A bug patch may involve both old code and recent feature patches.Summary: The file, inode, and superblock components contain a disproportionally large number of bugs; transactional code is large and has a proportionate number of bugs; tree structures are not particularly error-prone, and should be used when needed without much worry.
To build a more reliable file system, it is important to understand the type of bugs that are most prevalent and the typical patterns across file systems.
Since different types of bugs require different approaches to detect and fix, these fine-grained bug patterns provide useful information to developers and tool builders alike.
We partition file-system bugs into four categories based on their root causes as shown in Table 3.
The four major categories are semantic [26,44], concurrency [16,28], memory [14,26,44], and error code bugs [19,40].
4) shows the total number and percentage of each type of bug across file systems.
There are about 1800 total bugs, providing a great opportunity to explore bug patterns at scale.
Semantic bugs dominate other types (except for ReiserFS).
Most semantic bugs require file-system domain knowledge to understand, detect, and fix; generic bug-finding tools (e.g., Coverity [9]) may have a hard time finding these bugs.
Concurrency bugs account for about 20% on average across file systems (except for ReiserFS), providing a stark contrast to user-level software where fewer than 3% of bugs are concurrencyrelated [26,42,45].
ReiserFS stands out along these measures because of its transition, in Linux 2.6.33, away from the Big Kernel Lock (BKL), which introduced a large number of concurrency bugs.
There are also a fair number of memory-related bugs in all file systems; their percentages are lower than that reported in user-level software [26,45].
Many research and commercial tools have On-disk or in-memory data structures are corrupted (e.g., file data or metadata corruption, wrong statistics) File system becomes unusable (e.g., dereference null pointer, assertion failures, panics) Operation failure or unexpected error code returned (e.g., failed write operation due to ENOSPC error) Deadlock Wait for resources in circular chain File system makes no progress (e.g., infinite loop, live lock) System resources are not freed after usage (e.g., forget to free allocated file-system objects) Diverts from expectation, excluding the above ones (e.g., undefined behavior, security vulnerability) been developed to detect memory bugs [9,35], and some of them are used to detect file-system bugs.
Error code bugs account for only 10% of total bugs.
Summary: Beyond maintenance, bug fixes are the most common patch type; over half of file-system bugs are semantic bugs, likely requiring domain knowledge to find and fix; file systems have a higher percentage of concurrency bugs compared with user-level software; memory and error code bugs arise but in smaller percentages.
File systems mature from the initial development stage to the stable stage over time, by applying bug-fixing, performance and reliability patches.
Various bug detection and testing tools are also proposed to improve file-system stability.
A natural question arises: do file-system bug patterns change over time, and in what way?
Our results ( Figure 5) show that within bugs, the relative percentage of semantic, concurrency, memory, and error code bugs varies over time, but does not converge; a great example is XFS, which under constant development goes through various cycles of higher and lower numbers of bugs.
Interesting exceptions occasionally arise (e.g., the BKL removal from ReiserFS led to a large increase in concurrency bugs in 2.6.33).
JFS does experience a decline in bug patches, perhaps due to its decreasing usage and development [6].
JFS and ReiserFS both have relatively small developer and user bases compared to the more active file systems XFS, Ext4 and Btrfs.Summary: Bug patterns do not change significantly over time, increasing and decreasing cyclically; large deviations arise due to major structural changes.
As shown in Figure 2( system hangs and resource leaks), and other wrong behaviors.
Table 4 provides more detail on these categories.
Figure 6(a) shows the per-system breakdowns.
Data corruption is the most predominant consequence (40%), even for well-tested and mature file systems.
Crashes account for the second largest percentage (20%); most crashes are caused by explicit calls to BUG() or Assert() as well as null-pointer dereferences.
If the patch mentions that the crash also causes corruption, then we classify this bug with multiple consequences.
Unexpected errors and deadlocks occur quite frequently (just under 10% each on average), whereas other bug consequences arise less often.
For example, exhibiting the wrong behavior without more serious consequences accounts for only 5-10% of consequences in file systems, whereas it is dominant in user applications [26].
Given that file-system bugs are serious bugs, we were curious: do certain bug types (e.g., semantic, concurrency, memory, or error code) exhibit different levels of severity?
Figure 6(b) shows the relationship between consequences and bug patterns.
Semantic bugs lead to a large percentage of corruptions, crashes, errors, hangs, and wrong behaviors.
Concurrency bugs are responsible for nearly all deadlocks (almost by definition) and a fair percentage of corruptions and hangs.
Memory bugs lead to many memory leaks (as expected) and a fair amount of crashes.
Finally, error code bugs lead to a relatively small percentage of corruptions, crashes, and (unsurprisingly) errors.
Summary: File system bugs cause severe consequences; corruptions and crashes are most common; wrong behavior is uncommon; semantic bugs can lead to significant amounts of corruptions, crashes, errors, and hangs; all bug types have severe consequences.
To gain further insight into the different classes of bugs, we now describe each class in more detail.
We present examples of each and further break down each major class (e.g., memory bugs) into smaller sub-classes (e.g., leaks, null-pointer dereferences, dangling pointers, uninitialized reads, double frees, and buffer overflows).
Semantic bugs are dominant in file systems, as shown in Figure 2(b).
Understanding these bugs often requires file-system domain knowledge.
Semantic bugs usually are difficult to categorize in an informative and general way.
However, we are the first to identify several common types of file-system specific semantic bugs based on extensive analysis and careful generalization of many semantic bugs across file systems.
These common types and typical patterns provide useful guidelines for analysis and detection of file-system semantic bugs.
We partition the semantic bugs into five categories as described in Table 3 File systems maintain a large amount of in-memory and on-disk state.
Generally, operations transform the file system from one consistent state to another; a mistaken state update or access may lead to serious consequences.
As shown in Figure 7(a), these state bugs contribute to roughly 40% of semantic bugs.An example of a state bug is shown in S1 of Table 5 (on page 9), which misses an inode-field update.
Specifically, the buggy version of ext3 rename() does not update the mtime and ctime of the directory into which the file is moved, leaving metadata in an incorrect state.There are also numerous logic bugs, which arise via the use of wrong algorithms, bad assumptions, and incorrect implementations.
An example of a wrong algorithm is shown in S2 of Table 5: find group other() tries to find a block group for inode allocation, but does not check all candidate groups; the result is a possible ENOSPC error even when the file system has free inodes.File system behavior is also affected by various configuration parameters, such as mount options and special hardware support.
Unfortunately, file systems often forget or misuse such configuration information (about 10% to 15% of semantic bugs are of this flavor).
A semantic configuration bug is shown in S3 of Table 5; when Ext4 loads the journal from disk, it forgets to check if the device is read-only before updating the on-disk superblock.Correct that only a small percentage of semantic bugs (3-9%) are I/O timing bugs; however, these bugs can lead to potential data loss or corruption.A fair amount of generic bugs also exist in all file systems, such as using the wrong variable type or simple typos.
These bugs are general coding mistakes (such as comparing unsigned variable with zero [48]), and may be fixed without much file-system knowledge.Summary: Incorrect state update and logic mistakes dominate semantic bug patterns; configuration errors are also not uncommon; incorrect I/O orderings are rare (but can have serious consequences); generic bugs require the least file-system knowledge to understand.
Concurrency bugs have attracted a fair amount of attention in the research community as of late [16,22,28,49,50].
To better understand file-system concurrency bugs, we classify them into six types as shown in Table 3 (on page 5): atomicity violations, deadlocks, order violations, missed unlocks, double unlocks, and wrong locks.
An example of an atomicity violation bug in Ext4 is shown in C1 of Table 5.
For this bug, when two CPUs simultaneously allocate blocks, there is no protection for the i cached extent structure; this atomicity violation could thus cause the wrong location on disk to be read or written.
A simple spin-lock resolves the bug.There are a large number of deadlocks in file systems (about 40%).
Two typical causes are the use of the wrong kernel memory allocation flag and calling a blocking function when holding a spin lock.
These patterns are not common in application-level deadlocks, and thus are useful to both developers (who should be wary of such patterns) and tool builders (who should detect them).
Many deadlocks are found in ReiserFS, once again due to the BKL.
The BKL could be acquired recursively; replacing it introduced a multitude of locking violations, many of which led to deadlock.A typical memory-related deadlock is shown in C2 of Table 5.
Btrfs uses extent readpages() to read free space information; however, it should not use GFP KERNEL flag to allocate memory, since the VM memory allocator kswapd will recursively call into filesystem code to free memory.
The fix changes the flag to GFP NOFS to prevent VM re-entry into file-system code.The remaining four categories account for a small percentage.
Missing unlocks happen mostly in exit or failure paths (e.g., putting resource releases at the end of functions with goto statements).
C3 of Table 5 shows a missing-unlock bug.
ext3 group add() locks super block (line 1) but forgets to unlock on an error (line 4).
Summary: Concurrency bugs are much more common in file systems than in user-level software.
Atomicity and deadlock bugs represent a significant majority of concurrency bugs; many deadlock bugs are caused by wrong kernel memory-allocation flags; most missing unlocks happen on exit or failure paths.
Memory-related bugs are common in many source bases, and not surprisingly have been the focus of many bug detection tools [9,35].
We classify memory bugs into six categories, as shown in Table 3: resource leaks, null pointer dereferences, dangling pointers, uninitialized reads, double frees, and buffer overflows.Resource leaks are the most dominant, over 40% in aggregate; in contrast, studies of user-level programs show notably lower percentages [26,42,45].
We find that roughly 70% of resource leaks happen on exit or failure paths; we investigate this further later ( §4.6).
An example of resource leaks (M1 of As we see in Figure 7(c), null-pointer dereferences are also common in both mature and young file systems (the remaining memory bugs account for small percentages).
An example is shown in M2 of Table 5; a return statement is missing, leading to a null-pointer dereference.Summary: Resource leaks are the largest category of memory bug, significantly higher than that in user-level applications; null-pointer dereferences are also common; failure paths contribute strongly to these bugs; many of these bugs have simple fixes.
File systems need to handle a wide range of errors, including memory-allocation failures, disk-block allocation failures, I/O failures [7,8], and silent data corruption [37].
Handling such faults, and passing error codes through a complex code base, has proven challenging [19,40].
Here, we further break down error-code errors.
We partition the error code bugs into missing error codes and wrong error codes as described in Table 3.
Fig- ure 7(d) shows the breakdown of error code bugs.
Missing errors are generally twice as prevalent as wrong errors (except for JFS, which has few of these bugs overall).
A missing error code example is shown in E1 of Table 5.
The routine posix acl from disk() could return an error code (line 2).
However, without error checking, acl is accessed and thus the kernel crashes (line 3).
An example of a wrong error code is shown in E2 of Table 5.
diAlloc()'s return value should be -EIO.
However, in line 3, the original code returns the close (but wrong) error code EIO; callers thus fail to detect the error.Summary: Error handling bugs occur in two flavors, missing error handling or incorrect error handling; the bugs are relatively simple in nature.
Many bugs we found arose not in common-case code paths but rather in more unusual fault-handling cases [19,52].
This type of error handling (i.e., reacting to disk or memory failures) is critical to robustness, since bugs on failure paths can lead to serious consequences.
We now quantify bug occurrences on failure paths; Tables 6 (a) and (b) present our accumulated results.
As we can see from the first table, roughly a third of bugs are introduced on failure paths across all file systems.
Even mature file systems such as Ext3 and XFS make a significant number of mistakes on these rarer code paths.When broken down by bug type in the second table, we see that roughly a quarter of semantic bugs occur on failure paths, usually in the previously-defined state and logic categories.
Once a failure happens (e.g., an I/O fails), the file system needs to free allocated disk resources and update related metadata properly; however, it is easy to forget these updates, or perform them incorrectly, leading to many state bugs.
In addition, wrong algorithms (logic bugs) are common; for example, when block allocation fails, most file systems return ENOSPC immediately instead of retrying after committing buffered transactions.A quarter of concurrency bugs arise on failure paths.
Sometimes, file systems forget to unlock locks, resulting in deadlock.
Moreover, when file systems output errors to users, they sometimes forget to unlock before calling blocking error-output functions (deadlock).
These types of mistakes rarely arise in user-level code [28].
For memory bugs, most resource-leak bugs stem from forgetting to release allocated resources when I/O or other failures happen.
There are also numerous null-pointer dereference bugs which incorrectly assume certain pointers are still valid after a failure.
Finally (and obviously), all error code bugs occur on failure paths (by definition).
It is difficult to fully test failure-handling paths to find all types of bugs.
Most previous work has focused on memory resource leaks [41,52], missing unlock [41,52] and error codes [19,40]; however, existing work can only detect a small portion of failure-handling errors, especially omitting a large amount of semantic bugs on failure paths.
Our results provide strong motivation for improving the quality of failure-handling code in file systems.Summary: A high fraction of bugs occur due to improper behavior in the presence of failures or errors across all file systems; memory-related errors are particularly common along these rarely-executed code paths; a quarter of semantic bugs are found on failure paths.
A small but important set of patches improve performance and reliability, which are quantitatively different than bug patches ( Figure 3).
Performance and reliability patches account for 8% and 7% of patches respectively.
Performance is critical for all file systems.
Performance patches are proposed to improve existing designs or implementations.
We partition these patches into six categories as shown in Table 7, including synchronization (sync), access optimization (access), scheduling (sched), Inefficient usage of synchronization methods Synchronization (e.g., removing unnecessary locks, using smaller locks, using read/write locks) Access Apply smarter access strategies Optimization (e.g., caching metadata and statistics, avoiding unnecessary I/O and computing)Schedule Improve I/O operations scheduling (e.g., batching writes, opportunistic readahead) Scale on-disk and in-memory data structures Scalability (e.g., using trees or hash tables, per block group structures, reducing memory usage of inodes) Overcome sub-optimal data block allocations (e.g., reducing file fragmentation, clustered I/Os) Other performance improvement techniques (e.g., reducing function stack usage) Synchronization-based performance improvements account for over a quarter of all performance patches across file systems.
Typical solutions used include removing a pair of unnecessary locks, using finer-grained locking, and replacing write locks with read/write locks.
A sync patch is shown in P1 of Table 5; ext4 fiemap() uses write instead of read semaphores, limiting concurrency.Access patches use smarter strategies to optimize performance, including caching and work avoidance.
For example, Ext3 caches metadata stats in memory, avoiding I/O.
Figure 8(a) shows access patches are popular.
An example Btrfs access patch is shown in P2 of Table 5; before searching for free blocks, it first checks whether there is enough free space, avoiding unnecessary work.Sched patches improve I/O scheduling for better performance, such as batching of writes, opportunistic readahead, and avoiding unnecessary synchrony in I/O.
As can be seen, sched has a similar percentage compared to sync and access.
Scale patches utilize scalable on-disk and inmemory data structures, such as hash tables, trees, and per block-group structures.
XFS has a large number of scale patches, as scalability was always its priority.Summary: Performance patches exist in all file systems; sync, access, and sched each account for a quarter of the total; many of the techniques used are fairly standard (e.g., removing locks); while studying new synchronization primitives, we should not forget about performance.
Finally we study our last class of patch, those that aim to improve file-system reliability.
Different from bug-fix patches, reliability patches are not utilized for correctness.
Rather, for example, such a patch may check whether the super block is corrupted before mounting the file system; further, a reliability patch might enhance error propagation [19] or add more debugging information.
Table 8 presents the classification of these reliability patches, including adding assertions and other functional robustness Enhance file-system robustness Robust (e.g., boundary limits and access permission checking, additional internal assertions) Corruption Improve file systems' ability to handle various Defense possible corruptions Error Improve original error handling (e.g., gracefully Enhancement handling failures, more detailed error codes) Add endianness, user/kernel space pointer and lock annotations for early bug detection Debug Add more internal debugging or tracing support (robust), corruption defense (corruption), error enhancement (error), annotation (annotation), and debugging (debug).
Figure 8(b) displays the distributions.
Robust patches check permissions, enforce file-system limits, and handle extreme cases in a more friendly manner.
Btrfs has the largest percentage of these patches, likely due to its early stage of development.Corruption defense patches validate the integrity of metadata when reading from disk.
For example, a patch to the JBD (used by Ext3) checks that the journal length is valid before performing recovery; similarly, a patch to Ext4 checks that a directory entry is valid before traversing that directory.
In general, many corruption patches are found at the I/O boundary, when reading from disk.Error enhancement patches improve error handling in a variety of ways, such as more detail in error codes, removing unnecessary error messages, and improving availability, for example by remounting read-only instead of crashing.
This last class is common in all file systems, which each slowly replaced unnecessary BUG() and assertion statements with more graceful error handling.Annotation patches label variables with additional type information (e.g., endianness) and locking rules to enable better static checking.
ReiserFS uses lock annotations to help prevent deadlock, whereas XFS uses endianness annotations for numerous variable types.
Debug patches simply add more diagnostic information at failure-handling points within the file system.Interestingly, reliability patches appear more ad hoc than bug patches.
For bug patches, most file systems have similar pattern breakdowns.
In contrast, file systems make different choices for reliability, and do so in a generally non-uniform manner.
For example, Btrfs focuses more on Robust patches, while Ext3 and Ext4 prefer to add more Corruption defense patches.Summary: We find that reliability patches are added to file systems over time as part of hardening; most add simple checks, defend against corruption upon reading from disk, or improve availability by returning errors instead of crashing; annotations help find problems at compile time; debug patches add diagnostic information; reliability patch usage, across all file systems, seems ad hoc.
The patch dataset constructed from our analysis of 5079 patches contains fine-grained information, including characterization of bug patterns (e.g., which semantic bugs forget to synchronize data), detailed bug consequences (e.g., crashes caused by assertion failures or null-pointer dereferences), incorrect bug fixes (e.g., patches that are reverted after being accepted), performance techniques (e.g., how many performance patches remove unnecessary locks), and reliability enhancements (e.g., the location of metadata integrity checks).
These details enable further study to improve file-system designs, propose new system language constructs, build custom bug-detection tools, and perform realistic fault injection.In this section, we show the utility of PatchDB by examining which patches are common across all file systems.
Due to space concerns, we only highlight a few interesting cases.
A summary is found in Table 9.
We first discuss specific common bugs.
Within semantic bugs is forget sync, in which a file system forgets to force data or metadata to disk.
Most forget sync bugs relate to fsync.
Even for stable file systems, there are a noticeable number of these bugs, leading to data loss or corruption under power failures.
Another common mistake is forget config, in which mount options, feature sets, or hardware support are overlooked.
File systems also return the ENOSPC error code despite the presence of free blocks (early enospc); Btrfs has the largest number of these bugs, and even refers to the Ext3 fix strategy in its patches.
Even though semantic bugs are dominant in file systems, few tools can detect semantic bugs due to the difficulty of specifying correct behavior [15,25,27].
Fortunately, we find that many semantic bugs appear across file systems, which can be leveraged to improve bug detection.For concurrency bugs, forgetting to lock an inode when updating it is common; perhaps a form of monitors [20] would help.
Calling a blocking function when holding a spin lock (lock sleep) occurs frequently (also in drivers [14,36]).
As we saw earlier ( §4.5.2), using the wrong kernel memory allocation flag is a major source of deadlock (particularly XFS).
All file systems miss unlocks frequently, in contrast to user applications [28].
For memory bugs, leaks happen on failure or exit paths frequently.
For error code bugs, there are a large number of missed I/O error bugs.
For example, Ext3, JFS, ReiserFS and XFS all ignore write I/O errors on fsync before Linux 2.6.9 [37]; as a result, data could be lost even when fsync returned successfully.
Memory allocation errors are also often ignored (especially in Btrfs).
Three file systems mistakenly dereference error codes.For performance patches, removing locks (without sacrificing correctness) is common.
File systems also tend to write redundant data (e.g., fdatasync unnecessarily flushes metadata).
Another common performance improvement case is check before work, in which missing specific condition checking costs unnecessary I/O or CPU overhead.Finally, for reliability patches, metadata validation (i.e., inode, super block, directory and journal) is popular.
Most of these patches occur in similar places (e.g., when mounting the file system, recovering from the journal, or reading an inode).
Also common is replacing BUG() and Assert() calls with more graceful error handling.Summary: Despite their diversity, file-system patches share many similarities across implementations; some examples occur quite frequently; PatchDB affords new opportunities to study such phenomena in great detail.
Operating-System Bugs: Faults in Linux have been studied [14,36].
Static analysis tools are used to find potential bugs in Linux 1.0 to 2.4.1 [14] and Linux 2.6.0 to 2.6.33 [36].
Most detected faults are generic memory and concurrency bugs.
Both studies find that device drivers contain the most faults, while Palix et al. [36] also show that file-system errors are rising.
Yin et al. [53] analyze incorrect bug-fixes in several operating systems.
Our work embellishes these studies, focusing on all file-system bugs found and fixed over eight years and providing more detail on which bugs plague file systems.
User-Level Bugs: Various aspects of modern user-level open source software bugs have also been studied, including patterns, impacts, reproducibility, and fixes [16,26,28,42,50].
As our findings show, file-systems bugs display different characteristics compared with user-level software bugs, both in their patterns and consequences (e.g., file-system bugs have more serious consequences than user-level bugs; concurrency bugs are much more common).
One other major difference is scale; the number of bugs (about 1800) we study is larger than previous efforts [16,26,28,42,50] File-System Bugs: Several research projects have been proposed to detect and analyze file-system bugs.
For example, Yang et al. [51,52] use model checking to detect file-system errors; Gunawi et al. [19] use static analysis techniques to determine how error codes are propagated in file systems; Rubio-Gonzalez et al. [40] utilize static analysis to detect similar problems; Prabhakaran et al. [37] study how file systems handle injected failures and corruptions.
Our work complements this work with insights on bug patterns and root causes.
Further, our public bug dataset provides useful hints and patterns to aid in the development of new file-system bug-detection tools.
We performed a comprehensive study of 5079 patches across six Linux file systems; our analysis includes one of the largest studies of bugs to date (nearly 1800 bugs).
Our observations, summarized in the introduction and throughout, should be of utility to file-system developers, systems-language designers, and tool makers; the careful study of these results should result in a new generation of more robust, reliable, and performant file systems.
We thank Ric Wheeler (our shepherd) and the anonymous reviewers for their excellent feedback and suggestions.
We also thank the members of the ADSL research group for their insightful comments.
This material is based upon work supported by the National Science Foundation under the following grants: CNS-1218405, CCF-0937959, CSR-1017518, CCF-1016924, as well as generous support from NetApp, EMC, and Google.
Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF or other institutions.
