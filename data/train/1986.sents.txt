Query-aware synthetic data generation is an essential and highly challenging task, important for database management system (DBMS) testing, database application testing and application-driven benchmarking.
Prior studies on query-aware data generation suffer common problems of limited parallelization, poor scalability, and excessive memory consumption, making these systems unsatisfactory to terabyte scale data generation.
In order to fill the gap between the existing data generation techniques and the emerging demands of enormous query-aware test databases, we design and implement our new data generator , called Touchstone.
Touchstone adopts the random sampling algorithm instantiating the query parameters and the new data generation schema generating the test database, to achieve fully parallel data generation, linear scalability and austere memory consumption.
Our experimental results show that Touchstone consistently outper-forms the state-of-the-art solution on TPC-H workload by a 1000× speedup without sacrificing accuracy.
The applications of query-aware data generators include DBMS testing, database application testing and application-driven benchmarking [5,15].
For example, during the database selection and performance optimization, the internal databases in production are hard to be shared for performance testing due to the privacy considerations, so we need to generate synthetic databases with the similar workload characteristics of the target queries.
A bulk of existing data generators, e.g., [12,11,4,20], generate test databases independent of the test queries, which only consider the data distribution of inter-and intra-attribute.
They fail to guarantee the similar workload characteristics of the test queries, therefore it's difficult to match the overheads of the query execution engine for real world workloads.
A number of other studies, e.g., [6,14,5,15], attempt to build query-aware data generators.
But the performance of the state-of-the-art solution MyBenchmark [15] still remains far from satisfactory, due to the lack of parallelization, scalability and memory usage control, as well as the narrow support of non-equi-join workload.
In order to generate the enormous query-aware test databases, we design and implement Touchstone, a new query-aware data generator, based on the following design principles: * Rong Zhang is the corresponding author.Full Parallelization: With the explosive growth of data volume in the industrial applications, the database system is expected to support storage and access services for terabyte or even petabyte scale data.
So the synthetic data generator must be fully parallel for generating such extremely large test databases.
Linear Scalability: The single machine has been far from meeting the requirements of generating large test databases, and the data scales may be unbelievably big for the future applications, therefore the data generator needs to be well scalable to multiple nodes and data size.
Austere Memory Consumption: When generating the synthetic database for multiple queries, memory could easily be the bottleneck, because massive information is maintained by the data generator in order to guarantee the dependencies among columns.
The memory usage needs to be carefully controlled and minimized.Since [6,14,5,15] are closest to the target of this work, we list the following key insufficiencies of these studies for elaborating the necessity of proposing Touchstone.
In particular, all of these approaches do not support fully parallel data generation in a distributed environment due to the primitive data generation algorithms over the huge shared intermediate state, limiting the efficiency of data generation over target size at terabytes.
Moreover, their memory consumptions, e.g., symbolic databases of QAGen [6], constrained bipartite graphs of WAGen [14] and MyBenchmark [15], caching referenced tables for generating foreign keys of DCGen [5], strongly depend on the size of generation outputs.
Once the memory is insufficient to host the complete intermediate state, vast computational resources are wasted on disk I/O operations.
In addition, one key advantage of our work is the support of non-equi-join workload, which is important for real world applications but not supported by any of the existing approaches.In query-aware data generation, we need to handle the extremely complicated dependencies among columns which are caused by the complex workload characteristics specified on the target test queries, as well as the data characteristics specified on the columns.
Touchstone achieves fully parallel data generation, linear scalability and austere memory consumption for supporting the generation of enormous query-aware test databases.
There are two core techniques employed by Touchstone beneath the accomplishments of all above enticing features.
Firstly, Touchstone employs a completely new query instantiation scheme adopting the random sampling algorithm, which supports a large and useful class of queries.
Secondly, Touchstone is equipped with a new data generation scheme using the constraint chain data structure, which easily enables thread-level parallelization on multiple nodes.
In summary, Touchstone is a scalable query-aware data generator with a wide support to complex queries of analytical applications, and achieves a 1000× performance improvement against the state-ofthe-art work MyBenchmark [15].
The input of Touchstone includes database schema H, data characteristics D and workload characteristics W , as illustrated in Figure 1.
H defines data types of columns, primary key and foreign key constraints.
In Figure 1, there are three tables R, S, and T .
For example, table S has 20 tuples and three columns.
Data characteristics D of columns are defined in a meta table, in which the user defines the percentage of Null values, the domain of the column, the cardinality of unique values and the average length and maximum length for varchar typed columns.
In our example, the user expects to see 5 unique values on column R.r 2 in the domain [0,10], and 8 different strings with an average length of 20 and a maximum length of 100 for column T.t 3 with 20% Null values.
Workload characteristics W are represented by a set of parameterized queries which are annotated with several cardinality constraints.
In Figure 1, our sample input consists of four parameterized queries, i.e., Q = {Q 1 , Q 2 , Q 3 , Q 4 }.
These four queries contain 11 variable parameters, i.e., P = {P 1 , P 2 , ..., P 11 }.
Each filter/join operator in the queries is associated with a size constraint, defining the expected cardinality of the processing outcomes.
Therefore, there are 14 filter/join operators and corresponding 14 cardinality constraints in our example, i.e., C = {c 1 , c 2 , ..., c 14 }.
Our target is to generate the three tables and instantiate all the variable query parameters.
In the following, we formulate the definition of cardinality constraints.Definition 1 Cardinality Constraint: Given a filter (σ ) or join () operator, a cardinality constraint c is denoted as a triplet c = [Q, p, s], where Q indicates the involving query, p gives the predicate on the incoming tuples, and s is the expected cardinality of operator outcomes.The cardinality constraint c 1 in Figure 1, for example, is written as [Q 1 , R.r 2 < P 1 , 4], indicating that the operator with predicate R.r 2 < P 1 in query Q 1 is expected to output 4 tuples.
For conjunctive and disjunctive operators, their cardinality constraints can be split to multiple cardinality constraints for each basic predicate using standard probability theory.
These cardinality constraints generally characterize the computational workload of query processing engines, because the computational overhead mainly depends on the size of the data in processing.
This hypothesis is verified in our experimental evaluations.While the focus of cardinality constraints is on filter and join operators, Touchstone also supports complex queries with other operators, including aggregation, groupby and orderby.
For example, the query Q 2 in Figure 1 applies groupby operator on T.t 3 and summation operator on S.s 3 over the grouped tuples.
The cardinality of the output tuples from these operators, however, is mostly determined, if it does not contain a having clause.
And such operators are usually engaged on the top of query execution tree, hence the output result cardinalities generally do not affect the total computational cost of query processing.
Based on these observations, it is unnecessary to pose explicit cardinality constraints over these operators [14,5] in Touchstone.Based on the target operators (filter or join) and the predicates with equality or non-equality conditional expressions, we divide the cardinality constraints into four types, i.e.,C = C σ = ∪ C σ = ∪ C = ∪ C = .
Accordingly, we classify the example constraints in Figure 1 asC σ = = {c 2 , c 5 , c 8 , c 10 } 1 , C σ = = {c 1 , c 4 , c 7 , c 12 , c 13 }, C = = {c 3 , c 6 , c 9 , c 11 } and C = = {c 14 }.
Following the common practice in [5,24,25], the equi-join operator is always applied on the pair of primary and foreign keys.Then we formulate the problem of query-aware data generation as follows.
Given the input database schema H, data characteristic D and workload characteristics W , the objective of data generation is to generate a database instance (DBI) and instantiated queries, such that 1) the data in the tables strictly follows the specified data characteristics D; 2) the variable parameters in the queries are appropriately instantiated; and 3) the executions of the instantiated queries on the generated DBI produce exactly the expected output cardinality specified by workload characteristics W on each operator.While the general solution to query-aware data generation problem is NP-hard [21], we aim to design a data generator, by relaxing the third target in the definition above.
Specifically, the output DBI is expected to perform as closely as the cardinality constraints in C. Given the actual/expected cardinalities of processing outputs, i.e., { ˆ s 1 , ˆ s 2 , . . . , ˆ s n }, corresponding to constraints on the queries in C = {c 1 , c 2 , . . . , c n }, we aim to minimize the global relative error Touchstone still attempts to generate a DBI with the best effort.
The infrastructure of Touchstone is divided into two components, which are responsible for query instantiation and data generation respectively, as shown in Figure 2.
Query Instantiation: Given the inputs including database schema H, data characteristics D, Touchstone builds a group of random column generators for non-key columns, denoted by G, each G i in which corresponds to a column of the target tables.
Given the input workload characteristics W , Touchstone instantiates the parameterized queries by adjusting the related column generators if necessary and choosing appropriate values for the variable parameters in the predicates of c ∈ C σ = ∪ C σ = ∪ C = .
The instantiated queries ¯ Q are output to the users for reference, while the queries ¯ Q and the adjusted column generators ¯ G are fed into the data generation component.
The technical details are available in Section 3.
Data Generation: Given the inputs including instantiated queries ¯ Q and constraints over the equi-join operators C = specified in W , Touchstone decomposes the query trees annotated with constraints into constraint chains, in order to decouple the dependencies among columns, especially for primary-foreign-key pairs.
Data generation component generally deploys the data generators over a distributed platform.
The random column generators and constraint chains are distributed to all data generators for independent and parallel tuple generation.
The technical details are available in Section 4.
The basic elements of Touchstone system are a group of random column generators G = {G 1 , G 2 , . . . , G n }, which determine the data distributions of all non-key columns to be generated.
A random column generator G i in G Figure 2: The overall architecture of Touchstone is capable of generating values for the specified column, while meeting the required data characteristics in expectation.
In the following, we give the detailed description of the random column generator.A random column generator G i contains two parts, a random index generator and a value transformer as shown in Figure 3.
In the random index generator, the output index domain is the integers from 0 to n − 1 while n is the specified cardinality of unique values in corresponding column.
Given an index, the transformer deterministically maps it to a value in the specified domain of the column.
We adopt different transformers based on the type of the column.
For numeric types, e.g., Integer, we simply pick up a linear function which uniformly maps the index to the value domain.
For string types, e.g., Varchar, there are some seed strings pregenerated randomly, which satisfy the specified length requirements.
We first select a seed string based on the input index as shown in Figure 3, and then concatenate the index and the selected seed string as the output value.
This approach allows us to easily control the cardinality of string typed columns with tiny memory consumption.To manipulate the distribution of the column values, there is a probability table in the random index generator.
The probability table consists of a number of entries and each entry corresponds to an index.
Specifically, each entry in the table (k i , p i , c i ) specifies an index k i , the probability p i of occurrence, and the cumulative probability c i for all indexes no larger than k i .
In order to save the memory space, we compress the table by keeping only the entries with non-uniform probabilities.
If an index does not appear in the probability table, its probability is automatically set by the uniform probability.
The entries in the table are ordered by k i .
In Figure 3, we present an example of random column generator designed for column T.t 3 from example inputs in Figure 1.
The specified data characteristics request this column to contain 8 unique strings with average length 20 and maximum length 100.
In the result generator, based on the indexes in [0,7] generated by random index generator, the transformer outputs random strings with the desired lengths, at probabilities {p 0,2,3,5,7 = 0.1,p 1 = 0.2, p 4,6 = 0.15}.
The details of probability assignment will be discussed in Section 3.
Value Generation: Given the random column generator, firstly, a Null value is output with the probability of the specified percentage.
If Null value is not chosen, the index generator picks up an index based on the probabilities by running binary search over CDF (c i ) in the probability table with a random real number in (0,1], and the transformer outputs the corresponding column value.
There are two general objectives in query instantiation, targeting to 1) construct the random column generators for each non-key column in the tables; and 2) find concrete values for the variable parameters in the queries.Generally speaking, the query instantiation component is responsible for handling three types of constraints, i.e., C σ = , C σ = and C = .
Note that the fourth type of constraints C = involves matching between primary and foreign keys, which is taken care of by the data generation process at runtime.
In Algorithm 1, we list the general workflow of query instantiation.
The algorithm iteratively adjusts the data distribution adopted by the random column generators and the concrete values of the variable parameters, in order to meet the constraints as much as possible.
The distribution adjustment on the column generator is accomplished by inserting entries in its probability table.
In each iteration, the algorithm reinitializes the column generators (line 3) such that there is no entry in the probability table, namely the probabilities of candidate values are uniform.
The algorithm then attempts to adjust the column generators in ¯ G and the concrete values of the variable parameters in queries ¯ Q (lines 4-11).
Specifically, it firstly adjusts the column generators and instantiates the variable parameters based on the equality constraints over filters (lines 4-6).
It then follows to revise the variable parameters in the queries in order to meet the non-equality constraints on filter and join operators (lines 7-11).
The details of the adjustment on column generators and the parameter instantiation are presented in the following subsections.
The algorithm outputs the new (adjusted) generators ¯ G and the instantiated queries ¯ Q, when the global relative error for all constraints is within the specified threshold θ or the number of iterations reaches its maximum I. Input: Initial generators G, input queries Q, error threshold θ and maximum number of iterations I Output: New generators ¯ G and instantiated queries ¯Q 1: Initialize ¯ Q ← Q 2: for all iteration i = 1 to I do 3: Initialize ¯ G ← G 4: for all constraint c ∈ C σ = do 5:Adjust the generator in ¯ G for the column within c 6:Instantiate the corresponding parameter in ¯ Q for all c ∈ C σ = do 8:Instantiate the corresponding parameter in ¯ Q for all c ∈ C = do 10:Obtain constraints from all descendant nodes 11:Instantiate the corresponding parameter in ¯ Q Calculate the global relative error e if e ≤ θ then return ¯ G and ¯ Q 14: return ¯ G and ¯ Q (historical best solution with minimum e)In the rest of the section, we discuss the processing strategies for these three types of constraints respectively.Filters with Equality Constraint always involve a single non-key column at a time like the workloads of standard benchmarks.
Given all these equality constraints on the filter operators, i.e., C σ = , the system groups the constraints according to the involved column.
In our running example in Figure 1, there are four such constraints C σ = = {c 2 , c 5 , c 8 , c 10 }, among which, c 2 and c 8 target column S.s 3 , and c 5 and c 10 target column T.t 3 .
Note that all relational operators in equality constraints are handled by treating them as '='.
For example,c 5 = [Q 2 , T.t 3 NOT LIKE P 4 , 32] ⇒ [Q 2 , T.t 3 LIKE P 4 , 8] ⇒ [Q 2 , T.t 3 = P 4 , 8].
The processing strategy for equality constraints on filters runs in three steps.
Firstly, the algorithm randomly selects an index and obtains the corresponding value from the transformer of the column generator, for instantiating each variable parameter in the equality con- Figure 4: An example of parameter searching procedure for constraint c 7 .
Given the predicate in c 7 , our algorithm attempts to cut the space by revising the parameter P 5 .
For a concrete P 5 , the expected number of tuples meeting the predicate is evaluated by the random sampling algorithm.
The best value for P 5 is returned, after the binary search identifies the optimal value at desired precision or reaches the maximum iterations.straints.
Secondly, the algorithm updates the occurrence probability of the selected index in the column generator by inserting an entry in the probability table, in order to meet the required intermediate result cardinality.
Whether the filter is the leaf node of the query execution tree or not, the probability of the inserted entry is calculated as s out s in , where s in is the size of input tuples and s out is the expected size of output tuples.
After the above two steps for all equality constraints, the algorithm calculates the cumulative probabilities in the probability table of adjusted column generators.
In Figure 3, there are three entries in the probability table for generating data with the distribution that satisfies the constraints c 5 and c 10 .
For example, the entry with index 1 is inserted for instantiating parameter P 4 in the predicate of c 5 , while the two entries with indexes 4 and 6 are inserted for instantiating parameters P 7 and P 8 in the predicate of c 10 .
Suppose there are k variable parameters in the equality constraints over filters.
The total complexity of the processing strategy is O(k log k), because the algorithm only needs to instantiate the parameters one by one, and accordingly it inserts an entry into the probability table in order of selected index for each parameter instantiation.
Filters with Non-Equality Constraint could involve multiple non-key columns.
In Figure 1, some constraints, e.g.,c 1 = [Q 1 , R.r 2 < P 1 , 4] and c 4 = [Q 2 , S.s 3 ≥ P 3 , 7], apply on one column only, while other constraints, e.g., c 7 = [Q 3 , R.r 2 − R.r 3 > P 5 , 6] and c 12 = [Q 4 , 2 × R.r 2 + R.r 3 < P 9 , 7], involve more than one column with more complex mathematical operators.
Our underlying strategy handling these non-equality constraints is to find the concrete parameters generating the best matching output cardinalities against the constraints, based on the data distributions adopted by the random column generators.Since the cardinality of tuples satisfying the constraints is monotonic with the growth of the variable parameter, it suffices to run a binary search over the parameter domain to find the optimal concrete value for the variable parameter.
In Figure 4, we present an example to illustrate the parameter searching procedure.
The cutting line in the figure represents the parameter in the constraint, which decides the ratio of tuples in the shadow area, i.e., satisfying the constraint.
By increasing or decreasing the parameter, the likelihood of tuples in the shadow area changes correspondingly.
The technical challenge behind the search is the hardness of likelihood evaluation over the satisfying tuples, or equivalently the probability of tuples falling in the shadow area in our example.
To tackle the problem, we adopt the random sampling algorithm, which is also suited for the non-uniform distribution of the involved columns.
Note that the binary search may not be able to find a parameter with the desired precision, based on the determined data distribution of columns after processing equality constraints over filters.
Therefore, in Algorithm 1, we try to instantiate the parameters for non-equality constraints upon different data distributions by iteration.The complexity of the approach is the product of two components, the number of iterations in parameter value search and the computational cost of probability evaluation using random sampling algorithm in each iteration.
The number of iterations for the binary search is logarithmic to the domain size of the parameter, decided by the minimal and maximal value that the expression with multiple columns could reach.
The cost of random sampling depends on the complexity of the predicate, which usually only involves a few columns.
Joins with Non-Equality Constraint are slightly different from the filters with non-equality constraints, because the columns involved in their predicates may overlap with the columns in the predicates of their child nodes as query Q 4 in Figure 1, which usually does not happen to filters in the query execution tree.
Therefore, we must process the constraints in a bottom-up manner without the premise of probability independence, such that the precedent operators are settled before the join operator with non-equality constraint is handled.
In Figure 5, we present the processing flow on query Q 4 .
After Touchstone concretizes the parameters P 9 and P 10 in constraints c 12 and c 13 , the input data to the join operator with constraint c 14 is determined.
Based on the characteristics of the inputs, we apply the same binary search strategy designed for filter operator to construct the optimal parameter, e.g., P 11 in Figure 5, for the desired result cardinality.
Since the algorithm is identical to that for filter operator, we hereby skip detailed algorithm descriptions as well as the complexity analysis.
Given the generators of all non-key columns and the instantiated queries, the data generation component is responsible for assembling tuples based on the outputs of the column generators.
The key technical challenge here is to meet the equality constraints over the join operators, i.e., C = , which involve the dependencies among primary and foreign keys from multiple tables.
To tackle the problem, we design a new tuple generation schema, which focuses on the manipulation of foreign keys only.The tuple generation consists of two steps.
In the first compilation step, Touchstone orders the tables as a generation sequence and decomposes the query trees into constraint chains for each target table.
In the second assembling step, the working threads in Touchstone independently generate tuples for the tables based on the result order from compilation step.
For each tuple, the working thread fills values in the columns by calling the random column generators independently and incrementally assigns a primary key, while leaving the foreign keys blank.
By iterating the constraint chains associated with the table, the algorithm identifies the appropriate candidate keys for each foreign key based on the maintained join information of the referenced primary key, and randomly assigns one of the candidate keys to the tuple.
Compilation Step: The generation order of the tables is supposed to be consistent with the dependencies between primary keys and foreign keys, because the primary key must be generated before the adoption of its join information for generating corresponding foreign keys of other tables.
Since such primary-foreign-key dependencies form a directed acyclic graph (DAG), Touchstone easily constructs a topological order over the tables.
In Figure 6, we illustrate the result order over three tables, R → S → T , based on the database schema H in Figure 1.
In order to decouple the dependencies among columns and facilitate parallelizing, Touchstone decomposes the query trees annotated with constraints into constraint chains.
A constraint chain consists of a number of constraints corresponding to the cardinality constraints over the operators in query trees.
There are three types of constraints included in the constraint chains, namely FIL-TER, PK and FK, which are associated with the types of related operators.
The constraint chains with respect to a table are defined as the sequences of constraints with descendant relationship in the query trees.
In Figure 6, we present all the constraint chains for tables R, S and T .
For example, table R has two constraint chains extracted from queries Q 1 and Q 3 .
And the constraint chains of table S are marked in Figure 1 for easily understanding.Each FILTER constraint keeps the predicate with the instantiated parameters.
Each PK constraint in the chain records the column name of the primary key.
Each FK constraint maintains a triplet, covering two column Figure 6: Results of constraint chain decomposition names of the foreign key and the referenced primary key, and the expected ratio of tuples satisfying the predicate on the join operator.
The second constraint in the first chain for table S in Figure 6, for example, is FK[S.s 2 , R.r 1 , 2 3 ], indicating the foreign key is S.s 2 , the referenced primary key is R.r 1 and two out of three tuples in table S are expected to meet the predicate S.s 2 = R.r 1 of join operator in the case of satisfying the predicate S.s 3 = P 2 of previous filter.
The expected ratios in FK constraints are calculated based on the cardinality requirements of the specified cardinality constraints.
Assembling Step: For simplicity, we assume that there is a single-column primary key and one foreign key in the table.
Note that our algorithm can be naturally extended to handle tables with composite primary key and multiple foreign keys.
The result constraint chains are distributed to all working threads on multiple nodes for parallel tuple generation.
When generating tuples for a specified table, each working thread maintains two bitmap data structures at runtime, i.e., φ f k and φ pk .
They are used to keep track of the status of joinability, e.g., whether the generating tuple satisfies individual predicates over join operators, for primary key and foreign key, respectively.
The length of the bitmap φ f k (resp.
φ pk ) is equivalent to the number of FK (resp.
PK) constraints in all chains of the target table.
Each bit in the bitmap corresponds to a FK/PK constraint.
It has three possible values, T , F and N, indicating if the join status is successful, unsuccessful or null.
In Figure 6, for example, table S has two FK constraints and two PK constraints, resulting in 2-bit representations for both φ f k and φ pk .
Touchstone also maintains the join information table to track the status of joinability of primary keys based on the bitmap representation φ pk .
In Figure 7, we show two join information tables of primary keys R.r 1 and S.s 1 respectively.
The join information table of R.r 1 is maintained in the generation of table R, which is ready for generating the foreign key S.s 2 of table S.
During the generation of table S, the join information table of S.s 1 is maintained for generating the foreign key T.t 2 of table T .
There are two attributes in the entry of join information table, i.e., bitmap and keys, indicating the status of joinability and the corresponding satisfying primary key values.
Note that the keys in the entry may be empty (such entries will not be stored in practice), which means there is no primary key with the desired joinability status.
Input: Column generators ¯ G, constraint chains of the target table Ω, join information tables of referenced primary key and current primary key t rpk and t pk Output: Tuple r and join information table t pk 1: r.pk ← a value assigned incrementally 2: r.columns ← values output by column generators ¯ G 3: φ f k ← N..
.
N, φ pk ← N..
.
N 4: for all constraint chain ω ∈ Ω do φ f k [i] ← f lag // iis the bit index for c 14: r. f k ← a value selected from t rpk satisfying φ f k 15: Add r.pk in the entry of t pk with bitmap φ pk 16: return r and t pkThe tuple generation algorithm is listed in Algorithm 2.
We present a running example of tuple generation in Figure 7.
A new tuple for table S is initialized as (S.s 1 = 7, S.s 2 =?
, S.s 3 = 16), φ f k = NN and φ pk = NN (lines 1-3).
The f lag is set to True before traversing each constraint chain (line 5), which is used to track if the predicates from the precedent constraints of current chain are fully met.
On the first constraint chain, since the predicate in the first FILTER constraint is S.s 3 = 4, f lag is then set to False (line 8), and algorithm does not need to handle the next FK constraint (line 11).
On the second chain, the tuple satisfies the predicate S.s 3 ≥ 15, resulting in the update of bitmap representation as φ pk = NT (line 10).
On the third chain, after passing the first FILTER constraint, the corresponding bit of next FK constraint in φ f k is randomly flipped to F at the probability of 2 5 (lines 12-13), because the expected ratio of satisfying tuples is 3 5 .
The f lag is set to False (line 12) to reflect the failure of full matching of precedent constraints for later PK constraint.
Then, the bit corresponding to next PK constraint in φ pk is set as F according to the value of f lag (line 10).
Therefore, the two bitmaps are finalized as φ f k = FN and φ pk = FT .
Then the algorithm identifies (line 14) two entries matching φ f k = FN, namely satisfying the T /F requirements on the corresponding bits of φ f k , with bitmaps FT and FF respectively, in the join information table of R.r 1 .
Given these two entries, it randomly selects (line 14) a foreign key, e.g., 6, from four candidate referenced primary keys {2, 7, 6, 8}, which are all appropriate as the foreign key S.s 2 .
That there is no entry in t rpk satisfying the T /F requirements of φ f k , which is called mismatch case, is dealt in the rest of the section.
Finally, the algorithm updates (line 15) the join information table of S.s 1 by adding the primary key S.s 1 = 7 into the entry with bitmap FT .
For a table, suppose there are k non-key columns, m constraints in the related constraint chains and n entries in the join information table of referenced primary key.
The complexity of tuple generation mainly consists of three parts, k times of calling random column generators for filling the values of non-key columns, the traversing over m constraints within chains for determining the joinability statuses of foreign key and primary key, and the comparing with n bitmaps in the join information table for searching the appropriate foreign key candidates.
For practical workloads, k, m and n are all small numbers, e.g., k ≤ 12, m ≤ 20 and n ≤ 40 for TPC-H [3] workload, so our tuple generation is highly efficient.
Handling Mismatch Cases: For the data generation of big tables, if a joinability status of the primary key may occur, its occurrence can be considered as inevitable based on the probability theory.
However, there are still some joinability statuses of the primary key that never occur.
For example, in Figure 7, the bitmap φ pk for primary key S.s 1 can not be T F due to the constraints, i.e., Filter[S.s 3 = 16] and Filter[S.s 3 ≥ 15].
Therefore, in the tuple generation, it should be avoided to generate the bitmap φ f k that does not have any matching entry in the join information table of the referenced primary key.
In order to achieve this objective, the main idea is to add rules to manipulate relevant FK constraints.
Figure 8 gives an example of adjustments to FK constraints for handling the mismatch case.
There are three FK constraints with the serial numbers of 1, 2 and 3 in the three constraint chains, respectively.
Since there are four bitmaps, i.e., FTT, TTT, TFT, FTF, that are not presented in the join information table of the referenced primary key rpk corresponding to the foreign key f k of the target table, three rules are added in two FK constraints to avoid [2].
To reflect the adjustments to FK constraints in the tuple generation, minor modification is applied on the original tuple generation algorithm on lines 12-13 in Algorithm 2.
Specifically, the updated algorithm first checks all existing rules in current FK constraint.
If there is a rule which can be applied to the statuses of previous constraints, φ f k and f lag are updated according to the rule.
Otherwise, the algorithm updates φ f k and f lag by the probability based on the adjusted ratio.
Management of Join Information: For generation of a table, it can be completely parallel on multiple nodes with multiple working threads on each node.
Each working thread maintains its own join information table of the primary key to avoid contention.
But the join information table of referenced primary key can be shared among multiple working threads on each node.
After the generation of the table, we merge the join information tables maintained by the multiple working threads in distributed controller as in Figure 2.
But there are serious memory and network problems for the space complexity of the join information table is O(s) with s as the table size.Since the relationship of foreign key and primary key can be many to one and the intermediate result cardinality is the main factor that affects the query performance, we design a compression method by storing less primary key values in the join information table but still promise the randomness of remaining values.
Assuming the size of keys in an entry of join information table is N, which is hard to know in advance and may be very large.
We aim to store only L (L << N) values in the keys and promise the approximately uniform distribution of these L ones among all N values.
The compression method is implemented as follows: we store the first L arriving values in the keys, if any; and for the i-th (i > L) arriving value, we randomly replace a value stored previously in the keys with the probability of L/i.
By such a method, the space complexity of the join information table is reduced to O(n * L), where n is the number of entries in the join information table and L is the maximum allowed size of keys in each entry.
Since n is generally small, e.g., n ≤ 40 for TPC-H workload, and L usually can be set to thousands, the memory consumption and network transmission of the join information table are acceptable.
Environment.
Our experiments are conducted on a cluster with 8 nodes.
Each node is equipped with 2 Intel Xeon E5-2620 @ 2.0 GHz CPUs, 64GB memory and 3 TB HDD disk configured in RAID-5.
The cluster is connected using 1 Gigabit Ethernet.
Workloads.
The TPC-H [3] is a decision support benchmark which contains the most representative queries of analytical applications, while the transactional benchmarks, e.g., TPC-C and TPC-W, do not contain queries for analytical processing.
So we take the TPC-H workload for our experiments.
We compare Touchstone with the state-of-the-art work MyBenchmark [15] with source codes from the authors.
2 The workloads for comparison consist of 6 queries from TPC-H, including Q 2,3,6,10,14,16 .
Note that these queries are selected based on the performance of MyBenchmark, which drops significantly when other queries are included in the workloads.
Touchstone, on the other hand, can easily handle all of the first 16 queries, i.e., Q 1 to Q 16 , in TPC-H with excellent performance.
To the best of our knowledge, Touchstone provides the widest support to TPC-H workload, among all the existing studies [6,14,5,15].
Input Generation.
To build valid inputs for experiments, we generate the DBI and queries of TPC-H using its tools dbgen and qgen, respectively.
And the DBI of TPC-H is imported into the MySQL database.
The database schema of TPC-H is used as the input H.
We can easily obtain the input data characteristics D for all columns from the DBI in MySQL.
Given the TPC-H queries, their physical query plans are obtained from MySQL query parser and optimizer over the DBI.
The cardinality constraints corresponding to the operators in query plans are then identified by running the queries on the DBI in MySQL.
The input workload characteristics W are constructed by the parameterized TPC-H queries and above cardinality constraints.
Note that we can generate databases with different scale factors using the same input W by employing selectivities instead of the absolute cardinalities in our input constraints.
Settings.
As data is randomly generated according to the column generators in Touchstone, the distribution of generated data may be difficult to satisfy the expectation for small tables such as Region and Nation.
We therefore revise the sizes of Region and Nation from 5 to 500, and from 25 to 2500 respectively.
The cardinality constraints involving these two tables are updated proportionally.
In addition, the small tables can also be pre-generated manually.
The error threshold (desired precision) and maximal iterations in query instantiation are set to 10 −4 and 20 respectively.
The default maximum allowed size L of keys in join information table is set to 10 4 .
We compare Touchstone with MyBenchmark from four aspects, including data generation throughput, scalability to multiple nodes, memory consumption and capability of complex workloads.
Figure 9 shows the data generation throughputs per node of Touchstone and MyBenchmark as we vary the number of nodes under different scale factors.
Due to the unacceptably long processing time of MyBenchmark, we adopt smaller scale factors for it and large scale factors for Touchstone.
Overall, the data generation throughput of Touchstone is at least 3 orders of magnitude higher than that of MyBenchmark.
This is because MyBenchmark does not have a good parallelization or an efficient data generation schema.
Furthermore, as the number of nodes increases from 1 to 5, the data generation throughput per node of MyBenchmark decreases dramatically for all three scale factors.
Although the decline of data generation throughput per node of Touchstone is obvious too when SF = 1, Touchstone is linearly scalable (the throughput per node is stable) when SF = 100.
This is because for small target database, e.g., SF = 1, the distributed maintenance rather than data generation dominates the computational cost in Touchstone, while its overhead comparatively diminishes by increasing the target database size.
Figure 10 reports the peak memory consumptions of Touchstone and MyBenchmark under different data scales.
The experiment is conducted on 5 nodes with no restriction on memory usage.
The memory usage of MyBenchmark mainly consists of two parts, namely, memory consumed by MyBenchmark Tool and memory consumed by PostgreSQL for managing intermediate states.The memory usage of Touchstone mainly includes memory for JVM itself and memory for maintaining join information.
As shown in Figure 10, the memory consumption of Touchstone is much lower than that of MyBenchmark under the same scale factors.
It is worth noting that the memory consumption of Touchstone remains almost constant when SF > 10.
This is because for Touchstone, the JVM itself occupies most of the memory, while the join information maintenance only spends a tiny piece of memory.
Figure 11 and Figure 12 present the data generation time (total running time) and global relative error separately of Touchstone and MyBenchmark as we vary the number of input queries with SF = 1.
The input queries are loaded in order of their serial numbers.
The experiment is carried out on 5 nodes.
In Figure 11, it is obvious that the data generation time of MyBenchmark increases significantly as the number of queries increases.
At the same time, the generation time of Touchstone grows very little when more queries are included, significantly outperforming MyBenchmark.
In Figure 12, the error of Touchstone is much smaller than that of MyBenchmark.
Moreover, as there are more input queries, the global relative error of Touchstone remains small with little change, while the error of MyBenchmark has an obvious rise.
In summary, Touchstone is more capable of supporting complex workloads than MyBenchmark.It can be seen from previous experiments that MyBenchmark can not be easily applied to generate the terabyte scale database for complex workloads due to its poor performance.
In the following, we further demonstrate the advantages of Touchstone by a series of experiments using the workload of 16 queries, i.e., Q 1 to Q 16 .
In this section, we evaluate the impact of workload complexity on query instantiation time and total running time in Touchstone, as well as the scalability to data scale and multiple nodes of Touchstone.
Figure 13 shows the query instantiation time of Touchstone as we vary the number of queries with SF = 1 and SF = 100, respectively.
The input queries are loaded in order of their serial numbers.
The query instantiator is deployed on a single node.
As shown in Figure 13, even when all 16 queries are used for input, query instantiation is finished within 0.2s. And there is a minimal difference in query instantiation time for SF = 1 and SF = 100, as the complexity of query instantiation is independent of data scale.
Overall, the query instantiation time is only correlated to the complexity of input workloads.
Figure 14 shows the total running time of Touchstone as we vary the number of queries with SF = 500.
Touchstone is deployed on 8 nodes.
From the result, it can be seen that the running time increases slowly as the number of queries increases.
For Q 7 and Q 8 , there are relatively more cardinality constraints over equi-join operators, so the time increment is larger when we change from 6 queries to 8 queries.
But when the number of queries changed from 10 to 16, the time increment is almost indiscernible, for Q 11 to Q 16 are simple, among which Q 12 to Q 15 have no cardinality constraints on equi-join operators 3 .
Overall, the total running time increased by only 16% from 2 queries to 16 queries for 500GB data generation task, so Touchstone is insensitive to the workload complexity.
Figure 15 presents the total running time of Touchstone under different scale factors with the input of 16 queries.
Touchstone is deployed on 8 nodes.
As shown in Figure 15, Touchstone is linearly scalable to data size.
Because the generation of each tuple is independent and the generated tuples need not be stored in memory, the data generation throughput is stable for different data scales.
Moreover, the total runtime of Touchstone is less than 25 minutes for SF = 1000 (1TB), so it is capable of supporting industrial scale database generation.
Figure 16 presents the data generation throughputs per node of Touchstone as we vary the number of nodes with SF = 500.
The input workload includes 16 queries.
The result shows that the data generation throughput per node 3 Depending on the physical query plans of Q 12 to Q 15 , the primary keys in their equi-join operators are from the original tables, so all foreign keys must be joined and the sizes of output tuples are determined.is approximatively unchanged as the number of nodes increases, validating the linear scalability of Touchstone.
To the best of our knowledge, Touchstone is the first query-aware data generator which can support full parallel data generation on multiple nodes.
The data fidelity of synthetic database is evaluated by relative error on cardinality constraints and performance deviation on query latencies.
We calculate the relative error for each query in the similar way with global relative error, which only involves its own cardinality constraints.
We compare the latency of query processing on base database generated by dbgen against that on synthetic database generated by Touchstone to show the performance deviation.
Figure 17 shows the relative errors for Q 1 to Q 16 with different scale factors from 1 to 5.
The maximum error among all 16 queries is less than 4%, and there are 14 queries with errors less than 1%.
Figure 18 shows the global relative error of all 16 queries as we vary the scale factor, which is less than 0.2% for all scale factors.
And with the increase of scale factor, the global relative error has a sharp decrease.
Since data is randomly generated by column generators, as expected by the probability theory, the larger the data size, the smaller the relative error.
Figure 19 presents the performance deviations of all 16 queries with SF = 1.
We vary the maximum allowed size L of keys in the join information table from 10 3 to 10 5 .
We can see that the performance deviation is inconspicuous for all 16 queries, and the size of L has no significant influence on query latencies.
The result strongly illustrates the correctness and usefulness of our work.
We are the first work to give such an experiment to verify the fidelity of the generated DBI.
More experimental results are available in our online technical report [2], which demonstrate the effectiveness for data generation of non-equi-join workloads, handling mismatch cases, the compression method on join information table, and other benchmark workloads.
There are many data generators [7,12,11,4,20,23,1,9] which only consider the data characteristics of the target database.
For example, Alexander et al. [4] proposes pseudo-random number generators to realize the parallel Figure 19: Performance deviation for each query data generation.
Torlak [23] supports the scalable generation of test data from a rich class of multidimensional models.
However, all these data generators can not generate test databases with the specified workload characteristics on target queries.There are query-aware data generators [6,14,5,15], among which [6,14,15] are a series of work.
QAGen [6] is the first query-aware data generator, but for each query it generates an individual DBI and its CSP (constraint satisfaction program) has the usability limitations as declared in experimental results.
WAGen [14] makes a great improvement that it generates m (≤ n) DBIs with n input queries, but WAGen can't guarantee that only one DBI is generated and still has CSP performance problem.
Though MyBenchmark [15] has done a lot of performance optimization, generating one DBI can not be promised for multiple queries and the performance is still unacceptable for the generation of terabyte scale database.
DCGen [5] uses a novel method to represent data distribution with ideas from the probabilistic graphical model.
But DCGen is weak in support of foreign key constraint, and it cannot easily support parallel data generation in a distributed environment.There are some interesting non-relational data generators [18,8,13,19,10].
For example, Olston et al. [18] introduces how to generate example data for dataflow programs.
Sara [8] generates structural XML documents.
[13,19] are synthetic graph generators.
Chronos [10] can generate stream data for real time applications.
In addition, there are query generation works [17,16] which are partly similar to us, but they generate queries satisfying the specified cardinality constraints over an existing DBI.
Moreover, the dataset scaling works [22,25] can serve part of our targets, which scale up/down a given DBI with similar column correlations.
Limitations.
Touchstone aims to support the most common workloads in real world applications.
Below we list the scenarios that we cannot support currently.
(1) Touchstone does not support filters on key columns.
Primary and foreign keys are identifiers of tuples and generally have no physical meaning, so the filters which are representations of business logics usually do not involve key columns.
(2) Equality constraints over filters involving multiple columns are not supported in Touchstone.
The equality predicate with multiple columns for filter is a very strict constraint, and has not been found in workloads of standard benchmarks.
(3) Equi-joins on columns with no reference constraint are not supported in our work.
This is because the equi-join is usually applied on the pair of primary and foreign keys in practical workloads, which is also the assumption of many works [5,24,25].
(4) Touchstone does not support the database schema with cyclic reference relationship.
In our data generation process, generating foreign keys requires the join information tables of corresponding referenced primary keys, so the primary-foreign-key dependencies must form a direct acyclic graph (DAG), which is also the precondition of DCGen [5].
Privacy issue.
Our work can help to protect privacy to some extend by removing query parameter values or using approximate query intermediate cardinalities.
However, if the database statistics and workload characteristics are strictly related to privacy issues in some cases, it will not be a good way to use this kind of workloadaware data generators for performance testing.In this paper we introduce Touchstone [2], a queryaware data generator with characteristics of completely parallelizable and bounded usage to memory.
And Touchstone is linearly scalable to computing resource and data scale.
Our future work is to support more operators, e.g., intersect and having, for covering the complex queries of TPC-DS, which has not be well supported by any existing query-aware data generation work.
