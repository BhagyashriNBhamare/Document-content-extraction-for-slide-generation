Secure processors enable new sets of applications such as commercial grid computing, software copy-protection, and secure mobile agents by providing security from both physical and software attacks.
This paper proposes new hardware mechanisms for memory integrity verification and encryption, which are two key primitives required in single-chip secure processors.
The integrity verification mechanism offers significant performance advantages over existing ones when the checks are infrequent as in grid computing applications.
The encryption mechanism improves the performance in all cases.
Many emerging applications require physical security as well as conventional security against software attacks.
For example, in Digital Rights Management (DRM), the owner of a computer system is motivated to break the system security to make illegal copies of protected digital content.
Similarly, mobile agent applications [5] require that sensitive electronic transactions be performed on untrusted hosts.
The hosts may be under the control of an adversary who is financially motivated to break the system and alter the behavior of a mobile agent.
Therefore, physical security is essential for enabling many applications in the Internet era.Conventional approaches to build physically secure systems [20,22] are based on building processing systems containing processor and memory elements in a private and tamper-proof environment that is typically implemented using active intrusion detectors.
Providing high-grade tamperresistance can be quite expensive [1].
Moreover, the applications of these systems are limited to performing a small number of security critical operations because system computation power is limited by the components that can be enclosed in a small tamper-proof package.
In addition, these processors are not flexible, e.g., their memory or I/O subsystems cannot be upgraded easily.Just requiring tamper-resistance for a single processor chip would significantly enhance the amount of secure computing power, making possible applications with heavier computation requirements.
Secure processors have been recently proposed [12,21], where only a single processor chip is trusted and the operations of all other components including off-chip memory are verified by the processor.To enable single-chip secure processors, two main primitives, which prevent an attacker from tampering with the off-chip untrusted memory, have to be developed: memory integrity verification and encryption.
Integrity verification checks if an adversary changes a running program's state.
If any corruption is detected, then the processor aborts the tasks that were tampered with to avoid producing incorrect results.
Encryption ensures the privacy of data stored in the off-chip memory.
To be worthwhile, the verification and encryption schemes must not impose too great a performance penalty on the computation.Given off-chip memory integrity verification, secure processors can provide tamper-evident (TE) environments where software processes can run in an authenticated environment, such that any physical tampering or software tampering by an adversary is guaranteed to be detected.
TE environments enable applications such as certified execution and commercial grid computing, where computation power can be sold with the guarantee of a compute environment that processes data correctly.
The performance overhead of the TE processing largely depends on the performance of the integrity verification [21].
With both integrity verification and encryption, secure processors can provide private and authenticated tamperresistant (PTR) environments where, additionally, an adversary is unable to obtain any information about software and data within the environment by tampering with, or otherwise observing, system operation.
PTR environments can enable Trusted Third Party computation, secure mobile agents, and Digital Rights Management (DRM) applications.In this paper, we describe new hardware schemes to effi-ciently verify and encrypt all or a part of untrusted external memory.
Our integrity verification scheme maintains incremental multiset hashes of all memory reads and writes at run-time, and verifies a sequence of memory operations at a chosen later point of time.
Our encryption scheme uses onetime-pad encryption and time stamps, and overlaps the decryption computation from the corresponding data access.
This enables a processor to overlap decryption computation with data access and hide most of the decryption latency.
We evaluate our new schemes, viewing them as hardware mechanisms in a microprocessor.
We compare them to the most efficient existing schemes, namely, hash tree integrity checking and direct block encryption.
Simulations show that our integrity verification scheme outperforms the hash tree scheme when the checks are infrequent, e.g., less than once a million memory accesses.
For example, a processor only needs to check the integrity of previous memory operations at the end of an execution for a certified execution application in commercial grid computing.
In these cases, the performance overhead of our scheme is less than 5% in most cases and 15% in the worst case.
On the other hand, the hash tree scheme has less than 25% overhead for many cases, but may cause more than 50% degradation when onchip caches are small.
Therefore, our integrity verification scheme significantly reduces the performance overhead of TE processing.
Our new scheme has the added benefit of reducing memory space overhead from 33% for a typical hash-tree scheme to 6.25%.
Simulations also demonstrate that the one-time-pad encryption scheme outperforms the existing direct block encryption in all cases.
The one-time-pad scheme incurs about 8% performance overhead on average, and 18% in the worst case.
The direct encryption incurs about 13% performance degradation on average, and 25% in the worst case.The assumed model and how integrity verification and encryption are used in secure processors is presented in Section 2.
The hash-tree mechanism for memory verification and our new scheme are described in Section 3.
The conventional encryption mechanism and our new mechanism based on a one-time-pad and time stamps are discussed in Section 4.
Section 5 discusses implementation issues.
In section 6 we evaluate the schemes on a superscalar processor simulator.
We discuss related work in Section 7 and conclude the paper in Section 8.
We consider systems that are built around a single processor with external memory and peripherals.
We do not consider multiprocessor systems in this paper.
Figure 1 illustrates the model.
The processor, implemented on a monolithic integrated circuit (IC), is assumed to be trusted and protected from physical attacks; its internal state cannot be tampered with or observed directly by Figure 1.
Our secure computing model.
physical means.
The processor can contain secret information that identifies it and allows it to communicate securely with the outside world.
This information could be a Physical Random Function [8], or the secret part of a public key pair protected by a tamper-sensing environment [20].
The trusted computing base (TCB) consists of the processor chip and optionally 1 some core parts of the operating system that plays the part of the Nexus in Palladium [4] or the security kernel in AEGIS [21].
The processor is used in a multitasking environment, which uses virtual memory, and runs mutually mistrusting processes.
External memory and peripherals are assumed to be untrusted; they may be observed and tampered with at will by an adversary.The system provides programs with two secure execution environments: tamper evident (TE) and private tamper resistant (PTR).
In the TE environment, the integrity of a program's execution is guaranteed.
The PTR environment ensures the privacy of instructions and data in addition to integrity.
Once a program has entered a secure execution environment using a special instruction, the TCB protects it and provides it with an additional instruction to sign messages with the processor's private key.
The resulting signature is used to prove to a user that he is seeing the results of a correct execution of his program.Since the adversary can attack off-chip memory, the processor needs to check that it behaves like valid memory.
Memory behaves like valid memory if the value the processor loads from a particular address is the most recent value that it has stored to that address.
We therefore require memory integrity verification.
The TCB needs to ensure the integrity of memory accesses before it performs a signing operation or stores data into non-private memory space.For PTR environments, we additionally have to encrypt data values stored in off-chip memory.
The encryption and decryption of data values can be done by a hardware en-1 In some models, the operating system may be entirely untrusted.gine placed between the integrity checker and the off-chip memory bus, as in AEGIS.We assume that programs are well-written and do not leak secrets via memory access patterns.
We do not handle security issues caused by bugs in an application program.
This section presents a new memory integrity verification scheme, which has a significant performance advantage over existing methods.
We first briefly summarize existing hash-tree schemes, and then introduce the new scheme.For memory integrity verification, a simple solution based on message authentication codes (MACs) does not work.
XOM [12] uses a MAC of the data and address for each memory block for authentication.
Unfortunately, this approach does not prevent replay attacks; valid MACs guarantee that a block is stored by the processor, but do not guarantee that it is the most recent copy.
Therefore, we exclude the simple MAC scheme.In our description of algorithms, we use a term chunk as the minimum memory block that is verified by integrity checking.
If a word within a chunk is accessed by a processor, the entire chunk is brought into the processor and its integrity is checked.
In the simplest instantiation, a chunk can be an L2 cache block.
Hash trees (or Merkle trees) are often used to verify the integrity of dynamic data in untrusted storage [14].
Figure 2 illustrates a binary hash tree.
Data (V 1 , V 2 , etc) is located at the leaves of a tree.
Each internal node contains the hash of the concatenation of its children.
The root of the tree is stored in secure memory where it cannot be tampered with.A chunk consists of children of one node that are covered by the same hash.
In the figure, one chunk contains two hashes or the same amount of data.
For simplicity, we make the chunks the same as the L2 cache blocks.
As a result, a tree with higher arity requires larger L2 blocks.To check the integrity of a node in the tree, the processor (i) reads the node and its siblings from the memory, (ii) concatenates their data together, (iii) computes the hash of the concatenated data, and (iv) checks that the resultant hash matches the hash in the parent.
The steps are repeated all the way to the root of the tree.To update a node, the processor checks its integrity as described in the previous paragraph while it (i) modifies the node, and (ii) recomputes and updates the parent to be the hash of the concatenation of the node and its siblings.
These steps are repeated to update the whole path from the node to the root, including the root.With a balanced m-ary tree, the number of chunks to check on each memory access is log m (N ), where N is the number of chunks in the verified memory space.
The logarithmic overhead of the hash tree can be significant.
For example, [9] showed that applying the hash tree to a processor can slow down the system by as much as factor of ten.
The experiments used 4-GB memory and 128 bit hashes.
The performance overhead of using a hash tree can be dramatically reduced by caching the internal hash chunks on-chip with regular data.
The processor trusts data stored in the cache, and can access them directly without any checking.
Therefore, instead of checking the entire path from the chunk to the root of the tree, the processor checks the path from the chunk to the first hash it finds in the cache.
This hash is trusted and the processor can stop checking.
When a chunk is evicted from the cache, the processor brings its parent into the cache (if it is not already there), and updates the parent in the cache.
We refer to this optimized hash tree scheme as CHTree.Previous work [9] showed that, in all cases, CHTree clearly outperforms the basic hash trees where only regular data is stored in the cache.
In this paper, we use CHTree for comparison.
See [9] for more details and variants.
CHTree checks the integrity of memory after every memory access.
However, checking after each access implies unnecessary overhead when we are only interested in the integrity of a sequence of memory operations.We introduce a new approach of verifying memory integrity with low run-time overhead.
Intuitively, the processor maintains a read log and a write log of all of its operations to off-chip memory.
At runtime, the processor updates logs with minimal overhead so that it can verify the integrity of a sequence of operations at a later time.
To maintain the logs in a small fixed amount of trusted on-chip storage, the processor uses incremental multiset hash functions [6].
When the processor needs to check its operations, it performs a separate integrity-check operation using the logs.Since the multiset hash functions are used to maintain logs, we refer to our scheme as a log-hash scheme.
The particular function we use is MSet-Add-Hash based on the hash function MD5 [17].
MSet-Add-Hash requires one MD5 operation using a secret key in the processor, and one addition operation over a fixed number of bits to update the multiset hash incrementally.
The details and formal proofs of the security of MSet-Add-Hash and the loghash memory integrity checking scheme are in [6].
In this paper, we extend the scheme to work with trusted caches and on-demand memory allocation, give a brief overview of why it works, and evaluate the scheme's performance.
Figure 3 shows the steps of the Log Hash (LHash) integrity checking scheme.
We describe the operations assuming that the chunk is the same as an L2 cache block and the cache is write-allocate.
The processor keeps two multiset hashes (READHASH and WRITEHASH) and a counter (TIMER) in trusted on-chip storage.
We denote the (READHASH, WRITEHASH, TIMER) triple by T .
To initialize T , add-chunk is called on each of the chunks that need to have their integrity verified.
This operation effectively remembers the initial value of the chunks in WRITEHASH.
At runtime, the processor calls read-chunk and writechunk to properly update the logs.
When a chunk gets evicted or invalidated from the cache, the processor logs the chunk's value by calling write-chunk.
WRITEHASH is updated with the hash of the corresponding address-chunktime stamp triple.
If the chunk is dirty, the chunk and the time stamp are written back to memory; if the chunk is clean, only the time stamp is written back to memory.The processor calls read-chunk to bring a chunk into the cache.
READHASH is updated with the hash of the addresschunk-time stamp triple that is read from the off-chip memory.
TIMER is then increased to be strictly greater than the time stamp that was read from memory.In order to check memory, all chunks that are not in the cache are read so that each chunk has been added to READHASH and WRITEHASH the same number of times.
If READHASH is equal to WRITEHASH, then the memory was behaving correctly (like valid memory, cf. Section 2) during the sequence of memory operations since the last integrity checking operation.
This checking is done in the integrity-check operation in Figure 3.
The WRITEHASH logs information on the chunks that, according to the processor, should be in memory at any given point in time.
The READHASH logs information on the chunks the processor reads from memory.
Because the checker checks that WRITEHASH is equal to READHASH, substitution (the RAM returns a value that was never written to it) and replay (the RAM returns a stale value instead of Initialization Operation add-chunk(T , Address, Chunk):1.
TimeStamp = T .
TIMER.Update T .
WRITEHASH with the hash of (Address·Chunk·TimeStamp).2.
Write (Chunk, TimeStamp) to address, Address, in memory.
• For a cache eviction or an invalidation write-chunk(T , Address, Chunk):1.
TimeStamp = T .
TIMER.Update T .
WRITEHASH with the hash of (Address·Chunk·TimeStamp).2.
If a block is dirty, write (Chunk, TimeStamp) back to memory.
If the block is clean, only write TimeStamp back to memory (we do not need to write Chunk back to memory).
• For a cache miss, do read-chunk(T , Address):1.
Read the (Chunk, TimeStamp) pair from Address in memory.2.
Update T .
READHASH with the hash of (Address·Chunk·TimeStamp).3.
Increase T .
TIMER:T .
TIMER = max(T .
TIMER, TimeStamp+1)and store Chunk in the cache.
integrity-check(T ):1.
NewT = (0, 0, 0).2.
For each chunk address covered by T , check if the chunk is in the cache.
If it is not in the cache, (a) read-chunk(T , address).
(b) add-chunk(NewT , address, chunk), where chunk is the chunk read from memory in Step 2a.3.
Compare READHASH and WRITEHASH.
If different, there is a read that does not match its most recent write, therefore raise an integrity exception.
the one that is most recently written) attacks are prevented.
The purpose of the time stamps is to prevent reordering attacks in which RAM returns a value that has not been written yet so that it can subsequently return stale data.
The processor performs an integrity-check operation when a program needs to check a sequence of operations, or when TIMER is near its maximum value.
Unless the check is at the end of a program's execution, the processor will need to continue memory verification after an integritycheck operation.
To do this, the processor initializes a new WRITEHASH while it reads memory during an integritycheck.
If the integrity check passes, WRITEHASH is set to the new WRITEHASH, and READHASH and TIMER are reset.
The program can then continue execution as before.In the case where we do not know at initialization how much memory the processor will use, new addresses can be added to the protected region by calling add-chunk on them on demand and using a table to maintain the list of chunks that have been touched.
For example, the processor can use the program's page table to keep track of which pages it used during the program's execution.
When there is a new page allocated, the processor calls add-chunk for all chunks in the page.
When the processor performs an integrity-check operation, it walks through the page table in an incremental way and reads all chunks in a valid page.In this scheme, the page table does not need to be trusted.
If an adversary changes the page table so that the processor initializes the same chunk multiple times or skips some chunks during the check operation, the integrity check will fail in that READHASH will not be equal to WRITEHASH (as long as each chunk is read only once during the check).
Encryption of off-chip memory is essential for providing privacy to programs.
Without encryption, physical attackers can simply read confidential information from off-chip memory.
On the other hand, encrypting off-chip memory directly impacts the memory latency because encrypted data can be used only after decryption is done.
This section discusses issues with conventional encryption mechanisms and proposes a new mechanism that can hide the encryption latency by decoupling computations for decryption from offchip data accesses.We encrypt and decrypt off-chip memory on an L2 cache block granularity using a symmetric key encryption algorithm since memory accesses are carried out for each cache block.
Encrypting multiple blocks together will require accessing all the blocks for decrypting any one of them.
The Advanced Encryption Standard (AES) [16] is a symmetric-key encryption algorithm approved by the National Institute of Standards and Technology (NIST).
We use AES as a representative algorithm.AES can process data blocks of 128 bits using cipher keys with lengths of 128, 192, and 256 bits.
The encryption and decryption consist of 10 to 16 rounds of four transformations.
The critical path of one round consists of one S-box look-up, two shifts, 6-7 XOR operations, and one 2-to-1 MUX.
This critical path will take 2-4 ns with 0.13µ technology depending on the implementation of the S-box look-up table.
Therefore, encrypting or decrypting one 128-bit data block will take about 20-64 ns depending on the implementation and the key length.
Thus, decryption can add significantly to memory latency.When the difference in technology is considered, this latency is in good agreement with a custom ASIC implementation of Rijndael in 0.18µ technology [11,19], which reported that the critical path of encryption is 6 ns and the critical path of key expansion is 10 ns per round with 1.89 ns latency for the S-box.
Their key expansion is identical to two rounds of the AES key expansion because they support 256-bit data blocks.
Therefore, the AES implementation will take 5 ns per round for key expansion, which results in a 6 ns cycle per round, for a total of 60-96 ns, depending on the number of rounds.
Cache Block (B) AES B[1] AES AES AES B[2] B[3] B[4] IV = (0...0,Addr,RV) Encryption Key EB[1] EB[2] EB[3] EB[4] EB RV 񮽙 In Memory AES -1 AES -1 AES -1 AES -1 Key B[1] B[2] B[3] B[4] B Decryption IV[i] = AES K (B[i] ⊕ EB[i-1]), where EB[0]is an initial vector IV.
IV consists of the address of the block and a random vector RV, and is padded with zeros to be 128 bits.
This prevents adversaries from comparing whether two cache blocks are the same or not.
After the encryption, the random vector RV is stored in the off-chip memory along with the encrypted data (EB).
To hide decryption latency, we propose a scheme that decouples the AES computation from the corresponding data access by using one-time pads [1] and time stamps.
Figure 5.
Encryption mechanism that uses one-time-pads from AES with time stamps.
• For an L2 cache write-back write-back-block(Address, B):1.
Increment TIMER.
TS = TIMER.
2.
For each 1 ≤ i ≤ 4 (a) OTP[i] = AES −1 K (V, Address, TS, i).
(b) EB[i] = B[i] ⊕ OTP[i].3.
Write TS and EB to memory.
• For an L2 cache miss read-block(Address):1.
Read the time stamp (TS) from memory.
To encrypt and write a dirty cache block to memory 2 , the TIMER is incremented, and the block is encrypted by XOR'ing each 128-bit chunk B [i] with an encryption pad OTP [i].
The pad is computed using the AES decryption on (V, Address, TS, i) with a secret key K. V is a fixed bit vector that makes the input 128 bits, and can be randomly selected by the processor at the start of program execution.
TS is a time stamp that is the current value of TIMER.
Finally, the encrypted block and the time stamp are stored in off-chip memory.
Note that the counter TIMER should be separate from the one for the LHash scheme as they are increased at different rates.To read an encrypted block from memory, the proces-sor first reads the corresponding time stamp from memory.
To improve performance, it is also possible to cache time stamps on-chip.
Once the time stamp is retrieved, we immediately start with the generation of the OTP using AES.
The pad is generated while EB is fetched from memory.
Once the pad has been generated and EB has been retrieved from memory, EB is decrypted by XOR'ing with the pad.
When the TIMER reaches its maximum value, the processor changes the secret key and re-encrypts blocks in the memory.
The re-encryption is very infrequent given an appropriate size for the time stamp (32 bits for example), and given that the timer is only incremented when dirty cache blocks are evicted from the cache.
We do not need to increment TS during re-encryption, because Address is included as an argument to AES −1 K , thus guaranteeing the unicity of the one-time-pads.
The conventional one-time-pad scheme is proven to be secure [1].
Our scheme is an instantiation of a counter-mode encryption scheme, and can easily be proven to be secure, given a good encryption algorithm that is non-malleable [13].
The direct encryption scheme serves our purpose in terms of security, however, it has a major disadvantage for performance.
In Figure 7 (a), the AES decryption is performed immediately after each 128-bit chunk is read.
Therefore, if the AES decryption takes 40ns, we will get the decrypted result for the last chunk 40ns after the last chunk is read.
The decryption latency is directly added to the memory latency and delays the processing.
We assume that the latency of any L2 miss is determined by the decryption of last 128-bit chunk (EB [4]).
The latency may be slightly reduced for accesses to the first chunk if each 128-bit chunk is returned separately.
However, this requires more complicated miss handling.
In the new scheme, after the time stamp is read, we perform AES computation to generate encryption pads as shown in Figure 7 (b).
This computation is overlapped with the following bus accesses for the encrypted cache block.
After the last chunk is read, most of the AES computation is done and a processor only needs to perform an XOR to obtain the entire decrypted block.
For example, if it takes 80 ns for reading the time stamp, and an additional 40 ns for the cache block, we can hide 40 ns of the AES latency.When overlapping the AES computation with data bus accesses is not sufficient to hide the entire latency, the time stamp can be cached on-chip or speculated based on recent accesses.
In these cases, the AES computation can start as soon as the memory access is requested as in Figure 7 (c), and completely overlapped with the long memory accesses.The ability to hide the encryption latency improves processor performance.
Further, it allows to use a cheaper implementation of the AES algorithm with longer latency.
This section discusses some practical issues in implementing integrity verification and encryption on real systems.
The discussion pertains to both existing and new schemes.
To implement the memory checking and the encryption schemes, the layout of meta-data such as time-stamps and hashes should be determined.
The layout should be simple enough for hardware to easily compute the address of the corresponding meta-data from the address of a data chunk.
We give an example layout for the LHash scheme where we use the beginning of the memory space for data and the end of the space for time stamps.Time stamps are laid out linearly at the end of the memory space starting at T S Base .
Therefore, the address of a time stamp can be computed byT imeStampAddr = T S Base + Addr B Chunk × B T S .
B Chunk is the chunk size, and B T S is the time-stamp size.For the encryption scheme, we use the same linear layout with a different base address to determine the address of time stamps or random initial vectors.
When the operating system cannot be trusted, the secure processor must verify the virtual memory space rather than physical memory space 3 .
The algorithms simply use virtual addresses in computing hashes or AES.
The only non-trivial problem is determining the physical address of meta-data.
In our solution, an L2 cache block contains its virtual address and the owner process' ID.
Note that the cache does not have to be virtually-addressed.
On a cache eviction, the processor uses the mapping described in Section 5.1 and computes the virtual address of the corresponding metadata.
Finally, the processor converts this virtual address to the physical address.
For this we use a TLB; in practice, we should not use the processor core's standard TLB and should use a second TLB to avoid increasing the latency of the standard TLB.
The second TLB is also tagged with process identifier bits which are combined with virtual addresses to translate to physical addresses.Though having virtual address information and secure process IDs appears to be expensive, they are required also for on-chip protection in secure processors without a security kernel [21].
Our method does not require actual physical space for time stamps of unused virtual memory space.
Physical memory for time stamps can be allocated on demand.
Our integrity verification and encryption schemes allow only the primary processor to access off-chip memory.
For untrusted I/O such as Direct Memory Access (DMA), a part of memory is set aside as an unprotected and unencrypted area.
When the transfer is done into this area, a trusted application or OS copies the data into protected space, and checks/decrypts it using a scheme of its choosing.
This section evaluates our integrity verification and encryption schemes compared to the existing schemes through analysis and detailed simulations.
Our simulation framework is based on the SimpleScalar tool set [3].
The simulator models speculative out-of-order processors with separate address and data buses.
All structures that access the main memory including an L2 cache, the integrity checking unit, and the encryption unit share the same bus.
The architectural parameters used in the simulations are shown in Table 1.
SimpleScalar is configured to execute Alpha binaries, and all benchmarks are compiled on EV6 (21264) for peak performance.
We used a small buffer for time stamps to exploit spatial locality because time stamps are only 4 B while the memory bus is 8-B wide.For all the experiments in this section, nine SPEC2000 CPU benchmarks [10] putation, each benchmark is simulated for 100 million instructions after skipping the first 1.5 billion instructions.
Figure 8 shows the baseline characteristics of these benchmarks.
Benchmarks mcf, applu, and swim show poor L2 cache performance, and heavily utilize the off-chip memory bandwidth (bandwidth-sensitive).
The other benchmarks are sensitive to cache sizes, and do not require high off-chip bandwidth (cache-sensitive).
We use the term "baseline" to refer to a standard processor without integrity verification or encryption.
In the following discussions, we evaluate the overhead of security mechanisms compared to the baseline system with the same configurations.
We note that these overheads are optimistic because additional hardware costs for the security mechanisms can potentially be used to improve the baseline.Unfortunately, our simulation framework does not allow us to simulate slightly larger caches that incorporate a few hundred thousand bits of extra space in lieu of the additional gates required for integrity verification and encryption.
However, Figure 8 suggests that our estimation is not overly optimistic.
Even if we consider the baseline with L2 caches that are twice as large, it only improves the baseline performance by 22% on the average.
Therefore, we can consider the pessimistic overhead of the schemes to be at most 22% larger than the optimistic overhead.
We also note that our overhead estimation does not affect the comparisons between the new schemes and the old schemes since they have comparable hardware costs.
This subsection evaluates the log hash integrity checking scheme LHash and compares it to the hash tree scheme CHTree.
For all integrity checking schemes, we used chunks that are the same as L2 cache blocks.
Integrity checking schemes need memory space for hashes or time stamps in addition to the data they verify.
The additional memory space compared to data chunks is approximately 1/(m CHT ree −1) for CHTree with a m CHT ree -ary hash tree and B T S /B Chunk for LHash.
For typical values (m CHT ree = 4, B T S = 4 Bytes, B Chunk = 64 Bytes), the overheads are 33% for CHTree and 6.25% for LHash, respectively.
Therefore, LHash requires significantly less memory space compared to CHTree.
Note that increasing the arity of the hash tree for less space overhead is usually not viable; it implies larger L2 blocks, which often degrades the baseline performance without integrity verification.The major logic component to implement the schemes is a hash (MAC) computation unit.
To evaluate the cost of computing hashes, we considered the MD5 [17] and SHA-1 [7] hashing algorithms.
The core of each algorithm is an operation that takes a 512-bit block, and produces a 128-bit or 160-bit (for SHA-1) digest.
In each case, simple 32-bit operations are performed over 80 rounds, which requires on the order of 625 1-bit gates per round.
The logic overhead depends on how many rounds need to be implemented in parallel to meet the required throughput.For CHTree, the hash of B Chunk (typically 64 Bytes) needs to be computed for each memory read/write.
For LHash, two hashes of B Address + B Chunk + B T S (typically 72 Bytes) for each memory read.
Therefore, LHash would require about 2-3 times more hash throughput and would have about 2-3 times more logic overhead compared to CHTree.
For a memory throughput of 1.6GB/s, the circuit size will be around 5,000 1-bit gates for CHTree and 10,000 to 15,000 1-bit gates for LHash.
We first investigate the performance of the LHash scheme ignoring the overhead of the integrity-check operation.
For applications with very infrequent integrity checks such as certified execution, the overhead of the integrity-check operation is negligible and the results in this section represent the overall performance.
The effect of frequent integrity checking is studied in the following subsection.
Figure 9 illustrates the impact of integrity checking on the run-time program performance.
For four different L2 cache configurations, the normalized IPCs (instructions per clock cycle) of cached hash trees (CHTree) and log-hashes (LHash) are shown.
The IPCs are normalized to the baseline performance with the same configuration.The results clearly show the advantage of the log-hash scheme (LHash) over the conventional hash tree scheme when we can ignore the integrity-check overhead.
For all cases we simulated, LHash outperforms CHTree.
The performance overhead of the LHash scheme is often less than 5% and less than 15% even for the worst case.
On the other hand, the cached hash tree CHTree has as much as 50% overhead in the worst case and 20-30% in general.The figure also demonstrates the general effects of cache configuration on the memory integrity verification performance.
The overhead of integrity checking decreases as we increase either cache size or cache block size.
Larger caches result in less memory accesses to verify and less cache contention between data and hashes.
Larger cache blocks reduce the space and bandwidth overhead of integrity checking by increasing the chunk size.
However, we note that increasing the cache block size beyond an optimal point degrades the baseline performance.Integrity checking impacts the run-time performance in two ways: cache pollution and bandwidth consumption.
Table 2.
L2 miss-rates of program data for integrity verification schemes.
Table 2 illustrates the effects of integrity checking on cache miss-rates.
Since LHash does not store hashes in the cache, it does not affect the L2 miss-rate.
However, CHTree can significantly increase miss-rates for small caches since it stores its hash nodes in the L2 cache with program data.
In fact, the performance degradation of the CHTree scheme for cache-sensitive benchmarks such as gzip, twolf, vortex, and vpr in the 256-KB case (Figure 9) is mainly due to cache pollution.
As you increase the cache size, cache pollution becomes negligible as you can cache both data and hashes without contention.
In our processor implementation, however, it consumed more (8.5% to 20%) because our bus width is 8B while the time stamps are only 4B.
CHTree consumes additional bandwidth for hashes, which can be significant depending on the L2 cache performance.
For bandwidth-sensitive benchmarks, the bandwidth overhead directly translates into the performance overhead.
This makes log-hash schemes much more attractive even for processors with large caches where cache pollution is not an issue.
The last subsection clearly demonstrated that the LHash scheme outperforms the hash tree scheme when integritycheck operations are ignored.
In this subsection, we study the integrity checking schemes including the overhead of periodic integrity-check operations.Let us assume that the log-hash schemes check memory integrity every T memory accesses.
A processor executes a program until it makes T main memory accesses, then checks the integrity of the T accesses by performing an integrity-check operation.
Obviously, the overhead of the checking heavily depends on the characteristics of the program as well as the check period T .
We use two representative benchmarks swim and twolf -the first consumes the largest amount of memory and the second consumes the smallest.
swim uses 192MB of main memory and twolf uses only 2MB of memory.
A processor only verifies the memory space used by a program.
Figure 11 compares the performance of the memory integrity checking schemes for varying check periods.
The performance of the conventional CHTree scheme is indifferent to the checking period since it has no choice but to check the integrity after each access.On the other hand, the performance of the log-hash scheme (LHash) heavily depends on the checking period.
The LHash scheme is infeasible when the application needs to assure memory integrity after a small number of memory accesses.
In this case, CHTree should be used.The performance of LHash converges to the run-time performance for a long period such as hundreds of millions to billions of accesses.
In certified execution, commercial grid computing, secure mobile agents, and Trusted Third Party, the execution only needs to be verified at the end.
For these applications, LHash is better for any program with more than a billion accesses.
All SPEC benchmarks and most programs fall into this category, and the performance improvement is given by Figure 9.
Both direct block encryption and one-time-pad encryption use the same size random initial vectors and time stamps.
Therefore, the memory space overhead will be the same for both schemes.
For typical 4-B random vectors and time stamps with 64-B cache block, the overhead is 6.25%.
The main area overhead of the encryption schemes is the logic required by the AES algorithm.
Given the gate counts of the AES implementation of [19], a 128-bit AES encryption without pipelining costs approximately 75,000 gates.
For 1.6GB/s throughput, the module needs to be duplicated four times, which corresponds to the order of 300,000 gates.
Using a simpler encryption algorithm such as RC5 [18] can substantially decrease the gate count, at the cost of de-creased security.
Both direct encryption and one-time-pad encryption will have the same logic overhead because they require the same encryption throughput.
In the experiments, we simulated the case when all instructions and data are encrypted in the memory.
Both encryption mechanisms degrade the processor performance by consuming additional memory bandwidth for either time stamps or random vectors, and by delaying the data delivery for decryption.
As shown in the figure, the memory encryption for these configurations results in up to 18% performance degradation for the one-time-pad encryption, and 25% degradation for the direct encryption.
On average, the one-time-pad scheme reduces the overhead of the direct encryption by 43%.
Our scheme is particularly effective when the decryption latency is the major concern.
For applications with low bandwidth usage such as gcc, gzip, twolf, vortex, and vpr, the performance degradation mainly comes from the decryption latency, and our scheme reduces the overhead of the conventional scheme by more than one half.
As noted in Section 4, the one-time-pad encryption mechanism requires re-encrypting the memory when the global time stamp reaches its maximum value.
Because the reencryption operation is rather expensive, the time stamp should be large enough to either amortize the re-encryption overhead or avoid re-encryption.
Fortunately, the simulation results for the SPEC benchmarks show that even 32-bit time stamps are large enough.
In our experiments, the processor writes back to memory every 4800 cycles when averaged over all the benchmarks, and 131 cycles in the worst case of swim.
Given the maximum time stamp size of 4 billion, this indicates reencryption is required every 5.35 hours (in our 1 GHz processor) on average, and every 35 minutes for swim.
For our benchmarks, the re-encryption takes less than 300 million cycles even for swim, which has the largest working set.
Therefore, the re-encryption overhead is negligible in practice.
If 32-bit time stamps are not large enough, the re-encryption period can be increased by having larger time stamps or per-page time stamps.
Finally, we study the performance of PTR processing by simulating integrity verification and encryption together.
Previous work [21] has shown that these two mechanisms are the primary concerns for the performance of PTR processing.
We compare the performance using our new schemes with the performance using CHTree and direct block encryption.
In the new schemes, two separate time stamps are used for integrity verification and encryption.
Figure 13 demonstrates that our new schemes significantly improve the performance of PTR processing over the existing schemes.
With existing schemes, PTR processing incurs up to 60% performance degradation in the worst case (mcf), and around 40% overhead in most cases.
With LHash and one-time-pad encryption, PTR processing can be done with 23% overhead even in the worst case, and less than 15% in most cases.
Blum et al. [2] addressed the problem of securing various data structures in untrusted memory.
They proposed using a hash tree rooted in trusted memory to check the integrity of arbitrarily large untrusted RAM.
Their approach has a O(log(N )) cost for each memory access.
[9] shows how caching of internal nodes of the tree can significantly improve the performance of the scheme.
The log hash scheme we introduce can perform better than a hash-tree based scheme because it checks sequences of memory operations, rather than checking each operation.
Blum et al. [2] also proposed an offline checker to check the correctness of RAM after a sequence of operations have been performed on RAM.
Their scheme computes a running hash of memory reads and writes.
We have used their offline checker as a basis for designing our log hash checker, though there are key differences between the two checkers.
Their checker's implementation uses -biased hash functions [15]; these hash functions can be used to detect random errors, but are not cryptographically secure.
For our log hash checker, we have used incremental multiset hashes [6], which are cryptographically secure.
Furthermore, our log hash checker can use smaller time stamps without increasing the frequency of checks, which leads to better performance.Previous designs of secure processors [12,21] directly use encryption algorithms such as DES, Triple DES, and AES to encrypt and decrypt memory; this can appreciably increase memory access latency for reads.
We have used one-time pads to hide virtually all the decryption latency.
Memory integrity verification and encryption are key primitives required to implement secure computing systems with trusted processors and untrusted memory.
They are also responsible for almost all of the performance overhead of tamper-evident and private tamper-resistant processing.
We have presented a new memory verification scheme based on maintaining an incremental hash of logs of memory operations, and a new encryption scheme based on one-time-pads and time stamps.
The new integrity verification scheme offers significant performance improvement for applications with infrequent memory checks, while the encryption scheme is good for any application.
With the reduced overhead, the new schemes make secure processors usable over a wider range of applications.
