We propose a new framework for N-best reranking on sparse feature sets.
The idea is to reformulate the reranking problem as a Multitask Learning problem, where each N-best list corresponds to a distinct task.
This is motivated by the observation that N-best lists often show significant differences in feature distributions.
Training a single reranker directly on this heteroge-nous data can be difficult.
Our proposed meta-algorithm solves this challenge by using multitask learning (such as ℓ 1 /ℓ 2 regularization) to discover common feature representations across N-best lists.
This meta-algorithm is simple to implement, and its modular approach allows one to plug-in different learning algorithms from existing literature.
As a proof of concept, we show statistically significant improvements on a machine translation system involving millions of features.
Many natural language processing applications, such as machine translation (MT), parsing, and language modeling, benefit from the N-best reranking framework ( Shen et al., 2004;Collins and Koo, 2005;Roark et al., 2007).
The advantage of N-best reranking is that it abstracts away the complexities of first-pass decoding, allowing the researcher to try new features and learning algorithms with fast experimental turnover.In the N-best reranking scenario, the training data consists of sets of hypotheses (i.e. N-best lists) generated by a first-pass system, along with their labels.
Given a new N-best list, the goal is to rerank it such that the best hypothesis appears near the top of the list.
Existing research have focused on training a single reranker directly on the entire data.
This approach is reasonable if the data is homogenous, but it fails when features vary significantly across different N-best lists.
In particular, when one employs sparse feature sets, one seldom finds features that are simultaneously active on multiple N-best lists.In this case, we believe it is more advantageous to view the N-best reranking problem as a multitask learning problem, where each N-best list corresponds to a distinct task.
Multitask learning, a subfield of machine learning, focuses on how to effectively train on a set of different but related datasets (tasks).
Our heterogenous N-best list data fits nicely with this assumption.The contribution of this work is three-fold:1.
We introduce the idea of viewing N-best reranking as a multitask learning problem.
This view is particularly apt to any general reranking problem with sparse feature sets.2.
We propose a simple meta-algorithm that first discovers common feature representations across N-bests (via multitask learning) before training a conventional reranker.
Thus it is easily applicable to existing systems.3.
We demonstrate that our proposed method outperforms the conventional reranking approach on a English-Japanese biomedical machine translation task involving millions of features.The paper is organized as follows: Section 2 describes the feature sparsity problem and Section 3 presents our multitask solution.
The effectiveness of our proposed approach is validated by experiments demonstrated in Section 4.
Finally, Sections 5 and 6 discuss related work and conclusions.
For concreteness, we will describe N-best reranking in terms of machine translation (MT), though our approach is agnostic to the application.
In MT reranking, the goal is to translate a foreign language sentence f into an English sentence e by picking from a set of likely translations.
A standard approach is to use a linear model:ˆ e = arg max e∈N (f ) w T · h(e, f )(1)where h(e, f ) is a D-dimensional feature vector, w is the weight vector to be trained, and N (f ) is the set of likely translations of f , i.e. the N-best list.
The feature h(e, f ) can be any quantity defined in terms of the sentence pair, such as translation model and language model probabilities.Here we are interested in situations where the feature definitions can be quite sparse.
A common methodology in reranking is to first design feature templates based on linguistic intuition and domain knowledge.
Then, numerous features are instantiated based on the training data seen.
For example, the work of ( Watanabe et al., 2007) defines feature templates based on bilingual word alignments, which lead to extraction of heavilylexicalized features of the form:h(e, f ) =        1 if foreign word "Monsieur"and English word "Mr." co-occur in e,f 0 otherwise (2) One can imagine that such features are sparse because it may only fire for input sentences that contain the word "Monsieur".
For all other input sentences, it is an useless, inactive feature.Another common feature involves word ngram templates, for example:h(e, f ) =    1 if English trigram "Mr.Smith said" occurs in e 0 otherwise (3) In this case, all possible trigrams seen in the Nbest list are extracted as features.
One can see that this kind of feature can be very sensitive to the first-pass decoder: if the decoder has loose reordering constraints, then we may extract exponentially many nonsense ngram features such as "Smith said Mr." and "said Smith Mr.".
Granted, the reranker training algorithm may learn that these nonsense ngrams are indicative of poor hypotheses, but it is unlikely that the exact same nonsense ngrams will appear given a different test sentence.In summary, the following issues compound to create extremely sparse feature sets:1.
Feature templates are heavily-lexicalized, which causes the number of features to grow unbounded as the the amount of data increases.2.
The input (f ) has high variability (e.g. large vocabulary size), so that features for different inputs are rarely shared.3.
The N-best list output also exhibits high variability (e.g. many different word reorderings).
Larger N may improve reranking performance, but may also increase feature sparsity.When the number of features is too large, even popular reranking algorithms such as SVM ( Shen et al., 2004) and MIRA ( Watanabe et al., 2007;Chiang et al., 2009) may fail.
Our goal here is to address this situation.
In the following, we first give an intuitive comparison between single vs. multiple task learning (Section 3.1), before presenting the general metaalgorithm (Section 3.2) and particular instantiations (Section 3.3).
Given a set of I input sentences {f i }, the training data for reranking consists of a set of I N-best lists {(H i , y i )} i=1,...,I , where H i are features and y i are labels.To clarify the notation: 1 for an input sentence f i , there is a N-best list N (f i ).
For a N-best list N (f i ), there are N feature vectors corresponding to the N hypotheses, each with dimension D.
The collection of feature vectors for N (f i ) is represented by H i , which can be seen as a D × N matrix.
Finally, the N -dimensional vector of labels y i indicates the translation quality of each hypothesis in N (f i ).
The purpose of the reranker training algorithm is to find good parameters from {(H i , y i )}.
The conventional method of training a single reranker (single task formulation) involves optimizing a generic objective such as:arg min w I i=1 L(w, H i , y i ) + λΩ(w)(4)where w ∈ R D is the reranker trained on all lists, and L(·) is some loss function.
Ω(w) is an optional regularizer, whose effect is traded-off by the constant λ.
For example, the SVM reranker for MT (Shen et al., 2004) defines L(·) to be some function of sentence-level BLEU score, and Ω(w) to be the large margin regularizer.
2 On the other hand, multitask learning involves solving for multiple weights, w 1 , w 2 , . . . , w I , one for each N-best list.
One class of multitask learning algorithms, Joint Regularization, solves the following objective:arg min w 1 ,.
.
,w I I i=1 L(w i , H i , y i ) + λΩ(w 1 , .
.
, w I ) (5)The loss decomposes by task but the joint regularizer Ω(w 1 , .
.
, w I ) couples together the different weight parameters.
The key is to note that multiple weights allow the algorithm to fit the heterogenous data better, compared to a single weight vector.
Yet these weights are still tied together so that some information can be shared across N-best lists (tasks).
One instantiation of Eq.
5 is ℓ 1 /ℓ 2 regularization: In MT, evaluation metrics like BLEU do not exactly decompose across sentences, so for some training algorithms this loss is an approximation.Ω(w 1 , .
.
, w I ) ||W|| 1,2 , where W = [w 1 |w 2 | . . . |w I ] T We are now ready to present our general reranking meta-algorithm (see Algorithm 1), termed Reranking by Multitask Learning (RML).
Input: N-best data {(H i , y i )} i=1,...,I Output: Common feature representation h c (e, f )and weight vector w c1: [optional] RandomHashing({H i }) 2: W = MultitaskLearn({(H i , y i )}) 3: h c = ExtractCommonFeature(W) 4: {H i c } = RemapFeature({H i }, h c ) 5: w c = ConventionalReranker({(H i c , y i )})The first step, random hashing, is optional.
Random hashing is an effective trick for reducing the dimension of sparse feature sets without suffering losses in fidelity (Weinberger et al., 2009;Ganchev and Dredze, 2008).
It works by collapsing random subsets of features.
This step can be performed to speed-up multitask learning later.
In some cases, the original feature dimension may be so large that hashed representations may be necessary.The next two steps are key.
A multitask learning algorithm is run on the N-best lists, and a common feature space shared by all lists is extracted.
For example, if one uses the multitask objective of Eq.
5, the result of step 2 is a set of weights W. ExtractCommonFeature(W) then returns the feature id's (either from original or hashed representation) that receive nonzero weight in any of W. 3 The new features h c (e, f ) are expected to have lower dimension than the original features h(e, f ).
Section 3.3 describes in detail different multitask methods that can be plugged-in to this step.The final two steps involve a conventional reranker.
In step 4, we remap the N-best list data according to the new feature representations h c (e, f ).
In step 5, we train a conventional reranker on this common representation, which by now should have overcome sparsity issues.
Using a conventional reranker at the end allows us to exploit existing rerankers designed for specific NLP applications.
In a sense, our meta-algorithm simply involves a change of representation for the conventional reranking scenario, where the new representation is found by multitask methods which are well-suited to heterogenous data.
Here, we describe various multitask methods that can be plugged in Step 2 of Algorithm 1.
Our goal is to demonstrate that a wide range of existing methods from the multitask learning literature can be brought to our problem.
We categorize multitask methods into two major approaches:1.
Joint Regularization: Eq.
5 is an example of joint regularization, with ℓ 1 /ℓ 2 norm being a particular regularizer.
The idea is to use the regularizer to ensure that the learned functions of related tasks are close to each other.
The popular ℓ 1 /ℓ 2 objective can be optimized by various methods, such as boosting ( Obozinski et al., 2009) and convex programming ( Argyriou et al., 2008).
Yet another regularizer is the ℓ 1 /ℓ ∞ norm ( Quattoni et al., 2009), which replaces the 2-norm with a max.One could also define a regularizer to ensure that each task-specific w i is close to some average parameter, e.g.i ||w i − w avg || 2 .
If we interpret w avg as a prior, we begin to see links to Hierarchical Bayesian methods for multitask learning (Finkel and Manning, 2009;Daume, 2009).2.
Shared Subspace: This approach assumes that there is an underlying feature subspace that is common to all tasks.
Early works on multitask learning implement this by neural networks, where different tasks have different output layers but share the same hidden layer (Caruana, 1997).
Another method is to write the weight vector as two parts w = [u; v] and let the task-specific function be and Zhang, 2005)u T · h(e, f ) + v T · Θ · h(e, f ) (Ando.
Θ is a D ′ × D matrix that maps the original features to a subspace common to all tasks.
The new feature representation is computed by the projection hc (e, f ) Θ · h(e, f ).
Multitask learning is a vast field and relates to areas like collaborative filtering ( Yu and Tresp, 2005) and domain adaptation.
Most methods assume some common representation and is thus applicable to our framework.
The reader is urged to refer to citations in, e.g. ( Argyriou et al., 2008) for a survey.
As a proof of concept, we perform experiments on a MT system with millions of features.
We use a hierarchical phrase-based system (Chiang, 2007) to generate N-best lists (N=100).
Sparse features used in reranking are extracted according to (Watanabe et al., 2007).
Specifically, the majority are lexical features involving joint occurrences of words within the N-best lists and source sentences.It is worth noting that the fact that the first pass system is a hierarchical system is not essential to the feature extraction step; similar features can be extracted with other systems as first-pass, e.g. a phrase-based system.
That said, the extent of the feature sparsity problem may depend on the performance of the first-pass system.We experiment with medical domain MT, where large numbers of technical vocabulary cause sparsity challenges.
Our corpora consists of English abstracts from PubMed 4 with their Japanese translations.
The first-pass system is built on hierarchical phrases extracted from 17k sentence pairs and target (Japanese) language models trained on 800k medical-domain sentences.
For our reranking experiments, we used 500 lists as the training set 5 , 500 lists as held-out, and another 500 for test.
We present some statistics to illustrate the feature sparsity problem: From 500 N-best lists, we extracted a total of 2.4 million distinct features.
By type, 75% of these features occur in only one Nbest list in the dataset.
Less than 3% of features occur in ten or more lists.
The distribution of feature occurrence is clearly Zipfian, as seen in the power-law plot in Figure 1.
We can also observe the feature growth rate (Table 1).
This is the number of new features introduced when an additional N-best list is seen.
It is important to note that on average, 2599 new features are added everytime a new N-best list is seen.
This is as much as 2599/4188 = 62% of the active features.
Imagine an online training algorithm (e.g. MIRA or perceptron) on this kind of data: whenever a loss occurs and we update the weight vector, less than half of the weight vector update applies to data we have seen thus far.
Herein lies the potential for overfitting.From observing the feature grow rate, one may hypothesize that adding large numbers of N-best lists to the training set (500 in the experiments here) may not necessarily improve results.
While adding data potentially improves the estimation process, it also increases the feature space dramatically.
Thus we see the need for a feature extraction procedure.
( Watanabe et al., 2007) also reports the possibility of overfitting in their dataset (Arabic-English newswire translation), especially when domain differences are present.
Here we observe this tendency already on the same domain, which is likely due to the highly-specialized vocabulary and the complex sentence structures common in research paper abstracts.
Our goal is to compare different feature representations in reranking: The baseline reranker uses the original sparse feature representation.
This is compared to feature representations discovered by three different multitask learning methods:• Joint Regularization ( Obozinski et al., 2009) • Shared Subspace ( Ando and Zhang, 2005) • Unsupervised Multitask Feature Selection ( Abernethy et al., 2007).
6 We use existing implementations of the above methods.
7 The conventional reranker (Step 5, Al- 1 3900 3900 3900 2 7535 11435 7913 3 6078 17513 7087 4 3868 21381 4747 5 1896 23277 2645 6 3542 26819 combined with the 3900 from N-best 1, the total features so far is 11435.
gorithm 1) used in all cases is SVM rank .
8 Our initial experiments show that the SVM baseline performance is comparable to MIRA training, so we use SVM throughout.
The labels for the SVM are derived as in (Shen et al., 2004), where top 10% of hypotheses by smoothed sentence-BLEU is ranked before the bottom 90%.
All multitask learning methods work on hashed features of dimension 4000 (Step 1, Algorithm 1).
This speeds up the training process.
All hyperparameters of the multitask method are tuned on the held-out set.
In particular, the most important is the number of common features to extract, which we pick from {250, 500, 1000}.
Table 2 shows the results by BLEU ( Papineni et al., 2002) and PER.
The Oracle results are obtained by choosing the best hypothesis per N-best list by sentence-level BLEU, which achieved 36.9 BLEU in both Train and Test.
A summary of our observations is:1.
The baseline (All sparse features) overfits.
It achieves the oracle BLEU score on the train set (36.9) but performs poorly on the test (28.6).2.
Similar overfitting occurs when traditional ℓ 1 regularization is used to select features on the sparse feature representation 9 .
ℓ 1 regularization is a good method of handling sparse features for classification problems, but in reranking the lack of tying between lists makes this regularizer inappropriate.
A small set of around 1200 features are chosen: they perform well independently on each task in the training data, but there is little sharing with the test data.3.
All three multitask methods obtained features that outperformed the baseline.
The BLEU scores are 28.8, 28.9, 29.1 for Unsupervised Feature Selection, Joint Regularization, and Shared Subspace, respectively, which all outperform the 28.6 baseline.
All improvements are statistically significant by bootstrap sampling test (1000 samples, p < 0.05) ( Zhang et al., 2004).4.
Shared Subspace performed the best.
We conjecture this is because its feature projection can create new feature combinations that is more expressive than the feature selection used by the two other methods.5.
PER results are qualitatively similar to BLEU results.6.
As a further analysis, we are interested in seeing whether multitask learning extracts novel features, especially those that have low frequency.
Thus, we tried an additional feature representation (feature threshold) which only keeps features that occur in more than x Nbests, and concatenate these high-frequency features to the multitask features.
The feature threshold alone achieves nice BLEU results (29.0 for x > 10), but the combination outperforms it by statistically significant margins (29.3-29.6).
This implies that multitask learning is extracting features that complement well with high frequency features.For the multitask features, improvements of 0.2 to 1.0 BLEU are modest but consistent.
Figure 2 shows the BLEU of bootstrap samples obtained as part of the statistical significance test.
We see that multitask almost never underperform baseline in any random sampling of the data.
This implies that the proposed meta-algorithm is very sta-ble, i.e. it is not a method that sometimes improves and sometimes degrades.Finally, a potential question to ask is: what kinds of features are being selected by the multitask learning algorithms?
We found that that two kinds of features are usually selected: one is general features that are not lexicalized, such as "count of phrases", "count of deletions/insertions", "number of punctuation marks".
The other kind is lexicalized features, such as those in Equations 2 and 3, but involving functions words (like the Japanese characters "wa", "ga", "ni", "de") or special characters (such as numeral symbol and punctuation).
These are features that can be expected to be widely applicable, and it is promising that multitask learning is able to recover these from the millions of potential features.
10 Previous reranking work in NLP can be classified into two different research focuses:1.
Engineering better features: In MT, (Och and others, 2004) investigates features extracted from a wide variety of syntactic representations, such as parse tree probability on the outputs.
Although their results show that the proposed syntactic features gave little improvements, they point to some potential reasons, such as domain mismatch for the parser and overfitting by the reranking 10 Note: In order to do this analysis, we needed to run Joint Regularization on the original feature representation, since the hashed representations are less interpretable.
This turns out to be computationally prohibitive in the time being so we only ran on a smaller data set of 50 lists.
Recently new optimization methods that are orders of magnitude faster have been developed ( Liu et al., 2009), which makes larger-scale experiments possible.
2.
Designing better training algorithms: Nbest reranking can be seen as a subproblem of structured prediction, so many general structured prediction algorithms (c.f. ( Bakir et al., 2007)) can be applied.
In fact, some structured prediction algorithms, such as the MIRA algorithm used in dependency parsing ( McDonald et al., 2005) and MT ( Watanabe et al., 2007) uses iterative sets of N-best lists in its training process.
Other training algorithms include perceptron-style algorithms ( Liang et al., 2006), MaxEnt (Charniak and Johnson, 2005), and boosting variants ( Kudo et al., 2005).
The division into two research focuses is convenient, but may be suboptimal if the training algorithm and features do not match well together.
Our work can be seen as re-connecting the two focuses, where the training algorithm is explicitly used to help discover better features.Multitask learning is currently an active subfield within machine learning.
There has already been some applications in NLP: For example, (Col- lobert and Weston, 2008) uses a deep neural network architecture for multitask learning on partof-speech tagging, chunking, semantic role labeling, etc.
They showed that jointly learning these related tasks lead to overall improvements.
(De- selaers et al., 2009) applies similar methods for machine transliteration.
In information extraction, learning different relation types can be naturally cast as a multitask problem (Jiang, 2009;Carlson et al., 2009).
Our work can be seen as following the same philosophy, but applied to N-best lists.
In other areas, ( Reichart et al., 2008) introduced an active learning strategy for annotating multitask linguistic data.
(Blitzer et al., 2006) applies the multitask algorithm of ( Ando and Zhang, 2005) to domain adaptation problems in NLP.
We expect that more novel applications of multitask learning will appear in NLP as the techniques become scalable and standard.
N-best reranking is a beneficial framework for experimenting with large feature sets, but unfortunately feature sparsity leads to overfitting.
We addressed this by re-casting N-best lists as multitask learning data.
Our MT experiments show consistent statistically significant improvements.From the Bayesian view, multitask formulation of N-best lists is actually very natural: Each Nbest is generated by a different data-generating distribution since the input sentences are different, i.e. p(e|f 1 ) 񮽙 = p(e|f 2 ).
Yet these N-bests are related since the general p(e|f ) distribution depends on the same first-pass models.The multitask learning perspective opens up interesting new possibilities for future work, e.g.:• Different ways to partition data into tasks, e.g. clustering lists by document structure, or hierarchical clustering of data• Multitask learning on lattices or N-best lists with larger N.
It is possible that a larger hypothesis space may improve the estimation of task-specific weights.
• Comparing multitask learning to sparse online learning of batch data, e.g. ( Tsuruoka et al., 2009).
• Modifying the multitask objective to incorporate application-specific loss/decoding, such as Minimum Bayes Risk ( Kumar and Byrne, 2004) • Using multitask learning to aid large-scale feature engineering and visualization.
We have received numerous helpful comments throughout the course of this work.
In particular, we would like to thank Albert Au Yeung, Jun Suzuki, Shinji Watanabe, and the three anonymous reviewers for their valuable suggestions.
