In the last 10 years, cache attacks on Intel x86 CPUs have gained increasing attention among the scientific community and powerful techniques to exploit cache side channels have been developed.
However, modern smart-phones use one or more multi-core ARM CPUs that have a different cache organization and instruction set than Intel x86 CPUs.
So far, no cross-core cache attacks have been demonstrated on non-rooted Android smartphones.
In this work, we demonstrate how to solve key challenges to perform the most powerful cross-core cache attacks Prime+Probe, Flush+Reload, Evict+Reload, and Flush+Flush on non-rooted ARM-based devices without any privileges.
Based on our techniques, we demonstrate covert channels that outperform state-of-the-art covert channels on Android by several orders of magnitude.
Moreover, we present attacks to monitor tap and swipe events as well as keystrokes, and even derive the lengths of words entered on the touchscreen.
Eventually, we are the first to attack cryptographic primitives implemented in Java.
Our attacks work across CPUs and can even monitor cache activity in the ARM TrustZone from the normal world.
The techniques we present can be used to attack hundreds of millions of Android devices.
Cache attacks represent a powerful means of exploiting the different access times within the memory hierarchy of modern system architectures.
Until recently, these attacks explicitly targeted cryptographic implementations, for instance, by means of cache timing attacks [9] or the well-known Evict+Time and Prime+Probe techniques [43].
The seminal paper by Yarom and Falkner [60] introduced the so-called Flush+Reload attack, which allows an attacker to infer which specific parts of a binary are accessed by a victim program with an unprecedented accuracy and probing frequency.
Recently, Gruss et al. [19] demonstrated the possibility to use Flush+Reload to automatically exploit cache-based side channels via cache template attacks on Intel platforms.
Flush+Reload does not only allow for efficient attacks against cryptographic implementations [8,26,56], but also to infer keystroke information and even to build keyloggers on Intel platforms [19].
In contrast to attacks on cryptographic algorithms, which are typically triggered multiple times, these attacks require a significantly higher accuracy as an attacker has only one single chance to observe a user input event.Although a few publications about cache attacks on AES T-table implementations on mobile devices exist [10,[50][51][52]57], the more efficient cross-core attack techniques Prime+Probe, Flush+Reload, Evict+Reload, and Flush+Flush [18] have not been applied on smartphones.
In fact, there was reasonable doubt [60] whether these cross-core attacks can be mounted on ARM-based devices at all.
In this work, we demonstrate that these attack techniques are applicable on ARM-based devices by solving the following key challenges systematically:1.
Last-level caches are not inclusive on ARM and thus cross-core attacks cannot rely on this property.
Indeed, existing cross-core attacks exploit the inclusiveness of shared last-level caches [18,19,22,24,35,37,38,42,60] and, thus, no cross-core attacks have been demonstrated on ARM so far.
We present an approach that exploits coherence protocols and L1-to-L2 transfers to make these attacks applicable on mobile devices with non-inclusive shared lastlevel caches, irrespective of the cache organization.
1 2.
Most modern smartphones have multiple CPUs that do not share a cache.
However, cache coherence protocols allow CPUs to fetch cache lines from remote cores faster than from the main memory.
We utilize this property to mount both cross-core and cross-CPU attacks.level caches that are instruction-inclusive and datanon-inclusive as well as caches that are instructionnon-inclusive and data-inclusive.
• Our cache-based covert channel outperforms all existing covert channels on Android by several orders of magnitude.
• We demonstrate the power of these attacks by attacking cryptographic implementations and by inferring more fine-grained information like keystrokes and swipe actions on the touchscreen.Outline.
The remainder of this paper is structured as follows.
In Section 2, we provide information on background and related work.
Section 3 describes the techniques that are the building blocks for our attacks.
In Section 4, we demonstrate and evaluate fast cross-core and cross-CPU covert channels on Android.
In Section 5, we demonstrate cache template attacks on user input events.
In Section 6, we present attacks on cryptographic implementations used in practice as well the possibility to observe cache activity of cryptographic computations within the TrustZone.
We discuss countermeasures in Section 7 and conclude this work in Section 8.
In this section, we provide the required preliminaries and discuss related work in the context of cache attacks.
Today's CPU performance is influenced not only by the clock frequency but also by the latency of instructions, operand fetches, and other interactions with internal and external devices.
In order to overcome the latency of system memory accesses, CPUs employ caches to buffer frequently used data in small and fast internal memories.
Modern caches organize cache lines in multiple sets, which is also known as set-associative caches.
Each memory address maps to one of these cache sets and addresses that map to the same cache set are considered congruent.
Congruent addresses compete for cache lines within the same set and a predefined replacement policy determines which cache line is replaced.
For instance, the last generations of Intel CPUs employ an undocumented variant of least-recently used (LRU) replacement policy [17].
ARM processors use a pseudo-LRU replacement policy for the L1 cache and they support two different cache replacement policies for L2 caches, namely round-robin and pseudo-random replacement policy.
In practice, however, only the pseudo-random replacement policy is used due to performance reasons.
Switching the cache replacement policy is only possible in privi-leged mode.
The implementation details for the pseudorandom policy are not documented.CPU caches can either be virtually indexed or physically indexed, which determines whether the index is derived from the virtual or physical address.
A so-called tag uniquely identifies the address that is cached within a specific cache line.
Although this tag can also be based on the virtual or physical address, most modern caches use physical tags because they can be computed simultaneously while locating the cache set.
ARM typically uses physically indexed, physically tagged L2 caches.CPUs have multiple cache levels, with the lower levels being faster and smaller than the higher levels.
ARM processors typically have two levels of cache.
If all cache lines from lower levels are also stored in a higher-level cache, the higher-level cache is called inclusive.
If a cache line can only reside in one of the cache levels at any point in time, the caches are called exclusive.
If the cache is neither inclusive nor exclusive, it is called noninclusive.
The last-level cache is often shared among all cores to enhance the performance upon transitioning threads between cores and to simplify cross-core cache lookups.
However, with shared last-level caches, one core can (intentionally) influence the cache content of all other cores.
This represents the basis for cache attacks like Flush+Reload [60].
In order to keep caches of multiple CPU cores or CPUs in a coherent state, so-called coherence protocols are employed.
However, coherence protocols also introduce exploitable timing effects, which has recently been exploited by Irazoqui et al. [25] on x86 CPUs.In this paper, we demonstrate attacks on three smartphones as listed in Table 1.
The Krait 400 is an ARMv7-A CPU, the other two processors are ARMv8-A CPUs.
However, the stock Android of the Alcatel One Touch Pop 2 is compiled for an ARMv7-A instruction set and thus ARMv8-A instructions are not used.
We generically refer to ARMv7-A and ARMv8-A as "ARM architecture" throughout this paper.
All devices have a shared L2 cache.
On the Samsung Galaxy S6, the flush instruction is unlocked by default, which means that it is available in userspace.
Furthermore, all devices employ a cache coherence protocol between cores and on the Samsung Galaxy S6 even between the two CPUs [6].
Read-only shared memory can be used as a means of memory usage optimization.
In case of shared libraries it reduces the memory footprint and enhances the speed by lowering cache contention.
The operating system implements this behavior by mapping the same physical memory into the address space of each process.
As this memory sharing mechanism is independent of how a file was opened or accessed, an attacker can map a binary to have read-only shared memory with a victim program.
A similar effect is caused by content-based page deduplication where physical pages with identical content are merged.Android applications are usually written in Java and, thus, contain self-modifying code or just-in-time compiled code.
This code would typically not be shared.
Since Android version 4.4 the Dalvik VM was gradually replaced by the Android Runtime (ART).
With ART, Java byte code is compiled to native code binaries [1] and thus can be shared too.
Initially, cache timing attacks were performed on cryptographic algorithms [9,30,31,40,41,44,55].
For example, Bernstein [9] exploited the total execution time of AES T-table implementations.
More fine-grained exploitations of memory accesses to the CPU cache have been proposed by Percival [45] and Osvik et al. [43].
More specifically, Osvik et al. formalized two concepts, namely Evict+Time and Prime+Probe, to determine which specific cache sets were accessed by a victim program.
Both approaches consist of three basic steps.
Evict+Time:1.
Measure execution time of victim program.2.
Evict a specific cache set.3.
Measure execution time of victim program again.
Prime+Probe:1.
Occupy specific cache sets.
2.
Victim program is scheduled.
3.
Determine which cache sets are still occupied.
Both approaches allow an adversary to determine which cache sets are used during the victim's computations and have been exploited to attack cryptographic implementations [24,35,43,54] and to build cross-VM covert channels [37].
Yarom and Falkner [60] proposed Flush+Reload, a significantly more fine-grained attack that exploits three fundamental concepts of modern system architectures.
First, the availability of shared memory between the victim process and the adversary.
Second, last-level caches are typically shared among all cores.
Third, Intel platforms use inclusive last-level caches, meaning that the eviction of information from the last-level cache leads to the eviction of this data from all lower-level caches of other cores, which allows any program to evict data from other programs on other cores.
While the basic idea of this attack has been proposed by Gullasch et al. [21], Yarom and Falkner extended this idea to shared last-level caches, allowing cross-core attacks.
Flush+Reload works as follows.
Flush+Reload:1.
Map binary (e.g., shared object) into address space.
2.
Flush a cache line (code or data) from the cache.
Check if the corresponding line from step 2 has been loaded by the victim program.
Thereby, Flush+Reload allows an attacker to determine which specific instructions are executed and also which specific data is accessed by the victim program.
Thus, rather fine-grained attacks are possible and have already been demonstrated against cryptographic implementations [22,27,28].
Furthermore, Gruss et al. [19] demonstrated the possibility to automatically exploit cache-based side-channel information based on the Flush+Reload approach.
Besides attacking cryptographic implementations like AES T-table implementations, they showed how to infer keystroke information and even how to build a keylogger by exploiting the cache side channel.
Similarly, Oren et al. [42] demonstrated the possibility to exploit cache attacks on Intel platforms from JavaScript and showed how to infer visited websites and how to track the user's mouse activity.Gruss et al. [19] proposed the Evict+Reload technique that replaces the flush instruction in Flush+Reload by eviction.
While it has no practical application on x86 CPUs, we show that it can be used on ARM CPUs.
Recently, Flush+Flush [18] has been proposed.
Unlike other techniques, it does not perform any memory access but relies on the timing of the flush instruction to determine whether a line has been loaded by a victim.
We show that the execution time of the ARMv8-A flush instruction also depends on whether or not data is cached and, thus, can be used to implement this attack.While the attacks discussed above have been proposed and investigated for Intel processors, the same attacks were considered not applicable to modern smartphones due to differences in the instruction set, the cache organization [60], and in the multi-core and multi-CPU architecture.
Thus, only same-core cache attacks have been demonstrated on smartphones so far.
For instance, Weiß et al. [57] investigated Bernstein's cache-timing attack [9] on a Beagleboard employing an ARM Cortex-A8 processor.
Later on, Weiß et al. [58] investigated this timing attack in a multi-core setting on a development board.
As Weiß et al. [57] claimed that noise makes the attack difficult, Spreitzer and Plos [52] investigated the applicability of Bernstein's cache-timing attack on different ARM Cortex-A8 and ARM Cortex-A9 smartphones running Android.
Both investigations [52,57] confirmed that timing information is leaking, but the attack takes several hours due to the high number of measurement samples that are required, i.e., about 2 30 AES encryptions.
Later on, Spreitzer and Gérard [50] improved upon these results and managed to reduce the key space to a complexity which is practically relevant.Besides Bernstein's attack, another attack against AES T-table implementations has been proposed by Bogdanov et al. [10], who exploited so-called wide collisions on an ARM9 microprocessor.
In addition, power analysis attacks [13] and electromagnetic emanations [14] have been used to visualize cache accesses during AES computations on ARM microprocessors.
Furthermore, Spreitzer and Plos [51] implemented Evict+Time [43] in order to attack an AES T-table implementation on Androidbased smartphones.
However, so far only cache attacks against AES T-table implementations have been considered on smartphone platforms and none of the recent advances have been demonstrated on mobile devices.
We consider a scenario where an adversary attacks a smartphone user by means of a malicious application.
This application does not require any permission and, most importantly, it can be executed in unprivileged userspace and does not require a rooted device.
As our attack techniques do not exploit specific vulnerabilities of Android versions, they work on stock Android ROMs as well as customized ROMs in use today.
In this section, we tackle the aforementioned challenges 1 and 2, i.e., the last-level cache is not inclusive and multiple processors do not necessarily share a cache level.
When it comes to caches, ARM CPUs are very heterogeneous compared to Intel CPUs.
For example, whether or not a CPU has a second-level cache can be decided by the manufacturer.
Nevertheless, the last-level cache on ARM devices is usually shared among all cores and it can have different inclusiveness properties for instructions and data.
Due to cache coherence, shared memory is kept in a coherent state across cores and CPUs.
This is of importance when measuring timing differences between cache accesses and memory accesses (cache misses), as fast remote-cache accesses are performed instead of slow memory accesses [6].
In case of a non-coherent cache, a cross-core attack is not possible but an attacker can run the spy process on all cores simultaneously and thus fall back to a same-core attack.
However, we observed that caches are coherent on all our test devices.To perform a cross-core attack we load enough data into the cache to fully evict the corresponding last-level cache set.
Thereby, we exploit that we can fill the lastlevel cache directly or indirectly depending on the cache organization.
On the Alcatel One Touch Pop 2, the lastlevel cache is instruction-inclusive and thus we can evict instructions from the local caches of the other core.
Fig- ure 1 illustrates such an eviction.
In step 1, an instruction is allocated to the last-level cache and the instruction cache of one core.
In step 2, a process fills its core's data cache, thereby evicting cache lines into the last-level cache.
In step 3, the process has filled the last-level cache set using only data accesses and thereby evicts the instructions from instruction caches of other cores as well.We access cache lines multiple times to perform transfers between L1 and L2 cache.
Thus, more and more addresses used for eviction are cached in either L1 or L2.
As ARM CPUs typically have L1 caches with a very low associativity, the probability of eviction to L2 through other system activity is high.
Using an eviction strategy that performs frequent transfers between L1 and L2 increases this probability further.
Thus, this approach also works for other cache organizations to perform crosscore and cross-CPU cache attacks.
Due to the cache coherence protocol between the CPU cores [6,33], remotecore fetches are faster than memory accesses and thus can be distinguished from cache misses.
For instance, In this section, we tackle the aforementioned challenges 3 and 4, i.e., not all ARM processors support a flush instruction, and the replacement policy is pseudo-random.
There are two options to evict cache lines: (1) the flush instruction or (2) evict data with memory accesses to congruent addresses, i.e., addresses that map to the same cache set.
As the flush instruction is only available on the Samsung Galaxy S6, we need to rely on eviction strategies for the other devices and, therefore, to defeat the replacement policy.
The L1 cache in Cortex-A53 and Cortex-A57 has a very small number of ways and employs a least-recently used (LRU) replacement policy [5].
However, for a full cache eviction, we also have to evict cache lines from the L2 cache, which uses a pseudorandom replacement policy.Eviction strategies.
Previous approaches to evict data on Intel x86 platforms either have too much overhead [23] or are only applicable to caches implementing an LRU replacement policy [35,37,42].
Spreitzer and Plos [51] proposed an eviction strategy for ARMv7-A CPUs that requires to access more addresses than there are cache lines per cache set, due to the pseudorandom replacement policy.
Recently, Gruss et al. [17] demonstrated how to automatically find fast eviction strategies on Intel x86 architectures.
We show that their algorithm is applicable to ARM CPUs as well.
Thereby, we establish eviction strategies in an automated way and significantly reduce the overhead compared to [51].
We evaluated more than 4 200 access patterns on our smartphones and identified the best eviction strategies.
Even though the cache employs a random replace- ment policy, average eviction rate and average execution time are reproducible.
Eviction sets are computed based on physical addresses, which can be retrieved via /proc/self/pagemap as current Android versions allow access to these mappings to any unprivileged app without any permissions.
Thus, eviction patterns and eviction sets can be efficiently computed.We applied the algorithm of Gruss et al. [17] to a set of physically congruent addresses.
Table 2 summarizes different eviction strategies, i.e., loop parameters, for the Krait 400.
N denotes the total eviction set size (length of the loop), A denotes the shift offset (loop increment) to be applied after each round, and D denotes the number of memory accesses in each iteration (loop body).
The column cycles states the average execution time in CPU cycles over 1 million evictions and the last column denotes the average eviction rate.
The first line in Table 2 shows the average execution time and the average eviction rate for the privileged flush instruction, which gives the best result in terms of average execution time (549 CPU cycles).
We evaluated 1 863 different strategies and our best identified eviction strategy (N = 11, A = 2, D = 2) also achieves an average eviction rate of 100% but takes 1 578 CPU cycles.
Although a strategy accessing every address in the eviction set only once (A = 1, D = 1, also called LRU eviction) performs significantly fewer memory accesses, it consumes more CPU cycles.
For an average eviction rate of 100%, LRU eviction requires an eviction set size of at least 16.
The average execution time then is 3 026 CPU cycles.
Considering the eviction strategy used in [51] that takes 4 371 CPU cycles, clearly demonstrates the advantage of our optimized eviction strategy that takes only 1 578 CPU cycles.We performed the same evaluation with 2 295 different strategies on the ARM Cortex-A53 in our Alcatel One Touch Pop 2 test system and summarize them in Table 3.
For the best strategy we found (N = 21, A = 1, D = 6), we measured an average eviction rate of 99.93% and an average execution time of 4 275 CPU cycles.
We observed that LRU eviction (A = 1, D = 1) on the ARM Cortex- A53 would take 28 times more CPU cycles to achieve an average eviction rate of only 99.10%, thus it is not suitable for attacks on the last-level cache as used in previous work [51].
The reason for this is that data can only be allocated to L2 cache by evicting it from the L1 cache on the ARM Cortex-A53.
Therefore, it is better to reaccess the data that is already in the L2 cache and gradually add new addresses to the set of cached addresses instead of accessing more different addresses.On the ARM Cortex-A57 the userspace flush instruction was significantly faster in any case.
Thus, for Flush+Reload we use the flush instruction and for Prime+Probe the eviction strategy.
Falling back to Evict+Reload is not necessary on the Cortex-A57.
Similarly to recent Intel x86 CPUs, the execution time of the flush instruction on ARM depends on whether or not the value is cached, as shown in Figure 3.
The execution time is higher if the address is cached and lower if the address is not cached.
This observation allows us to distinguish between cache hits and cache misses depending on the timing behavior of the flush instruction, and therefore to perform a Flush+Flush attack.
Thus, in case of shared memory between the victim and the attacker, it is not even required to evict and reload an address in order to exploit the cache side channel.A note on Prime+Probe.
Finding a fast eviction strategy for Prime+Probe on architectures with a random replacement policy is not as straightforward as on Intel x86.
Even in case of x86 platforms, the problem of cache trashing has been discussed by Tromer et al. [54].
Cache trashing occurs when reloading (probing) an address evicts one of the addresses that are to be accessed next.
While Tromer et al. were able to overcome this problem by using a doubly-linked list that is accessed forward during the prime step and backwards during the probe step, the random replacement policy on ARM also contributes to the negative effect of cache trashing.We analyzed the behavior of the cache and designed a prime step and a probe step that work with a smaller set size to avoid set thrashing.
Thus, we set the eviction set size to 15 on the Alcatel One Touch Pop 2.
As we run the Prime+Probe attack in a loop, exactly 1 way in the L2 cache will not be occupied after a few attack rounds.
We might miss a victim access in 1 16 of the cases, which however is necessary as otherwise we would not be able to get reproducible measurements at all due to set thrashing.
If the victim replaces one of the 15 ways occupied by the attacker, there is still one free way to reload the address that was evicted.
This reduces the chance of set thrashing significantly and allows us to successfully perform Prime+Probe on caches with a random replacement policy.
In this section, we tackle the aforementioned challenge 5, i.e., cycle-accurate timings require root access on ARM.In order to distinguish cache hits and cache misses, timing sources or dedicated performance counters can be used.
We focus on timing sources, as cache misses have a significantly higher access latency and timing sources are well studied on Intel x86 CPUs.
Cache attacks on x86 CPUs employ the unprivileged rdtsc instruction to obtain a sub-nanosecond resolution timestamp.
The ARMv7-A architecture does not provide an instruction for this purpose.
Instead, the ARMv7-A architecture has a performance monitoring unit that allows to monitor CPU activity.
One of these performance countersdenoted as cycle count register (PMCCNTR)-can be used to distinguish cache hits and cache misses by relying on the number of CPU cycles that passed during a memory access.
However, these performance counters are not accessible from userspace by default and an attacker would need root privileges.We broaden the attack surface by exploiting timing sources that are accessible without any privileges or permissions.
We identified three possible alternatives for timing measurements.
Unprivileged syscall.
The perf_event_open syscall is an abstract layer to access performance information through the kernel independently of the underlying hardware.
For instance, PERF_COUNT_HW_CPU_CYCLES returns an accurate cycle count including a minor overhead due to the syscall.
The availability of this feature depends on the Android kernel configuration, e.g., the stock kernel on the Alcatel One Touch Pop 2 as well as the OnePlus One provide this feature by default.
Thus, in contrast to previous work [51], the attacker does not have to load a kernel module to access this information as the perf_event_open syscall can be accessed without any privileges or permissions.POSIX function.
Another alternative to obtain sufficiently accurate timing information is the POSIX function clock_gettime(), with an accuracy in the range of microseconds to nanoseconds.
Similar information can also be obtained from /proc/timer_list.Dedicated thread timer.
If no interface with sufficient accuracy is available, an attacker can run a thread that increments a global variable in a loop, providing a fair approximation of a cycle counter.
Our experiments show that this approach works reliably on smartphones as well as recent x86 CPUs.
The resolution of this threaded timing information is as high as with the other methods.In Figure 4 we show the cache hit and miss histogram based on the four different methods, including the cycle count register, on a Alcatel One Touch Pop 2.
Despite the latency and noise, cache hits and cache misses are clearly distinguishable with all approaches.
Thus, all methods can be used to implement cache attacks.
Determining the best timing method on the device under attack can be done in a few seconds during an online attack.
To evaluate the performance of our attacks, we measure the capacity of cross-core and cross-CPU cache covert channels.
A covert channel enables two unprivileged applications on a system to communicate with each other without using any data transfer mechanisms provided by the operating system.
This communication evades the sandboxing concept and the permission system (cf. collusion attacks [36]).
Both applications were running in the background while the phone was mostly idle and an unrelated app was running as the foreground application.Our covert channel is established on addresses of a shared library that is used by both the sender and the receiver.
While both processes have read-only access to the shared library, they can transmit information by loading addresses from the shared library into the cache or evicting (flushing) it from the cache, respectively.The covert channel transmits packets of n-bit data, an s-bit sequence number, and a c-bit checksum that is computed over data and sequence number.
The sequence number is used to distinguish consecutive packets and the checksum is used to check the integrity of the packet.
The receiver acknowledges valid packets by responding with an s-bit sequence number and an x-bit checksum.
By adjusting the sizes of checksums and sequence numbers the error rate of the covert channel can be controlled.Each bit is represented by one address in the shared library, whereas no two addresses are chosen that map to the same cache set.
To transmit a bit value of 1, the sender accesses the corresponding address in the library.
To transmit a bit value of 0, the sender does not access the corresponding address, resulting in a cache miss on the receiver's side.
Thus, the receiving process observes a cache hit or a cache miss depending on the memory access performed by the sender.
The same method is used for the acknowledgements sent by the receiving process.We implemented this covert channel using Evict+Reload, Flush+Reload, and Flush+Flush on our smartphones.
The results are summarized in Table 4.
On the Samsung Galaxy S6, we achieve a cross-core transmission rate of 1 140 650 bps at an error rate of 1.10%.
This is 265 times faster than any existing covert channel on smartphones.
In a cross-CPU transmission we achieve a transmission rate of 257 509 bps at an error rate of 1.83%.
We achieve a cross-core transition rate of 178 292 bps at an error rate of 0.48% using Flush+Flush on the Samsung Galaxy S6.
On the Alcatel One Touch Pop 2 we achieve a cross-core transmission rate of 13 618 bps at an error rate of 3.79% using Evict+Reload.
This is still 3 times faster than previous covert channels on smartphones.
The covert channel is significantly slower on the Alcatel One Touch Pop 2 than on the Samsung Galaxy S6 because the hardware is much slower, Evict+Reload is slower than Flush+Reload, and retransmission might be necessary in 0.14% of the cases where eviction is not successful (cf. Section 3.2).
On the older OnePlus One we achieve a cross-core transmission rate of 12 537 bps at an error rate of 5.00%, 3 times faster than previous covert channels on smartphones.
The reason for the higher error rate is the additional timing noise due to the cache coherence protocol performing a high number of remote-core fetches.
In this section we demonstrate cache side-channel attacks on Android smartphones.
We implement cache template attacks [19] to create and exploit accurate cache-usage profiles using the Evict+Reload or Flush+Reload attack.
Cache template attacks have a profiling phase and an exploitation phase.
In the profiling phase, a template matrix is computed that represents how many cache hits occur on a specific address when triggering a specific event.
The exploitation phase uses this matrix to infer events from cache hits.To perform cache template attacks, an attacker has to map shared binaries or shared libraries as read-only shared memory into its own address space.
By using shared libraries, the attacker bypasses any potential countermeasures taken by the operating system, such as restricted access to runtime data of other apps or address space layout randomization (ASLR).
The attack can even be performed online on the device under attack if the event can be simulated.Triggering the actual event that an attacker wants to spy on might require either (1) an offline phase or (2) privileged access.
For instance, in case of a keylogger, the attacker can gather a cache template matrix offline for a specific version of a library, or the attacker relies on privileged access of the application (or a dedicated permission) in order to be able to simulate events for gathering the cache template matrix.
However, the actual exploitation of the cache template matrix to infer events neither requires privileged access nor any permission.
Just as Linux, Android uses a large number of shared libraries, each with a size of up to several megabytes.
We inspected all available libraries on the system by manually scanning the names and identified libraries that might be responsible for handling user input, e.g., the libinput.so library.
Without loss of generality, we restricted the set of attacked libraries since testing all libraries would have taken a significant amount of time.
Yet, an adversary could exhaustively probe all libraries.
We automated the search for addresses in these shared libraries and after identifying addresses, we monitored them in order to infer user input events.
For instance, in the profiling phase on libinput.so, we simulated events via the android-debug bridge (adb shell) with two different methods.
The first method uses the input command line tool to simulate user input events.
The second method is writing event messages to /dev/input/event*.
Both methods can run entirely on the device for instance in idle periods while the user is not actively using the device.
As the second method only requires a write() statement it is significantly faster, but it is also more device specific.
Therefore, we used the input command line except when profiling differences between different letter keys.
While simulating these events, we simultaneously probed all addresses within the libinput.so library, i.e., we measured the number of cache hits that occurred on each address when triggering a specific event.
As already mentioned above, the simulation of some events might require either an offline phase or specific privileges in case of online attacks.
Figure 5 shows part of the cache template matrix for libinput.so.
We triggered the following events: key events including the power button (key), long touch events (longpress), swipe events, touch events (tap), and text input events (text) via the input tool as often as possible and measured each address and event for one second.
The cache template matrix clearly reveals addresses with high cache-hit rates for specific events.
Darker colors represent addresses with higher cache-hit rates for a specific event and lighter colors represent addresses with lower cache-hit rates.
Hence, we can distinguish different events based on cache hits on these addresses.
We verified our results by monitoring the identified addresses while operating the smartphone manually, i.e., we touched the screen and our attack application reliably reported cache hits on the monitored addresses.
For instance, address 0x11040 of libinput.so can be used to distinguish tap actions and swipe actions on the screen of the Alcatel One Touch Pop 2.
Tap actions cause a smaller 0x840 0x880 0x3280 0x7700 0x8080 0x8100 0x8140 0x8840 0x8880 0x8900 0x8940 0x8980 0x11000 0x11040 0x11080 number of cache hits than swipe actions.
Swipe actions cause cache hits in a high frequency as long as the screen is touched.
Figure 6 shows a sequence of 3 tap events, 3 swipe events, 3 tap events, and 2 swipe events.
These events can be clearly distinguished due to the fast access times.
The gaps mark periods of time where our program was not scheduled on the CPU.
Events occurring in those periods can be missed by our attack.
Swipe input allows to enter words by swiping over the soft-keyboard and thereby connecting single characters to form a word.
Since we are able to determine the length of swipe movements, we can correlate the length of the swipe movement with the actual word length in any Android application or system interface that uses swipe input without any privileges.
Furthermore, we can determine the actual length of the unlock pattern for the pattern-unlock mechanism.
Figure 7 shows a user input sequence consisting of 3 tap events and 3 swipe events on the Samsung Galaxy S6.
The attack was conducted using Flush+Reload.
An attacker can monitor every single event.
Taps and swipes can be distinguished based on the length of the cache hit phase.
The length of a swipe movement can be determined from the same information.
Figure 8 shows the same experiment on the OnePlus One using Evict+Reload.
Thus, our attack techniques work on coherent non-inclusive last-level caches.
Figure 8: Monitoring address 0xBFF4 of libinput.so on the OnePlus One reveals tap and swipe events.
Instead of attacking shared libraries, it is also possible to apply this attack to ART (Android Runtime) executables [1] that are compiled ahead of time.
We used this attack on the default AOSP keyboard and evaluated the number of accesses to every address in the optimized executable that responds to an input of a letter on the keyboard.
It is possible to find addresses that correspond to a key press and more importantly to distinguish between taps and key presses.
Figure 9 shows the corresponding cache template matrix.
We summarize the letter keys in one line (alphabet) as they did not vary significantly.
These addresses can be used to monitor key presses on the keyboard.
We identified an address that corresponds only to letters on the keyboard and hardly on the space bar or the return button.
With this information it is pos- sible to precisely determine the length of single words entered using the default AOSP keyboard.
We illustrate the capability of detecting word lengths in Figure 10.
The blue line shows the timing measurements for the address identified for keys in general, the red dots represent measurements of the address for the space key.
The plot shows that we can clearly determine the length of entered words and monitor user input accurately over time.
Our proof-of-concept attacks exploit shared libraries and binaries from Android apk files to infer key strokes.
The cache template attack technique we used for these attacks is generic and can also be used to attack any other library.
For instance, there are various libraries that handle different hardware modules and software events on the device, such as GPS, Bluetooth, camera, NFC, vibrator, audio and video decoding, web and PDF viewers.
Each of these libraries contains code that is executed and data that is accessed when the device is in use.
Thus, an attacker can perform a cache template attack on any of these libraries and spy on the corresponding device events.
For instance, our attack can be used to monitor activity of the GPS sensor, bluetooth, or the camera.
An attacker can record such user activities over time to learn more about the user.We can establish inter-keystroke timings at an accuracy as high as the accuracy of cache side-channel attacks on keystrokes on x86 systems with a physical keyboard.
Thus, the inter-keystroke timings can be used to infer entered words, as has been shown by Zhang et al. [61].
Our attack even has a higher resolution than [61], i.e., it is sub-microsecond accurate.
Furthermore, we can distinguish between keystrokes on the soft-keyboard and generic touch actions outside the soft-keyboard.
This information can be used to enhance sensor-based keyloggers that infer user input on mobile devices by exploiting, e.g., the accelerometer and the gyroscope [7,11,12,39,59] or the ambient-light sensor [49].
However, these attacks suffer from a lack of knowledge when exactly a user touches the screen.
Based on our attack, these sensor-based keyloggers can be improved as our attack allows to infer (1) the exact time when the user touches the screen, and (2) whether the user touches the soft-keyboard or any other region of the display.Our attacks only require the user to install a malicious app on the smartphone.
However, as shown by Oren et al. [42], Prime+Probe attacks can even be performed from within browser sandboxes through remote websites using JavaScript on Intel platforms.
Gruss et al. [16] showed that JavaScript timing measurements in web browsers on ARM-based smartphones achieve a comparable accuracy as on Intel platforms.
Thus, it seems likely that Prime+Probe through a website works on ARM-based smartphones as well.
We expect that such attacks will be demonstrated in future work.
The possibility of attacking millions of users shifts the focus of cache attacks to a new range of potential malicious applications.In our experiments with the predecessor of ART, the Dalvik VM, we found that the just-in-time compilation effectively prevents Evict+Reload and Flush+Reload attacks.
The just-in-time compiled code is not shared and thus the requirements for these two attacks are not met.
However, Prime+Probe attacks work on ART binaries and just-in-time compiled Dalvik VM code likewise.
In this section we show how Flush+Reload, Evict+Reload, and Prime+Probe can be used to attack AES T-table implementations that are still in use on Android devices.
Furthermore, we demonstrate the possibility to infer activities within the ARM TrustZone by observing the cache activity using Prime+Probe.
We perform all attacks cross-core and in a synchronized setting, i.e., the attacker triggers the execution of cryptographic algorithms by the victim process.
Although more sophisticated attacks are possible, our goal is to demonstrate that our work enables practical cache attacks on smartphones.
Many cache attacks against AES T-table implementations have been demonstrated and appropriate countermeasures have already been proposed.
Among these countermeasures are, e.g., so-called bit-sliced implementations [29,32,46].
Furthermore, Intel addressed the problem by adding dedicated instructions for AES [20] and ARM also follows the same direction with the ARMv8 instruction set [4].
However, our investigations showed that Bouncy Castle, a crypto library widely used in Android apps such as the WhatsApp messenger [2], still uses a T-table implementation.
Moreover, the OpenSSL library, which is the default crypto provider on recent Android versions, uses T-table implementations until version 1.0.1.
3 This version is still officially supported and commonly used on Android devices, e.g., the Alcatel One Touch Pop 2.
T-tables contain the precomputed AES round transformations, allowing to perform encryptions and decryptions by simple XOR operations.
For instance, let p i denote the plaintext bytes, k i the initial key bytes, and s i = p i ⊕ k i the initial state bytes.
The initial state bytes are used to retrieve precomputed T-table elements for the next round.
If an attacker knows a plaintext byte p i and the accessed element of the T-table, it is possible to recover the key bytes k i = s i ⊕ p i .
However, it is only possible to derive the upper 4 bits of k i through our cache attack on a device with a cache line size of 64 bytes.
This way, the attacker can learn 64 key bits.
In second-round and last-round attacks the key space can be reduced further.
For details about the basic attack strategy we refer to the work of Osvik et al. [43,54].
Although we successfully mounted an Evict+Reload attack on the Alcatel One Touch Pop 2 against the OpenSSL AES implementation, we do not provide further insights as we are more interested to perform the first cache attack on a Java implementation.Attack on Bouncy Castle.
Bouncy Castle is implemented in Java and provides various cryptographic primitives including AES.
As Bouncy Castle 1.5 still employs AES T-table implementations by default, all Android devices that use this version are vulnerable to our presented attack.
To the best of our knowledge, we are the first to show an attack on a Java implementation.During the initialization of Bouncy Castle, the T-tables are copied to a local private memory area.
Therefore, these copies are not shared among different processes.
Nevertheless, we demonstrate that Flush+Reload and Evict+Reload are efficient attacks on such an implemen-0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0 0xB0 0xC0 0xD0 0xE0 0xF0Plaintext byte values Address 0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0 0xB0 0xC0 0xD0 0xE0 0xF0Plaintext byte values tation if shared memory is available.
Further, we demonstrate a cross-core Prime+Probe attack without shared memory that is applicable in a real-world scenario.
Figure 11 shows a template matrix of the first T-table for all 256 values for plaintext byte p 0 and a key that is fixed to 0 while the remaining plaintext bytes are random.
These plots reveal the upper 4 key bits of k 0 [43,51].
Thus, in our case the key space is reduced to 64 bits after 256-512 encryptions.
We consider a firstround attack only, because we aim to demonstrate the applicability of these attacks on ARM-based mobile devices.
However, full-key recovery is possible with the same techniques by considering more sophisticated attacks targeting different rounds [47,54], even for asynchronous attackers [22,26].
We can exploit the fact that the T-tables are placed on a different boundary every time the process is started.
By restarting the victim application we can obtain arbitrary disalignments of T-tables.
Disaligned T-tables allow to reduce the key space to 20 bits on average and for specific disalignments even full-key recovery without a single brute-force computation is possible [51,53].
We observed not a single case where the T-tables were aligned.
Based on the first-round attack matrix in Figure 11, the expected number of encryptions until a key byte is identified is 1.81 · 128.
Thus, full key recovery is possible after 1.81 · 128 · 16 = 3 707 encryptions by monitoring a single address during each encryption.Real-world cross-core attack on Bouncy Castle.
If the attacker has no way to share a targeted memory region with the victim, Prime+Probe instead of Evict+Reload or Flush+Reload can be used.
This is the case for dynamically generated data or private memory of another process.
Figure 12 shows the Prime+Probe histogram for cache hits and cache misses.
We observe a higher execution time if the victim accesses a congruent memory location.
Thus, Prime+Probe can be used for a real-world cross-core attack on Bouncy Castle and also allows to exploit disaligned T-tables as mentioned above.
Figure 12: Histogram of Prime+Probe timings depending on whether the victim accesses congruent memory on the ARM Cortex-A53.
0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xA0 0xB0 0xC0 0xD0 0xE0 0xF0Plaintext byte values In a preprocessing step, the attacker identifies the cache sets to be attacked by performing random encryptions and searching for active cache sets.
Recall that the cache set (index) is derived directly from the physical address on ARM, i.e., the lowest n bits determine the offset within a 2 n -byte cache line and the next s bits determine one of the 2 s cache sets.
Thus, we only have to find a few cache sets where a T-table maps to in order to identify all cache sets required for the attack.
On x86 the replacement policy facilitates this attack and allows even to deduce the number of ways that have been replaced in a specific cache set [43].
On ARM the random replacement policy makes Prime+Probe more difficult as cache lines are replaced in a less predictable way.
To launch a Prime+Probe attack, we apply the eviction strategy and the crafted reaccess patterns we described in Section 3.2.
Figure 13 shows an excerpt of the cache template matrix resulting from a Prime+Probe attack on one T-table.
For each combination of plaintext byte and offset we performed 100 000 encryptions for illustration purposes.
We only need to monitor a single address to obtain the upper 4 bits of s i and, thus, the upper 4 bits of k i = s i ⊕ p i .
Compared to the Evict+Reload attack from the previous section, Prime+Probe requires 3 times as many measurements to achieve the same accuracy.
Nevertheless, our results show that an attacker can run Prime+Probe attacks on ARM CPUs just as on Intel CPUs.
The ARM TrustZone is a hardware-based security technology built into ARM CPUs to provide a secure execution environment [4].
This trusted execution environment is isolated from the normal world using hardware support.
The TrustZone is used, e.g., as a hardwarebacked credential store, to emulate secure elements for payment applications, digital rights management as well as verified boot and kernel integrity measurements.
The services are provided by so-called trustlets, i.e., applications that run in the secure world.Since the secure monitor can only be called from the supervisor context, the kernel provides an interface for the userspace to interact with the TrustZone.
On the Alcatel One Touch Pop 2, the TrustZone is accessible through a device driver called QSEECOM (Qualcomm Secure Execution Environment Communication) and a library libQSEEComAPI.so.
The key master trustlet on the Alcatel One Touch Pop 2 provides an interface to generate hardware-backed RSA keys, which can then be used inside the TrustZone to sign and verify signatures.Our observations showed that a Prime+Probe attack on the TrustZone is not much different from a Prime+Probe attack on any application in the normal world.
However, as we do not have access to the source code of the TrustZone OS or any trustlet, we only conduct simple attacks.
4 We show that Prime+Probe can be used to distinguish whether a provided key is valid or not.
While this might also be observable through the overall execution time, we demonstrate that the TrustZone isolation does not protect against cache attacks from the normal world and any trustlet can be attacked.We evaluated cache profiles for multiple valid as well as invalid keys.
Figure 14 shows the mean squared error over two runs for different valid keys and one invalid key compared to the average of valid keys.
We performed Prime+Probe before and after the invocation of the corresponding trustlet, i.e., prime before the invocation and probe afterwards.
We clearly see a difference in some sets (cache sets 250-320) that are used during the signature generation using a valid key.
These cache profiles are reproducible and can be used to distinguish whether a valid or an invalid key has been used in the TrustZone.
Thus, the secure world leaks information to the non-secure world.On the Samsung Galaxy S6, the TrustZone flushes the cache when entering or leaving the trusted world.
However, by performing a Prime+Probe attack in parallel, i.e., multiple times while the trustlet performs the corresponding computations, the same attack can be mounted.
Although our attacks exploit hardware weaknesses, software-based countermeasures could impede such attacks.
Indeed, we use unprotected access to system information that is available on all Android versions.As we have shown, the operating system cannot prevent access to timing information.
However, other information supplied by the operating system that facilitates these attacks could be restricted.
For instance, we use /proc/pid/ to retrieve information about any other process on the device, e.g., /proc/pid/pagemap is used to resolve virtual addresses to physical addresses.
Even though access to /proc/pid/pagemap and /proc/self/pagemap has been restricted in Linux in early 2015, the Android kernel still allows access to these resources.
Given the immediately applicable attacks we presented, we stress the urgency to merge the corresponding patches into the Android kernel.
Furthermore, we use /proc/pid/maps to determine shared objects that are mapped into the address space of a victim.
Restricting access to procfs to specific privileges or permissions would make attacks harder.
We recommend this for both the Linux kernel as well as Android.We also exploit the fact that access to shared libraries as well as dex and art optimized program binaries is only partially restricted on the file system level.
While we cannot retrieve a directory listing of /data/dalvik-cache/, all files are readable for any process or Android application.
We recommend to allow read access to these files to their respective owner exclusively to prevent Evict+Reload, Flush+Reload, and Flush+Flush attacks through these shared files.In order to prevent cache attacks against AES T-tables, hardware instructions should be used.
If this is not an option, a software-only bit-sliced implementation must be employed, especially when disalignment is possible, as it is the case in Java.
Since OpenSSL 1.0.2 a bit-sliced implementation is available for devices capable of the ARM NEON instruction set and dedicated AES instructions are used on ARMv8-A devices.
Cryptographic algorithms can also be protected using cache partitioning [34].
However, cache partitioning comes with a performance impact and it can not prevent all attacks, as the number of cache partitions is limited.We responsibly disclosed our attacks and the proposed countermeasures to Google and other development groups prior to the publication of our attacks.
Google has applied upstream patches preventing access to /proc/pid/pagemap in early 2016 and recommended installing the security update in March 2016 [15].
In this work we demonstrated the most powerful cross-core cache attacks Prime+Probe, Flush+Reload, Evict+Reload, and Flush+Flush on default configured unmodified Android smartphones.
Furthermore, these attacks do not require any permission or privileges.
In order to enable these attacks in real-world scenarios, we have systematically solved all challenges that prevented highly accurate cache attacks on ARM so far.
Our attacks are the first cross-core and cross-CPU attacks on ARM CPUs.
Furthermore, our attack techniques provide a high resolution and a high accuracy, which allows monitoring singular events such as touch and swipe actions on the screen, touch actions on the soft-keyboard, and inter-keystroke timings.
In addition, we show that efficient state-of-the-art key-recovery attacks can be mounted against the default AES implementation that is part of the Java Bouncy Castle crypto provider and that cache activity in the ARM TrustZone can be monitored from the normal world.The presented example attacks are by no means exhaustive and launching our proposed attack against other libraries and apps will reveal numerous further exploitable information leaks.
Our attacks are applicable to hundreds of millions of today's off-the-shelf smartphones as they all have very similar if not identical hardware.
This is especially daunting since smartphones have become the most important personal computing devices and our techniques significantly broaden the scope and impact of cache attacks.
We would like to thank our anonymous reviewers for their valuable comments and suggestions.
