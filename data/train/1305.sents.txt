Given a set of objects P and a query point q, a k nearest neighbor (k-NN) query retrieves the k objects in P that lie closest to q. Even though the problem is well-studied for static datasets, the traditional methods do not extend to highly dynamic environments where multiple continuous queries require real-time results, and both objects and queries receive frequent location updates.
In this paper we propose conceptual partitioning (CPM), a comprehensive technique for the efficient monitoring of continuous NN queries.
CPM achieves low running time by handling location updates only from objects that fall in the vicinity of some query (and ignoring the rest).
It can be used with multiple, static or moving queries, and it does not make any assumptions about the object moving patterns.
We analyze the performance of CPM and show that it outperforms the current state-of-the-art algorithms for all problem settings.
Finally, we extend our framework to aggregate NN (ANN) queries, which monitor the data objects that minimize the aggregate distance with respect to a set of query points (e.g., the objects with the minimum sum of distances to all query points).
Early work in spatial databases focused on the point k-NN query that retrieves the k (≥1) objects from a static dataset that are closest (according to Euclidean distance) to a static query point.
The existing algorithms (e.g., [H84, RKV95, HS99]) consider that the data are indexed with a spatial access method and utilize some pruning bounds to restrict the search space.
In addition, several papers study variations of NN search such as reverse NNs [SRAA01] and constrained NNs [FSAA01].
Recently, the focus has shifted towards moving NN queries and/or objects in clientserver architectures.
Song and Roussopoulos [SR01] reduce the number of moving NN queries over static objects by introducing some redundancy.
In particular, when a k-NN query is processed, the server sends to the client a number m > k of neighbors.
The k nearest neighbors at a new location q' will be among the m objects of the first query q provided that the distance between q and q' is within a range determined by k and m. For the same settings (moving query -static data objects), Zhang et al. [ZZP+03] propose the concept of location-based queries that return the NN of q along with its Voronoi cell, i.e., the area around the query point where the NN set remains the same.
The Voronoi cell is computed on-the-fly using an R-tree on the data objects.
Given clients and data objects that move with linear and known velocities, time-parameterized [TP03] queries report, in addition to the current NN set, its validity period and the next change of the result (that will occur at the end of the validity period).
Linear NN [BJKS02, TP03] queries return all NN sets up to a future timestamp q t assuming that there are no updates of the velocity vectors between the current time and q t .
All the above techniques target the efficient processing of a single snapshot query since they report the NN set at the query time, possibly with some validity information (e.g., expiry time, Voronoi cell), or generate future results based on predictive features (e.g., velocity vectors of queries or data objects).
On the other hand, continuous monitoring: (i) involves multiple longrunning queries (from geographically distributed clients), (ii) is concerned with both computing and keeping the results up to date, (iii) usually assumes main-memory processing to cope with the intensive (object or query) location updates, (iv) attempts to minimize factors such as the CPU or communication cost (as opposed to I/O overhead).
Continuous monitoring of spatial queries is becoming increasingly important due to the wide availability of inexpensive and compact positioning devices, the evolution of mobile communications and the need for improved location-based services.
Consequently, several techniques (reviewed in Section 2) have been developed in the last few years for continuous range and NN queries.
In this paper, we propose the conceptual partitioning monitoring (CPM) method for NN queries in highly dynamic environments.
The data objects are indexed by a main-memory grid G consisting of cells with size δ×δ (assuming two-dimensional space).
Each cell c in the grid is associated with the list of objects residing therein.
The running queries are stored along with their current result in a query table QT.
When a query q arrives at the system, its initial result is computed by the NN search module of CPM.
CPM organizes the cells into (hyper) rectangles based on their proximity to q.
This conceptual partitioning provides a natural processing order of the cells in G, so that the NN search considers the minimal set of cells in order to retrieve the NNs of q.
We refer to the set of encountered cells as the influence region of q.
The next task of CPM is to monitor the results of the queries upon the arrival of object updates.
Clearly, only updates affecting the influence region of a query can potentially invalidate its current result.
To restrict processing to such updates and to efficiently compute the changes in the results, we maintain book-keeping information in the object index and the query table.
We also show that it is often possible to compute the new result of an affected query among the objects that issue updates, without searching in The first monitoring method for spatial queries, called Q-index [PXK+02], assumes static range queries over moving objects.
The queries are indexed by an R-tree and moving objects probe the index to find the queries that they influence.
Q-index avoids the expensive (due to intensive updates) maintenance of an index on the objects.
In addition, it utilizes the concept of safe regions to reduce the number of updates.
In particular, each object p is assigned a circular or rectangular region, such that p needs to issue an update only if it exits this area (otherwise, it does not influence the result of any query).
MQM [CHC04], another range monitoring method, partitions the workspace into rectangular subdomains.
Each object in the system is assigned a resident domain, consisting of adjacent sub-domains.
An object is aware only of the range queries intersecting its resident region, and reports its location to the server when it crosses the boundary of any of these queries.
The number of sub-domains that form an object's resident region depends on how many queries it can store and process concurrently.
When an object exits its resident region, it requests a new one from the server.
To decide the new resident region, the server uses a binary partitioning tree, which maintains for each sub-division of the workspace the queries that intersect it.
This method applies only to static ranges.
To deal with moving range queries, Gedik and Liu [GL04] propose another distributed system, called Mobieyes.
Mobieyes partitions the workspace using a grid and maintains the monitoring regions of the queries.
The monitoring region of a query is defined as the union of the grid cells it can potentially intersect, provided that its center remains within its current cell.
Objects falling in the monitoring region of a query receive information about the query position and velocity, and notify the server when they enter or leave the predicted query region.
Note that this way the objects store locally and monitor their spatial relationship only with queries that they might actually affect when they move, saving their limited storage and processing resources.
On the other hand, queries issue updates to the server when they change velocity vector, or when they move out of their current cell.
Mokbel et al. [MXA04] present SINA, a system that centrally processes continuous range queries over mobile data.
SINA is based on shared execution and incremental evaluation.
Shared execution is achieved by implementing query evaluation as a spatial join between the objects and the queries.
Incremental evaluation implies that the query processor computes only the updates of the previously reported answers, as opposed to reevaluating the queries from scratch.
The result updates are either positive or negative.
The former category corresponds to objects entering the range of a query, while the latter one to objects leaving a range.
Both the object and the query indexes are implemented as disk-resident regular grids.
Let U P and U q be the set of objects and queries that issue location updates since the previous evaluation cycle.
Processing begins with the hashing phase that joins U P and U q in-memory to produce positive updates.
Next, the invalidation phase generates negative updates for objects in U P that move out of their current cell and queries in U q that exit cells that they used to overlap with.
Finally, movement within the same cell is handled in the joining phase; for each cell that contains objects in U P or intersects queries in U q , SINA joins the new objects with the existing queries, and the new queries with the static objects.
The resulting updates are merged with the updates of the previous phases (potentially canceling out some of them), and are reported to the client.
All the aforementioned methods focus on range query monitoring, and their extension to NN queries is either impossible or nontrivial.
Henceforth, we discuss algorithms that target explicitly NN processing.
Koudas et al. [KOTZ04] describe DISC, a technique for e-approximate k-NN queries over streams of multidimensional points.
The returned k th NN lies at most e distance units farther from q than the actual k th NN of q. DISC partitions the space with a regular grid of granularity such that the maximum distance between any pair of points in a cell is at most e. To avoid keeping all arriving data in the system, for each cell c it maintains only K points falling therein and discards the rest.
It is proven that an exact k-NN search in the retained points corresponds to a valid ek-NN answer over the original dataset provided that k≤K. DISC indexes the data points with a B-tree that uses a space-filling curve mechanism to facilitate fast updates and query processing.
The authors show how to adjust the index to: (i) use the minimum amount of memory in order to guarantee a given error bound e, or (ii) achieve the best possible accuracy, given a fixed amount of memory.
DISC can process both snapshot and continuous ek-NN queries.
Yu et al. [YPK05] propose a method, hereafter referred to as YPK-CNN 1 , for continuous monitoring of exact k-NN queries.Objects are assumed to fit in main memory and are indexed with a regular grid of cells with size δ×δ.
YPK-CNN does not process updates as they arrive, but directly applies the changes to the grid.
Each NN query installed in the system is re-evaluated every T time units.
When a query q is evaluated for the first time, a twostep NN search technique retrieves its result.
The initial step visits the cells in a square R around the cell c q covering q until k objects are found.
Figure 2.1a, shows an example of a single NN query where the first candidate NN is p 1 with distance d from q; p 1 is not necessarily the actual NN since there may be objects (e.g., p 2 ) in cells outside R with distance smaller than d. To retrieve such objects, the second step searches in the cells intersecting the square SR centered at c q with side length 2⋅d+δ, and determines the actual k NN set of q therein.
In Figure 2.1a, YPK-CNN processes p 1 up to p 6 and returns p 2 as the actual NN.
The accessed cells appear shaded.
When re-evaluating an existing query q, YPK-CNN makes use of its previous result in order to restrict the search space.
In particular, it computes the maximum distance d max of the current locations of the previous NNs (i.e., d max is the distance of the previous neighbor that moved furthest).
The new SR is a square centered at c q with side length 2⋅d max +δ.
In Figure 2.1b, assume that the current NN p 2 of q moves to location p′ 2 .
Then, the rectangle defined by d max = dist(p′ 2 ,q) is guaranteed to contain at least one object (i.e., p 2 ).
YPK-CNN collects all objects (p 1 up to p 10 ) in the cells intersecting SR and identifies the new NN p 1 .
Finally, when a query q changes location, it is handled as a new one (i.e., its NN set is computed from scratch).
Yu et al. also discuss the application of YPK-CNN with a hierarchical grid that improves performance for highly skewed data.
SEA-CNN [XMA05] focuses exclusively on monitoring the NN changes, without including a module for the first-time evaluation of an arriving query q (i.e., it assumes that the initial result is available).
Objects are stored in secondary memory, indexed with a regular grid.
The answer region of a query q is defined as the circle with center q and radius best_dist, where best_dist is the distance of the current k th NN.
Book-keeping information is stored in the cells that intersect the answer region of q to indicate this fact.
When updates arrive at the system, depending on which cells they affect and whether these cells intersect the answer region of the query, SEA-CNN determines a circular search region SR around q, and computes the new k NN set of q therein.
To determine the radius r of SR, the algorithm distinguishes the following cases: (i) If some of the current NNs move within the answer region or some outer objects enter the answer region, SEA-CNN sets r=best_dist and processes all objects falling in the answer region in order to retrieve the new NN set.
(ii) If any of the current NNs moves out of the answer region, processing is similar to YPK-CNN; i.e., r = d max (where d max is the distance of the previous NN that moved furthest from q), and the NN set is computed among the objects lying in SR.
Assume that in Figure 2.2a the current NN p 2 issues an update reporting its new location p′ 2 .
SEA-CNN sets r=d max =dist(p′ 2 ,q), determines the cells intersecting SR (these cells appear shaded), collects the corresponding objects (p 1 up to p 10 ), and retrieves the new NN p 1 .
(iii) Finally, if the query q moves to a new location q′, then SEA-CNN sets r = best_dist+dist(q,q′), and computes the new k NN set of q by processing all the objects that lie in the circle centered at q′ with radius r. For instance, in Figure 2.2b the algorithm considers the objects falling in the shaded cells (i.e., objects from p 1 up to p 10 except for p 7 and p 9 ) in order to retrieve the new NN (p 5 ).
Table 2.1 summarizes the properties of existing methods for monitoring spatial queries.
The processing type refers to whether mobile objects have some computing capabilities, or the entire processing cycle takes place in a central server.
For instance, Qindex is classified as a distributed method since the objects decide whether they exit their safe regions before they issue an update.
On the other hand, SINA follows a centralized paradigm since each object issues an update whenever it moves, independently of whether it influences any query or not.
In summary, the only existing techniques applicable to continuous monitoring of exact k-NN queries are YPK-CNN and SEA-CNN.
Similar to these methods CPM also assumes centralized processing (in main memory 2 ).
We compare CPM against YPK-CNN and SEA-CNN both qualitatively (in Section 4) and experimentally (in Section 6).
In the next section, we present CPM in detail.
In accordance with real-world scenarios, we assume 2D 3 data objects and queries that change their location frequently and in an unpredictable manner.
An update from object p is a tuple <p.id, x old , y old , x new , y new >, implying that p moves from (x old , y old ) to (x new , y new ).
A central server receives the update stream and continuously monitors the k NNs of each query q installed in the system.
Similar to existing approaches (e.g., YPK-CNN, SEA-CNN), we use a grid index since a more complicated datastructure (e.g., main memory R-tree) would be very expensive to maintain dynamically.
The extent of each cell on every dimension is δ, so that the cell c i,j at column i and row j (starting from the low-left corner of the data space) contains all objects with x coordinate in the range [i⋅δ, (i+1)⋅δ) and y co-ordinate in the range [j⋅δ, (j+1)⋅δ).
Conversely, an object with co-ordinates (x,y) belongs to the cell c i,j , where i= ⎣x/δ⎦ and j= ⎣y/δ⎦.
CPM (and SEA-CNN) can also be applied with the hierarchical grid of [YPK05].
Section 3.1 describes the NN computation algorithm, which constitutes the core module of CPM.
Then, Sections 3.2 and 3.3 discuss the handling of location updates.
The query point c qThe cell containing q nThe number of queries installed in the system dist(p,q)Euclidean distance from object p to query point q best_NNThe best NN list of q best_distThe distance of the k th NN from q mindist (c,q) Minimum distance between cell c and query point q Table 3.1: Frequently used symbols and functions Given a cell c and a query q, mindist(c,q) is the minimum possible distance between any object p∈c and q. Let best_NN be the list of the k best NNs (of q) found so far, and best_dist be the distance of the k th of them.
If mindist(c,q)≥best_dist, we can safely prune c because it cannot contain any object lying closer to q than any of the current NNs.
Based on this observation, a naive way to process a NN query q in P, is to sort all cells c∈G according to mindist(c,q), and visit them in ascending mindist(c,q) order.
For each considered cell, we compute dist(p,q) for the objects p inside, and update accordingly the best_NN list.
The search terminates when the cell c under consideration has mindist(c,q) ≥ best_dist.
Figure 3.1a illustrates this process for a 1-NN query q.
The algorithm visits only the shaded cells and encounters in total two objects, p 1 and p 2 .
Between them, p 2 is returned as the result of the query.
It can be easily shown that the above algorithm processes only the cells that intersect the circle centered at q with radius equal to the distance between q and its k th NN.
These cells have to be visited anyway in order to avoid false misses; therefore, the naïve algorithm is optimal in terms of the number of processed cells.
Nevertheless, in practice it may be very expensive, since it requires computing the mindist for all cells and subsequently sorting them.
CPM overcomes this problem and avoids unnecessary computations by utilizing a conceptual space partitioning.
Each rectangle rect is defined by a direction and a level number.
The direction could be U, D, L, or R (for up, down, left and right) depending on the relative position of rect with respect to q.
The level number indicates the number of rectangles between rect and c q .
Lemma 3.1 regulates the visiting order among rectangles of the same direction.
Lemma 3.1: For rectangles DIR j and DIR j+1 of the same direction DIR with level numbers j and j+1, respectively, it holds that mindist(DIR j+1 ,q) = mindist(DIR j ,q) + δ.Proof: Without loss of generality, assume that the direction is D.
The minimum distance of q from either rectangle equals the length of its projection on the top edge of the rectangle.
Since the side length of the cells is δ, it follows that mindist(DIR j+1 ,q) = mindist(DIR j ,q) + δ.
Based on Lemma 3.1, the NN computation module of CPM visits cells in ascending mindist(c,q) order, thus, preserving the property of processing the minimal set of cells.
In particular, CPM initializes an empty heap H and inserts (i) the cell c q with key mindist(c q ,q)=0, and (ii) the level zero rectangles for each direction DIR, with key mindist(DIR 0 ,q).
Then, it starts deheaping entries iteratively.
If the de-heaped entry is a cell, it examines the objects inside and updates accordingly the best_NN.
If the de-heaped entry is a rectangle DIR lvl , it inserts into H (i) each cell c∈DIR lvl with key mindist(c,q) and (ii) the next level rectangle DIR lvl+1 with key mindist(DIR lvl+1 ,q) = mindist(DIR lvl ,q) +δ.
The algorithm terminates when the next entry in H (corresponding either to a cell or a rectangle) has key greater than or equal to best_dist.
Proof of correctness: Let best_NN be the list of NNs returned by the algorithm, and best_dist be the distance of the k th NN.
Clearly, all cells c inserted at some point into H do not contain any better NN than the objects in best_NN.
This is guaranteed by the sorting property of the heap and the fact that dist(p,q) ≥ mindist(c,q) holds ∀p∈c.
In order to prove correctness, it suffices to show that each cell that was not inserted into H cannot contain any object closer to q than best_dist.
This part of the proof is based on the observation that, at any point, the heap H contains exactly four rectangle entries, one for each direction.
We call these rectangles boundary boxes.
Let the boundary box of direction DIR be DIR lvl .
The algorithm has considered all cells falling into rectangles DIR i with i<lvl.
From Lemma 3.1 it follows that all cells c belonging to DIR i with i>lvl have mindist(c,q)>mindist(DIR lvl ,q).
Since mindist(DIR lvl ,q) ≥ best_dist for each boundary box DIR lvl , and since all the unexplored space falls in some rectangle of some direction DIR with level greater than lvl, best_NN is the correct result of q. 񮽙 In the example of Figure 3.2a, CPM initially inserts into the heap the cell c q = c 4,4 and the rectangles of level zero, i.e., H = {<c 4,4 ,0>, <U 0 ,0.1>, <L 0 ,0.2>, <R 0 ,0.8>, <D 0 ,0.9>} (the numbers indicate mindist assuming that δ=1).
Then it de-heaps c 4,4 , which is empty 4 and ignored.
The next entry in H is U 0 .
CPM en-heaps the cells of U 0 , as well as rectangle U 1 and proceeds in the same way until it de-heaps <c 3,3 ,1>, where it finds the first candidate NN p 1 with best_dist=dist(p 1 ,q)=1.7.
Since, the next entry in H has key less than best_dist, it continues until it de-heaps c 2,4 and discovers the new candidate p 2 , with best_dist = dist(p 2 ,q) = 1.3.
The algorithm terminates (with p 2 as the NN) when the top heap entry is c 5,6 because mindist(c 5,6 ,q) ≥best_dist.
The final point that requires clarification concerns the bookkeeping information and related structures maintained for efficient search and handling of updates (to be discussed shortly).
CPM keeps (in main memory) a query table QT that stores for each query, its co-ordinates, the current result, the best_dist, the visit list, and the search heap H:• best_dist determines the influence region of q, i.e., the set of cells that intersect the circle centered at q with radius best_dist.
Only updates affecting these cells can influence the NN result.
• The visit list of q consists of all cells c processed during NN search, sorted on mindist(c,q).
Each cell entry de-heaped from H is inserted at the end of the list.
In our example, the visit list of q contains the shaded cells in Figure 3.2a.• The search heap H contains the cell and rectangle entries that were en-heaped, but not de-heaped during NN search (i.e., their mindist from q is greater than or equal to best_dist).
The contents of H in our example are the shaded cells in Figure 3.2b, plus the four boundary boxes U 2 , D 1 , L 2 , and R 1 .
In addition, each cell c of the grid is associated with (i) the list of data objects within its extents, and (ii) the list of queries whose influence region contains c. For example, cell c 3,3 contains q in its influence list, while c 5,6 does not.
The structures of the query table and the object grid Upon termination, the heap H is also stored in QT.
The algorithm is optimal in the sense that it processes the minimal set of cells for retrieving the NN set of q.
As opposed to the naïve algorithm discussed in the beginning of the section, the only redundant mindist computations concern the cells that were en-heaped but not de-heaped (i.e., the shaded cells in Figure 3.
Get the next entry of H 9.
If it is a cell entry <c, mindist(c,q)> 10.
For each object p∈c, update best_NN & best_dist if necessary 11.
Insert an entry for q into the influence list of c 12.
Insert <c, mindist(c,q)> at the end of visit_list 13.
Else // it is a rectangle entry <DIR lvl , mindist(DIR lvl ,q)> 14.
For each cell c in DIR lvl 15.
Insert <c, mindist(c,q)> into H 16.
Insert <DIR lvl+1 , mindist(DIR lvl ,q)+δ> into H 17.
Until the next entry has key ≥ best_dist or H is empty 18.
Update the influence region information of q to <q, best_dist> Assume, for simplicity, that a single update from p∈P arrives at a time.
The first step is to delete p from its old cell c old .
CPM scans the influence list of c old and identifies the queries that contain p in their best_NN set.
Specifically, for each query q (in the influence list of c old ), if p∈q.best_NN and dist(p,q) ≤ best_dist, then the k NN set of q remains the same, but the order of the NNs can potentially change.
Therefore, CPM updates the order in q.best_NN to reflect the new dist(p,q).
On the other hand, if p∈q.best_NN and dist(p,q) > best_dist (i.e., p is a NN that has moved farther from q than best_dist), there may exist objects (not in q.best_NN) that lie closer to q than p; thus, q is marked as affected to indicate this fact and ignored for now.
Next, CPM inserts p into its new cell c new , and scans the influence list of c new .
For each entry q therein, if q has been marked as affected it ignores it.
Otherwise, if dist(p,q) < q.best_dist, it evicts the current k th NN from the result, inserts p into q.best_NN, and updates q.best_dist.
The last step re-computes the NN set of every query q that is marked as affected.
Figure 3.5a illustrates update handling, assuming that object p 4 moves to position p' 4 .
CPM first deletes p 4 from the object list of c 5,6 , which has an empty influence list and, hence, the deletion does not affect any result.
Next, it inserts p 4 into its new cell c 5,3 , whose influence list contains an entry for q.
Since dist(p' 4 ,q) > best_dist, update handling terminates without any change in the result.
Assume that, later on, object p 2 moves to a new position p' 2 , as shown in Figure 3.5b.
Since the old cell c 2,4 contains q in its influence list, CPM checks the query table entry for q and detects that p 2 = best_NN.
Query q is marked as affected because dist(p' 2 ,q) > best_dist.
Get the next element <c, mindist(c,q)> of visit_list 4.
For each object p∈c, update best_NN & best_dist if necessary 5.
Insert an entry for q into the influence list of c 6.
Until the next element has key ≥ best_dist or visit_list is empty 7.
If the first entry in H has key < best_dist 8.
(Same as lines 7-17 of Figure 3.4) 9.
Set influence region information of q to <q, best_dist> So far we have dealt with processing a single update.
However, in the general case, there is a set U P of object updates that arrive during the time interval between two consecutive update handling cycles.
Processing incrementally each update in U P , as discussed in Section 3.2, guarantees correctness of the result.
However, this can be improved upon.
Consider the example of Figure 3.7a, where U P contains location updates for p 2 and p 3 .
If p 2 is processed first, q will be marked as affected (p 2 is the current NN and moves farther than best_dist), triggering the NN recomputation module.
This, however, is unnecessary because object p 3 moves closer to q than the previous best_dist, and we could simply replace the outgoing NN p 2 with the incoming p 3 .
In general, let O be the set of outgoing NNs (i.e., NNs that move farther from q than best_dist) and I be the set of incoming objects (i.e., objects other than the current NNs that move closer to q than best_dist).
The circle with center q and radius best_dist contains objects I ∪ best_NN -O.
If |I|≥|O| (where |I| and |O| are the cardinalities of I and O, respectively), this circle includes at least k objects.
Therefore, we can form the new NN set from the k best objects in I ∪ best_NN -O without invoking re-computation.
We embed this enhancement in the CPM algorithm as follows.
Before processing U P , we record the current best_dist of q.
During update handling, we maintain the in_list of the k best incoming objects (we do not need more than the k best incomers in any case).
At the end of the procedure, if in_list contains more than |O| objects, we merge the NNs in best_NN -O with in_list, and keep the best k among them to form the new result of q.
We resort to NN recomputation only if in_list contains fewer than |O| objects.
Figure 3.8 shows the complete update handling module of CPM.
An important remark is that if |I|≥|O|, the influence region of q shrinks.
Consequently, line 22 deletes q from the influence lists of the cells that no longer belong to it.
Note that, at any time, the visit list contains a superset of the cells in the influence region of q. Therefore, we can simply scan the cells c in the visit list with mindist(c,q) between the new and the old value of best_dist, and delete q from their influence lists.
The new influence region of q in our example is shown in Figure 3.7b.
After update handling, the visit list contains a superset of the cells in the influence region (i.e., the visit list still includes the shaded cells in Figure 3.7a).
Update Handling (G, QT, U P ) // Input= G: the grid, QT: query table, U P : set of updates in P 1.
For each query q in QT 2.
Set q.out_count=0; // Counter of outgoing NNs 3.
Initialize a sorted list q.in_list of size k 4.
For each update <p.id,x old ,y old ,x new ,y new >∈U P 5.
Delete p from its old cell c old 6.
For each query q in the influence list of c old 7.
If p∈q.best_NN 8.
If dist(p,q) ≤ q.best_dist // p remains in the NN set 9.
Update the order in q.best_NN 10.
Else // p is an outgoing NN 11.
Evict p from q.best_NN 12.
q In addition to data objects, queries may also be dynamic; i.e., some are terminated, new ones arrive at the system, while others move.
When a query is terminated, we delete its entry from QT and remove it from the influence lists of the cells in its influence region.
For new arrivals, we execute the NN computation algorithm of Figure 3.4.
When an existing query q moves, we treat the update as a termination of the old query, and an insertion of a new one, posed at its new location.
Queries that receive updates are ignored when handling object updates in order to avoid waste of computations for obsolete queries.
Figure 3.9 presents the complete CPM algorithm, covering all update types.
// Input= G: the grid indexing P, QT: query table 1.
In every processing cycle do 2.
U q = set of query updates 3.
U P = set of updates in P 4.
Invoke Update Handling (G, QT, U P ) ignoring queries in U q 5.
For each query q in U q 6.
If q is a terminated or a moving query 7.
Delete q from QT and from inf.
lists of cells in its inf.
region 8.
If q is a new or a moving query 9.
NN Computation (G, q); 10.
Inform client for updated results In general, the nearest neighbors of q are concentrated in a small area of the workspace and the influence region of q contains few cells.
Therefore, the influence list overhead, and the search heap/visit list sizes are expected to be small.
However, in case that the physical memory of the system is exhausted, we can directly discard the search heap and the visit list of q to free space.
Even without this information, CPM can continue monitoring q; the difference is that we have to invoke the NN computation algorithm from scratch (instead of NN re-computation) in line 24 of the update handling module of Figure 3.8.
objects on average).
As δ decreases, C inf increases, the shape of the influence region better approximates Θ q , and O inf approaches k (which is its minimum value).
On the other hand, a large δ leads to a small number of cells which, however, contain a large number of objects.
Figure 4.1 illustrates the effect of δ on C inf and O inf , assuming a 1-NN query q.
The shaded cells correspond to the influence region of q, which in Figure 4.1a contains C inf =39 cells and O inf =1 objects.
For a larger value of δ, in Figure 4.1b, C inf =8 and O inf =8.
To estimate C SH , assume for simplicity that q is located at the center of its cell c q .
The boundary boxes are of the same level in each direction.
It follows that C SH is the number of cells that intersect the circumscribed square of Θ q .
Thus, C SH can be approximated by 4⋅⎡best_dist/δ⎤ 2 .
Similar to C inf , C SH decreases as δ increases, e.g., in Figure 4.1a, C SH =49, while in Figure 4.1b,C SH =9.
In summary, the space consumed by the influence lists of the cells and the query table, is inversely proportional to δ 2 .
Similarly, both the size of the influence lists and the size of the query table are linear to n and k. Concerning the computational cost of CPM, index update time is linear to N and f obj .
The result maintenance task takes linear time with respect to n, and is expected to grow as f qry increases.
The time of NN computation for a new or a moving query depends strongly on the cell size; a small value for δ incurs high overhead due to heap operations, while a large value implies a high number O inf of processed objects.
(a) Small δ (b) Large δ Figure 4.1: The effect of δ on the performance of CPM Next, we illustrate the superiority of CPM over the existing methods through some update handling scenarios.
YPK-CNN reevaluates periodically every query q, even if the object updates have not affected any cell in its vicinity.
This is due to the fact that it does not include a mechanism for detecting queries influenced by location updates.
Furthermore, in the general case, YPK-CNN visits more cells than necessary when performing NN search for moving and new queries.
Consider the 1-NN computation of query q in Figure 4.2a.
As discussed in Section 2 (the example is the same as Figure 2.1), YPK-CNN processes 25 cells and six objects (p 1 up to p 6 ).
Finally, it also incurs redundant computations for static queries.
Assuming that in Figure 4.2b the current NN p 2 moves to location p′ 2 , YPK-CNN processes 49 cells and ten objects (p 1 up to p 10 ).
Clearly, the unnecessary computations increase with dist(p′ 2 ,q).
On the other hand, CPM (i) only processes queries whose influence region intersects some updated cell, and (ii) the NN computation and re-computation modules restrict the search space to the minimum number of cells around q (i.e., shaded cells in Figure 4.2).
SEA-CNN also performs redundant computations in several cases.
First, assume that the only updates are from incoming objects and/or NNs that move within distance best_dist from q. For instance, in Figure 4.3a, p 6 moves closer to q than best_dist.
SEA-CNN visits all cells intersecting the circle centered at q with radius r = best_dist and determines the new NN (p' 6 ) among the processed objects p 1 , p 2 and p' 6 .
On the other hand, CPM directly compares dist(p' 6 ,q) with best_dist and sets p' 6 as the result without visiting any cells.
When k is larger, the computational waste of SEA-CNN increases because it considers a higher number of objects, even though there might be few changes in the result.
Another weak point of SEA-CNN concerns handling of outgoing NNs, which is similar to YPK-CNN.
Recall that when p 2 moves to p′ 2 , SEA-CNN processes ten objects p 1 up to p 10 (see Figure 2.2a), while CPM considers only four objects (see Figure 4.2b).
SEA-CNN incurs higher cost than CPM also in the case that q changes position.
In Figure 4.3b, assuming that q moves to q′, CPM considers only cells intersecting the circle with center at q′ and radius dist(p 5 ,q′), and retrieves the NN (p 5 ) by processing only two objects (p 4 and p 5 ) in total.
SEA-CNN considers 33 cells and eight objects.
A final remark about SEA-CNN is that it does not handle the case where some of the current NNs go off-line.
On the contrary, CPM trivially deals with this situation by treating off-line NNs as outgoing ones.
Summarizing, the speed of the objects does not affect the running time of CPM since update handling is restricted to the influence regions of the queries.
On the other hand, the performance of both YPK-CNN and SEA-CNN (as also observed in [YPK05] and [XMA05]) degrades with object speed because the search region for a static query is determined by how far the furthest previous NN has moved since the last evaluation.
For moving queries, CPM examines the minimum possible number of cells (which is independent of the query moving distance), whereas the cost of SEA-CNN increases with the velocity of q.
In this section we extend the CPM algorithm to aggregate NN queries starting with the sum function.
Given a set of query points Q = {q 1 ,q 2 ,…,q m }, a sum ANN query continuously reports the data object p that minimizes adist(p,Q) = ∑ qi∈Q dist(p,q i ).
The basis of our method remains the conceptual partitioning of the space around the query Q.
Since Q now consists of a set of query points, the partitioning applies to the space around the minimum bounding rectangle M of Q. Figure 5.1a exemplifies the partitioning into rectangles in the case of a 1-ANN query Q = {q 1 ,q 2 ,q 3 }.
We define amindist(c,Q) = ∑ qi∈Q mindist(c,q i ), which is a lower bound for the distance adist(p,Q) of any object p∈c.
The definition of amindist(DIR lvl ,Q) for a rectangle DIR lvl is similar.
The cell processing order is derived by corollary 5.1, which is based on the same geometric observations as Lemma 3.1 (and, hence, we omit its proof).
Corollary 5.1 (f=sum): For rectangles DIR j and DIR j+1 of the same direction DIR with level numbers j and j+1, it holds that amindist(DIR j+1 ,Q) = amindist(DIR j ,Q) + m⋅δ, where m is the number of points in Q.
The ANN search module of CPM is essentially the same as the algorithm in Figure 3.4.
The difference is that in the beginning of the search, we en-heap (in line 4) all cells c intersecting M.
The sorting key is amindist(c,Q) and amindist(DIR lvl ,Q) for the enheaped cells and rectangles, respectively.
When an object p is processed, we compute adist(p,Q) and update accordingly the list of best ANNs found so far (i.e., best_NN).
The algorithm terminates when the next entry in H has amindist greater than or equal to best_dist.
In our example, the algorithm terminates with p 2 as the result, after processing all the shaded cells in Figure 5.1b. Similar to Section 3.1, the influence region of Q is the set of cells c with amindist(c,Q)≤best_dist; only updates affecting these cells can change the ANN result.
Note that the influence region of a query is no longer a circle, but has an irregular shape (i.e., the shaded region in Figure 5.1b).
Update handling is the same as in Section 3, the difference being that we use the aggregate distance function instead of the Euclidean one.
When f=min, an ANN query Q retrieves the object(s) in P with the smallest distance(s) from any point in Q.
The ANN search considers cells and rectangles in ascending amindist order.
For a cell c, amindist(c,Q) = min qi∈Q mindist(c,q i ), while for a rectangle DIR lvl , amindist(c,DIR lvl ) = min qi∈Q mindist(DIR lvl ,q i ).
Corollary 5.2 dictates the cell processing order.
Corollary 5.2 (f=min or f=max): For rectangles DIR j and DIR j+1 of the same direction DIR with level numbers j and j+1, it holds that amindist(DIR j+1 ,Q) = amindist(DIR j ,Q) + δ.The ANN search and update handling modules of CPM are similar to the sum case.
Furthermore, for the min function, we can improve the O(m) time required to compute amindist(DIR 0 ,Q) to O(1).
The MBR M of Q contains by definition one point of Q on each edge.
Therefore, computing amindist(DIR 0 ,Q) for each direction DIR reduces to calculating the minimum distance between rectangle DIR 0 and the closest edge of M. For example, amindist(D 0 ,Q) equals to the distance between the top edge of D 0 and the bottom edge of M.
An interesting observation about the min aggregate function is that the influence region of Q contains cells that intersect at least one of the circles centered at some q i with radius best_dist.
Figure 5.2a shows an example where Q = {q 1 ,q 2 ,q 3 } and f=min.
The result of the query is p 2 , and the influence region of Q appears shaded.
When f=max, CPM monitors the object(s) of P that have the lowest maximum distance(s) from points in Q. For each cell c, amindist(c,Q) = max qi∈Q mindist(c,q i ), while for each boundary box DIR lvl , amindist(DIR lvl ,Q) = max qi∈Q mindist(DIR lvl ,q i ).
Corollary 5.2 holds also in the case of max, whereas computing amindist(DIR 0 ,Q) for each direction DIR can be performed in O(1) time: amindist(DIR 0 ,Q) equals the minimum distance between DIR 0 and the opposite edge of M.
In Figure 5.2b we illustrate the case where Q = {q 1 ,q 2 ,q 3 } and f=max.
The result of the query is object p 4 , and the corresponding influence region consists of the shaded cells.
propose algorithms for static datasets indexed by R-trees.
The adaptation of CPM to this problem inserts into the search heap only cells and conceptual rectangles that intersect the constraint region.
Assume, for instance, that in Figure 5.3 we want to monitor the NN to the northeast of q. CPM en-heaps only the cells c 4,4 , c 4,5 , c 5,4 , c 5,5 and rectangles U 0 , R 0 , U 1 , R 1 .
Inside c 5,5 , object p 3 is identified as the NN.
Note that object p 1 (the unconstrained NN) is not encountered at all since its cell is not visited, whereas p 2 is processed but not reported.
In this section we evaluate the performance of CPM and compare it with YPK-CNN and SEA-CNN.
In accordance with the experimental study of [XMA05], our datasets are created with the spatiotemporal generator of [B02].
The input of the generator is the road map of Oldenburg (a city in Germany).
The output is a set of objects (e.g., cars, pedestrians) moving on this network, where each object is represented by its location at successive timestamps.
An object appears on a network node, completes the shortest path to a random destination, and then disappears.
We use the default velocity values of the generator for slow, medium, and fast object speeds.
Objects with slow speed cover a distance that equals 1/250 of the sum of the workspace extents per timestamp.
Medium and fast speeds correspond to distances that are 5 and 25 times larger, respectively.
The NN queries are generated similarly, i.e., they are objects moving on the same network, but they stay in the system throughout the simulation.
The queries are evaluated at every timestamp and the simulation length is 100 timestamps.
In the implementation of SEA-CNN, we use the NN search algorithm of YPK-CNN to compute the initial results of the queries, or to retrieve the new NN sets when some of the current NNs disappear.
Next we examine scalability issues.
Figure 6.2a measures the effect of the object population N on the running time.
The generator is tuned so that the average object population during the simulation equals the desired value N. Similarly, Figure 6.2b illustrates the CPU overhead as a function of the number n of queries in the system.
The cost of all algorithms increases linearly to both N and n. However, YPK-CNN and SEA-CNN are much more sensitive than CPM to these parameters, confirming the scalability of our approach.
Note that a cell may be accessed multiple times within a cycle, if it is involved in the processing of multiple queries.
For CPM, cell accesses occur during the NN computation algorithm (for moving queries), and during NN re-computation (for stationary queries, when there are more outgoing NNs than incomers).
YPK-CNN re-evaluates the queries in every timestamp, and therefore induces cell visits for each query in every processing cycle.
SEA-CNN accesses cells whenever some update affects the answer region of a query and/or when the query moves.
CPM significantly outperforms its competitors because: (i) it does not search the grid if the update information suffices to maintain the results, and (ii) even if the updates necessitate computation from scratch or re-computation of the NN sets, CPM processes the minimal number of cells.
An interesting observation is that for k=1 and k=4, CPM accesses less than one cell per query on the average.
This happens because queries of case (ii) have a small cost (i.e., 1-2 cell visits), which is counter-balanced by queries of case (i) that do not incur any visits.
Figure 6.5a compares the performance of CPM, YPK-CNN and SEA-CNN versus the percentage of objects that move within a timestamp (i.e., the object agility f obj ).
As expected (see Section 4.1), the running time of CPM scales linearly with the object agility, due to the increasing index update cost.
In order to quantify the effect of the query agility f qry (i.e., the probability that a query moves within a timestamp), we vary f qry from 10% to 50% and keep the remaining parameters fixed to their default values.
As shown in Figure 6.5b, the CPU time of CPM increases linearly with f qry because NN computations (for moving queries) are more expensive than result maintenance for static queries.
Note that YPK-CNN is rather insensitive to the query agility because the incremental maintenance of the NN set (for stationary queries) has similar cost to the two-step NN computation (for moving queries).
(a) Effect of object agility (f obj ) (b) Effect of query agility (f qry ) Figure 6.5: CPU time versus object and query agilityIn the remaining two experiments, we compare individually the NN computation and result maintenance modules of the alternative methods.
First, we monitor 5K constantly moving queries (i.e., queries that issue location updates in every timestamp), while varying the object population N.
The query results are computed from scratch at every processing cycle; therefore, we can study the efficiency of the NN computation modules.
SEA-CNN is omitted (since it does not include an explicit mechanism for obtaining the initial NN set).
As shown in Figure 6.6a, CPM outperforms YPK-CNN and the performance gap increases with N. Finally, we process 5K static queries (i.e., f qry =0%), while varying the object population N.
This way we eliminate the NN computations from scratch (apart from the initial query evaluation) and measure the pure result maintenance cost.
As shown in Figure 6.6b, the behavior of YPK-CNN and SEA-CNN is similar, while CPM induces considerably fewer computations.
This paper investigates the problem of monitoring continuous NN queries over moving objects.
The task of the query processor is to constantly report the results of all queries, as location updates stream by from both the objects and the queries.
Our contribution is an efficient processing method, referred to as the conceptual partitioning monitoring (CPM) algorithm.
CPM is based on a conceptual partitioning of the space around each query q, in order to restrict the NN retrieval and the result maintenance computations to objects that lie in the vicinity of q.
The core of CPM is its NN computation module, which retrieves the first-time results of incoming queries, and the new results of existing queries that change location.
This module produces and stores book-keeping information to facilitate fast update handling.
Keeping the NN set of a query q up-to-date is performed by processing on-line the object updates as they arrive.
If the new NN set of a query can be determined solely by the previous result and the set of updates, then access to the object grid G is avoided.
Otherwise, CPM invokes the NN re-computation module, which uses the book-keeping information stored in the system to reduce the running time (compared to NN computation from scratch).
CPM is a generally applicable technique, since it does not require any knowledge about the object or query moving patterns (e.g., velocity vectors), and can concurrently process multiple (static or moving) queries.
We analyze its performance and compare it with the existing state-of-the-art methods.
As demonstrated by a qualitative analysis and by an extensive experimental study, CPM outperforms its competitors.
Finally, to support the generality of the proposed methodology, CPM is applied to aggregate NN monitoring, where a query consists of a set of points and the optimization goal depends on an aggregate function (such as sum, min and max).
In the future, we intend to explore the problem of continuous monitoring for variations of NN search, such as reverse NNs.
A preliminary approach on this topic considers one-dimensional streams and aggregate reverse NN [KMS02].
It would be interesting to develop alternative approaches for the continuous monitoring of multiple (conventional) reverse NN queries in spaces of higher dimensionality.
This work was supported by grant HKUST 6180/03E from Hong Kong RGC.
The authors would like to thank Kevin Di Filippo for proof-reading the paper.
