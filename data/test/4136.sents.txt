Denial-of-Service (DoS) attacks pose a severe threat to the availability of web applications.
Traditionally, attackers have employed botnets or amplification techniques to send a significant amount of requests to exhaust a target web server's resources, and, consequently, prevent it from responding to legitimate requests.
However, more recently, highly sophisticated DoS attacks have emerged, in which a single, carefully crafted request results in significant resource consumption and ties up a web applica-tion's back-end components for a non-negligible amount of time.
Unfortunately, these attacks require only few requests to overwhelm an application, which makes them difficult to detect by state-of-the-art detection systems.
In this paper, we present Rampart, which is a defense that protects web applications from sophisticated CPU-exhaustion DoS attacks.
Rampart detects and stops sophisticated CPU-exhaustion DoS attacks using statistical methods and function-level program profiling.
Furthermore , it synthesizes and deploys filters to block subsequent attacks, and it adaptively updates them to minimize any potentially negative impact on legitimate users.
We implemented Rampart as an extension to the PHP Zend engine.
Rampart has negligible performance overhead and it can be deployed for any PHP application without having to modify the application's source code.
To evaluate Rampart's effectiveness and efficiency, we demonstrate that it protects two of the most popular web applications, WordPress and Drupal, from real-world and synthetic CPU-exhaustion DoS attacks, and we also show that Rampart preserves web server performance with low false positive rate and low false negative rate.
Denial-of-Service (DoS) attacks are a class of attacks that aim to deteriorate the target system's availability and performance.
They prevent the system from handling some or even all requests from legitimate users, by overwhelming its available resources, e.g., network bandwidth, disk space, memory, or CPU time.
Consequently, users might experience long delays when interacting with the victim system, or they might be completely unable to access it.
Availability and performance are essential to high-profile web servers, such as those operated by banks, news organizations, and governments, however, which are regular targets of DoS attacks [9,21].
To degrade the performance of web servers, a common practice is to launch Distributed DoS attacks (DDoS) that flood the target system with numerous requests.
Specifically, among other attacks, attackers might command thousands of computers (or more) to send attack traffic, or they might spoof the victim's IP address to launch reflected attacks [29,34].
Fortunately for defenders, these attacks incur comparatively high cost for the attackers (e.g., acquiring a large-size botnet to mount the attack) and they can often already be detected by state-of-the-art network-level defense mechanisms [23-25, 30, 31].
Unfortunately, sophisticated DoS attacks gained significant traction recently.
In sophisticated attacks, attackers use low-bandwidth, highly targeted, and applicationspecific traffic to overwhelm a target system [8,12,14,22].
Different from traditional DDoS attacks that rely on flooding a victim system with an extensive amount of traffic, sophisticated DoS attacks require less resources and utilize a lower volume of intensive requests to attack the victim system's availability.
Specifically, attackers target expensive or slow execution paths of the victim system.
For example, an intensive attack might request the system to calculate computationally-expensive hashes for millions of times by specifying an unusually high iteration count for the bcrypt function.
Particularly problematic is that sophisticated DoS attacks are difficult to detect by state-of-the-art defenses, such as source address filtering or traceback mechanisms, because they were designed to mitigate large-scale network-layer DDoS attacks [18, 23- 25, 30, 31, 36, 37].
In this paper, we design and implement a defense mechanism, Rampart, to protect a web application's back end from sophisticated DoS attacks.
Rampart aims to mitigate attacks that overwhelm the available CPU resources (CPU time) of a web server through low-rate applicationlayer attack traffic, which we call CPU-exhaustion DoS attacks.
Therefore, we design Rampart to accurately and efficiently detect and stop suspicious intensive attacks that may cause CPU exhaustion, and to be capable to block future attacks, without negatively affecting the application's availability for legitimate users.Developing such a defense is challenging.
First, attack requests can blend in well with normal requests: Similar to requests sent by legitimate users, they also arrive at a low rate.
Moreover, attack requests are generally wellformed, and, thus, do not cause the application to crash or throw an exception except for possibly resource exhaustion exceptions (e.g., a stack overflow exception).
In turn, it is difficult to differentiate these two kinds of requests, i.e., it is non-trivial to block only attack requests without also incorrectly blocking legitimate requests.
Since a legitimate request can be mistakenly labeled as suspicious, the defense system has to quickly detect and revoke any false positive filter that blocks legitimate requests, to not reduce the application's availability unnecessarily.To address these challenges, we leverage statistical methods and fine-grained context-sensitive program profiling, which allows us to accurately detect and attribute CPU-exhaustion DoS attacks.
Specifically, Rampart actively monitors all requests to precisely model the resource usage of a web application at the function-level.
It then dynamically builds and updates statistical execution models of each function by monitoring the runtime of the function called under different contexts.
Upon arrival of a new request, the request is then constantly checked against the statistical models to detect suspicious deviation in execution time at runtime.
Rampart lowers the priority of a request that it labeled as suspicious by aborting or temporarily suspending the application instance that is serving it, depending on the server's load.
To prevent pollution attacks against the statistical models, Rampart collects only profiling measurements of normal requests that do not cause a CPU-exhaustion DoS and that do not deviate much from the norm observed in the past.
It also enforces a rate limit by network address.Rampart can deploy filters to prevent future suspicious requests from over-consuming the server's CPU time.
It employs an exploratory algorithm to tackle the problems of false positive requests and false positive filters.
Specifically, when a true positive attack request is detected, a filtering rule is deployed to block similar suspicious requests, which might include legitimate requests (false positives).
Rampart dynamically removes the deployed filter once the attack ends, to recover service for any legitimate users who might have been affected by the filter.
Similarly, a false positive filter might be created if a legitimate request was incorrectly identified as suspicious.
To not negatively impact an application's availability for future legitimate requests, Rampart periodically evaluates (explores) all generated filter policies and deactivates false positive filters.
In turn, this algorithm allows Rampart to rapidly and intelligently discover false positive rules, while simultaneously thwarting true attacks.We design Rampart as a general defense against CPUexhaustion DoS attacks.
Importantly, to be protected by Rampart, it is not necessary to modify a web application or its source code in any way.
To emphasize the practicality of Rampart, we implemented a prototype of Rampart for PHP, which remains the most popular server-side programming language today [5].
Moreover, we thoroughly evaluated our prototype implementation, and we find that it incurs negligible performance overhead of less than an additional 3 ms for processing a request, i.e., roughly 0.1% of the median website load times [33].
Finally, we demonstrate that Rampart can effectively preserve the availability and performance of real-world, non-trivial web applications when they are victim of CPU-exhaustion DoS attacks.
We focus on two of the most popular open-source content management systems: Drupal and WordPress.
For example, when launching known attacks without Rampart's protection, then the average CPU usage increases from 32.21% to 95.05% for attacks on Drupal and from 42.21% to 94.14% for attacks on WordPress.
However, if protected by Rampart, then the average CPU usage remains comparatively stable at no more than 39.62% for Drupal and 51.40% for WordPress.
Last, we demonstrate Rampart's ability to protect the two applications from unknown vulnerabilities.We make the following technical contributions:• We present Rampart, which is a defense that detects and mitigates sophisticated CPU-exhaustion DoS attacks against web applications by using statistical models and function-level program profiling.
• We implement Rampart as an extension for the PHP Zend engine.
Our prototype has negligible performance overhead and it can be readily deployed for 83% of websites worldwide without requiring source code modifications.
• We develop algorithms to reduce the false positive rate when detecting attacks and to mitigate any negative impact of a false positive.
In turn, Rampart has a low false positive rate of less than 1%.
• We thoroughly evaluate Rampart with both realworld and synthetic vulnerabilities in two popular web applications, and we demonstrate that it effectively mitigates the impact of low-rate CPUexhaustion DoS attacks and preserves application availability and server performance.
In this section, we discuss the design of Rampart, our defense mechanism to detect and mitigate sophisticated application-layer CPU-exhaustion DoS attacks (Section 2.1).
Precisely, Rampart performs contextsensitive function-level profiling to learn precise execution models for each endpoint of an application (Section 2.2).
Whenever the server is overwhelmed, the system terminates or suspends anomalous prolonged application instances that it suspects to be suffering from an attack (i.e., instances it suspects are attempting to serve an attack request), to reduce the server's workload (Section 2.3).
Rampart employs a probabilistic algorithm to limit the false positive rate when stopping attacks (Section 2.4) and it constructs filtering rules to adaptively block future attacks using an exploratory algorithm (Section 2.5).
Finally, we discuss how to optimize the performance of Rampart (Section 2.6) and we detail our prototype implementation (Section 2.7).
Threat Model.
We consider a remote attacker that can send arbitrary HTTP(S) requests to a server serving a web application that is vulnerable to CPU-exhaustion DoS attacks.
The attacker can exploit the vulnerability by sending carefully crafted requests that will consume a significant amount of the web server's CPU time.
Her goal is to occupy all available CPU resources (cores) by sending multiple requests in parallel at a low rate.
Attack requests are well-formed, and, thus, they cannot be easily distinguished from legitimate requests through statistical features, such as the size, or the values of the payload.
She can also send legitimate requests to hide her attack among legitimate traffic.
She does not, however, send numerous attack requests within a very short time window, i.e., flooding the target server, because volumetric attacks with a high attack rate can be easily detected by complementary network-based defenses, and a low attack rate is already sufficient to overwhelm the web server.
Therefore, remote attackers who flood the web server with numerous requests at a time are outside the scope of our threat model.
To detect and stop low-rate CPU-exhaustion DoS attacks efficiently, we have to address five core challenges: Different from conventional DDoS attacks, low-rate application-layer DoS attacks are difficult to detect because they do not overwhelm a web server with large number of concurrent requests.
In turn, existing state-of-the-art network-layer defense mechanisms [18, 23-25, 30, 31, 36, 37] cannot detect these sophisticated DoS attacks.Attribution.
It is not straight-forward how to attribute an attack to its corresponding request(s).
In fact, it is particularly difficult because attack requests exercise legitimate functionality of the web application and they do not crash the application.
Indeed, they do not even hijack the application's control flow.
Prevention.
Developing a mitigation strategy that effectively stops the attacks while not negatively impacting the application's availability to normal users is not trivial.
For example, simplistic URL-based requests filtering techniques are ill-suited because attackers send requests to endpoints that normal users may also visit.
Relying on hand-crafted features and payload values is similarly problematic because they do not scale across applications or attacks, and because real attack payloads can depend on other parameters and they may even vary per user or time for some (unknown) vulnerabilities [1].
False Positives.
Naturally, any defense mechanism relying on statistical properties may have false positives, i.e., legitimate requests that are blocked by a filter, or requests that might incorrectly be identified as attack requests, and, hence, might cause a false positive filter to be deployed.
Considering the nature of low-rate application-layer DoS attacks, minimizing the false positive rate and the impact of false positive filters is a major challenge.
Performance.
Lastly, our defense mechanism must not introduce significant performance overhead to the protected application.
In particular, users must not notice any performance degradation when the application is running at normal load.
Rampart monitors and learns profiles (models) of a web application to establish the resources it normally requires.
We use the models as reference to detect suspicious requests (Section 2.3).
Web application commonly provide multiple endpoints for interaction.
Users can request each of those endpoints under different contexts (e.g., anonymous or authenticated), and each requires different and diverse processing resources.
Therefore, a profile at the application-level or request-level is not suitable to differentiate attack requests from normal requests.To precisely model the resource usage of a web application in different states, Rampart employs contextsensitive function-level program profiling.
Specifically, Rampart records the CPU time spent in a function (including time spent by the operating system's kernel on behalf of the function) instead of its wall clock time, because an application instance can be interrupted and rescheduled by the operating system before the function returns.
Rampart associates the measured execution time with a unique ID, representing the application's cur-rent execution state.
The ID is obtained from the calling context of the function and its name.
In particular, we encode the execution state (ID) by calculating the hash value of the application's past states and the name of the function being invoked.
We compute the state when a function c is invoked by its parent function p as follows: state(c) = hash(state(p), c).
As a result, the ID of a function frame depends on all of its parent callers.
To keep track of previous application states, Rampart maintains a shadow call stack, where each function frame stores the application state when it is called.
We push a covering main function to the bottom of the call stack to measure the total CPU time spent in an endpoint.
We employ the name of an endpoint (e.g., /login) as the initial state to differentiate functions with the same name (e.g., main) for different endpoints.When calculating the ID, we do not consider sibling functions, because a varying numbers of sibling functions may have returned, and they represent a similar state in the program.
In addition, executed sibling functions may not necessarily influence the execution of pending functions.
For example, suppose that a parent function p calls a child function s for a random number of times at runtime in a loop, before calling another child function c.
If we consider the previous sibling function s, we might have to maintain hundreds or thousands of records for different instances of it, even though they consume very similar amounts of resources.
Moreover, we would have different IDs for c for each run of the program.
Similarly, we do not use the argument values to encode the state of a function frame because they can also be dynamic.
A straw-man approach to detect CPU-exhaustion DoS attacks is to set a global timeout in the web application because a key characteristic of such attacks is that their requests take considerable time and consume numerous CPU cycles of the victim server.
However, legitimate requests can also time out and could be mistakenly identified as attack attempts.
For example, a user may upload a large file that could take a long time to transfer or process.Instead of such a straw-man approach, Rampart monitors the CPU usage of a web server to detect CPUexhaustion DoS attacks, which works because attackers want to occupy as many CPU cores as possible, so that the victim server is less responsive.
Compared with a (global) timeout, abnormally high CPU usage is a more accurate indicator.
Rampart continuously monitors the CPU usage of the server in a fixed interval T , and computes the average CPU usage r S over the last S observations, where S is a parameter that a system administrator configures to control the detection sensitivity.
If r S is greater than a pre-defined threshold R CPU (e.g., 90%), Rampart raises an alarm, thus, indicating that the server is overloaded, and likely victim to a CPU-exhaustion DoS attack.Intuitively, the requests that consumed the most CPU time can be identified as the culprits that caused the CPUexhaustion.
However, this can quickly lead to false negatives.
Considering a similar upload example to before, i.e., a few users are uploading large files while a real attack is being launched.
If the upload requests consumed slightly more CPU time than the attack requests, then these legitimate requests would be incorrectly detected as the responsible request (false positives) and the real attack requests would evade detection (false negative), although they might always take this long to process.Instead, Rampart leverages the function execution models it learned (Section 2.2) to detect suspicious requests that are statistically different from the historical profile.
Rampart periodically (e.g., every 250 ms) checks the CPU time spent in functions that have not returned yet, then it compares the time with the corresponding records in the profiling database, and, finally, it identifies one request as suspicious using the following method:Let T min and T max be the minimum and maximum timeout thresholds.
T C is the CPU time of a function f in the stack; µ and σ are the mean and standard deviation of T C with the ID state( f ) in the database; k is a parameter that represents the distance from the mean.
We rely on the Chebyshev inequality (Equation 1) to estimate how likely one observation differs from the mean without assuming any underlying distributions.
In particular, the probability of a random variable (X) that is k-standard deviations away from the mean is no more than 1/k 2 .
P(|X − µ| > kσ ) ≤ 1 k 2 (1) T C > min(max(µ + k × σ , T min ), T max )(2)Thus, Rampart labels a request as suspicious if T C of function f is more than kσ away from the mean (Equation 2).
Rampart can then terminate the application instances that serve such prolonged suspicious requests to release the occupied resources only when the web server is overloaded.
Otherwise, it repeats the same process until all functions have returned.
The minimum threshold T min prevents Rampart from reporting a request as suspicious if a deeper function with very short execution time (e.g., hundreds of microseconds) times out.The above method effectively detects suspicious requests for which the required CPU time deviates significantly from what Rampart observed previously.
When serving attack requests, then T C will be significantly higher for some frames in the call stack compared to legitimate requests.
On the contrary, when serving the fileuploading requests and if T C for all functions will be close to the means, then these requests will not be marked as suspicious (the requests always take this long to process).
If they are not close the means, however, then Rampart aborts these requests if the server is overwhelmed, because they are indistinguishable from attack requests.A limitation of Rampart is that it requires at least one observation of a function call before it can rely on the function to determine if a request is suspicious.
In practice, this training phase can be completed automatically by using a fuzzer, a crawler program to traverse the web application, or an existing test harness.
In fact, developers can easily collect training data when testing their applications before deploying them to production.
To reduce detection variance, we recommend letting Rampart make at least N observations (e.g., we use N = 5, Section 4) for each endpoint.
Although Rampart might have not collected execution profiles for all states (function calls) of a web application, it knows the execution profile of each endpoint and it can start detecting attack requests.Another limitation is that an attacker could pollute the profiling records of an application state she selects by gradually increasing the CPU time.
We make such pollution harder by sampling requests to be written into the profiling database at random.
Additionally, we restrict the number of samples that can be selected from a single network address or network prefix each day.
To further increase the difficulty for an attacker to pollute or drift profiling records, one can consider strategies that assign higher importance (weight) to older measurement records when computing the mean and standard deviation (Equation 2).
Rampart marks a request as suspicious when a function consumes significantly more CPU time than it normally does.
It stops serving such suspicious requests when the server is overloaded, due to a real attack or a surge in visitor traffic.
While this approach stops real attacks, it can also negatively impact normal users.
For example, a user may make requests that Rampart falsely detects as an attack because they take slightly more time than the threshold that Rampart calculated (Equation 2).
Such requests, together with real attack requests, would then be terminated by Rampart until the CPU usage is reduced below R CPU .
To reduce the impact of false positives, Rampart can rely on a probabilistic algorithm to determine if a suspicious request should be dropped.
The observation is that suspicious user requests usually do not consume as much CPU time as attack requests.
Instead of aborting all suspicious requests immediately, Rampart can be lenient initially and allow some requests to require slightly more time at a lower priority.
Periodically, RampartAlgorithm 1 Probabilistic Algorithm 1.
procedure Init 2.
c ← 0, ω ← 1, β ← 1 3.
T o ← 10 ms, s ← 5 ms, ˆ R CPU ← 75% 4.
σ ←StdDev() 5.
i ←Max(T o , σ ) 6.
Timer(Check, i)7.
procedure Check 8.
c ← c + 1 9.
r ← Usage CPU avg () 10.
if r > ˆ R CPU then 11.
p ← (c × ω + r × β ) 12.
if Random(0,100) ≤ p then 13.
AbortRequest() 14.
else 15.
SuspendRequest(s) then checks whether these requests have timed out and becomes stricter as the execution time of a timed-out function increases.
In other words, a suspicious request that is fast is likely to be completely processed before it would be killed.
On the contrary, a slow suspicious request is probably an attack (a true positive) and will be aborted eventually.We also consider the server workload when determining the probability to abort a suspicious request.
Specifically, the probability increases with the average CPU usage so that less CPU time is allocated to slow suspicious requests.
Rampart suspends the allowed suspicious requests temporarily to free CPU time for other requests, i.e., allowed suspicious requests have lower priority.Rampart's algorithm to decide whether a request should be aborted or suspended is shown in Algorithm 1.
The Init procedure is executed at a function timeout event.
ˆ R CPU is the (upper) CPU usage threshold.
σ is the standard deviation of CPU time of the function frame.
T o is the minimum interval that Rampart periodically evaluates if the suspicious request should be suspended or aborted.
A CPU timer that expires at every interval i is set in line 6.
The number of timeouts for a timer is c. ω and β correspond to the weights of the counter and CPU usage.
Rampart suspends suspicious requests for the duration of s (wall clock time).
The Check procedure is called after Init and whenever the evaluation timer expires.
If the web server's average CPU usage r is greater thanˆRthanˆ thanˆR CPU , then we calculate the probability p (in percent), and abort the request probabilistically (if it is larger than a random value, line 12).
Otherwise, the request is suspended.
In either case, the web server can serve other normal requests first.
Rampart can detect and stop CPU-exhaustion DoS attacks already, but the above design of Rampart does not prevent such attacks from affecting the victim server.
Rampart lets an attack request be served until it has consumed a significant amount of CPU time.
For example, we demonstrate in Section 4.1.1 that attackers can still occupy the web server's CPU and cause CPUexhaustion DoS by continuously sending such requests.
Thus, Rampart needs to block follow-up attack requests to further mitigate CPU-exhaustion DoS attacks.We face two challenges in designing a prevention strategy.
First, it is difficult to extract features to properly distinguish attack requests from legitimate requests.
According to our threat model (Section 2.1), the two kinds of requests can be very similar.
The only reliable information Rampart has learned about an attacker is the network address (which can be spoofed) and the endpoints that are used to exploit the vulnerability.
Therefore, Rampart builds filtering policies using the source IP (network) address, the requested URI, and the request parameters (e.g., the query string and post data, i.e., keys and values of PHP's GET and POST arrays) of an attack request.
Rampart then immediately rejects a follow-up request matching any filter without further processing it.An attacker cannot evade the filter by supplying decoy parameters because each parameter is matched independently.
She can, however, try to evade using spoofed IP addresses.
However, IP address spoofing is an orthogonal problem because:1.
Rampart is a host-based defense system; 2.
IP address spoofing is commonly used in reflected DDoS attacks, which are out of scope of our work;3.
Defenses exist against network-based attacks (e.g., ingress filtering, unicast reverse path forwarding) [17].
Second, a filter should be deployed neither perpetually nor ephemerally.
False positives cannot be completely eliminated due to randomness in web applications.
On the one hand, a user could be blocked forever by a persistent filter, unless she switches to a different IP address not used by an attacker.
On the other hand, if the lifespan of a filter is too short, then an attacker can wait and launch another round of attacks.To address the above challenge, we design an exploratory algorithm to adaptively adjust the lifespan of a filter, instead of setting a fixed lifespan.
Specifically, each filter is assigned with a primary lifespan when it is first created.
A matching request is immediately dropped during the filter's primary lifespan.
The filter transitions into an inactive state with a secondary lifespan when its primary lifespan expires.
During the secondary lifespan, Rampart lets the application serve one matched request at a time to explore the result of removing the filter.
Rampart aborts this request if a CPU-exhaustion DoS attack attempt is detected, and it renews the filter with a longer primary lifespan to penalize the attacker.
Otherwise, the filter is removed because it might have been created as a false positive or the attacks have stopped.We present the exploratory algorithm in Algorithm 2.
The Init-Rule procedure is invoked when a filtering rule is first created.
T p and T s are the rule's default primary and secondary lifespans (in seconds), which are set the server's administrator.
The primary lifespan expires at time t expiry .
ˆ R CPU andŘandˇandŘ CPU are the upper and lower CPU usage thresholds.
Together with parameter α and β , they control if Rampart should explore a matched request (line 13-16).
exploring represents Rampart's exploration state and is initialized to false.Rampart calls the Check-Rule procedure when a new request arrives.
Rampart drops all incoming requests (line 10) that match the rule (line 8) if it is still active (line 9).
After it transitions into the inactive state (line 11), Rampart may start an exploration if no one is active (line 12).
Other matching requests received during exploration are dropped (line 22).
Rampart decides if it should explore a request (line 12-15) with a probability depending on the current average server CPU usage r, and the parametersˆRparametersˆ parametersˆR CPU , ˇ R CPU , α, and β (line 5-6).
During exploration (line [16][17][18][19][20], the request is aborted immediately if it is detected as suspicious (line 17).
The counter c is incremented by one to set a larger new primary lifespan (line [18][19].
The rule is deleted if the secondary lifespan has expired (line 24).
This algorithm controls the upper bound of the rate that one attacker can cause CPU-exhaustion DoS on a web server with a unique combination of the fields in a filter.
In particular, in any T p +T s window, an attacker can cause at most two attacks, which Rampart immediately detects and stops.
She cannot evade detection by sending benign requests to hide attacks, because the rule would not be destroyed unless the attacker sends only one attack request in a T p + T s window.
She is further penalized for sending an attack request during the filter's second lifespan with a growing primary lifespan.
Therefore, an optimal attacker can cause only one successful attack in every T p + T s interval (other attacks are quickly stopped).
In turn, our algorithm allows Rampart to recover the service's availability for a false positive user as soon as the server has sufficient resources.
Rampart is unlikely to detect a false positive user request it explores as suspicious again, because the server load is expected to be lower than the upper CPU usage threshold that is used to detect attacks.
Otherwise, requests for one endpoint by a user leading to a false positive would temporarily if exploring = false then 13.
r ← Usage CPU avg () 14.
p ← α( ˆ R CPU −r×β ) ( ˆ R CPU + ˇ R CPU )15.
be refused as the server is overloaded and it assigns the suspicious requests a lower priority.
The user can still access other parts of the application as long as they do not depend on the blocked one.
Rampart is an in-line dynamic analysis system and, hence, may incur significant performance overhead.
Next, we discuss how we optimized its performance.
First, Rampart needs to make two system calls to measure the CPU time of a function call: one before the actual function call and one after it.
Here, the system call overhead can be magnitudes larger than the raw execution time when profiling some built-in functions, e.g., arithmetic functions.
Therefore, we want to avoid unnecessary system calls while profiling applications at a fine granularity.
One might consider the unprivileged RTDSC(P) instruction of x86 processors to query the Time Stamp Counter (TSC) efficiently.
Unfortunately, TSC is a global counter and shared among all processes running on the same processor, including unrelated processes, which is why we cannot use it as per-process CPU counter.
Instead, we disable profiling for built-in functions, as they take almost constant or negligible time.
The execution time of some functions, e.g., string manipulation, however, does strictly depend on its input and we need to take them into account.
Fortunately, their execution time is included when Rampart profiles their parent functions, thus, we do not measure them separately.We also introduce a parameter Max_Prof_Depth to control the overall profiling granularity.
It specifies the maximum number of function frames that Rampart profiles.
If Max_Prof_Depth is set to 1, then only the covering main function is profiled.
If Max_Prof_Depth is large, more functions are profiled, which may be inefficient as the measured CPU time is inclusive.
Practically, Rampart still blocks CPU-exhaustion DoS effectively with low overhead when trading some profiling precision for performance (Section 3 and Section 4).
Second, some overhead may be the result of input and output operations on past measurements.
To improve write performance, Rampart writes measurements in batch after each request has been completely processed.
To further mitigate contention, Rampart offloads database operations to a dedicated daemon that regularly processes the measurement data.Rampart also sets a wall clock timer to periodically query for historical profiling records of function frames that have not yet returned.
To improve performance here, Rampart can clear the timer after the first query to avoid interrupts because it knows when the request will be marked as suspicious.
Thus, Rampart can wait until then or until the request was processed, whichever comes first.Finally, Rampart can optionally sample one measurement every X requests, and, in turn, avoid the system calls to write out measurements for X − 1 requests.
The first set of system calls remain required to measure the elapsed CPU time in case of an attack.
Sampling also helps to defend against pollution attacks (Section 2.3).
We implemented a prototype of Rampart as an extension to the PHP Zend engine in roughly 2,000 lines of C code.
The Rampart PHP extension is loaded in each PHP process and thread for function profiling and to monitor CPU usage.
We use the function getrusage provided by Linux to measure the CPU time of a function spent by both the user code and the system calls.
The daemon for processing the profiling results is implemented in 400 lines of Python code.
We implemented Rampart for PHP because it remains the most popular server-side programming language today with a market share of 83% [5].
Rampart is language-agnostic, and it can be implemented for other server-side programming languages as it does not rely on any language-specific features.
Rampart is an in-line defense and therefore introduces some performance overhead during normal execution, which we evaluate in this section.
We also investigate the performance degradation when a web application is the victim of a CPU-exhaustion DoS attack.
For our evaluation, we protect two open-source web applications: Drupal 7.13 and WordPress 3.9.0.
We evaluate Rampart on these specific applications and versions because of their popularity and because they contain known real-world CPU-exhaustion DoS vulnerabilities.
Following, we first describe our experiment settings and the baseline performance of the two applications (Section 3.1), then we evaluate the performance overhead introduced by Rampart (Section 3.2), and, last, we look at the performance degradation caused by sophisticated DoS attacks with and without Rampart (Section 3.3).
For our experiments, we use two machines, one being web server and one being the client.
Both machines are running Debian Stretch (Linux Kernel 4.9.0).
The web server runs Apache 2.4.25 with PHP 7.0.19-1 on an Intel Xeon X3450 quad-core CPU with 2.67 GHz and 16 GB RAM.
The client is an Intel Xeon W3565 quad-core CPU with 3.2 GHz and 16 GB RAM.
Both machines are on the same local area network (LAN) to eliminate any randomness that might result from sending requests over the Internet.We created 256 user accounts after a fresh installation of each application, and we saved the application database to disk so that we can recover the state for reproducibility.
Afterward, we used some accounts to interact with the two applications.
We used OWASP Zed Attack Proxy (ZAP) as a network proxy to capture the interactions between the clients (users) and the applications.
We also crawled all the endpoints of each web application with ZAP's spider program, and we stored the correspond requests for replay.
We then removed requests for static files (e.g., JavaScript, Cascading Style Sheets, etc.) and we merged the remaining requests (generated by humans and the spider program) into the user trace for each application.
Based on this user trace, we developed a traffic generator that can replay the trace's requests sequentially.
It mimics multiple parallel users (replaying multiple interactions in parallel), of whom each is assigned one user account.To evaluate overall server performance, we measure performance of each web application with various traffic loads (number of users).
After each round of experiments, we reset the application to its initial state.
We repeated each experiment five times to report average performance metrics (N = 5).
Importantly, the traffic generator sends two consecutive requests with a 0.1 s pause in-between to simulate a large number of concurrent connections.
In practice, however, the interval between consecutive requests sent by a legitimate user are much larger.
For each request, we record the timestamps when it was sent (T start ) and when the corresponding response was received (T end ), and we compute the request processing time (RPT = T end − T start ).
Throughout the experiments, we also monitor the server's CPU usage.The baseline performance of the server running the two applications is shown in Table 1.
Naturally, the average server CPU usage increases as the traffic load increases.
With modest loads of no more than 32 user instances, the average RPT (ARPT) of WordPress did not vary much.
However, both applications exhibited significant performance degradation in their ARPT once load became heavier (64 user instances and higher).
For a fair evaluation, we use 32 user sessions in the remaining experiments.
Based on the same parameters, we measure the overhead that our prototype implementation may incur.
We report ARPT and average CPU usage in Table 2 for various values of Max_Prof_Depth, which is Rampart's parameter to control how many function frames are profiled.
Unsurprisingly, if more function frames are profiled (higher Max_Prof_Depth), then performance degrades more.
Specifically, for Drupal, the parameter does not negatively affect the ARPT, but its increase correlates with higher CPU usage.
For WordPress, the server performance remains close to its baseline performance (Table 1) while Max_Prof_Depth was less than five, but performance degrades when more function frames are profiled.To investigate how Max_Prof_Depth might influence server performance, we recorded the number of profiled function frames and the time spent processing the measurement results by our analysis daemon.
For each analysis iteration, our single-threaded analysis daemon sampled up to 100 measurement files because it could not process all files in real time if Max_Prof_Depth was greater than nine.
The time to process 100 measurements, the average number of unique profiled function frames, and the average number of profiled function frames are shown in serve any overhead in Drupal's request processing time.
For WordPress, the CPU overhead is 5.65% and Rampart introduces an additional 0.2 ms (0.83%) for the request processing time on average.
Overall, WordPress incurs slightly higher overhead than Drupal because more functions are profiled (Table 2).
Finally, we investigate the RPT of Drupal with 32 concurrent user instances with Rampart enabled (Figure 1).
The bottom of the figure shows the 5 th percentile, mean, and 95 th percentile of the RPTs for requests sent for each one second interval.
The x-axis is the time elapsed since the start of experiment and the y-axis is the RPT.
The number of in-flight requests (RIF) in each one-second window are shown in a green solid line, and the average server CPU usage is shown in a blue dashed line in the top figure.
Evidently, CPU usage remains modest throughout the experiment.
Following, we show how a only few attack requests can quickly exhaust the CPU (Section 3.3), and how Rampart preserves server performance (Section 4).
We measure the performance degradation of the server when a CPU-exhaustion DoS attack was launched against a web application.
Specifically, we evaluate two kinds attacks for both web applications: XML-RPC for both Drupal and WordPress (CVE-2014-5266 [4]), PHPass for Drupal (CVE-2014-9016 [2]) and Wordpress (CVE-2014-9034 [3]).
The XML-RPC attacks allow remote attackers to cause a CPU-exhaustion DoS by sending a large XML document containing a significant number of elements.
The PHPass attacks allow remote attackers to cause a CPU-exhaustion DoS by supplying a long password that is improperly handled by the password hashing functions.
We also evaluated several other CVEs (e.g., CVE-2012- 1588, CVE-2013-2173, and CVE-2014, which can similarly cause CPU-exhaustion DoS, which we omit due to space limitations.We use our traffic generator to send attack traffic from the client machine to the server.
Each generated attack payload takes Drupal and WordPress between 10 and 30 seconds to process.
We then launch multiple attackers concurrently via our traffic generator.
For each attacker session, the generator sends two consecutive requests with five seconds break in-between.
Assuming that the RPT for an attack request is 25 seconds, then the attack traffic rate with 30 attacker sessions is one attack request per second.
This rate is significantly lower than that of a typical DDoS attack (tens of thousands of requests per second or more).
Indeed, such sophisticated application-layer DoS attacks require significantly fewer resources to be successful.In our experiments, we configure the user traffic generator to run 32 user sessions (Section 3.2), and the attack traffic generator to operate 8 or 16 attacker sessions.
We launch the attack traffic generator five seconds after we started the user traffic generator.
As in our baseline performance experiments, we repeat each experiment five times to measure the average performance metrics, i.e., the server's CPU usage, the number of in-flight requests each second (RIF), and the request processing time (RPT) of user sessions and attacker sessions.
Rampart is disabled for all of these experiments.
For each figure, the middle and bottom graphs show the 5 th percentile, mean, and 95 th percentile of the RPT of user requests (middle) and attack requests (bottom) that were sent in each one second window.
The green and red solid lines in the top figure represent the RIF of user sessions and attacker sessions, and the blue dashed line shows the server's CPU usage.
A red solid vertical line in each three graphs indicates when we started the attack.
Launching 8 PHPass attacker sessions attack against Drupal (Figure 2), the server spends on average 42 seconds on processing one attack request.
The CPU remains almost fully occupied once we launch the attack, except for the five seconds break when we paused the attack.
In fact, the results show that an attacker sending only 0.17 requests per second (8 / (42 + 5)) can already exhaust CPU resources of a vulnerable server.
Performance degrades severely with 16 parallel attacker sessions, at which point the CPU usage stays close to 100% throughout the experiment.
Corresponding to doubling the number of attacker sessions, the server has to spend almost twice as much time (82 seconds, or 1.95x) to serve each request, likely because of the operating system's process scheduling.
For 16 attackers, the required attack rate is 0.18 requests per second (16 / (82 + 5)).
The results for the other three attacks, XML-RPC on Drupal, PHPass on WordPress, and XML-RPC on WordPress, are shown in Figure 3, Figure 4, and Figure 5.
The mean CPU usage and the ARPT for all the experiments is summarized in Table 3.
For Drupal, the two attacks consume between 52.4% and 62.84% additional CPU time and they cause a 36% slowdown in processing user requests.
The ARPT of WordPress is more sensitive to both attacks, causing an increase of 40% to 118% in ARPT and consuming between 41.65% and 51.93% additional CPU time.
For Rampart to be an effective defense, it must successfully preserve the availability of a web application from CPU-exhaustion DoS attacks.
Therefore, we first investigate whether Rampart can correctly detect and stop attacks exploiting known real-world CPU-exhaustion DoS vulnerabilities (Section 4.1).
Next, we look at whether Rampart can effectively protect web applications from unknown CPU-exhaustion DoS attacks (Section 4.2).
In We also study if Rampart may mistakenly mark a legitimate request as an attack request, i.e., a false positive, and what the consequences are.
For example, a user may initiate slow requests that appear similar to attack requests.
Blocking such requests while an active attack is occurring is acceptable because there is no good way to differentiate such requests from the attack requests (Section 2.1).
However, it is unnecessary and undesirable to constantly reject such legitimate requests when the application is not under attack.
We evaluate how Rampart can mitigate attacks exploiting the real-world vulnerabilities that we studied (Section 3.3).
We are particularly interested in understanding:1.
How well does Rampart help preserve server performance and availability when attacks occur?
2.
How long stays an aborted attack request alive before it is terminated by Rampart?
3.
How many attack requests are not aborted by Rampart, i.e., what is the false negative rate (FNR)?
4.
How many user requests are aborted, i.e., what is the false positive rate (FPR)?
To answer these questions, we perform the following experiments: First, we evaluate Rampart's ability to detect attack requests in the stop-only experiments (Section 4.1.1).
Here, Rampart uses the probabilistic algorithm (Algorithm 1) to lower a suspicious request's priority by either aborting or suspending it, but it does not deploy any filters to block requests.
In turn, Rampart checks all the requests sent by attackers.
Next, we evaluate whether Rampart can preserve server performance by stopping and filtering suspicious requests.
In the stop-and-filter experiments (Section 4.1.2), Rampart additionally uses the exploratory algorithm (Algorithm 2) to synthesize and deploy filters to block future attack requests.
Here, we set the primary lifespan (T p ) to 10 seconds and the secondary lifespan (T s ) to 30 seconds.
We assign a unique local IP address to each user/attacker session, so that Rampart can distinguish the different instances.We evaluate two threshold values (50% and 75%) for the CPU usage thresholdˆRthresholdˆ thresholdˆR CPU , which Rampart uses to determine if a server is under attack.
We report the average request processing time (ARPT), average server CPU usage, FPR, and FNR for user requests and attack requests over five runs per configuration.
The RPT of false positive requests that Rampart aborted are not included in the user ARPT.
In We summarize the results of the stop-only experiments in Table 4.
We observed no false negative in our experiments, i.e., all attack requests were detected and eventually aborted, which demonstrates that Rampart accurately detects CPU-exhaustion DoS attacks.
However, some user requests were also aborted by Rampart as false positives in the Drupal PHPass experiment with 8 attacker sessions.
Upon closer investigation of the logs and traffic traces of Drupal, some requests took the server more than several seconds to process, even when it was not under attack (black spikes in Figure 1).
Some of those requests were marked as suspicious because several function frames deviated from their execution models.
However, the overall impact was limited:1.
Not all such requests were aborted by Rampart.
2.
Requests of only a few users were aborted, although all users sent the same requests.
This is the case because Rampart only terminated application instances serving a suspicious request when the server was overloaded.
Nevertheless, the FPR is always less or equal to 0.33%, i.e., less than 18 out of 5,344 user requests were mistakenly aborted by Rampart.
At the same time, Rampart helps to preserve server performance and availability substantially, compared to the attack results without Rampart (Table 3).
The ARPT for user requests (ARPT-U) during the PHPass attacks on Drupal and WordPress are close to their baseline counterparts (Table 1).
However, ARPT-U during the XML-RPC attacks on the web applications did not improve significantly.
On the other hand, the ARPT for attack requests (ARPT-A) is long, with attack requests being processed for up to 2,294 ms (Drupal) and 787 ms (WordPress) before Rampart aborted them.
This explains why average CPU usage did not drop back to the baseline (Table 1) but remained slightly higher.
We also observe that PHPass attack requests consumed more CPU resource with a higher CPU usage thresholdˆRthresholdˆ thresholdˆR CPU .
Finally, we look at 8 attacker sessions launching the PHPass attack against Drupal withˆRwithˆ withˆR CPU set to 50% (Fig- ure 6).
The magenta dashed lines in the middle and bottom graphs represent the number of aborted user requests (middle) and attack requests (bottom).
In the first 20 seconds of the experiment, Rampart quickly aborted all attack requests because the server's CPU usage was above the threshold.
Some requests were aborted even when the CPU usage in the top figure appears to be lower than the 50% threshold, which is because Rampart monitors CPU usage at a shorter interval (10 ms), while the CPU data in the top figure was collected each second using the mpstat command.
When the server load decreased, the attack requests could occupy the CPU for up to five seconds until the CPU usage crossed the threshold again.
In turn, this behavior demonstrates the need for deploying filters to block suspicious requests to prevent CPU usage oscillation.
Nevertheless, Rampart detects and blocks attacks much earlier with a CPU threshold close to but above the expected CPU usage during normal operation.
We present the results of the stop-and-filter experiments in Table 5.
Analog to the stop-only experiments, we observed no false negative in the stop-and-filter experiments.
However, the FPR increased compared to the stop-only experiments because Rampart drops any request matching a filter created from false positive requests until the filter's primary lifespan has expired.
In fact, these events are evident in the Drupal PHPass experiment with 8 attacker sessions andˆRandˆ andˆR CPU = 50% (orange dashed line in Figure 7, which represents the number of requests that were dropped because of a filter).
Around the 35 th second and 39 th second, two user requests were detected and aborted as false positives and two matching filters were created.
As a result, 16 additional requests from these two users were also dropped in the following T p seconds.
The primary lifespan of the last rule then expired at the 49 th second.
Rampart then explored a matching request (the blue dashed line) at around the 58 th second according to the exploratory algorithm (Algorithm 2) and it detected that the filtering rule was a false positive.
Rampart's FPR in stop-and-filter mode is still negligible at less than 0.69%.
Although Rampart's stop-and-filter mode blocked some legitimate requests, it also immediately blocked the majority of attack requests (86.5%) and entirely prevented them from consuming any additional CPU time.
The remaining 21 attack requests (13.5%) were also all detected as suspicious and aborted.
In fact, 8 of the aborted requests were the initial requests sent by the 8 attackers, i.e., the earliest that any defense could have detected them as suspicious.
Rampart explored the remaining 13 requests and eventually also detected them as suspicious.
Since the attackers sent requests at an interval of five seconds, which is shorter than T s , Rampart incremented the primary lifespan of a filter as penalty each time an exploring request was detected as suspicious.Because Rampart blocked most of the attack requests immediately, it preserved the web server's performance as if no attack had occurred (Table 5).
In particular, the average CPU usage and the ARPT of user requests are much closer to their baseline (Table 1) compared to the stop-only experiments (Table 4).
The ARPT of attack requests is an order of magnitude smaller.
Overall, the results illustrate that Rampart can effectively protect web applications from known CPU-exhaustion DoS attacks using the exploratory algorithm (Algorithm 2).
The results for the remaining three experiments withˆR withˆ withˆR CPU = 50%, namely, XML-RPC on Drupal, PHPass on WordPress, and XML-RPC on WordPress, are shown in Fig Compared to static vulnerability analysis tools that look for specific features in the source code, Rampart does not require an application's source code, nor does it require any knowledge about specific CPU-exhaustion DoS vulnerabilities.
Instead, Rampart is a generic defense that automatically detects known and unknown applicationlevel CPU-exhaustion DoS attacks at runtime dynamically.We demonstrate Rampart's ability to detect and mitigate such attacks in web applications.
Beyond the vulnerabilities that we explored, we automatically inserted CPU-exhaustion DoS vulnerabilities into the source code of the two web applications at random locations.
We configured Rampart to record all invoked functions when serving a request for the two web applications, and we then inserted a vulnerability (Listing 1) into a function that was randomly chosen.
The vulnerable code calculates the hash value of a variable $v by repeatedly invoking the md5 function (line 11).
The number of iteration in the loop is controlled by the parameter $exp, which an attacker can set through the dos-exp query parameter.
In our experiment, attacker requests set $exp to 24 to cause CPU-exhaustion DoS (i.e., 2 24 md5 invocations).
For each application, we randomly chose 50 vulnerabilities (requests) and launched 16 attacker sessions.
We set the average CPU threshold R CPU to 75%.
All 50 vulnerabilities in WordPress were successfully exploited, while only 21 vulnerabilities in Drupal could be exploited because the other 29 vulnerable functions were not invoked.
They could not be invoked because they require to be set up by other requests beforehand, which we did not replay.We report the results with and without Rampart (Table 6).
The average CPU usage threshold to determine if Rampart successfully mitigated an attack against Drupal is 45% and for WordPress it is 55%.
Rampart successfully mitigates all attacks withˆRwithˆ withˆR CPU = 50%.
However, some attack requests were incorrectly classified as benign.
These false negatives occurred for Drupal because the server load was light (less than the 50% threshold) when those requests arrived.
Although Rampart did not abort those requests, it flagged them as suspicious.
Overall, the synthetic attacks experiments demonstrate that Rampart can detect and mitigate CPU-exhaustion DoS attacks regardless of the location of the vulnerable code, i.e., it can detect and mitigate attacks not only for front-facing code, but it can also detect and mitigate attacks for (third-party) library functions.
Our prototype is implemented as an extension to the PHP engine (and can be similarly implemented for other languages), and, thus, it can adapt to any change of an application's source code without requiring any manual interaction or reconfiguration.
Rampart can automatically detect new vulnerabilities that might be introduced by unintentional source code modifications.
On the contrary, a developer using a static vulnerability detection tool would need to run it each time she modifies the code.
Considering Rampart's effectiveness and low overhead, Rampart is a practical defense to protect applications from CPU-exhaustion DoS attacks.
We compare Rampart to the most relevant work, i.e., sophisticated DoS vulnerability detection, program profiling techniques, and anomaly detection.
DoS Vulnerability Detection.
CPU-exhaustion DoS attacks received significant attention from researchers over the past years.
Existing research focused on finding vulnerabilities (bugs) that can be exploited to launch sophisticated DoS attacks.
In turn, prevention of the attacks is manual by fixing the detected bugs before an application is deployed.
Safer performs static taint analysis and control-dependency analysis to identify loops and recursive calls whose execution can be controlled by a remote attacker [10].
Similarly, SaferPHP uses static taint anal- ysis to find loops whose execution can be influenced by network inputs [32].
It then uses symbolic execution to detect whether the network inputs can trigger the loops to run infinitely.
Xiao et al. proposed ∆Infer, which is an approach to detect workload-dependent performance bottleneck loops by inferring iteration counts of the loops using complexity models [35].
Torpedo detects second-order DoS vulnerabilities using taint analysis and symbolic execution [26].
SlowFuzz is a dynamic testing tool that generates inputs triggering worst-case algorithmic behavior for several well-known algorithms [27].
Although these systems can detect CPU-exhaustion bugs before the applications are deployed, they commonly rely on additional manual analysis to confirm vulnerabilities or reduce false positives.
They also incur additional opportunity cost because developers need to run them whenever the application's code or any of its dependencies are updated.
Most important, they do not prevent attacks after an application has been deployed.Instead of using static program analysis, Rampart dynamically monitors a web application's state and determines automatically if the current state deviates significantly from the expected state.
In turn, Rampart automatically adapts to any change to the application or its libraries without requiring source code.
Rampart achieves a low false positive rate by leveraging a probabilistic algorithm and by updating the filtering rules intelligently with an exploratory strategy, and it exhibits false negatives only if an attack is not severe enough to consume significant CPU resource.Program Profiling.
The program profiling implementation of Rampart is inspired by prior work related to flowsensitive and context-sensitive profiling [6,7,13,15,16].
Here, a function's execution time is counted in different contexts based on the calling context tree.
That is, they accumulate all functions that are called on the current execution path, to distinguish the same function called under different contexts.
For Rampart, we adopt a similar profiling strategy: We compute a hash value to encode the current execution state.
Correspondingly, we can profile the running time of each called function in different contexts, and we can build a statistical execution model for each function.
Moreover, during profiling, we compare the profiled functions to their statistical models, which allows us to identify the request that caused the CPUexhaustion DoS attack, and which enables Rampart to block similar requests in the future.Anomaly Detection.
Rampart employs anomaly detection techniques to detect suspicious requests.
The simplest anomaly detection approach is to set a static threshold for each feature, and to generate alerts when some or all the feature values are below or above their thresholds.
Instead of a static threshold, Rampart learns a dynamic threshold for function execution time because it is impractical to determine a static threshold for each function accurately and a priori, as their execution time can vary greatly in different execution contexts.
Prior work employed supervised learning algorithms to build anomaly detection models [11,19,20,28], which stands in contrast to Rampart: We leverage anomaly detection models using statistical methods, but without requiring any labels during training.
Sophisticated Denial-of-Service (DoS) attacks targeting application-layer vulnerabilities can cause significant harm by severely degrading the performance and availability of a victim server over a prolonged period with only few carefully crafted requests.In this paper, we present Rampart, which is a system that protects web applications from sophisticated DoS attacks that would otherwise overwhelm the server's available CPU resources through carefully crafted attack requests.
Rampart performs context-sensitive functionlevel program profiling and learns statistical models from historical observations, which it then employs to detect and stop suspicious requests that could cause CPUexhaustion DoS.
Rampart also adaptively synthesizes and updates filtering rules to block future attack requests.
We thoroughly evaluated Rampart's effectiveness and performance on real-world vulnerabilities as well as synthetic attacks for two popular web applications, Drupal and WordPress.
Our evaluation demonstrated that Rampart is robust against a varying number of attackers and that it can effectively and efficiently protect web applications from CPU-exhaustion DoS attacks with negligible performance overhead, low false positive rate, and low false negative rate.
We thank the anonymous reviewers for their helpful suggestions and feedback to improve the paper.
This material is based on research supported by DARPA under agreement FA8750-15-2-0084, NSF under agreement CNS-1704253, ONR under grants N00014-09-1-1042, N00014-15-1-2162 and N00014-17-1-2895, and the DARPA Transparent Computing program under contract DARPA-15-15-TCFP-006.
The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon.
The views, findings, conclusions or recommendations expressed in this material are those of the authors and should not be interpreted as necessarily representing the official views, policies or endorsements, either expressed or implied, of DARPA, NSF, ONR, or the U.S. Government.
