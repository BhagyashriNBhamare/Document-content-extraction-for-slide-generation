As software becomes increasingly complex, its attack surface expands enabling the exploitation of a wide range of vulnerabil-ities.
Web applications are no exception since modern HTML5 standards and the ever-increasing capabilities of JavaScript are utilized to build rich web applications, often subsuming the need for traditional desktop applications.
One possible way of handling this increased complexity is through the process of software debloating, i.e., the removal not only of dead code but also of code corresponding to features that a specific set of users do not require.
Even though debloating has been successfully applied on operating systems, libraries, and compiled programs, its applicability on web applications has not yet been investigated.
In this paper, we present the first analysis of the security benefits of debloating web applications.
We focus on four popular PHP applications and we dynamically exercise them to obtain information about the server-side code that executes as a result of client-side requests.
We evaluate two different debloating strategies (file-level debloating and function-level debloating) and we show that we can produce functional web applications that are 46% smaller than their original versions and exhibit half their original cyclomatic complexity.
Moreover, our results show that the process of debloating removes code associated with tens of historical vulnerabilities and further shrinks a web application's attack surface by removing unnecessary external packages and abusable PHP gadgets.
Despite its humble beginnings, the web has evolved into a full-fledged software delivery platform where users increasingly rely on web applications to replace software that traditionally used to be downloaded and installed on their devices.
Modern HTML5 standards and the constant evolution of JavaScript enable the development and delivery of office suites, photo-editing software, collaboration tools, and a wide range of other complex applications, all using HTML, CSS, and JavaScript and all delivered and rendered through the user's browser.This increase in capabilities requires more and more complex server-side and client-side code to be able to deliver the features that users have come to expect.
However, as the code and code complexity of an application expands, so does its attack surface.
Web applications are vulnerable to a wide range of client-side and server-side attacks including Cross-Site Scripting [4,47,72], Cross-Site Request Forgery [3,33,46], Remote Code Execution [18], SQL injection [19,41], and timing attacks [35,40].
All of these attacks have been abused numerous times to compromise web servers, steal user data, move laterally behind a company's firewall, and infect users with malware and cryptojacking scripts [43,49,74].
One possible strategy of dealing with ever-increasing software complexity is to customize software according to the environment where it is used.
This idea, known as attack-surface reduction and software debloating, is based on the assumption that not all users require the same features from the same piece of software.
By removing the features of different deployments of the same software according to what the users of each deployment require, one can reduce the attack surface of the program by maintaining only the features that users utilize and deem necessary.
The principle of software debloating has been successfully tried on operating systems (both to build unikernel OSs [53] and to remove unnecessary code from the Linux kernel [51,52]) and more recently on shared libraries [56,61] and compiled binary applications [42].
In this paper, we present the first evaluation of the applicability of software debloating for web applications.
We focus on four popular open-source PHP applications (phpMyAdmin, MediaWiki, Magento, and WordPress) and we map the CVEs of 69 reported vulnerabilities to the source code of each web application.
We utilize a combination of tutorials (encoded as Selenium scripts), monkey testing, web crawling, and vulnerability scanning to get an objective and unbiased usage profile for each application.
By using these methods to stimulate the evaluated web applications in combination with dynamically profiling the execution of server-side code, we can precisely identify the code that was executed during this stimulation and therefore the code that should be retained during the process of debloating.Equipped with these server-side execution traces, we evaluate two different debloating strategies (file-level debloating and function-level debloating) which we use to remove unnecessary code from the web applications and quantify the security benefits of this procedure.
Among others, we discover an average reduction of the codebase of the evaluated web application of 33.1% for file-level debloating and 46.8% for function-level debloating, with comparable levels of reduction in the applications' cyclomatic complexity.
In terms of known vulnerabilities, we remove up to 60% of known CVEs and the vast majority of PHP gadgets that could be used in Property Oriented Programming attacks (the equivalent of Return-Oriented Programming attacks for PHP applications).
Overall, our contributions are the following:• We encode a large number of application tutorials as Selenium scripts which, in combination with monkey testing, crawling, and vulnerability scanning, can be used to objectively exercise a web application.
Similarly, we map 69 CVEs to their precise location in the applications' source code to be able to quantify whether the vulnerable code could be removed during the process of debloating.
• We design and develop an end-to-end analysis pipeline using Docker containers which can execute client-side, application stimulation, while dynamically profiling the executing server-side code.
• We use this pipeline to precisely quantify the security benefits of debloating web applications, finding that debloating pays large dividends in terms of security, by reducing a web application's source code, cyclomatic complexity, and vulnerability to known attacks.To motivate further research into debloating web applications and to ensure the reproducibility of our findings, we are releasing all data and software artifacts.
In this section, we briefly describe the effect of package managers on software bloat and provide a motivating example for debloating web applications.
To ease the development of software, developers reuse thirdparty libraries, external packages, and frameworks for their applications.
This approach enables developers to focus on their applications while relying on proven and tested components.
Statistics from popular package managers show that reliance on external packages is a widely adopted practice across many different languages.
NPM, the registry hosting NodeJS packages, reports more than 10 billion package downloads a month [73].
Similarly, PyPI, the package manager for Python, reports more than a billion a month [30], while Packagist, the main repository for Composer package manager for PHP, reports the download of 500 million packages each month [29].
At the same time, it is doubtful that all the code and features obtained through these packages and frameworks are actually used by the applications that rely on them.
For the most part, when developers rely on external dependencies, they include entire packages with no effective way of disabling and/or removing the parts of these packages and frameworks that their applications do not require.
In this study, we look at the bloat of web applications and quantify how debloating can provide concrete security benefits.
Even though debloating has been successfully applied in other contexts, we argue that the idiosyncrasies of the web platform (e.g. the ambient authority of cookies and the client/server model which is standard for the web but atypical for operating systems and compiled software) require a dedicated analysis of the applicability of debloating for web applications.To understand how the bloat of a web application can lead to a critical vulnerability, we use a recent vulnerability of the Symfony web framework (CVE-2018-14773 [28]) as a motivating example.
Specifically, the Symfony web framework supported a legacy IIS header that could be abused to have Symfony return a different URL than the one in the request header, allowing the bypassing of web application firewalls and server-side access-control mechanisms.
If this type of header was never used by the server, debloating the application would have removed support for it, which ultimately would have prevented anyone from exploiting the vulnerability.
Drupal, a popular PHP Content Management System (CMS), was also affected by the same vulnerability since it uses libraries from the Symfony framework to handle parts of its internal logic [26].
Even if Drupal developers were not responsible for the code that leads to the vulnerability, their application could still be exploited since Symfony was an external dependency.
Even more interestingly, an analysis of the official Symfony patch on GitHub [27] reveals that the vulnerable lines were derived from yet another framework called Zend [31].
This shows that the structure of web applications can be very complex with code reuse originating from many different sources.
Even if developers take all possible precautions to minimize vulnerabilities in their own code, flaws from external dependencies can cascade and lead to a critical entry point for an attacker.Overall, there are clear benefits that debloating could have on web applications.
Assuming that we are able to pinpoint all the code that is required by the users of a given software deployment, all other code (including the code containing vulnerabilities) can be removed from that deployment.
Figure 1: Overview of the architecture of our pipeline for debloating web applications and assessing the effects of different debloating strategies.
In this section, we describe the process of gathering information regarding known vulnerabilities (in the form of CVEs) for web applications, designing and executing tests against web applications of interest, and identifying the server-side code that was executed as a result of client-side actions.
The setup for our framework is depicted in Figure 1.
To debloat target applications, we first collect information about the vulnerabilities of the applications that we analyze in our study.
This information includes the files, functions, and line numbers where each vulnerability resides (Step 1, Section 3.3).
Then, we simulate usage of the application through a combination of different techniques (Step 2, Section 3.4).
Using a PHP profiler tool (XDebug), we record the lines, functions, and files, that are triggered during the simulation (Step 3, Section 3.5).
In the middle part of our pipeline, the debloating engine takes both the target applications and coverage information to perform debloating at different levels of granularity, and rewrite parts of the application to remove unused pieces of code based on the debloating strategy being evaluated (Steps 4 and 5, Section 4).
Our framework also provides a complete reporting panel to assist human analysts in understanding which vulnerabilities can be removed by the present debloating strategies.Last, we verify the correctness of our debloating process by running a set of tests against the debloated web applications, and verifying that no removed piece of code is triggered (Step 5).
To this end, we utilize assertions in place of the removed code blocks.
An absence of error messages from these assertions means that all tests were successfully completed without triggering any missing server-side code.
As an final step of verification, we also test the debloated applications against a series of exploits and verify that exploits which abuse any of the vulnerabilities that were removed as part of the debloating process, do not succeed (Step 6, Section 5.6).
To ease integration and facilitate the analysis of new web applications, we adopted a modular architecture that relies on three Docker containers.
The Application container hosts our web applications.
The profiler enabled on its web server is responsible for collecting code coverage information.
The Database container runs a MySQL server that stores the code coverage information along with the databases of the tested applications.
Lastly, the Debloating container which includes our debloating logic, analyzes the coverage information and generates debloated versions of applications.
It also provides a reporting panel that indicates which vulnerabilities are removed in each application after debloating.
To add a new vulnerability, a user simply has to provide the details of the vulnerable file(s) and line(s).
To understand how the process of debloating increases the security of web applications, we decided against using toy-like web applications.
Instead, we focused on established opensource applications with millions of users, and the presence of a sufficient number of known historical vulnerabilities (in the form of CVEs) to allow us to generalize from them.
To this end, we selected phpMyAdmin [60], MediaWiki [59], Magento [58], and WordPress [75], which are representative samples of four different types of web applications namely web-administration tools, wikis, online shops, and blogging software.
Table 1 shows the versions of these web applications that we utilized, in order to map CVEs to the location of the vulnerability in the source code of each application.
To determine whether debloating web applications can actually remove vulnerabilities, we performed a mapping of known CVEs to the vulnerable lines, functions, and files, that they exploit in each application.
This way, by looking at an application after debloating, we can determine if the files, functions, or lines responsible for the vulnerability, are still present or were removed during the debloating process.
Even though there exist multiple databases listing the current and historical CVEs of popular software (including the web applications in question) [36,37], locating the actual source code containing the vulnerability described in a CVE, is a non-trivial process which requires careful investigation.
In some cases, the right patch can be discovered because of a direct reference to a CVE in a commit message, or in a bug report on official public repositories of web applications.
For others, the fix is included within numerous commits that have to be carefully analyzed to locate the appropriate lines of code.
Since a vulnerability can span over multiple lines, functions, and even multiple files, we record all affected locations in a database so that this information can be later correlated with each evaluated application.Given the time-consuming nature of mapping CVEs to existing code, for this study, we limited ourselves to, at most, 20 CVEs per application of interest.
The complete list of CVEs we mapped for this study can be found in Table 9 in the Appendix.
To select these CVEs, we ordered existing vulnerabilities by their CVSS score (thereby selecting the ones that are the most critical) and we did not consider vulnerabilities that were reported before 2013.
This focus on fairly recent vulnerabilities (i.e. in the last five years) makes our results more generalizable to the current state of web applications, as opposed to quantifying vulnerabilities in source-code which has since dramatically evolved.
Note that, because not all versions of a web application are vulnerable to all evaluated CVEs, we had to map vulnerabilities across a number of different versions, as shown in Table 1.
Modern web applications provide an incredibly wide range of features and options to their users.
Even though, from a functional perspective, more features are desirable, from a security perspective, the code that implements new features may contain new vulnerabilities thereby further expanding a program's attack surface.
In order for a system to be able to remove code related to unnecessary features, one must first identify which features are necessary for a target set of users.Given a usage profile, the goal of our framework is to produce debloated versions of web applications which maintain the code and features that are part of that profile but remove the rest.
To be as objective as possible with what features are considered "necessary," we utilize four independent sources of web application usage: i) online tutorials describing how to use the applications of interest, ii) web crawlers that autonomously navigate the application, iii) vulnerability scanners that feed malicious content to the application, and iv) monkey testing tools that click on random parts of webpages and type random keystrokes.
The combination of all four gives our profiles both breadth (through the crawler and monkey testing) as well as depth (through the user following complicated paths while providing expected inputs and the vulnerability scanner which provides large amounts of malicious inputs trying to exploit the web application).
To simulate common interactions with an application, we use a popular search engine to search for the application's name followed by the word "tutorials" (e.g. "phpMyAdmin tutorials") and follow the tutorials from the first two pages of search results.Specifically, we map each tutorial to a Selenium script that allows us to both execute the same tutorial multiple times and also assess the correctness of the results (e.g. encode that when we delete a database using phpMyAdmin, the deleted database is no-longer shown in the list of databases).
Note that this mapping of tutorials to Selenium scripts is yet another time-consuming process which, occasionally, has to be repeated for different versions of the same web application.
One change in a form field or in a selector can break the complete flow of a test suite and we observed a significant number of cases with slight interface changes between two consecutive versions of the same application.Overall, after fine-tuning the scripts for all our tested versions, we obtained 46 tutorials which translated into 302 use cases scripted as Selenium tests requiring 16,025 lines of code.
Given our desire for complete reproducibility of our results, we include the complete list of tutorials in the Appendix (Table 8) along with WebArchive links that will remain available despite potential future domain expirations and linkrot of the original URLs [48].
Below, we provide a non-exhaustive list of actions that were part of the followed tutorials of each web application.
Full details are available in the actual tutorials and in the Selenium scripts which we will release together with this paper.Actions covered by phpMyAdmin tutorials: As a web administration tool, all phpMyAdmin functionality is protected by an authentication mechanism.
We followed the actions described by tutorials when logged in as a root user account with full application access.
The Selenium-encoded tutorials cover database operations including creating and dropping databases, filling tables with data, querying, table indexes, and importing/exporting data.
They also include administration tasks such as adding new user accounts, optimizing databases, checking database server status, obtaining performance metrics, and accessing server settings such as variables, charsets, and engines.Actions covered by MediaWiki tutorials: MediaWiki provides different features depending on the privileges of the user.
Unauthenticated users can only visit and search pages.
Registered ones can post and edit content while administrators can perform moderation and management operations.
The tutorials that we followed cover all these different use cases.
More specifically, actions coded in our tutorials include authentication, creating and renaming pages, importing and exporting content from the wiki, as well as changing settings such as skins, styles, and formatting options.
Actions covered by WordPress tutorials: As a blogging software, WordPress has two distinct entry points, one for normal unauthenticated users to read blogs and post comments, and a separate administration panel accessible to privileged and authenticated users.
WordPress tutorials mostly focus on administrative tasks since normal users have limited abilities.
The Selenium-encoded tutorials include actions such as creating a new post using HTML for the content, modifying most post options (ranging from visibility and tags to setting featured images), as well as downloading and changing WordPress themes.
For the administration panel, the tutorials include exporting content, setting up user accounts, and uploading media.
Finally, the tutorials include the visiting of posts and the posting of comments as well as the management of comments, such as approving them, marking them as spam, and deleting them.
Actions covered by Magento tutorials: Magento is the largest evaluated web application in terms of source code and has the most features compared to the other applications.
Similar to WordPress, the tutorials mostly target administration tasks which include store settings, advanced product search options, order notification via RSS, product pricing, currencies and tax rules, delivery and payment methods, emails and notifications, reviews and ratings and cache control.
Some tutorials go in even more details by covering product and stock management, managing customers and groups configurations, modifying the UI, creating pages, and using widgets.
On the customer side, we followed tutorials that included registration of a new account, authentication actions, and purchasing products until checkout.
Monkey testing is a method for testing software where the simulated user sends random clicks and keystrokes to the target application.
This unpredictable behavior can uncover bugs in an application as it can trigger paths and actions that were not anticipated by developers.
In our case, we use such a technique to trigger additional code, not covered by tutorials.
We observe that this approach adds breadth to the code coverage by reaching easy to access features.
In addition, by feeding random key strokes into forms, monkey testing can bring the application in an error state thus exercising error-handling pieces of code.We rely on the stress-testing library called gremlins.js [7] in conjunction with the GreaseMonkey browser extension [6] to inject the library into web application pages.
Since this kind of testing can occasionally trigger unwanted actions, we have to take necessary steps to stop them, e.g., prevent the test from leaving the web application and visiting external websites.
We also want to prevent gremlins.js from getting trapped on a single page as an unexpected JavaScript dialogue box or a dead end page can pause our test execution.
An additional issue is that of accidentally logging out a web application by clicking on a logout link.
Given that we run monkey-testing under three different usage profiles (public user, logged-in user, and administrator) we took steps to avoid accidental logouts.
Overall, we perform the following modifications: i) we remove all links that lead to external pages, ii) we remove logout buttons for applications that require authentication, iii) we override the aforementioned JavaScript functions and iv) we set a timeout to detect when the monkey is stuck and reset it to a known good state.
All these actions are done using injected JavaScript on target pages prior to starting the gremlins.js library.To cover a large set of pages from a web application, we run gremlins.js for 12 hours for each of the test profiles.
To guarantee the reproducibility of our experiment, we choose a fixed seed for each run that will generate the same sequence of pseudo-random actions.
Web spiders (also known as crawlers) are a type of bot that follows the links of a web application and optionally submits forms with predefined content.
Each newly crawled page is added to a database of the application that the crawler uses to prevent repeated visits to the same pages.
For our study, we use BurpSuite Spider v2.0.14beta [2] to crawl our web applications.
As a result, we augment the application coverage with code paths that were not triggered, either through the followed tutorials or through monkey testing.
Vulnerability scanners are tools that try to detect security flaws in web applications.
We use BurpSuite Scanner v2.0.14beta [2] based on the URLs extracted by the spider to look for vulnerabilities in headers, URLs and forms.
Notably, the scanner tries different injection mechanisms like SQL injection, XSS, PHP file injection, and path traversal, to trigger errors and reach unwanted states in the application.
The vulnerability scanner goes beyond what the crawler and the monkey cover by modifying headers and URL parameters.
By inspecting the resulting coverage, we observe that each of these four methods result in exercising server-side code that would not have been exercised through the other methods.
We quantify this relationship in Section 5.
Regardless of the method that is used to interact with a web application, in order to be able to successfully remove unused code (i.e. debloat the web application), we must be able to associate client-side requests with server-side code.
To record the files and lines of code that are triggered by user requests, we make use of PHP profilers.PHP profilers are available as PHP extensions that modify the PHP engine to collect code-coverage information.
There exist a number of different profilers, such as, XDebug [23], phpdbg [16], and xhprof [24] all of which require a similar setup to record code coverage.
For our framework, we decided to use XDebug as it is the most mature profiler and is actively maintained.
Connecting a web application to XDebug.
To be able to perform dynamic analysis and record lines of code that are triggered by user requests, our framework must add calls to specific XDebug functions in every PHP file of a web application.
Specifically, both xdebug start code coverage() and xdebug get code coverage() functions are called to, respectively, start and receive coverage information.
If the "get" function is never called, the coverage information is lost.
In the following paragraphs, we describe challenges related to obtaining the code coverage from XDebug and how we overcame them.The case of unrecorded lines.
Boomsma and Gross reported on the possibility of removing unused code in a custom PHP application [34].
By performing dynamic analysis, they observed which files were not used and removed them from their application.
The authors utilized their own profiler and took advantage of the auto append built-in function of PHP to add the necessary log functions at the very end of all PHP files [1].
For our study, we initially attempted to use the same approach and ran preliminary tests by appending XDebug function calls at the end of our tested files.
However, we discovered that the coverage was incomplete and that some lines were not properly recorded.
Given that any PHP file can call the exit() or die() function at any time to terminate the current script, our XDebug calls which were located at the end of each file, were not always executed thus leading to under-reported code coverage.
Avoiding early exits.
To overcome the coverage problems due to calls to exit functions, we utilized a specific type of PHP callback functions, called shutdown functions.
When registered, these functions are triggered after all the code on the page has finished running or after either exit() or die() functions are called.
This way, we are able to obtain the desired coverage information even if a PHP script used one of the aforementioned functions.
Interestingly, we also discovered that calls to exit() inside a shutdown function prevent the execution of other shutdown functions including the call to collect our own code-coverage information.
To correct this issue, we statically analyzed the evaluated applications and automatically added calls to collect code coverage before these exit calls (e.g. Line 7 in Listing 1).
Getting correct coverage information of shutdown functions.
Another challenge, in terms of recording correct code-coverage information, is to properly record the executed lines of code inside shutdown functions.
As mentioned by the PHP manual [12], shutdown functions are called in the order they were registered.
This means that if our own shutdown function is registered first, it will also be triggered first, thereby missing any calls to subsequent shutdown functions present in the same PHP file.
To get full coverage, we use the following approach: our own shutdown function will perform a late registration of a final shutdown function that will be added at the very end of the execution queue.
This way, we can be certain that the very last shutdown function that will be executed in a script will be our own, providing us with the desired coverage information.Getting correct coverage information of destructors.
The final challenge that we faced was to properly record covered lines for all class destructors.
PHP uses garbage collection and reference counting to remove objects from memory, whenever they are no longer necessary.
However, there is no real way to anticipate when the garbage collector will effectively remove objects during program execution.
If objects are destroyed before the shutdown functions are executed, our framework has no issue recording them.
However, if they are destroyed after, our shutdown functions are incapable of registering the execution of these destructors.To handle this special case, we rewrote class destructors so that they register themselves while they are executing.
Every time a destructor is called, we query the XDebug engine to check whether code-coverage recording is currently in progress.
This way, we can determine whether the destructor is called before or after shutdown functions.
If the destructor is called after shutdown functions, we dynamically decide to start recording all executed lines within the destructor and save the coverage information when it finishes executing.Summary.
As witnessed through the above use cases, collecting the correct code coverage information for a web application is significantly more complicated than one would initially expect.
Through the preprocessing of code, and the use of destructors and shutdown functions, we solve the issues that were not even mentioned in prior work and get a precise view of the code that executes at the server side, as a result of user requests.
Listing 1 provides an example of concrete modifications in a PHP file.
On line 7, we added a code-coverage call before an exit which happens inside a shutdown functions to prevent information loss due to early exits.
On lines 14 and 17, we wrapped the destructor with code-coverage calls.
In this section, we briefly describe the evaluated debloating strategies and the steps we took to ensure that the debloated applications remain functional.
By combining the simulated usage of a web application (achieved through tutorials encoded in Selenium scripts, web crawlers, monkey testing, and vulnerability scanning) with server-side code profiling, we can identify the code that was executed as part of handling web requests.
Consequently, code whose execution was not triggered by any client-side request can presumably be removed since it is not necessary for any of the functionality that is desired by users (as quantified by the utilized usage profiles).
In this work, we evaluate the following debloating strategies:• File-level debloating: Given that the source code of web applications spans tens or hundreds of different files, we can completely remove a file, when none of the lines of code in that file were executed during the stimulation of the web application.
• Function-level debloating: In function-level debloating, not only can we remove entire files but we can also selectively remove some of the functions contained in other files.
This is a more fine-grained approach which allows us to remove more code, than the more conservative, file-level debloating strategy.More fine-grained approaches are possible, such as, the removal of specific code statements from retained functions which were not exercised during stimulation.
However, such changes essentially modify the logic of a function (e.g. removing conditional code blocks) thereby increasing the probability of breaking the resulting program when a minute change of a client-side request would lead the execution into these blocks of code.
We replace all removed functions and files with placeholders which, if executed, have the following tasks:• Exit the application: If a placeholder happens to be triggered, the PHP application will start its shutdown procedures.
This way, the application does not enter an unexpected state that was not planned by the debloating process.
• Record information about the missing function: In order to better understand which missing placeholders were triggered and how, our framework logs several pieces of information, such as, the URL that triggered the execution of the removed code, the name of the class and function of the removed code, and the corresponding line numbers.To ensure that the debloating process has preserved the functionality of the debloated web application, we rerun all the Selenium-mapped tutorials and monkey scripts after the debloating stage.
If our placeholder code for removed files and functions executes during this stage, this means that this code should not have been removed.This feedback mechanism proved invaluable during the development of our framework since it helped us identify problems with our coverage logic which in turn revealed the challenges that we described in Section 3.5.2.
To assess the impact of debloating web applications, we analyze our results from a number of different perspectives.
First, we show the contributions of different application-profiling methods and then compute different metrics to understand the effectiveness of debloating in terms of reducing the attack surface of our tested applications.
Next, we focus on CVEs to determine whether debloating can actually remove critical vulnerabilities.
Then, we take a closer look at the bloat introduced by external packages along with the security implications that come with using this specific development practice.
Finally, we look at what has effectively been removed in debloated applications and test a number of exploits against the original and debloated versions of the evaluated web applications.
As described in Section 3.4, to ensure that we exercise web applications in an objective and repeatable way, we utilized tutorials, monkey testing, crawlers, and vulnerability scanners.
Figure 2 shows the coverage, in terms of server-side files, that each method obtained on the latest version of each web application in our testbed.
We can clearly see that all four methods are required, with each method contributing differently for different web applications.
For example, tutorials trigger To evaluate the effectiveness of our two debloating strategies, we computed different metrics that provide insights into what has actually been removed during the debloating process.
The size of a program positively correlates with the number of programming errors (i.e. bugs).
According to McConnel [55], the industry average, at least in 2004, was to have between 1 and 25 bugs for every one thousands lines of code.
Given the importance of the size of an application to its overall security, we start by estimating the reduction of the attack surface by looking at the Logical Lines Of Code (LLOC, sometimes also called Effective Lines Of Code).
LLOC is intended to measure lines of code without comments, empty lines and syntactic structure required by the programming language.
LLOC reduction is a robust and precise indicator of how much the volume of the code was reduced.
Figure 3 reports on the LLOC for all versions of the applications we debloated.
Figure 4: Evolution of cyclomatic complexity before and after debloatingFunction-level debloating.
On average, function-level debloating is able to remove 46.8% of lines of code.
For both Magento and MediaWiki, it can remove up to 7% more code over file-level debloating.
For phpMyAdmin and WordPress, we observe an increase of debloating capability of up to 24%.
This larger reduction (compared to MediaWiki and Magento) is mainly due to the differences in software development practices.Compared to the other tested applications, phpMyAdmin and WordPress are more monolithic with a smaller number of large source-code files.
Since file-level debloating only removes files when none of their functions were executed, the monolithic nature of these two applications resists this kind of coarse-level debloating.
Contrastingly, Magento and MediaWiki are developed in a much more modular fashion (many small files each responsible for a small number of well-defined tasks) and therefore lend themselves better to file-level debloating.
The more fine-grained, function-level debloating bypasses this issue and can therefore reduce the attack surface of a web application, even for more monolithic web applications.
Next, we look at the evolution of cyclomatic complexity (CC).
CC is defined as the number of linearly independent paths through the code of an application [54].
A high CC for a single class implies complicated code that is difficult to debug and maintain [39] and therefore more prone to contain vulnerabilities when compared to code with low CC [52,69].
Figure 4 reports on the evolution of the overall CC for each tested version in our experiment.
File-level debloating decreases CC between 5.9% to 74.3% with an average of 32.5%.
Functionlevel debloating decreases the program complexity between 23.8% and 80.2% with an average of 50.3%.
These statistics demonstrate that debloating can remove complex instructions and execution paths in addition to simple ones.
Moreover, the difference between file-level and function-level debloating shows that code removal through function-level debloating is much more suited to all kinds of web applications as shown earlier through LLOC reduction achieved via function-level debloating.
In this section, we investigate the number of removed CVEs after debloating along with the effects of debloating on different vulnerability categories.
One practical way to measure the security benefits of debloating web applications is to study the effects of debloating on known historical vulnerabilities.
If vulnerabilities were part of the core functionality of the program, the evaluated debloating strategies will not be able to remove the code associated with them.
However, if some vulnerabilities reside in parts of a web application that are not commonly used, the process of debloating can effectively remove them.
Table 2 compares the effectiveness of debloating strategies by listing the fractions of removed CVEs.
We consider a vulnerability to have been successfully removed if all the lines of code and functions associated with that vulnerability were removed during the stage of debloating.
This is a conservative approach as one modification performed on a single line could thwart a complete attack.
As such, the numbers we report in this section can be interpreted as lower bounds of the actual number of removed CVEs.In terms of configuration, we selected the default one for each application.
However, certain vulnerabilities may not be exploitable under this configuration.
For example, there exists 5 CVEs in our dataset for MediaWiki which require file upload functionality to be enabled.
Since this option is disabled by default, we make an explicit distinction in the table.
"Total Removed CVEs" is the total number of CVEs removed by debloating regardless of whether the vulnerable code is enabled or disabled through a configuration option.
"Removed Exploitable CVEs" reports on the CVEs that are reachable under default configurations of target web applications.On average, we discovered that up to 38 % of vulnerabilities are removed by file debloating whereas 10-60 % are removed by function debloating.
As shown in Table 2, function-level debloating can triple (in the case of phpMyAdmin and Magento) the number of removed CVEs, compared to file-level debloating.
This behavior can be generalized to web applications that do not have CVE information and demonstrates that the reduction of a web application's LLOC (Section 5.2.1) and its cyclomatic complexity (Section 5.
vulnerabilities.
Wordpress is a clear negative outlier with only 10% CVE reduction, even through the more flexible function-debloating strategy.
As mentioned earlier, WordPress is a relatively monolithic application and most of our mapped CVEs are located in core WordPress code (e.g., Authentication, CSRF tokens, and post/comment-related actions) which cannot be removed by our debloating framework.
Even though our results demonstrate the ability to remove vulnerabilities from web applications through the use of debloating, one may wonder whether debloating is better suited for some types of vulnerabilities over others.
Figure 5 provides details on the categories of the CVEs we removed through debloating.
One can observe that for certain classes of vulnerabilities, such as, Denial-of-Service attacks and Information-Revealing vulnerabilities, debloating can almost completely remove them.
For others, such as, restriction bypassing, command execution, and SQL injection, debloating can substantially reduce them.
Our interpretation of these findings has to do with the maturity of the evaluated web applications.
Specifically, all four web applications have been available for a long period of time, allowing many shallow vulnerabilities to have already been discovered and corrected.
The remaining vulnerabilities are likely to be situated in parts of a web application that are less commonly exercised.
For example, the code-execution vulnerabilities that can be removed for phpMyAdmin are inside very specific features, such as, the ability to export PHP arrays (CVE-2016-6609), the support of the ZIP extension while importing data (CVE-2016-6633), and the abilities to copy table definitions (CVE-2013-3238) and perform Regex search and replace over table columns (CVE-2016-5734).
Contrastingly, the three cryptography-related vulnerabilities we analyzed are still present in the debloated versions of web applications.
One of the CVEs related to this category is about a flaw in the cookie encryption algorithm in phpMyAdmin (CVE-2016-6606).
Since every page interacts with user cookies to, at the very least, verify them, vulnerable code cannot be removed.
Another vulnerability in this category relates to an insecure random number generator used in cryptographic operations by Magento (CVE-2016-6485).
This vulnerability exists in a constructor of the main encryption classes which is widely used throughout the application.
When considered together, these findings suggest that cryptography-related vulnerabilities are a core part of web applications and thus unlikely to be removed through the process of debloating.
In our testbed, phpMyAdmin v.4.7.0, MediaWiki v.1.28.0 and Magento v.2.0.5 rely on external dependencies that can be downloaded via Composer (WordPress does not rely on external packages).
As described in Section 2, Composer is a package manager for PHP (similar to the NPM manager for NodeJS applications) which allows web applications to specify which external packages they rely on and have these packages be tracked and updated.As we briefly discussed in Section 5.2.1, the number of LLOC of these three specific versions dramatically increases (compared to prior versions) because of this dependency on external packages.
Table 3 provides statistics on the number of packages pulled by these applications and how much bloat they provide against our usage profiles.First, one can observe that external packages introduce a large amount of unused code.
For all three debloated applications, more than 84% of their code was removed from them.
This means that the attack surface is unnecessarily large through the dependency on external packages.
The number of removed lines from external packages for Magento is particularly noteworthy with more than 178,000 lines of code removed.
Moreover, the number of packages that can be completely removed is also quite large: 84% for phpMyAdmin, 60% for MediaWiki and 81% for Magento.
This confirms that most packages are unnecessary for the usage profiles that we recorded.
Finally, focusing exclusively on the lines of code, phpMyAdmin is the only application where external packages have more lines than the main application.
However, after debloating, this relationship is reversed with the codebase of phpMyAdmin being three times the size of the introduced external packages.Despite the advantages of using package managers (e.g. the ability to track dependencies and update vulnerable libraries without the need to update the main application), our findings show that these advantages come at a considerable cost in terms of unnecessarily expanding the attack surface of a web application with code that is seldomly executed.
As such, developers must take special care to include the bare minimum of external packages, knowing the unwanted side-effects that each external package brings.
What are POI gadgets?
Property Oriented Programing (POP) is an exploitation technique in PHP which works similarly to Return Oriented Programming (ROP) [67] and is used to exploit PHP Object Injection (POI) vulnerabilities [11].
In this technique, the attacker creates exploit gadgets from available code in the applications.
By chaining multiple gadgets within the application, an attacker can usually run arbitrary code, write to arbitrary files, or interact with a database.
Dahse et al. have studied the automatic generation of such gadget chains for PHP applications [38].
PHP unsafe deserialization.
The PHP language gives developers the ability to serialize arbitrary objects in order to store them as text, or transfer them over the network.
Deserialization reverses this process, generating PHP objects from serialized data.
This mechanism can be abused by an attacker to load specific classes in the application and build a gadget chain.
Practical examples of this vulnerability are when unserialize is called on a database field or value of a field within a cookie that can be manipulated by the users.
Historically, this attack was very difficult to successfully execute.
Attackers could only build gadgets with the classes that were present in the context of the vulnerable file.
They needed insights into how the application was built in order to know which classes could be abused for gadgets.
However, starting from PHP 5, the autoload() magic function [10] was introduced and unintentionally made exploitation of deserialization vulnerabilities easier.
This new loading feature was beneficial for PHP developers who did not have to manually include all the files they wanted to use at the very top of each of their PHP files.
It also helped the adoption of package managers like Composer, as any external dependency could be easily called from anywhere in the application.
The downside of this new function was that it also allowed attackers to instantiate any PHP class across the entire application thereby enabling the easier construction of gadget chains.In order to build a chain, attackers use these so-called "magic" functions [13] that form the basis of their gadget chain.
One of the functions that is widely used in POI exploits is the destruct function.
In Section 3.5, we detailed the challenges in getting complete coverage of destructors in our tested applications.
Accurate coverage of destructors also allows us to precisely analyze the impact of debloating on gadget creation.Can debloating remove gadgets from external packages?
Given the increased footprint of web applications due to their reliance on package managers and external dependencies, one may wonder about the possibility of abuse of these packages for We analyzed the available gadget chains in PHPGGC and checked whether any of our tested PHP applications included these chains.
Table 4 summarizes the presence of each gadget and whether debloating removes them or not.
WordPress is not included in this table because it does not rely on external packages.
This does not make WordPress immune to POI attacks, but universally known gadget chains in popular external packages can not be used to exploit WordPress.
For the affected applications, file-level debloating removes 4/6 gadgets while function debloating removes 6/6 available gadget chains.
This again demonstrates the power of debloating which can not only remove some fraction of vulnerabilities but also make the exploitation of the remaining ones harder by removing the gadgets that attackers could abuse during a POI attack.
During our analysis of external packages, we identified yet another source of bloat in new versions of web applications.
When declaring external dependencies through Composer, two options are available: "require" and "require-dev".
The first option indicates packages that are mandatory for the application to run properly.
The second lists packages that should only be used in development environments, such as, packages providing support for unit testing, performance analysis, and profiling.
We discovered that applications downloaded from official websites often include these development packages.
As such, when these packages are used to deploy web applications in production mode, they will contain unnecessary development libraries.
This does not only increase the attack surface by having unnecessary code bloating the application, but can also lead to exploitation for misconfigured applications.CVE-2017-9841 presents one example of such a vulnerability [25].
Specifically, this CVE refers to an RCE attack in specific versions of the PHPUnit library, which is a popular unit testing library for PHP.
By default, Composer places all external packages under "vendor" directory.
If this specific directory happens to be accessible through a misconfiguration of the server, PHPUnit files are then accessible and can be exploited to conduct an RCE attack.The four web applications that we evaluated for this study, present different behaviors with respect to development packages.
WordPress does not rely on external packages downloaded through Composer.
MediaWiki never included development packages in its releases.
phpMyAdmin had them in version 4.7.0 but stopped including them in version 4.8.3 (the latest at the time of writing).
Magento started including them from version 2.0 and still includes them today.
We have reached out to Magento and informed them about this issue.
In the previous sections, we analyzed the effects of debloating on the source code of applications from a software-engineering perspective (i.e. LLOC and Cyclomatic Complexity reduction) as well as from a security standpoint (i.e. number of CVEs and gadgets removed).
At the same time, one may wonder what exactly was removed from each application during the process of debloating.Given that thousands of files were removed, manually analyzing each file does not scale.
As such, we turn to NLP techniques that allow us to cluster the removed files together and provide us with hints about the nature of each cluster.
Specifically, we use the k-means clustering algorithm based on text vectors extracted from removed file names and file paths.
Each file path includes directories that indicate which library or package, the file belongs to.
For most modern web applications, this allows for a reasonable separation of files across different application plugins and modules.
To end up with meaningful clusters, we tuned TFIDF vectorizer parameters along with the number of k-means clusters.
We used the TFIDF maximum frequency limit to ignore common terms appearing in more than 50% of the files.
Depending on the size and modularity of the application, 10 to 20 clusters yielded the most instructive grouping of files.
Table 5 shows the categories of the three largest removed clusters from each web application.
Across all four applications, we observe the removal of source code related to external packages (e.g. Symfony for phpMyAdmin, Elastica for MediaWiki, and Table 5: Features and external packages with the most removed files after file debloating (removed features are marked in italic).
Entries marked with * are packages that are indirectly pulled by other "require-dev" packages (not used by core application) for the purpose of test coverage reporting and coding standard enforcement.
Zendframework1 for Magento), followed by localization/theme files (e.g. twentyfourteen theme for WordPress), and unused database drivers.
We provide more application-specific details of removed features in the next paragraphs.
phpMyAdmin's removed features include the uploading of plugins, GIS visualizations, and unused file formats used in import/export (such as, Dia, EPS, PDF, SVG, and ZIP).
In addition, debloating removed unused plugins and external packages which make up the top 3 features removed from this web application as shown in Table 5.
phpMyAdmin version 4.6.0 and 4.7.0 include unit tests which are also removed by our system.
The LLOC for the removed test files is less than 2% of the whole code base of the application.MediaWiki provides an API to interact with the wiki which is separate from the regular web interface that users interact with.
Most actions within this API, including queries, file upload, and non-default output formats for this API were removed.
Top categories of removed files consist of localization of messages and language files in addition to external dependencies (Lines 2 and 3) as listed in Table 5.
The debloating process also removes fileupload modules which are disabled, by default, in MediaWiki.
It is important to note that even if a module is "disabled," the code still resides on the server and could be abused by specific types of attacks.
For example, in a recent attack against a WordPress plugin, the vulnerability could be exploited even if that plugin was disabled [32].
Debloating removes the source code of disabled and unused features and therefore does not suffer from this type of attack.
Finally, the process of debloating, removed unused extensions of Mediawiki (e.g. citation, input box, pdf handler, poem and syntax highlighting).
Mediawiki 1.19.1 and 1.28.0 include unit tests, and they measure less than 1.5% of LLOC in the whole code base of their respective versions.WordPress takes a slightly different approach where the core functionality is concentrated in a relatively small number of large PHP files.
The removed features of WordPress include installation files, unused modules (FTP, multi-site, user registration), disabled themes and update files (note that we could not exercise update files during our tests because this would change the version of the evaluated web application and create inconsistencies in our analysis of removed CVEs).
In terms of testing, the installation files that we obtained from the WordPress website do not contain any unit tests.Magento consists of both external packages and internal modules.
We observed that various internal modules were removed, including an XML API for mobile, wishlists, ratings, and specific payment modules (such as, Paypal).
Since many packages and internal modules include the terms "sales," "orders," and "tax," these individual files across multiple modules were clustered into the same category by k-means.
Finally, Magento 1.9.0 does not include unit tests while the test files included in Magento 2.0.5 and its external packages measure up to 15% of its code base.
For Magento 2.0.5, Zendframework1 which is an external dependency has most of its files removed by debloating.
To ensure the correct mapping of CVEs to source code and the ability of debloating to stop real attacks, we collected 4 exploits available in the Metasploit framework and augmented them with 4 POCs that we developed based on public bug-tracker records and vulnerability details.
After verifying that we can successfully exploit the original versions of the evaluated web applications, we tested the same exploits on the debloated versions.
Half of the previously successful exploits failed because the vulnerable code was removed during the process of debloating.
Table 6 lists the tested exploits against original and debloated applications.As before, this demonstrates that while debloating is not a panacea against all possible issues, it can substantially improve the security of web applications.
Finally, we present a demonstration of CVE-2016-4010 on Magento 2.0.5 in the following video: https://vimeo.com/328225679.
Without XDebug With CC Figure 6: Measurement of the CPU consumption for the tested web applications.
100% corresponds to the use of a single CPU core.
It is known that code-coverage tools impose a non-negligible overhead on web applications [65].
In this section, we report on the results of conducting all the Selenium tests with and without XDebug (our chosen PHP profiler) while measuring execution time, and recording server-side CPU usage and memory consumption.
Table 7 presents the overall results and Figure 6 focuses on CPU consumption.
First, looking at the execution time, we can see that code coverage has a varying impact on the tested web applications.
On one hand, phpMyAdmin is lightly affected with a 14% increase.
On the other hand, the time it takes to run all tests for MediaWiki has tripled.
For CPU consumption, the overhead is noticeable and all applications at least double their use of resources when code coverage is active.
phpMyAdmin is exhibiting the biggest performance hit with a reported average almost 9 times higher than the one from the base application.
Figure 6 shows that all median values are higher for applications with XDebug and most applications, at some point, require a second core with values above 100%.
Finally, in terms of memory consumption, the server-side code profiler incurs a relatively modest increase for most applications.
The worst overhead is observed when evaluating WordPress with an increase of 4.3% of the total device memory (16GB), i.e., an additional 700MB of RAM.Even though our results show that the overall overhead is substantial, it is important to note that this overhead is not the overhead of the debloated web applications.
Debloated web applications do not require code-coverage statistics and will therefore execute in the exact same environment as the original application (i.e. without XDebug).
Depending on how code-coverage infor-mation is obtained, this overhead may or may not be an issue.
For example, if the coverage is calculated in an offline fashion where traces of application usage are replayed against a testing system, this overhead will have no impact on the real production systems.
To allow for the online computation of code coverage (using real-time user traffic), we need more optimized code profilers.
For example, XDebug currently overloads 43 opcodes to obtain line-level code-coverage information that is more fine-grained than required by our debloating techniques and incurs an unnecessary performance overhead [64].
We leave the development and evaluation of faster code profilers for future work.
In this study, we set out to precisely quantify the security benefits of debloating, when applied to web applications.
Through a series of experiments, we demonstrated that debloating web applications has a number of very concrete advantages.
We showed that debloating can, on average, decrease an application's code base by removing hundreds of thousands of lines of code, reduce its cyclomatic complexity by 30-50% and remove code associated with up to half of historical CVEs.
Moreover, even for vulnerabilities that could not be removed, debloating can remove gadgets that makes their exploitation significantly harder.
Next, we discuss some of the inherent and technical limitations of our approach and future direction.Lack of available exploits: The number of exploits publicly available compared to the total number of registered CVEs is low.
At the same time, the effort to study vulnerability reports, find the relevant patch or bug report, and track the actual vulnerability down to source code level takes a non-negligible amount of manual labor.
This lack of available exploits limits our ability to test the exploitability of vulnerabilities before debloating since certain vulnerabilities might only be exploitable under specific configurations.
For example the set of five file-upload-related vulnerabilities in our MediaWiki dataset (marked as gray in Table 9) require access to file upload functionality which is disabled by default.
A maintained set of automated, replayable exploits against popular web applications similar to "BugBox" introduced by Nilson et al. in 2013, could substantially help researchers at this step [57].
To address this issue, we mapped the CVEs to features within those applications.
This is done by studying the architecture of target applications based on documentation within the code and available on their websites.
We marked a CVE as unexploitable if the underlying feature is disabled by default, and online tutorials in our dataset do not require users to enable that functionality.
This limitation only applies to reported numbers on removed CVEs and does not affect our results on POI gadgets since their mere existence is enough for them to be used in gadget chains.Our approach results in lower bounds for CVE removal since disabling modules through application configuration does not guarantee removal of all code paths that trigger those modules.
Taking CVE-2019-6703 as an example, a vulnerability was discovered in the WordPress "Total Donations" plugin [32] and disabling this plugin did not prevent attackers from invoking the vulnerable end point and running their exploits.Dynamic code coverage: Given our reliance on dynamic code-coverage techniques, it is clear that the success of debloating a web application is tightly related to its usage profile.
Even though we constructed profiles in a way that is reproducible and unbiased (i.e. by relying on external popular tutorials, monkey testing, crawlers, and vulnerability scanners), we cannot claim that real web users would not trigger code that was removed during the stage of debloating, while they are interacting with a debloated web application.More specifically, our modeled usage profiles do not cover all possible benign states of target web applications as we assume that users do not use all available features.
Our intuition behind debloating proves to be successful to a large degree since removing unnecessary features brings clear security improvements.
At the same time, our current usage model may not cover deep error states (e.g. logical errors in multi-stage form submissions, or the invalid structure of uploaded files).
As such, we intend to follow-up this work with crowd sourcing and user studies to understand how administrators, developers, and regular users utilize the evaluated web applications and whether their usage profiles would allow for similar levels of debloating.Due to nature of our approach, we can not take advantage of standard static-analysis techniques, since we aim to remove the features that are not useful for a given set of users, not those that are not reachable by other code.
Using static analysis would greatly overestimate the code that needs to be maintained through the process of debloating and the resulting web application would contain code (and therefore vulnerabilities) that is not useful to all users.
Going forward, we envision a hybrid approach where dynamic analysis is used as a first step to identify the core features that are useful for a specific set of users.
These features can then be used as a starting point for a follow-up static analysis phase to ensure that all code related to these features is maintained when debloating a web application.Handling requests to removed code: A separate issue is that of handling requests to removed code.
Our current prototype utilizes assertions to log these requests so that we can investigate why the corresponding server-side code was not captured by our coverage profiler.
When real users utilize debloated web applications, one must decide how these failures (i.e. client-side requests requiring server-side code that was removed) will be handled.
Assuming that cleanly exiting the application and showing an error to the user is not sufficient, we need methods to authenticate the user's request, determine whether the request is a benign one (and not a malicious request that aims to exploit the debloated web application) and potentially re-introduce the removed code.
The client/server architecture of web applications lends itself well to this model since the web server can decide to re-introduce debloated code and handle the user's request, without any knowledge of this happening from the side of the user.
All of this, however, requires server-side systems to introduce the code at the right time and for the appropriate users.
We leave the design of such systems for future work.Metrics to measure debloating effectiveness: In this paper, we use Cyclomatic Complexity (CC), Logical Lines of Code (LLOC), reduction in historical CVEs, and POP gadget reduction as four metrics to measure the effects of debloating on different web applications.
However, not every line of code contributes equally to a program's attack surface.
For example, 15% of removed files from Magento 2.0.5 are test files for external packages and the core of the application.
Such code may not be directly exploitable or used in a POP chain unless there is a misconfiguration (e.g., autoloading including these files, or the directories being publicly accessible).
As such, the resulted reduction in source code metrics (CC and LLOC) may also reflect the code that does not contribute to the attack surface.
Contrastingly, the reduction of exploitable CVEs draws a more realistic picture of real world attacks.
The drawback of this metric is its unavailability for proprietary software and the manual effort required to map CVEs to source code and verify their exploitability.Debloating effectiveness: Through our debloating experiments we discovered that, in terms of debloating, not all applications are "equal."
Modular web applications debloat significantly better than monolithic ones (such as Wordpress).
We hope that our findings will inspire different debloating strategies that lend themselves better to monolithic web applications which resist our current function-level and file-level debloating strategies.
Over the years, different approaches that target very different parts of the software stack have been studied in the context of software debloating.
Despite the importance of the web platform, there has been very little work that attempts to apply debloating to it.
Snyder et al. investigated the costs and benefits of giving websites access to all available browser features through JavaScript [70].
The authors evaluated the use of different JavaScript APIs in the wild and proposed the use of a client-side extension which controls which APIs any given website would get access to, depending on that website's level of trust.
Schwarz et al. similarly utilize a browser extension to limit the attack surface of Chrome and show that they are able to protect users against microarchitectural and side-channel attacks [66].
These studies are orthogonal to our work since they both focus on the client-side of the web platform, whereas we focus on the server-side web applications.Boomsma et al. performed dynamic profiling of a custom web application (a PHP application from an industry partner) [34].
The authors measured the time it takes for their dynamic profile system to get complete coverage and the percentage of files that they could remove.
Since the application was a custom one, the authors were not able to report specifics in terms of the reduction of the programs attack surface, as that relates to CVEs.
Contrastingly, by focusing on popular web applications, and utilizing function-level as well as file-level debloating, we were able to precisely quantify the reduction of vulnerabilities, both in terms of known CVEs as well as gadgets for PHP object-injection attacks.
Regehr et al. developed C-Reduce which is a tool that works at the source code level [63].
It performs reduction of C/C++ files by applying very specific program transformation rules.
Sun et al. designed a framework called Perses that utilizes the grammar of any programming language to guide reduction [71].
Its advantage is that it does not generate syntactically invalid variants during reduction so that the whole process is made faster.Heo et al. worked on Chisel whose distinguishing feature is that it performs fine-grained debloating by removing code even on the functions that are executed, using reinforcement learning to identify the best reduced program [42].
All three aforementioned approaches are founded on Delta debugging [76].
They reduce the size of an application progressively and verify at each step if the created variant still satisfies the desired properties.Sharif et al. proposed Trimmer, a system that goes further than simple static analysis [68].
It propagates the constants that are defined in program arguments and configuration files so that it can remove code that is not used in that particular execution context.
However, their system is not particularly well suited for web applications where we remove complete features.
Our framework goes beyond this contextual analysis by mapping what is actually executed by the application.Other works include research that revolves mainly around static analysis to remove dead code.
Jiang et al. looked at reducing the bloat of Java applications with a tool called JRed [45].
Jiang et al. also designed RedDroid to reduce the size of Android applications with program transformations [44].
Quach et al. adopted a different approach by bringing dead-code elimination benefits of static linking to dynamic linking [61].
Rastogi et al. looked at debloating a container by partitioning it into smaller and more secure ones [62].
They perform dynamic analysis on system-call logs to determine which components and executables are used in a container, in order to keep them.
Koo et al. proposed configuration-driven debloating [50].
Their system removes unused libraries loaded by applications under a specific configuration.
They test their system on Nginx, VSFTPD, and OpenSSH and show a reduction of 78% of code from Nginx libraries is possible based on specific configurations.
In this paper, we analyzed the impact of removing unnecessary code in modern web applications through a process called software debloating.
We presented the pipeline details of the end-to-end, modular debloating framework that we designed and implemented, allowing us to record how a PHP application is used and what server-side code is triggered as a result of client-side requests.
After retrieving code-coverage information, our debloating framework removes unused parts of an application using file-level and function-level debloating.By evaluating our framework on four popular PHP applications (phpMyAdmin, MediaWiki, Magento, and WordPress) we witnessed the clear security benefits of debloating web applications.
We observed a significant LLOC decrease ranging between 9% to 64% for file-level debloating and up to an additional 24% with function-level debloating.
Next, we showed that external packages are one of the primary source of bloat as our debloating framework was able to remove more than 84% of unused code in versions that used Composer, PHP's most popular package manager.
By quantifying the removal of code associated with critical CVEs, we observed a reduction of up to 60% of high-impact, historical vulnerabilities.
Finally, we showed that the process of debloating also removes instructions and classes that are the primary sources for attackers to build gadgets and perform POI attacks.Our results demonstrate that debloating web applications provides tangible security benefits and therefore should be seriously considered as a practical way of reducing the attack surface of web-applications deployments.
The main purpose of our work is to quantify the security benefits of debloating web applications, allowing the community to have informed discussions about the advantages of debloating, without the need of vague references to attack-surface reduction.
To ensure the repeatability of our findings and to motivate more research in this area, all developed code and data artifacts are publicly available at: https://debloating.com.
