We present überSpark (üSpark), an innovative architecture for compositional verification of security properties of extensible hypervisors written in C and Assembly.
üSpark comprises two key ideas: (i) endowing low-level system software with abstractions found in higher-level languages (e.g., objects, interfaces, function-call semantics for implementations of interfaces, access control on interfaces , concurrency and serialization), enforced using a combination of commodity hardware mechanisms and lightweight static analysis; and (ii) interfacing with platform hardware by programming in Assembly using an idiomatic style (called CASM) that is verifiable via tools aimed at C, while retaining its performance and low-level access to hardware.
After verification, the C code is compiled using a certified compiler while the CASM code is translated into its corresponding Assembly instructions.
Collectively, these innovations enable compositional verification of security invariants without sacrificing performance.
We validate üSpark by building and verifying security invariants of an existing open-source commodity x86 micro-hypervisor and several of its extensions, and demonstrating only minor performance overhead with low verification costs.
The modern hypervisor stack is, by necessity, extensible.
Hypervisors not only enable the old-hat style of customization, such as modularity for device drivers, but are further extended with convenient functionality for security services such as attestation, debugging, tracing, application-level integrity and confidentiality, trustworthy resource accounting, on-demand I/O isolation, trusted path, and authorization [14], [18], [22], [49], [53], [57], [62], [64], [65], [71], [74], [75], [77], [80], [83]- [86].
Further, the overwhelming majority of the deployed hypervisor codebase is written in low-level C and Assembly, due to hardware accesses, developer familiarity, and performance requirements.
1.1.
Problem -The unbridled growth of these extensible hypervisors, while enabling useful functionality, † In the fictional Transformers universe, the AllSpark is a powerful object capable of creating a new Transformer by bestowing ordinary machinery with sparks -the building blocks of a Transformer.
In a similar vein, ÜBERSPARK bestows ordinary hypervisors with verifiable objects (ÜOBJECT) for automated compositional security analysis.
raises significant security concerns.
As the size and complexity of these systems increase -not to mention the number of extensions, which may be active in arbitrary combinations -so has the incidence of security-related bugs.
Indeed exploitable bugs in extension interfaces have led to compromises in various hypervisors ranging from complex VMMs to micro-hypervisors [2], [3], [26], [27], [44].
Thus, higher assurance in the security properties offered by hypervisors is critically important.
1.2.
Solution -We address this challenge by developing überSpark (üSpark), an architecture for building extensible hypervisors that: (a) is compatible with commodity systems; (b) enables automated compositional verification of security properties; and (c) produces performant systems.
Compatibility with commodity systems is crucial to impacting developers and deployment ecosystems.
üSpark supports development and verification directly at the C and Assembly source and enables access to more commodity hardware features.
It is thus distinct from prior approaches that sacrifice commodity compatibility by employing new programming languages or hardware models [33], [36], [81].
Compositionality means that extensible systems can be verified modularly, rapidly, and independently as they are implemented.
Specifically, when an extension is added, üSpark does not require complete system re-verification to re-establish properties.
While this goal guides much work in high-level languages, achieving it for low-level languages is a significant challenge.
Furthermore, it distinguishes us from verification of full functional correctness [31], [33], [43].
We focus only on security invariants -memory separation, control-flow integrity, information flow -and other extension properties that can be formulated as invariants.
We verify such properties directly, compositionally, and automatically on the C and Assembly implementation.
This helps bring to commodity-compatible hypervisors those on-going approaches, which offer full functional correctness, but we also enable precise reasoning on untrusted and unverified system code.
Finally, the üSpark hypervisor's performance is close to that of a commodity unverified system.Key to the power of üSpark is the enforcement of verifiable-object abstractions to hypervisors.
The basic building block is a üobject, which encapsulates specific system resources and provides an interface for accessing them -with a well-defined behavioral contract comprising a use manifest along with formal behavior specifications.
A üobject may represent core components of a hypervisor or an extension and may be concurrent or sequential.
Public methods of concurrent üobjects are invoked in parallel by multiple cores whereas sequential üobjects are implemented as monitors, guarding all method invocations via a per-üobject lock.
üObjects communicate with each other via function calls.There are two special üobjects: prime sets up a sane initial state, while sentinel ensures control-flow semantics even when üobjects with different levels of privilege and trust invoke each other.
Together, they enable compositional inductive proofs of security properties expressed as invariants over sequential üobjects via source code analysis and hardware assumptions [8].
A third group of special üAPI üobjects allow access to shared resources enabling state-of-the-art tools for automatic verification of sequential C code to be soundly applied to verifying security properties, while still allowing multithreaded high-performance applications.In keeping with our first and second design goals, üSpark enforces verifiable-object abstractions using a combination of commodity hardware mechanisms (pagetables and de-privileging) and light-weight static analysis, leveraging off-the-shelf C99 source-code analysis and certified-compilation tools.
üObjects, including prime and sentinel, are automatically and modularly verified using Frama-C [41], an industrial-strength software analysis and verification framework.
We use standard and custom Frama-C plug-ins to perform static verification checks that include: per-üobject behavioral contracts (via a standard weakest-precondition plug-in); abstract variable assertions that enable behavioral asserts as well as üobject control-flow integrity (via a standard abstract-interpretation plug-in on stack frames and other variables); syntactic checks that ensure conformance with a restricted C99 syntax and logical de-privileging of üobjects (via a standard abstract syntax tree analysis plug-in); and, composition checks that enable client üobjects that share a common server üobject to compose soundly (via a custom composition-check plug-in).
üSpark also provides an idiomatic use of Assembly, called CASM, to separate it from C code during system construction.
During analysis with Frama-C, the CASM code is replaced by a C99 hardware model which models key commodity hardware features.
Our custom Frama-C plug-in checks that the syntactic restrictions imposed by CASM are respected by every üobject.
The verified üobjects are then compiled into executable binaries.
During üobject compilation, all C99 code is processed using the certified CompCert compiler [12] while each CASM instruction is replaced by the corresponding Assembly instruction by our custom Frama-C plugin.
The CASM language is designed to ensure that the C and Assembly code operate on disjoint state.
Our longer-term goal is to guarantee that the verified source code properties carry over to the binary by leveraging the C-Assembly separation and cleanly extending the bisimulation proof of the CompCert compiler to encompass hardware state and Assembly code.
In addition, we aim to ensure the semantic equivalence between the hardware model and the corresponding Assembly instructions.
Proving these guarantees formally appears straightforward, and need only be done once for the üSpark framework, but we leave it to future work.The üSpark object abstraction is distinguished from other systems in that it allows many fine-grained objects in privileged mode.
Static analysis enforces logical deprivileging of those objects -e.g., a hypervisor module running in host-mode ring 0 is precluded from accessing page-table structures, thereby being "logically" deprivileged -while control transfer between them does not involve a context switch, thereby significantly helping with system performance, our third design goal.
1.3.
Contributions -(a) We present üSpark, an innovative architecture providing verifiable object abstractions for automated compositional verification of hypervisor security properties while targeting commodity compatibility and performance ( §4, §5).
(b) We use üSpark to incrementally develop and verify security properties of an existing open-source commodity x86 micro-hypervisor with multiple independent security extensions (hypervisor and extensions realized as 11 üobjects with 7001 SLoC; 5544 and 2079 lines of annotations and hardware model; §6, §7).
(c) We carry out a comprehensive evaluation showcasing verification metrics, development effort and performance, and report on our experience (1 person yr; üobject verification times from 1-23 minutes with a cumulative time ≈ 1hr; 2% average runtime overhead over native micro-hypervisor applications with guest performance unaffected; §8, §9).
To motivate and explain üSpark, we use as a running example, a hypervisor that closely corresponds to our case study.
Imagine the hypervisor managing a multi-CPU guest, and supporting optional security extensions that implement various guest-specific and system-wide security properties.
The hypervisor manages system devices used by itself, by extensions, and by the guest.
System devices execute device firmware in parallel with the CPUs and perform DMA.
The hypervisor and extensions are written in C and Assembly.The hypervisor leverages CPU capabilities, such as memory-mapped I/O (MMIO) and legacy I/O, for system-to-device interaction; it initializes boot CPU (BSP) state; it sets up memory page tables, as well as device allocations and DMA protections (e.g., via an IOMMU); it initializes multi-CPU support via the Local Advanced Programmable Interrupt Controller (LAPIC) and activates other CPUs and sets up their memory page tables and appropriate protections.
Constructing a verified hypervisor of this sort, the developers must not only build it and test it well, but also verify its code against a set of general safety properties (e.g., memory integrity) as well as functional invariants on hardware and software state (e.g., IOMMU, LAPIC, CPU states).
Consider now adding two new verified extensions to the hypervisor: hyperdep, which ensures that guest-VM data pages are non-executable; and (b) sysclog, which ensures that every system call issued by the guest is logged via a dedicated network card to an external trusted entity on the network.
In order to preserve the verified status of the system, the developers must prove that: (a) memory integrity is not violated by the extensions; (b) each extension provides its claimed property to guests configured to use it; and (c) the extensions are used in tandem by a guest if and only if they provide a well-defined compositional property (e.g., separability).
This is non-trivial, since it requires the construction and verification of inductive invariants that imply the core security properties of the hypervisor, and those of enabled extensions.
Also, since extensions are optional, verification must account for all possible configurations -e.g., enabling either hyperdep, or sysclog, or both -while avoiding the combinatorial blowup.Of course, history tells us that two extensions are never enough for any extensible system.
What is more, not all extensions come from the same developers or with the same pedigree.
Consider, for instance, an unverified, strictly optional extension to the hypervisor; this might be an extension that provides essential functionality, but has not been verified, and is taken as an acceptable risk.
For our example, let us use aprvexec, an extension that ensures that guest code pages contain only read-only, whitelisted content.
As with hyperdep and sysclog, core hypervisor properties, and the properties of other extensions should not be violated by running aprvexec, and the risk of running aprvexec should only be suffered by a guest that explicitly enables it and relies on its presumed properties.
Note that the guest itself, unless it is verified as rigorously as the rest of the hypervisor, is such an unverified component in the system.
3.1.
Goals -Our overarching goal is to enable development of performant extensible hypervisors offering proofs of wide-ranging properties on their code, including low-level memory safety, control-flow guarantees, and information flow, as well as higher-level properties such as trusted network logging (sysclog) and data execution prevention (hyperdep), going all the way up to security properties spanning both hardware and software states (IOMMU, LAPIC, network-card and CPU).
Also, verification must support properties over shared system states: e.g., both hyperdep and sysclog manipulate guest memory protections via the same guest pagetables.
Our design goals fall broadly in three categories.
3.1.1.
Compositionality: When new components are added, or existing components changed, human reverification effort should be limited to the changed codebase, yet it should provide guarantees about the entire system under all possible configurations.
Our development and verification approach must integrate into the existing hypervisor C and Assembly language programming ecosystem, and cover the entire source code base including commodity hardware and guest OS.
We must support extensions that are unverified in order to preserve the legacy ecosystem.
However, unverified code (e.g., the guest) must not violate system properties established by verified code.
Our development and verification techniques must foster wider adoption by hypervisor developers.
We envision that entry-level developers will rely on basic building blocks to provide simple properties while seasoned developers will harness the full verification power to provide stronger guarantees.
3.1.3.
Performance: Verification must not preclude aggressive code optimizations for individual components, including extensions, and must not adversely affect runtime performance.
Further, commodity guest OS on multi-core hardware must be supported.
3.2.
Non-goals -We do not aim for full functional correctness (i.e., verifying that the implementation behaves exactly as specified in a high-level abstraction).
This separates the concerns of showing how a complex low-level system achieves low-level formal properties from how those low-level properties refine a high-level abstract model; we focus on the former, since it is a hard and as yet open problem, whereas much on-going work tackles the latter [31], [42].
3.3.
Attacker Model and Assumptions -We assume that the attacker does not have physical access to the CPU, memory, chipset or other verified extensionspecific system devices (our hardware TCB).
Other system devices, the guest OS, and unverified extensions are under the attacker's control.
This is reasonable since a majority of today's attacks are mounted by malicious software or untrusted system devices.
We assume that our hardware TCB is functionally correct, and we have load-time integrity, i.e., the verified hypervisor is the one securely loaded onto the hardware at boot time.
Finally, we assume that the verification tools we use are sound.
We next describe our architecture, and how it addresses our goals ( §3.1) via verifiable object abstractions (Fig 1) 4.1.
üObjects -The basic building block in üSpark-the "üobject" -is used to contain any system component including verified and unverified hypervisor and guest blobs and system devices.
Logically, a üobject is a singleton object guarding some otherwise indivisible resources (e.g., registers, memory, devices) and implementing public methods to access them.
Public methods are essentially regular function signatures but can be restricted to specific callers ( §4.2.1).
Every üobject also has a special public method, init, to set up the üobject in a known-good initial state.
A üobject may be concurrent or sequential.
The public methods of a concurrent üobject can be invoked in parallel on multiple cores.
In contrast, at most one core can invoke the methods of a sequential üobject at a time, as with a traditional monitor.
When multiple cores are active, sequential execution is enforced via per-üobject locks.Each üobject defines its functionality using C and Assembly.
Assembly language for a verified üob-ject is written using CASM, a dialect of C in which Assembly instructions are encoded within regular C functions (CASM functions) via C-like pseudofunction calls (CASM instructions 1 ).
For example, for the x86 instruction movcr3 involving register eax there is a corresponding CASM pseudo-function called ci_movl_eax_cr3.
Each CASM instruction pseudofunction is defined in the üSpark hardware model ( §7.1.2) and bridges the shift between the reference C semantics and the hardware instructions (e.g. access to memory and to registers).
During verification, each CASM instruction is replaced by the C source code from the hardware model.
The resulting C-only program is verified for required properties.
CASM functions are verified to respect the C application binary interface (ABI), which is crucial for the soundness of verification.
During compilation, all C functions are processed via a certified compiler while each CASM instruction is replaced by the corresponding Assembly instruction.
In contrast to prior code-level verification approaches ( §10), CASM supports two-way nested C to Assembly calling with full device modeling.
This allows using various verification techniques to prove (higher-level) properties on device states other than just memory and numeric safety ( §7.2).
CASM also allows aggressive compiler optimizations of the callee C functions including inlining as per compiler specifications, resulting in optimal runtime performance ( §8.3).
We envision further optimizations including inlining of hand-written CASM code as part of our future work ( §11.2).
Beyond defining its own functionality, a üobject is also accompanied by a behavior contract.
This consists of a use manifest ( §4.3) and a formal behavior specification of its own public interface, which guarantee that if a certain assumption is satisfied in how a public method is invoked, then a property on the return values is guaranteed to hold upon return of that method, without mention of internal üobject state.Every üobject is held to a number of invariants, which together guarantee its adherence to the verifiableobject abstraction.
These invariants include memory and (internal) control-flow integrity, so that the code can be reasoned about; and satisfaction of the formal contract, so that the contract alone may overapproximate the üob-ject, thereby enabling compositional verification; as well as correct initialization.
The invariants are discharged via assumptions on the hardware and proofs on the source code of the üobject, and on the contract of üobjects it interacts with ( §5, §7.2).
While our use of object encapsulation is similar to existing micro-kernel architectures [42] and prior capability systems [32], [63], üSpark is distinguished by privileged disaggregation, i.e., multiple verified privileged üobjects can be logically deprivileged.
This enables us to achieve the sweet spot with both high performance (there is no hardware de-privileging overhead; §8.3.1) and compositional verification (privileged üobjects can be verified seperately; §7.2).
4.1.1.
Prime: is the first üobject to execute in a üS-park enabled hypervisor.
Prime is verified to satisfy its contract which is: to set up the required system interfaces and associated policies, establish operating stacks, prepare the platform CPU cores, invoke the init methods of other üobjects to initialize their state, and kick-start üobject interactions.
4.2.
üObject Interaction -A üobject interacts with another by invoking a public method in its interface with appropriate parameters.
All verified üobjects operate on a single stack (one per CPU core) that is set up initially by the prime.
Each unverified üobject uses its own, separate stack.
The verifiable-object abstraction requires üobject-to-üobject control-flow integrity (otherwise returns could land at arbitrary üobject program sites, access controls would be violated, etc.).
Therefore, üobjects must also be verified to use their stack correctly (another invariant).
For unverified üobjects, that also means that stacks must be switched to/from the unverified üobject stack and a separate shadow stack must be maintained for storing return addresses during control transfers.
The special sentinel üobject performs (verifiably) this functionality.
4.2.1.
Sentinel: is a special üobject that mediates interactions among other üobjects.
Thus, an invocation of a public method of a callee üobject by a caller üobject is intercepted by the sentinel and dispatched only after a number of optional runtime checks have succeeded.
These runtime checks logically ensure that the caller may invoke a given public method on the callee according to the üobject manifest ( §4.3).
For example, an extension can be split between a top half and a bottom half as with traditional device drivers (in our case study, sysclog could shed its networking code into a separate üobject, sysclognw, that only takes transmission requests from sysclog, and is the only authorized user of a separate NIC dedicated to logging), ensuring that only the top half may invoke the bottom half at runtime, while still keeping the two isolated from each other and independently verifiable.
If caller and callee are both verified, then no runtime check is required, since static analysis enforces the call policy ( §4.3).
If one is unverified, the sentinel consults the policy dynamically and allows or rejects the call accordingly.Besides the runtime checks, the sentinel is responsible for transfering control among üobjects.
If both are verified, the control transfer is just a function call.
But if either is unverified, the sentinel must employ the appropriate control-transfer method for the isolation mechanism imposed on the unverified üobject (e.g., if using ring-based isolation, switch privilege levels and stacks, marshal arguments, etc.).
The sentinel may implement control transfers according to a number of concrete ways (hardware virtual machines, software fault isolation, etc.), while still adhering to the high-level invariant for isolation.
For example, in our micro-hypervisor implementation, the sentinel traverses both ring-based isolated üobjects, and hardware virtual machines ( §6).
The sentinel is an üobject, so it adheres to the same invariants as regular üobjects, but it is also verified to implement its function correctly (perform the checks, properly transfer control, etc.).
4.3.
üObject Resource Confinement -üSpark implements üobject resource confinement in which distinct system resources are: (a) managed by designated üob-jects, (b) protected from access by unauthorized üob-jects, and (c) regulated in their use by authorized client üobjects.
Such resources include üobject local memory (code, data, stack), system memory (e.g., BIOS data, free memory), CPU state and privileged instructions, system devices and I/O regions.
Every üobject includes a use manifest in its contract that describes which resources it may access.
It is held to the property that it can only use the resources declared in its manifest.For verified üobjects, üSpark employs a hardware model identifying CPU interfaces to system resources (e.g., I/O and designated memory instructions interface to system devices, instructions that can modify CPU model specific register states, etc.) and static analysis to ensure that access to those interfaces respects the üob-ject's manifest ( §7).
For example, sysclog's manifest shows that it may access the dedicated NIC for its remote logging, and static analysis ensures that the code for sysclog may access only that NIC, nor can any other üobject access sysclog's NIC.In contrast, unverified üobjects are held to their use manifests via more direct enforcement mechanisms, such as hardware MMU and privilege protections (virtualization, de-privileging) and software manipulations (e.g., SFI).
Unverified üobjects can also be granted direct access to exclusively held system devices so they can perform I/O without any performance overhead (e.g., a guest OS üobject is allocated all the devices except the LAPIC and sysclog's network card).
Device üobjects use DMA as their interface to other üobjects.
üSpark uses hardware IOMMU capabilities to ensure that device üob-jects are restricted to perform DMA only to designated üobject DMA memory regions.
4.3.1.
üAPI üobjects: are a special set of üobjects that encapsulate shared resources over which system properties are established ( §6.4).
For example, guest OS üob-ject memory and CPU state are manipulated by multiple extensions (hyperdep and sysclog).
üSpark enforces a composition check ( §7.2.1), which for a given set of üAPI üobjects checks if a set of "client" üobjects are composable.
Note that every üAPI üobject also performs composability checks at runtime for invocations from unverified üobjects.
Such composability checks reason about the use-manifest portion of a client üobject's contract, which constrains how that üobject invokes the üAPI's public methods, ensuring some system-specific and üAPI-specific composability guarantee, such as separability.
Client üobjects must satisfy the property that whenever they invoke a üAPI call, they obey their own use manifest, and üSpark discharges this property via static analysis on verified üobjects or runtime sentinel checks for unverified üobjects.
4.4.
üSpark Blueprint -üSpark also defines a hypervisor blueprint (üBP), which a hypervisor implementation is held to.
The üBP is a high-level control-flow graph that divides hypervisor execution into three phases: startup, intercept, and exception handling which can in turn be customized based on the actual number of system üob-jects and their interactions (Figure 2; §6).
The üBP along with our high-level proofs ( §5) enables us to abstract the hypervisor, running on multi-core platform hardware with system devices and DMA, as a non-deterministic sequential program.
This, in turn, allows us to prove invariant properties of üobjects, and the hypervisor as a whole, via sequential source-code verification.
Further, the üBP also enforces that fragile bits of the hardware state (e.g., CPU and IOMMU) are only touched within a monitor.
This, allows us to prove invariant properties encompassing hardware states and keeps our hardware model simple by precluding modeling of concurrent hardware accesses ( §7.1.2).
We present a formalization of üSpark that justifies the soundness of our analysis.
For brevity, we first give an overview of the formal reasoning followed by our highlevel verification approach and related theorems.
Full proof details can be found in our technical report [73].
5.1.
üSpark Formalism Overview -üSpark reasoning relies foundationally on a set of invariants -properties that must hold throughout the execution of a üSpark hypervisor (Appendix A).
The invariants are divided into üSpark system invariants and üSpark general programming invariants (those that pertain specifically to üobject C and CASM functions).
Each invariant is proved by reducing it further to a set of proof-assumptions on hardware (PAHs) and proof-obligations on code (POCs) using the üSpark blueprint (üBP; Fig. 2).
POCs are then discharged on all üSpark verified üobjects including the prime and sentinel using specific verification tools and techniques ( §7).
A hypervisor implementation is compliant with üSpark-and therefore amenable to compositional reasoning -if it satisfies all the üSpark invariants.
Full details of invariant-to-PAH/POC mappings, a onetime effort, is described in [73].
At a high level, üSpark invariants ensure the hypervisor implementation follows the üBP and that prime is correct, and the first to start in the system, and that it sets up memory protections, stacks, and CPUs, before starting other execution contexts in a well-defined state.
The remaining invariants guarantee that üobjects have memory and control-flow integrity, and the sentinel properly transfers control among them, respecting the concurrent or sequential designation.
5.2.
Verification Approach and Theorems -There are two tasks in verifying properties of a üSpark hypervisor: (a) showing that it obeys the üSpark invariants; and (b) showing that it obeys any hypervisor/extension-specific invariant properties.
The benefit of (a) is that developers can express system-specific properties in terms of üobjects and their interactions with each other, yet verify those properties separately on each individual üobject in isolation, and on the ensemble of the behavior contracts of all üobjects, without having to perform slow verification of the combined source code for the whole code base.Crucial to the model of üobject are CASM programs, defined below.
First, we define a CASM function as a CompCert-C99 (CC99) function whose body consists only of a block of Assembly instructions that respect the CC99 ABI.
A üobject CASM program is a CC99 program such that: (i) all Assembly code appears only in CASM functions; and (ii) these CASM functions preserve the caller C functions' CPU register state.Given a üobject CASM program, we are interested in verifying two kinds of properties: (1) invariant properties: whether ϕ holds at every state (after every instruction), and (2) individual state assertions: whether ϕ holds at specific program points.
We can also specify assumptions (i.e., preconditions), stating that we assume ϕ holds when a function is called.
Verification tools such as Frama-C ( §7) take programs annotated with properties to be checked and decide whether the properties hold on all execution traces of the program.We begin by stating two üSpark theorems essential for the correctness of our approach, which follow directly from the üSpark programming invariants (Appendix A).
Theorem 1 (DISJOINTCASM).
The union of üobject CASM and C functions preserve the existing semantic preservation property of the certified compiler.Theorem 2 (EXITSENTINEL).
üobject execution can only exit via the sentinel.The next theorem states that each üSpark execution is an interleaving of properly nested executions of üobjects, one on each core (a more formal definition can be found in [73]).
Intuitively, it means that üobject calls and returns are properly nested except that the return of an unverified üobject can be an exception, as an unverified üobject can lie about its return address, but will be caught by the hardware if it steps out of the üobject memory.
This theorem enables us to view üSpark semantically as a concurrent object-oriented program, which is then abstracted as a non-deterministic sequential program for verification.
π of üSpark and a sequential üobject s.
The projection of π on executions of s consists of a sequence of properly nested executions of s, each on a specific core.
We use C verification tools to verify CASM functions in üobjects by converting Assembly to C.
In addition to general-purpose registers (which are preserved to respect the CC99 ABI) these Assembly instructions access special hardware registers (e.g., LAPIC).
Let us denote the set of registers accessed by CASM functions in üSpark by R hw .
We introduce a set of fresh C variables (denoted V hw ), one for each register; replace each Assembly instruction accessing R hw by one or more CC99 statements that operate in a semantically equivalent way over V hw ; replace each r ∈ V hw with v r in assertions used for specifying hardware state during verification.
We refer to the mapping between R hw and V hw , and the induced mapping from Assembly instructions to CC99 statements, as our hardware model.
We assume that this mapping is correct.
We refer to the CC99 function obtained by transforming a CASM function f in this manner as 񮽙 f .
5.2.2.
Abstract üSpark: We abstract üobjects as a nondeterministic CC99 (NDCC99) program, i.e., a CC99 program with non-deterministic selection of values from finite sets.
In particular, the abstract üSpark üBP consists of a set of abstract üobjects, where each abstract üobject 񮽙 s is obtained from the corresponding concrete üobject s by converting each function g ∈ p(s) to an abstract function 񮽙 g; more concretely: by replacing all CASM functions as described above, replacing accesses to data that other cores and devices can modify by nondeterministic values, replacing a call to an unverified üobject by a call to the intercept handler üobject with non-deterministic arguments.
The next theorem states that each function g in a sequential üobject refines its abstract version 񮽙 g in that for each properly nested execution of g, there is a corresponding execution of 񮽙 g.
This is crucial to the soundness of our verification.
We use C verification tools to verify POCs directly on üBP (NDCC99 programs) of üSpark.
Theorem 4 allows us to lift the verification results to üobject source-code, formally stated in the following theorem (we only show the statement for invariant properties; the statement for individual state assertions is similar).
Theorem 5 (INVCOMPOSE).
Given any sequential üob-ject s, let 񮽙 s be the üBP abstraction of s.
If an invariant property ϕ holds on every execution of 񮽙 g(s), then ϕ is an invariant property of every execution of s.
We applied üSpark to XMHF, an open-source microhypervisor for the x86 32-bit hardware-virtualized platform [72].
Originally, XMHF consists of a core hypervisor and a single extension (called hypapp), that together implement security-specific functionality.
The latest version (0.2.2) runs a Ubuntu 12.04 32-bit multicore guest OS with the core and hypapp at the highest privilege level and has been used to develop a wide variety of security applications [53], [74], [83], [85], [86].
Our goal is üXMHF-an incrementally developed and verified version with deprivileged components, and multiple hypapps.
As a first step, we refactor XMHF into: (a) verified hypervisor (vh) üobjects for prime, sentinel, core, üAPIs, and verified hypapps; (b) unverified hypervisor (uh) üobjects for unverified hypapps; and (c) unverified guest (ug) üobjects for the OS (Figure 2); §8 quantifies this refactoring effort.
6.1.
Core, Hypapp and Guest üObjects -We instantiate üXMHF core using three vh üobjects: xcstrt (startup), xcihub (handling ug üobject intercepts), and xcehub (runtime harware exception and watchdog handling).
We instantiate extensions described in §2 as separate vh and uh üobjects and add support for multiple hypapps within xcihub.
Finally, we instantiate a ug üobject, guest for the guest OS.
The xcstrt üobject gets control from the prime üobject ( §6.2), invokes all registered hypapp üobjects for initialization, and then transfers control to guest.
The xcihub üobject gets control from the sentinel upon any intercept ( §6.3) and in turn invokes the hypapp üobjects for guest event processing.
Upon intercept handling, xcihub resumes execution of guest ug üobject (Figure 2).
Finally, for each CPU in the system, prime: (a) activates protected-mode with paging and hypervisor-mode via control registers CR0 and CR4 and the VMXON instruction; (b) sets up SYSENTER MSRs, interrupt descriptor table and VM control structure (VMCS) to transfer control to the sentinel; and (c) loads vh page tables in CR3 and transfers control to xcstrt core startup üobject.
6.3.
Sentinel üObject -For vh to vh üobject control transfers, the sentinel uses an indirect JMP instruction.The SYSEXIT and SYSENTER fast system call instructions are used vh to uh control transfers and vice-versa.
In such cases, the sentinel loads the uh page tables into the CR3 register and transfers control to the uh üobject entry point (or return address via the SYEXIT instruction) at the de-privileged level.
The sentinel uses the VMLAUNCH instruction for a call from a vh to ug üobject.
It handles intercepts by transferring control to the vh xcihub üobject and upon return from xcihub resumes the ug üobject via the VMRESUME instruction.
In both cases, it loads the ug üobject EPTs prior to the launch.
The sentinel handles exceptions by transferring control to the vh xcehub üobject.
Upon return from xcehub execution is resumed via the IRET instruction.
6.4.
üAPI üObjects -Both the core and hypapp üob-jects use üAPI üobjects to influence the ug üobject state.
This state includes the ug üobject EPTs and VMCS.
We implement üAPI üobjects ugmpgtbl and ugcpust which present interfaces to the ug üobject EPTs and VMCS respectively.
We also implement an additional üAPI üobject uhcpust as an interface to shared CPU state between vh and uh üobjects (e.g., MSRs).
6.5.
üObject Runtime Library -üObjects rely on a set of common functionality implemented in the following libraries: (a) libuc with memory and string functions; (b) libucrypt with SHA-1 functionality; (c) libustub with üobject entry and sentinel CASM stubs; and (d) libuhw for platform hardware access.
7.1.
Verification and Development Tools -We first describe the verification and development tools we use.
7.1.1.
Static Analysis with Frama-C: Frama-C [41] is an industrial-strength C99 static analysis and verification toolkit, written in type-safe OCaml.
It has a modular architecture and offers different plugins for distinct styles of analysis.
We use the following Frama-C plugins: Deductive verification via Frama-C's WeakestPrecondition (WP) plugin enables the verification of assume-guarantee behavior specifications on C functions.
Those specifications are expressed in the Annotated ANSI C Specification Language (ACSL) [25] in terms of the C source variables and operations.
The WP plugin verifies such ACSL specifications statically on the body of the function by discharging verification conditions via an ensemble of external SMT solvers.
Abstract interpretation via Frama-C's Value plugin analyzes a program using a sound abstraction of its concrete semantics.
It is used to prove ACSL assertions placed in the body of the program that express partial specifications about program variables, and can be combined with deductive verification.
Abstract syntax tree (AST) analysis via Frama-C's AST plugin performs syntactic analysis on control-flow graphs and ASTs to enforce syntactic restrictions, e.g., the absence of primitives like function pointers.
7.1.2.
Hardware Model: We have implemented a C99 hardware model for the commodity x86 hardwarevirtualized platform, by representing platform features such as CPU registers and system-device states as C variables and describing formally how the hardware (should) behave.
The hardware model is a re-usable but trusted component.
Our hardware model allows for iterative development, modeling only portions of the device used in proving security invariants.
This design principle, coupled with serialization enforced by the üSpark architecture blueprint ( §4.4), enables us to keep the hardware model simple and amenable to formal validations.
Various techniques exist to validate such a hardware model [50], [58] which we plan on exploring as future work ( §11).
We built üSpark-specific plugins on top of Frama-C as follows: (a) übp -enforces üSpark blueprint; (b) ühwm -embeds hardware model during verification; (c) ücasm -substitutes Assembly mnemonics corresponding to CASM instructions after verification; (d) ücc -enforces general üSpark coding rules; (e) ümf -parses üobject manifest; and (f) ücvf -performs composition check ( §7.2.1).
These üSpark-specific plugins do not impact the robustness of the Frama-C toolset as we do not modify the kernel or standard plugins.
Further, Frama-C's modular architecture helps us keep üSpark-specific Frama-C plugins small, simple, and amenable to manual audits to ensure correctness ( §8.1).
In keeping with our longer term goal of guaranteeing that the verified source code properties carry over to the binary, we employ the CompCert [11], [12], [46] certified C99 compiler to compile üobjects.
CompCert over-specifies C99 implementation-defined and unspecified behaviors and is formally verified to produce semantically equivalent Assembly from a C99 program.
Our choice of Frama-C and CompCert is further justified by their semantic compatibility.
We empirically tested Frama-C against CompCert's C99 specifications and found that both tools had the same treatment of C99 implementation-defined and unspecified behaviors.
Further, both tools employ an identical byte-addressable memory model with base addresses and offsets.
Therefore, they combine naturally into a powerful analysis and development workflow towards producing verified system binaries.
7.1.5.
Soundness Via Weakening: We weaken our execution model in two cases to enable sound reasoning.
First, since current state-of-the-art static analyzers including Frama-C largely assume sequential execution, we treat all reads to DMA memory and all memory reads by a concurrent üobject as non-deterministic, for verification to soundly model interference from devices and other cores.
Second, we preclude use of C function pointers and CASM indirect jump instructions, which remain challenging for current state-of-the-art static analyzers [21].
In practice ( §7.2), this weakining does not stop us from verifying important security properties, since such properties are implemented via sequential üobjects using non-DMA memory.
7.2.
üXMHF Verification -Verification of üXMHF consists of: (a) üobject composition check, and (b) verifying üSpark invariants ( §5) and üobject local properties.
Throughout this section we use vh, uh and ug as acronyms for verified and unverified hypervisor and unverified guest üobjects respectively.
7.2.1.
üObject Composition Check: Resources accessed by multiple üobjects are guarded by üAPI üobjects ( §4.3.1).
Here we check that all üobjects are composable over the set of üAPIs they use.
At a high level, this is checked by constructing an assertion that captures the conjunction of the possible values that the two üobjects write to a shared resource, and then verifying that this assertion is not violated.
More specifically, for every üAPI üobject, an interface stub function is first created using its manifest.
Next, the stub is populated with invariant definitions and assertions (if any) listed in the manifest of every vh and uh non-üAPI üob-ject that invokes it.
Figure 3a shows an example stub for ugmpgtbl üAPI üobject setentry interface with hyperdep and sysclog hypapps enabled.
Lines 2-6 are populated using the corresponding hypapp üobject manifests.
Figure 3b shows the same stub with sysclog and aprvexec hypapps enabled.
Finally, the assertions in the stub are verified under non-deterministic inputs.
For example, hyperdep and syclog both set the read, write and clear the execute bits for the memory protections of the provided guest memory-page (lines 2-3) and are therefore composable; the assertions (lines 4-6) in Figure 3a are valid.
However, sysclog and aprvexec are not composable (Figure 3b) since aprvexec sets the execute bit while sysclog clears the execute bit in the protections for the provided memory-page (lines 9-10).
Note, such composition check assertions are also performed at runtime for üAPI invocations from uh üobjects ( §4.3.1).
This composition check procedure is üXMHF-specific, and a more general check is an interesting direction for future work.
7.2.2.
üObject Compositional Verification: As we discussed in §5, we first verify üSpark invariants via a set of PAHs and specific POCs on all vh üobjects including the prime and sentinel.
§7.2.3 describes POC verification in further detail.
We then verify each of the üXMHF core, hypapp and üAPI üobjects for their local invariants.
For brevity we summarize the hyperdep üobject verification approach here.
Appendix B lists the invariants and verification approach for other üXMHF üobjects.
hyperdep preserves the following invariant over the ugmpgtbl setentry üAPI: guest OS provided memory pages are marked read-write and not executable.
We use deductive verification to verify the hyperdep üobject activate method to ensure that the guest page address that is passed is used as the parameter to the ugmpgtbl üobject setentry method with read, write and no-execute protections.
Finally, we verify the üobject runtime library ( §6.5) for memory safety including behavior specifications for the memory and string functions within libuc.
Note, uh üobjects are not verified since their properties follow from üAPI invariants.
ensured by our composition check ( §7.2.1).
7.2.3.
POC Verification: For brevity, we choose a sampling of POCs from a few üSpark invariants (Inv 4 ü , Inv 6 ü , Inv 6 üprog , Inv 7 üprog , and Inv 10 ü ; see Appendix A and [73]) that showcase the importance of all the verification techniques described in §7.1.1.
All the üSpark invariant POCs are verified using a combination of these techniques.
Note that examples described below are necessary (but not sufficient since they are a sample) for the high-level proofs; for example the NESTEDCALL theorem ( §5) cannot be proved if there is no non-overlapping, unity-mapped memory (Inv 4 ü ) or DMA protection (Inv 6 ü ).
Figure 4 shows a POC code snippet -from the vh üobject page-table setup function within prime -for Inv 4 ü verified using deductive verification.
ACSL requiresassign-ensure clause triples (lines 4-11) are used to specify function behavior.
In this case they specify that every memory address in the page tables is disjoint with virtual-to-physical unity mapping.
ACSL loop invariant clause allows specification of loops with data structure invariants (lines 17-25).
Finally, ACSL ghost variables -C statements and variables only visible in specifications -are most notably used for modular reasoning of nested function calls.
For example, line 28 invokes a support function for obtaining the memory protection of the specified memory address.
This is aliased into a ghost variable which can then be used within the specification (line 29).
In summary, the requires-8 ... assigns-ensures clause triplet is sufficient to represent the function behavior, and the loop invariants and ghost variables within the function are used to prove the clause triplet.
ACSL is highly expressive with global and type invariants, including first-order, polymorphic, recursive and higher-order specifications [25].
priate verification driver callbacks whenever such device registers are written to (line 12).
This ensures required device state invariants.
For example, assertions in lines 16-17 of the IOMMU control register callback ensure that DMA page-table protections when enabled always point to the populated DMA page tables (which are populated by the prime in a separate function not shown).
This ensures that devices can only perform DMA to üobject DMA memory region.
Similar techniques are used to: (a) hook designated CASM instructions for üobject access to system memory including ug üobject memory regions; and (b) proving intra-üobject CFI in the presence of both C and CASM functions by ensuring that CASM functions respect the C ABI and preserve callee registers and stack frames (via corresponding hardware model callbacks, assertions, and ACSL annotations).
POCs for Inv 6 üprog and Inv 7 üprog are verified by analysing the abstract syntax trees (AST) to preclude statements involving function pointers in C functions and to ensure CASM functions always end with a CASM ret instruction respectively.
The POC for Inv 10 ü is verified via CFG analysis to enforce üSpark blueprint conformance.
Similar AST-based techniques are employed to: (a) embed hardware model statements, (b) substitute Assembly mnemonics, and (c) ensure soundness of the hardware model by precluding C functions from touching hardware model functions and variables and vice-versa.
8.1.
System size and Verification TCB -üXMHF is implemented in 7001 SLoC verified privileged code split into 11 üobjects with 5544 lines of ACSL annotations and 2079 lines of hardware model ( Figure 6).
We also implemented an unverified hypervisor extension (aprvexec; 199 SLoC) to illustrate how unverified and verified hypervisor üobjects interact.
Depending on the properties, üobject verification takes 48 seconds to 23 minutes, and up to 1.1 GB of memory.
Cumulative verification time is just over an hour, comparing favorably to related verification efforts [34].
Compositional verification enables each üobject to be (re-)verified separately.
The prime üobject takes the longest to verify, but typically does not change as often as other üobjects.
Decomposing prime into multiple üobjects can further reduce its (re-)verification time significantly.
Our verification TCB comprises the ACSL annotations, the hardware model ( §7.1.2), and Frama-C with associated plugins.
Modularity of üobject programs helps keep annotations small and feasible for manual review.
Various orthogonal techniques exist to validate our hardware model [50], [58] that we plan to explore as future work.
Frama-C is an industrial-strength tool used in many critical systems today [41]; we did not encounter any soundness bugs in these tools ( §9).
Frama-C üSpark specific plugins (totaling 1021 SLoC of OCaml; Fig- ure 7) are modular, simple, and built upon the existing Frama-C kernel and plugins making them amenable to manual audits.
Overall, our TCB compares favorably with other prior approaches (Figure 8).
8.2.
Developer Effort -üXMHF was developed and verified in a year by a single system developer who was new to Frama-C/ACSL.
A fraction of the time was spent adding implementation support for multiple hypapps with a greater part spent on porting to the üSpark hypervisor architecture by creating required üobjects and adding verification related harnesses and annotations.
Annotation-to-code ratio (ACR) ranges from 0.2:1 to 1.6:1 ( Figure 6).
For üobjects whose properties rely solely on üAPI's the ACR is small (e.g., hyperdep).
üObjects with properties requiring functional correctness (e.g., sysclog and xcihub) have relatively larger ACR.
The prime and sentinel üobjects have the highest ACR since they discharge most of the üSpark invariants.
8.3.
Performance Measurements -All performance benchmarks were carried out on a Dell Optiplex 9020 with an Intel Core-i5 4590 quad-core processor with 4GB of memory.
All üobjects were compiled with full compiler optimizations turned on.
call overhead for verified-to-verified üobject transitions is 2x w.r.t NULL function call (Figure 9).
This is due to control transfers to the sentinel and üobject entry points and return addresses via JMP instructions.
For transitions involving unverified üobjects the sentinel overhead is broken up into: (a) software overhead such as register saving, parameter marshalling, and call-policy enforcement; and (b) hardware deprivileging overhead.
As seen, segmentation and CR3-based page tables provide the lowest overheads (37x and 48x), but are still an order of magnitude larger than the verified-to-verified sentinel call overhead.
Hardware deprivileging adds a significant portion (upward of 60%) to the sentinel call in this case.
These overheads are comparable to existing unverified disaggregated systems and micro kernels ( §10).
8.3.2.
üXMHF Microbenchmarks: For purposes of micro benchmarking we measure the üXMHF xcihub üobject, which handles several intercepts required for guest execution.
üXMHF delivers near native XMHF performance in all cases ( Figure 10).
We attribute the small overhead for certain intercepts to the code refactoring using üobjects.
(Figure 12).
We use the hypapps described in §6.1 along with another unverified hypapp ropdet (which captures guest branch information for ROP detection) for hypapp performance benchmarking.
We wrote a guest üobject that interacts with the hypapps to leverage their services as follows.For sysclog, activate syscall logging by setting the syscall code page to no-execute and perform sample syscalls.
For hyperdep, set a data page to no-execute and perform data read and write operations on that page.
For aprvexec, setup a code page for approved execution, and invoke the hypapp to approve and lock the page against writes, before executing a sort function on that code page.
Finally, for ropdet, register a test function over which ROP detection is to be performed, and a invoke the test function to collect branch information.
Figure 11 shows the performance overhead for these hypapps compared to native XMHF without üSpark.
Verified sysclog and hyperdep run close to native XMHF speeds (2% avg.
overhead).
Unverified aprvexec and ropdet incur higher overheads (9% and 11% respectively).
The overhead is due to üAPI invariant checks (<10%) and the sentinel cost of deprivileging, shadow stack and parameter marshalling ( §8.3.1).
For I/O performance benchmarks, we wrote a mix of DMA I/O (usb and net) and programmed I/O operations (disk and serial) within a hypervisor üobject.
The I/O performance overhead (Figure 11) is anywhere from 1-5% with the DMA-based I/O incurring more overhead.
We attribute the higher DMA-based I/O overhead to the IOMMU page tables for DMA access.
Note that üSpark does not actively interpose on any I/O operations, which results in a much lower overhead.
These I/O overheads also match up to existing micro hypervisor I/O architecture overheads [67], [72], [86].9.
EXPERIENCE AND LESSONS LEARNED 9.1.
Frama-C -The WP plugin's limited casting support helped detect erroneous esoteric casts, e.g., pointer to int/u8.
While the Value plugin cannot propagate states to arbitrarily large loops, the semantic unrolling option helped propagate states only for desired functions so memory/time resources can be well spent.
WP loop invariants are versatile in supporting unbounded loops with nesting.
WP discharges proofs more effectively when operating over single-dimensional array accesses for mutating assignments and invariants and simple statements using shift and bit-wise operators.
WP also caused proof failures in certain cases with local variable aliasing of function parameters; using parameter variables directly ameliorated the issue.
We did not encounter any soundness bugs in Frama-C and its plugins.
9.2.
Verification Theories -Automated verification results vary by theory, e.g., Alt-Ergo and Z3 failed to discharge a few verification conditions (VC) that CVC3 handled.
Frama-C's ability to combine provers was very useful; CVC3, Z3 and Alt-Ergo together solved all the VCs generated during verification.
9.3.
Annotations -ACSL is versatile in its support for writing partial specifications (e.g., memory safety of SHA-1) and assertions as well as complete specifications (e.g., page-table setup).
Futher, ACSL annotations use actual C variables and operations.
This expressivity spectrum thus allows system programmers to easily transition into the verification domain by initially using simple assertions and function contracts (partial specifications) and iteratively mastering complete specifications.
9.4.
CompCert -The C99 subset handled by CompCert suffices to implement most systems-level software constructs.
However, struct bit fields with packing and alignment within struct fields are currently unsupported.
We added methods with bitwise operators to pack, unpack, deconstruct, and align such variables in the sources.
SELinux [66], AppArmor [1] and FBAC [59] are some examples of OS kernel modifications that add features to an existing (privileged) kernel to enforce various access control policies.
Such approaches suffer from the lack of assurance and separation: a bug in an extension or the core can exist, and then affect other parts of the system arbitrarily.
10.2.
Unverified disaggregation -Xen/Xoar [17] converts Xen into deprivileged partitions.
NOVA [67] deprivileges everything (including VMM modules), except for a small privileged micro kernel.
Safe composition of OS kernel extensions include extensible operating systems [10], [15], [20], [23], [39], [61], kernel driver isolation [13], [28], [47], [48], [69], [70], [78], interposition mechanisms [29], [35], [37], [40] and API compatability libraries [5], [7], [9], [30], [56], [79].
Xax [19] confines untrusted application code to an ABI for accessing OS services.
SGX [4] protects application code from (buggy) privileged code.
Disaggregation brings mere isolation but no formal guarantees on its own.
10.3.
Verified sandboxing -SFI [52], [54], [60], [76], [82] is a software-based approach for application-level memory isolation but lacks support for low-level privileged instructions and hardware device access, which are necessary for hypervisor and its extensions.
Also, SFI employs unverified binary rewriting which can change the semantics of the program and break invariants necessary for compositional verification.
Singularity [36] sacrifices legacy compatibility with a complete redesign of a OS written in type-safe languages (MSIL/TAL) and uses software mechanisms to isolate processes (SIP) and supports only memory and type-safety properties.
10.4.
Verified kernels -seL4 [43] verifies full functional correctness of the C implementation (7500 LOC) of the micro kernel by showing that it refines an abstract specification.
Their specifications don't support abstractions among the kernel or the different kernel modules.
These interdependencies often lead to more complex invariants which are difficult to prove (20 person years).
Further, seL4 does not allow adding properties using untrusted services; such additions require direct integration into the kernel and lengthy re-verification.
Furthermore, there is no support for Assembly (ASM) or device states, which precludes verification of low-level code interacting with devices; (1200 C and 500 ASM SLoC remain unverified).
mCertiKOS [31] follows a similar approach to seL4 but makes the abstract specification layered to reduce the interdependencies among the kernel and various extensions and makes the verification process more tractable for an admittedly stripped down version of the original CertiKOS kernel (single-core, non-preemptible custom guest OS, basic process and syscall handling).
There is no hardware model and support for ASM is limited to only general-purpose registers.
Adding extra system instruction support and device models does not seem trivial; even the stripped down version of the kernel has 300 C and 170 ASM SLoC unverified.
This is attributed to memory model limitations of their methodology [31].
Lastly, both mCertiKOS and seL4 require the developer to write line-for-line specifications for C/ASM code in a different abstract language (Isabelle/HOL or Coq/Ocaml/Lasm) with a very steep learning curve.
The VCC project [16], [45] verifies the functional correctness of a fixed Hyper-V hypervisor codebase running a multi-CPU guest, via automated theorem proving.
However, the code annotations do not support abstractions among the core hypervisor or drivers.
This leads to complex invariants due to interdependencies; only 20% of the hypervisor code-base has been verified [16].
Further, their ASM verification methodology and lack of a full hardware model only allows proving memory safety and arithmetic properties for ASM functions while precluding compiler optimizations for the corresponding C callee functions [51].
XMHF [72] employs the CBMC model checker with assertions on the C code of a micro-hypervisor to verify memory integrity.
However, multiple extensions or composing other properties on top of memory integrity are unsupported.
Further, that effort assumes interface confinement and leaves out 422 C and 388 ASM SLoC due to limitations of CBMC with largeloops and lack of a hardware model.
10.5.
Verified System Stack -In Verve [81], a simplified OS and applications are verified for type and memory safety using a Hoare-style verification condition (VC) generator and automated theorem proving.
Ironclad [33] extends Verve with support for higher-level application properties.
High-level specifications (written in Dafny) are translated to corresponding code with VCs discharged via an automated theorem prover; the verification took 3 person-years.
Verisoft [6] integrates hardware and software, with high-level specifications written in C0 (a tiny subset of C semantics) and refined down to a custom CPU semantics.
The verification took 20 person-years on a simple OS with only a disk driver.
System stack verification approaches, while powerful, sacrifice compositionality, legacy compatibility and performance.
Any changes to kernel code and/or extension configuration requires lengthy re-verification (in person years).
Further, the entire system software stack has to be re-implemented in type-safe languages such as C# and TAL (in Verve) or in high-level Dafny specifications (in Ironclad) or on a non-commodity CPU abstraction (in Verisoft).
Furthermore, these approaches lack support for co-existence with unverified programs or a guest OS.
We now discuss current limitations of our approach with pointers to future work towards bridging these gaps.
11.1.
Hardware Model -Our hardware model is currently a trusted component.
However, orthogonal techniques such as path-exploration lifting [50] and mechanized x86-multiprocessor semantics [58] provide a solid foundation on which we plan to build upon and validate our hardware model in the future.
11.2.
CASM and Certified Compilation -Our highlevel proofs depend on Compcert's specification of the C memory and register semantics and CASM's adherence to those semantics (discharged as invariants on the source-code and our hardware model) to ensure that the C and Assembly code operate on disjoint state.
In the future, we plan on leveraging recent developments with Compcert such as the ability to compile and link multi-module source programs [68] to cleanly extend the bi-simulation proof of the CompCert compiler to encompass hardware state and Assembly code.
Future work also involves proving (e.g., via bi-simulation) the semantic equivalence between the hardware model and the corresponding Assembly instructions and demonstrating the semantic synergy between CompCert, CASM and the Frama-C kernel more rigorously for proved properties to translate to the binary.
11.3.
Functional Verification -Our focus in this paper is on security invariants and trace properties and functional correctness to support such properties.
We are optimistic that liveness properties and full-functional correctness are achievable future goals and not any more harder than existing approaches [31], [33], [43].
11.4.
Concurrency -We have shown that a practical multi-threaded system with interesting security properties can be built by dealing with a serialized execution model and sequential verification in lieu of complex concurrent verification.
However, we do realize the importance of relaxing our serialized execution model especially in high-performance computing environments and plan on leveraging source-level multi-threaded verification (e.g., Frama-C mthread plugin [24]) to address concurrency in the future.
11.5.
Soundness of Tools -Similar to existing approaches, we assume that the verification tools such as Frama-C with associated plugins and back-end theorem provers such as Z3, CVC3 and Alt-Ergo are sound ( §8.1, §3.3).
Discharging this assumption, while a desirable goal, is currently an open and hard problem in the face of formal methods.
However, seminal breakthroughs such as certified software model-checking [55] and formal verification of C static analyzers [38] give us hope that proving soundness of our verification tools will indeed be possible in the future.
11.6.
Applicability -Our future work involves generalizing üSpark to a more broadly applicable framework for building compositionally verifiable systems.
We are exploring the applicability of üSpark to generalpurpose hypervisors (e.g., Xen and KVM), BIOS, device firmware, operating-system kernel and drivers, userspace applications and browser extensions including vertical integration among these stacked subsystems.
The immediate challenges we envision there include unraveling complex data structures, supporting dynamic memory allocations and use of indirect function calls in addition to supporting some form of concurrency.
We presented überSpark, an innovative architecture enforcing verifiable object abstractions in low-level C and Assembly languages and leveraging them in combination with off-the-shelf C software verifiers and certifying compilers to produce high assurance hypervisors for commodity platforms.
We incrementally developed and verified a commodity x86 micro-hypervisor using üS-park, and performed a comprehensive evaluation which shows automated compositional verification with modest development effort and minimal runtime overhead.Availability: ÜBERSPARK and ÜXMHF sources are available at: http://uberspark.org Inv 1 ü üSpark begins execution with the entry point of a distinguished initial "prime" üobject sI in singlecore mode with just core 1 activated Inv 2 ü A special "asynchronous" function startcores(s) activates all cores i > 1 and begins executing a designated üobject s immediately thereafter; all cores remain active thereafter for the system lifetime.
We now describe our verification approach in detail for verifying the invariant properties of the üXMHF üobjects shown in Figure 15.
For all the üobjects we verify via deductive verification that the üobject entry point function transfers control to the appropriate method handler for a given public method.We verify the üAPI üobjects via abstract interpretation.
For the uhcpust üobject we verify that the write method, in case of a write to MSR EFER, always preserves the EFER bits required for üSpark functionality.
On system call trap intercept, log syscall information to network log buffer sysclognw vh Log info in network log buffer and transmit buffer when full aprvexec uh Guest OS approved code pages are always marked read-only and executable For the ugmpgtbl üobject we verify that the setentry method's entry parameter does not fall within hypervisor memory regions.
Finally, for the ugcpust üobject we verify that the write method disallows writes to any host-specific state in the guest VMCS.For the xcihub üobject we employ deductive verification to verify the main method such that, for any given intercept a special function hcbinvoke is called with the intercept type and associated parameters.
hcbinvoke is then verified to ensure that it calls all the registered hypapp üobjects for that intercept.For the sysclog üobject we employ deductive verification to first verify that the init method invokes the ugmpgtbl üobject setentry method with the syscall page address with read and no-execute protections.
We then verify that the syscall trap handler obtains syscall information via a call to the ugcpust üobject read method and stores this information to the network log buffer via a call to the sysclognw üobject log method.We verify the sysclognw üobject via deductive verification and abstract interpretation.
We use deductive verification to verify the log method to ensure that: (a) the buffer passed in as parameters is stored in the network buffer data structure, and (b) when the buffer is full, its contents are copied into the üobject dmadata region, buffer is reset, and the network send function is invoked.
We then verify the send function via abstract interpretation to ensure that it programs the network card hardware to read from the dmadata region, transmit the buffer, and wait for end of transmission signal.We use deductive verification to verify the hyperdep üobject activate method to ensure that the guest page address that is passed is used as the parameter to the ugmpgtbl üobject setentry method with read, write and no-execute protections.Note, aprvexec (unverified) üobject is not verified since its properties follow from the ugmpgtbl üAPI invariants ensured by our composition check as described in §7.2.1.
