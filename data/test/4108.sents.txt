IPsec enables cryptographic protection of IP packets.
It is commonly used to build VPNs (Virtual Private Networks).
For key establishment, the IKE (Internet Key Exchange) protocol is used.
IKE exists in two versions, each with different modes, different phases, several au-thentication methods, and configuration options.
In this paper, we show that reusing a key pair across different versions and modes of IKE can lead to cross-protocol authentication bypasses, enabling the impersonation of a victim host or network by attackers.
We exploit a Bleichenbacher oracle in an IKEv1 mode, where RSA encrypted nonces are used for authentication.
Using this exploit, we break these RSA encryption based modes, and in addition break RSA signature based authentica-tion in both IKEv1 and IKEv2.
Additionally, we describe an offline dictionary attack against the PSK (Pre-Shared Key) based IKE modes, thus covering all available au-thentication mechanisms of IKE.
We found Bleichenbacher oracles in the IKEv1 implementations of Cisco (CVE-2018-0131), Huawei (CVE-2017-17305), Clavister (CVE-2018-8753), and ZyXEL (CVE-2018-9129).
All vendors published fixes or removed the particular authentication method from their devices' firmwares in response to our reports.
VPNs (Virtual Private Networks) allow employees to securely access a corporate network while they are outside the office.
They also allow companies to connect their local networks over the public Internet.
Examples for large industrial VPNs are the ANX (Automotive Network Exchange), ENX (European Network Exchange), and JNX (Japanese Network Exchange) associations, which connect vehicle manufacturers with their suppliers [1][2][3] Figure 1: The relationship between IKEv1 Phase 1, Phase 2, and IPsec ESP.
Multiple simultaneous Phase 2 connections can be established from a single Phase 1 connection.
Grey parts are encrypted, either with IKE derived keys (light grey) or with IPsec keys (dark grey).
The numbers at the curly brackets denote the number of messages to be exchanged in the protocol.stations and the core network [4, pp. 66-67].
Other applications of VPNs involve circumventing geo-restrictions and censorship.
IPsec (Internet Protocol Security) is a protocol stack that protects network packets at the IP layer.
In contrast to other widespread cryptographic protocols like TLS (Transport Layer Security) or SSH (Secure Shell), which operate at the application layer, IPsec allows to protect every IP based communication.
When transmitting payload data, IPsec uses two different data formats to protect IP packets: AH (Authentication Header) for integrityonly setups and ESP (Encapsulating Security Payload) for confidentiality with optional integrity.IKE.
To establish a shared secret for an IPsec connection, the IKE protocol has to be executed.
There are two different versions of IKE named IKEv1 (1998) and IKEv2 (2005 .
The numbers at the curly brackets to the left denote the number of messages to be exchanged in the protocol.previous version, both are still available in all implementations and both can be configured for actual use in all major operating systems and network devices.
IKE consists of two phases, where Phase 1 is used to establish initial authenticated keying material between two peers.
Phase 2 is used to negotiate further derived keys for many different IP based connections between the two.
IKE is one of the most complex protocols in use, and the dependencies between Phase 1 and Phase 2 make it hard to analyze.
Figures 1 and 2 illustrate this complexity: In IKEv1, both phases are clearly separated, but there are two different modes for Phase 1.
In IKEv2, Phase 1 has been simplified, but now Phase 1 interleaves with the first execution of the Phase 2 protocol.Authentication.
In IKEv1, four authentication methods are available for Phase 1 (cf. subsection 2.2): Two RSA encryption based methods, one signature based method, and a PSK (Pre-Shared Key) based method.
All Phase 1 modes/methods contain a DHKE (DiffieHellman Key Exchange), which guarantees PFS (Perfect Forward Secrecy) for every connection.
IKEv2 Phase 1 omits both encryption-based authentication methods, so only signature and PSK based authentication remain.Attacks.
Our attacks only target Phase 1 in IKEv1 and IKEv2, where we impersonate an IKE device.
Once attackers succeed with this attack on Phase 1, they share a set of (falsely) authenticated symmetric keys with the victim device, and can successfully complete Phase 2 -this holds for both IKEv1 and IKEv2.
The attacks are based on Bleichenbacher oracles discovered in implementations of the two RSA encryption based IKEv1 variants (cf. sections 5-7).
These Bleichenbacher oracles can very efficiently be used to decrypt nonces, which breaks these two variants (subsection 4.2).
The oracles can also be used to forge digital signatures, which breaks the signature based IKEv1 and IKEv2 variants (subsection 4.4).
We additionally show that both PSK based modes can be broken with an offline dictionary attack if the PSK has low entropy (section 9).
We thus provide attacks against all authentication modes in both IKEv1 and IKEv2 under reasonable assumptions.Contribution.
In this paper, we make the following contributions:• We identify and describe Bleichenbacher oracles in the IKEv1 implementations of four large network equipment manufacturers, Cisco, Huawei, Clavister, and ZyXEL.
• We show that the strength of these oracles is sufficient to break all handshake variants in IKEv1 and IKEv2 (except those based on PSKs) when given access to powerful network equipment.
• We demonstrate that key reuse across protocols as implemented in certain network equipment carries high security risks.
IKE is a family of AKE (Authenticated Key Exchange) protocols.
It is responsible for negotiating multiple sets of cryptographic algorithms and keys, called SAs (Security Associations) in IPsec terminology.
Each SA can either be used to protect the integrity of IP packets with the data format AH (Authentication Header) or to protect confidentiality with optional integrity using the data format ESP (Encapsulating Security Payload).
IKE messages are exchanged over UDP (User Datagram Protocol) and their destination port is 500.
IKE is standardized in two major versions: Version 1, described in RFC 2409 [16] and accompanying documents, was published in 1998.
It has been declared obsolete by the IETF (Internet Engineering Task Force), but it is nevertheless included in all implementations and still widely used.
Version 2, first published in RFC 4306 in 2005 [22] was designed as a low-latency alternative to Version 1, and therefore has a fundamentally different design.
It is subject of ongoing standardization, but only minor clarifications are incorporated in the most recent RFCs.
IKEv1 uses a data format called ISAKMP (Internet Security Association and Key Management Protocol), which has later been integrated with IKEv2.
IKEv1 consists of two phases (cf. Figure 1).
In Phase 1, a SA is established for IKEv1 itself, such that the subsequent Phase 2 messages can be encrypted.
Additionally, a shared symmetric key is established as basis of authentication in Phase 2.
In Phase 2, several SAs for IPsec AH and ESP are negotiated.IKEv1 Phase 1.
For Phase 1 of the protocol, two modes -main mode and aggressive mode -and four authentication methods are available.
A main mode handshake consists of exactly six messages; an aggressive mode handshake compresses the protocol flow into only three messages.
We do not cover the aggressive mode explicitly in this paper.
However, all results described in this paper hold for the aggressive mode as well.
Throughout the rest of this paper, we assume readers familiar with the TLS protocol, as we will sometimes compare IKE with TLS.
Figure 3 gives a simplified overview of the IKE protocol structure of Phase 1.
Since IKE uses UDP, the protocol itself has to keep track of the handshake session.
IKE uses random values called cookies (and denoted by c I and c R ) for this purpose; these cookies are present in each IKE header.The first two messages (m 1 and m 2 ) are used to negotiate on a proposal -a combination of different cryp- tographic algorithms, comparable to TLS ciphersuites.
In messages m 3 and m 4 a DHKE is performed, together with the exchange of additional parameters called ancillary data (anc), depending on the chosen authentication method.
Based on these messages and the shared DH secret, four symmetric keys (k, k d , k a , k e ) 1 are derived by both parties (cf. Table 1).
The formula to derive the intermediate key k varies between the different authentication methods, which are explained in more detail in the following sections.
From this intermediate key, the other three keys are derived as the result of a pseudorandom function.
Inputs to this function are k, the most recent generated key, the shared DH secret g xy , the cookies (c I , c R ), and an index.The last two messages (m 5 and m 6 ) are used for key confirmation.
For this, two MAC values 2 are generated using k.
These MACs are either exchanged or digitally signed.
In main mode, messages m 5 and m 6 are encrypted under key k e .
Signature PKE & RPKE PSK k PRF n I ,n R (g xy ) PRF h(n I ,n R ) (c I , c R ) PRF PSK (n I , n R ) k d PRF k (g xy , c I , c R , 0) k a PRF k (k d , g xy , c I , c R , 1) k e PRF k (k a , g xy , c I , c R , 2) In Phase 1 of IKEv1, four different modes of authentication are available: (a) Digital signatures, (b) PKE (Public Key Encryption), (c) RPKE (Revised Public Key Encryption), and (d) PSKs (Pre-Shared Keys).
While the message exchange patterns in Phase 1 are fixed to main or aggressive mode, the two communicating entities may freely negotiate any of these four authentication modes.Signature Based Authentication.
This authentication mode assumes that each party owns an asymmetric key pair with valid certificates.
After choosing this authentication mode, nonces n I and n R are exchanged as ancillary information with the third and fourth message.
These nonces are then used as key input to the PRF function, which is used to derive the shared key k from the shared Public Key Encryption Based Authentication.
This mode requires that both parties exchanged their public keys securely beforehand (e. g. with certificates during an earlier handshake with signature based authentication).
RFC 2409 advertises this mode of authentication with a plausibly deniable exchange to raise the privacy level.In this mode, messages three and four exchange nonces and identities as ancillary information (see Fig- ure 4).
In contrast to the signature based mode, they are encrypted using the public key of the respective other party.
The encoding format for these ciphertexts is PKCS #1 v1.5.
For verification, both parties exchange their MAC values.Revised Public Key Encryption Based Authentication.
The PKE based mode of authentication requires both parties to perform two public-and two private-key operations.
To reduce this computational overhead, the revised public key encryption based mode of authentication (RPKE) was invented (see Figure 8).
This mode still encrypts the nonces n I and n R with the other party's public key using PKCS #1 v1.5.
However, the identities are encrypted with ephemeral symmetric keys ke I and ke R that must not be confused with k e , which is derived later in the handshake.
ke I and ke R are derived from each party's nonces and cookies.
The rest of the handshake is identical to the non-revised mode.PSK Based Authentication.
If initiator and responder do not have asymmetric keys, symmetric PSKs can be used for authentication.
This can be implemented with a (low or high entropy) password both parties know.
The PSK is used to derive k from the nonces n I and n R , which are exchanged as ancillary information ( Figure 12).
The rest of the handshake is identical to the public key encryption based modes.
The structure of IKEv2 [24,25] is fundamentally different from IKEv1 (cf. Figure 2) -Phase 1 and Phase 2 are partially interleaved, and Phase 2 is reduced to a two-message protocol.
For our analysis it is only important that IKEv2 (cf. Figure 6) shares two authentication methods with IKEv1, and that we can directly apply our attacks to impersonate an IPsec device in Phase 1 of IKEv2.
Bleichenbacher's attack is a padding oracle attack against RSA PKCS #1 v1.5 encryption padding, which is explained in more detail in Appendix B.
If an implementation allows an attacker to determine if the plaintext of a chosen RSA ciphertext starts with the two bytes 0x00 0x02, then a Bleichenbacher attack is possible.
In his seminal work [9], Bleichenbacher demonstrated how such an oracle could be exploited: c = (c 0 · s e ) mod N = (m 0 · s) e mod N.The attackers query the oracle with c.
If the oracle responds with 0, they increment s and repeat the previous step.
Otherwise, the attackers learn that 2B ≤ m 0 · s − rN < 3B for some r.
This allows the attackers to reduce the range of possible solutions to:2B + rN s ≤ m 0 < 3B + rN sThe attackers proceed by refining guesses for s-and rvalues and successively decreasing the size of the interval containing m 0 .
At some point, the interval will contain a single valid value, m 0 .
Bleichenbacher's original paper [9] describes this process in further detail.Signature Forgery Using Bleichenbacher's Attack.It is well known that in the case of RSA, performing a decryption and creating a signature is mathematically the same operation.
Bleichenbacher's original paper already mentioned that the attack could also be used to forge signatures over attacker-chosen data.
In two papers by Jager et al. [19,20], this has been exploited for attacks on XML-based Web Services, TLS 1.3, and Google's QUIC protocol.
The ROBOT study [10] used this attack to forge a signature from Facebook's web servers as proof of exploitability.Optimized Bleichenbacher Attack In 2012, Bardou et al. [7] presented an optimization of the standard Bleichenbacher attack by trimming the initial space for m 0 .
They divide a ciphertext by an integer t by multiplying it with t −e mod N with e being the public exponent of the oracle.In case the original plaintext was divisible by t, then the multiplication c 0 · u e · t −e is equal to m 0 t under the assumption that m 0 and m 0 · ut −1 are PKCS #1 v1.5 conforming.
Note, that the value u and t must be coprime integers with u < 2 3 t and t < 2N 9B .
In order to find a suitable amount of trimmer values that result in PKCS #1 v1.5 conforming messages, we need to calculate a few thousand t and u values, satisfying the above requirements.
After that, we get a set of trimmer values shrinking the m 0 search space into smaller chunks of 2B · t u ≤ m 0 < 3B · t u .
Bleichenbacher attacks [9] are adaptive chosen ciphertext attacks against RSA-PKCS #1 v1.5.
Though the attack has been known for two decades, it is a common pitfall for developers [10,27].
The mandatory use of PKCS #1 v1.5 in two ciphersuite families -the PKE ( Figure 4) and RPKE ( Figure 8) authentication methods -raised suspicion of whether implementations resist Bleichenbacher attacks.
PKE authentication is available and fully functional in Cisco's IOS (Internetwork Operating System).
In Clavister's cOS and ZyXEL's ZyWALL USGs (Unified Security Gateways), PKE is not officially avail-Initiator (IDI , skI , pkI ) Responder (IDR, skR, pkR) m1 := (proposals) − cI , 0, m1 −−−−−−−−−− − → m2 := (proposal) ← − cI , cR, m2 −−−−−−−−−− − cn I := Encpk R (nI ) cid I := Encpk R (IDI ) m3 := (g x , cid I , cn I ) − cI , cR, m3 −−−−−−−−−− − → cn R := Encpk I (nR) cid R := Encpk I (IDR) m4 := (g y , cid R , cn R ) ← − cI , cR, m4 −−−−−−−−−− − k := PRF h(nI ,nR) (cI , cR)Derive kd, ka, ke from kk := PRF h(nI ,nR) (cI , cR) Derive kd, ka, ke from k Compute MACI using k m5 := Enck e (MACI ) − cI , cR, m5 −−−−−−−−−− − → Compute MACR using k m6 := Enck e (MACR) ← − cI , cR, m6 −−−−−−−−−− − Compute MACR andcompare to m6Compute MACI and compare to m5 able.
There is no documentation and no configuration option for it; therefore, it is not fully functional.
Nevertheless, these implementations processed messages using PKE authentication in our tests.
RPKE is implemented in certain Huawei devices including the Secospace USG2000 series.
We were able to confirm the existence of Bleichenbacher oracles in all these implementations (CVE-2018-0131, CVE-2017-17305, CVE- 2018-8753, and CVE-2018, which are explained in depth in sections 5 -7.
On an abstract level, these oracles work as follows: If we replace the ciphertext c n I in message m 3 (cf. Figure 4) with our modified RSA ciphertext, the responder will Each time we get a Case 1 answer, we can advance the Bleichenbacher attack one more step.
If a Bleichenbacher oracle is discovered in a TLS implementation, then TLS-RSA is broken since one can compute the Premaster Secret and the TLS session keys without any time limit on the usage of the oracle.
For IKEv1, the situation is more difficult: Even if there is a strong Bleichenbacher oracle in PKE and RPKE mode, our attack must succeed within the lifetime of the IKEv1 Phase 1 session, since a DHKE during the handshake provides an additional layer of security that is not present in TLS-RSA.
For example, for Cisco this time limit is currently fixed to 60 seconds for IKEv1 and 240 seconds for IKEv2.To phrase it differently: In TLS-RSA, a Bleichenbacher oracle allows to perform an ex post attack to break the confidentiality of the TLS session later on, whereas in IKEv1 a Bleichenbacher oracle only can be used to perform an online attack to impersonate one of the two parties in real time.
Figure 5 depicts a direct attack on IKEv1 PKE: 1.
The attackers initiate an IKEv1 PKE based key exchange with Responder A and adhere to the protocol until receiving message m 4 .
They extract c n R from this message, and record the public values c I , c R .
They also record the nonce n I and the private DHKE key x chosen by themselves.
2.
The attackers keep the IKE handshake with Responder A alive for a maximum period t timeout .
For Cisco and ZyXEL, we know that t timeout ≥ 60s, for Clavister and Huawei t timeout ≥ 30s.
3.
The attackers initiate several parallel PKE based key exchanges to Responder B.• In each of these exchanges, they send and receive the first two messages according to the protocol specification.
• In message m 3 , they include a modified version of c n I according to the Bleichenbacher attack methodology.
• They wait until they receive an answer m 4 (Case 1), or they can reliably determine that this message will not be sent (timeout or reception of a repeated message m 2 ).4.
After receiving enough Case 1 answers from Responder B, the attackers compute n R .
From the DHKE share of Responder A and their private DHKE share x they compute g xy .
5.
The attackers now have all the information to complete the key derivation described in Table 1.
They can compute MAC I and encrypt message m 5 to Responder A with key k e .
They thus can impersonate Responder B to Responder A.It is important to note that this attack also can be used to execute a man-in-the-middle attack against two parties.
For that, the connection is interrupted by the attackers and on the following attempt to restart the IKEv1 session with a handshake, the attackers execute a Bleichenbacher decryption attack against each party.
In case of success, they can decrypt and manipulate the whole traffic.
Each theoretical description of some public key primitive starts with something like (pk, sk)$ ← KeyGen(1 κ )to indicate that freshly generated keys should be used if the security proof should remain valid.
In practice, this is difficult to achieve.
TLS now has four versions (not counting the completely broken SSL 2.0 and 3.0), three major handshake families, both prime order and elliptic curve groups, and many minor variants described in the different ciphersuites.
It is practically impossible to maintain a separate key pair for each ciphersuite.
Typically, a single RSA key pair together with an encryption & signing certificate is used to configure a TLS server.
As a result, cross-ciphersuite [26] and cross-version [20] attacks have been shown, despite security proofs for single ciphersuite families.For IKE, there is a similar situation: Maintaining individual key pairs for all "ciphersuite families" and versions of IKE is practically impossible and oftentimes not supported.
This is the case with the implementations by Clavister and ZyXEL, for example.
Thus, it is common practice to have only one RSA key pair for the whole IKE protocol family.
The actual security of the protocol family in this case crucially depends on its cross-ciphersuite and cross-version security.
In fact, our Huawei test device reuses its RSA key pair even for SSH host identification, which further exposes this key pair.
The attack against IKEv2 with signature based authentication proceeds as follows (cf. Figures 6 and 7).
It can easily be adapted to IKEv1.1.
The attackers initiate an IKEv2 signature based key exchange with Responder A and adhere to the pro- tocol until they receive message m 2 .
After this message, they have enough data to complete the key derivation described in Figure 6.
From these keys they need k pI to compute) (kd, kaI , kaR, keI , keR, kpI , kpR) ← PRFs(nI , nR, cI , cR) IKE AUTH Messages Encrypted-then-MACed with (keI , kaI ), (keR, kaR)MACI ← PRFk pI (IDI ) σI ← Sign skI (cI , 0, m1, nR, MACi) m3 := (IDI , σI , proposalR) − cI , cR, m3 −−−−−−−−−− − → MACR ← PRFk pR (IDR) σR ← Sign skR (cI , cR, m2, nI , MACR) m4 := (IDR, σR, proposalR) ← − cI , cR, m4 −−−−−−−−−− − (k eI , k aI , k eR , k aR ) ← PRFk d (nI , nR)MAC I = PRF k pI (ID B ), which is part of the data to be signed with the private key of Responder B. 2.
They keep the IKE handshake with Responder A alive for a maximum period t timeout .
For Cisco IOS, we know that t timeout ≥ 240s.
3.
The attackers encode the hash h of (c I , 0, m 1 , n R , MAC I ) with PKCS #1 v1.5 for digital signatures.
We denote this encoded value as H.
They then compute c ← (H · r e ) (mod N), which is known as the blinding step in the Bleichenbacher attack.
4.
The attackers initiate several parallel PKE based key exchanges with Responder B.• In each of these exchanges, they send and receive the first two messages according to Fig- ure 4.
• In message m 3 , they include a modified version of c according to the Bleichenbacher attack methodology.
• They wait until they receive an answer m 4 (Case 1), or they can reliably determine that this message will not be sent (timeout, or reception of a repeated message m 2 ).5.
After receiving enough Case 1 answers from Responder B, the attackers can compute the decryption m ← c d (mod N).
Since m = c d = (H · r e ) d = H d · r ed = H d · r (mod N), It is common knowledge that the aggressive mode of IKEv1 using PSKs is susceptible to offline dictionary attacks, against passive attackers who only eavesdrop on the IP connection.
This has actually been exploited in the past [5].
We show that an offline dictionary attack is also possible against the main mode of IKEv1 and against IKEv2 with PSKs, if the attackers are active and interfere with DHKE.
Additionally, the attackers have to act as a responder, thus waiting for a connection request by the victim initiator.
Once the attackers have actively intercepted such an IKE session, they learn an encrypted MAC I value.
This value is computed from public data from the intercepted session, the shared DHKE value, and the PSK.
Since the attackers know all of these values except the PSK, they can now perform an offline dictionary attack against it.
Details on this attack can be found in section 9.
Cisco includes the PKE authentication mode in IOS, which is the operating system on the majority of Cisco routers and current Cisco switches.
The mode can also be found in IOS XE, which combines a Linux kernel with IOS as an application.
IOS XE is used on Cisco's carrier routers and enterprise switches [13].
For our tests, we used a Cisco ASR 1001-X router running IOS XE in version 03.16.02.
S with IOS version 15.5(3)S2.Based on the default configuration, we first generated an RSA key pair on the device using the default options (i. e., we created general-keys; cf. Appendix C).
Second, we created a peer entry with the RSA public key and IP address of our test initiator.
Third and last, we configured a policy that only IKEv1 and only PKE authentication is allowed.
Our test initiator is based on Scapy [8], a Python library for network packet manipulation.
With it, we can create any IKE message and fully control all fields like cookies, proposals, nonces, ciphertexts, etc.Ciphertext c n I in Figure 4 is the target of our attack.
This ciphertext is sent with message m 3 of an IKEv1 handshake.
After sending an invalid ciphertext to our Cisco router, no error message is sent back to the initiator.
Instead, the router retransmits message m 2 to the initiator after one second has elapsed.
If the router succeeds decrypting the message, m 4 is sent immediately to the initiator.
This is clearly a Bleichenbacher oracle.
For testing PKCS #1 v1.5 compliance, after decrypting c n I , the responder should check if the first two bytes of the plaintext are indeed 0x00 0x02, if the following eight bytes are non-zero, and then search for the first zero byte.
All data following this zero byte are considered the decrypted message.Our test device performs all these checks after decrypting c n I .
As an edge case, Cisco's implementation also accepts a plaintext that entirely consists of padding, i. e. where the zero byte separating padding and message is the last byte of the plaintext.
Furthermore, IOS ignores c ID I and determines the public key to use for its response based on the IP address of the initiator.
One can even omit c ID I when constructing m 3 ; it does not have any effect on the Bleichenbacher oracle.This makes the Cisco oracle a FFT oracle based on the observations made by Bardou et al. [7].
The probability to get a valid padded message for such an FFT oracle is Pr(P|A) = 0.358 with Pr[A] ≈ 2 −16 being the probability that the first two bytes are 0x0002 [7,9].
For a 128-byte RSA modulus, the probability Pr(P|A) can be computed as follows: Pr(P|A) = ( 255 Oracle Performance Restrictions.
In order to investigate the performance restriction we used the debug logs of Cisco IOS.
There one can see that IKE handshakes are processed by a state machine.
This state machine enforces some non-cryptographic boundary conditions, which have impact to the performance of a Bleichenbacher attack against Responder B. For example, IOS has a limit for concurrent SAs under negotiation of 900.
Unfortunately, Cisco's implementation is not optimized for throughput.
From our observations, we assume that all cryptographic calculations for IKE are done by the device's CPU despite it having a hardware accelerator for cryptography.
One can easily overload the device's CPU for several seconds with a standard PC bursting handshake messages, even with the default limit for concurrent handshakes.
Moreover, even if the CPU load is kept below 100 %, we nevertheless observed packet loss.
With 1024-bit RSA keys, our test device is capable of handling only 850 Bleichenbacher requests per second on average.
We also saw significant CPU load after around 64,000 Bleichenbacher oracle requests, possibly caused by a memory limitation of our test device.
For other devices or more powerful ones, this is probably not a limitation.
Another possible reason is that hash collisions occur when the device needs to store many cookievalue pairs in its SA database due to the high amount of IKE handshakes during the attack.Attack Performance Restrictions.
For an attack, Responder A has to be held waiting.
Here, a limitation in IKEv1 is the quick mode timer.
It is started after receiving the first handshake message.
If the quick mode handshake (i. e. phase 2 of the IKE handshake) is not completed after 75 seconds, this timer cancels the handshake deleting all ephemeral values like the cookie c R , the nonce n R , and the DH secret y.Furthermore, the state machine maintains an error counter with a fixed limit of five.
Every time an erroneous message is received or the device retransmits a message during Phase 1, the counter is incremented.
Retransmissions happen every ten seconds if no message was received during that time, which we refer to as SA timeouts.
After a fifth retransmission of any Phase 1 packet, IOS waits one last time for ten seconds before canceling the handshake.
This translates to a maximum of 60 seconds between two messages sent from the peer.For an attack, the attackers require the victim's DHKE share that is sent with message m 3 or m 4 , depending on the role the attackers play.
If the attackers play the role of an initiator, a Bleichenbacher attack has to be successful within the maximum of 60 seconds between messages m 4 and m 5 .
If the attackers play the role of a responder, a few seconds can be gained by delaying message m 4 slightly below ten seconds so that no retransmission is triggered.In Cisco's IKEv2 implementation, timers are more relaxed.
Here, an attack can take up to 240 seconds until a timeout occurs.
Clavister cOS and the firmware of ZyXEL ZyWALL USGs do not officially support the PKE authentication mode.
It is not documented in their manuals and the web and command line interfaces do not offer any configuration option for it.
Nevertheless, both implementations responded to handshake proposals with PKE authentication in our tests.
For these, we used a virtual Clavister cOS Core in version 12.00.06 and a ZyXEL ZyWALL USG 100 running firmware version 3.30 (AQQ.7).
For PKE authentication, both implementations use the key pair that is configured for IKEv1 authentication with signatures.
Both implementations show the same behavior regarding the handling of IKEv1 (e. g. both respond with identical error messages).
PKE authentication with Clavister and ZyXEL is nonfunctional since one cannot configure public keys for peers.
Therefore, we always expect an error notification after sending message m 3 .
When sending an invalid ciphertext c n I with message m 3 , we receive an error message containing only 16 seemingly random bytes.
A valid c n I instead triggers an error message containing the string "Data length too large for private key to decrypt".
While the error message itself is misleading (the ciphertext can in fact be decrypted by the private key), the difference in the error messages is clearly a Bleichenbacher oracle.Clavister and ZyXEL perform the same checks as Cisco.
Therefore, the strength of the oracle and the estimated amount of messages is identical to the Cisco case.
We did not evaluate the performance of an attack against these oracles.
We identified Huawei as another large network equipment supplier who offers the RPKE mode with cer- Compute MACI and compare to m5 tain devices such as their Secospace USG2000 series [18].
For our tests, we used a Huawei Secospace USG2205 BSR firewall running firmware version V300R001C10SPC700.The steps for setting up an IPsec configuration are very similar to Cisco.
We started with the default configuration and generated an RSA key pair.
Importing the RSA public key of our Scapy based test initiator turned out to be a little more complicated since the required data format is non-standard.
Similar to Cisco, we configured a proposal, a policy, and a policy-template so that only IKEv1 with RPKE authentication is allowed.Again, ciphertext c n I (cf. Figure 8) is the target of our attack.
After sending an invalid ciphertext with m 3 to the device, the firewall does not send an error message back to the initiator.
In contrast to Cisco's implementation, there are no retransmissions.
If the firewall succeeds in processing the message, m 4 is sent to the initiator.
This is also clearly a Bleichenbacher oracle.
Huawei's firewall also performs all PKCS #1 v1.5 checks mentioned in subsection 5.1 after decrypting c n I .
Therefore, Huawei's oracle is similar to the FFT oracle.However, the constraints of the RPKE mode reduce the strength of the oracle.
If all PKCS #1 v1.5 checks were successful, the ephemeral key ke I is derived and used to decrypt the identity payload c ID I in order to determine the public key to use for its response.
Unfortunately, during a Bleichenbacher attack the attackers do not know which ke I is derived.
There is no way for attackers to distinguish a failed PKCS #1 v1.5 check from a failed decryption of c ID I .
This reduces the probability to get a Case 1 answer from Huawei by the factor 112 256 .
Thus, Huawei's Bleichenbacher oracle has an additional false negative rate of 56.64 %, which is explained in more detail in the next section.
Consequently, we estimate that a successful attack requires 371, 843/(1 −0.5664) = 857, 571 requests.
RFC 2409 defines an unusual padding for messages encrypted using symmetric algorithms: The message is padded with zero bytes.
The last padding byte contains the number of zero bytes inserted.
Padding is mandatory even if this requires an additional block containing only padding.
Figure 9 gives examples of this padding.
00 message 04 00 00 00 00 message 06 00 00 00 00 00 Huawei's implementation of this padding is odd: There are no checks whether the padding bytes are in fact zero-bytes.
The implementation only reads the last byte and removes the given number of bytes together with the padding length byte.
It does not verify whether the value of the padding length byte is larger than the block length of the negotiated algorithm.
It only cancels processing if the value of the padding length byte is larger than the decrypted ciphertext or if the padding length byte is zero.In contrast to Cisco, we observed that the Huawei device as responder thoroughly checks the identity payload c ID I sent by the initiator.
It has to be present, its length has to be a multiple of the symmetric algorithm's block length, and the plaintext needs to be correctly padded in terms of the checks described above.
If the plaintext identity ID I after removing the padding is 121 or less bytes in length, the device however ignores the identity value and continues the handshake using the initiator's configured public key based on its IP address.
If ID I is 122 bytes long, the device crashes and reboots, which takes several minutes.
If ID I is 123 to 255 bytes long, ID I is used to determine the public key of the initiator.
If ID I is more than 256 bytes long, the Huawei device also crashes and reboots.This complicates a Bleichenbacher attack scenario: Even if the attackers hit a PKCS #1 v1.5 compliant message, the decrypted value (i. e. what the device treats as the nonce n I ) is unknown to them.
This value is then used to derive the key ke I , which in turn is used to decrypt c ID I supplied by the attackers.
Since the attackers do not have ke I , they cannot construct any c ID I that decrypts to a meaningful ID I .
During our tests, we sent random bytes for c ID I to our test device.
However, even without influence on ID I , the attackers can adjust the length of c ID I .
Here, the attackers have to deal with two contradicting restrictions: On the one hand, it is necessary to keep the length of ID I below 122 bytes to prevent both a crash and the evaluation of the value of ID I .
On the other hand, no assumptions on the padding length byte can be made.
The longer the length of c ID I , the higher the possibility that the value of the padding length byte is below the plaintext length so that no padding error occurs.Regardless of the length of c ID I , the padding length byte can only decrypt to one of 256 possible values.
Taking into account that the length of c ID I has to be a multiple of 16 (the block length of AES), the attackers have to choose between a c ID I with a length of 128 bytes and one with 112 bytes.
For 128 bytes, all padding length byte values above 121 and zero will make the device not respond, either due to a padding error, an evaluation of ID I , or a crash.
This way, the Bleichenbacher oracle has an additional false negative rate of 47.66 %.
For 112 bytes, the chance of getting a Case 1 answer is slightly lower.
Now, all padding length byte values above 111 and zero will make the device not respond due to the padding error.
With this choice, the Bleichenbacher oracle has an additional false negative rate of 56.64 %.
However, this choice eliminates the chance of hitting the crash condition with 122 bytes.
Therefore, we recommend a length of 112 bytes for c ID I , which favors reliability of the attack over speed.
For our proof-of-concept attack, we focused on our Cisco test device due to the high false negative rate of the Huawei oracle.
In order to keep the required time for an attack below the limits, we built a highly parallelized Bleichenbacher attacker using Java (cf. Figure 10).
This tool pipelines all steps of the attack through IN and OUT queues and keeps track of used and unused SAs.SA States.
There is a global limit of 900 Phase 1 SAs under negotiation per Cisco device in the default configuration.
If this number is exceeded, one is blocked.
Thus, one cannot start individual handshakes for each Bleichenbacher request to issue.
Instead, SAs have to be reused as long as their error counter allows.For that, we are pooling SAs and tracking their states.
This is necessary since for example receiving a message m 2 can have three meanings: (1.)
The SA has been cre-ated as a response to a message m 1 , (2.)
a Bleichenbacher request was not successful and message m 2 was a retransmission after one second, or (3.)
the SA was not recently used for a request and message m 2 was a retransmission after ten seconds.When preparing a Bleichenbacher request, an SA is taken from the unused SA pool and put into the used SA pool to ensure that SAs are not mixed up.
In a parallel attack, constant SA state checks at all processing steps are required.
After receiving a response to a Bleichenbacher request, we return the corresponding SA to the unused SA pool.In our Bleichenbacher attacker, an SA can only be in one out of eight states.
The life of an SA starts with the generation of an initiator cookie c I .
With it, the first message m 1 is send and the state of the SA is set to PRESTART.
When we receive a corresponding message m 2 , we store the responder cookie value for that SA and update its state to FRESH.
From now on, every time we receive a message m 2 for that SA, we increment its state from FIRST to FIFTH.
After the FIFTH state is reached and another timeout or Bleichenbacher response is received, we set the state to EXHAUSTED and remove the SA from the unused SA pool.Packet and Network Pool.
For a fast attack, we require an efficient packet builder and analyzer.
The former only creates either first messages (m 1 ) for SA generation or third messages (m 3 ) for Bleichenbacher requests.
The latter analyzes the responses from the Bleichenbacher oracle.
Our packet builder uses static bytes sequences for the messages updating only the cookie values and encrypted nonce payloads.
We omit the identity payload c ID I from m 3 in order to save an unnecessary public key decryption.
The analyzer only needs the length of a received message and the values of two bytes at specific positions in order to distinguish Bleichenbacher responses from timeout packets.For sending and receiving packets with multiple threads, we use Java NIO DatagramChannels and NIO Selectors.Bleichenbacher Producer and Consumer.
A special producer thread executes the Bleichenbacher attack against a target and distributes the computations to consumers.
We implemented two distribution mechanism (multiple and single interval) in order to address the different steps in Bleichenbacher's attack.The consumers do the expensive computations for the Bleichenbacher attack.
In order to address the different computations in the two attack variants (standard and optimized), the consumers are provided with a task description of whether a multiplication or a division of the ciphertext is required.
Other consumers are used to verify the results from the packet analyzer and to notify the producer in case a valid padding was found.Cisco Oracle Simulator.
In order to accelerate our evaluation process, we first queried our test device with different valid and invalid PKCS #1 v1.5 messages.
After that, we analyzed its responses and reimplemented its behavior as a local multi-threaded simulator.
Thus, the speed of finding valid PKCS #1 v1.5 messages is only limited by the hardware resources of the attackers' systems.
For the decryption attack from subsection 4.2 on Cisco's IKEv1 responder, we need to finish the Bleichenbacher attack in 60 seconds.
If the public key of our ASR 1001-X router is 1024 bits long, we measured an average of 850 responses to Bleichenbacher requests per second.
Therefore, an attack must succeed with at most 51,000 Bleichenbacher requests.Based on this result, we used our Cisco oracle simulator to measure the percentage of attacks that would succeed before the time runs out.
These results can be found in Figure 11.
Standard Bleichenbacher.
In total, we executed 990 decryption attacks with a 1024-bit public key and different encrypted nonces.
On average, a decryption using Bleichenbacher's original algorithm requires 303,134 requests.
However, in 78 simulations, we needed less than 51,000 request to decrypt the nonce and thus could have impersonated the router.Optimized Bleichenbacher.
For the optimized Bleichenbacher algorithm, we executed 200 attacks against our Cisco oracle simulator with different nonces and a 1024-bit key.
On average, we gained a reduction for requests by approximately 18 % (247,283) using 3,000 trimmers for each attack.
The amount of attacks that require less than 51,000 requests increases from 7.88 % to 26.20 %.
Real Cisco Hardware.
For an attack against the real hardware, the limitations of Cisco's IKEv1 state machine are significant.
The main obstacle is the SA management: Once the attackers negotiate several thousand SAs with the router, its SA handling becomes very slow.We managed to perform a successful decryption attack against our ASR 1001-X router with approximately Cisco Bleichenbacher attack statistic Figure 11: Statistics of 990 standard decryption, 439 optimized decryption, and 542 signature-forgery attacks against our Cisco Bleichenbacher oracle simulator.19,000 Bleichenbacher requests.
However, due to the necessary SA negotiations, the attack took 13 minutes.
Note that a too slow Bleichenbacher attack does not permanently lock out attackers.
If a timeout occurs, they can just start over with a new attack using fresh values hoping to require fewer requests.
If the victim has deployed multiple responders sharing one key pair (e. g. for load balancing), this could also be leveraged to speed up an attack.
For our attack with forged signatures, we have 240 seconds time.
Therefore, we may issue 204,000 Bleichenbacher requests before the time runs out.
The timeout limits of IKEv1 are irrelevant for this attack; the IKEv1 handshake is only used to forge the signature we need for message m 5 in IKEv2 (cf. Figure 7).
Like with the decryption attack, we used our Cisco oracle simulator in order to speed up the evaluation.
We simulated 542 attacks with a 1024-bit key and random messages padded as PKCS #1 v1.5 for signatures.
From these attacks, 121 signatures needed less than 204,000 Bleichenbacher requests (on average 508,520).
Thus, 22 % of our attack simulations would have been fast enough to allow attackers to impersonate a Cisco router.
Note that due to the increased time limit, attacking IKEv2 with a forged signature has a higher success rate than the same attack on IKEv1.
PSKs as authentication method are often found in scenarios where users authenticate against services such as websites and computer logins.
Other applications include interconnecting devices like with Bluetooth, Wi-Fi, or IKE.
In the case of IKE, knowing the PSK allows attackers to impersonate any of the peers of an IPsec connection.
We will show in the following section how to mount offline dictionary attacks against IKEv1 and IKEv2.
It is well known that the PSK based mode of authentication is vulnerable to an offline dictionary attack when used together with the aggressive mode of IKEv1 Phase 1.
This has actually been exploited in the past [5].
For the main mode however, only an online attack against PSK authentication was thought to be feasible.
This required attackers to initiate many handshake attempts to try all different passwords making it likely to be detected.
We present an attack that only requires a single handshake in which attackers simulate a responder.
With it, the attackers learn enough information to mount an offline dictionary attack.
Thus, they can learn the PSK and can thus impersonate any party or act as a Man in the Middle.On the network, the attackers wait for the victim to initiate a handshake with a responder.
If victim and responder already have an active connection, the attackers bacher vulnerabilities in OpenSSL, JSSE (Java Secure Socket Extension), and a TLS hardware accelerator chip [27].
Somorovsky showed that MatrixSSL was also affected [29].
Recently, the ROBOT survey showed that thousands of domains on the Internet were running Bleichenbacher vulnerable servers, among them Facebook and PayPal [10].
Cross Protocol Attacks.
VPNs have already been target of cross protocol attacks.
One has been found in PPTP (Point-to-Point Tunneling Protocol) VPNs [17].
Another famous cross protocol attack is DROWN [6], which exploits the broken SSL 2.0 to break the current TLS 1.2.
In 2012, Mavrogiannopoulos et al. described a cross-protocol attack against all TLS versions using explicit elliptic curve Diffie-Hellman parameters [26].
A paper by Jager et al. [20] shows how to attack TLS 1.3 and QUIC from a Bleichenbacher oracle in some implementation of previous TLS versions.
In this paper, we have shown that all versions and variants of the IPsec's Internet Key Exchange (IKE) protocol can be broken, given two entry points.The first entry point is weak PSKs.
Offline dictionary attacks are possible against all three different variants, with two different adversaries: IKEv1 PSK in aggressive mode can be broken by a passive adversary, and both IKEv1 PSK in main mode and IKEv2 PSK can be broken by an active adversary who acts as a responder.The second entry point is Bleichenbacher oracles in the IKEv1 PKE and RPKE variants.
We have shown that such oracles exist in Cisco, Clavister, Huawei, and ZyXEL devices, and have computed their strength.
Given an oracle of this strength, we were able to show that under the attack restrictions imposed by Cisco's default values, we could successfully attack all public keybased variants of IKEv1 and IKEv2 with success probabilities between 7 % and 26 % in a single attempt.
Therefore, by repeating the attacks, all implementations can be broken.
In this work, we focus on IKE implementations.
However, if network devices reuse RSA key pairs for other services like SSH, TLS, etc., further attack surfaces could arise.To counter these attacks, both entry points must be closed: Only high entropy PSKs should be used, and both PKE and RPKE modes should be deactivated in all IKE devices.
It is not sufficient to configure key separation on the sender side.
All receivers must also be informed about this key separation -novel solutions are required to achieve this task.
create usage-keys, through which two RSA special-usage key pairs -one encryption pair and one signature pairare generated.
In their documentation [12], Cisco states the following:If you plan to have both types of RSA authentication methods in your IKE policies, you may prefer to generate special-usage keys.
With special-usage keys, each key is not unnecessarily exposed.
(Without special-usage keys, one key is used for both authentication methods, increasing the exposure of that key.)
We have not evaluated whether special usage keys are a working countermeasure against our key reuse attack.
The authors wish to thank Juraj Somorovsky and Tibor Jager with whom we had long conversations regarding Bleichenbacher attacks.
Thanks to Cisco who provided us test hardware for our experiments.
This paper is based in part upon work in the research projects SyncEnc and VERTRAG, which are funded by the German Federal Ministry of Education and Research (BMBF, FKZ: 16KIS0412K and 13N13097), as well as the FutureTrust project funded by the European Commission (grant 700542-Future-Trust-H2020-DS-2015-1).
1 RFC 2409 calls these keys SKEYID, SKEYID d , SKEYID a , and SKEYID e .
We shorten these names for brevity.2 RFC 2409 calls these values HASH.
This is misleading, since in practice the HMAC version of the negotiated hash algorithm is used as PRF.
Therefore, we use the name MAC.
2In general, IKEv2 is perceived to be more secure than IKEv1.
However, the attack described above works similarly against IKEv2.
The current standard RFC 5996 [23] mentions that it is generally not smart to rely only on a user chosen password and recommends to use IKEv2 together with EAP (Extensible Authentication Protocol) protocols.
However, in practice IKEv2 is usually used without EAP.Instead of using IKEv2 together with some EAP-TLS variant (like EAP-TTLS with EAP-MD5), one could also switch to OpenVPN and thus reduce the overhead from tunneling TLS in IKEv2.
Moreover, the advice from RFC 5996 is misleading since some EAP modes like EAP-MD5 or EAP-MSCHAPv2 also do not prevent offline dictionary attacks, they just require the attackers to shift from IKE to attacking EAP.
Ultimately, our research indicates that implementations only support IKEv2 with EAP for remote access of a user to a network.
Site-to-site scenarios are not covered by this construction and therefore remain vulnerable to the attack.
Related WorkIPsec and IKE For some time, real-world cryptographic research in the area of IPsec concentrated on the encryption layer.
Thus, the security of ESP is well understood today, thanks to major contributions from Pa- terson et al. in 2006Pa- terson et al. in -2007.
Their work shows vulnerabilities affecting encryption-only configurations of ESP due to flaws in the standard and its implementations [14,28].
These flaws can be resolved by integrity protection.
However, in 2010 they also showed that a particular integrity protection -namely a MAC-thenencrypt configuration -also leads to a plaintext-recovery attack [15].
Research paid only little attention to IKE.
The Logjam paper [5] discovered that some of the most used DH groups standardized for IKE offer an attack surface if the attackers are able to perform costly precomputations.
Another contribution by Checkoway et al. shows that the random number generator used by VPN devices from Juniper Networks was manipulated leading to a passive decryption vulnerability [11].
However, both these findings do not target IKE itself, but rather the parameters of underlying cryptographic building blocks.Bleichenbacher Attacks.
Even though the seminal work by Bleichenbacher dates back to 1998 [9], Bleichenbacher vulnerabilities are discovered regularly.
Though the vulnerability is not protocol-related, the majority of vulnerabilities have been found in TLS implementations.
A paper by Meyer et al. found Bleichen- A IKEv1 with Signature AuthenticationThe IKEv1 and IKEv2 signature authentication modes are similar and both target of our signature forgery attack.
Supplementary to the description of the IKEv2 variant (cf. Figure 6), here we present the IKEv1 signature authentication mode in detail.
Figure 13 shows the message flow for this mode.First, the initiator creates a set of proposals consisting of algorithms, key lengths, and additional parameters and sends it with his initiator cookie to the responder.
The responder selects a proposal based on his configured policies.
After that, initiator and responder exchange DHKE parameters and nonces.Both peers are now able to derive all symmetric keys.
In order to confirm the keys and authenticate against each other, a MAC is computed by each party using key k from the key derivation.
Subsequently, two signatures are generated by the peers: one over MAC I and one over MAC R .
After both peers exchanged their signatures and optionally the corresponding certificates, they validate the signatures and continue with Phase 2 only if the signatures are valid.
The PKCS #1 v1.5 encryption padding scheme [21] randomizes encryptions by requiring the encoding shown in Figure 14.
To encrypt a plaintext message n (here, a nonce), the following steps have to be performed:1.
The encrypter generates a random byte string P of length P = N − n − 3.
P must not contain 0x00.
Furthermore, P must be at least eight bytes long ( P ≥ 8).2.
The message with padding before encryption is m = 0x00 || 0x02 || P || 0x00 || n.
The ciphertext is computed as c = m e mod N.To decrypt such a ciphertext, the na¨ıvena¨ıve decrypter performs the following steps: However, if the attackers learn whether the decrypter rejects messages due to the checks performed in steps 2-4, the decrypter is susceptible to Bleichenbacher's attack.
C Key Types of Cisco IOSOur key reuse attack assumes that the same RSA key pairs are used for encryption and signatures.
When generating RSA key pairs, Cisco IOS gives the administrator a choice: The default is to create general-keys, which generates a single key pair for all authentication methods that is vulnerable to our attacks.
The other option is to In general, IKEv2 is perceived to be more secure than IKEv1.
However, the attack described above works similarly against IKEv2.
The current standard RFC 5996 [23] mentions that it is generally not smart to rely only on a user chosen password and recommends to use IKEv2 together with EAP (Extensible Authentication Protocol) protocols.
However, in practice IKEv2 is usually used without EAP.Instead of using IKEv2 together with some EAP-TLS variant (like EAP-TTLS with EAP-MD5), one could also switch to OpenVPN and thus reduce the overhead from tunneling TLS in IKEv2.
Moreover, the advice from RFC 5996 is misleading since some EAP modes like EAP-MD5 or EAP-MSCHAPv2 also do not prevent offline dictionary attacks, they just require the attackers to shift from IKE to attacking EAP.
Ultimately, our research indicates that implementations only support IKEv2 with EAP for remote access of a user to a network.
Site-to-site scenarios are not covered by this construction and therefore remain vulnerable to the attack.
IPsec and IKE For some time, real-world cryptographic research in the area of IPsec concentrated on the encryption layer.
Thus, the security of ESP is well understood today, thanks to major contributions from Pa- terson et al. in 2006Pa- terson et al. in -2007.
Their work shows vulnerabilities affecting encryption-only configurations of ESP due to flaws in the standard and its implementations [14,28].
These flaws can be resolved by integrity protection.
However, in 2010 they also showed that a particular integrity protection -namely a MAC-thenencrypt configuration -also leads to a plaintext-recovery attack [15].
Research paid only little attention to IKE.
The Logjam paper [5] discovered that some of the most used DH groups standardized for IKE offer an attack surface if the attackers are able to perform costly precomputations.
Another contribution by Checkoway et al. shows that the random number generator used by VPN devices from Juniper Networks was manipulated leading to a passive decryption vulnerability [11].
However, both these findings do not target IKE itself, but rather the parameters of underlying cryptographic building blocks.Bleichenbacher Attacks.
Even though the seminal work by Bleichenbacher dates back to 1998 [9], Bleichenbacher vulnerabilities are discovered regularly.
Though the vulnerability is not protocol-related, the majority of vulnerabilities have been found in TLS implementations.
A paper by Meyer et al. found Bleichen- The IKEv1 and IKEv2 signature authentication modes are similar and both target of our signature forgery attack.
Supplementary to the description of the IKEv2 variant (cf. Figure 6), here we present the IKEv1 signature authentication mode in detail.
Figure 13 shows the message flow for this mode.First, the initiator creates a set of proposals consisting of algorithms, key lengths, and additional parameters and sends it with his initiator cookie to the responder.
The responder selects a proposal based on his configured policies.
After that, initiator and responder exchange DHKE parameters and nonces.Both peers are now able to derive all symmetric keys.
In order to confirm the keys and authenticate against each other, a MAC is computed by each party using key k from the key derivation.
Subsequently, two signatures are generated by the peers: one over MAC I and one over MAC R .
After both peers exchanged their signatures and optionally the corresponding certificates, they validate the signatures and continue with Phase 2 only if the signatures are valid.
The PKCS #1 v1.5 encryption padding scheme [21] randomizes encryptions by requiring the encoding shown in Figure 14.
To encrypt a plaintext message n (here, a nonce), the following steps have to be performed:1.
The encrypter generates a random byte string P of length P = N − n − 3.
P must not contain 0x00.
Furthermore, P must be at least eight bytes long ( P ≥ 8).2.
The message with padding before encryption is m = 0x00 || 0x02 || P || 0x00 || n. To decrypt such a ciphertext, the na¨ıvena¨ıve decrypter performs the following steps: However, if the attackers learn whether the decrypter rejects messages due to the checks performed in steps 2-4, the decrypter is susceptible to Bleichenbacher's attack.
Our key reuse attack assumes that the same RSA key pairs are used for encryption and signatures.
When generating RSA key pairs, Cisco IOS gives the administrator a choice: The default is to create general-keys, which generates a single key pair for all authentication methods that is vulnerable to our attacks.
The other option is to
