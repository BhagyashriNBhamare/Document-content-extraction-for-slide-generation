Password remains the most widespread means of au-thentication, especially on the Internet.
As such, it is the Achilles heel of many modern systems.
Face-book pioneered using external cryptographic services to harden password-based authentication in a large scale.
Everspaugh et al. (Usenix Security '15) provided the first comprehensive treatment of such a service and proposed the Pythia PRF-Service as a cryptographically secure solution.
Recently, Schnei-der et al. (ACM CCS '16) proposed a more efficient solution which is secure in a weaker security model.
In this work, we show that the scheme of Schnei-der et al. is vulnerable to offline attacks just after a single validation query.
Therefore, it defeats the purpose of using an external crypto service in the first place and it should not be used in practice.
Our attacks do not contradict their security claims, but instead show that their definitions are simply too weak.
We thus suggest stronger security definitions that cover these kinds of real-world attacks, and an even more efficient construction, Phoenix, to achieve them.
Our comprehensive evaluation confirms the practicability of Phoenix: It can handle up to 50% more requests than the scheme of Schnei-der et al. and up to three times more than Pythia.
In spite of the research and development in authentication mechanisms such as public-key infrastructure or secure hardware tokens, the reality has shown that password-based authentication remains the most widespread means, especially on the Internet.
As such, password-based authentication is the Achilles heel of many modern systems.
Following a suggestion from the 70s, passwords are commonly stored as salted hash values.
Yet, it is no longer adequate in the face of the increasing number of attacks.
Prominent breaches of user accounts include Adobe, Yahoo, and much more [24].
The financial consequences are also dramatic.
Verizon asked for a 1 billion discount on acquiring Yahoo [20] after knowing it had been hacked (1.5 billion+ accounts).
We see an urgent need for action.Obvious Weaknesses in Current Systems.
Almost all web services store passwords as salted hash values as shown in Figure 1.
The security of the Alice, 123456 Alice, salt H(salt,123456)Figure 1: Password-based Authentication passwords relies crucially on the assumption that the databases are kept secret from external attackers, and the internal administrators are trusted for not disclosing the databases or guessing the passwords themselves.
However, the reality shows that databases get stolen.
This is disastrous as passwords usually have low entropy and therefore can be guessed by a brute-force attack easily.
Under the aforementioned threat, there is a need for new solutions to protect passwords in a setting where the attacker has full access to the compromised service provider, including its secret keys and databases.
It is not hard to see that any solution in which the web service can verify a given password alone is not viable, as a compromised service provider has all the knowledge (e.g., secret keys) to carry out a brute-force guessing attack (e.g., decrypting by the secret key of the web service) as in a normal validation.
Additional cryptographic mechanisms are needed to enhance security.Moreover, an ideal solution should not change the infrastructure from the point of view of users.
This is challenging as it rules out solutions which requires the end users to perform cryptographic operations.External Password Hardening Services.
A promising approach for the web service provider is to use external crypto services [4], where a crypto server carries out certain cryptographic operations, such as the computation of pseudorandom functions (PRF).
Its general advantage is that it abstracts crypto away from developers, freeing them from the selection and implementation of suitable algorithms and the involved issue of key management.Cryptographic PRF services are used in practice by Facebook [16] for password-based authentication.
In this setting, the end-user Alice enters her user-Alice, 123456 Alice PRF(….)
Figure 2: Password-based Authentication name and the corresponding password into the web service as usual, as in Figure 2.
The service provider no longer stores salted hash values, but only pseudorandom values which can only be computed with the help of the external PRF server, i.e., the service provider acts as a client of the PRF service.
While used in practice, such kind of password hardening services did not receive much attention from the academia until the seminal work of Everspaugh et al. [9].
They formalize partiallyoblivious PRFs (PO-PRF) with several security properties that conventional PRF services do not offer, with a fairly efficient construction, Pythia.
Even if the web server is compromised and the database (of pseudorandom values) is stolen, bruteforce offline attacks are no longer possible.
The reason is that the adversary must interact with the PRF service to confirm a guess.
The partial obliviousness ensures that the external crypto server does not learn the password but can still see the username when answering PRF requests.
Rate limiting can thus be applied to make sure that an adversary cannot guess too many times.
For incident response after key compromise, or to update the key proactively as a prudent practice, both the web server and the crypto service should be able to rotate their keys, without the end users noticing anything.
Efficient key rotation [9,21] means the amounts of communication and server computation are independent of the size of the database.
It is an important security feature that cryptographic password hardening services must have [9,21].
Using Pythia for password hardening is not without disadvantages.
For example, it is only secure under a strong assumption [21], and is based on pairings, which is not as efficient as one can hope for.
Very recently, Schneider et al. [21] claimed that all the properties expected by Pythia can be achieved by a weaker cryptographic primitive called partially-oblivious commitments (PO-COM).
Using PO-COM, the PRF values are replaced with "enrollment records" which can be jointly computed by the client and the server via an enrollment protocol.
The main difference lies in how a password is verified.
Instead of jointly computing a PRF value, the client and the server engage in a validation protocol to verify whether a candidate password matches an enrollment record.
Schneider et al. [21] also suggested a scheme that is twice as efficient as Pythia.
Unfortunately, as we will show, their scheme is vulnerable to offline dictionary attacks.
This motivates us to develop a new solution which is secure against such attacks while achieving even better efficiency.
Formal security definitions are important even from a practical standpoint.
They precisely describe what level of security can be achieved and serve as a basis for comparison between different solutions.
Finding the "right" security definitions is challenging.
They should be strong enough to cover all realworld attacks, but not to exclude efficient solution.
In this work, we revisit the security notions of Everspaugh et al. [9] and Schneider et al. [21].
We argue that both fail to cover key rotation and rate limiting, while the latter even leaves room for practicallyrelevant attacks.In response, we propose strengthened security definitions for password hardening schemes.
Next, we propose a new construction, Phoenix, which is 1) extremely efficient, 2) reasonably simple, and 3) secure based on simple and well-known assumptions.
With these properties, we believe that Phoenix may attract deployment interest.
Below highlights our contributions in more details.
ties are not compromised simultaneously.
Somewhat surprisingly, none of the existing security definitions take key rotation into account.
To fill the gap, we formalize forward security of password hardening services, which captures the security guarantee in the presence of key rotation mechanisms.Modeling Online Attacks.
We argue that the definition of obliviousness (renamed to hiding in our work) given by Schneider et al. [21] is too weak.
The property is supposed to protect the passwords when the client is compromised.
Ideally, it should be guaranteed that the best attack strategy for guessing a password is to brute-force by repeatedly interacting with the crypto service online (modeled by the validation oracle in the security definition).
Unfortunately, obliviousness, as defined by Schnei- der et al. [21], fails to capture this intuition, as its security experiment denies the adversary access to the validation oracle after receiving the challenge enrollment record.
Indeed, permitting the adversary such accesses would allow it to trivially distinguish between two possible passwords.
Moreover, by resorting to a crypto server to harden the passwords, one naturally expects it can perform rate limiting.
While it is obviously a crucial feature, we are not aware of any definition which takes this into account.
To resolve these issues, we suggest a "correct" security definition, which covers both online attacks and rate limiting.
The latter is guaranteed by upperbounding the advantage of the adversary by the loss of entropy in guessing and validation.Attacking against Schneider et al. [21].
The shortcoming of the obliviousness definition by Schneider et al. [21] is not just a definitional deficiency.
We detail how to perform highly efficient (essentially only one exponentiation for each trial) offline dictionary or direct attacks against their scheme by just a single interaction with the crypto server!
We stress that our attack is outside of the security model of Schneider et al. [21].
Below we only show part of the scheme which matters in the attack.In their scheme, an enrollment record, stored by the client C using the crypto service provided by S, can be seen as an ElGamal encryption under a secret key s x of S, in the form of (T 1 , T 2 ) = (g y , g ys x · pw sk C ) ∈ G 2 , where G is a (multiplicative) finite cyclic group.
To validate that this record corresponds to a password pw for some username un, C sends (T 1 , un, v) for v = pw r·sk C .
Without any validity checking, S returns π 2 , a zero-knowledge proof of s x with respect to (g y , g ys x ).
This opens the door for the following generic offline dictionary attack, without exploiting the structure of the zero-knowledge proof: An adversary A who compromised C (and hence obtained sk C and (T 1 , T 2 )) sends (g y , un, h) to S where h is a random group element independent of any passwords.
After getting π 2 from S, A can then try different passwords pw by testing if the proof π 2 is for (T 1 , T 2 /pw sk C ).
This is doable since the entropy of pw is assumed to be low.
By further exploiting the structure of the specific instantiation of the proof, the adversary can even extract the password directly: It first extracts the value g ys x from the proof π 2 , then computes pw = (T 2 /g ys x ) 1/sk C .
We conclude that one must not use the scheme of Schneider et al., as our attack defeats its purpose of using an external crypto service.Reviving the Broken Scheme.
In the spirit of providing password hardening services using a weaker tool than PO-PRFs [21], we present Phoenix, a conceptually simple construction from standard cryptographic primitives.
It achieves two seemingly contradicting goals: a high security level without sacrificing the efficiency.
Our scheme can, in fact, handle roughly 50% more request per second than that of Schneider et al. [21], and three times more than Pythia [9].
Since the scheme of Schnei- der et al. [21] is vulnerable to the one validationquery offline dictionary attacks, ours is the first efficient and fully secure solution based on standard decisional Diffie-Hellman assumption.
Let λ ∈ N be the security parameter.
By x ←$ S we denote the uniform drawing of a random element x from set S. Unless stated otherwise, all algorithms run in probabilistic polynomial time (PPT).
x ←$ A(y) denotes the event that A on input y outputs x.
If A is deterministic we write x ← A(y) instead.
For two PPT interactive algorithms A, B, we denote by (a, b) ←$ A(x), B(y) X the event that A and B engage in the protocol X on input x and y, and produce local outputs a and b, respectively.
If there is only one output, then it is assumed to be for A.
We write B A(x),·· (y) if B can invoke an unbounded number of executions of the interactive protocol with A in an arbitrarily interleaved order.
Both previous works formulated cryptographic primitives [9,21] which were supposed to cover the properties of cryptographic password hardening (PH) services.
We do not follow this approach.
Instead, we define PH directly, which is simpler and more natural.
A direct definition removes the need for bridging the security requirements of the underlying primitives to those expected by PH (e.g., the main feature of key rotation seems to make more sense in PH than in the underlying commitment [21]).
Our formalization of PH is closely related to the definition of partially-oblivious commitments (PO-COM) defined by Schneider et al. [21], with the main difference being that we consider key rotation in all security definitions.
Roughly speaking, a PH scheme PH is a two party protocol that is partitioned in phases.
The first phase is the setup phase, in which a client C and the server S set up their public and secret keys individually without communication.
Each phase after the first is either an enrollment, a validation, or a key rotation phase, in an arbitrary order.In an enrollment phase, the client and the server cooperate to generate an enrollment record T for a username un, and a password pw, where un is an input available for both and pw is a private input from the client.
The client then stores the record T .
Subsequently, in a validation phase, the client can interact with the server to verify if a pair (un, pw) is stored in a record T .
Similar to the enrollment phase, un is a common input and pw is a private input from the client.
We note that in the original syntax [21], while un is not an input of the server, it is supposed to be revealed to the server during the interactions in the protocol for rate limiting.Suppose an adversary, who may have knowledge of some enrollment records, compromises either the client or the server secret key.
It can then act as the compromised party and interacts with the other in the protocols to figure out the underlying passwords of the enrollment records.
As soon as the incident is discovered, the (true) client and the (true) server communicate to refresh their keys and all enrollment records.
Instead of regenerating them from scratch, they enter a key rotation phase to update their secret keys.
In addition to an updated client secret key, the client also obtains some auxiliary information, using which it is able to update each enrollment record locally, without further communicating with the server, nor knowing the underlying password of the record.
Note that our syntax of the key rotation phase is significantly different.
In the original definition [21], the key rotation protocol updates a single enrollment record instead of all records stored by the client.
We believe that this was an oversight.
We provide a formal definition of cryptographic password hardening schemes.
Some algorithms in our formalization get as input some auxiliary input, such as a random session identifier.
Under normal circumstances, the auxiliary information is an empty string denoted by .
Non-empty auxiliary information is only used in defining forward-security.
Definition 1 (PH) Let U and P be the username and password space respectively.
A cryptographic password hardening service PH consists of the efficient algorithms (Setup, KGen C , KGen S , C, S enrl , C, S val , C, S rot , Udt), to be executed in four phases:Setup Phase.
On input the security parameter λ, Setup(1 λ ) outputs the public parameter pp.
On input the public parameter pp, the client runs KGen C (pp) to generate a client public key pk C , and a client secret sk C , while the server runs KGen S (pp) to generate a server public key pk S , a server secret sk S .
All parties will take as input the public parameter pp, the client public key pk C , and the server public key pk S in all subsequent protocols.
Enrollment Phase.
In the enrollment protocol C(sk C , un, pw, aux), S(sk S , un, aux) enrl , the client inputs its secret key sk C , a username un ∈ U, a password pw ∈ P, and some auxiliary information aux.
The server inputs its secret key sk S , a username un, and some auxiliary information aux.
The client outputs an enrollment record T , while the server outputs nothing.
We say that the enrollment record T stores the tuple (un, pw).
The client stores the tuple (T, un), and securely deletes the password pw and all intermediate values that are computed locally or obtained from the server.
The server is also supposed to delete all intermediate values.Validation Phase.
In the validation protocol C(sk C , T, un, pw), S(sk S , un) val , the client inputs its secret key sk C , an enrollment record T , a username un ∈ U, and a password pw ∈ P.
The server inputs its secret key sk S , and a username un.
The client outputs a decision b ∈ {0, 1} of whether T stores the tuple (un, pw), while the server outputs nothing.Key Rotation Phase.
In the key rotation protocol C(sk C ), S(sk S ) rot , the client and the server input their secret keys sk C and sk S respectively.
The client outputs an updated client public key pk C , an updated client secret key sk C and an update token τ .
The server outputs an updated server public key pk S , and an updated secret key sk S .
Using the update token τ , the client runs the update algorithm Udt(τ, T, un) to update each of the old enrollment records T into new ones T .
Correctness.
We require that all honestly generated enrollment records can pass validation.
Formally, a cryptographic password hardening service scheme PH is correct if for all security parameter λ ∈ N, public parameters pp ∈ Setup(1 λ ), key pairs (pk C , sk C ) ∈ KGen C (pp) and (pk S , sk S ) ∈ KGen S (pp), username un ∈ U, password pw ∈ P, enrollment records T ∈ C(sk C , un, pw, ), S(sk S , un, ) enrl , it holds that C(sk C , T, un, pw), S(sk S , un) val = 1.
Note that it is unnecessary to define the correctness of key rotation, as it will be captured by forward security to be introduced below.
Our security definitions are fundamentally different from, and arguably stronger than, the originals [21].
In particular, our notions cover important real-world attacks and ensures security in the presence of key rotation, as discussed in the introduction.
In the following, we first give an overview of our definitions, and discuss the differences in details in Section 2.4.
A cryptographic password hardening service is required to be (partially) oblivious, hiding, binding, and forward secure.
Roughly speaking, partial oblivious means that it is infeasible, even for a malicious server, to tell which password pw is used by the client in the enrollment and validation protocols.
It is partial in the sense that the username un can be revealed.
In fact, un is required to be revealed to the server for rate limiting.
We therefore simply let un be a common input for both parties in the enrollment and the validation protocols.Hiding means that, given the client secret key sk C , a username un, and an enrollment record T of (un, pw) for some hidden password pw, the best strategy of any adversary to guess pw is by launching an online dictionary attack which requires interaction with the server via the validation protocol.Binding requires that it is computationally infeasible, even for a malicious server, to convince the client that an enrollment record T is valid for two distinct pairs (un, pw) and (un , pw ).
Forward security means that compromising either the client or the server secret key does not help the adversary to determine the underlying password of an enrollment record.
We formalize this intuition in an even stronger property.
It requires that even if both the client and server secret keys are adversarially generated, the updated keys and enrollment records are indistinguishable from the freshly generated ones.
This formalization is simpler because we do not need to argue about the security of secret keys which can be rotated for many times.
Partial obliviousness protects against a malicious server that wishes to learn the password pw behind an enrollment record after observing its creation and several validations.
The property is partial since it does not guarantee anything about the secrecy of the username un.
In fact, in the syntax defined above, we let the client reveal the username un to the server explicitly by regarding un as a common input.Technically, we consider a security experiment played between a challenger acting as the client and an adversary acting as the malicious server.
The challenger generates the client secret key and keeps it secret (Line 1).
Furthermore, it simulates executions of the enrollment, validation, and key rotation protocol, where only the client secret key input is fixed (Line 2).
The adversary can provide all other client inputs, as well as the server side code.
The embedded client secret key can be updated by executing the key rotation protocol.
The client outputs of all protocol executions, except for sk C from the key rotation protocol, are given to the adversary.The experiment then proceeds in two stages, a learning phase and a challenge phase.
In the learning phase, the adversary is free to interact with the challenger in the above protocols.
At the end of this phase, the adversary outputs a username un * , and two passwords pw * 0 and pw * 1 (Line 3).
It will then be challenged on one of the passwords and the attacker has to guess the password.
Formally, the challenger generates the challenge record T * (for the password pw b ) together with the adversary (line 7).
In addition to the previous protocols, the adversary gets access to an additional embedded-password validation protocol, which embeds either (un* , pw * 0 ) or (un * , pw * 1 ) (Lines 8).
Note that the adversary may query the (normal) enrollment and validation protocol on most username-password pairs, and the protocols only return ⊥ for the pairs (un * , pw * b ) for b ∈ {0, 1} (Lines 10 and 11) to avoid it from winning trivially.
Finally, the adversary outputs b guessing which tuple is embedded (Line 9).
Definition 2 (Partial Obliviousness) A cryptographic password hardening service PH is partially oblivious if, for any three-stage PPT adversaryObl b Π,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk C , sk C ) ←$ KGen C (pp) 2 : O := {{C(sk C , . . .), ·· X : X ∈ {enrl, val, rot}} 3 : (un * , pw * 0 , pw * 1 , state) ←$ A O 1 (pp, pk C ) 4: / / All client outputs are given to adversary, 5 :/ / except for sk C output by C(skC), ··rot.6 : / / C(skC), ··rot updates skC embedded in all oracles to skC .
7 : (T * , state) ←$ C(sk C , un * , pw * b , ), A 2 (st) enrl 8 : O := O ∪ {{C(sk C , ·, un * , pw * b ), ·· val } 9 : b ←$ A O 3 (state, T * ) 10 : / / C(skC, . . .), ··enrl and C(skC, . . .), ··val return ⊥ 11 : / / on input containing (un * , pw * b ) for b ∈ {0, 1}.12 : return b Figure 3: Partial Obliviousness ExperimentA = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ) such that Pr Obl 0 Π,A (1 λ ) = 1 − Pr Obl 1 Π,A (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiments and the adversary.
Figure 3 defines the two experiments.
The hiding property protects the passwords from an adversary who compromises the client, learns its secret key and all enrollment records, and wishes to learn the underlying password behind one of the records.
We formalize this intuition by letting the adversary play the client role in the enrollment, validation, and key rotation protocols.
Inevitably, since passwords are assumed to have low entropy, the adversary always succeeds if it attempts to validate the target record with all possible passwords.
Our formulation covers this fact by adjusting the success determination accordingly.
To explain our idea, consider the following experiment: The challenger chooses a random password.
The adversary is given access to a magical oracle which, when given a guess, answers whether the guess equals the chosen password.
Suppose that only Q guesses are allowed.
Obviously, the best strategy of the adversary is to asks for the Q most probable passwords.
If one of them returns true, then the adversary wins by outputting that password.
Otherwise, its best strategy is to output the most probable password which is not yet guessed, i.e., the (Q + 1)-th most probable password.
Since the adversary can use the server as the magical oracle by interacting with it in the validation protocol, the best we can hope for is that the adversary cannot perform significantly better than the above strategy.Technically, we consider a security experiment (see Figure 4) played between a challenger acting as the server and an adversary acting as the malicious client.
The challenger generates the server secret key honestly and keeps it secret (Line 1).
The adversary can interact with the challenger in the enrollment, validation, and key rotation protocols using arbitrary client side codes (Line 2).
Eventually, the adversary outputs a client secret key sk C , a username un * , and a distribution χ of passwords (Line 6).
The distribution models the real-world situations where the passwords to be protected are not uniformly random in {0, 1} λ but instead follow a certain distribution possibly with low entropy, which might be known by the adversary.
The challenger then chooses a random password pw * (Line 7) from the distribution χ and computes a fresh challenge enrollment record T * for the tuple (un * , pw * ) using the honest client and server code (Line 8).
The challenger sends T * to the adversary (Line 9).
The adversary can continue to interact with the server and finally outputs pw .
It wins if pw * is equal to pw .
Using the above strategy, the adversary wins with probability at least Q+1 i=1 p i , where Q is the number of times the validation oracle is queried on inputs containing un * , and p i is the i-th most probable event in χ.
We therefore require that the success probability of the adversary be negligibly close to Q+1 i=1 p i .
We remark that similar bounds are used in the context of password-authenticated key exchange [3].
hardening service PH is hiding if, for any two-stage PPT adversary A = (A 1 , A 2 ), there exists a negligible function negl (λ) such that HidingΠ,A (1 λ ) = 1 ≤ Q+1 i=1 p i + negl (λ)where the randomness is taken over the random coins of the experiment and the adversary, p i is the probability of the i-th most probable event in the distribution χ specified by A 1 in the experiment, and Q is the number of times ·, S(sk S , ·) val is queried by A 2 on server input un * .
Figure 4 defines the experiment Hiding Π,A .
Similar to commitments, binding guarantees it is infeasible to open an enrollment record into two dis-Hiding Π,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk S , sk S ) ←$ KGen S (pp) 2 : O := {{·, S(sk S , . . .) X : X ∈ {enrl, val, rot}}3 : / / All server outputs are given to adversary, 4 : / / except for sk S output by ·, S(skS )rot.5 : / / ·, S(skS )rot updates skS embedded in all oracles to skS .
6 : (sk C , un * , χ, state) ←$ A O 1 (pp, pk S ) 7 : pw * ←$ χ 8 : T * ←$ C(sk C , un * , pw * , ), S(sk S , un * , ) enrl 9 : pw ←$ A O 2 (state, T * ) 10 : return (pw * = pw )Figure 4: Hiding Experiment tinct passwords.
In our setting, however, the enrollment record is never opened but only validated.
The binding property in this context prevents a malicious server from convincing the client that an enrollment record T * is valid for distinct tuples (un * 0 , pw * 0 ) and (un * 1 , pw * 1 ).
Since by the correctness requirement if T is the enrollment record for (un, pw), then (T, un, pw) must pass validation.
Thus, the binding property implicitly guarantees that a malicious server can never convince the client that an invalid enrollment record is valid.Technically, we consider a security experiment played between a challenger acting as the client and an adversary acting as the malicious server.
At the beginning, the adversary outputs a client secret key sk C , an enrollment record T * , and a tuple (un * 0 , pw * 0 ).
The challenger and the adversary then interact in the validation protocol to validate the tu- ple (T * , un * 0 , pw * 0 ), BindingΠ,A (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiment and the adversary.
Figure 5 defines the binding experiment.Binding Π,A (1 λ ) 1 : (pk S , sk C , T * , un * 0 , pw * 0 , state) ←$ A 1 (1 λ ) 2 : (b 0 , state) ←$ C(sk C , T * , un * 0 , pw * 0 ), A 2 (state) val 3 : (un * 1 , pw * 1 , state) ←$ A 3 (state) 4 : (b 1 , state) ←$ C(sk C , T * , un * 1 , pw * 1 ), A 4 (state) val 5 : b 2 ← ((un * 0 , pw * 0 ) = (un * 1 , pw * 1 )) 6 : return b 0 ∧ b 1 ∧ b 2Figure 5: Binding Experiment Intuitively, the key rotation should render an old client or server key useless to the adversary.
Further, an old client or server secret key should not help in recovering information from an updated enrollment record.
To formalize this intuition, one possible but complicated way is to define a security experiment which gives the adversary accesses of a special key rotation oracle apart from the usual enrollment and validation oracles.
The key rotation oracle leaks either the client or the server secret key to the adversary, and at the same time rotates the old keys to the new ones.
The goal of the adversary is to find out the underlying password of an enrollment record.
Alternatively, we consider a simpler definition based on the intuition that the rotated keys and enrollment records are indistinguishable from freshly generated ones.Technically, we consider a security experiment played between a challenger, acting as both the client and the server, and an adversary acting as a malicious outsider.
At the beginning, the adversary outputs both secret keys sk C and sk S , and a valid tuple (T, un, pw) under the specified keys.
This models the situations where the adversary somehow obtains the secret keys which might be rotated many times.
The challenger then either rotates the keys and updates the enrollment record, or samples a new pair of keys and generates a fresh enrollment record for (un, pw), using some auxiliary information aux = L(T ), for some leakage function L.
The updated or fresh keys and enrollment record are then sent to the adversary, who must guess how those are produced.
We require the probability of the adversary guessing correctly to be negligible.
Rot b Π,A,L (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk C , sk S , T, un, pw, state) ←$ A 1 (pp) 3 : b 0 ← C(sk C , T, un, pw), S(sk S , un) val 4 : if b = 0 then 5 : ((pk C , sk C , τ ), (pk S , sk S )) ←$ C(sk C ), S(sk S )rot 6 :T ←$ Udt(τ, T, un)7 : else 8 : (pk C , sk C ) ←$ KGen C (pp), (pk S , sk S ) ←$ KGen S (pp) 9 : aux ← L(T ) 10 : T ←$ C(sk C , un, pw, aux), S(sk S , un, aux) enrl 11 : endif 12 : b 1 ←$ A 2 (state, sk C , sk S , T ) 13 : return b 0 ∧ b 1 Figure 6: L-Forward Security Experiment Pr Rot 0 Π,A,L (1 λ ) = 1 − Pr Rot 1 Π,A,L (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiments and the adversary.
Figure 6 defines the two experiments.
We comprehensively explain the differences between our definitions and those of Schneider et al. [21].
We argue that ours either capture the intended security features better, or imply their counterparts.
The property was introduced in the name "partially hiding", which we believe is an oversight since the primitive was called "partially-oblivious" commitment schemes.
The adversary in the original security experiment is stronger such that it generates both the client and server secret keys.
However, it is also weaker in other abilities:• Their embedded-password validation oracle embeds an enrollment record T output by the adversary.
In contrast, ours allow the adversary to query on any enrollment record T .
• The client secret key embedded in the oracles is fixed.
The adversary cannot instruct the challenger to rotate it into a new one.
• The adversary does not learn the client outputs from the embedded-password oracles.
We think this violates the general philosophy of cryptographic definitions where, for most of the time, only the secret keys are assumed to be hidden from the adversary.
The property was introduced in the name of "obliviousness", which we believe is an oversight since obliviousness is supposed to be a security property against a malicious server.
However, the original security experiment models a malicious client, who is trying to figure out the underlying password pw of a given enrollment record T .
Recall that the whole point of introducing PO-PRF and PO-COM is to prevent against offline dictionary attacks.
The idea is that, even given the client secret key sk C and the enrollment record T for some username un, the adversary can only guess the underlying password pw one at a time with the aid of the server.
This rate-limits validation queries based on the username un.
Assuming there is enough entropy in the password pw, the adversary is unable to recover pw before the limited number of validation query quota is used up.
Curiously, the definition of Schneider et al. [21] does not model such an attack: In the second stage, after specifying the challenge passwords pw 0 and pw 1 , the adversary is no longer given access to the validation oracle.
If they allow the adversary to query the validation oracle even once in this stage, the adversary can win trivially by simply querying the oracle with either pw 0 or pw 1 .
We fix this issue by requiring the adversary to specify a distribution χ of passwords instead of just two, and allowing it to query the validation oracle as many times as it wants.
The resistance against offline dictionary attacks is then modeled by the success probability of the adversary: We require that the adversary must only be able to rule out at most one possible password from each query to the validation oracle.
Finally, note that the adversary in the original definition cannot access any rotation oracle.
In the original definition, the binding property is only guaranteed for honestly generated keys and honestly validated enrollment records.
It is not clear what this security guarantee means in the context of password hardening, the main motivating application.
We thus make the following changes with a malicious server in mind.
First, although it is not necessary for the context of password hardening, we let the adversary provide the client secret key.
Second, it does not output the two pairs (un 0 , pw 0 ) and (un 1 , pw 1 ) right away.
Instead, it first outputs (un 0 , pw 0 ), waits until the validation protocol is executed on this pair, and then adaptively outputs the second pair.
Third, the server-side code for validating the two pairs (un 0 , pw 0 ) and (un 1 , pw 1 ) is provided by the adversary.
This formulation makes more sense in the context of password hardening.
It models a malicious server which is trying to convince the client that an enrollment record is valid for two pairs (un 0 , pw 0 ) and (un 1 , pw 1 ), whereas at least one of which must be invalid.
We propose a conceptually simple, almost generic construction, Phoenix, based on (partially) homomorphic encryption and pseudorandom functions.In the enrollment protocol, S receives a username un.
It returns h S ← PRF k S (un, n S ) for some random nonce n S .
C computes h C ← PRF k C (un, pw, n C ) for another random nonce n C , and encrypts the product h S · h C under the server public key.
Then, it stores the ciphertext as the enrollment record of (un, pw) in its database, and securely deletes the password pw and all intermediate values computed locally or received from the server.
S should also delete all its intermediate values.To validate a candidate password pw , C computes the pseudorandom value h C ← PRF k C (un, pw , n C ), and performs a homomorphic operation on the ciphertext such that it now encrypts the product h S · h C /h C .
It then sends the resulting ciphertext to S, who attempts to decrypt it.
Suppose the candidate password is correct, the term h C is canceled out, and S is left with a ciphertext of h S .
S thus verifies whether the message obtained from decryption equals h S , and proves the correctness of the decryption if so.
C is convinced that the candidate password is correct if and only if the proof is valid.To support key rotation, we need key homomorphism in addition to message homomorphism.
We thus instantiate the above generic construction with an encryption scheme which is inspired by ElGamal [8] and Cramer-Shoup [6], and the pseudorandom function PRF k (·) = H(·) k [17], where k ∈ Z q and the hash function H is modeled as a random oracle.
We cannot use ElGamal or CramerShoup directly, as the former is only CPA-secure (so it is difficult to simulate the validation oracle in the security reduction) while the latter (or any CCA-secure scheme in general) is not homomorphic.
Interestingly, with such an instantiation, an enrollment record is an encryption of H S (un, n S ) k S · H C (un, pw, n C ) k C , from which we can draw connection to Pythia [9], in which the record is computedSetup(1 λ ) crs ←$ Π.Gen(1 λ ), g ←$ G return (crs, g) KGen C (pp) pk C ← ⊥, sk C ← k C ←$ Zq return (pk C , sk C ) KGen S (pp) s, x, y, k S ←$ Zq h ← g s z ← g x h y pk S ← (h, z) sk S ← (s, x, y, k S )return (pk S , sk S ) Figure 7: Setup Phase of Phoenix as e(H S (un), H C (pw)) k S .
The pairing function e(·, ·) is used in Pythia mainly for partial blinding by the client, i.e., blinding pw but not un.
In our construction, the server only evaluates the PRF on the username un but not the password pw, which perhaps explains why we do not need pairing.
Let G be a (multiplicative) finite cyclic group of order q = q(λ).
Let H i∈{C,S} : {0, 1} λ × {0, 1} * → G be hash functions to be modeled as random oracles.
Let Π be a standard non-interactive zero-knowledge proof of knowledge system for length-2 discrete logarithm representation (instantiated in Figure 11).
We construct our cryptographic password hardening service, Phoenix, as follows.Setup Phase.
Figure 7 shows the setup algorithm as well as the key generation algorithms.
The setup algorithm samples a common reference string crs of the proof system Π and a random generator g of the group G, and outputs them as the public parameter pp.
The client secret key is a random integer k C .
The server secret key consists of random integers s, x, y, k S , while the corresponding public key consists of h = g s and z = g x h y .
Enrollment Phase.
Figure 8 shows the enrollment protocol.
The input auxiliary information aux is either an empty string denoted by , or a tuple (n S , n C ) of server and client nonces which is purely for proving forward security.
In the former usual case, the server and the client sample their nonces n S and n C respectively independently and randomly.
Next, the server sends the server PRF value h S = H S (un, n S ) k S and the server nonce n S to the client, who computes the client PRF value h C = H C (un, n S ) k C locally, and encrypts the value h S · h C using an ElGamal-like encryption scheme as (g r , h r · h S · h C , z r ).
The element z r serves as an in-tegrity tag which is important for proving the hiding property.
The client then store the ciphertext and the nonces as the enrollment record.Validation Phase.
Figure 9 shows the validation protocol.
The client wishes to validate whether T is a valid enrollment record of the given candidate username un and password pw.
Recall that an enrollment record is of the form T = (g r , h r · h S · h C , z r , n S , n C ).
To prepare for a validation request, the client divides the element h r · h S · h C by the candidate PRF value H C (un, n S ) k C , and rerandomizes the ciphertext components.
It then sends the rerandomized ciphertext and the server nonce to the server.
The latter checks if the ciphertext is indeed a valid encryption of h S = H S (un, n S ) k S and, if so, returns a proof of knowledge of this fact.
If the proof passes verification, then the client is convinced that the candidate username and password satisfy h S = H S (un, n S ) k S and h C = H C (un, n S ) k C , and concludes that the enrollment record T is valid.Key Rotation Phase.
Figure 10 shows the key rotation protocol and the update algorithm.
In a nutshell, the protocol and the algorithm work together to perturb the secret keys and the enrollment records randomly yet consistently through homomorphisms.
To be concrete, in the key rotation protocol, the server samples random integers α, β, γ, δ and η, such that the secret key components of the client and the server are computed as (s , x , y , k S , k C ) = (αs + β, αx + δ, y + η, αs + γ, αs).
The client then updates each of the stored enrollment records T as follows.
Recall that an enrollment record T = (T 1 , T 2 , T 3 , n S , n C ) is of the form (T 1 , T 2 , T 3 ) = (g r , g sr g k S S g k C C , g (x+sy)r) .
Denote r := r + v. For consistency, T 2 is updated asT 2 = (T 2 · h v ) α · (T 1 · g v ) β · g γ S = g αs(r+v) g αk S S g αk C C · g β(r+v) · g γ S = g (αs+β)(r+v) g αk S +γ S g αk C C = g s r g k S S g k C C. To update T 3 , the client obtains from the server the value ζ = δ + α · η · s + β · (y + η), and computesT 3 = (T 3 · z v ) α · (T 1 · g v ) ζ = g α(x+sy)(r+v) · g (δ+α·η·s+β·(y+η))(r+v) = g ((αx+δ)+(αs+β)(y+η))(r+v) = g (x +s y )r .
The client runs the update algorithm on all of its stored enrollment records.Correctness.
The correctness of Phoenix follows immediately from the completeness of Π.
We give intuitions behind why Phoenix is partially oblivious, hiding, binding, and forward secure in the random oracle model, assuming the DDH assumption holds in G.
We refer the curious readers to Appendix C for the formal security analysis.Partial Obliviousness.
Partial obliviousness means that a compromised server cannot distinguish which password among pw * 0 and pw * 1 was used to generate an enrollment record for some known username un * .
To show why this requirement is satisfied, recall that in the challenge enrollment recordT * = (T * 1 , T * 2 , T * 3 , n * S , n * C ), the only compo- nent which is dependent on the password pw * b is T * 2 , which is of the form T * 2 = h r h S H C (un * , pw * b , n * C ) k C .
Since H C is modeled as a random oracle, bothH C (un * , pw * 0 , n * C ) and H C (un * , pw * 1 , n * C )can be programmed to random values independent of the passwords, which perfectly hide the bit b from the server.
One subtlety here is the consistency of the simulation of the random oracle, which can be ensured as long as no oracles are queried on inputs containing the random nonce n * C before T * is generated.
Fortunately, the latter happens with overwhelming probability as n * C is randomly picked by the challenger during the generation of T * .
Hiding.
The hiding property, which defends against dictionary attacks by a compromised client, is the most difficult property to prove.
Our proof is inspired by the techniques used to prove the security of password-authenticated key exchange (PAKE) protocols.
The main idea is to gradually and unnoticeably replace the challenge enrollment record with a truly random one, such that it hides the password perfectly.
During the course, we argue that the only ways for the adversary to notice the changes are either solving the DDH problem or guessing the correct password in a query to the validation oracle.
Since DDH is assumed to be hard, we conclude that the adversary cannot perform better than guessing.Binding.
The binding property requires that a malicious cannot convince the client that an enrollment record T * is valid for two distinct usernamepassword tuples (un * 0 , pw * 0 ) and (un * 1 , pw * 1 ).
This property follows straightforwardly from the DL assumption, which states that finding the discrete logarithm of g 2 base g 1 is hard for random Client C(sk C , un, pw, aux) Server S(sk S , un, aux)parse pk S as (h = g s , z = g x h y ), sk C as k C parse sk S as (s, x, y, k S )if aux = then parse aux as (n S , n C ) if aux = then parse aux as (n S , n C ) To see why, note that if the enrollment recordelse n C ← {0, 1} λ else n S ← {0, 1} λ r ←$ Zq, h C ← H C (un, pw, n C ) k C h S , n S h S ← H S (un, n S ) k S return T ← (g r , h r · h S · h C , z r , n S , n C ) Figure 8: Enrollment Protocol of Phoenix Validation Protocol Client C(sk C , T, un, pw) Server S(sk S , un) parse pk S as (h, z), sk C as k C parse sk S as (s, x, y, k S ) parse T as (T 1 , T 2 , T 3 , n S , n C ) u ←$ Zq, b ← 0 c 1 c 2 c 3 ←   T 1 · g u T 2 · h u /H C (un, pw, n C ) k C T 3 · z u   (c 1 , c 2 , c 3 , n S ) if c 2 c 3 = c s 1 · H S (un, n S ) k S c x 1 (c 2 /H S (un, n S ) k S ) y then b ← Π.Vf((g, h, c 1 , c 2 , H S (un, n S )), π) π π ←$ Π.PoK{(s, k S ) : c 2 = c s 1 · H S (un, n S ) k S ∧ h = g s } return b endifT * = (T * 1 , T * 2 , T * 3 , n * S , n * C ) stores both tuples (un * b , pw * b ), b ∈ {0, 1}, then T * 2 is of the form T * 2 = h r H S (un * b , n * S ) k S H C (un * b , pw * b , n * C ) k C .
Then it must be the case that H S (un * 0 , n * S ) k S H C (un * 0 , pw * 0 , n * C ) k C = H S (un * 1 , n * S ) k S H C (un * 1 , pw * 1 , n * C ) k C .
To exploit this collision, the challenger simulates H S and H C such that their inputs are mapped to g a 1 and g b 2 respectively for random exponents a and b. Doing so allows it to extract the discrete logarithm from the ratio of the exponents associated with H S and H C in the expression respectively.Forward Security.
Phoenix achieves L-forward security with a mild leakage defined by the leakage function L which, on input T = (T 1 , T 2 , T 3 , n S , n C ), merely outputs the nonces (n S , n C ).
This can be proved by an information-theoretic argument that, all possible combinations of client and server secret keys obtainable from fresh key generation can also be obtained by key rotation.
Then, no matter how the new secret keys are generated, the enrollment record T can be updated to be consistent with the new keys, and is indistinguishable to a fresh enrollment record generated using the same nonces.
We implemented a prototype using Python3, Falcon as web framework, and Charm for the cryptographic computations.
We used NIST P-256 for all TLS public key operations and as the base group for Phoenix.
Information was passed to Phoenix via HTTP GET parameters and returned as a text/json response (with group elements encoded in base64): therefore, an enrollment interaction would go as follows.
The client sends an http request to /enroll?tweak=john and would get back a response in the following form: {hs="rPHu...LcQ==",ns="4qKM...uWQ="} We then measured the performance of Phoenix in comparison with Pythia and the scheme by Schneider et al. [21] on Amazon EC2 using t2.micro instances with the server running in Frankfurt and clients both on a separate t2.micro instance in Frankfurt and Ireland.
At the time of writing, t2.micro instances were equipped with 1 GB of RAM and one core Intel XEON E5-2676.
Client C(sk C ) Server S(sk S )parse pk S as (h, z) parse sk S as (s, x, y, k S )parse sk C as k C α, β, γ, δ, η ←$ Zq ζ := δ + α · η · s + β · (y + η) k C ← α · k C α, β, γ, ζ k 1 ← α · k S + γ, s ← α · s + β pk C ← ⊥ x ← α · x + δ, y ← y + η sk C ← k C pk S ← (h α · g β , z α · g ζ ) τ ← (α, β, γ, ζ) sk S ← (s , x , y , k S ) return (pk C , sk C , τ ) return (pk S , sk S )Udt(τ, T, un)/ / Use the old server public key.parse pk S as (h, z)parse τ as (α, β, γ, ζ) We used the Nginx web server configured with ECDHE-ECDSA-AES128-GCM-SHA256 for TLS and uWSGI for the Python applications.parse T as (T 1 , T 2 , T 3 , n S , n C ) g S ← H S (un, n S ) v ←$ Zq T 1 ← T 1 · g v T 2 ← (T 2 · h v ) α · (T 1 · g v ) β · g γ S T 3 ← (T 3 · z v ) α · (T 1 · g v ) ζ return T ← (T 1 , T 2 , T 3 , n S , n C )Latency.
For the latency measurements, a full interaction was executed between the cryptographic service and the consuming web service.
The numbers take both server and client-side processing into account.
As the client-side computations for Phoenix are significant compared to the server-side computations, the total latency is significantly larger than the pure latency of the HTTP(S) requests.
The latency measurements try to answer the question "How long does the user have to wait for the website to check the password?"
.
The presented numbers are an average over 5, 000 executions of the respective protocol.
We measured HTTP and HTTPS setups as well as HTTPS with keep-alive which removes all costs for TCP and TLS handshakes and is therefore close to the inherent latency of the cryptographic scheme.As shown in Table 1, even in a single datacenter setup, the full TLS handshake takes approximately as much time as the computations of Phoenix: Reusing a keep-alive connection it takes approximately half the time compared to a fresh HTTPS connection in the same datacenter setting.
If the crypto service is hosted by a different datacenter from the web application, network round-trip time quickly dominates the overall execution time of Phoenix: There is only one round-trip inherently needed for either Phoenix protocol execution and the difference between the one-datacenter and same-continent setting is almost exactly this one round-trip using keep-alive.
In a real world setup for a large website, we expect the web service to keep a connection to the cryptographic service open at any time and the HTTPS with keep-alive measurements is realistic.Throughput.
For throughput measurements, we used the Apache benchmark tool with 10, 000 iterations and 400 parallel requests.
uWSGI and Nginx were both configured to run with two processes to keep OS overhead on the single core server low.As shown in Table 2, Phoenix can process approximately 50 % more requests than the scheme by Schneider et al. and [23] suggest choosing a work factor of up to one second.
Apple uses 10, 000 iterations of PBKDF2 for iTunes [12], which takes around 278.80 ms on our Amazon instance.
Both computation cost and latency of Phoenix are considerably below this mark which suggests Phoenix is highly practical and can even be combined with traditional password hardening in a hybrid approach.
We revisit the existing security notions of cryptographic password hardening service and found that some important properties were overlooked or not well defined.
While Pythia [9] and the subsequent work by Schneider et al. [21] highlight the importance of key rotation, none of their security notions take this feature into account.
Furthermore, we argue that the security definitions of Schnei- der et al. [21] are weak.
We give a stronger definition and show that the scheme of Schneider et al. is insecure under our security definition.
The attack is simple yet of high practical relevance since it allows an offline password dictionary attack, which is supposedly avoided by the password hardening service.We propose the Phoenix password hardening service which greatly improves efficiency while satisfies all desirable security properties.
Specifically, it is more efficient than the insecure protocol of Schneider et al. and the seminal Pythia PRF service.
With its efficiency and simplicity, Phoenix is the first readily deployable password hardening service.
Many primitives are related to partially-oblivious pseudorandom functions [9], such as delegatable PRFs [14] and fully oblivious PRFs [18,11].
They do not allow partial obliviousness [9].
One-more unpredictability formalized for partially oblivious PRFs [9] draws some similarities to onemore unforgeability of blind signature schemes [13,19,10,22].
This similarity inspires the subsequent analysis [21] that the "one-more" type assumptions are needed for proving the security of Pythia [9].
One should not confuse the resistance against offline dictionary attack with a similar property achieved by threshold password-authenticated keyexchange (t-PAKE) [15].
We only consider protocols between two parties, namely, a client and the server.
On the other hand, to authenticate using t-PAKE, a client has to interact with a threshold number of available servers.
There are other schemes [15,1,7] which support blinding, but they fail to achieve partial blinding (and hence rate-limiting).
One may also consider our primitive to be similar to other proof-of-knowledge protocols such as PSignatures [2] since both share a mechanism to verify if two commitments are committing to the same value.
However, they are different in general.
In particular, ours does not involve any signature.
Non-Interactive Zero-Knowledge Proof of Knowledge (NIZKPoK).
Π = (Gen, Prove, Vf) is an adaptive non-interactive zero-knowledge (NIZK) proof system for a language L ∈ NP with the witness relation R if it satisfies the following properties:Completeness: For all x, w such that R(x, w) = 1, and common reference strings crs ∈ Gen(1 λ ), we have Vf(crs, x, Prove(crs, x, w)) = 1.
Soundness: For all adversaries A,Pr[x / ∈ L ∧ Vf(crs, x, π) → 1 : crs ←$ Gen(1 λ ); (x, π) ←$ A(crs)] = (λ).
Zero-Knowledge: There exists PPT simulator S = (S crs , S Prove ) such that, for all PPT adversaries A,| Pr[A Prove(crs,·,·) (crs) → 1 : crs ← Gen(1 λ )]− Pr[A S (crs,td,·,·) (crs) → 1 : (crs, td) ← S crs (1 λ )]| = (λ)where S (crs, td, x, w) = S Prove (crs, td, x).
Furthermore, Π is a proof of knowledge (PoK) system if, for all PPT provers P * , there exists a PPT algorithm E P * such that| Pr[Vf(crs, x, π) = 1 ∧ (x, w) / ∈ R : crs ← Gen(1 λ ); (x, π) ← P * (crs), w ← E P * (crs, x, π)]| = (λ)For ease of reading, we denote by PoK{w : R(x, w) = 1} the execution of Prove(crs, x, w).
Discrete Logarithm (DL) Assumption.
Let G be a finite cyclic group of order q = q(λ).
Let g be a generator of G, and h be a group element.
The discrete logarithm problem asks to find an integer x ∈ Z q such that h = g x .
The discrete logarithm assumption states that, for any PPT algorithm A, the probability of A solving a random instance of the discrete logarithm problem is negligible.Decisional Diffie-Hellman (DDH) Assumption.
Let G be a finite cyclic group of order q = q(λ).
Let g be a generator of G, and a, b, c ∈ Z q .
The decisional Diffie-Hellman problem asks to distinguish the tuple (g, g a , g b , g a·b ) from (g, g a , g b , g c ).
The decisional Diffie-Hellman assumption states that, for any PPT algorithm A, the probability of A solving a random instance of the decisional DiffieHellman problem is negligible.
We will show that Phoenix is partially oblivious, hiding, binding, and forward secure, relying mainly on the DDH assumption.Note that the instantiation of Π in Figure 11 is a well-known extension of the Schnorr proofs [5], which is complete, sound, and zero-knowledge, assuming the DL assumption holds in G (implied by the DDH assumption) and the two hash functions are modeled as random oracles.
Thus, in the following, we will assume Π is sound and zero-knowledge.
For conciseness, consider an extended DDH problem, which asks to distinguish whetherc i ←$ Z q for i ∈ [t] or c i = a · b i for i ∈ [t], when given a tuple (g, g a , g b i , g c i ) t i=1for some t = poly (λ).
By standard hybrid argument, it can be shown that if DDH is hard in G, then so does the extended DDH.
H ←$ H = {H : {0, 1} * → Zq} return crs := H Π.Vf((g, h, c 1 , c 2 , g S ), π) parse π as ( ¯ h, ¯ c 1 , ¯ g S , ¯ s, ¯ k S ) c := H(g, h, c 1 , c 2 , g S , ¯ h, ¯ c 1 , ¯ g S ) b 1 := (c ¯ s 1 g ¯ k S S = ¯ c 1 · ¯ g S · c c 2 ) b 2 := (g ¯ s = ¯ h · h c ) return b := (b 1 ∧ b 2 ) Π.PoK{(s, k S ) : c 2 = c s 1 · g k S S ∧ h = g s } r 1 , r 2 ←$ Zq ¯ h := g r1 ¯ c 1 := c r1 1 ¯ g S := g r2 S c := H(g, h, c 1 , c 2 , g S , ¯ h, ¯ c 1 , ¯ g S ) ¯ s := r 1 + c · s ¯ k S := r 2 + c · k S return π := ( ¯ h, ¯ c 1 , ¯ g S , ¯ s, ¯ k S )Figure 11: Instantiation of Π sequence of hybrid experiments for b ∈ {0, 1}, each differs slightly from the previous:EXP b,0 : is identical to Obl b Π,A .
EXP b,1 :The challenger simulates the random oracle H C as follows.
On query H C (un, pw, n C ), it samples a ←$ Z q and returns g a .
This experiment is functionally equivalent to Exp b,0 .
EXP b,2 :When executing C(sk C , un * , pw * b , ), A 2 (st) enrl , since aux = , the challenger picks the client nonce n * C randomly and programs the random oracleH C on (un * , pw * b , n * C ) and (un * , pw * 1−b , n * C ).
If any oracle (including the random oracle) is queried on input containing n * C before, the challenger aborts.
This happens with probability O(2 −λ ) for each oracle query.
Thus, this experiment is computationally indistinguishable to Exp b,1 .
EXP b,3 :The challenger is given an extended DHtuple (g, g k C , g γ , g θ , g δ , g ξ ) with δ = k C γ and ξ = k C θ.
Since the challenger does not know k C , it computes the pseudorandom values H C (un, pw, n C ) k C differently.
Let a be such that H C (un, pw, n C ) is programmed to g a .
The challenger computes Proof: The idea of the proof is to gradually switch the challenge enrollment record to an entirely random one using hybrid argument.
After arriving at that hybrid experiment, the information that can be obtained by the adversary from the oracles can also be obtained by guessing the password.
Thus, no adversary can perform better than the one which performs an online dictionary attack.
We prove formally by defining a sequence of hybrid experiments, each differs slightly from the previous:H C (un, pw, n C ) k C as (g k C ) a .
Since no or- acle is queried on input containing n * C before the challenge is requested, H C (un * , pw * b , n * C ) is not yet programmed.
Upon receiving the chal- lenge request (un * , pw * 0 , pw * 1 ) from A, it programs H C (un * , pw * b , n * C ) := g γ and H C (un * , pw * b , n * C ) k C := g δ .
Additionally, it programs H C (un * , pw * 1−b , n * C ) := g θ and H C (un * , pw * 1−b , n * C ) k C := g ξ .
EXP 0 : is identical to Hiding Π,A .
EXP 1 : The proofs are now simulated using the simulator S of the proof system Π.
This experiment is computationally indistinguishable from EXP 0 by the computational zero-knowledge property of Π.EXP 2 :The challenger simulates the random oracle H S as follows.
When A queries H S (un, n S ), it samples γ ←$ Z q and programs H S (un, n S ) := g γ .
It further computes H S (un, n S ) k S = (g k S ) γ .
Notice that the knowledge of k S is no longer required by the challenger.
Furthermore, when executing C(sk C , un * , pw * , ), S(sk S , un * , ) enrl , since aux = , the challenger picks fresh client and server nonces n * C and n * S respectively randomly and programs the random oracle H S on (un * , n * S ).
If any oracle (including the random oracle) is queried on input containing n * S before, the challenger aborts.
This happens with probability O(2 −λ ) for each oracle query.
Thus, this experiment is computationally indistinguishable to Exp 1 .
unless it is successful in one of the Q queries to the validation oracle on un * .
Among all successful adversaries, A cannot do better than guessing pw * and hence (c * 1 , c * 2 , c * 3 ) correctly, and re-randomizes the latter.
Note that the probability of guessing the correct pw * is upper-bounded by Q+1 i=1 p i .
To conclude, the probability that A wins in EXP 0 , that is Hiding Π,A , is upper-bounded by Q+1 i=1 p i + (λ).
Suppose that the DL assumption holds in G, and H S and H C are modeled as random oracles, then Phoenix is binding.Proof: Our idea is to program the random oracles so that they map inputs to random group elements, with their discrete logarithms known to the simulator.
Thus, if the adversary outputs two valid tuples for the same enrollment record, the simulator can solve a system of linear equations of the exponents.
It is then able to recover the discrete logarithm of a group element which is used as a generator for simulating the random oracles.
Formally, we prove by reduction.
Suppose a PPT adversary A breaks binding with non-negligible probability, we construct a PPT solver B of the discrete logarithm problem.
Let B be a simulator which receives a discrete logarithm problem instance (g 1 , g 2 ).
It generates crs honestly and sends pp := (crs, g 1 ) to A. B maintains dictionaries D 1 and D 2 mapping (un, n S ) and (un, pw, n C ) respectively to random exponents.
When A queries the random oracle H S on (un, n S ), it checks whether H S (un, n S ) is programmed.
If so, it retrieves and returns H S (un, n S ).
Otherwise, it samples a random exponent a ← Z q , records D 1 [un, n S ] := a, and programs H S (un, n S ) := g a 1 .
B simulates H C similarly.
When A queries the random oracle H C on (un, pw, n C ), it checks whether H C (un, pw, n C ) is programmed.
If so, it retrieves and returns H C (un, pw, n C ).
Otherwise, it samples a random exponent b ← Z q , records D 2 [un, pw, n C ] := b, and programs H C (un, pw, n C ) := g b 2 .
Assuming A is successful, it outputs (sk C , T * , un * 0 , pw * 0 , state) such that C(sk C , T * , un * 0 , pw * 0 ), A 2 (state) val outputs 1 at the client side.
Parse sk C = k C , and T * = (T * 1 , T * 2 , T * 3 , n * S , n * C ).
Let a 0 and b 0 be such that H S (un * 0 , n * S ) = g a 0 1andH C (un * 0 , pw * 0 , n * C ) = g b 0 2.
This means that A is able to produce a proof π 0 of the knowledge of (s, k S,0 ) such thatT * 2 = (T * 1 ) s · H S (un * 0 , n * S ) k S,0 · H C (un * 0 , pw * 0 , n * C ) k C = (T * 1 ) s · g a 0 ·k S,0 1 · g b 0 ·k C 2and h = g s 1 .
Using the extractor of Π, B extracts (s, k S,0 ).
Next, A outputs (un * 1 , pw * 1 , state) such that C(sk C , T * , un * 1 , pw * 1 ), A(state) val outputs 1 at the client side.
Let a 1 and b 1 be such that H S (un * 1 , n * S ) = g a 1 and H C (un * 1 , pw * 1 , n * C ) = h b 1 .
This means that A is able to produce a proof π 1 of the knowledge of (s, k S,1 ) such that and solves the discrete logarithm problem with overwhelming probability.T * 2 = (T * 1 ) s · H S (un * 1 , n * S ) k S,1 · H C (un * 1 , pw * 1 , n * C ) k C = (T * 1 ) s · gaTheorem C.4 (Forward Security) Let L be a leakage function such that L(T ) := (n S , n C ) for T = (T 1 , T 2 , T 3 , n S , n C ).
Phoenix is L-forward secure.Proof: We prove by showing that each pair of client and server secret keys output by the key generation algorithms can also be obtained via rotation from any old pair of secret keys, and vice versa.Consider the Rot b Π,A,L experiment.
Let (s, x, y, k S , k C ) ∈ Z 5 q be the client and server secret key components chosen by A.
There is a one-to-one correspondence between each (s , x , y , k S , k C ) ∈ Z 5 q and each (α, β, γ, δ, η) ∈ Z 5 q , given equivalently by               s = α · s + β x = α · x + δ y = y + η k S = α · k S + γ k C = α · k C and                α = k C /k C β = s − α · s γ = k S − α · k S δ = x − α · x η = y − y .
Thus, the distribution of (s , x , y , k S , k C ) which is sampled uniformly from Z 5 q and that which is computed from a uniformly random tuple (α, β, γ, δ, η) are identical.Next, let T = (T 1 , T 2 , T 3 ) given by A be of the form (g r , g sr g k S S g k C C , g (x+sy)r ).
The new record T is of the form T = (g r , g s r g k S S g k C C , g (x +s y )r ), where if b = 0 then r = r + v for a uniformly random v ←$ Z q , and if b = 1 then r ←$ Z q is sampled uniformly at random.
The two cases give identical distributions.
This research is based upon work supported by the German research foundation (DFG) through the collaborative research center 1223, by the German Federal Ministry of Education and Research (BMBF) through the project PROMISE, and by the state of Bavaria at the Nuremberg Campus of Technology (NCT).
NCT is a research cooperation between the Friedrich-Alexander-Universität Erlangen-Nürnberg (FAU) and the Technische Hochschule Nürnberg Georg Simon Ohm (THN).
Sherman Chow is supported by the Early Career Award and General Research Funds (CUHK 14201914) of the Research Grants Council of Hong Kong.
We thank Andrei Sabelfeld and the reviewers for for valuable comments that helped to improve our paper.
