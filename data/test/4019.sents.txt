Android kernel vulnerabilities pose a serious threat to user security and privacy.
They allow attackers to take full control over victim devices, install malicious and un-wanted apps, and maintain persistent control.
Unfortunately , most Android devices are never timely updated to protect their users from kernel exploits.
Recent An-droid malware even has built-in kernel exploits to take advantage of this large window of vulnerability.
An effective solution to this problem must be adaptable to lots of (out-of-date) devices, quickly deployable, and secure from misuse.
However, the fragmented Android ecosystem makes this a complex and challenging task.
To address that, we systematically studied 1, 139 An-droid kernels and all the recent critical Android kernel vulnerabilities.
We accordingly propose KARMA, an adaptive live patching system for Android kernels.
KARMA features a multi-level adaptive patching model to protect kernel vulnerabilities from exploits.
Specifically , patches in KARMA can be placed at multiple levels in the kernel to filter malicious inputs, and they can be automatically adapted to thousands of Android devices.
In addition, KARMA's patches are written in a high-level memory-safe language, making them secure and easy to vet, and their run-time behaviors are strictly confined to prevent them from being misused.
Our evaluation demonstrates that KARMA can protect most critical kernel vulnerabilities on many Android devices (520 devices in our evaluation) with only minor performance overhead (< 1%).
Android is a popular mobile operating system based on the Linux kernel.
The kernel, due to its high privilege, is critical to the security of the whole Android system [4].
For example, Android relies on the Linux kernel to enforce proper isolation between apps and to protect important system services (e.g., the location manager) from unauthorized access.
Once the kernel is compromised, none of the apps in the system can be trusted.
Many apps contain sensitive personal data, such as bank accounts, mobile payments, private messages, and social network data.
Even TrustZone, widely used as the secure keystore and digital rights management in Android, is under serious threat since the compromised kernel enables the attacker to inject malicious payloads into TrustZone [42,43].
Therefore, Android kernel vulnerabilities pose a serious threat to user privacy and security.Tremendous efforts have been put into finding (and exploiting) Android kernel vulnerabilities by both whitehat and black-hat researchers, as evidenced by the significant increase of kernel vulnerabilities disclosed in Android Security Bulletin [3] in recent years.
In addition, many kernel vulnerabilities/exploits are publicly available but never reported to Google or the vendors, let alone patched (e.g., exploits in Android rooting apps [47]).
The supply of Android kernel exploits likely will continue growing.
Unfortunately, officially patching an Android device is a long process involving multiple parties with disparate interests: Google/the vendor verifies a reported vulnerability and creates a patch for it.The patch is then thoroughly tested and released to carriers; carriers test the update again for compatibility with their networks and release it to their users as an overthe-air (OTA) update.
Many updates may queue up at the carriers waiting to be tested [33]; finally, the user may or may not install the update promptly.
Arguably, device vendors and carriers have little incentive to keep user devices updated and secure.
They instead prefer users to buy new devices.
For example, phone vendors usually move to new products and stop updating older devices within one year.
Consequently, many Android phones become obsolete shortly after they get into the customers' hands.
There also exist lots of small vendors that do not have necessary resources to keep their phones updated.
This dire situation is faithfully reflected in the vulnerable phones in use.
Table 1 lists the statistics of two infamous kernel vulnerabilities: CVE-2015-3636 ("PingPong Root") [16] and CVE-2015-1805 [15] (data collected from 30 million devices 1 ).
After months Table 1: Devices vulnerable to two infamous root exploits as of Nov. 2016.
The second column lists the dates when they are disclosed in Android Security Advisory.since their public disclosure, there are still a significant portion of devices vulnerable to them.
Hence, it is unsurprising that Android malware with years-old root exploits can still compromise many victim devices worldwide [5,17,18,21].
In light of these serious threats, there is an urgent need for third-parties to promptly provide patches for these out-of-date devices, without involving vendors or carriers.
Android's fragmented ecosystem poses a significant challenge to a third-party kernel patching system: there are thousands of Android vendors that have produced and keep producing tens of thousands of devices [1], and Google releases new versions of Android at a regular base.
This combination creates a mess of Android devices with all kinds of hardware and software configurations.
For example, Android Lollipop (Android 5.0) was released in November 2014; as of September 2016, 46.3% of Android devices still run an older version of Android with little hope of any future updates [2].
Even worse, many Android vendors, small and large ones alike [19], indefinitely "delay" releasing the kernel source code despite the fact that the kernel's license (GPL) demands it.
As such, existing source-code based patching systems [22,23,25,27] can only cover a limited number of devices; a binary-based approach would work better for a third-party solution.
However, kernel binaries in these devices could differ significantly in details.
For example, they may use different build systems, different versions of the compiler, and different optimization levels.
An effective solution must accommodate thousands of similar yet very different kernels, a challenging goal.To achieve our goal, we first quantified the Android fragmentation by systematically studying and measuring 1, 139 Android kernel binaries.
We formulated three key observations that allowed us to effectively tackle this problem.
We also analyzed all the recent critical Android kernel vulnerabilities.
Armed with these insights, we propose KARMA, a multi-level adaptive patching model that can overcome the Android fragmentation issue.
KARMA stands for Kernel Adaptive Repair for Many Androids 2 .
It protects kernel vulnerabilities by filtering malicious inputs to prevent them from reaching the vulnerable code.
KARMA's patches are written in vulnerability's disclosure date to decide if it is potentially vulnerable.
2 KARMA is a part of the OASES (Open Adaptive Security Extensions, https://oases.io) project, an initiative founded by Baidu to enable fast and scalable live patching for mobile and IoT devices.
a high-level memory-safe language.
To prevent patches from being misused, KARMA strictly confines their runtime behaviors so that the kernel remains as stable and consistent as possible under attack.
Adaptiveness is a key distinguishing feature of KARMA from other live patching systems.
It allows KARMA to scale to many Android devices.
Specifically, given a reference patch and a target kernel, KARMA automatically identifies whether the target kernel contains the same vulnerability and customizes the reference patch for the target kernel if so.
Therefore, KARMA's patches are easy to vet, secure, and adaptive.
Like other kernel patching systems, KARMA requires privileged access to the devices it protects.
It can either be pre-installed in the device's firmware or installed afterwards [7].
The implementation of KARMA supports all major Android platforms, and we are currently working with various Android vendors to pre-install KARMA in their future devices.
The main contributions of our paper are four-fold:• We analyzed the fragmentation issue that hinders existing kernel live patching solutions to be ubiquitously applied on Android devices, and brought the need of an adaptive Android kernel patching solution to light.
• We studied 1, 139 Android kernels from popular devices and 76 critical Android kernel vulnerabilities in the last three years.
Based on these insights, we propose KARMA, a multi-level adaptive patching model that can be applied to the fragmented Android ecosystem.
• We implemented KARMA with the framework and primitives enabling memory-safe adaptive live patching.
The implementation can support all the current Android kernel versions (from 2.6.x to 3.18.x) and different OEM vendors.
• We comprehensively evaluated KARMA against all the recently reported critical kernel vulnerabilities.
Our evaluation shows that KARMA can both adaptively and effectively handle the majority of these vulnerabilities with negligible overhead (< 1%).
The rest of the paper is organized as follows.
We first state the problem and present the design of KARMA in Section 2.
We then evaluate the applicability, adaptability, and performance overhead of KARMA in Section 3.
Section 4 discusses the potential improvements to KARMA, and Section 5 compares KARMA to the closely related work.
We conclude the paper in Section 6.
In this section, we first present our key observations on the Android fragmentation problem and then describe the design of KARMA in detail.
Designing a live kernel patching system that can scale to lots of devices is a challenging task.
However, three key observations we gained from systematically measuring the Android fragmentation render this task feasible and manageable.
These observations can serve as a foundation for future systems tackling this problem.Observation A: most kernel functions are stable across devices and Android releases.Android (Linux) kernel is a piece of large and mature software.
Like other large software, evolution is more common and preferred than revolution -bugs are fixed and new features are gradually added.
Complete rewrite of a core kernel component is few and far between.
A patch for one kernel thus can probably be adapted to many other kernels.
Adaptiveness is a key requirement for protecting the fragmented Android ecosystem.To measure the stableness of Android kernels, we collected 1, 139 system images from four major vendors (Samsung/Huawei/LG/Oppo, 1, 124 images) and Google (15 images).
These four vendors together command more than 40% of the Android smartphone market, and Google devices have the newest Android software.
This data set is representative of the current Android market: these images come from 520 popular old and new devices, feature Android versions from 4.2 to 7.0, and cover kernels from 2.6.x to 3.18.x.
The statistics of these images are shown in Table 2 and 3.
After collecting these images, we extracted symbols from their kernels.
There are about 213K unique functions, and about 130K of them are shared by more than 10 kernels.
We wrote a simple tool to roughly analyze how many different revisions each of these shared functions has.
Specifically, we abstract the syntax of each function by the number of its arguments, the conditional branches it contains, the functions called by it, and nonstack memory writes.
We then cluster each function across all the images based on these syntactic features.
Each different cluster can be roughly considered as a revision of the function (i.e., each cluster potentially requires a different revision of the patch).
The results are shown in Fig. 1 and 2.
Specifically, Fig. 1 shows how many clusters each shared function has.
About 40% of the shared functions have only one cluster, and about 80% of them have 4 clusters or less.
Fig. 2 shows the percentage of the kernels in the largest cluster for each shared function.
For about 60% of shared functions, the largest cluster contains more than 80% of all the kernels that have this function.
These data show that most kernel functions are indeed stable across different devices.
Vulnerabilities in shared functions should be given a higher priority for patching because they affect more devices.Observation B: many kernel vulnerabilities are triggered by malicious inputs.
They can be protected by filtering these inputs.Kernel vulnerabilities, especially exploitable ones, are often triggered by malicious inputs through syscalls or external inputs (e.g., network packets).
For example, CVE-2016-0802, a buffer overflow in the Broadcom WiFi driver, can be triggered by a crafted packet whose size field is larger than the actual packet size.
Such vulnerabilities can be protected by placing a filter on the inputs (i.e., function arguments and external data received from functions like copy_from_user) to screen malicious inputs.
We surveyed all the critical kernel vulnerabilities in the Android Security Bulletin reported in 2015 and 2016 and found that 71 out of 76 (93.4%) of them could be patched using this method (Table 6).
Observation C: many kernel functions return error codes that are handled by their callers.
We can leverage the error handling code to gracefully discard malicious inputs.When a malicious input is blocked, we need to alter the kernel's execution so that the kernel remains as consistent and stable as possible.
We observe that many kernel functions return error codes that are handled by their callers.
In such functions, a patch can simply end the execution of the current function and return an error code when a malicious input is detected.
The caller will handle the error code accordingly [34].
Linux kernel's coding style recommends that functions, especially exported ones, returning an error code to indicate whether an operation has succeeded or not [24].
If the function does not normally return error codes, it should indicate errors by returning out-of-range results.
A notable exception is functions without return values.
Most (exported) kernel functions follow the official coding style and return error codes -even kernel functions that return pointers often return out-of-range "error codes" using the ERR_PTR macro.Based on these observations, our approach is as follows: for each applicable vulnerability, we create a patch that can be placed on the vulnerable function to filter malicious inputs.
The patch returns a selected error code when it detects an attack attempt.
The error is handled by the existing error handling code, keeping the kernel stable.
This patch is then automatically adapted to other devices.
Automatic adaptation of patches can significantly reduce the manual efforts and speed up the patch deployment.
KARMA features a secure and adaptive multi-level patching model.
The security is enforced by the following two technical constraints:Rule I, a patch can only be placed at designated locations, and its patched function must be able to return error codes or return void (i.e., no return value).
KARMA protects kernel vulnerabilities by preventing malicious inputs from reaching them.
For security reasons, a patch can only be placed at the designated levels.
Specifically, level 1 is the entry or return points of a vulnerable function; level 2 is before or after call instructions to a callee of the vulnerable function.
Note that we do not patch the callee itself but rather hook call instructions in order to avoid affecting other callers of this callee.
A typical example of callees hooked by KARMA is copy_from_user, a function dedicated to copy untrusted user data into the kernel.
copy_from_user is a perfect checkpoint for malicious inputs because the kernel calls it whenever the kernel needs to read the user data; Level 3 is similar to the existing binary-based patches [22,23,27].
Level-3 patches are more flexible but potentially dangerous because they are (currently) unconstrained.
If a vulnerability is difficult to patch at level 1 and level 2, we fall back to level 3.
Level-3 patches have to be manually scrutinized to prevent them from being misused.
Our experiment with 76 critical kernel vulnerabilities shows that level 1 can patch 49 (64%) vulnerabilities, level 2 can patch 22 (29%) vulnerabilities, and we have to fall back to level 3 in only 5 cases (7%).
This multi-level design allows KARMA to patch most, if not all, Android kernel vulnerabilities.
In the following, we focus on the level-1 and level-2 patches since level-3 patches (i.e., binary patching) have been studied by a number of the previous research [22,23,27].
A patch can indirectly affect the kernel's control flow by returning an error code when a malicious input is intercepted.
This immediately terminates the execution of the vulnerable function and passes the error code to the caller.
We require a patched function to return error codes on fault in order to leverage the existing error handling code of the kernel to gracefully fail on malicious inputs.
Allowing a patch to return arbitrary values (i.e., other than error codes) may have unintended consequences.
Fortunately, many kernel functions return error codes on fault, following the guidelines of the official coding style.
Similarly, we allow functions that return void to be patched.Rule II, a patch can read any valid kernel data structures, but it is prohibited from writing to the kernel.Even though KARMA's patches are vetted before deployment, they may still contain weakness that can be exploited by attackers.
To control their side effects, patches are only allowed to read necessary, valid kernel data structures (e.g., registers, stacks, the heap, code, etc.), but they are prohibited from writing to the kernel.
Allowing a patch to change the kernel's memory, even one bit, is dangerous.
For example, it could be exploited to clear the U-bit (the user/kernel bit) of a page table entry to grant the user code the kernel privilege.
Without the write permission, patches are also prevented from leaking kernel information to a local or remote adversary.
This rule is enforced by providing a set of restricted APIs as the only interface for the patches to access the kernel data.By combining these two rules with a careful vetting process and the memory-safety of the patches, we can strictly confine the run-time behaviors of patches to prevent them from potential misuse.
KARMA works in two phases as shown in Figure 3.
The offline phase adapts a reference patch (P r ) to all the devices supported by KARMA.
The reference patch often comes from an upstream source, such as Google and chipset manufacturers.
It targets a specific device and kernel (named as the reference kernel, K r ) and is not directly applicable to other devices.
To address that, KARMA employs an automated system to customize P r for each target kernel (K t ).
Specifically, KARMA first roughly identifies potentially vulnerable functions in kernel K t , and applies symbolic execution to compare the semantics of each candidate function (F t ) against reference function F r .
If these two functions are semantically equivalent, KARMA further adjusts the reference patch for kernel K t , signs it, and deposits it to the cloud.
To prevent malicious patches from being installed by user devices, reference patches are carefully vetted and all the patches are signed.
User devices only install signed patches.
Matching semantics with symbolic execution can abstract syntactic differences in function binaries (e.g., register allocation).
Semantic matching decides whether candidate function F t is semantically equivalent, or very similar to, reference function F r , and whether F t has been patched or not.
In other words, it is responsible for locating a function in the target kernel that can be patched but has not been patched yet.
Semantic matching also provides a scheme to customize reference patch P r for target kernels.In the second phase, the KARMA client in the user device downloads and verifies the patches for its device and applies them to the running kernel.
Specifically, the client verifies that each downloaded patch is authentic by checking its signature and that it is applicable to this device by comparing the device model and the kernel version.
If a patch passes the verification, it is cached in a secure store provided by Android.
The client then applies the patch to the running kernel.
An applied patch immediately protects the kernel from exploits without rebooting the device or user interactions.
In the unlikely event that a patch causes the device to malfunction, the user can reboot the device and skip the problematic patches 1 function kpatcher ( patchID , sp , cpsr , r , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r1 , r11 , r12 , r14 ) 2 if patchID == xca5269db5f4 then 3 uaddr1 = r 4 uaddr2 = r2 5 if uaddr1 == uaddr2 then by holding a hardware key.
Currently, KARMA's patches are written in the Lua language.
We choose Lua for its simplicity, memory-safety, and easiness to embed and extend (in security, simplicity is a virtue).
Lua provides sufficient expressive power for KARMA to fix most kernel vulnerabilities.
Other kernel scripting languages, such as BPF [8], can also satisfy our requirements.
To execute these patches, we embed a restricted Lua engine in the kernel.
The engine strictly enforces the security rules of KARMA (Section 2.2).
In the rest of this section, we first illustrate KARMA's patches and then present these two phases in detail.
Patches in KARMA are written in the Lua programming language.
Lua is a simple, extensible, embedded language.
It has only eight primitive types, such as nil, boolean, number, string, and table.
Tables are the only built-in composite data type.
Most user data structures are built on top of tables.
Lua is a dynamically typed language, and all the data accesses are checked at the run-time.
This reduces common memory-related flaws like buffer overflows.
Lastly, Lua creates an isolated environment to execute patches.
This prevents patches from directly accessing the kernel memory.
Instead, the kernel data can only be accessed through restrictive APIs provided by KARMA.
Figure 4 shows a simplified patch for CVE-2014-3153, exploited by the infamous Towelroot.
CVE-2014-3153 is a flaw in function futex_requeue.
It fails to check that two arguments are different, allowing a local user to gain the root privilege via a crafted FUTEX_REQUEUE command [14].
To fix it, we just check whether these two arguments (in register rr and r1, respectively) are different and return an error code (-22 or -EINVAL) if they are the same.
As shown in Fig. 4, each hooking point has a unique ID.
The patch can check this ID to ensure that it is called by the correct hooking points.
When invoked, the patch receives the current values of the registers as arguments.
They allow the patch to access function argu-1 s t a t i c i n t sock _diag _rcv_m sg ( s t r u c t sk_buff * skb , s t r u c t nlmsghdr * nlh ) 2 { 3... CVE-2013-1763: Figure 5 shows the original source code patch for CVE-2013-1763.
Each "+" sign marks a new line added by the patch.
The added lines validate that the protocol family of the received message (req->sdiag_family) is less than AF_MAX and returns -EINVAL otherwise.
This patch can be easily converted to a reference patch for KARMA.
However, since __sock_diag_rcv_msg does not appear in the kernel's symbol table (because it is a static function), KARMA instead hooks the entry point of its parent function and screens the arguments there.CVE-2013-6123: this is a vulnerability in function msm_ioctl_server, which reads an untrusted data structure (u_isp_event) from the user space with copy_from_user.
However, it fails to check that the queue_index field of the input is valid.
This vulnerability is fixed by line 10-17 in Fig. 6.
To patch this vulnerability in KARMA, we cannot hook the entry point of msm_ioctl_server because the malicious input data is not available yet.
Instead, we should hook the return point of copy_from_user and filter the received data.
copy_from_user returns status codes; therefore it can be hooked by KARMA.
If the patch detects a malicious input, it returns the error code of -EINVAL.
This terminates the execution gracefully.CVE-2016-0802: this is a buffer overflow in the 1 s t a t i c l o n g msm_ioctl_server ( s t r u c t file * file , v o i d * fh , bool valid_prio , i n t cmd ,v o i d * arg ) 2 { 3 ... 4 i f ( copy_from_user (& u_isp_event , 5 ( v o i d __user *) ioctl_ptr -> ioctl_ptr , 6s i z e o f ( s t r u c t m sm_ is p_ ev en t_ ct rl ) ) ) { 7... 8 } 9.
Broadcom WiFi driver, caused by the missing check that the packet data length is less than the packet length.
This vulnerability represents an interesting challenge to KARMA: the source-code is patched in several functions, and a new argument is added to function dhd_wl_host_event and dngl_host_event.
The error condition is finally checked in function dngl_host_event.
Apparently, this type of fix (i.e., adding new arguments to functions) cannot be translated directly in KARMA because patches are not allowed to write the kernel memory.
To address that, we need to hook both dhd_rx_frame and dngl_host_event functions.
The first hook saves the packet length, and the second hook compares the packet length to the data length.
If the data length is larger than the packet length, the patch returns the error code of BCME_ERROR.
This is an example of KARMA's multi-invocation patches (also called stateful patches).
Both patches bear the same patch ID.
The variables at the first hook are made accessible to the second hook by KARMA's Lua engine.
An alternative fix is to hook only dhd_rx_frame and manually extract the data length from the packet.
However, this fix is less favorable because the patch has to parse the packet structure by itself and it is placed differently from where the source-code patch modifies the control flow, i.e., where the error handling is guaranteed to work.
KARMA's offline component adapts a reference patch for all supported devices.
It first identifies the vulnerable function in a target kernel through structural and semantic matching; then it uses the information from semantic matching to customize the patch for the target kernel.
In the following, we describe these two steps in detail.1 v o i d dhd_rx_frame (...) 2 { 3 ... 4 dhd_wl_ho st_eve nt ( dhd , & ifidx , 5 skb_mac_header ( skb ) , 6 skb -> mac .
raw , 7 + len -2 , 8 & event , & data ) ; 9... 10 } 11 s t a t i c i n t dhd _wl_ho st_eve nt (...) 12 { 13...14 - if ( dngl_host_event ( dhd_pub , pktdata ) == BCME_OK ) { 15 + if ( dngl_host_event ( dhd_pub , pktdata , pktlen ) == BCME_OK ) { 16 ... 17 } 18 i n t dngl_host_event (...) 19 { 20 ... 21 + if ( datalen > pktlen ) 22 + return ( BCME_ERROR ) ; 23... 24 } Figure 7: Source-code patch for CVE-2016-0802 Given a target kernel K t , we first identify candidate functions (F t ) in K t that may contain the same vulnerability as reference function F r .
However, this task is not as simple as searching the kernel symbol table.
There are a number of challenges.
First, function F t might have different semantics than F r even though their names are the same.
Accordingly, the patch cannot be applied to K t .
KARMA addresses this problem by further matching their semantics.
Second, F t may have a (slightly) different name than F r even though their semantics is the same.
For example, CVE-2015-3636 [30], exploited by PingPong root, exists in function ping_unhash in the Google Nexus 5 kernel but ping_v4_unhash in some other kernels.
Third, F t could have been inlined in the target kernel and thus does not exist in the symbol table.
To address these challenges, we assume that most (other) functions are not changed or renamed across different kernels.
This assumption is backed by our first observation (Section 2.1).
To find matches of function F r in target kernel K t , we first extract the symbol table from K t 's binary 3 and search in it for the name of F r .
If an exact match is found, we consider this function to be the only candidate.
Otherwise, we try to identify candidate functions by call relations.
Specifically, we first extract the call graphs from the target and the reference kernels.
We collect callers and callees of function F r in the reference kernel's graph, and try to locate nodes in the target kernel's graph that have similar call relations to these two sets of functions.
We may find a unique matching node if the function has been simply renamed.
If the function has been inlined, the target kernel's call graph contains direct edges from the caller set to the callee set (instead of connected through F r ).
Accordingly, we use the containing function as the candidate.
Multiple candidate functions may be identified using this approach.
The semantics of these candidate functions is then compared to that of function F r to ensure that the patch is applied to correct functions.
In this step, KARMA uses semantic matching to decide whether a function should be patched and whether a given reference patch can be adapted to it.
For two Android kernels, the same source code could be compiled into different binaries -they may vary in register allocation, instruction selection, and instruction layout.
In addition, the positions of structure members may have shifted, and the stack may contain different temporary variables (e.g., because of differences in the register spilling).
Therefore, simple syntactic comparison of functions is too restrictive and may reject functions that could otherwise be patched.
To this end, we leverage symbolic execution to compare semantics of the candidate function (F t ) and the reference function (F r ).
Path explosion is a significant obstacle in symbolic execution.
The situation is even more serious in the Linux kernel because many kernel functions are highly complicated.
Even if the vulnerable function looks simple, it may call complex other functions.
This can quickly overwhelm the symbolic execution engine.
In KARMA, we assume that functions called by F t and F r have the same semantics if they share the same signature (i.e., function name and arguments).
Therefore, we can use non-local memory writes (i.e., writes to the heap or global variables), function calls, and function returns as checkpoints for semantic comparison.
Non-local memory writes, function calls, and returns make up the function's impacts to the external environment.
We consider two functions having the same semantics if their impacts to the environment are the same.
We do not take stack writes into consideration because the same function may have different stack layouts in two kernels.To compare their semantics, we symbolically execute the basic blocks of F r and F t and generate constraints for memory writes and function calls.
For each memory write, we first check whether it is a local write or not (we consider it a local write if its address is calculated related to the stack/base pointer).
If it is a non-local write, we add two constraints that the memory addresses and the content-to-write should be equal.
For function calls, we first check that these functions have the same name (and arguments if the kernel source is available).
If so, we add constraints that the arguments to these two functions should be equal.
We handle function returns similarly by adding constraints for register rr at the function exits.
External inputs to these two functions, such as initial register values, non-local memory reads, and sub-function returns, are symbolized.KARMA supports two modes of operation: in the strict mode, we require that two matching constraints are exactly the same, except for constants.
Constants are often used as offsets into structures or the code (e.g., to read embedded constants in the code).
These offsets could be different even for the same source code because of different hardware/software settings (e.g., conditional compiling).
We ignore these constants to accommodate these differences.
In a relaxed mode, we use a constraint solver to find a solution that can fulfill all the constraints at the same time.
We consider two functions to be semantically equivalent if there exist at least one such solution.
Moreover, to avoid patching an already-patched function, we compare path constraints for the variables accessed by reference patch P r in function F r and F t .
If they are more restrictive in F t than in F r (i.e., conditional checks are added in F t ), the function may have already been patched.
Note that since KARMA's patches cannot modify the kernel memory, reapplying a patch is likely safe.
If a semantic match is found, the symbolic formulas provide useful information for adapting patch P r for the target kernel.
For example, we can adjust P r 's registers and field offsets by comparing formulas of the function arguments.
We evaluate the effectiveness of semantic matching in Section 3.2.
To enable its protection, KARMA needs to run its client in the user device.
The client consists of a regular app and a kernel module.
The app contacts the KARMA servers to retrieve patches for the device, while the kernel module verifies the integrity of these patches and applies ones that pass the verification.
Free the allocated memory for live patching get_callee Locate a callee that can be hooked search_symbol Get the kernel symbol address current_thread Get the current thread context read_buf Read raw bytes from memory with the given size read_int_8Read 8 bits from memory as an integer read_int_16Read 16 bits from memory as an integer read_int_32Read 32 bits from memory as an integer read_int_64Read 64 bits from memory as an integer used by patches to read kernel data.
Our vetting process automatically ensures that patches can only use the second group of APIs.
As such, the memory safety of Lua is retained because all the APIs that a patch can access are read-only.
Table 4 lists these APIs, which provide the following functionalities: 1) symbol searching: return the run-time address of a symbol; 2) function hooking: hook a given function/sub-function in order to execute the patch before/after the function is called; 3) typed read: given an address, validate whether the address is readable and return the (typed) data if so; 4) thread-info fetching: return the current thread information, such as its thread ID, kernel stack, etc.
The first two functionalities belong to the first group, and the rest belongs to the second group.
Again, the live patcher can use both groups of the APIs, but patches can only use the second one.
To apply a patch, KARMA hooks the target function to interpose the patch in the regular execution flow, as shown in Fig. 8.
Specifically, for each hooking point, we create a piece of the trampoline code and overwrite the first few instructions at the hooking point with a jump to the trampoline.
At run-time, the trampoline saves the current context by pushing all the registers to the stack and invokes the Lua engine to execute the associated patch.
The saved context is passed to the patch as arguments so that the patch can access these registers.
Before installing the hook, the live patcher calls the stop_machine function and checks whether there are any existing invocations of the target function in the kernel stacks.
If so, it is unsafe to immediately patch the function because otherwise the existing invocations will return to the patched version, potentially causing inconsistent kernel states.
When this happens, we return an error code to the client which will retry later.
As soon as the patch is applied, the vulnerable function is protected from attacks.
If no malicious inputs are detected, the patch returns zero to the trampoline, which in turn restores the context, executes KARMA supports two methods to dispatch a patch, one for each of the two execution contexts: the interrupt context or the thread (or process) context.
In the interrupt context, the Lua engine is directly invoked through the engine's C interface, similar to a regular function call.
However, it is expensive to launch a new Lua engine each time a patch is executed.
In the thread context, we instead schedule patches to a standalone Lua engine (through a workqueue) and wait for the results.
The Lua engine executes in a self-contained kernel thread and processes incoming requests from the workqueue.
Each request is identified by the thread ID and the patch ID.
This dispatching method cannot be used in the interrupt context because blocking functions (e.g., to acquire a lock) cannot be called in that context.
If a vulnerable function is called in both contexts, we dispatch the patch according to the active context (we have not found such cases in practice).
Patch dispatching in the thread context is more complex.
In the following we give more details about it.
The kernel is a concurrent execution environment, especially with multi-core CPUs, which most Android devices have.
A patch accordingly can be executed simultaneous by multiple threads on different CPU cores.
These invocations are grouped by their thread ID and patch ID.
Specifically, for each distinct combination of thread ID and patch ID, a separate name space is created.
Each Lua variable is saved to its associated name space.
A name space is not destroyed until the associated thread ends.
Therefore, variables of the previous invocations remain available to the subsequent invocations in the same name space 4 .
By keeping the states across invocations, KARMA can support multi-invocation patches, i.e., complex patches that need to combine the results of several executions to make a decision.
A number of patches we tested require this capability.
In the thread context, we can also support multiple Lua engines to improve the throughput of patch execution.
Specifically, we can spawn multiple kernel threads to run several instances of the Lua engine.
A dispatch algorithm decides which Lua engine a request should be scheduled to.
The algorithm must be deterministic so that requests in the same name space will always be scheduled to the same engine, allowing them to access states from previous invocations.
When a thread ends, its associated states are cleared from all the Lua engines.Lua is a garbage-collected language.
Patches thus do not need to explicitly manage memory allocation and release.
The Lua engine uses a simple mark-and-sweep garbage collector [35].
Kernel patches usually do not need to allocate many memory blocks.
The default garbage collector works well for our purpose without slowing down the system.
We have implemented a prototype of KARMA.
We wrote a number of offline tools for patch adaptation and signing.
Our symbolic execution engine was based on the angr framework [6,44].
We implemented the syntactic and semantic matching by ourselves.
Our Lua engine in the kernel is similar to the lunatik-ng project [26].
For example, the Linux kernel does not use floating-point arithmetic.
We therefore changed Lua's internal number representation from floating-points to integers.
We also removed the unnecessary Lua libraries such as file operations.
Furthermore, we added the support to name spaces in our Lua engine and extended the Lua language with the APIs specified in Table 4.
We added roughly about 11K lines of source code in total to the Android kernel.
The added code was compiled as an 800KB kernel module.
This kernel module can be pre-installed on Android devices through collaboration with vendors or installed afterwards through rooting, the only choice available.
KARMA can support all the known Android kernel versions (from 2.6.x to 3.18.x) and different vendors.
The effectiveness of KARMA can be evaluated by its applicability, adaptability, and performance.
Applicability quantifies how many existing kernel vulnerabilities can be patched by KARMA, and adaptability quantifies how many devices that KARMA can adapt a reference patch for.
In the following, we describe these three aspects of the evaluation in detail.
We tested KARMA with all the critical kernel vulnerabilities from Android Security Bulletin and ones used to root Android devices.
There are 76 such vulnerabilities in total in the last three years.
Remarkably, KARMA can fix 71 of them (93.4%) with level-1 and level-2 patches; i.e., we can create an adaptable KARMA patch for them.
Table 6 in Appendix A gives a more complete list of the results.
In the following, we describe how KARMA can prevent some interesting kernel vulnerabilities used in one-click rooting apps and recent malware incidents [5,17,18,21].
Appendix A contains a couple of more examples.CVE-2013-6282 (VROOT): this was one of the most popular vulnerabilities used in the wild to root Android devices, publicly known as "VROOT".
It exists in the get/put_user macros.
They both fail to check that user-provided addresses are in the valid range.
The original patches add the necessary checks to these macros and return -EFAULT if invalid addresses are detected [12].
However, KARMA cannot patch these two macros because they are expanded by the compiler and thus do not exist in the kernel binary.
Instead, KARMA patches their expanded functions (i.e., __get_user_1/2/4 and __put_user_1/2/4/8) with checks of whether user-provided addresses are less than current_thread_info()->addr_limit-1.
Note that these patches can access the current thread_info structure by using the current_thread API provided by KARMA.
These patches simply return -EFAULT if the address is out of the range.CVE-2013-2595 (Framaroot): this vulnerability was a part of the infamous Framaroot app (the "Gandalf" payload).
It exists in the camera driver for the Qualcomm MSM devices [10].
The driver provides an uncontrolled mmap interface, allowing the attacker to map sensitive kernel memory into the user space.
KARMA can patch this vulnerability by validating whether the memory to be mapped is within the user space.CVE-2013-2596 (MotoChopper): an integer overflow in the fb_mmap function allows a local user to create a read-write mapping of the entire kernel memory and consequently gain the kernel privileges.
Specifically, the function has a faulty conditional check: if((vma->vm_end -vma->vm_start + off)>len) return -EINVAL; Because off is a user-controlled variable, an attacker can pass in a really large number to overflow (vma->vm_end -vma->vm_start + off) (the result is interpreted as a negative number) and bypass the validation.
Here the original patch adds more checks to prevent this situation [11].
To patch this vulnerability in KARMA, we hook the fb_mmap function and extract the needed variables from its argument vma.
For example, we can calculate off as (vma->vm_pgoff << PAGE_SHIFT).
The patch then checks whether (vma->vm_end -vma->vm_start + off) is negative or not, and return -EINVAL if so.
KARMA is an adaptive kernel live patching system for Android.
Its ability to automatically adapt a reference patch is the key to protect a wide variety of devices and reduce the window of vulnerability.
In this experiment, we evaluate KARMA's adaptability with 1, 139 Android kernels collected from Internet.Semantic matching is the key to KARMA's adaptability.
It uses symbolic execution to abstract away syntactic differences in function binaries, such as register allocation, instruction selection, and data offset.
To evaluate its effectiveness, we cluster the collected 1, 139 Android kernels 5 by syntactic and semantic features for 13 popular vulnerabilities.
Specifically, the opcode-based clustering classifies kernel functions by types and frequencies of instruction opcodes; the syntax-based clustering classifies kernel functions by function calls and conditional branches; and the semantic-based clustering classifies kernel functions according to KARMA's semantic matching results.
Table 5 lists the number of clusters and the percentage of kernels in the largest cluster for each clustering method.
This table shows that the semantic-based method is the most precise one because it has the smallest number of clusters.
Technically, each cluster may need a different adaptation of the reference patch.
Therefore, fewer clusters mean a better chance for adaptation to succeed and less manual efforts if automated adaptation fails.
Moreover, the largest clusters in the semantic matching often contain the majority of the vulnerable kernels.
For example, a single reference patch for the largest cluster of perf_swevent_init can be applied to 96.3% of the vulnerable kernels.We randomly picked some functions to manually verify the outcome of semantic matching.
(a)The rest of the control f ow graph is omitted for simplicity.
Semantic matching can also separate kernel functions that are incorrectly classified together by the syntax matching.
For example, the control flow and most instructions of function msm_cci_validate_queue (the function related to CVE-2014-9890) are identical in the Finally, KARMA's semantic matching is quite efficient.
It simplifies symbolic execution by considering most functions remain unchanged.
The last-but-two column of Table 5 lists the time used by semantic matching to compare each listed function in two kernels.
The analysis time increases with the complexity of the function, but they are all less than 36 seconds with an average of 12.5 seconds.
Without this heuristics, it will take much longer and may never finish in some cases.
To evaluate the performance overhead of KARMA, we experimented with both a standard Android benchmark (CF-Bench [9]) and a syscall-based micro-benchmark.
Both benchmarks were run on Google Nexus 5 with Android 4.4.
Each reported result is the average over 20 measurements.
The standard deviation of the results is negligible.
Overall, we find that KARMA does not introduce noticeable time lag to regular operations of the test device.
Considering the fact that most critical kernel vulnerabilities exist in less-hot code paths (e.g., device drivers' ioctl interfaces as shown in Table 6), we consider KARMA's performance is sufficient for real-world deployment.The first benchmark measures the whole system performance with CF-Bench.
We tested the performance of the following four configurations: the original kernel without any patches, the kernel with the patch for Towelroot, the kernel with the patch for PingPong root, and the kernel with both patches.
The results are shown in Fig. 11.
The measured performance is virtually the same for all four configurations.
This benchmark shows that KARMA's kernel engine has minimal impact on the performance if patches are not frequently executed.To further quantify the overhead of KARMA, we measured the execution time of a syscall with several different patches executed by a single Lua engine.
We inserted a hook point in the execution path of a selected syscall (i.e., the patch was always executed for this syscall) and measured the execution time of the syscall under the following conditions:• The patch simply returns 0.
This reflects the run-time cost of the trampoline for function hooking.
It takes about 0.42µs to execute.
• The patch contains a set of if/elseif/else conditional statements.
This simulates patches that validate input arguments.
It takes about 0.98µs to execute.
• The patch consists of a single read of the kernel memory.
This measures the overhead of the Lua APIs provided by KARMA.
It takes about 0.82µs to execution.
• To simulate more complex patches, we created a patch with a mixture of assignments, memory reads, and conditional statements.
It takes about 3.74µs to execute.The results are shown in Figure 12.
In each test, the syscall was invoked in a tight loop for a thousand times, and each result is the average of 20 runs.
To put this into context, we counted all the syscalls made by Google Chrome for Android during one minute of browsing.
The most frequently made syscall was gettimeofday for about 110, 000 times.
This translates to about 0.55 seconds (0.9%) of extra time even if we assume the patch takes 5µs for each invocation.
In summary, KARMA only incurs negligible performance overhead and performs sufficiently well for real-world deployment.
In this section, we discuss potential improvements to KARMA and the future work.
First, KARMA aims at protecting the Android kernel from exploits because the kernel has a high privilege and its compromise has serious consequences on user security and privacy.
An approach similar to KARMA can be applied to the Android framework and user-space apps.
In addition, Android O formalizes the interface between the Android framework and the vendor implementation so that, eventually, the Android framework can be updated independent of the vendor implementation (aka.
project Treble [20]).
This will at least partially address the user-space update problem.
However, project Treble does not address the kernel update problem.
Android kernels are still fragmented and out-of-date.
A system like KARMA is still necessary.Second, KARMA's patches are written in the Lua programming language.
It relies on the Lua engine to strictly confine patches' run-time behaviors.
However, this approach increases the kernel's trusted computing base despite the fact that the Lua engine is relatively mature and secure.
Executing patches on the Lua engine also negatively impacts the performance, especially if the system is under heavy load (in reality, this is not a concern because most Android kernel vulnerabilities are on the kernel's cold paths, such as device drivers' ioctl functions, as shown in Table 6).
We are investigating alternative designs that can achieve similar security guarantees, such as BPF [8] and sandboxed binary patches.Third, KARMA leverages the existing error handling code in the kernel to handle filtered malicious inputs, in order to keep the kernel as stable as possible.
However, error handling code has been shown to contain vulnerabilities [36], and this design may leak resources and even cause deadlocks (KARMA does not allow patches themselves to release resource because that requires writing to the kernel).
We did not find this to be a constraint during our experiment with all the critical Android kernel vulnerabilities.
KARMA's reference patch is often a direct translation of the official source-code patch, which should have properly released the resources.
If an official patch cannot be translated to a level-1 or level-2 patch, we can fall back to the level-3 (binary) patch.
Level-3 patches are more flexible but require careful vetting.Fourth, KARMA uses symbolic execution to semantically match two vulnerable functions.
The approach is sufficient for our purpose in practice because many kernel functions are rather stable across devices and Android releases.
In theory, the approach is not sound.
It is a trade-off between soundness and scalability.
Many systems make a similar trade-off because symbolic execution itself is neither very scalable nor very precise (e.g., how to handle loops).
We are improving our method to better identify vulnerable functions and adapt patches.
If KARMA's automated adaption cannot find a proper function to patch, we can fall back to the binary patch for this particular vulnerability.Lastly, KARMA is a third-party kernel live patching system.
Patches can be promptly delivered to user devices without the long wait caused by vendors and carriers.
However, without testing performed by vendors and carries, its patches could cause stability issues in the user devices.
Our implementation allows users to selectively disable a problematic patch.
With KARMA's cloud service, we can automatically blacklist such patches from specific device models.
We can also work with device vendors so patches can be quickly tested before release.
Kernel live patching: the first category of the related work consists of a number of kernel live patching systems, such as kpatch [23], kGraft [22], Ksplice [27], and KUP [37].
They assume that the kernel source code is available (a reasonable assumption for their purpose) and create live patches from source code patches.
Their patches are however in the binary form.
This design does not fit the threat model of KARMA.
First, although Android kernel is licensed in GPL, many Android vendors, small and large alike [19], do not (promptly) release their kernel source code.
Second, these systems lack a mechanism to automatically adapt a kernel patch to different Android devices.
An important design goal of KARMA is adaptiveness so that it can scale to the Android ecosystem.
Third, binary patches are prone to misuse because they are hard to understand and vet, and these systems have no strong confinement of patches' run-time behaviors.
KARMA has been designed specifically to address all these challenges in a live kernel patching system for Android.Among these systems, kpatch [23] and kGraft [22] replace a whole vulnerable function with the patched version.
They differ in how patches are applied: kpatch stops all the running processes and ensures that none of these processes are running inside the function to be patched (similar to KARMA).
kGraft instead maintains two copies of each patched function at the same time and dynamically decides which copy to execute.
Specifically, the kernel code active at the time of patching (e.g., system calls, kernel threads, and interrupt handlers) is dispatched to the original version until it reaches a completion point; all other code is dispatched to the patched version.
Like kpatch, Ksplice [27] also stops the machine to apply patches.
However, Ksplice can patch individual instructions instead of replacing whole functions.
These systems share the same limitation that they cannot support patches that "change the semantics of persistent data structures [27]".
To address that, KUP [37] employs the process checkpoint-and-restart to implement kernel hot patching.
Specifically, it checkpoints all the user processes, replaces the running kernel with the patched version, and then restores these user processes.
Because it replaces the whole kernel, KUP can support all kinds of patches.
However, restoring external resources (e.g., sockets) is often problematic for checkpoint-and-restore systems, including KUP.Semantic matching: the second category of the related work includes systems that compare semantics or similarity of two functions [31,32,39,40].
BinHunt [32] first uses symbolic execution to compute semantic similarity of basic blocks and uses a graph isomorphism algorithm to further compare the similarity of CFGs (controlflow graphs).
Their follow-up work, iBinHunt [40], extends BinHunt with the inter-procedural control-flow graph comparison.
However, whole-program comparison could be very time-consuming.
To solve that, iBinHunt runs the program with taint tracking and only compares basic blocks within the same data flows.
This approach is not suitable for KARMA because none of the commercial Android devices support kernel dynamic taint tracking or whole-kernel instrumentation.
CoP [39] also uses symbolic execution to compute the semantic similarity of basic blocks and uses the longest common sub-sequence of linearly independent paths to measure the similarity of programs.
KARMA uses symbolic execution to solve syntax differences in semanticallyequivalent functions.
In addition, it leverages the fact that most kernel functions remain semantically similar across different kernel versions to significantly speedup the comparison.
DiscovRE [31] takes a different approach by using the syntactic information (i.e., structural and numeric features) to compare function similarities.
This can significantly improve the analysis efficiency.
KARMA requires a more precise comparison than that can be provided by syntax-based approaches.Automatic patch/filter generation: the third category of the related work includes systems that aim at automatically generating patches or input filters.
For example, Talos [34] is a vulnerability rapid response system.
It inserts SWRRs (Security Workarounds for Rapid Response) into the kernel source code in order to temporarily protect kernel vulnerabilities from being exploited.
Talos shares a similar goal as KARMA, and both rely on the kernel's error handling code to gracefully neutralize attacks.
Talos' source code based approach cannot be applied to the fragmented Android ecosystem.
To address the fragmentation problem, KARMA can automatically adapt a patch to other devices and strictly confine the run-time behaviors of its patches.
ClearView [41] learns invariants of a program during a dynamic training phase.
When program failure happens, it identifies the failure-related invariants and uses them to generate patches for the program.
PAR [38] proposes a patternbased automatic program repair framework.
Its generated patches resemble the patterns learned from humanwritten patches.
ASSURE introduces rescue points that can recover software from unknown exploits while maintaining system integrity and availability [45].
ShieldGen [29] is a system for automatically generating vulnerability signatures (i.e., data patches).
Signature-based filtering can only block known attacks.
To address that, ShieldGen leverages protocol specifications to generate more exploits from an initial sample.
Bouncer [28] uses static analysis and dynamic symbolic execution to create comprehensive input filters to protect software from bad inputs.
Compared to these systems, KARMA aims at protecting kernel vulnerabilities for many Android systems and have a different design.
We have presented the design, implementation, and evaluation of KARMA, an adaptive live patching system for Android kernel vulnerabilities.
By filtering malicious user inputs, KARMA can protect most Android kernel vulnerabilities from exploits.
Compared to existing kernel live patching systems, the unique features of KARMA are that it can automatically adapt a reference patch for many Android devices, and it strictly confines the run-time behaviors of its patches.
These two features allow KARMA to scale to a large, fragmented Android ecosystem.
Our evaluation results demonstrated that KARMA can protect most critical Android kernel vulnerabilities in many devices with negligible performance overhead.
We would like to thank our shepherd David Lie and the anonymous reviewers for their insightful comments that greatly helped improve the presentation of this paper.
Yue Chen and Zhi Wang were supported in part by the US National Science Foundation (NSF) under Grant 1453020 and a grant from Baidu X-Lab.
Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the NSF.
lCase Studies A. 1 CVE-2014-3153 (Towelroot) this vulnerability is the second most-used one to root Android devices, known as "Towelroot".
It lies in the futex_requeue function, which takes the addresses of two futexes as arguments.
By design, the function should only re-queue from a non-PI (priority inheritance [46]) futex to a PI futex.
However, this condition is violated if these two addresses point to the same futex.
This leads to an exploitable dangling pointer condition.
To fix this bug, Linux simply adds a check to ensure that these two futex addresses are different [13].
This vulnerability can be similarly fixed in KARMA by hooking the futex_requeue function, obtaining its arguments, and compare their equality.
The patch returns -EINVAL if an attack is detected (Figure 4).
A.2 CVE-2015-3636 (PingPong Root)This is another popular vulnerability used to root Android devices, known as "PingPong Root".
It originates in the interaction between the socket and hlist functions.
Specifically, when hlist_nulls_del(&sk-> sk_nulls_node) is called, it assigns LIST_POISON2 to sk->sk_nulls_node.pprev.
LIST_POISON2 is defined as the constant of x222222.
If interpreted as an address, address LIST_POISON2 can be mapped by a malicious app in the user space without any permissions.
A second call to connect by the attacker will result in a use-after-free on this attacker-controlled address, compromising the kernel.
The Linux patch sets the pointer to NULL in the ping_unhash function [16].
However, this method cannot be applied by KARMA because its patch is prohibited from writing to the kernel memory.
Instead, the patch checks if sk->sk_nulls_node.pprev equals to LIST_POISON2.
If so, it returns an error code without freeing the associated memory.
This blocks the exploit but leaves the socket object on the list.
This patch is not clean, but it works and does not impact the kernel's functionalities.
Alternatively, KARMA can hook connect in the kernel to prevent reusing the freed socket.
VulnerabilityHotpatching Using KARMA Adaptable?CVE-2016-7117Hook __sys_recvmmsg and its invocation of fput.
Case Studies A. 1 CVE-2014-3153 (Towelroot) this vulnerability is the second most-used one to root Android devices, known as "Towelroot".
It lies in the futex_requeue function, which takes the addresses of two futexes as arguments.
By design, the function should only re-queue from a non-PI (priority inheritance [46]) futex to a PI futex.
However, this condition is violated if these two addresses point to the same futex.
This leads to an exploitable dangling pointer condition.
To fix this bug, Linux simply adds a check to ensure that these two futex addresses are different [13].
This vulnerability can be similarly fixed in KARMA by hooking the futex_requeue function, obtaining its arguments, and compare their equality.
The patch returns -EINVAL if an attack is detected (Figure 4).
This is another popular vulnerability used to root Android devices, known as "PingPong Root".
It originates in the interaction between the socket and hlist functions.
Specifically, when hlist_nulls_del(&sk-> sk_nulls_node) is called, it assigns LIST_POISON2 to sk->sk_nulls_node.pprev.
LIST_POISON2 is defined as the constant of x222222.
If interpreted as an address, address LIST_POISON2 can be mapped by a malicious app in the user space without any permissions.
A second call to connect by the attacker will result in a use-after-free on this attacker-controlled address, compromising the kernel.
The Linux patch sets the pointer to NULL in the ping_unhash function [16].
However, this method cannot be applied by KARMA because its patch is prohibited from writing to the kernel memory.
Instead, the patch checks if sk->sk_nulls_node.pprev equals to LIST_POISON2.
If so, it returns an error code without freeing the associated memory.
This blocks the exploit but leaves the socket object on the list.
This patch is not clean, but it works and does not impact the kernel's functionalities.
Alternatively, KARMA can hook connect in the kernel to prevent reusing the freed socket.
Hotpatching Using KARMA Adaptable?CVE-2016-7117Hook __sys_recvmmsg and its invocation of fput.
