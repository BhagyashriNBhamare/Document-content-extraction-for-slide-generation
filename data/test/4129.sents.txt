Passwords and access control remain the popular choice for protecting sensitive data stored online, despite their well-known vulnerability to brute-force attacks.
A natural solution is to use encryption.
Although standard practices of using encryption somewhat alleviate the problem , decryption is often needed for utility, and keeping the decryption key within reach is obviously dangerous.
To address this seemingly unavoidable problem in data security, we propose password-hardened encryp-tion (PHE).
With the help of an external crypto server, a service provider can recover the user data encrypted by PHE only when an end user supplied a correct password.
PHE inherits the security features of password-hardening (Usenix Security '15), adding protection for the user data.
In particular, the crypto server does not learn any information about any user data.
More importantly , both the crypto server and the service provider can rotate their secret keys, a proactive security mechanism mandated by the Payment Card Industry Data Security Standard (PCI DSS).
We build an extremely simple password-hardened en-cryption scheme.
Compared with the state-of-the-art password-hardening scheme (Usenix Security '17), our scheme only uses minimal number-theoretic operations and is, therefore, 30%-50% more efficient.
In fact, our extensive experimental evaluation demonstrates that our scheme can handle more than 525 encryption and (suc-cessful) decryption requests per second per core, which shows that it is lightweight and readily deployable in large-scale systems.
Regarding security, our scheme also achieves a stronger soundness property, which puts less trust on the good behavior of the crypto server.
Online services store huge amount of sensitive user data in their databases, such as email and physical addresses, personal interests, etc.
Pragmatically, accesses to this data is restricted to authorized users by an access control mechanism instead of by encryption and decryption, for a very simple reason that (the users of) the online services eventually need to use them.
Nevertheless, some information is required to be stored in an encrypted form, such as credit card information, as mandated by the payment card industry data security standard (PCI DSS) [19].
Note that any form of encryption is useless if an attacker gains access to anything which possesses the decryption capabilities or leads to the decryption.
For example, an attacker who gets access to a password database can first launch an offline dictionary attack to obtain user passwords, then logs in as these users and "legitimately" requests the online service provider to perform decryption.
Even worse, an insider or a persistent attacker who obtains the decryption key can download the entire database and perform decryption offline.
It is clear that as long as an online service provider has the full capability of decrypting the database, an attacker fully compromising it is just as powerful and can launch catastrophic attacks.
To defend against such a powerful attacker, an appealing approach is to use external crypto services to provide an extra layer of protection.
This is a central idea in password-hardening (PH) services [10,16].
In the context of PH, an online service provider who is providing services to end users is itself a client of a crypto server providing PH services.
Hereinafter, we call the online service provider as the server and the crypto server as the rate-limiter 1 .
When an end user registers with the server, the latter cooperates with the rate-limiter to jointly create a record which encrypts the password of the end user.
Later, when this end user logs in with a candidate password, the server cooperates with the rate-limiter again to check if the candidate password is identical to the one encrypted in the corresponding record.Due to the cooperation requirement above, PH essentially performs a double encryption of the passwords.
What makes PH interesting is its set of four fundamental guarantees tailored to practical deployment.
First, the server (or the rate-limiter) alone is unable to check whether a candidate password is correct.
This means the best strategy for any attacker who has fully compromised the server is to launch online (instead of offline) attacks.
Second, the rate-limiter can track the number of unsuccessful login attempts of each end user, and rate-limit password validation requests, and hence online attacks, on a per-user basis.
The third guarantee is that the ratelimiter learns no information about the passwords, meaning that PH is not just "transferring" the problem to the rate-limiter.
Lastly, if either the server or the rate-limiter is compromised, or if the secret keys are in use for quite some time, the parties can jointly execute a key-rotation mechanism to refresh their secret keys.
Furthermore, the key-rotation is seamless to the end users and requires arguably minimal help from the rate-limiter.
Specifically, the server can locally update the records of its end users without interacting with the rate-limiter or the end users.
This proactive mechanism provides forward security.These strong security guarantees of PH make it very difficult for an attacker to get access to the passwords of the end users, even if the server is fully compromised.
However, the protection of PH is confined to just the password itself.
An attacker who fully compromises the server can simply decrypt any encrypted database and retrieve all other related data in it.
The problem of PH services stems from its limitation of functionality.
In an abstract sense, PH can only "encrypt" a special message: the password.
Decryption is not possible; one can just test whether a given message is encrypted.
It is thus not suitable for encrypting general messages.
In other words, PH only provides authentication.
To solve this problem, we propose passwordhardened encryption (PHE) services, which is an extension of PH services that goes beyond authentication and uses the passwords to secure general data in addition to the passwords.
PHE aims to ensure that any attacker who can compromise the storage of these encrypted data cannot decrypt directly.The formulation of PHE is similar to that of PH described above, with the following key differences.
When an end user registers, the server and the rate-limiter jointly create a record which not only encrypts the user password but also a secret message.
The message can be a freshly generated key for a symmetric key encryption scheme (e.g., AES).
The server then encrypts any sensitive information belonging to this end user with this key and discards the key after encryption.
Later, when the end user logs in, the server and the rate-limiter jointly validate the given candidate password.
If and only if the password is correct, the server can then recover the key and proceed to decrypt the sensitive user information.
Figure 1 depicts the basic workflow of a PHE scheme.
PHE inherits all four fundamental security guarantees provided by PH, with the protection of passwords extended to additional secret messages as well.
In particular, PHE inherits the key rotation capability.
This makes PHE an appealing approach, for example, to conform to PCI DSS which requires credit card information to be encrypted by a mechanism supporting key rotation.With per-user secret messages, each user can now enjoy the benefit of encrypting their respective data using an independent key.
Data leakage is thus limited even if some of the keys are compromised.
More importantly, if the server decides to rotate not only its own secret key but also some of the (data-)keys, the rotation is not as costly as re-encrypting the whole database.In a nutshell, PHE is a one-package data-security solution for online service providers who employ passwordbased authentication and store sensitive user data.
PHE can be applied to any scenarios where a passwordbased authentication system is employed to protect user data, as a cryptographic replacement to access-controlbased protection.
For example, it can be used by online retail stores and e-commerce providers to encrypt credit card numbers and especially the CVV (card verification values).
It can also be used as a more secure password vault, where the user password serves as a master password for encrypting other (high-entropy) passwords (with the aid of the rate-limiter).
Our contributions can be summarized as follows:• We introduce and formalize the notion of PHE in order to protect arbitrary user data while retaining the functionality and security features of the underlying PH. The definitional framework encompasses dedicated cryptographic games as well as a soundness property that is stronger than the one previously adopted in PH services, inasmuch as it puts less trust on the good behavior of the rate-limiter.
• We propose a remarkably simple PHE construction.
Its novelty lies in the fact that it reduces the number of number-theoretic operations (in particular, dispenses from the implicit use of ElGamal encryption) in previous PH services, despite providing stronger security guarantees.
• Our PHE instantiation is between 30% and 50% more efficient than previous PH (without E) constructions.
Our extensive experimental evaluation demonstrated that our PHE scheme is highly efficient (∼ 10ms per request) and scales well to highthroughput scenarios.
• We prove the security of our construction in the random oracle model under the decisional DiffieHellman (DDH) assumption.
To appreciate the technical contribution brought by our PHE construction, we first consider a natural attempt which builds PHE by using PH as a black box.
Such a generic construction will likely require the use of zeroknowledge proof systems for a complex language dependent on the PH scheme.
Since our aim is to build a practical scheme which is plausible for deployment, we decide to modify the construction of the PH scheme PHOENIX [16] in a non-black-box way to become a PHE scheme.
More interestingly, it turns out that a major component in the construction of PHOENIX -a variant of the Cramer-Shoup encryption scheme [9] -is unnecessary.
With this observation, we design an extremely simple PHE scheme (which also gives a much simpler PH scheme) as follows.To encrypt the message M under the password pw, the server and the rate-limiter sample random nonces n S and n R respectively, and jointly compute(H x R,0 H y S,0 , H x R,1 H y S,1 M y )where H R,b = H R (n R , b) and H S,b = H S (n S , pw, b) are (multiplicative) group elements output by hash functions H R and H S , b ∈ {0, 1}, and x and y are the secret keys of the rate-limiter and the server respectively.To decrypt with the password pw, the server computes H y S,0 to recover the hash value H x R,0 , and sends the latter to the rate-limiter.
Upon verifying the correctness of H x R,0 , the rate-limiter returns H x R,1 .
The server then computes the value H y S,1 .
Together with H x R,1 , the server can then recover M.
We observe that in the existing definition of PH [16], in the case where the rate-limiter rejects in the validation phase, it is indistinguishable to the server whether the rate-limiter refuses to entertain the validation request (even when the password is correct) or the password indeed does not match the record.
To address this issue, we define the (strong) soundness property, which requires the rate-limiter to explain not only the reasons for acceptance, but also for rejections.In any real-world instantiation with strong soundness, compromised/cheating rate-limiters which (selectively) prevent legitimate logins (using correct passwords) can be detected.
It further means that external parties can serve as rate-limiters with minimal trust requirements.To achieve our newly defined soundness, additional zero-knowledge proofs need to be generated by the ratelimiter during both encryption and decryption.
This does not impact efficiency in any significant way, as confirmed by our experimental evaluation.
From the viewpoint of extending the definition of PH to that of PHE, we made the following contributions other than the stronger soundness requirement.
Firstly, all security experiments are modified to reflect attacks against not only the passwords but also the secret data to be encrypted.
Furthermore, most of the syntax and security experiments are more refined and simplified when comparing to their PH counterparts [16].
For example, in the definition of PH [16], the username of an end user serves as a common input to both the server and the rate-limiter in the enrollment and validation protocols.
This input is actually unnecessary (in the security definition nor in the construction) and is not present in our definition.In short, apart from adding encryption and decryption functionalities, we also make several improvements which can also be applicable to PH schemes, in terms of both definition and construction.
We first briefly recap PH schemes, then overview other cryptographic primitives which offer related security guarantees but not those fundamental to PHE / PH. Everspaugh et al. [10] introduced the notion of PH services to replace salted hashes for login validation.
Keyrotation is also identified as an important property to "heal the system" after compromise [10].
While Everspaugh et al. [10] formally defined partially-oblivious pseudorandom functions (PO-PRF) services, and informally suggested PH as an application, the subsequent work by Schneider et al. [20] attempted to give a formal definition (of a closely related notion called partially-oblivious commitments) and a scheme provably secure under the said definition.
Unfortunately, the definition of Schneider et al. [20] was shown by Lai et al. [16] to be flawed, as they discovered a devastating attack to the scheme of Schneider et al. [20] which extracts user passwords.
To capture such attacks Lai et al. [16] gave a new security definition.
They also proposed a scheme PHOENIX which is secure under the new definition.PHE services extend the security of PH as defined by Lai et al. [16] to messages, such that encrypted messages can only be decrypted with the correct password and the help of the external rate-limiter.
Finally, we stressed again that our PHE not only performs much better than the possible approach of applying generic zero-knowledge proof to "glue" PH with an encryption, but also leads to an implicit PH scheme which is even more efficient than the state-of-the-art [16].
The main goal of password-protected secret sharing (PPSS) or password-authenticated key-exchange (PAKE) is also to protect a secret message (of an end user, with the help of possibly more than one server) in such a way that it can only be recovered using the correct password.
Unlike the "game-based style" definition used in this work and in PH, the security of state-of-the-art PPSS/PAKE schemes [12,13] is usually proven in "simulation style" under the UC framework [8].
PPSS in the public-key model implies threshold PAKE [2] so we focus on PPSS.
While it seems that PHE can be constructed from PPSS by having the server hold one of the shares and the rate-limiter hold the other, the resulting scheme lacks important features of PHE.Per-user rate-limiting.
While global rate-limiting is trivial, note that PHE schemes additionally allow (and require) the rate-limiter to count the number of unsuccessful login attempts of each user, and refuse to provide decryption services to the server for a certain user (indirectly) if the latter has attempted too many unsuccessful logins.
Existing PPSS schemes do not, nor can be easily extended to, support per-user rate-limiting.
Key-rotation.
Most PPSS schemes do not support keyrotation.
The only existing scheme with key-rotation [5] is very inefficient: It requires "a few hundred exponentiations" per number of shares [5].
Distributed password verification (DPV) protocols [6] also require the online service provider to seek help from external crypto servers for verifying user passwords.
Moreover, both notions explicitly feature key-rotation mechanisms.
Yet, unlike PH, DPV does not explicitly support per-user rate limiting, nor can the existing construction [6] be modified to support it.
Unlike PHE, DPV does not provide encryption functionality.
Hidden credential retrieval (HCR) [4] also considers having a crypto service to unlock credentials for users who hold low-entropy passwords.
Not protected by other mechanisms, the crypto service in HCR can launch an inevitable offline dictionary attack to recover the user credential.
HCR does not support key rotation either.Password-based key-derivation or encryption [14,15,17] encrypts messages directly using keys derived from passwords.
As typical passwords have low entropy, salt values are also used.
Yet, it is still vulnerable to brute-force attacks by an attacker who obtained the salts database.
We formalize password-hardened encryption, an extension of password-hardening, for encrypting messages which can only be decrypted by the user password, the secret keys of both the server and the rate-limiter.
Let 1 λ be a λ -bit unary string of 1 which represents the security parameter.
Let P and M be the password space and message space respectively.
Let S and R refer to the server and the rate-limiter respectively.
We denote by (u, v) ←$ P S(x), R(y) the protocol P executed by the parties S and R with common input , local inputs x and y, and local outputs u and v respectively.
We denote the empty string by ε.A password-hardened encryption (PHE) scheme consists of the efficient algorithms and protocols (Setup, KGen S , KGen R , Encrypt, Decrypt, Rotate, Update), which we define as follows:Setup and Key Generation.
The following algorithms initialize our PHE system.pp ← Setup(1 λ ).
The setup algorithm generates the public parameters pp.
(pk S , sk S ) ← KGen S (pp).
The server runs KGen S (pp) to generate a key-pair (pk S , sk S ).
(pk R , sk R ) ← KGen R (pp).
The rate-limiter runs KGen R (pp) to generate a key-pair (pk R , sk R ).
We assume that all parties take pp, pk S , and pk R as inputs in all algorithms and protocols.Encryption.
When an end user registers for an account with password pw ∈ P and a secret message M ∈ M (e.g., an AES key, which can also be chosen by the server on behalf of the end user), the server engages in the (labeled) encryption protocol with the rate-limiter R to compute a record T with label :(( , T ), ε) ← Encrypt S(sk S , pw, M), R(sk R ).
The server S inputs a secret key sk S , a password pw ∈ P, a message M ∈ M.
The rate-limiter R takes as inputs a secret key sk R .
Both parties take a common input label = ( S , R ).
When the protocol concludes, S outputs a record T with a label = ( S , R ).
R outputs nothing, denoted by the empty string ε.We assume the convention that = or = ε.
The first condition is an exception which only appears in the definition of forward-security, while the second holds in all other situations, including normal executions in realworld applications.
In this case, is sampled during the protocol execution.
The label consists of S and R , which can be interpreted as the session identifiers or the pseudonyms of the end user assigned by the server and the rate-limiter respectively.Decryption.
When an end user logs in to the service provided by the server with a candidate password pw ∈ P, the server retrieves the corresponding encryption record T and label for the user, and engages in the (labeled) decryption protocol with the rate-limiter:(( f , M), ε) ← Decrypt S(sk S , pw, T ), R(sk R ).
The server S inputs its secret key sk S , the candidate password pw, and the retrieved record T .
The rate-limiter R inputs its secret key sk R .
Both parties take a common input (non-empty) label 2 .
The server outputs a flag f and a message M.
The flag f is either ⊥ to indicate failure (the rate-limiter aborts), 0 if the record or the password is invalid, or 1 for a successful login.
The rate-limiter outputs nothing, i.e., the empty string ε.Key Rotation and Record Update.
The server S and the rate-limiter R may decide to rotate their keys and update the records, which can be due to a regular routine or a compromise on either side.
The process consists of two steps, performed without involving any end user.First, S and R engage in a key rotation protocol to rotate their keys and compute an update token.
((pk S , sk S , τ), (pk R , sk R )) ← RotateS(sk S ), R(sk R ).
Their input is the respective secret key sk S and sk R .
When Rotate concludes, S outputs a rotated key-pair (pk S , sk S ), and an update token τ.
R outputs a rotated key-pair (pk R , sk R ).
With the token, S then locally runs an update algorithm on each record T with label .
T ← Update (τ, T ).
On input a label , an update token τ, and a record T (which encrypts some message M with label ), the update algorithm outputs a new record T (also encrypting M with label ).
One may consider a general treatment of update which allows changing the encrypted message M. For simplicity, we assume that M remains unchanged.
3Correctness.
A PHE is correct whenever all honestly generated records can be successfully decrypted to recover the encrypted message with the correct password.
Moreover, if a record passes decryption with respect to some secret keys, then the updated record also passes decryption with respect to the rotated keys.
Since correctness is subsumed by soundness and forward security, we omit the formal definition.
PHE is secure against persistent attackers.
Intuitively key-rotation can be seen as structuring the PHE protocol execution into separate rounds.
In each round, the attacker can compromise either the rate-limiter or the server and use whatever he learned in the next roundHid b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk R , sk R ) ←$ KGen R (pp) 2 : O := {P·, R(sk R , . . .) :3 : P ∈ {Encrypt ε , Decrypt , Rotate : ∈ {0, 1} * }} 4 : / / All rate-limiter outputs are given to adversary, 5 : / / except for sk R from Rotate·, R(skR).6 : / / Rotate·, R(skR updates skR embedded in all oracles to sk R .
Both our definitions and our construction assume a secure channel when executing honest interactions between server and rate-limiter.
This assumption is also made implicitly in the original definition of PH [16].
Practically this implies using a TLS connection between rate-limiter and server, and updating long-term keys and certificates during key-rotation.7 : (sk * S , χ, M * 0 , M * 1 , st) ←$ A O 1 (pp, pk R ) 8 : pw * ←$ χ 9 : (( * , T * ), ε) ←$ Encrypt ε S(sk * S , pw * , M * b ), R(sk R ) 10 : b ←$ A O 2 (st, * , T * ) 11 : return bWe formalize the security properties of PHE, extending those from password-hardening [16].
This obviously makes a secure PHE scheme also a secure PH scheme.Message Hiding (Figure 2).
Strengthening the (password-)hiding property of PH, the encrypted message corresponding to a record should also remain hidden even if the server (and its secret key) is compromised.
Specifically, message hiding requires that an adversary cannot distinguish whether a record T * is encrypting M * 0 or M * 1 , even if these messages, as well as the distribution of the password, are chosen by the adversary.
However, since by functionality the message can be recovered by engaging in the decryption protocol with the rate-limiter using the correct password, the highest possible security level that we can hope for is upper-bounded by the entropy of the password.
Our formalization covers this by parameterizing the winning condition of the adversary using the distribution of the passwords.Formally, we model message hiding as an experiment Hid b PHE,A (1 λ ) participated by a 2-stage adversary A = (A 1 , A 2 ) acting as the malicious server and a challenger acting as the honest rate-limiter.
The adversary A 1 gets access to the encryption, decryption, and key update oracles on chosen inputs.
Eventually, A 1 outputs a server secret key sk * S , a password distribution χ, two messages M * 0 and M * 1 , and a state st. The challenger picks a random password pw * from the distribution χ, and encapsulates M * b into a record T * with label * honestly using sk * S and pw * by locally emulating the encryption protocol.
Note that the communication transcript of the emulation is not given to A. Intuitively this is justified because the server was honest while the record was created and we assume a secure channel.Finally, A 2 gets * and T * , and must guess whether M * 0 or M * 1 is encrypted by outputting a guess b , which is also output by the experiment.Definition 1 (Message Hiding) A PHE scheme PHE is message hiding if, for any PPT adversary A = (A 1 , A 2 ), there exists a negligible function negl (λ ) such thatPr Hid 0 PHE,A (1 λ ) = 1 − Pr Hid 1 PHE,A (1 λ ) = 1 ≤ 2 Q ∑ i=1 p i + negl (λ ) ,where the probability related to an experiment outcome is taken over the random coins of the experiment, p i is the probability of the i-th most probable event in the distribution χ specified by the adversary, and Q is the number of times that A 2 queries Decrypt ·, R(sk R ) with input label = (·, * R ) 4 .
Partial Obliviousness (Figure 3).
Our formalization of partial obliviousness follows the recent definition for PH [16] closely but is adapted to our PHE setting.
This property hides the password and the encrypted message against a malicious rate-limiter, e.g., during the execution of the encryption and decryption protocols.
It is partial in the sense that it does not guarantee the anonymity of the end user.
In particular, it might be possible for the rate-limiter to link executions of the encryption and decryption protocols triggered by the same end user.
Formally, we model partial obliviousness as an experiment Obl b PHE,A (1 λ ) participated by a 3-stage adversary A = (A 1 , A 2 , A 3 ) acting as the malicious rate-limiter, and a "challenger" acting as the honest server.
Initially, A 1 can interact through the oracles O (denoted by A O 1 ) with the challenger in the protocols for encryption, decryption, and key-rotation on inputs of its choice.
The server outputs of the protocols are given to A, with the obvious exception of the rotated secret key from the rotation protocol.
Eventually, A 1 outputs two passwordmessage pairs(pw * 0 , M * 0 , pw * 1 , M * 1 ), with some state information st to be passed to A 2 .
The password pw * b and message M * b , where b is specified by the experiment, 4 The constant 2 in the upper bound is due to the specific style and proof technique which we do not think is inherent: We will eventually show that, for our construction, Hid b PHE,A for both b ∈ {0, 1} are indistinguishable to a hybrid experiment except with probability∑ Q i=1 p i + negl (λ ).
Taking the union bound yields the constant 2.
Obl b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk S , sk S ) ←$ KGen S (pp) 2 : O := {PS(sk S , . . .), · : 3 : P ∈ {Encrypt ε , Decrypt , Rotate : ∈ {0, 1} * }} 4 : (pw * 0 , M * 0 , pw * 1 , M * 1 , st) ←$ A O 1 (pp, pk S ) 5 : // All server outputs are given to A, except for sk S from RotateS(skS ), ·.6 : / / RotateS(skS ), · updates skS embedded in all oracles to sk S .
Figure 3: Partial Obliviousness Experiment is called the "challenge password" and "challenge message" respectively.7 : (( * , T * ), st) ←$ Encrypt ε S(sk S , pw * b , M * b ), A 2 (st) 8 : / / The server output ( f , m) from Decrypt S(skS , . . . , ), · is withheld from A 9 : / / if (, pw) = (( * S , ·), pw * 0 ) or (( * S , ·), pw * 1 ).
10 : b ←$ A O 3 (st, * , T * ) 11 : return bThe challenger, acting as the server, then engages in the encryption protocol using the empty label, the challenge password, and the challenge message with the adversary A 2 acting as the rate-limiter.
Upon termination, the challenger outputs a record T * with label * and sends them to A 3 .
The adversary A 2 outputs a state st which will also be passed to A 3 .
After the generation of the challenge record T * , A 3 can still interact with the challenger through the oracles, except that the decryption oracle will no longer return the decryption result to A, if it is queried on inputs containing ( * , pw * 0 ) or ( * , pw * 1 ).
This prevents A from winning trivially.
Eventually, A 3 outputs a guess b of which password-message pair is chosen as the challenge.
The experiment then simply outputs the value b .
Definition 2 (Partial Obliviousness) A PHE scheme PHE is partially oblivious if, for any three-stage PPT adversary A = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ ) such thatPr Obl 0 PHE,A (1 λ ) = 1 − Pr Obl 1 PHE,A (1 λ ) = 1 ≤ negl (λ ) ,where each probability is taken over the random coins of the experiment.Soundness (Figure 4 and Figure 5).
Soundness (Fig- ure 4) ensures that if a record and its encrypted message are generated by an honest server and a (possibly malicious) rate-limiter, then the message can be recovered by engaging in the decryption protocol using the correct password (unless the rate-limiter aborts).
On the other hand, decrypting using an incorrect password is guaranteed to yield f = 0 (unless the rate-limiter aborts).
This property arguably suffices for practical applications.Soundness PHE,A (1 λ ) 1 : (pk R , sk S , pw, pw , M, st) ←$ A 1 (1 λ ) 2 : ((, T ), st) ←$ Encrypt ε S(sk S , pw, M), A 2 (st) 3 : (( f , M ), st) ←$ Decrypt S(sk S , pw , T ), A 3 (st) 4 : b 0 ← ( f = ⊥) 5 : b 1 ← (pw = pw ∧ ( f = 1 ∨ M = M )) 6 : b 2 ← (pw = pw ∧ f = 0) 7 : return b 0 ∧ (b 1 ∨ b 2 )Figure 4: Soundness ExperimentStrongSoundness PHE,A (1 λ ) 1 : (pk R , sk S , , , pw, pw , T, st) ←$ A (1 λ ) 2 : (( f , M), st) ←$ Decrypt S(sk S , T, pw), A 2 (st) 3 : (( f , M ), st) ←$ Decrypt S(sk S , T, pw ), A 3 (st) 4 : b 0 ← (⊥ / ∈ { f , f }) / / Rate-limiter does not abort.
5 : b 1 ← ((, pw) = ( , pw ) ∧ ( f , M) = ( f , M ))6 : / / Same labels and passwords, different behaviors7 : b 2 ← ((, pw) = ( , pw ) ∧ f = f = 1) 8 : / / Record is valid under different label-password pairs 9 : return b 0 ∧ (b 1 ∨ b 2 )Figure 5: Strong Soundness ExperimentTo make the rate-limiter even more accountable, the strong soundness property guarantees all properties of soundness, with some additional ones ( Figure 5).
These additional requirements are similar to those in the binding property of PH. Specifically, we additionally require that, even for a maliciously generated record, it is infeasible for the malicious rate-limiter to behave inconsistently without getting caught (assuming that it does not abort).
The inconsistent behaviors include: 1) convince the server to output differently when decrypting the same record using the same password and the same label; 2) convince the server that the record is valid when decrypting with different label-password pairs.
Definition 3 ((Strong) Soundness) A PHE scheme PHE is sound if, for any PPT adversary A = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ ) such that SoundnessPHE,A (1 λ ) = 1 ≤ negl (λ ) .
Furthermore, it is strongly sound if it also holds thatPr StrongSoundness PHE,A (1 λ ) = 1 ≤ negl (λ ) .
The probabilities are taken over the random coins of the corresponding experiment.Forward Security ( Figure 6).
The key rotation phase should heal the system in the sense that it renders the old secret keys of the server and the rate-limiter useless to the adversary.
The old secret keys should not help the adversary in recovering information from an updated record.
On the other hand, the rotated keys and updated records should function the same as freshly generated keys and records respectively.
In order not to consider all possible sequences of corruption of the server and the rate-limiter in all security properties, we adopt the approach in the original PH definition [16] to define a strong notion of forward security.
This property ensures that even for maliciously generated records and maliciously generated secret keys for both the server and the rate-limiter, the rotated keys and updated records are indistinguishable to freshly generated keys and records respectively, except for the information that is preserved for ensuring functionality, e.g., the encrypted messages and the labels.Unlike the original definition [16], our definition allows the adversary to generate multiple records.
This definition seems not to be equivalent to the single-record variant, as an adversary against the single-record variant cannot simulate a challenger of the multi-record variant without knowing the update token chosen by the challenger of the single-record variant.Definition 4 (Forward Security) A PHE scheme PHE is forward secure if for any two-stage PPT adversary A = (A 1 , A 2 ) there exists a negligible function negl (λ ) withPr FwdSec 0 PHE,A (1 λ ) = 1 − Pr FwdSec 1 PHE,A (1 λ ) = 1 ≤ negl (λ ) ,where each probability is taken over the random coins of the experiments.
Since PHE is an extension of PH with an encryption functionality, it is natural to construct a PHE scheme from an existing PH scheme (e.g., [10,16]).
Recall that in a PH scheme, when a new end-user registers, the server and the rate-limiter engage in an enrollment protocol and jointly create a record which "encrypts" the password of the end user.
Later, when the end user logs in with a candidate password, the server and the rate-limiter can jointly verify whether the candidate password is valid.
Our first attempts are to construct PHE generically from PH or PO-PRF.
Below, we discuss why these approachesFwdSec b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk S , sk R , {( i , pw i , T i )} n i=1 , st) ←$ A 1 (pp) 3 : / / for some n = poly (λ ) 4 : ∀i ∈ [n], (( f i , M i ), ε) ← Decrypt i S(sk S , pw i , T i ), R(sk R ) 5 : if b = 0 then 6 : ((pk S , sk S , τ), (pk R , sk R )) ←$ RotateS(sk S ), R(sk R ) 7 : ∀i ∈ [n], T i ←$ Update i (τ, T i ) 8 : else 9 : (pk S , sk S ) ←$ KGen S (pp), (pk R , sk R ) ←$ KGen R (pp) 10 : ∀i ∈ [n], (( i , T i ), ε) ←$ Encrypt i S(sk S , pw i , M i ), R(sk R ) 11 :/ / By the assumed convention,i = i ∀i ∈ [n]12 : endif 13 : b ←$ A 2 (st, sk S , sk R , T 1 , . . . , T n ) 14 : return ((∀i ∈ [n], f i = 1) ∧ b ) At first glance, a PHE scheme might be built on top of a PH scheme, by additionally encrypting the message in the enrollment protocol, in such a way that it can be decrypted if and only if a valid candidate password is provided.
Below, we sketch a plausible construction.Suppose there exist a PH scheme and a public-key encryption (PKE) scheme which are both key-rotatable.
In the encryption phase, the server and the rate-limiter engage in the enrollment protocol of the PH scheme.
The server additionally encrypts the message using PKE to the rate-limiter.
Later, in the decryption phase, the server and the rate-limiter engage in the validation protocol of the PH scheme.
The server additionally requests the ratelimiter to decrypt a possibly blinded / rerandomized version of the ciphertext.One can immediately notice that the above construction suffers from a mix-and-match attack: The server can request decryption of arbitrary combinations of enrollment records and ciphertexts in the decryption phase.
One way to avoid this issue is to let the rate-limiter sign the record-ciphertext pairs as they are created, and let the server prove in zero-knowledge that a decryption request is on a record-ciphertext pair which is blinded / rerandomized from another pair for which it possesses a signature.
However, such an approach seems inefficient since the server likely needs to prove complex statements involving PH protocol execution, PKE encryption, and signature verification.
We also investigate the possibility of building PHE generically from PO-PRF.
Similar to the construction of symmetric-key encryption from PRFs, where a ciphertext C which encrypts message M using key k is computed as C = (PRF(k, r) ⊕ M, r), one idea is to encrypt a message by the output of the PO-PRF as a one-time pad.When instantiated with PYTHIA, the only known construction of PO-PRF, a PRF value is a group element e(H 1 (un), H 2 (pw)) k in the target group of a cryptographic bilinear map e.
A ciphertext of M would thus be C = e(H 1 (un), H 2 (pw)) k · M.
The problem with this approach is that, after key-rotation (from k to rk where r is a random field element), the corresponding ciphertext becomes C = C r = e(H 1 (un), H 2 (pw)) rk · M r , which encrypts M r instead of M.Another idea is to use the output of a PO-PRF as the secret key of a key-homomorphic encryption (KHE) scheme.
However, recall that PRF values of PYTHIA are target group elements, and hence the companion KHE scheme must have target group elements as secret keys.
Assuming the decryption algorithm of the KHE scheme only uses generic group operations, it seems rather difficult to "protect" the secret key, i.e., one may infer the secret key from the ciphertext and its corresponding decryption result by "undoing" the generic group operations involved in decryption.
Additional machinery such as another bilinear map might be needed.
In other words, this approach needs a cryptographic trilinear map of which no known efficient construction exists.
We adopt an alternative approach which upgrades the PH scheme PHOENIX by Lai et al. [16] in a non-blackbox way into an efficient PHE scheme.
The transform is based on the observation below: In the validation protocol of PHOENIX, the server first sends to the rate-limiter a PKE ciphertext encrypting a pseudorandom value generated by the rate-limiter.
The latter decrypts the ciphertext and checks whether the pseudorandom value is wellformed, or equivalently whether the candidate password is valid.
If so, it proves the well-formedness in zeroknowledge to the server.
The rate-limiter essentially provides an "equality check service" to the server.
With this observation, the idea is to turn such a service into a "conditional decryption service" where decryption is performed if the equality check is satisfied.However, we can do even better.
Observe that the use of PKE in PHOENIX is actually not necessary: It does not offer protection against a malicious rate-limiter since the latter knows the decryption key anyway.
It also does not offer protection against a malicious server, since the (password-)hiding property relies on the fact that the server must guess the correct password to derive (a ciphertext of) the pseudorandom value.
We believe that the use of PKE in PHOENIX is inherited from the scheme [20] the authors were trying to fix.In the following, we construct an extremely simple PHE scheme by taking the core idea of PHOENIX, stripping off the PKE operations, and adding a (symmetrickey) encryption mechanism for messages.
The only drawback of removing the PKE operations seems to be that we now explicitly require that the communication between the server and the rate-limiter is done through a secure channel, which was implicitly assumed in PHOENIX 5 .
Along with the simplification and the upgrade, we also let the rate-limiter generate a proof even if the pseudorandom value given by the server, or equivalently the given candidate password, is invalid (which was missing in PHOENIX).
With these modifications the scheme satisfies the strong soundness definition (which subsumes binding), making the rate-limiter more accountable.
Let G be a finite multiplicative cyclic group of order q with identity element I. Let Π.
(Gen, Prove, Vf) be a non-interactive zero-knowledge proof of knowledge (NIZKPoK) scheme for discrete logarithm representations in G (e.g., the generalized Schnorr protocol).
Let H S , H R : {0, 1} * → G be hash functions (to be modeled as random oracles in the security proof).
Let the password space and message space to be P := {0, 1} * and M := G respectively.
Our construction is as follows.Setup and Key Generation (Figure 7).
The setup procedure generates a common reference string crs (which defines H S and H R ) and a generator G of the group G.
The server and the rate-limiter generate their keys using KGen S and KGen R respectively and individually.
The server secret key consists of an integer y ∈ Z q .
The ratelimiter secret key is x ∈ Z q and the public key is X = G x .
Encryption (Figure 8).
When a new end-user registers for a new account with the server, the server engages in an encryption protocol with the rate-limiter.
The server inputs its secret key, the password pw, and the message M, while the rate-limiter inputs its secret key.
(As mentioned in the discussion of the definitions, the input label is always an empty string in real-world usage.)
The protocol is as follows.
In the usual case where is empty, the server and the rate-limiter sample random nonces n S and n R respectively.
These nonces serve asSetup (1 λ ) crs ←$ Π.Gen(1 λ ) G ←$ G return (crs, G) KGen S (pp) pk S ← ε sk S ← y ←$ Z q return (pk S , sk S ) KGen R (pp) x ←$ Z q X ← G x pk R ← X sk R ← x return (pk R , sk R )Figure 7: Setup and Key Generation of PHE session identifiers or pseudonyms of the registering enduser.
Otherwise, if is non-empty, the parties simply parse it as the tuple (n R , n S ).
Next, the parties jointly create the ciphertext(H x R,0 H y S,0 , H x R,1 H y S,1 M y ) 6, where H S,b = H S (pw, n S , b) and H R,b = H R (n R , b) for b ∈ {0, 1} 7 .
To do so, the ratelimiter sends the tuple (H x R,0 , H x R,1 ) along with the ratelimiter nonce n R to the server.
The latter completes the ciphertext by multiplying the tuple with (H y S,0 , H y S,1 M y ) (component-wise).
Finally, the server stores the resulting ciphertext as the record T and the nonces n S and n R as the label for the registering end-user.
Decryption (Figure 9).
When an end user logs in with a candidate password pw, the server looks up its corresponding record T and label , and engages in the decryption protocol with the rate-limiter.
The server inputs its secret key sk S , the label , the record T , and the password pw.
The rate-limiter inputs its secret key sk R and the label .
In a slightly different formulation, we can let the server send with the first message to the rate-limiter.
Recall that the record T is in the form(T 0 , T 1 ) = (H x R,0 H y S,0 , H x R,1 H y S,1 M y ).
To begin, the server computes C 0 as T 0 /H S (pw, n S , 0) y , which is equal to H x R,0 if the password pw is correct.
It sends C 0 to the rate-limiter, who checks if C 0 is indeed equal to H x R,0 .
If so it sends H x R,1 , and a proof that the computation is done faithfully, back to the server.
The latter then verifies the proof, recovers M as (T 1 H −x R,1 H −y S,1 ) 1/y , and outputs the flag f = 1 and the message M. Otherwise, the rate-limiter proves that C 0 and H x R,0 are not equal.
The server verifies the proof and outputs the flag f = 0 (and M = ε).
Key Rotation and Update (Figure 10).
When either one of the server and the rate-limiter is compromised, or due to a regular routine, they may engage in a key rotation protocol to rotate their (public and) secret keys such 6 The purpose of encrypting M y instead of M is to "absorb" the effect of key-rotation to y, so that M does not change after key-rotation.
7 The input b essentially splits H R (and H S ) into two independent hash functions, thus saving the need to have a two-integer secret key.
that they are distributed identically as freshly generated keys.
Then, the server locally runs the update algorithm on each record so that it is valid with respect to the new keys.
Note that the update is done without knowing the passwords and messages corresponding to the records.In the key rotation protocol, the rate-limiter generates a tuple of random integers (α, β ) and sends it to the server 8 .
The latter updates its secret key to y = αy.
Similarly, the rate-limiter updates its secret key to x = αx + β .
It also publishes its new public key X = G x .
To update each encryption record T without knowing the encrypted message and the corresponding password, the server runs the update algorithm on each record T with its label = (n R , n S ).
Recall that a record T is in the form(T 0 , T 1 ) = (H x R,0 H y S,0 , H x R,1 H y S,1 M y ).
The algorithm simply computes T = (T 0 , T 1 ) as (T 0 , T 1 ) =(T α 0 H β R,0 , T α 1 H β R,1 ) =(H αx+β R,0 H αy S,0 , H αx+β R,1 H αy S,1 M αy ) =(H x R,0 H y S,0 , H x R,1 H y S,1 M y ).
Correctness.
The correctness of the scheme follows immediately from the completeness of the NIZKPoK scheme, and is subsumed by the soundness property.
We state our formal results with proof sketches.
Full proofs are postponed to Appendix A.Theorem 1 (Partial Obliviousness) Assume that DDH is hard in G. Then, in the random oracle model, our construction achieves partial obliviousness.Proof 1 (Proof sketch) The proof is based on the observation that the adversary can only obtain (pseudorandom) hashes of(pw * b , M * b ) but not (pw * 1−b , M * 1−b ), since (essentially) the only way to obtain the latter is by querying the decryption oracle on (, pw) where = ( * S , ·) and pw = pw * 1−b , which is refused by the oracle.Theorem 2 (Message Hiding) If Π is zero-knowledge and DDH is hard in G, then our construction achieves message hiding in the random oracle model.
The core of the proof relies on the fact that the adversary must submit a pseudorandom value in order to gain any useful information about the challenge message M * b .
However, since the pseudorandom value is masked by the (pseudorandom) hash of the Encrypt S(sk S , pw, M), · parse pk R as X, parse sk S as y if = ε then parse as (n R , n S ) Figure 8: Encryption Protocol of PHE challenge password pw * , the only way to obtain the value is through guessing pw * .
else n S ← {0, 1} λ endif H S,0 ← H S (pw, n S , 0), H S,1 ← H S (pw, n S , 1) receive (n R ,C, π) from R H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" if Π.Vf(crs, stmt, π) = 0 then return ⊥ endif T ← (C 0 H y S,0 , C 1 H y S,1 M y ) ← (n R , n S ) return ( , T ) Encrypt ·, R(sk R ) parse sk R as x if = ε then parse as (n R , n S ) else n R ← {0, 1} λ endif H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) C = (C 0 ,C 1 ) ← (H x R,0 , H x R,1 ) stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" wit ← x π ← Π.PoK(crs, stmt, wit) send (n R ,C, π) to R return εTheorem 3 (Strong Soundness) If Π is sound and has the proof of knowledge property, then our construction is strongly sound.Proof 3 (Proof sketch) The proof follows almost immediately from the soundness and the proof of knowledge property of Π: An adversary against (strong) soundness must convince an honest server to either draw an incorrect conclusion about the validity of a record or a candidate password, or recover a different message which is not encrypted in the record.
This means that the adversary is able to produce proofs of contradicting statements, one of which must be false.
We can thus use such an adversary as a black-box to break the soundness of Π.Theorem 4 (Forward security) Our construction is perfectly forward secure.Proof 4 (Proof sketch) The truth of the claim follows from the fact that, for any tuples (x, y) and (x , y ) in Z 2 q , there exists a unique mapping (x , y ) = (αx + β , αy) defined by (α, β ) in Z 2 q which maps (x, y) to (x , y ).
We report the performance evaluation of our prototype implementation and discuss the possibility of practical deployment.
We use SHA256 for the hash functions and NIST P-256 for the group G. For the zeroknowledge proofs, we use sigma protocols [7] based on Fiat-Shamir [11] for equality and inequality of discrete logarithm representations.
For a detailed evaluation, we implemented our scheme using the Charm [1] crypto prototyping library and the Falcon Web Framework.
Data is passed through GET parameters to the crypto service and the results are communicated back in JSON.
We used a dedicated virtual machine on an off-the-shelves server and assigned one up to eight cores to the virtual machine.
The host system for the local setup is running nginx and uwsgi on a 10-core Intel Xeon E5-2640 CPU.
For all studies, we assume an https connection with keep-alive.
We consider this realistic for busy sites where a dedicated connection is kept open between the PHE service and the user-facing web server.To estimate the resources needed, we evaluated the throughput of the PHE rate-limiter.
The measurements are obtained using the Apache benchmark tool.
As shown in Figure 11, the PHE crypto service perfectly scales to more cores and can handle more than 525 encryption and (successful) decryption (i.e., registration and login) requests per second (per core).
As shown in Table 1, this is a significant improvement even compared to PHOENIX which has no encryption functional- [16].
Enrollment in PHOENIX is significantly cheaper (1500 requests per second [16]) than encryption in our scheme, as the former does not involve any zero-knowledge proofs.
PYTHIA is even slower due to the pairing-based construction and achieves 129 enrollment or validation requests per second [16].
Decrypt S(sk S , pw, T ), · parse pk R as X parse sk S as y parse T as (T 0 , T 1 ) parse as (n R , n S ) H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) H S,0 ← H S (pw, n S , 0), H S,1 ← H S (pw, n S , 1) C 0 ← T 0 H −y S,0 send C 0 to R receive ( f ,C 1 , π) from R if f = 1 then stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" M ← (T 1 C −1 1 H −y S,1 ) 1/y elseif f = 0 ∧C 1 = I then stmt ← "∃(α, β ) s.t. (C 1 , I) = (C α 0 H β R,0 , X α G β )" M ← ε endif if Π.Vf(crs, stmt, π) = 1 then return ( f , M) endif return (⊥, ε) Decrypt ·, R(sk R ) parse sk R as x parse as (n R , n S ) receive C 0 from S H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) if C 0 = H x R,0 then f ← 1, C 1 ← H x R,1 stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" wit ← x else f ← 0, r ←$ Z q , C 1 ← C r 0 H −rx R,0 stmt ← "∃(α, β ) s.t. (C 1 , I) = (C α 0 H β R,0 , X α G β )" wit ← (α, β ) = (r, −rx) endif π ← Π.PoK(crs, stmt, wit) send ( f ,C 1 , π) to S return εFinally, we measure the throughput of the server.
Since the server needs to perform twice the amount of exponentiations than the rate-limiter does, it is expected that the throughput of the server is roughly half that of the rate-limiter.
This expectation is indeed confirmed by the evaluation Figure 12, in which the server is utilizing the same set of machines as were used for the rate-limiter-side evaluation.
Specifically, the server can process about 250 requests per core per second.
Although no measurement of the server throughput is available for PHOENIX [16], we expect our scheme comes on top since fewer exponentiations (e.g., encryption and rerandomization in PHOENIX) are required.
On the other hand, since the server in PYTHIA does nothing but equality checks, its computation cost should be negligible.Considering current recommendations for best practice [21] on password hashing we note that algorithms like scrypt or Argon2 [3] are usually configured to limit login throughput to tens of requests per second which is significantly slower than the overhead introduced by PHE.
It might be advisable to instantiate H S with such a state-of-the-art hashing function for maximum protection.
When doing so the overhead of PHE becomes tiny.RotateS(sk S ), R(sk R ) Client S Server R parse sk S as y parse sk R as x α, β ←$ Z q (α, β ) y ← αy x ← αx + β τ ← (α, β ) pk S ← ε pk R ← G x sk S ← y sk R ← x return (pk S , sk S , τ) return (pk R , sk R ) Update (τ, T )parse pk R as X parse as (n R , n S ) parse τ as (α, β )parse T as (T 0 , T 1 ) H R,0 ← H R (n R , 0) H R,1 ← H R (n R , 1) T 0 ← T α 0 H β R,0 T 1 ← T α 1 H β R,1 return T ← (T 0 , T 1 ) Regarding the scalability of PHE, we make two remarks.
First, note that the state kept by the rate-limiter for each server is small: It consists of one counter per end user of the server, solely for rate-limiting purposes.
Second, instances of the encryption, decryption, and key rotation protocols (for the same or different servers) are independent.
Thus, it is expected that the throughput of the ratelimiter scales linearly with the number of cores, except for the inevitable overhead for threading.
We envision a practical deployment of the system due to a mutual benefit of all parties -end users, online service providers, and crypto service providers.End Users.
As the end users are registered for the services provided by the online service providers, we assume that the latter is trusted to a certain degree.
Al- though a new party, namely the rate-limiter, is introduced for the transition from an existing, say access-controlbased, data security solution to the more secure PHE solution, the end users need not trust any additional parties due to the obliviousness property against rate-limiters.
In fact, the transition to PHE even reduces trust in the online service providers, since the latter can no longer decrypt user data by themselves.Online Service Providers.
By providing a better security solution for the end users, an online service provider can improve its image which potentially popularizes its services.
The risk of financial losses due to data leakage is also reduced, since attackers would now need to fully compromise both the online service provider and the rate-limiter to decrypt user data.
This is particularly important for small companies whose developers are not specialized in security.
Assuming that the rate-limiters are developed and maintained by security experts, it is a reasonable assumption that these rate-limiters are much harder to attack.Crypto Service Providers.
Crypto service providers have financial incentives to run and maintain ratelimiters, assuming online service providers and end users are willing to invest in better security.
The PHE solution also introduces a better division of labor: Security experts can focus on developing and maintaining ratelimiters which are specialized in security, while online service providers can focus on providing (non-security) services they used to provide.
An existing system can be converted gradually in at least two ways.
As an end user logs in, the server can retrieve the record from the existing system (e.g., salted hash), and create a new record encrypting a random message M using PHE.
To convert the system in a single batch conversion step, assuming the existing system stores passwords in the form of salted hashes (n S , H(n S , pw)), the server samples a random message M, further hashes each record to compute (n S , H y S,0 H y S,1 ) = (n S , H(H(n S , pw), 0) y , H(H(n S , pw), 1) y M y ) (modeling H as a random oracle and interpreting its output as a group element), and communicate with the rate-limiter to complete the PHE record.Either way, the random message M is used as a symmetric key (e.g., for AES) to encrypt the existing (plaintext) profile of the end user, and is discarded after encryption.
Note that for both approaches, the entire transformation happens at the back-end and does not require special actions from the end user.
We have proposed and constructed password-hardened encryption (PHE) services, an extension to passwordhardening (PH) services, which not only protects passwords but also user data stored by an online service provider, even if the latter is fully compromised.
This is achieved with the aid of an external yet minimally trusted rate-limiter.
PHE inherits all useful properties of PH, namely obliviousness, hiding and forward security, and features a stronger soundness property which makes the rate-limiter more accountable.
Forward security, or the ability to rotate secret keys, is particularly important in the data security context and is explicitly required by standards such as the PCI DSS [19].
Our construction is obtained by taking the core idea behind a recent PH scheme PHOENIX [16], greatly simplifying it, and augmenting it with encryption functionality.
The result is an extremely simple and efficient PHE scheme, which can be readily deployed in existing online services without affecting the end users at all or changing the database infrastructure significantly.
The scheme incurs an even milder overhead than existing PH schemes, and scales well to a large number of end users and servers.This work opens up a number of research directions.
First, it would be interesting to explore cryptographic techniques to achieve rate limiting while preserving enduser anonymity and / or do so in a distributed manner with more than one rate-limiter.
The second is to consider a stronger attacker model, in which the attacker can partly observe the messages exchanged between the end user and the server in the decryption phase.
In this setting, it is inevitable for the end user to also perform cryptographic operations, which in turns allows stronger security guarantees.
The third is to revisit other cryptographic primitives in the password-hardened paradigm.
Given the seamless nature of such paradigm (in the view of the end users), it is more likely for the cryptographic primitives to be deployed.
Finally, new constructions, perhaps based on other (e.g., lattice-based) complexity assumptions or without using the random oracle, and more efficient instantiations are always welcome.Message Hiding.
If the DDH assumption holds in G, Π is zero knowledge, and H S and H R are modeled as random oracles, then PHE is message hiding.
We prove formally by defining a sequence of hybrid experiments, each differs slightly from the previous:Exp b,0 : is identical to Hid b PHE,A .
Exp b,1 :The proofs are now simulated using the simulator guaranteed by the zero-knowledge property of Π.
This experiment is computationally indistinguishable from Exp b,0 by the zero-knowledge property of Π.
Exp b,2 : The challenger simulates the random oracles H S and H R as follows.
When H S (resp.
H R ) is queried on some input m, the challenger samples a ←$ Z q and programs H S (m) := G a (resp.
H R (m) := G a ).
This experiment is functionally equivalent to Exp b,1 .
Exp b,3 : The challenger replaces the function H R (m) x by a random function.
The indistinguishability of Exp b,3 to Exp b,2 follows from the DDH assumption in the random oracle model [18].
Exp b,4 : When A queries the decryption oracle with the label = (·, * R ), the challenger always rejects, i.e., it outputs a simulated proof that the value C 0 is invalid.
In the following, we show that a distinguisher which distinguishes this experiment from Exp b,3 cannot succeed with a probability higher than that of guessing the password pw * , except with negligible probability.
Then, the proof is done since Exp 0,4 and Exp 1,4 are functionally identical.After the modification made in Exp b,3 , note that the challenger essentially acts as a conditional decryption oracle which, on input (n R ,C 0 ), checks if the ciphertext is well-formed, i.e., whether C 0 = H R (n R , 0) x (which is programmed to a random value), and if so outputs C 1 = H R (n R , 1) x with a simulated proof of correctness.
Otherwise, it outputs a simulated proof of the statement that C 0 and C 0 = H R (n R , 0) x are not equal.Recall that the challenge record is computed asT * 0 T * 1 = H R (n * R , 0) x H S (pw * , n * S , 0) y H R (n * R , 1) x H S (pw * , n * S , 1) y (M * b ) ywhere H R (n * R , 0) x and H R (n * R , 1) x are all uniformly random values in the view of A. Thus, in the experiment Exp b,3 , the only information of (pw * , M * b ) available to A, apart from the challenge record, is obtained via interacting with the decryption oracle, which always rejects unless A guesses the uniformly random value H R (n * R , 0) x correctly, which equivalently means guessing the value H S (pw * , n * S , 0) correctly.
Since H S is a random oracle, it holds except with negligible probability that A has queried H S at the point (pw * , n * S , 0).
Thus, the challenger can extract pw * .
Soundness.
If Π is sound and has the proof of knowledge property, then PHE is strongly sound.To prove such claim, we observe that if there exists an adversary A which causes either of the soundness experiments to output 1, then the challenger can extract two proofs for two contracting statements respectively, which breaks the soundness of Π.
We can assume the server acted by A never aborts (else the experiment outputs 0).
Suppose there exists A such that the experiment Soundness PHE,A outputs 1 with non-negligible probability.
There are two cases.
First, (pw = pw ∧ ( f = 1 ∨ M = M )).
Second, (pw = pw ∧ f = 0).
In either case, the challenger receives upon conclusion of the encryption protocol a proof for the statement "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )".
Then, in the first case, suppose the first sub-case f = 1 happens.
It means that the challenger receives a proof for the statement "∃(α, β ) s.t. (C 1 , I) = (C α 0 H β R,0 , X α G β )", which equivalently means "∃x s.t. C 0 = H x R,0 ∧ X = G x )".
Since the statements are contradictory, either one is false.
The challenger can thus be turned into an adversary against the soundness of Π.
Similarly, in the second sub-case, M = M .
This means that the challenger has a proof of "∃x s.t. (C 1 , X) = (H x R,1 , G x )" for some C 1 = C 1 , another contradicting statement.For the second case, since pw = pw , the challenger sends C 0 which is not equal to C 0 except with negligible probability to A in the decryption protocol.
The contradicting statement here is then "∃x s.t.(C 0 , X) = (H x R,0 , G x )".
The analysis of the other experiment is similar.
We describe it for completeness.
Suppose there exists A such that the experiment StrongSoundness PHE,A outputs 1 with non-negligible probability.
There are again two cases.
First, ((, pw) = ( , pw ) ∧ ( f , M) = ( f , M )).
Second, ((, pw) = ( , pw ) ∧ f = f = 1).
For the first case, since (, pw) = ( , pw ) the same message C 0 is sent from the challenger to A in the decryption protocols.
We then split into two subcases.
First, f = 0 but f = Forward Security.
We show that PHE is perfectly forward secure.
To prove such claim, it suffices to show that the secret keys sk S and sk R output from the rotation protocol are identically distributed as fresh secret keys.
The public keys and the records are uniquely determined by the secret keys.For any client and server secret keys x and y, there is a one-to-one correspondence between each fresh key pairs (x , y ) ∈ Z 2 q and each tuple of randomness (α, β ) ∈ Z 2 q chosen in the rotation protocol, given byx = αx + β y = αy ≡ α = y /y β = x − αx .
Thus, the distribution of (x , y ) which is sampled uniformly from Z 2 q and that which is computed from a uniformly random tuple (α, β ) are identical.
This research is based upon work supported by the German research foundation (DFG) through the collaborative research center 1223, by the German Federal Ministry of Education and Research (BMBF) through the project PROMISE (16KIS0763), and by the state of Bavaria at the Nuremberg Campus of Technology (NCT).
NCT is a research cooperation between the Friedrich-AlexanderUniversität Erlangen-Nürnberg (FAU) and the Technische Hochschule Nürnberg Georg Simon Ohm (THN).
This work is partially supported in parts by Germany/Hong Kong Joint Research Scheme (G-CUHK406/17) of the Germany Academic Exchange Service (DAAD) and the Research Grants Council (RGC), University Grant Committee of Hong Kong, and General Research Funds (CUHK 14201914) of RGC.
Part of the work of the first author was done when he was with The Chinese University of Hong Kong.This work is also partially supported by the European Research Council (ERC) under the European Union's Horizon 2020 research (grant agreement No 771527-BROWSEC), by Netidee through the project EtherTrust (grant agreement 2158), by the Austrian Research Promotion Agency through the Bridge-1 project PR4DLT (grant agreement 13808694) and COMET K1 SBA.
sPartial Obliviousness.
If the DDH assumption holds in G, and H S is modeled as a random oracle, then PHE is partially oblivious.
We prove by defining a sequence of hybrid experiments for b ∈ {0, 1}, each differs slightly from the previous:The challenger simulates the random oracle H S as follows.
If A queries H S directly on an input X, the challenger samples a random integer a ←$ Z q and programs H S (m) := G a .
However, if H S is invoked by the challenger when executing the encryption protocol on the password pw and the message M (and the empty label ε), it samples n S ←$ {0, 1} λ and programs H S such that H S (pw, n S , 0) = G a 0 and H S (pw, n S , 1)M = G a 1 for random integers a 0 , a 1 ←$ Z q , assuming H S has not been programmed on (pw, n S , 0) and (pw, n S , 1).
The latter assumption holds except with negligible probability as n S is uniformly random.
If the above assumption holds, this experiment is functionally equivalent to Exp b,0 .
Exp b,2 :The challenger replaces the values H S (pw, n S , 0) y and (H S (pw, n S , 1)M) y by random values.
This experiment is computationally indistinguishable to Exp b,1 by the DDH assumption [18].
In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 .
The experiments Exp 0,2 and Exp 1,2 are thus identical in the view of A. Partial Obliviousness.
If the DDH assumption holds in G, and H S is modeled as a random oracle, then PHE is partially oblivious.
We prove by defining a sequence of hybrid experiments for b ∈ {0, 1}, each differs slightly from the previous:The challenger simulates the random oracle H S as follows.
If A queries H S directly on an input X, the challenger samples a random integer a ←$ Z q and programs H S (m) := G a .
However, if H S is invoked by the challenger when executing the encryption protocol on the password pw and the message M (and the empty label ε), it samples n S ←$ {0, 1} λ and programs H S such that H S (pw, n S , 0) = G a 0 and H S (pw, n S , 1)M = G a 1 for random integers a 0 , a 1 ←$ Z q , assuming H S has not been programmed on (pw, n S , 0) and (pw, n S , 1).
The latter assumption holds except with negligible probability as n S is uniformly random.
If the above assumption holds, this experiment is functionally equivalent to Exp b,0 .
Exp b,2 :The challenger replaces the values H S (pw, n S , 0) y and (H S (pw, n S , 1)M) y by random values.
This experiment is computationally indistinguishable to Exp b,1 by the DDH assumption [18].
In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 .
The experiments Exp 0,2 and Exp 1,2 are thus identical in the view of A.
