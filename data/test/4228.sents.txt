New advances in machine learning have made Automated Speech Recognition (ASR) systems practical and more scal-able.
These systems, however, pose serious privacy threats as speech is a rich source of sensitive acoustic and textual information.
Although offline and open-source ASR eliminates the privacy risks, its transcription performance is inferior to that of cloud-based ASR systems, especially for real-world use cases.
In this paper, we propose Prεεch, an end-to-end speech transcription system which lies at an intermediate point in the privacy-utility spectrum.
It protects the acoustic features of the speakers' voices and protects the privacy of the textual content at an improved performance relative to offline ASR.
Additionally, Prεεch provides several control knobs to allow customizable utility-usability-privacy trade-off.
It relies on cloud-based services to transcribe a speech file after applying a series of privacy-preserving operations on the user's side.
We perform a comprehensive evaluation of Prεεch, using diverse real-world datasets, that demonstrates its effectiveness.
Prεεch provides transcription at a 2% to 32.25% (mean 17.34%) relative improvement in word error rate over Deep Speech, while fully obfuscating the speakers' voice biometrics and allowing only a differentially private view of the textual content.
New advances in machine learning and the abundance of speech data have made Automated Speech Recognition (ASR) systems practical and reliable [5,17].
ASR systems have achieved a near-human performance on standard datasets [5,17], at a scale.
This scalability is desirable in many domains, such as journalism [25], law, business, education, and health care, where cost, delay, and third-party legal implications [29] prohibit the application of manual transcription services [12].
For example, recent research has identified private voice transcription as one of the challenges journalists face when interviewing sensitive sources [25].
Several companies, such as Google and Amazon, provide online APIs for speech transcription.
This convenience, however, comes at the cost of privacy.
A speech recording contains acoustic features that can reveal sensitive information about the user, such as age, gender [39], emotion [4,40], accent, and health conditions [41].
The acoustic features are also biometric identifiers of the speakers [26], enabling speaker identification and impersonation [20].
Additionally, the textual content of speech can be sensitive [29].
For example, medical recordings can contain private health information about patients [12], and business recordings can include proprietary information.
Current cloud services already support several speech processing APIs like speaker identification and diarization.
They also support text analysis APIs, such as topic modeling, document categorization, sentiment analysis, and entity detection ( Sec. 3.2), that can extract sensitive information from text.
Applying these APIs to the recorded speech can significantly undermine the user's privacy.Offline and open-source transcription services, like Deep Speech [18], solve these privacy challenges as the speech files never leave the user's trust boundary.
However, we find that their performance does not match that of a cloud service provider [45], especially on real-world conversations and different accents (Sec. 2.2).
Thus, the primary goal of this paper is to: provide an intermediate solution along the utilityprivacy spectrum that uses cloud services while providing a formal privacy guarantee.We present Prεεch (Privacy-Preserving Speech) as a means to achieve this goal; it is an end-to-end speech transcription system that: (1) protects the users' privacy along the acoustic and textual dimensions; (2) improves the transcription performance relative to offline ASR; and (3) provides the user with control knobs to customize the trade-offs between utility, usability, and privacy.
Textual Privacy: Prεεch segments and shuffles the input speech file to break the context of the text, effectively transforming it into a bag-of-words.
Then, it injects dummy (noise) segments to provide the formal privacy guarantee of differential privacy (DP) [13].
Acoustic Privacy: Prεεch applies voice conversion to protect the acoustic features of the input speech file and ensure noise indistinguishability.We evaluate Prεεch over a set of real-world datasets covering diverse demographics.
Our evaluation shows that Prεεch provides a superior transcription accuracy relative to Deep Speech, the state-of-the-art offline ASR.
Also, Prεεch prevents cloud services from extracting any user-specific acoustic features from the speech.
Finally, applying Prεεch thwarts the learning of any statistical models or sensitive information extraction from the text via natural language processing tools.In summary, the main contributions of this paper are: (1) End-to-end practical system: We propose Prεεch, a new end-to-end system that provides privacy-preserving speech transcription at an improved performance relative to offline transcription.
Specifically, Prεεch shows a relative improvement of 2% to 32.52% (mean 17.34%) in word error rate (WER) on real-world evaluation datasets over Deep Speech, while fully obfuscating the speakers' voice biometrics and allowing only a DP view of the textual content.
(2) Non-standard use of differential privacy: Prεεch uses DP in a non-standard way, giving rise to a set of new challenges.
Specifically, the challenges are (1) "noise" corresponds to concrete words, and need to be added in the speech domain (2) "noise" has to be indistinguishable from the original speech (details in Sec. 4.5).
(3) Customizable Design: Prεεch provides several control knobs for users to customize the functionality based on their desired levels of utility, usability, and privacy (Sec. 7.4).
For example, in a relaxed privacy setting, Prεεch's relative improvement in WER ranges from 44% to 80% over Deep Speech (Sec. 7.4.1).
The full version of this paper is available online [3], and some demonstrations of Prεεch are available at this link [2].
We first provide some background on online and offline speech transcription services.
Next, we present a utility evaluation using standard and real-world speech datasets.
Speech transcription refers to the process of extracting text from a speech file.
ASR systems are available to the users either through cloud-based online APIs or offline software.
(1) Cloud-Based Transcription: We utilize two cloud-based speech transcription services -Google's Cloud Speech-toText and Amazon Transcribe.
(2) Offline Transcription: We consider the Deep Speech architecture from Baidu [18], which is trained using Mozilla's 1 Common Voice dataset as a representative offline transcription 1 https://voice.mozilla.org/en/datasets service.
This dataset is crowdsourced and open-source.
Specifically, we use the Deep Speech 0.4.1 model 2 (released in January 2019).
Note that we do not consider offline transcribers that are not open for general use.
For example, Google's ondevice speech recognizer [1] is an offline transcriber that is currently only supported on Google's Pixel devices and does not allow an API or open-source access, limiting its usability.Notations: Let S denote the input speech file associated with a ground truth transcript T g S .
The user can either use a cloud service provider (CSP) or an offline service provider (OSP) to obtain the transcript (denoted by T CSP S or T OSP S , respectively).
Transcription Accuracy: The standard metric for quantifying the accuracy loss from transcription is the word error rate (WER) [18].
WER treats the transcript as a sequence of words.
It models the difference between the two sequences by counting the number of deleted words (D), the number of substituted words (U), and the number of injected words (I).
If the number of words in T g S is W , WER is given as: D+U+I W .
In this section, we empirically evaluate the utility gap between the CSP and the OSP over a wide range of standard and realworld datasets.
We use these datasets throughout the paper.
Standard Datasets: These datasets include (1) the TIMIT-TEST subset [16], (2) a subset from Librispeech dev-clean dataset [31], and (3) the DAPS dataset [28].
TIMIT-TEST 3 subset comprises of 1344 utterances by 183 speakers from eight major dialect regions of the United States.
The LibriSpeech subset consists of eleven speakers, 20 utterances each.
For DAPS, we use the evaluation subset prepared for the 2018 voice conversion challenge [24] that consists of five scripts read by ten speakers: five males and five females.
Real-world Datasets: We also assess the real-world performance of both transcription services on non-American accent datasets and real conversations among speakers of different demographics.
For the accented datasets, we evaluate 200 utterances of two speakers from the VCTK dataset [46]: speaker p262 of a Scottish accent and speaker p266 of an Irish accent.
For the real-world datasets, we evaluate 20 minutes of speech from the "Facebook, Social Media Privacy, and the Use and Abuse of Data" hearing before the U.S. Senate 4 .
We construct the 20 minutes by selecting three continuous chunks of speech from the hearing such that they include nine speakers: 8 senators and Mark Zuckerberg.
Another real-world dataset is the Supreme Court of the United States case "Carpenter v. United States" 5 We study the privacy threats that a cloud-based transcription service poses while processing private speech data.
The biometric information embedded in S can leak sensitive information about the speakers, including their emotional status [4,40], health condition [41], sex [39], and even identity [26].
Furthermore, extracting this information enables critical attacks like voice cloning and impersonation attacks [23,47].
In this section, we showcase a few representative examples of how cloud-based APIs can pose serious privacy threats to the acoustic features within S. Speaker Diarization: CSPs utilize advanced diarization capabilities to cluster the speakers within a speech file, even if they have not been observed before.
The basic idea is to (1) segment the speech file into segments of voice activity, and (2) extract a speaker-specific embedding from each segment, such that (3) segments with close enough embeddings should belong to the same speaker.
We verified the strength of the diarization threat over three multi-speaker datasets: VCTK (mixing p266 and p262), Facebook, and Carpenter.
We measure the performance of the IBM diarization service using Watson's Speech-to-Text API 6 via Diarization Error Rate (DER).
DER estimates the fraction of time the speech file segments are not attributed to the correct speaker cluster.
The DER values are 0%, 4.85%, and 1.32% for the three 6 https://www.ibm.com/cloud/watson-speech-to-text datasets, respectively.
Hence, the API can correctly distinguish between, and cluster, the different speakers, more than 95% of the entire dataset duration despite lacking any prior information about the individual speakers.Speaker Identification: A speaker identification task maps the speech segments in a speech file to an individual.
We use the Azure Identification API, which consists of two stages: (1) user enrollment and (2) identification (whether a given voice sample matches any of the enrolled users).
The enrollment stage requires only 30 seconds of speech from each user to extract their voice-print.
We enrolled 22 speakers as follows: 10 from DAPS, two from VCTK, two from Carpenter, and eight from Facebook.
The identification accuracy was nearly 100% for all speakers.Speaker Cloning and Impersonation: Lastly, we applied a Tacotron-based speech synthesizer from Google [20]; a network that can synthesize speech in the voice of any speaker.
The network generates a target speaker's embedding, which it uses to synthesize speech on a given piece of text.
In our setting, we used the network to generate the speakers' embedding in our evaluation datasets.
Then, we synthesized eight speech utterances using the embeddings of each speaker.
We enrolled the speakers in Azure's Speech Identification API using their natural voice samples and tested whether the API will map the synthesized segments to the corresponding speaker.
Except for the second speaker in Carpenter, the cloned samples were successfully identified as the true speakers.
CSPs possess natural language processing (NLP) capabilities that enable automated statistical analyses on large sets of documents.
Those analyses fall into two broad categories.
The first type involves identifying specific words from the transcript that correspond to sensitive information such as an address, name, and SSN using named-entity extraction [14].
The other type of analysis involves statistically analyzing the entire transcript on the whole to extract some semantic or user-identifying information.
This analysis uses two types of information: the set of words (i.e., bag-of-words representation of the transcript) and their order of appearance (to capture the context).
Bag-of-Words Analysis: One of the most commonplace analysis that treats a document as a bag-of-words is topic modeling [37,43].
Topic modeling is an unsupervised machine learning technique that identifies clusters of words that best characterize a set of documents.
Another popular technique is stylometry analysis, which aims at attributing authorship (in our case, the speaker) of a document based on its literary style.
It is based on computing a set of stylistic features like mean word length, words histogram, special character count, and punctuation count from the disputed document [30].
Context-based Analysis: An example of context-based analysis is sentiment analysis (understanding the overall attitude in a block of text).
Text categorization is another example; it refers to classifying a document according to a set of predetermined labels.
Our discussion in the previous sections highlights a trade-off between privacy and utility.
The OSP provides perfect privacy at the cost of higher error rates, especially for non-standard speech datasets.
On the other hand, clear privacy violations accompany revealing the speech recording to the CSP.
Motivated by this trade-off, we present Prεεch, a practical system that lies at an intermediate point along the utility-privacy spectrum of speech transcription.
We consider the scenario where users have audio recordings of private conversations that require high transcription accuracy.
For example, a journalist with recordings of confidential interviews is a paradigmatic user for Prεεch.
Other examples include a therapist with recordings of patient therapy sessions or a course instructor with oral examination records of students.
Prεεch, however, does not target real-time transcription applications.
For example, voice assistants and online transcription (e.g. a live-streaming press conference) are out-of-scope.
Thus, for our target use cases, the latency of transcription is not a critical concern.
The adversary is the CSP or any other entity having direct or indirect access to the stored speech at the CSPs.
This adversary is capable of the aforementioned voice-and text-based analysis.
Prεεch provides an end-to-end tunable system which aims at satisfying the following design goals:1.
protect the users' privacy along the acoustic and textual dimensions; 2.
improve on the transcription accuracy compared to offline models; and 3.
provide the users with control knobs to customize Prεεch's functionality according to their desired level of utility, usability, and privacy.To this end, Prεεch applies a series of privacy-preserving operations to the input speech file before sending it to the CSP.
Fig. 1 shows the high-level overview of Prεεch.
Below, we briefly describe Prεεch's privacy-preserving operations.
Prεεch protects the privacy of the textual content of an input speech file S through the following three operations:Segmentation and shuffling: Prεεch breaks S into a sequence of segments, denoted by S.
This is followed by shuffling the segments to remove all ordering information.
Thus, segmenting and shuffling S transform its textual content into a bag-of-words representation.Sensitive word scrubbing (SWS): First, Prεεch applies the OSP to identify the list of sensitive keywords that contain numbers, proper nouns, or any other user-specified words.
Next, Prεεch applies keyword spotting, KWS, (identify portions of the speech that correspond to a keyword) to each of the segments in S. Only the segments that do not contain a keyword pass to the CSP for transcription.Dummy word injection to ensure differential privacy:The bag-of-words representation of a transcript corresponds to its word histogram (Sec. 4.5).
As discussed in Sec. 3.2, several statistical analyses can be built on the word histogram of the transcript T CSP S such as topic modeling or stylometry analysis.
Thus, protecting the privacy of this word histogram is a primary focus of Prεεch, and the privacy guarantee we choose is that of differential privacy.
To this end, Prεεch ensures DP by adding a suitable amount of dummy words to S before sending it to the CSP.
This way, the CSP is allowed only a differentially private view of the word histogram and any subsequent statistical model built over it (by Thm.
4.1 in Sec. 4.5).
The main challenge in this setting is that the dummy words must be added in the speech domain, which Prεεch addresses as follows.
First, Prεεch estimates the general domain of the text for S (specifically its vocabulary, details in Sec. 4.5) from T OSP S .
Next, it generates dummy text segments using a state-of-the-art NLP language model.
Finally, Prεεch applies text-to-speech (TTS) transforms to these dummy segments and adds them to S. However, leaving it just at this would be insufficient as the CSP can potentially distinguish between the two different sources of speech (TTS generated dummy segments and segments in S) based on their acoustic features.
Therefore, Prεεch provides the user with multiple options to synthesize indistinguishable dummy segments, namely (1) voice cloning [20], and (2) voice conversion [21,44].
These options offer different trade-offs between utility, usability, and privacy (Secs. 4.5.2 and 4.6).
As stated in Sec. 3.2, textbased attacks exploit individual sensitive words or the order of the words or the word histogram.
Thus, from the above discussion, Prεεch protects privacy along all three dimensions (evaluation results in Sec. 7).
Voice conversion, VC, is a standard speech processing technique that transforms the voice of a source speaker of a speech utterance to that of another speaker.
Prεεch applies voice conversion to fulfill a two-fold agenda.
First, it obfuscates the sensitive voice biometric features in S. Second, VC ensures that the dummy segments (noise added to ensure differential privacy) are acoustically indistinguishable from the original speech file segments.
There are two main categories in voice conversion: one-to-one VC, and many-to-one VC ( Sec. 4.6).
Fig. 1 depicts the workflow of Prεεch.
Given a speech file S, the first step (1) is to break S into a sequence of disjoint and short speech segments, S.
This is followed by (2) sensitive word scrubbing where speech segments containing numbers, proper nouns, and user-specified keywords are removed from S. Next, (3) given the domain of S's textual content (its vocabulary), Prεεch generates a set of text segments (as is suitable for satisfying the DP guarantee as discussed in Sec. 4.5), and subjects it to TTS transformation (4).
At this point, Prεεch has audio segments for the input speech, S, as well as the dummy segments, S d .
If the user also wants to hide the voice biometric information in S, Prεεch applies (5) voice conversion over all the segments in S S d to convert them to the same target speaker.
This process hides the acoustic features of S and ensures that the segments in S and S d are indistinguishable.
This is followed by Prεεch partitioning S across N > 0 non-colluding CSPs (Sec. 4.5).
This partitioning reduces the number of dummy segments that are required to achieve the DP guarantee (Sec. 4.5).
Next, Prεεch adds a suitable amount of dummy segments from S d to each partition S i , i ∈ [N] and shuffles them.
Additionally, Prεεch keeps track of time-stamps of the dummy segments, T S i and order of shuffling, Order i for each such partition (6).
After obtaining the transcript (7) for each partition from the N CSPs, Prεεch removes S d 's transcripts and de-shuffles the remaining portion of the transcript using T S i and Order i , and outputs the final transcript to the user (8).
In what follows, we elaborate on the key components of Prεεch, namely segmentation, sensitive word scrubbing, DP word histogram release, and voice conversion.
A key component of Prεεch is breaking the textual context by segmenting S.
We represent S as a sequence of segments S, where each segment can contain multiple words.
Prεεch applies a hierarchical segmentation approach that starts with a stage of silence detection based on the energy level, followed by pitch detection to detect speech activity for finer segmentation.
The mechanism is illustrated in Fig. 2.
We define a period of silence as the time duration when the RMS power of the speech signal drops below -35 dB for at least 500ms.
The initial segmentation stage detects such silence periods from S resulting in coarse segments.
A human speech signal can be viewed as a modulated periodic signal where the signal period is referred to as the glottal cycle [27].
In the second stage, Prεεch uses the existence of glottal cycles [7] to detect human voice, which breaks down the coarse segments into finer ones.
A time duration of at least 20 ms without the presence of glottal cycles is regarded as non-speech.
As some segments might be abrupt or too short to allow for correct speech recognition, Prεεch performs two additional optimization steps.
First, it merges nearby fine segments to ensure a minimum length per segment.
Second, it does not partition segments at the boundaries of the identified human speech and allows 40 ms of non-speech to be included at the beginning and the end of each segment.Control Knob: Segmenting S presents with a trade-offsmaller segments result in better privacy guarantee at the expense of deteriorated transcription accuracy due to semantic context loss.
Prεεch allows the user to tune the minimum length of the segments as a means to control this trade-off.
Prεεch performs sensitive word scrubbing (SWS) as follows.
First, it obtains the offline transcript of S, T OSP S .
Next, it applies named entity recognition (NER) on T OSP S .
NER is an NLP technique that seeks to locate and classify named entities in text into pre-defined categories such as the names of persons, organizations, locations, expressions of times, monetary values, etc.
Prεεch also gives the option for users to specify some keywords of their choice.
This allows customization of the sensitive keyword list as users have subjective ideas of what they might consider sensitive.After the list of sensitive words is finalized, Prεεch applies keyword spotting (KWS) on the segments.
KWS is needed for the following three reasons.
First, KWS is used to spot the userdefined keywords which cannot be identified by NER.
Second, the initial T OSP S is generated on S without segmentation to achieve the highest estimation accuracy.
However, for Prεεch, we need to identify the segments containing the keywords.
Finally, the OSP might not transcribe the named-entities correctly at all locations.
For example, the name "Carpenter" might be repeated 20 times in S, while the OSP transcribes it accurately only five times.
KWS has higher accuracy in spotting keywords than the OSP's transcription accuracy.Control Knob: KWS takes the list of keywords and matches them phonetically to a speech file based on a sensitivity score.
This sensitivity score sets a threshold for the phonetic similarity required for a keyword to be spotted.
A low score results in false positives by flagging phonetically similar words as keywords which degrades the utility by transcribing non-sensitive segments using the OSP.
Conversely, a high score could result in some keywords being missed and revealed to the CSP.
Hence, the sensitivity score is a trade-off parameter between privacy and utility (Sec. 7.3.1).
We define vocabulary, V , to be the domain of non-stop and As discussed in Sec. 3.2, the aforementioned word histogram is sensitive and can only be released to the CSP in a privacypreserving manner.
Our privacy guarantee of choice is DP which is the de-facto standard for achieving data privacy [11,13,15].
DP provides provable privacy guarantees and is typically achieved by adding noise to the sensitive data.Definition 4.1 ((ε, δ)-differentially private d-distant his- togram release).
A randomized mechanism A : N |V | → N |V | ,which maps the original histogram into a noisy one, satisfies (ε, δ)-DP if for any pair of histograms H 1 and H 2 such that||H 1 − H 2 || 1 = d and any set O ⊆ N |V | , Pr[A(H 1 ) ∈ O] ≤ e ε · Pr[A(H 2 ) ∈ O] + δ.
(1)In our context, the DP guarantee informally means that from the CSP's perspective, the observed noisy histogram, ˜ H, could have been generated from any histogram within a distance d from the original histogram, H.
We define the set of all such histograms to be the ε-indistinguishability neighborhood for H.
In other words, from˜Hfrom˜ from˜H the CSP will not be able to distinguish between T CSP S and any other transcript that differs from T CSP S in d words from V .
An important result for differential privacy is that any postprocessing computation performed on the output of a differentially private algorithm does not cause any loss in privacy.Theorem 4.1.
(Post-Processing) Let A : X → R be a randomized algorithm that is (ε, δ)-DP.
Let f : R → R be an arbitrary randomized mapping.
Then f • A : X → R is (ε, δ)- Another result is that the privacy of DP-mechanism can be amplified if it is preceded by a sampling step.Theorem 4.2.
Let A be an (ε, δ)-DP algorithm and D is an input dataset.
Let A be another algorithm that runs A on a random subset of D obtained by sampling it with probability β.
Algorithm A will satisfy (ε , δ )-DP where ε = ln(1 + β(e ε − 1)) and δ < βδ.Additionally, we define a DP mechanism namely the truncated Laplace mechanism [6] which is used in Prεεch.
p = e ε/d −1 e ε/d +1 and η 0 = − d·ln((e ε/d +1)δ) ε + d.Theorem 4.3.
The truncated Laplace mechanism satisfies (ε, δ)-DP for d-distant histogram releases [6].
Prεεch's use of DP is different from the most standard usecase of DP (like numeric datasets).
It deals with concrete units like words instead of numeric statistics -introducing new challenges; we discuss these challenges and how Prεεch circumvents them in this section.
Vocabulary definition: The foremost task for defining the word histogram is defining the vocabulary, V .
The most conservative approach to define V is to consider the total set of all English stemmed and non-stop words.
Such a vocabulary would be prohibitively large for efficient and practical usage.However, note that such a definition of V is an overestimate as no real-world document would contain all possible English words.
Recall that our objective of adding noise is to obfuscate any statistical analysis built on top of the document's BoW (histogram), such as a topic modeling and stylometry analysis.
Typically, BoW based statistical analyses are concerned only with the set of most frequent words.
For example, any standard topic model captures only the top m percentile most frequent words in a transcript [37,43].
The same applies to stylometry analysis, which is based on measures of the unique distribution of frequently used words of different individuals.Thus, as long as the counts of the most common words of the transcript are protected (via DP), the subsequent statistical model (like topic model) built over the word histogram will be privacy-preserving too (by Thm.
4.1).
However, highfrequency words might not be the only ones that contain important information about T S .
To tackle this, we also include words with large Term Frequency-Inverse Document Frequency (TF-IDF) weight to our vocabulary.
This weight is a statistical measure used to evaluate how significant a word is to a document relative to a baseline corpus.
The weight increases proportionally to the number of times a word appears in the document but is offset by the frequency of the word in the baseline corpus.
This offset adjusts for the fact that some words appear more frequently in general.
To this end, Prεεch makes an estimate of the vocabulary from T OSP S .
Although existing offline transcribers have high WER, we found (empirically) that they can identify the set of domain words of S with high accuracy (details in Sec. }}
.
Note that V should be devoid of all sensitive words which are scrubbed off from S in step 2 of Fig. 1.
Additionally, the vocabulary can be extended to contain out-of-domain words, i.e., random English words that are not necessarily part of the original document.
This helps in protecting against text classification attacks (Sec. 7.3).
Specificities of the word histogram: As discussed above, the goal of the DP mechanism is to generate noisy counts for each w i ∈ V .
An artifact of our setting is that this noise has to be non-negative and integral.
This is because dummy words (for the noisy counts) can only be added to S; removing any word from S is not feasible as this would entail in recognizing the word directly from S, which would require accurate transcription.
Hence, Prεεch uses the truncated Laplace mechanism to ensure non-negative and integral noise.
Setting privacy parameters: The parameters ε and δ quantify the privacy provided by a DP-mechanism; lower the values higher is the privacy guarantee achieved.
The distance parameter d, intuitively, connects the privacy definition in the word histogram, which is purely a formal representation, to a semantic privacy notion.
For example, it can quantify how much the noisy topic models computed by the CSP (from T CSP S ) should differ from that of T g S .
Thus, the user can tune d depending on the target statistical analysis.
In the following, we detail a mechanism, as a guide for the user, for choosing d when the target statistical analysis is topic modeling.Let us assume that the user has a set of speech files {S j } to be transcribed.
Let D j denote the ground truth transcript corresponding to speech file S j .
The objective is to learn t topics from the corpus j D j with at least k words per topic (a topic is a distribution over a subset of words from the corpus).
Let T = {T 1 , · · · , T t } represent the original topic model built on j D j = j T g S j and T = T 1 , · · · , Tt represent the noisy topic model computed by the CSP.The following theorem (Thm.
4.4) provides a lower bound on the pairwise 1 distance between the true and noisy topics as a function of the privacy parameters of the DP word histogram release mechanism (specifically, the term C min is a function of (d, ε, δ)).
(T, T ) ∈ T × T , ||T − T || 1 ≥ 2 1 1−(t−1) k max j |D j | C min t − 1 2 1 − t k max j |D j || , where C min = min j,l v·(|D j |−|w l, j |ω j ) |D j |·(|D j |+v·ω j ), |D j | is the total number of words in D j , ω j is the total number of unique words, v is the variance of the distribution Lp(ε , δ , d), δ = βδ and |w l, j | is the number of times the word w l ∈ V appears in D j .
The proof of this theorem and the descriptions of the parameters are presented in the full paper [3] .
Dummy word injection: As discussed earlier, achieving differential privacy requires adding dummy words to S. Prεεch generates the dummy text corpus using an NLP language model (Sec. 6).
The model takes in a short text sample from the required topic and generates an entire document of any required length based on that input.
In some scenarios, the user can also provide a corpus of non-publicly available documents with the same vocabulary.
This scenario is valid in many practical settings.
For instance, in an educational institution, the sensitive speech files requiring transcription might be the interviews/oral exams of the students conducted on a specific subject, and the noise corpus can be the lecture notes of the same subject.Next, Prεεch generates a set of dummy segments, S d , from the dummy corpus above.
Let us assume that each of the true segments contains at most k non-stop words (depends on the segment length).
Prεεch ensures that each dummy segment also contains no more than k non-stop words.
Additionally, each such segment must contain only one word from the vocabulary V .
This means that although the physical noise addition is carried at the segment level, it is still equivalent to adding noise at the level of words (belonging to V ) as we only care about w i ∈ V .
Each dummy segment is injected only once per CSP.
Since the dummy segments have to be added in the speech domain, Prεεch applies TTS transforms to the segments in S d such that they have the same acoustic features as S.
This condition ensures that S d are indistinguishable from S in terms of their acoustic features.
Prεεch provides the user with two broad options to satisfy this conditionvoice cloning or voice conversion.Voice cloning is a TTS system that generates speech in a target speaker voice.
Given a speech sample from the target speaker, the system generates an embedding of the speaker's voice biometric features.
It uses this embedding to synthesize new utterances of any linguistic content in the target speaker's voice.
Prεεch utilizes such a technology to clone the original speaker's voice and uses it to generate acoustically similar dummy segments S d .
Prεεch applies a state-of-the-art voice cloning system [20], which generates a close-to-natural synthetic voice using a short (∼ 5 sec.)
target voice sample.We evaluate this cloning system in Sec. 3.1, and the cloned samples are successfully identified as the true speakers.
However, voice cloning does not protect the speakers' voice biometrics, and can be potentially thwarted by a stronger adversary.
Hence, Prεεch provides voice conversion (VC) as a stronger privacy-preserving option for the user.
VC transforms the voice of a source speaker to sound like a target speaker.
Prεεch utilizes VC to obfuscate the true speakers' voice biometrics as well as to mitigate the DP noise indistinguishability concern by converting the true and dummy segments into a single target speaker voice (Sec. 4.6).
We discuss the utility-privacy trade-offs of both options in Sec. 7.
It is important to note that the dummy segments do not affect the WER of T CSP S .
It is so because Prεεch can exactly identify all such dummy segments (from their timestamps) and remove them from T CSP S .
Additionally, since the transcription is done one segment at a time, the dummy segments do not affect the accuracy of the true segments (S) either.
Segmentation and voice conversion are the culprits behind the WER degradation, as will be evident in Sec. 7.
Thus in Prεεch, the noise (in the form of dummy segments) can ensure differential privacy without affecting the utility.
This is in contrast to standard usage of differential privacy for releasing numeric statistics where the noisy statistics result in a clear loss of accuracy.
However, the addition of the dummy segments in Prεεch does increase the monetary cost of using the online service that has to transcribe more speech data than needed.
We analyze this additional cost in Sec. 7.
In practice, we have multiple well-known cloud-based transcription services with low WER like Google Cloud Speechto-Text, Amazon Transcribe, etc.
Prεεch uses them to its advantage in the following way.
Prεεch splits the set of segments S into N different sets (step 3 in Sec. 4.5.3)S i , i ∈ [N]where N is the number of CSPs with low WER.
Then, Prεεch sends each subset to a different CSP (after adding suitable noise segments to each set and shuffling them).
Since each engine is owned by a different, often competing corporation, it is reasonable to assume that the CSPs are non-colluding.
Thus, assuming that each segment contains at most one word in V , each subset of segments S i can be viewed as randomly sampled sets from S with sampling probability β = 1/N.
From Thm.
4.2, this partitioning results in a privacy amplification.
We summarize the DP mechanism by which Prεεch generates the dummy segments for S.
The inputs for the mechanism are (1) S -the short segments of the speech file S, (2) the privacy parameters ε and δ and (3) N -the number of non-colluding CSPs to use.
This mechanism works as follows:• Identify the vocabulary V = {w|w ∈ { top m percentile of the most frequent words in T OSP S } ∪ { words with TF-IDF value ≥ ∆ in T OSP S }} through running an offline transcriber over S.• Tune the value of d based on the lower bound from Thm.
4.4, ε and δ.
• Generate N separate noise vectors,η i ∼ [Lp((ln(1 + 1 β (e ε − 1)), βδ, d)] |V | , i ∈ [N].
Thus for every partition i, Prεεch associates each word in V with a noise value, a non-negative integer.
• From the NLP generated text, extract all the text segments that contain words from V .
For each partition i, sample the text segments from this corpus to match the noise vector η i .
This is the set of noise (dummy) segments for partition i, S d,i .
Iterate on generating text from the NLP language model until the required noise count is satisfied.
•Randomly partition S into N sets S i , i ∈ [N] where Pr[segment s goes to partition i] = β = 1/N, s ∈ S.• For each partition i ∈ [N], shuffle the dummy segments in S d,i (after applying TTS and VC) with the segments in S i (after applying VC), and send it to the CSP i .
The first 4 steps in the above mechanism are performed in stage 3 in Prεεch (Fig. 1) while steps 5-6 are performed in stage 6.
i , i ∈ [N] from T CSP i S is (ε, δ)-DP.Proof.
From Thm.
4.2 and Thm.
4.3, we conclude that the word histogram˜Hhistogram˜ histogram˜H i computed from T CSP i S is (ε, δ) -DP for distance d. Thm.
4.1 proves that the topic model from˜Hfrom˜ from˜H i is still (ε, δ)-DP as it is a post-processing computation.
Here, we summarize the key novelty in Prεεch's use of DP: (1) Typically, DP is applied to statistical analysis of numerical data where "noise" corresponds to numeric values.
In contrast, in Prεεch, "noise" corresponds to concrete units -words.
To tackle this challenge, we applied a series of operations (segmentation, shuffling, and partitioning) to transform the speech transcription into a BoW model, where the DP guarantee can be achieved.
Moreover, the noise addition has to be done in the speech domain.
This constraint results in new challenges: the lack of a priori access to the word histogram domain V , and generating indistinguishable dummy speech segments.
(2) In our setting, the use of a DP mechanism does not introduce a privacy-utility trade-off from the speech transcription standpoint.
Prεεch performs transcription one segment at a time.
It keeps track of the timestamps of the dummy segments and completely removes their corresponding text from the final transcription (Sec. 4.2.3).
This filtration step is achievable in Prεεch, unlike numeric applications of DP, because of the atomic nature of transcription.
However, the dummy segments increase the monetary cost of transcription, resulting in a privacy-monetary cost trade-off as shown in Table 3.
To tackle this issue, Prεεch takes advantage of the presence of multiple CSPs (Sec. 4.5.2).
Thus, the idea of utilizing multiple CSPs for cost reduction (Thm.
4.2) is a novel contribution.
(3) We introduce an additional parameter d, the distance between the pair of histograms, in our privacy definition (Defn.
4.1).
Intuitively, d connects the privacy definition in the word histogram model, which is purely a formal representation, to a semantic privacy notion (e.g., 1 distance between true and noisy topic models, Thm.
4.4) as shown in Fig. 6 and 7.
This contribution builds on ideas like group privacy [13] and generalized distance metrics [10].
The construction of the DP word histogram provides the user with multiple control knobs for customization: Parameter d: According to Def.
4.1, from˜Hfrom˜ from˜H the CSP will not be able to distinguish between T CSP S and any other transcript that differs from T CSP S in d words from V .
Thus, higher the value of d, larger is the ε-indistinguishability neighborhood for˜Hfor˜ for˜H and hence, better is the privacy guarantee.
But it results in an increased amount of noise injection (hence, increased monetary cost -details in Sec. 7.3).
Vocabulary: The size of V is a control knob, specifically, the parameters m and ∆ and the number of out-of-domain words.The trade-off here is: the larger the size of V , the greater is the scope of the privacy guarantee.
However, the noise size scales with |V | and hence incurs higher cost (details in Sec.
Voice transformation for noisy segments: Prεεch provides two options for noise synthesis -voice cloning and voice conversion.
Voice cloning does not affect the transcription utility, measured in WER, because it does not apply any transformations on the original speaker's voice.
However, it fails to protect the sensitive biometric information in S. Moreover, there is no guarantee that a strong adversary cannot develop a system that can distinguish the cloned speech segments from the original ones.
This puts Prεεch's effectiveness at the risk of the arms race between the voice cloning system's performance and the adversary's strength.
This limitation is addressed by voice conversion at the cost of transcription utility.
We quantify these utility-privacy trade-offs in Sec. 7.
Number of CSPs used for transcription: As discussed above, employing multiple CSPs lowers the monetary cost incurred.
However, as shown in Table 1, AWS has a higher WER than Google.
Hence, using both the CSPs results in lower overall utility than just using Google's cloud service.
Below, we discuss the two main categories of VC systems, highlighting their privacy-utility trade-offs.
One-to-one VC maps a predefined source speaker voice to a target speaker voice.
In Prεεch, we use sprocket [21], which is based on spectral conversion using a Gaussian mixture model (GMM).
Sprocket's training phase takes three steps: (1) acoustic features extraction of the source and target speakers samples, (2) time-alignment of the source and target features, and (3) GMM model training.
During conversion, sprocket extracts the acoustic features of the new utterances, converts them using the learned GMM model, and generates the target waveform.
Prεεch applies sprocket to convert the voice of all source speakers, including the synthesized dummy segments, into the same target speaker voice.
For perfect voice privacy, the VC system should (1) map any voice (even if previously unseen) to the same target voice, (2) not leak any distinguishing acoustic features, and (3) operate on speech containing multiple speakers.
To this end, Prεεch deploys the two-stage many-to-one VC [44] mechanism.
As shown in Fig. 4, the first stage is a phoneme classifier that transfers the speech utterance into phonetic posterior grams (PPG) matrix.
A PPG is a time-aligned phonetic class [44], where a phoneme is the visual representation of a speech sound.
Thus, the phoneme classifier removes the speakeridentifying acoustic features by mapping the spoken content into speaker-independent labels.
In the second stage, a speech synthesizer converts the PPGs into the target voice.The PPGs intermediate stage is irreversible and speakerindependent.
It guarantees that the converted dummy segments S d and converted original segments S cannot be distinguished from each other.
However, the actual implementation of the system carries many challenges.
The first stage is a performance bottle-neck as it needs large phonetically aligned training data to generalize to new unseen voices.
We overcome this challenge by generating a custom training speech dataset with aligned phonemes as described in Sec. 6.
The aforementioned VC techniques present an interesting utility-usability-privacy trade-off.
The one-to-one VC technique gives better accuracy than many-to-one VC since it is trained for a specific predefined set of source speakers (details in Sec. 7.4.1).
However, this utility gain comes at the price of usability and privacy.
First, unlike many-to-one VC, sprocket needs parallel training data -a set of utterances spoken by both the source and target speakers.
Hence, it requires an enrollment phase to get the source speaker's voice samples, thereby limiting the scalability of Prεεch for previously unseen speakers.
Second, one-to-one VC does not provide perfect indistinguishability.
These two limitations are mitigated by applying many-to-one VC (Sec. 7.4.1).
In this section, we go over the end-to-end system design of Prεεch and identify potential privacy vulnerabilities.Voice Privacy: Many-to-one VC removes all the identifying features from S, like the speakers' voices, background noise, and recording hardware, thereby protecting voice privacy.Textual Privacy: For sensitive word scrubbing, the best-case scenario from a privacy point of view is to have the user spell out the entire keyword list.
However, due to its high usability overhead, Prεεch uses NER instead to identify named entities automatically from T OSP S .
In Sec. 7.3.1, we empirically show that Prεεch can achieve near-perfect true positive rate in identifying the segments containing sensitive words.
However, this is only an empirical result and is dataset dependent.Our main defense against statistical analysis on the text is the DP guarantee on the word histogram.
This DP guarantee would break down if the adversary can distinguish the dummy segments from the true segments.
Many-to-one VC technique, by design, ensures that both sets of segments have the same acoustic features.
However, the possibility of distinguishing them based on their textual features still remains.
To address this threat, we rely on state-of-the-art NLP models with low perplexity (log-likelihood) scores to generate the dummy text corpus.
The low perplexity scores ensure that the auto-generated text is as close as possible to the natural language generated by humans [19,36].
Although there is no formal guarantee about the adversary's ability to distinguish dummy and true segments based on their textual features, we have empirically analyzed this threat in Sec. 7.3.3 and Sec. 7.3.4.
We leverage state-of-the-art NLP techniques to mount attacks on the dummy segments.
Our results show that the adversary fails to distinguish between the dummy and true segments.
However, the extent of such robustness is based on the efficacy of state-of-the-art NLP techniques.Word correlations can also weaken the DP guarantee (d −w, if w is the maximum size of word groups with high correlation).
This can be addressed by either increasing d or considering n-gram (n = w) word histograms.
However, this would increase the requisite amount of dummy segments.Long segments can also be a source of privacy vulnerability as each segment contains more contextual information.
Hence, in the prototype Prεεch presented in the paper, we use short segments that contain at most two non-stop words.Another weakness is related to vocabulary estimation, especially if some of the distribution-tail words are deemed to be sensitive.
Prεεch provides no formal guarantees on the words that do not belong to V .
Although our empirical evaluation shows that the OSP has a very high accuracy for the weighted estimation of V (Sec. 7.3.2), some sensitive distribution-tail words might still be missed due to the OSP's transcription errors.
Additionally, our formal DP guarantee holds only for the word histogram (BOW ) on V .
Textual analysis models other than BOW are empirically evaluated in Sec. 7.3.3 and Sec. 7.3.4.
Finally, if the CSP can reorder the segments (even partially since the speech file it receives contains dummy segments as well), it will be able to distinguish the dummy segments from the true ones and hence, learn the textual content of the file.
For this again, we show empirically that current NLP techniques fail to reorder the segments (Sec. 7.3.4) even in the worst-case setting where all the segments go to one CSP.
However, as before, this is an empirical result only.
Formal Privacy Guarantee: For a speech file S, Prεεch provides perfect voice privacy (when using many-to-one VC) and an (ε, δ)-DP guarantee on the word histogram for the vocabulary considered (BOW ), under the assumption that the dummy segments are indistinguishable from the true segments.
In this section, we describe the implementation details of Prεεch's building blocks (shown in Fig. 1).
Segmentation: We implement the two-level hierarchical segmentation algorithm described in Sec. 4.3.
The silence detection based segmentation is implemented using the Python pydub package 7 .
We used Praat 8 to extract the pitch information required for the second level of the segmentation algorithm.
Sensitive Keyword Scrubbing: We use the NLP Python framework spaCy 9 for named entity recognition (NER) from the text.
The keyword lists per each dataset can be found in the full paper [3] .
We employ PocketSphinx 10 for keyword spotting, a lightweight ASR that can detect keywords from continuous speech.
It takes a list of words (in the text) and their respective sensitivity thresholds and returns segments that contain speech matching the words.
PocketSphinx is a generic system that can detect any keyword specified in runtime; it is not trained on a pre-defined list of keywords and requires no per-user training or enrollment.
Generating Dummy Segments: We use the open source implementation 11 of OpenAI's state-of-the-art NLP language model, GPT 2 [36], to generate the noise corpus.Using this predictive model, we generate a large corpus representing the vocabulary of the evaluation datasets.
An example of the generated text is available in the full paper [3] .
To generate the dummy segments, we segment each document at the same level as the speech segmentation algorithm.
We build a hash table associating each vocabulary word with the segments that contain it.
Prεεch uses a dummy segment only once per CSP to prevent it from identifying repetitions.Text-to-Speech: We use the multi-speaker (voice cloning) TTS synthesizer [20] to generate the speech files corresponding to the dummy segments.
We use a pre-existing system implementation and pretrained models 12 .
One-to-One Voice Conversion: We use the open-source sprocket software 13 .
As described in Sec. 4.6.1, sprocket requires a parallel training data and the target voice should be unified for all source speakers.
For the VCTK datasets, we use speaker p306 as the target voice.
Since we also evaluate Prεεch on non-standard datasets (Facebook and Carpenter cases), we had to construct the parallel training data for their source speakers.
For this, we use TTS to generate the required target voice training utterances in a single synthetic voice.Many-to-One Voice Conversion: We utilize pre-existing architectures and hyperparameters 14 for the two-stage many-toone VC [44] mechanism, shown in Fig. 4.
The first network, net 1 , is trained on a set of {raw speech, aligned phoneme labels} samples from a multi-speaker corpus, where the labels are the set of 61 phonemes from the TIMIT dataset.
The only corpus that has a manual transcription of speech to the phonemes' level is the TIMIT dataset -a limited dataset.
We found that training net 1 on TIMIT alone results in an inferior WER performance.
For better generalization, we augment the training set by automatically generating phoneme-aligned transcriptions of standard ASR corpora.
We use the Montreal Forced Aligner 15 to generate the aligned phonemes on LibriSpeech and TED-LIUM [38] datasets.
The second network, net 2 , synthesizes the phonemes into the target speaker's voice.
It is trained on a set of {PPGs, raw speech} pairs from the target speaker's voice.
We use the trained net 1 to generate the PPGs data for training net 2 .
As such, we only need speech samples of the target speaker to train net 2 .
This procedure also allows net 2 to account for net 1 's errors.
We use Ljspeech 16 as the target voice for its relatively large size -24 hours of speech from a single female.
We evaluate how well Prεεch meets the design objectives of Sec. 4.
Specifically, we aim to answer the following questions: One We answer the first three questions for a prototype implementation of Prεεch that provides the maximum degree of formal privacy and hence, the least utility.
For evaluating Q4, we relax the privacy guarantee to obtain utility and usability improvements.Prototype Prεεch: For the prototype Prεεch presented in the paper: (1) segmentation length is adjusted to ensure that each segment contains at most two non-stop words (2) noisy segments are generated via the GPT2 language model (3) a single CSP (Google) is utilized (4) many-to-one VC is applied to both the dummy and true segments.
We assess the transcription WER after deploying end-to-end Prεεch on the non-standard datasets.
Recall that Table 1 in Sec. 2.2 shows the baseline WER performance of the CSP and OSP before applying Prεεch.
WER Analysis: Column 4 in Table 2 shows the end-to-end WER for the prototype Prεεch which represents the accumulative effect of segmentation, SWS, and many-to-one VC.
Although VC is the main contributor to Prεεch's WER, as is evident from Sec. 7.4.1 and Sec. 7.3.1, there are two main observations.
First, many-to-one VC is superior to Deep Speech.
Specifically, Prεεch's relative improvement over Deep Speech ranges from 11.91% to 32.25% over the evaluation datasets (except for Carpenter2).
Recall that we trained the VC system using standard ASR corpora, while we evaluate the WER on non-standard cases.
Still, Prεεch's WER is superior to that of Deep Speech, which has been trained through hundreds of hours of speech data.
Second, Prεεch does not have the same performance for all the datasets.
This observation arises again from the lack of diversity in our VC training set.
For example, the speaker in Carpenter 1 speaks loudly, allowing VC to perform well.
On the other hand, the second speaker (Carpenter 2) is not as clear or loud, which results in an inferior VC performance.
This observation is consistent with Deep Speech as well.
Our experiments show that these results can be improved by adding samples of the source speaker voice to the training pipeline of net 1 and net 2 .
We chose not to go with this approach as this limits the usability of the system, and in such a case sprocket (Sec. 7.4.1) would be a better choice.
To test the voice biometric privacy, we conduct two experiments using the voice analysis APIs (details in Sec. 3.1).
In the first experiment, we assess the CSP's ability to separate speech belonging to different speakers after Prεεch applies the VC system.
On our multi-speaker datasets, IBM diarization API concludes that there is only one speaker present.Furthermore, we run the diarization API after adding the dummy segments (after TTS and VC).
Again, the API detects the presence of only one speaker.
Thus, not only does Prεεch hide the speaker's biometrics and map them to a single target speaker but also ensures noise indistinguishability, which is key to its privacy properties.The second experiment tests Prεεch's privacy properties against a stronger adversary, who has access to samples from the true speakers.
We enroll segments from the true speakers as well as the fake target speaker to Azure's Speaker Identification API.
We pass the segments from Prεεch (after adding dummy segments and applying VC) to the API.
When manyto-one VC is applied, in all evaluation cases, the API identifies the segments as belonging to the fake target speaker.
Not a single segment was matched to the original speaker.
Both experiments show that prototype Prεεch is effective in sanitizing the speaker's voice and ensuring noise indistinguishability.
Table 3: Number of extra words due to dummy segments and the additional monetary cost in USD with varying d, at ε = 1 and δ = 0.05.
Figure 6: Sentiment scores heatmap of 10 documents with varying d, at ε = 1 and δ = 0.05.
We perform an extensive evaluation of the textual privacy, including sensitive word scrubbing, analysis of the DP mechanism, and defense against statistical analysis.
We run PocketSphinx keyword spotting on each dataset at different sensitivity scores ranging from 0.2 to 1 17 .
Fig. 5 shows the detection true positive rate (TPR) versus the false positive rate (FPR) at different sensitivity scores.
As the figure shows, the sensitivity score is a trade-off knob between privacy (high TPR) and utility (low FPR).
We observe that Prεεch is able to achieve almost perfect TPR with low FPR values.
Next, we evaluate the impact of SWS on the transcription utility.
We set a sensitivity score of 0.95 for all the datasets to have a near-perfect TPR while minimizing the FPR.
Our experiments show that the total duration of the segments flagged with sensitive keywords at this score is: 0.13%, 0.06%, 0.18%, 0.20%, and 0.08% of the total duration of each dataset in Fig. 5.
Then, we transcribe the sensitive-flagged segments using Deep Speech.
The overall transcription accuracy after SWS (i.e., equivalent to choosing voice cloning in Prεεch as cloning results in no addition WER) is presented in the second column of Table 2.
Since the segments are short, the portion of speech transcribed locally is limited.
Hence, the impact of the OSP transcription errors is not significant.
We follow the DP mechanism described in Sec. 4.5.3.
Vocabulary Estimation: We estimate the vocabulary V using the OSP transcript.
Let W represent the set of unique words in T g S .
We define the accuracy of the vocabulary estimation, D acc , as the ratio between the count of the correctly identified unique words from T OSP S , |W | est , and the count of the unique words in T g S , |W |.
For our datasets, the domain estimation accuracy is at least 75.54%.
We also calculate the weighted estimation accuracy defined as: 17 The sensitive keywords list for each dataset is in the full paper [3] .
D weighted = ∑ P(w est ).1 w est ∈W |W |where P(w est ) is the weight of the estimated word w est in T g S .
D weighted is more informative since it gives higher weights to the most frequent words in T g S .
The weighted estimation accuracy is 99.989% in our datasets.From W est we select V over which we apply the DP mechanism.
Additionally, we extend our vocabulary to contain a set of random words from the English dictionary.Histogram Distance: We analyze the distance between the original and noisy histograms (after applying Prεεch) and its impact on the cost of online transcription.
Because of the nature of Prεεch's DP mechanism, the noise addition depends on four values only: |V |, ε, δ, and d.For all our experiments, we fix the values of ε = 1 and δ = 0.05.
Table 3 shows the amount of noise (dummy words) and their transcription cost in USD 18 for each of the evaluation datasets at different values of d. Each dataset has a different vocabulary size |V | and word count.
The increase in the vocabulary size requires adding more dummy segments to maintain the same privacy level.
In Prεεch, adding more noise comes at an increased monetary cost, instead of a utility loss.
The table highlights the trade-off between privacy and the cost of adding noise.
In this section, we evaluate the statistical analyses (details in Sec. 3.2) performed by the adversary to extract textual information on the noisy transcripts obtained from Prεεch.Topic Model: We generate the topic models from the documents corresponding to the original and noisy word histograms, and evaluate their 1 distance.
The topic model operates on a corpus of documents; hence we include eight more Supreme Court cases to our original evaluation datasets (Face- book and Carpenter).
In this evaluation, we treat all these ten documents as one corpus; we aim to generate the topic model before and after applying Prεεch to the whole corpus.We use AWS Comprehend API to generate the topic model.
The API needs the number of topics as a hyperparameter that ranges from 1 to 100.
Based on our apriori knowledge of the T = {T 1 , · · · , T t } is a set of t topics where each T i , i ∈ [t]is a word distribution.
We use the Hungarian algorithm to match each noisy topic T i ∈ T to its closest match in T , the true topic model.
We evaluate the topics 1 distance for 21 runs.
At each run, we generate a random noise vector per document, select the corresponding dummy segments, and evaluate the topic model on the set of original and noisy documents.
Fig. 7 shows the empirical CDF of the topics 1 distance at different values of d.
As the figure shows, the higher the distance parameter d, the larger is the 1 distance between true and noisy topics.Stylometry: In this experiment, we assume that the CSP applies stylometry analysis on T CSP S in an attempt to attribute it to an auxiliary document whose authors are known to the CSP.
To evaluate the worst-case scenario, we assume the adversary possesses the original document T g S , and we compute the 2 & Government.
Running the API on Prεεch processed documents, using an extended-vocabulary (i.e., contains random words), dropped the classification accuracy to 0%.
None of the documents got identified as legal, law, or government even at the smallest distance parameter value d = 2.
Although a portion of the noise words belongs to the original Law & Government category, segmentation, shuffling, and the out-ofdomain noise words successfully confuse the classifier.
Sentiment Analysis: Sentiment analysis generates a score in the [−1, 1] range, which reflects the positive, negative, or neutral attitude in the text.
First, we evaluate the sentiment scores of the original ten documents.
For all of them, the score falls between −0.2 and −0.9, which is expected as they represent legal documents.
Next, we evaluate the scores from Prεεch processed documents considering an extended-vocabulary.
We find that all scores increase towards a more positive opinion.
Fig. 6 shows a heatmap of the sentiment scores as we change the distance parameter d for the then evaluation documents.
Thus, Prεεch's two-pronged approach -1) addition of extended-vocabulary noise 2) removal of ordering information via segmentation and shuffling, proves to be effective.
In a setting where the adversary has no apriori knowledge about the general domain of the processed speech, the noise addition mechanism gains extend from DP guarantee over the histogram to other NLP analyses as well.
The indistinguishability of the dummy segments is critical for upholding the DP guarantee in Prεεch.
We perform two experiments to analyze whether current state-of-the-art NLP models can distinguish the dummy segments from their textual content.
Most Probable Next Segment: In this experiment, the adversary has the advantage of knowing a true segment S t that is at least a few sentences long from the Facebook dataset.
We use the state-of-the-art GPT 20 language model by OpenAI [35] to determine the most probable next segment following S t using the model's perplexity score.
In NLP, the perplexity score measures the likelihood that a piece of text follows the language model.
We get the perplexity score of stitching S t to each of the other segments at the CSP.
The segment with the lowest perplexity score is selected as the most probable next segment.
We iterate over all the true segments of the Facebook dataset, selecting them as S t .
We observed that a dummy segment is selected as the most probable next segment in 53.84% of the cases.
This result shows that the language model could not differentiate between the true and dummy segments even when part of the true text is known to the adversary.
Segments Re-ordering: Next, we attempt to re-order the segments based on the perplexity score.
We give the adversary the advantage of knowing the first true segment S 0 .
We get the perplexity score of S 0 , followed by each of the other segments.
The segment with the lowest score is selected as the second segment S 1 and so on.
We use the normalized Kendall tau rank distance K τ to measure the sorted-ness of the re-ordered segments.
The normalized K τ distance measures the number of pairwise disagreements between two ranking lists, where 0 means perfect sorting, and 1 means the lists are reversed.
The K τ score for running this experiment on the Facebook dataset is 0.512, which means that the re-ordered list is randomly shuffled w.r.t the true order.
Hence, our attempt to re-order the segments has failed.
These empirical results show that it is hard to re-order the segments or distinguish the dummy segments.
This is expected due to three reasons: (1) the segments are very short; (2) the dummy segments are generated using a state-of-the-art language model; and (3) we observed that most of the transcription errors happen in the first and last words of a segment due to breaking the context.
These errors add to the difficulty of re-ordering.
Moreover, if the user partitions S among multiple CSP's (Sec.4.5.3), then consecutive segments would not go to the same CSP with high probability.
This setting would increase Prεεch's protection against re-ordering attacks.
In this section, we empirically evaluate the controls knobs that provide a utility-privacy trade-off.
Minimum segment length: Fig. 8 shows the trade-off between the number of words per segment and WER as function of the minimum segment length.
As expected, increasing the minimum duration of a segment results in an increase in the number of words per segment.
The WER in turn drops when the number of words per segment increase as the transcription service has more textual context.
However, it can lead to potential privacy leakage.
The results in Fig. 8 indicate that for two real-world datasets, the number of words per segment can be kept between 2 and 3 with an acceptable degradation of the WER.Voice Cloning: Voice cloning does not affect the true segments (it is only applied to dummy segments), resulting in no additional WER degradation.
The WER for deploying voice cloning is incurred only due to segmentation and SWS.
Thus, as shown in column 2 of Table 2, the relative improvement in WER ranges from 44% to 80% over Deep Speech.
This approach, however, has two limitations.
First, the speaker's voice biometrics from S are not protected.
Second, there is no guarantee that an adversary would not be able to distinguish the cloned speech segments from the original ones.Sensitivity score of KWS: As shown in Fig. 5, lower the sensitivity score, higher is the TPR and hence greater is the privacy (most prominent in the Carpenter2 dataset).
However, this also increases the FPR, which means a larger number of non-sensitive segments are transcribed via the OSP resulting in reduced accuracy.One-To-One VC: Table 2, column 3, shows that one-to-one VC outperforms many-to-one VC on most of the datasets.
This result is expected since sprocket is trained and tested on the same set of source speakers while the many-to-one VC system generalizes to previously unseen speakers.
We observe that the improvement for the VCTK dataset is more significant than others.
Recall that in our one-to-one VC implementation in Sec. 6, the target voice for VCTK is a natural voice -speaker p306.
The target voice for the other datasets is a synthetic one, which hinders the quality of the converted voice and the transcription accuracy.
We investigate this observation by training sprocket for VCTK on a synthetic target voice as well.
The WER then increased to 19.33% and 9.21% for p266 and p262.
Hence, we attribute the difference in the relative improvement to the target voice naturalness.
In practice, the target voice could easily be a natural pre-recorded voice, and the users are asked to repeat the same utterances at the enrollment phase.
However, the one-to-one VC technique suffers from some privacy loss.
The one-to-one VC system translates the acoustic features from a source to a target speaker's voice.
Hence, it may leak some features from the source speaker.
We observed that one-to-one VC is vulnerable to speaker identification analysis.
Specifically, using Azure's Speaker Identification API, 10% of the voice-converted segments using sprocket were identified to their true speakers.
In our setting, usability can be measured along three dimensions: latency, monetary cost, and implementation overhead.
However, we would like to stress that Prεεch is not designed for real-time speech transcription.
Hence, latency is not a primary concern for Prεεch.
Nevertheless, we include it in the following discussion for the sake of completeness.
Latency Evaluations: Note that all the operations of Prεεch are performed on speech segments.
Hence, the latency is linear in the number of segments.
We evaluate the end-to-end system latency per segment (with length ∼ 6s) for the OSP, the CSP, and Prεεch; the latency values are 2.17s, 1.70s, and 14.90s, respectively.
We observe that the overhead of Prεεch is mostly attributed to the many-to-one VC (11s per segment on average).
When voice cloning (or one-to-one VC) is applied instead, Prεεch's end-to-end per segment latency reduces to 3.90s (or 11.47s) at the expense of a privacy loss as discussed in Sec.7.4.1.
Vocabulary Size: Considering a larger V (Sec. 4.5.3) increases the scope of the DP guarantee.
For example, adding external words provides protection against statistical analysis like text classification (Sec.7.3).
However, larger V results in increased amount of dummy segments and hence, increased monetary cost (Table 3).
For example, extending V by ∼ 1000 out-of-domain words for the Carpenter dataset incurred a total cost of $25 at d = 15.
Distance Parameter d: As explained in Sec. 4.5.2, larger the value of d, greater is the scope of privacy.
However, the amount of required noise increases by d. For example, for the dataset VCTK p266, increasing d from 2 to 15 increases the cost by roughly $5 (Table 3).
The following control knobs provide a venue for customizing the utility-usability trade-off.
As discussed in Sec. 4.5.2, using multiple CSPs reduces the amount of dummy segments (and hence, the monetary cost) in Prεεch.
However, it comes at the price of utility; the transcription accuracy of the different available CSPs varies.
For example, from Table 1, we observe that AWS has a higher WER than Google.
Thus, using multiple CSPs may result in a lower mean utility.One-to-One VC: As discussed above, one-to-one VC technique has lower WER than many-to-one VC technique (Table 2).
However, it requires access to representative samples of the source speaker voice for parallel training thereby limiting scalability for previously unseen speakers (Sec. 4.6).
In this section, we provide a summary of the related work.Privacy by Design: One class of approaches redesigns the speech recognition pipeline to be private by design.
For example, Srivastava et al. proposes an encoder-decoder architecture for speech recognition [42].
Other approaches address the problem in an SMC setting by representing the basic operations of a traditional ASR system using cryptographic primitives [32].
VoiceGuard is a system that performs ASR in the trusted execution environment of a processor [8].
However, these approaches require redesigning the existing systems.Speech Sanitization: Recent approaches have considered the problem from a similar perspective as ours.
They sanitize the speech before sending it to the CSP.
One such approach randomly perturbs the MFCC, pitch, tempo, and timing features of a speech before applying speech recognition [45].
Others sanitize the speaker's voice using vocal tract length normalization (VTLN) [33,34].
A recent approach modifies the features relevant to emotions from an audio signal, makes them less sensitive through a GAN [4].
Last, adversarial attacks against speaker identification systems can provide some privacy properties.
These approaches apply minimal perturbations to the speech file to mislead a speaker identification network [9,22].
These approaches are different from ours in two ways.
First, they do not consider the textual content of the speech signal.
The only exception is the approach by Qian et al. [34], which addresses the problem of private publication of speech datasets.
This approach requires a text transcript with the audio file, which is not the case for the speech transcription task.
In addressing the textual privacy of a speech signal, Prεεch adds indistinguishable noise to the speech file.
The proposed techniques fail to provide this property.
Second, the approaches above only consider voice privacy against a limited set of features, such as speaker identification or emotion recognition.
Prεεch applies many-to-one VC to provide perfect voice privacy.
In this paper, we have proposed Prεεch, an end-to-end system for speech transcription that (1) protects the users' privacy along the acoustic and textual dimensions at (2) an improved performance relative to offline ASR, (3) while providing customizable utility, usability, and privacy trade-offs.
The work reported in this paper was supported in part by the NSF under grants 1661036, 1838733, 1942014, and 1931364.
We also acknowledge Google for providing us with Google Cloud Platform credits and NVIDIA Corporation with the donation of the Quadro P6000 GPU used for this research.
We would like to thank the anonymous reviewers for their useful comments and Micah Sherr for shepherding this paper.
