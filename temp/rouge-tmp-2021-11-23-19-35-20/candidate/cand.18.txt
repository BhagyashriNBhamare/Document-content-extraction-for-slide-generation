It is currently supported by all modern commercial web browsers and deployed on a number of popular websites, which justified a recently growing interest by the research community [20,5,13,1,18,10]. For instance, the following policy:script-src https://example.com; img-src *; default-src 'none' specifies these restrictions: scripts can only be loaded from https://example.com, images can be loaded from any web origin, and contents of different type, e.g., stylesheets, cannot be included. Moreover, CSP prevents by default the execution of inline scripts and bans a few dangerous JavaScript functions, like eval; these restrictions can be explicitly deactivated by policy writers to simplify deployment, although they are critical for the security of CSP.Simple as it looks, however, CSP is typically hard to deploy correctly on real websites [19,20,1,18] and there are several, diverse reasons for this:1. The most important design goal of our proposal is to avoid both a major overhaul of the existing CSP specification and a dramatic change to the logic behind policy writing, so as to simplify its practical adoption by web developers who are already familiar with CSP.Our proposal builds on the pragmatic observation that static white-lists are inherently complex to write down for modern web applications and do not really fit the dynamic nature of common web interactions, so we devise Compositional CSP (CCSP), an extension of CSP based on runtime policy composition. Notably, by introducing a dynamic dimension to CSP and by delegating part of the policy specification efforts to the content providers, it is possible to come up with white-lists which are much more precise than those which could be realistically written by the developers of the protected page alone, since they often lack an in-depth understanding of the externally included contents and their dependencies.Concretely, we make the following contributions:1. This means that the content security policy of w must not only whitelist https://a.com as a valid source for script inclusion to load stats.js, but it must also white-list all the dependencies of stats.js with their correct type. Second, the policy above is brittle: if the developers of stats.js or dependency.js change the implementation of their scripts, for instance to include additional libraries from other sources, the policy of w must correspondingly be updated to white-list them. In CCSP, direct dependencies are specified by means of fine-grained white-lists reminiscent of CSP 1.0 and CSP Level 2, since these dependencies are relatively easy to identify for web developers and it is feasible to come up with reasonably strict and secure white-lists for them. In this case, the policy supplied by the script provider is compliant with said upper bounds, hence the browser would update the content security policy of the page as follows:script-src https://a.com/stats.js https://b.com/dependency.js; img-src https://c.comThis policy is reminiscent of the policy we would write using CSP 1.0 or CSP Level 2, but it is assembled dynamically by interacting with the content providers. This significantly simplifies the specification of the original policy for the page developers and makes it naturally robust to changes in the included contents, as long as the capabilities required by the updated contents still comply with the original upper bounds on policy relaxation specified by the page developers. In the end, the resulting policy can realistically be as strict and precise as a nonce-based policy, but all the security information is available in the HTTP headers, thus overcoming the typical limitations associated with the use of nonces. Developers at a.com may want to mitigate the impact of vulnerabilities in the b.com library, since the end user of the advertisement library may be unaware of the inclusion of external contents and just blame the developers of a.com for any security issue introduced by the advertisement system. We abstract from the details of the matching algorithm of CSP and we just write matches(u, se) if u matches any of the source expressions in the list se.We let P stand for the set of the content security policies and we let p range over it. In the following, we do not discuss how the join and the meet of two policies are actually computed, but we provide an abstract specification of CCSP which uses these operations as a black box. It includes a list of bindings between a source expression list (a scope) and a content security policy, expressing that contents retrieved from a URL matching a given scope are entitled to relax the policy of the protected resource only up to the specified upper bound.The next paragraph makes these intuitions more precise.Enforcement Model. Conceptually, each protected resource needs to keep track of two elements: the enforced content security policy p and the upper bounds on policy relaxation R = {( se 1 , p 1 ), . . . , ( se n , p n )} collected via the CSP-Intersect headers. We call R a relaxation policy and we refer to the pair (p, R) as the protection state of the protected resource.In the protection state (p, R), a content inclusion is allowed if and only if it is allowed by the content security policy p, whose weakening is subject to the relaxation policy R. Initially, the protection state is set so that p is the policy delivered with the CSP-Compose header of the protected resource and R = {( se 1 , p 1 ), . . . , ( se n , p n )} is the CSP-Intersect header originally attached to it. The protection state can be dynamically updated when the protected resource includes contents with a CSP-Union header. Given a URL u and a relaxation policy R, we define the upper bound for u under R as:ub(u, R) =      p 1 . . . p n if bnds(u, R) = {p 1 , . . . , p n } with n > 0 ⊥ if bnds(u, R) = / 0Though simple, this definition is subtle. This prevents trivial bypasses of the relaxation policy R, where u specifies a more liberal upper bound than ub(u, R) for other contents recursively loaded by itself.Observe that CCSP gives web developers the possibility of granting different capabilities on policy relaxation to different content providers, but content security policies are still enforced per-resource (web page or iframe), rather than per-content. If R = / 0, no policy relaxation is possible and the security guarantees offered to the protected resource are simply those provided by the initial content security policy p. Observe that no policy relaxation is allowed even if a content provider at u sends its own relaxation policy R = / 0, since all the relaxation bounds in R will be set to ub(u, R) = ⊥ when updating the protection state, thanks to the use of the meet operator in Equation 1. Legacy content providers will not attach any CSP-Union header to the contents they serve, although developers of resources protected by CCSP may expect them to supply this information to relax their policies. The second possibility, instead, is specific to CCSP, but it is not really a compatibility issue, because providers are not forced to put restrictions on policy relaxation and they are assumed to behave rationally, i.e., they do not deliberately put restrictions to break contents which are recursively loaded from other providers as part of their intended functionality. Assuming a reasonably large deployment of CCSP by content providers, developers who are willing to deploy a standard content security policy on their websites would have a much simpler life if they decided to run CCSP instead, because the policies written in the CSP-Compose headers are a subset of the policies which would need to be written using the standard CSP; moreover, the direct dependencies of the protected resource are much simpler to identify than the indirect ones. Writing accurate CSP-Intersect headers for controlled policy relaxation might be more complex for the average web developer, but quite liberal policies would be easy to write and still appropriate for content providers with a high level of trust. Developers of protected resources can write CSP-Intersect headers for CCSP-compliant providers and trust that they provide appropriate CSP-Union headers for their contents; at the same time, however, developers can also include the dependencies of legacy content providers directly in the CSP-Compose header. Two observations are in order here.First, as anticipated, content providers typically have an economic interest on the correct integration between the contents they supply and the CSP policies of the embedding pages, such as in the case of advertisements, hence content providers often do not need further convincing arguments to deploy CCSP. Moreover, one may argue that the challenges faced by the first-party adoption of CSP may actually depend on the lack of thirdparty support for policy deployment, which proved to be difficult for web developers [9,20,1,18]. If content providers could provide the correct policies for the content they supply, then also the first parties might be more willing to adopt CCSP, because they will encounter significantly less challenges upon deployment. We developed a simple Chromium extension which intercepts the CSP headers of incoming HTTP(S) responses and changes them to report the detected CSP violations to a web server run by us (we do this by leveraging the report-uri directive available in CSP). The use of 'strict-dynamic' can fix the 96 violations related to the script-src directive, which however represent only the 41.6% of the total number of violations in this category. To properly fix the other 135 cases in CSP, one would need to identify the missing dependencies of the included scripts and adapt the content security policy of the website accordingly, but this is not always easy for web developers, as testified by the fact that these violations occurred on popular websites. This suggests that the use of CCSP by the top script providers could provide a benefit to the majority of the websites. On Jan 23rd 2017 we detected three CSP violations at www.orange.sk, a national website of the popular telecommunication provider Orange.The first violation was due to a script imported from static.hotjar.com, which was trying to create an iframe including contents from vars.hotjar.com. We fixed it by writing the following CSP-Intersect header for the homepage of www.orange.sk: CSP-Intersect: scope static.hotjar.com; frame-src *.hotjar.com; default-src 'none';We then attached the following CSP-Union header to the script from vars.hotjar.com: CSP-Union: frame-src https://vars.hotjar.com/rcj-b2 c1bce0a548059f409c021a46ea2224.htmlNotice that this time we were able to white-list exactly the required contents, since the whole URL is readily available in the script code. To get a rough estimate about the challenges of the CCSP deployment more in general, we inspected our dataset of CSP violations and we collected for the top 10 script providers (by number of violations) the following information: the number of scripts they serve, the number of CSP violations triggered by these scripts, and the type of these violations. It is also worth mentioning that CCSP is naturally effective at simplifying the policy specification process for web developers, assuming that content providers are willing to dedicate some efforts to foster the integration between their contents and the content security policies of the embedding resources.The idea of dynamically changing the enforced CSP policy advocated in CCSP is also present in the design of COWL, a confinement system for JavaScript code [12]. It is worth noticing that CSP Embedded Enforcement is a first step towards making the CSP enforcement depend upon an interaction between the protected resource and the content providers, though the problems it addresses are orthogonal to CCSP. By shifting part of the policy specification process to content providers and by adding a dynamic dimension to CSP, CCSP reconciles the protection offered by fine-grained white-listing with a reasonable policy specification effort for web developers and a robust support for the highly dynamic nature of common web interactions. However, there is no loss of generality in focusing only on well-formed policies, since if both unsafe-inline and inline(str) occur in the same directive, only one of them is enforced: browsers supporting CSP 1.0 would ignore inline(str), while browsers implementing more recent versions of CSP would ignore unsafe-inline. We let O stand for a denumerable set of objects and we let O range over subsets of O.We use the projection functions π 1 (·) and π 2 (·) to extract the components of a pair (location, subject or object). Formally, this means that O is partitioned into the subsets O t 1 , . . . , O t n , where t 1 , . . . ,t n are the available content types. Given a list of directives d and a content type t, we define d ↓ t as the value bound to the first t-src directive, if any; otherwise, the value bound to the first default-src directive, if any; and in absence of both, we let it be the wildcard { * }. t =      v if d = d 1 ,t-src v, d 2 ∧ ∀d ∈ { d 1 } : d = t-src v ⊥ otherwiseWe then define the lookup operator d ↓ t as follows:d ↓ t =          d.t if d.t = ⊥ v if d.t = ⊥ ∧ d = d 1 , default-src v, d 2 ∧ ∀d ∈ { d 1 } : d = default-src v { * } otherwiseThe judgement p s t O defines the semantics of policies. (D-VAL) d ↓ t = v v s L d s t {o ∈ O t | π 1 (o) ∈ L} (D-CONJ) p 1 s t O 1 p 2 s t O 2 p 1 + p 2 s t O 1 ∩ O 2The syntax of normal policies is obtained by replacing the occurrences of h in Table 5 with h, where:h ::= sc | * | (sc, he). Given a normal policy p and a content type t, we define p ⇓ t as follows:p ⇓ t = d ↓ t if p = d (p 1 ⇓ t) (p 2 ⇓ t) if p = p 1 + p 2Lemma 3 (Correctness of Smart Lookup). t = v and v s L for some L such that π 1 (o) ∈ L. By definition, this means that there exists se ∈ v such that se s L for some L such that π 1 (o) ∈ L . Hence, we have either se ∈ p 1 s ⇓ t or se ∈ p 2 s ⇓ t. Assume that se ∈ p 1 s ⇓ t, then o ∈ O 1 by using Lemma 3 and the observation that normalization does not change the semantics of policies. By using Lemma 3 and the observation that normalization does not change the semantics of policies, there exists v such that p 1 s ⇓ t = v and v s L for some L such that π 1 (o) ∈ L. By definition of join, we have (p 1 s p 2 ).