In practice, determining the exploitability is however a difficult, complicated and lengthy process, particularly for those UseAfter-Free (UAF) vulnerabilities residing in OS kernels.Use-After-Free vulnerabilities [24] are a special kind of memory corruption flaw, which could corrupt valid data and thus potentially result in the execution of arbitrary code. Technically speaking, our framework however follows a completely different design, which utilizes a fuzzing technique to diversify the contexts of a kernel panic and then leverages symbolic execution to explore exploitability under different contexts.To be more specific, our system first takes as input a PoC program which does not perform exploitation but causes a kernel panic. More specifically, FUZE facilitates exploit crafting from the following aspects.First, it augments a security analyst with the ability to automate the identification of system calls that he needs to take advantages for UAF vulnerability exploitation. Last but not least, it provides security analysts with the ability to achieve security mitigation bypassing.As we will show in Section 6, with the facilitation from all the aforementioned aspects, we could not only escalate kernel UAF exploitability but also diversify working exploits from various kernel panics. • We implemented FUZE to facilitate the process of exploit generation by extending a binary analysis framework and a kernel fuzzer on a 64-bit Linux system.  Identifying the time window between the occurrence of dangling pointer and its dereference;  selecting the proper system call syscall_M to perform heap spray;  adjusting the argument of the system call syscall_M; introducing the system call syscall_M and revising the original PoC program accordingly. As a result, the security analyst also needs to carefully compute the content of the data sprayed based on the semantic of the PoC program, and thus adjust the arguments of the system call selected for performing heap spray, before he finally revises the PoC program for exploitation in a manual fashion. By simply following the typical workflow mentioned above along with the facilitation in the step , however, In a PoC program, the occurrence of a dangling pointer as well as its dereference might be triggered in the same system call. As is shown in Fig- ure 2c, at the time of prepending the object to the list, a system call dereferences the dangling pointer and thus modifies data in the "previous link" residing in the freed object, resulting in an unexpected write operation which further triggers a kernel panic in consecutive kernel execution. Following the typical workflow specified in Figure 1 to craft an exploit for the vulnerability above, in the step , a security analyst needs to identify a proper system call, use it to perform heap spray and thus turn the PoC into a working exploit. Different from the original running context indicated by the PoC program in Table 1, we can easily observe, this new context provides a security analyst with a new primitive, with which he can spray data carefully crafted, manipulate the instruction pointer rip and thus perform a control flow hijack. As is mentioned earlier in Section 1, the ultimate goal of FUZE is not to yield a working exploit automatically but to facilitate the ability of a security analyst to craft a working exploitation. As a result, we decide to design FUZE to facilitate exploit crafting from the following four aspects.First, FUZE must provide a security analyst with the ability to track down the vulnerable object, the occurrence of a dangling pointer and its dereference. Last but not least, FUZE must give a security analyst the capability to automatically derive the data that needs to be sprayed in between the occurrence of a dangling pointer and its dereference. Given that an attacker has the full control over the content in the freed object, using the aforementioned approach that takes only the consideration of system calls, we may inevitably disregard some contexts that allow a security analyst to perform a successful exploitation. As is shown in Figure 4b, this allows FUZE to explore the exploitable machine states in a more complete fashion and thus thoroughly pinpoint the set of contexts useful for exploitation.It should be noted that, as is depicted in Figure 4b, symbolic execution under the context does not mean that symbolically executing kernel code at the site of kernel panic. In addition to the information extracted through KASAN, consecutive exploitation needs information pertaining to the execution of system calls that trigger vulnerabilities. With PID associated with each memory management operation, we can then pinpoint the life cycle of system calls on the trace and thus identify close(), the system call tied to the free operation.Since system call socket() manifests as an incomplete trace, we can easily pinpoint that it serves as the system call that dereferences the dangling pointer. Associating this information with debugging information and source code, we can easily understand how the dangling pointer was dereferenced and further track down which variable this dangling pointer belongs to. As is demonstrated above, this can be easily achieved by using the information extracted through KASAN and dynamic tracing.With the two critical sites identified, our next step is (b) Wrapped PoC program that encloses free and dangling pointer dereference in two separated system calls with race condition involvement. By providing the memory address to our kernel module, which monitors the allocation and free operations in kernel memory, we can augment the kernel module with the ability to pinpoint the occurrence of the target object as well as alert system call ioctl to redirect the execution of the wrapping function to the consecutive kernel fuzzing. To perform kernel fuzzing under the context initialized above, we borrow a state-of-the-art kernel fuzzing framework, which performs kernel fuzzing by using sequences of system calls and mutating their arguments based on At the fuzzing stage, our objective is to identify system calls for diversifying running contexts but not directly for generating exploitation. One is running inside namespaces responsible for triggering a free operation, while the other executes without the restriction of system resources attempting to dereference the data in the freed object.In addition to setting up kernel fuzzing for different initial contexts, we design two mechanisms to improve the efficiency of the kernel fuzzing framework. To expedite kernel fuzzing for hitting these vulnerable objects, we set up the parameters of system calls by using the file descriptor specified in the initial fuzzing context.Second, we expedite kernel fuzzing by reducing the amount of system calls that the fuzzing framework has to examine. The random input fed into kernel fuzzing could potentially crash kernel execution without providing useful primitives for exploitation (e.g., writing arbitrary data to an arbitrary address). Then, we look up these primitives and take them as candidate exploitable states while performing symbolic execution.Since primitives represent only the operations generally necessary for exploitation, but not reflect their capability in facilitating exploitation, we further evaluate the primitives guided by exploitation approaches commonly adopted, and deem those passing the evaluation as our exploitable states. They are commonly necessary for performing exploitation under a certain assumption.A control flow hijacking primitive describes a capability that allows one to gain a control over a target destination. To select primitives truly valuable for exploitation (i. e., exploitable machine states), we evaluate primitives as follows.As is specified in [26], with SMEP enabled, an attacker can use the following approach to bypass SMEP and thus perform control flow hijacking. 0x10000 represent the end of an unmapped memory region, and τ indicates the upper bound of the memory region in user space.Given SMEP enabled, another common approach [4] for bypassing SMEP and performing control flow hijacking is to leverage an invalid write to manipulate the metadata of the freed object. Since one could have the full control to the user space, he could modify the data in the new object (e.g., a function pointer) and thus hijack the consecutive execution of Linux kernel.To leverage this alternative approach to guide our evaluation, we retrieve the source and destination pertaining to each invalid write primitive. We deem a primitive matches this alternative exploitation approach only if the source indicates a valid user-space address or provides one with the ability to change the metadata to an address in user space.In addition to the approaches for bypassing SMEP, there is a common approach [21] to bypass SMAP and perform control flow hijacking. To address this issue, our design concretizes the symbolic value with a valid user-space address carrying the content to which we have the complete control.With this design, it is not difficult to note that, crafting an exploit with the symbolic address involved, one would have the difficulty in bypassing SMAP because an access to the user space is a clear violation to the protection of user-space read and write. To track down system calls as well as memory management operations in Linux kernel, we used ftrace to record information related to the memory allocation and free such as kmalloc(), kmem_cache_allocate(), kfree() and kmem_cache_free() etc.Since Linux kernel might utilize RCU, a synchronization mechanism, to free an object, which could potentially fail our dynamic tracing to pinpoint a dangling pointer at the right site, we also force our dynamic tracing component to invoke sleep(). Considering this set may not include the system calls which we have to perform fuzz testing against, our implementation complements declarative description for 16 system calls (see Appendix). Considering the symbolic execution might request the access to a page not loaded as the input to angr in its consecutive execution, we also detect uninitialized memory access by hooking the operations of angr (e.g., mem_read, mem_write) and migrate target pages based on the demand of symbolic execution with a broker agent. Last but not least, we therefore disabled CONFIG_RANDOMIZE_BASE option in all Linux kernels that we experiment.Regarding the configuration of FUZE, we performed kernel fuzzing and symbolic execution using a machine with Intel(R) Xeon(R) CPU E5-2630 v3 2.40GHz CPU and 256GB of memory. With this setup, we could prevent the explosion of our symbolic execution.To showcase FUZE can truly benefit the exploitation, we performed end-to-end exploitation using the exploitable machine states we identified. This means that, the exploits crafted for the same UAF vulnerability all utilizes different system calls to perform control flow hijacking and mitigation bypassing.Regarding the capability of disabling SMAP shown in Table 4, we discovered only 2 exploits publicly available and capable of bypassing SMAP. In this case, the exploit publicly available performs privilege escalation which bypasses SMAP without leveraging control flow hijacking.In addition to the ability of bypassing mitigation and diversifying exploits, Table 4 reveals the capability of FUZE in facilitating exploitability. For the two vulnerabilities above, their running contexts attached to the PoC programs have already carried valuable primitives, which symbolic execution could track down and expose for exploit generation.Last but not least, Table 4 also specifies some cases which FUZE fails to facilitate exploitation. Up until the submission of this work, for the cases tied to CVE-2013-7446, CVE-2017-15265 and CVE-2016, both exhaustive search and FUZE have not yet discovered any exploits indicating their ability to perform exploitation. It should be noticed that we do not discuss techniques for circumventing other kernel security mechanisms (e.g., PaX / Grsecurity [27]) simply because -for the performance concern -they are typically not widely deployed in modern OSes.Regarding the approaches of bypassing KASLR, a majority of research works focus on leveraging side-channel to infer memory layout in OS kernel. One is to utilize Return-Oriented Programming (ROP) to disable SMEP [18,26] or SMAP [21], while the other is to leverage implicit page frame sharing to project user-space data into kernel address space so that one could run shellcode residing in user memory without being interrupted by SMEP or SMAP [20]. To expedite the process of crafting an exploit to perform Data Oriented Programming (DOP) attacks, Hu et al. [14] introduce an automated technique to identify data oriented gadgets and chain those disjoint gadgets in an expected order.In addition to the aforementioned techniques, the past research explores fully automated exploit generation techniques.