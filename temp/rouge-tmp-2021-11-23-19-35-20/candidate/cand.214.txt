For instance, isolating cryptographic keys in a network-facing service can thwart vulnerabilities like the OpenSSL Heartbleed bug [37]; isolating a managed language's runtime can protect its security invariants from bugs and vulnerabilities in co-linked native libraries; and, isolating jump tables can prevent attacks on an application's control flow.Isolation prevents an untrusted component from directly accessing the private memory of other components. We survey techniques for isolation and switching provided by operating systems, hypervisors, compilers, language runtimes, and binary rewriting, as well as other work that uses MPK for memory isolation.OS-based techniques Isolation can be easily achieved by placing application components in separate OS processes. Novel kernel abstractions like light-weight contexts (lwCs) [33], secure memory views (SMVs) [24] and nested kernels [14], combined with additional compiler support as in Shreds [13] or runtime analysis tools as in Wedge [10], have reduced the cost of such data encapsulation to the point where isolating long-term signing keys in a web server is feasible with little overhead [33]. Settings that require more frequent switches like isolating session keys or the safe region in CPI [31], however, remain beyond the reach of OS-based techniques.Mimosa [20] relies on the Intel TSX hardware transactional memory support to protect private cryptographic keys from software vulnerabilities and cold-boot attacks. However, such isolation is languagespecific, relies on the compiler and runtime, and can be undermined by co-linked libraries written in unsafe languages.Software fault isolation (SFI) [47] provides memory isolation in unsafe languages using runtime memory access checks inserted by the compiler or by rewriting binaries. ERIM, on the other hand, provides strong isolation without relying on CFI and has lower overhead.ASLR Address space layout randomization (ASLR) is widely used to mitigate code-reuse exploits such as those based on buffer overflow attacks [43,23]. For example, as one of the isolation techniques used in CPI [31,46], a region of sensitive data is allocated at a random address within the 48-bit x86-64 address space and its base address is stored in a segment descriptor. Like prior work, it enables a (trusted) application component to isolate its sensitive data from untrusted components. The first invariant provides isolation of M T from U, while the second invariant prevents U from confusing T into accessing M T improperly by jumping into the middle of M T 's code.Background: Intel MPK To realize its goals, ERIM uses the recent MPK extension to the x86 ISA [28]. To prevent such exploits, ERIM relies on binary inspection to enforce the invariant that only safe WRPKRU and XRSTOR occurrences appear on executable pages.A WRPKRU occurrence is safe if it is immediately followed by one of the following: (A) a pre-designated entry point of T, or (B) a specific sequence of instructions that checks that the permissions set by WRPKRU do not include access to M T and terminates the program otherwise. U may behave arbitrarily and may contain memory corruption and control-flow hijack vulnerabilities that may be exploited during its execution.However, ERIM assumes that the trusted component T's binary does not have such vulnerabilities and does not compromise sensitive data through explicit information leaks, by calling back into U while access to M T is enabled, or by mapping executable pages with unsafe/exploitable occurrences of the WRPKRU or XRSTOR instruction.The hardware, the OS kernel, and a small library added by ERIM to each process that uses ERIM are trusted to be secure. A call gate transfers control from U to T by enabling access to M T and executing from a designated entry point of T, and later returns control to U after disabling access to M T . Efficiency A call gate's overhead on a roundtrip from U to T is two WRPKRUs, a few very fast, standard register operations and one conditional branch instruction. It also inspects any adjacent executable pages in the address space for instances that cross a page boundary.For every WRPKRU, it checks that the WRPKRU is safe, i.e., either condition (A) or (B) from Section 3.1 holds. An additional ERIM dynamic wrapper library is added using LD_PRELOAD, which wraps the entry points with stub functions that implement the call gates and have names that indicate to the ERIM runtime the 1 typedef struct secret { 2 int number; } secret; 3 secret * initSecret() { 4 ERIM_SWITCH_T; 5 secret * s = malloc(sizeof(secret)); 6 s->number = random();7 ERIM_SWITCH_U; 8 return s; 9 } 10 int compute(secret * s, int m) { 11 int ret = 0; 12 ERIM_SWITCH_T; 13 ret = f(s->number, m); 14 ERIM_SWITCH_U; 15 return ret; 16 } Listing 2: C component isolated with ERIM valid entry points. For instance, an application might need to restrict the filesystem name space accessible to U or restrict the system calls available to U.ERIM can be easily extended to support privilege separation with respect to OS resources, using one of the techniques described in Section 3.4 for intercepting systems calls that map executable pages. In this section, we show how to generate or modify program binaries to not contain unsafe WRPKRUs and XRSTORs, so that they pass the binary inspection.Intentional occurrences of WRPKRU that are not immediately followed by a transfer to T and all occurrences of XRSTOR, whether they are generated by a compiler or written manually in assembly, can be made safe by inserting the checks described in Section 3.4 after the instances. An x86 instruction contains: (i) an opcode field possibly with prefix, (ii) a MOD R/M field that determines the addressing mode and includes a register operand, (iii) an optional SIB field that specifies registers for indirect memory addressing, and (iv) optional displacement and/or immediate fields that specify constant offsets for memory operations and other constant operands.The strategy for rewriting an instruction depends on the fields with which the WRPKRU or XRSTOR subsequence overlaps. Whenever codegen outputs an inadvertent WRPKRU or XRSTOR, the surrounding instructions in the IR can be replaced with equivalent instructions as described above, and codegen can be run again.Runtime binary rewriting For binaries that cannot be recompiled, binary rewriting can be integrated with the interception and inspection mechanism (Section 3.4). Isolating cryptographic keys in web servers Isolating long-term SSL keys to protect from web server vulnerabilities such as the Heartbleed bug [37] is well-studied [33,34]. To verify this, we partitioned OpenSSL's low-level crypto library (libcrypto) to isolate the session keys and basic crypto routines, which run as T, from the rest of the web server, which runs as U.Native libraries in managed runtimes Managed runtimes such as a Java or JavaScript VM often rely on third-party native libraries written in unsafe languages for performance. For reference, the table also includes the cost of a simple syscall (getpid), the cost of a switch on lwCs, a recent isolation mechanism based on kernel page table protections [33], and the cost of a VMFUNC (Intel VT-x)-based extended page table switch.In our microbenchmark, calls with an ERIM switch are be- Table 2: Cycle counts for basic call and return tween 55 and 80 cycles more expensive than their no-switch counterparts. This corresponds to a total overhead of 2.7%, or about 0.43% for 100,000 switches a second.Scaling with multiple workers To verify that ERIM scales with core parallelism, we re-ran the first experiment above with 3, 5 and 10 NGINX workers pinned to separate cores, and sufficient numbers of concurrent clients to saturate all the workers. In all, we modified 300 LoC in LLVM's CPI/CPS pass.Like the original CPI/CPS paper [31], we compare the overhead of the original and our ERIM-protected CPI/CPS system on the SPEC CPU 2006 CINT/FLOAT benchmarks, relative to a baseline compiled with Clang without any protection. Table 6: Domain switch rates of selected SPEC CPU benchmarks and overheads for ERIM-CPI without binary inspection, relative to the original CPI with ASLR.CPI: The geometric means of the overheads (relative to no protection) of the original CPI and ERIM-CPI across all benchmarks are 4.7% and 5.3%, respectively. But before presenting these results, we provide a brief qualitative comparison of the techniques in terms of their threat models.Qualitative comparison of techniques Isolation using standard kernel page tables affords a threat model similar to ERIM's. While this is theoretically true, in this experiment, we already observe extremely high switch rates of 1.2M/s (for file size 0kb) and, even then, MPX's overhead is 8.4x that of ERIM's overhead.Further, as explained earlier, for strong security, SFI must be supported by control-flow integrity, which would induce additional overheads that are not included here.Extended page tables (VMFUNC) Next, we compare ERIM to isolation based on extended page tables (EPTs) using Intel VT-x and VMFUNC. This amounts to an overhead of at most 4.8% on the throughput of NGINX when isolating all session keys, which is up to 6.3x, 13.5x and 3x lower than the overhead of similar protection using SFI (with Intel MPX), lwCs and Intel VT-x, respectively.However, MPK by itself does not provide strong security because a compromised or malicious component can sim- ply write to the PKRU register and grant itself permission to access any component. This rewriting procedure can be integrated with a compiler or our binary inspection.ERIM is the first technique that enables efficient isolation in applications that require very high domain switching rates (~10 5 /s or more) and also spend significant time executing inside untrusted components. JITGuard [17], for instance, uses SGX to protect the internal data structures of a just-in-time compiler from untrusted code, thus preventing code-injection attacks. This instruction is relatively fast (11-260 cycles on current Intel CPUs), does not require a syscall, changes to page tables, a TLB flush, or inter-core synchronization.The PKRU register can also be modified by the XRSTOR instruction by setting a specific bit in the eax register prior to the instruction (XRSTOR is used to restore the CPU's previously-saved extended state during a context switch). We describe here three methods of developing applications or modifying existing applications to use ERIM.The binary-only approach requires that either U or T consist of a set of functions in a dynamic link library. While we have not yet integrated the logic into either a compiler or our inspection handler, the binaries used in our performance evaluation experiments do not have any unsafe WRPKRU occurrences and do not load any libraries at runtime. It has the switch overheads of hypervisor-based isolation using VM-FUNC but includes the OS kernel in the TCB.Unfortunately, MemSentry's patch works only on old Linux kernels which do not have the page table support needed for MPKs and, hence, cannot support ERIM. Burow et al.'s measurements of MPK overheads (Fig. 10 in [11]) are consistent with ours. A call gate enables access to M T using the WRPKRU instruction and immediately transfers control to a specified entry point of T, which may be an explicit or inlined function. Specifically, we link the widely-used C database library, SQLite, to Node.js, a stateof-the-art JavaScript runtime and map Node.js's runtime to T and SQLite to U. In principle, isolation using a hypervisor's extended page tables (VMFUNC) can afford a stronger threat model, in which the OS kernel need not be trusted [34]. The compiler approach requires modifications to the compiler to insert call gates at appropriate points in the executable and generate appropriate symbols that indicate valid entry points. We configure the benchmark to store the database in memory and report averages of 20 runs.The geometric mean of ERIM's runtime overhead across all tests is 4.3%. While ptrace() interception is expensive, note that it is required only when a program maps pages as executable, which is normally an infrequent operation.If programs map executable pages frequently, a more efficient interception can be implemented with a simple Linux Security Module (LSM) [50], which allows mmap, mprotect and pkey_mprotect system calls only from T. (Whether such a call is made by U or T is easily determined by examining the PKRU register value at the time of the syscall.) This amounts to an overhead of nearly 10% for an application that switches 100,000 times a second and, in our experiments, an overhead of up to 65% on the throughput of the web server NGINX when lwCs are used to isolate session keys (Section 6.5). To this end, ERIM combines MPK with binary inspection to ensure that all executable occurrences of WRPKRU or XRSTOR are safe, i.e., they cannot be exploited to improperly elevate privilege.Background: Linux support for MPK As of version 4.6, the mainstream Linux kernel supports MPK. 3) We show that ERIM can protect applications with high inter-component switching rates with low overhead, unlike techniques based on hardware (extended) page tables and SFI (even with hardware support). Session keys, on the other hand, are accessed far more frequentlyover 10 6 times a second per core in a high throughput web server like NGINX. The inspection prevents U from mapping any executable pages with unsafe WRPKRU and XRSTOR occurrences and consists of two parts: (i) an inspection function that verifies that a sequence of pages does not contain unsafe occurrences; and, (ii) an interception mechanism that prevents U from mapping executable pages without inspection.Inspection function The inspection function scans a sequence of pages for instances of WRPKRU and XRSTOR. Consequently, ASLR is not viable for strong memory isolation, despite proposals such as [35] to harden it.ARM memory domains ARM memory domains [7] are similar to Intel MPK, the x86 feature that ERIM relies on. We evaluate our ERIM prototype on three such applications: 1) Isolating the frequently accessed session keys in a web server (NGINX), 2) isolating a managed language runtime from native libraries written in unsafe languages, and 3) efficiently isolating the safe region in code-pointer integrity [31]. Next, we use ERIM to isolate the safe region of CPI and CPS [31] LLVM compiler pass to emit additional ERIM switches, which bracket any code that modifies the safe region. T's code may be invoked either by a direct call, or it may be inlined.After T has finished, the call gate sets PKRU to disable access to M T (lines 8-11). An optimization pass could hoist the domain switches out of the loops safely using only direct control flow instructions and enforcing store instructions to be bound to the application memory, but we have not implemented it yet. To isolate Node.js's stack from SQLite, we run Node.js on a separate stack in M T , and switch to the We measure overheads on the speedtest1 benchmark that comes with SQLite and emulates a typical database workload [4]. Therefore, unlike MPK, ARM's memory domains do not support low-cost user-mode switching.MPK-based techniques Koning et al. [30] present MemSentry, a general framework for da