Everspaugh et al. (Usenix Security '15) provided the first comprehensive treatment of such a service and proposed the Pythia PRF-Service as a cryptographically secure solution. The security of the Alice, 123456 Alice, salt H(salt,123456)Figure 1: Password-based Authentication passwords relies crucially on the assumption that the databases are kept secret from external attackers, and the internal administrators are trusted for not disclosing the databases or guessing the passwords themselves. It is not hard to see that any solution in which the web service can verify a given password alone is not viable, as a compromised service provider has all the knowledge (e.g., secret keys) to carry out a brute-force guessing attack (e.g., decrypting by the secret key of the web service) as in a normal validation. A promising approach for the web service provider is to use external crypto services [4], where a crypto server carries out certain cryptographic operations, such as the computation of pseudorandom functions (PRF). For incident response after key compromise, or to update the key proactively as a prudent practice, both the web server and the crypto service should be able to rotate their keys, without the end users noticing anything. We argue that both fail to cover key rotation and rate limiting, while the latter even leaves room for practicallyrelevant attacks.In response, we propose strengthened security definitions for password hardening schemes. To fill the gap, we formalize forward security of password hardening services, which captures the security guarantee in the presence of key rotation mechanisms.Modeling Online Attacks. Ideally, it should be guaranteed that the best attack strategy for guessing a password is to brute-force by repeatedly interacting with the crypto service online (modeled by the validation oracle in the security definition). By further exploiting the structure of the specific instantiation of the proof, the adversary can even extract the password directly: It first extracts the value g ys x from the proof π 2 , then computes pw = (T 2 /g ys x ) 1/sk C . For two PPT interactive algorithms A, B, we denote by (a, b) ←$ A(x), B(y) X the event that A and B engage in the protocol X on input x and y, and produce local outputs a and b, respectively. Each phase after the first is either an enrollment, a validation, or a key rotation phase, in an arbitrary order.In an enrollment phase, the client and the server cooperate to generate an enrollment record T for a username un, and a password pw, where un is an input available for both and pw is a private input from the client. A cryptographic password hardening service PH consists of the efficient algorithms (Setup, KGen C , KGen S , C, S enrl , C, S val , C, S rot , Udt), to be executed in four phases:Setup Phase. On input the public parameter pp, the client runs KGen C (pp) to generate a client public key pk C , and a client secret sk C , while the server runs KGen S (pp) to generate a server public key pk S , a server secret sk S . In the enrollment protocol C(sk C , un, pw, aux), S(sk S , un, aux) enrl , the client inputs its secret key sk C , a username un ∈ U, a password pw ∈ P, and some auxiliary information aux. In the validation protocol C(sk C , T, un, pw), S(sk S , un) val , the client inputs its secret key sk C , an enrollment record T , a username un ∈ U, and a password pw ∈ P. We therefore simply let un be a common input for both parties in the enrollment and the validation protocols.Hiding means that, given the client secret key sk C , a username un, and an enrollment record T of (un, pw) for some hidden password pw, the best strategy of any adversary to guess pw is by launching an online dictionary attack which requires interaction with the server via the validation protocol.Binding requires that it is computationally infeasible, even for a malicious server, to convince the client that an enrollment record T is valid for two distinct pairs (un, pw) and (un , pw ). In fact, in the syntax defined above, we let the client reveal the username un to the server explicitly by regarding un as a common input.Technically, we consider a security experiment played between a challenger acting as the client and an adversary acting as the malicious server. Since the adversary can use the server as the magical oracle by interacting with it in the validation protocol, the best we can hope for is that the adversary cannot perform significantly better than the above strategy.Technically, we consider a security experiment (see Figure 4) played between a challenger acting as the server and an adversary acting as the malicious client. The challenger then chooses a random password pw * (Line 7) from the distribution χ and computes a fresh challenge enrollment record T * for the tuple (un * , pw * ) using the honest client and server code (Line 8). hardening service PH is hiding if, for any two-stage PPT adversary A = (A 1 , A 2 ), there exists a negligible function negl (λ) such that HidingΠ,A (1 λ ) = 1 ≤ Q+1 i=1 p i + negl (λ)where the randomness is taken over the random coins of the experiment and the adversary, p i is the probability of the i-th most probable event in the distribution χ specified by A 1 in the experiment, and Q is the number of times ·, S(sk S , ·) val is queried by A 2 on server input un * . Alternatively, we consider a simpler definition based on the intuition that the rotated keys and enrollment records are indistinguishable from freshly generated ones.Technically, we consider a security experiment played between a challenger, acting as both the client and the server, and an adversary acting as a malicious outsider. The challenger then either rotates the keys and updates the enrollment record, or samples a new pair of keys and generates a fresh enrollment record for (un, pw), using some auxiliary information aux = L(T ), for some leakage function L. Rot b Π,A,L (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk C , sk S , T, un, pw, state) ←$ A 1 (pp) 3 : b 0 ← C(sk C , T, un, pw), S(sk S , un) val 4 : if b = 0 then 5 : ((pk C , sk C , τ ), (pk S , sk S )) ←$ C(sk C ), S(sk S )rot 6 :T ←$ Udt(τ, T, un)7 : else 8 : (pk C , sk C ) ←$ KGen C (pp), (pk S , sk S ) ←$ KGen S (pp) 9 : aux ← L(T ) 10 : T ←$ C(sk C , un, pw, aux), S(sk S , un, aux) enrl 11 : endif 12 : b 1 ←$ A 2 (state, sk C , sk S , T ) 13 : return b 0 ∧ b 1 Figure 6: L-Forward Security Experiment Pr Rot 0 Π,A,L (1 λ ) = 1 − Pr Rot 1 Π,A,L (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiments and the adversary. However, it is also weaker in other abilities:• Their embedded-password validation oracle embeds an enrollment record T output by the adversary. The idea is that, even given the client secret key sk C and the enrollment record T for some username un, the adversary can only guess the underlying password pw one at a time with the aid of the server. Curiously, the definition of Schneider et al. [21] does not model such an attack: In the second stage, after specifying the challenge passwords pw 0 and pw 1 , the adversary is no longer given access to the validation oracle. S should also delete all its intermediate values.To validate a candidate password pw , C computes the pseudorandom value h C ← PRF k C (un, pw , n C ), and performs a homomorphic operation on the ciphertext such that it now encrypts the product h S · h C /h C . Interestingly, with such an instantiation, an enrollment record is an encryption of H S (un, n S ) k S · H C (un, pw, n C ) k C , from which we can draw connection to Pythia [9], in which the record is computedSetup(1 λ ) crs ←$ Π.Gen(1 λ ), g ←$ G return (crs, g) KGen C (pp) pk C ← ⊥, sk C ← k C ←$ Zq return (pk C , sk C ) KGen S (pp) s, x, y, k S ←$ Zq h ← g s z ← g x h y pk S ← (h, z) sk S ← (s, x, y, k S )return (pk S , sk S ) Figure 7: Setup Phase of Phoenix as e(H S (un), H C (pw)) k S . Let Π be a standard non-interactive zero-knowledge proof of knowledge system for length-2 discrete logarithm representation (instantiated in Figure 11). Next, the server sends the server PRF value h S = H S (un, n S ) k S and the server nonce n S to the client, who computes the client PRF value h C = H C (un, n S ) k C locally, and encrypts the value h S · h C using an ElGamal-like encryption scheme as (g r , h r · h S · h C , z r ). If the proof passes verification, then the client is convinced that the candidate username and password satisfy h S = H S (un, n S ) k S and h C = H C (un, n S ) k C , and concludes that the enrollment record T is valid.Key Rotation Phase. The client sends an http request to /enroll?tweak=john and would get back a response in the following form: {hs="rPHu...LcQ==",ns="4qKM...uWQ="} We then measured the performance of Phoenix in comparison with Pythia and the scheme by Schneider et al. [21] on Amazon EC2 using t2.micro instances with the server running in Frankfurt and clients both on a separate t2.micro instance in Frankfurt and Ireland. Client C(sk C ) Server S(sk S )parse pk S as (h, z) parse sk S as (s, x, y, k S )parse sk C as k C α, β, γ, δ, η ←$ Zq ζ := δ + α · η · s + β · (y + η) k C ← α · k C α, β, γ, ζ k 1 ← α · k S + γ, s ← α · s + β pk C ← ⊥ x ← α · x + δ, y ← y + η sk C ← k C pk S ← (h α · g β , z α · g ζ ) τ ← (α, β, γ, ζ) sk S ← (s , x , y , k S ) return (pk C , sk C , τ ) return (pk S , sk S )Udt(τ, T, un)/ / Use the old server public key.parse pk S as (h, z)parse τ as (α, β, γ, ζ) We used the Nginx web server configured with ECDHE-ECDSA-AES128-GCM-SHA256 for TLS and uWSGI for the Python applications.parse T as (T 1 , T 2 , T 3 , n S , n C ) g S ← H S (un, n S ) v ←$ Zq T 1 ← T 1 · g v T 2 ← (T 2 · h v ) α · (T 1 · g v ) β · g γ S T 3 ← (T 3 · z v ) α · (T 1 · g v ) ζ return T ← (T 1 , T 2 , T 3 , n S , n C )Latency. uWSGI and Nginx were both configured to run with two processes to keep OS overhead on the single core server low.As shown in Table 2, Phoenix can process approximately 50 % more requests than the scheme by Schneider et al. and [23] suggest choosing a work factor of up to one second. The attack is simple yet of high practical relevance since it allows an offline password dictionary attack, which is supposedly avoided by the password hardening service.We propose the Phoenix password hardening service which greatly improves efficiency while satisfies all desirable security properties. Π = (Gen, Prove, Vf) is an adaptive non-interactive zero-knowledge (NIZK) proof system for a language L ∈ NP with the witness relation R if it satisfies the following properties:Completeness: For all x, w such that R(x, w) = 1, and common reference strings crs ∈ Gen(1 λ ), we have Vf(crs, x, Prove(crs, x, w)) = 1. Zero-Knowledge: There exists PPT simulator S = (S crs , S Prove ) such that, for all PPT adversaries A,| Pr[A Prove(crs,·,·) (crs) → 1 : crs ← Gen(1 λ )]− Pr[A S (crs,td,·,·) (crs) → 1 : (crs, td) ← S crs (1 λ )]| = (λ)where S (crs, td, x, w) = S Prove (crs, td, x). Furthermore, Π is a proof of knowledge (PoK) system if, for all PPT provers P * , there exists a PPT algorithm E P * such that| Pr[Vf(crs, x, π) = 1 ∧ (x, w) / ∈ R : crs ← Gen(1 λ ); (x, π) ← P * (crs), w ← E P * (crs, x, π)]| = (λ)For ease of reading, we denote by PoK{w : R(x, w) = 1} the execution of Prove(crs, x, w). For conciseness, consider an extended DDH problem, which asks to distinguish whetherc i ←$ Z q for i ∈ [t] or c i = a · b i for i ∈ [t], when given a tuple (g, g a , g b i , g c i ) t i=1for some t = poly (λ). EXP b,2 :When executing C(sk C , un * , pw * b , ), A 2 (st) enrl , since aux = , the challenger picks the client nonce n * C randomly and programs the random oracleH C on (un * , pw * b , n * C ) and (un * , pw * 1−b , n * C ). The challenger computes Proof: The idea of the proof is to gradually switch the challenge enrollment record to an entirely random one using hybrid argument. Upon receiving the chal- lenge request (un * , pw * 0 , pw * 1 ) from A, it programs H C (un * , pw * b , n * C ) := g γ and H C (un * , pw * b , n * C ) k C := g δ . Furthermore, when executing C(sk C , un * , pw * , ), S(sk S , un * , ) enrl , since aux = , the challenger picks fresh client and server nonces n * C and n * S respectively randomly and programs the random oracle H S on (un * , n * S ). Suppose that the DL assumption holds in G, and H S and H C are modeled as random oracles, then Phoenix is binding.Proof: Our idea is to program the random oracles so that they map inputs to random group elements, with their discrete logarithms known to the simulator. It generates crs honestly and sends pp := (crs, g 1 ) to A. B maintains dictionaries D 1 and D 2 mapping (un, n S ) and (un, pw, n C ) respectively to random exponents. The new record T is of the form T = (g r , g s r g k S S g k C C , g (x +s y )r ), where if b = 0 then r = r + v for a uniformly random v ←$ Z q , and if b = 1 then r ←$ Z q is sampled uniformly at random.