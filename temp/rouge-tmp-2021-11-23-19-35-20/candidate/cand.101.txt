In contrast to Man-inthe-middle attack, Mallory cannot eavesdrop the traffic transferred between a client C and a server S. Depending on the nature of the side channel, an unprivileged application or a sandboxed script may be required to run on the client side [40,27] to observe the results of the shared state change and determine the outcome of the spoofed packets (e.g., whether guessed sequence numbers are inwindow). seq is in rcv_window ) // shared state change 1 else // shared state change 2The example illustrates two variables: (1) the attackercontrolled variable in packet.seq -guessed sequence number in a spoofed packet and (2) the receive window deciding what in packet.seq are valid. Two necessary building blocks are needed in a TCP off-path side channel attack: (1) existence of vulnerable packet validation logic; (2) the shared state has to be observable by an attacker (i.e., the sandboxed script, unprivileged app, or the off-path attacker). Upon receipt of this challenge ACK, a legitimate remote peer who truly lost its connection, after a restart, sends a RST packet back with the sequence number derived from the ACK field of the challenge ACK, which can terminate the connection at that point. (3) HTTP pipeline is required so that a response arrives ahead of time will be deemed valid.This attack no longer works because the first culprit is eliminated by most modern operating systems (including Windows, Linux, Android), which adopted a more stringent check on ACK numbers as defined in RFC 5961 where only a much smaller window is considered valid. For instance, to infer if an ongoing connection exists, an off-path attacker can initially send a spoofed packet with one guessed port number and SYN bit set; after the attacker sends another 100 4 non-spoofed in-window RST packets to exhaust the challenge ACK count, it can then observe the number of responses to tell whether its initial spoofed packet matches the four tuples of an ongoing connection and hence triggers a challenge ACK.Since the shared rate limit is a simple software artifact, shortly after the vulnerability was reported, it was eliminated in a patch introduced in Linux 4.6 [8,42] where a per-socket rate limit is used instead. This effectively creates a timing channel that delays the local transmission if the opposite direction is transmitting at the same time.Even worse, this timing difference becomes more visible due to retransmissions caused by contention (collision). In addition to the RTT difference (RT T 2 > RT T 1), we can also measure the gap between the replies of the first query and the second, which should capture the delay effects similarly.In Fig. 3b, we also illustrate the amplifiable nature of the timing channel where the attacker sends two spoofed probing packets, causing more contention which delays post-probe query even further.In summary, this side channel allows an attacker to determine if the spoofed probing packets have triggered any response or not, coincidentally achieving the same purpose as the global IPID counter on Windows (which is no longer available). Half-duplex vs. Full-duplex To better understand that the significant part of the RTT difference is due to the half-duplex nature of wireless rather than the processing time to generate an ACK response on the client, we also conducted an experiment with the setup where both the victim and attacker machine connect to a Huawei router via ethernet. As depicted in Fig. 5, the timing side channel is no longer visible and amplifiable (note the heavily overlapped boxes), because of two reasons: (1) Now that downlink and uplink can transmit at the same time, there is simply no contention regardless of how many packets are transmitted. Subsequently, a sandboxed malicious script (by convention [25,27], we call them puppets) initiates a connection to the attacker (who is not necessarily close to the victim) to circumvent the reachability problem caused by NAT or firewall commonly found on wirelessly-connected clients. Based on this threat model, we consider a number of related attack goals:(1) inferring the presence of a connection from the client to a server (connection inference);(2) counting the number of bytes exchanged on the connection, or forcefully terminating the connection (sequence/ACK number inference); (3) injecting malicious payload into a connection (ACK number inference). If an incoming packet does not match any ongoing connec-tion, NAT and firewall will simply drop the packet, preventing the client from even observing it; if an incoming packet matches an ongoing connection, the packet is let through and handled as usual. This actually simplifies the connection inference, as the attacker can simply choose to send spoofed packets that always trigger responses (e.g., incoming SYN packets); if there is no response, it must be the case that no connection exists and packet is dropped by a NAT.For the second problem of real operating system implementations, we survey the latest Linux, macOS, and Windows in terms of their packet validation logic. In reality, packets belonging to different sockets can be processed simultaneously, and uplink and downlink should have equal access to the wireless channel rather than uplink waiting for downlink.path attacker now needs to guess a valid sequence number. For Linux, if 10 incoming ACK packets with just one-byte payload are received, depending on their sequence numbers, 10 responses are triggered (out-of-window), or at most 1 (in-window) due to rate limiting (row no. 1, 2, and 3). For macOS, if an incoming packet with no flags is received, a response is triggered for the out-of-window case; otherwise no response is triggered (row no. 10 and 11 Windows ACK In-window In-window 0 0 ⇤ : Due to rate limit in Linux, we can get at most 1 response per half a second. a : RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window; SND.MAX = latest unacknowledged sequence number Table 2: Behaviors on different OSes when processing 10 identical packets tuples and the expected sequence number, the attacker now needs to learn the correct ACK number to successfully inject malicious payload. As shown in Table 2, instead of always triggering an ACK packet for out-of-window ACK numbers, when the ACK number is too old (smaller than SND.UNA -MAX.SND.WND), Linux responds with an ACK (with rate limit); when the ACK number is too new (larger than SND.NXT), Linux incorrectly drops the packet without any reply (row no. 2 and 3). In addition, if a packet with in-window ACK number has no payload, Linux also ignores the packet with no response (row no. 6), which leaves no opportunity to differentiate the in-window and out-of-window cases (result similar to row no. 2 and 3). The issue is that when an ACK number is inferred, the client buffers the payload in its receive window, which is undesirable for two reasons: (1) it may cause future server's responses to be corrupted; (2) if selective ACK (SACK) is enabled, the client selectively acknowledges the data which has not actually been sent by the server, causing the server to ignore future packets from the client, effectively de-synchronizing the client and server. Therefore, in-window ACK numbers with the specific sequence number (i.e., RCV.NXT-1) still trigger responses (row no. 9) and yet no actual data are buffered at the client, while out-of-window ACK numbers can trigger at most one reply (line 7 and 8 in Table 2). Initially, we were surprised to find that an incoming data packet with an in-window sequence number is always silently dropped unless the ACK number is equal to SND.UNA or SND.NXT (the connection is idle during our initial experiments so the two numbers are equal). However, if the attacker is attempting to conduct web cache poisoning attack later on, it is possible to target a connection initiated by the puppet itself [25], which opens up an additional optimization below taking advantage of the ephemeral port selection algorithm employed by different OSes. To avoid bruteforcing all possible port numbers, we develop an optimized strategy based on the observation that local port numbers allocated for the same remote server and port pair are sequential; therefore, the puppet can potentially create n connections to the target server and only needs to test the port number every n increments.At this point, we can conduct the side channel attack on the connection of which we guessed the correct port number. In principle, the attacker can hijack any connection initiated by the client; it is simply more difficult to control the timing and predict what fake response to inject.Since all three systems do not comply with the specifications in terms of ACK validation, we have to cope with each variant differently: MacOS incorrectly interpreted the standard, allowing us to perform a binary search (see §4). The i th packet has a guessed ACK number i·|wnd|, and contains payload as:websocket.send(i · |wnd|) Hence, exactly one of these packets contains a valid ACK number and will be buffered. Note that the attack strategy against Windows is even more efficient than the one for Linux because only one round of bruteforcing of ACK numbers is needed.Furthermore, there exists an even more general alternative strategy to the inject step against Windows that does not depend on browser behaviors at all. Latency may vary under different network conditions, thus it is a bad idea to manually set a threshold to differentiate a quiet probe round (without triggering ACKs) versus a responsive probe round (triggering ACKs). However, a threshold too low runs the risk of misclassifying a quiet round into a responsive round, missing the correct guess altogether; this forces us to repeat the whole search process. Pipeline In order to significantly reduce the time the attack costs, instead of simply probing a single SEQ/ACK number at a time, we also use a pipelined process aiming at maximizing network utilization by scheduling probing packets for multiple targets at appropriate times. Second, as 2.4GHz networks tend to influence each other, we have also conducted the measurement in the lab where there were 43 accessible Wi-Fi in total, 22 of which were 2.4GHz network and 6 used the same channel that our test router used; there were also more than 10 students actively using the network. Furthermore, even if HTTPS is deployed on all pages, attackers could still mount the attack, as long as HTTP Strict Transport Security (HSTS) is absent; this is because the initial request to the website will still use HTTP and it is the server that subsequently redirects the browser to its HTTPS site. Besides longer RTTs compared to that of a local setup, the significant time cost is attributed to the following factors: (1) Regarding sequence number inference upon MacOS, though an attacker can send probing packets without any flags as shown in table 2, we found those packets are likely to be discarded in a real-world network environment. To cope with it, we send probing packets with ACK bit set and guess two acknowledgement numbers (e.g., 0 and 2G) for every guessed sequence number, effectively doubling the number of packets sent. Finally, as confirmed in our test routers, modern wireless routers all support CSMA/CA and RTS/CTS as it is part of the 802.11 standards [31], and the principle is unlikely to change any time soon.Although we only discuss the threat model where connections originated from a victim client are targeted, the attack actually also applies to connections originated from other clients connected through the same wireless router. In such cases, a completely off-path attack can be launched against a connection on such IoT devices, e.g., counting bytes exchanged on the connection, terminating its connection with another host, injecting malicious command on an ongoing telnet connection (similar to the capability described in [18]). Even though IEEE 802.11ax working group has been considering the possibility of supporting in-band full-duplex communication [2], research still needs to be done to make sure the real-world challenges such as backward compatibility are carefully considered and addressed [12,30]. Assuming an incoming packet already has a valid sequence number, the only constraints we have here are:(1) if it is a data packet and its ACK number is also inwindow, a correct TCP receiver should always respond with an ACK (or delayed ACK); (2) when a pure ACK with sequence number in-window and ACK number inwindow arrives, there should be no response (otherwise, an ACK war [6] may be triggered). In the remaining cases: (3) a data packet with outof-window ACK number; (4) a pure ACK with out-ofwindow ACK number, their responses appear to be flexible in practice -see row no. 2, 3, 13, 16, and 18 in Table 2) for the data packet case and row no. 2, 3, 12, 13, and 18 for the pure ACK case. The same rate limiting idea applies to connection identification, where packets are likely dropped by NAT or firewall if no connection is present and some response will be triggered if there is an active connection.Defenses in Application layer Clearly, HSTS and HTTPS will help ward off most serious web attacks such as the web cache poisoning attack. HSTS and HTTPS can prevent only web cache poisoning attack (application-layer attacks) but not the TCP-level attacks.Some versions of our attack also exploit features of browser implementations, and thus we believe some mitigations can be made in the browser (i.e., make parsing of responses stricter) to complicate the ACK number inference step. Finally, connection inference (privacy breach) and sequence number inference (byte counting and reset) attacks remain potent as they only rely on the TCP stack.For the purpose of supporting further research to reproduce and mitigate the attack, we open sourced our implementation of the attack against different OSes, now publicly available at [5].