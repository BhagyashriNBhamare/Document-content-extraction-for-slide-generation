Our evaluations on a broad set of attack behaviors and micro-benchmarks show that our system has a low detection latency (<2s) and a high system through-put (110,000 events/s; supporting ∼4000 hosts), and is more efficient in memory utilization than the existing stream-based complex event processing systems. Our system takes as input a real-time event feed aggregated from multiple hosts in an enterprise, and provides an anomaly query engine.The query engine provides a novel interface for users to submit anomaly queries using our domain-specific language, and checks the events against the queries to detect anomalies in real-time. SAQL provides (1) the syntax of event patterns to ease the task of specifying relevant system activities and their relationships, which facilitates the specification of rule-based anomalies; (2) the constructs for sliding windows and stateful computation that allow stateful anomaly models to be computed in each sliding window over the data stream, which facilitates the specification of time-series anomalies, invariant-based anomalies, and outlier-based anomalies (more details in Section 2.2). The specified models in SAQL are checked using continuous queries over unbounded streams of system monitoring data [51], which report the detected anomalies continuously.Rule-based anomalies allow system experts to specify rules to detect known attack behaviors or enforce enterprise-wide security policies. SAQL provides constructs to define and learn the invariants of system behaviors in each state computed from a window, which allow users to combine both states of windows and invariants learned under normal operations to detect more types of abnormal system behaviors.Outlier-based anomalies allow users to identify abnormal system behavior through peer comparison, e.g., finding outlier processes by comparing the abnormal processes with other peer processes. Deployment and Evaluation: We built the whole SAQL system (around 50,000 lines of Java code) based on the existing system-level monitoring tools (i.e., auditd [15] and ETW [13]) and the existing stream management system (i.e., Siddhi [20]). We performed a broad set of attack behaviors in the deployed environment, and evaluated the system using 1.1TB of real system monitoring data (containing 3.3 billion events): (1) our case study on four major types of attack behaviors (17 SAQL queries) shows that our SAQL system has a low alert detection latency (<2s); (2) our pressure test shows that our SAQL system has a high system throughput (110000 events/s) for a single representative rulebased query that monitors file accesses, and can scale to ∼4000 hosts on the deployed server; (3) our performance evaluation using 64 micro-benchmark queries shows that our SAQL system is able to efficiently handle concurrent query execution and achieves more efficient memory utilization compared to Siddhi, achieving 30% average saving. We next present how to use SAQL as a unified interface to specify various types of abnormal system behaviors.Rule-based Anomaly: Advanced cyber attacks typically include a series of steps that exploit vulnerabilities across multiple systems for stealing sensitive information [2,1]. Query 1 shows a SAQL query for describing an attack step that reads external network (evt1), downloads a database cracking tool gsecdump.exe (evt2 ), and executes (evt3) it to obtain database credentials.It also specifies these events should occur in ascending temporal order (Line 4). To achieve invariant-based anomaly detection, SAQL provides constructs of invariant models and learning specifics to define and learn invariants of system behaviors, which allows users to combine both stateful computation and invariants learned under normal operations to detect more types of abnormal system behaviors [35]. Query 3 shows a SAQL query that specifies a 10-second sliding window (Line 1), maintains a set of child processes spawned by the Apache process (Lines 2-4), uses the first ten time windows for training the model (Lines 5-8), and starts to detect abnormal child processes spawned by the Apache process (Line 10). 'in' val set | agg func '(' attr exp (',' attr exp)*')' | attr exp set op attr exp | '|' attr exp '|' | peer ref '(' attr exp')' temp rel ::= 'with' id (('->'|'<-') ('[' num '-' num time unit']')? {' inv init+ inv update+ '}' inv init ::= id ':=' (num|empty set) inv update ::= id '=' attr exp state cluster ::= 'cluster' '(' point def ',' distance def ',' method def ')' point def ::= 'points' '=' peer ref '(' attr (',' attr)* ')' distance def ::= 'distance' '=' dist metric method def ::= 'method' '=' cluster method '(' num (',' num)* ')'Context-Aware Syntax Shortcuts:• Attribute inferences: (1) default attribute names will be inferred if only attribute values are specified in an event pattern, or only entity IDs are specified in event return. State Invariant: The state inv rule specifies invariants of system behaviors and updates these invariants using states computed from sliding windows (i.e., invariant training), so that users can combine both states of windows and invariants learned to detect more types of abnormal system behaviors. This enables SAQL to specify a broad set of detection logics for time-series anomalies (e.g., Line 5 in Query 2), invariant-based anomalies (e.g., Line 9 in Query 3), and outlier-based anomalies (e.g., Line 7 in Query 4). The concurrent query scheduler inside the query optimizer analyzes the newly arrived anomaly model context against the existing anomaly model contexts of the queries that are currently running, and computes an optimized execution schedule by leveraging the master-dependent-query scheme. Given that the execution pipeline of a query typically involves four phases (i.e., event pattern matching, stateful computation, alert condition checking, and attributes return), the key idea is to maintain a map M from a master query to its dependent queries, and let the execution of dependent queries share the intermediate execution results of their master query in certain phases, so that unnecessary data copies of the stream can be significantly reduced. Algorithm 1 shows the scheduling algorithm:Algorithm 1: Master-dependent-query schemeInput: User submitted new SAQL query: newQ Map of concurrent master-dependent queries: M = {masQ i → {depQ i j }} Output: Execution results of newQ if M.isEmpty then return execAsMas(newQ, M); else for masQ i in M.keys do covQ = constructSemanticCover(masQ i , newQ); if covQ = null then if covQ = masQ i then replMas(masQ i , covQ, M); addDep(covQ, newQ); return execDep(newQ, covQ); return execAsMas(newQ, M);Function constructSemanticCover(masQ,newQ)if Both masQ and newQ define a single event pattern then if masQ and newQ share the same event type, operation type, and sliding window type then Construct the event pattern cover evtPattCovQ by taking the union of their attributes and agent IDs and the GCD of their window lengths; if Both masQ and depQ define states then if masQ and depQ have the same sliding window length and masQ defines a super set of state fields of depQ then Construct the state cover stateCovQ by taking the union of their state fields; return covQ by concatenating evtPattCovQ, stateCovQ, and the rest parts of masQ; return null; Function execAsMas(newQ, M)Make newQ as a new master and execute it; Function addDep(masQ, depQ, M)Add depQ to the dependencies of masQ; Function replMas(oldMasQ, newMasQ, M)Replace the old master oldMasQ with the new master newMasQ and update dependencies; Function execDep(depQ, masQ) if depQ == masQ then return execution results of masQ; else if Both masQ and depQ define states then if masQ and depQ have the same sliding window length and masQ defines a super set of state fields of depQ then Fetch the state aggregation results of masQ, enforce additional filters, and feed into the execution pipeline of depQ; elseFetch the matched events of masQ, enforce additional filters, and feed into the execution pipeline of depQ;1. The scheme currently enforces the results sharing in two execution phases: event pattern matching and stateful computation: (1) if both dep and masQ define states and their sliding window lengths are the same, the engine fetches the state aggregate results of masQ; (2) otherwise, the engine fetches the matched events of masQ without its further state aggregate results. • We construct a time-series anomaly query (Query 13) based on SMA to detect the scenario where abnormally high volumes of data are exchanged via network on the database server (i.e., step c5): For every process on the database server, this query detects the processes that transfer abnormally high volumes of data to the network. • We also construct an outlier-based anomaly query (Query 14) to detect processes that transfer high volumes of data to the network (i.e., step c5): The query detects such processes through peer comparison based on DBSCAN. To demonstrate the effectiveness of the SAQL system in supporting timely anomaly detection, we measure the following performance statistics of the query execution:• Alert detection latency: the difference between the time that the anomaly event gets detected and the time that the anomaly event enters the SAQL engine. We select Siddhi [20], one of the most popular stream processing and complex event processing engines, for baseline comparison.Micro-Benchmark Construction: We construct our micro-benchmark queries by extracting critical attributes • Browsers access files: finding files accessed by the processes chrome, firefox, iexplore, and microsoftedge. Note that unlike SAQL which provides explicit constructs for stateful computation, Siddhi as well as other stream-based query systems [20,12,51,4], do not provide the native support for these concepts, making these tools unable to specify advanced anomaly models (i.e., time-series anomalies, invariant-based anomalies, outlier-based anomalies). Parallelizing the SAQL query execution can be achieved through a query-based manner (i.e., allocating one computing resource for executing a set of queries over the entire stream), a substream-based manner (i.e., allocating one computing resource for executing all compatible queries over a set of sub-streams), or a mixed manner. Again, we would like to point out that the major focus of our work is to provide a useful interface for investigators to query a broad set of abnormal behaviors from system audit logs, which is orthogonal to the computing paradigms of the underlying stream processing systems.System Entities and Data Reduction: Our current data model focuses on files, processes, and network connections. Security-Related Languages: There exist domainspecific languages in a variety of security fields that have a well-established corpus of low level algorithms, such as cryptographic systems [33,34,70], secure overlay networks [61,72], and network intrusions [36,44,82,86] and obfuscations [47]. However, these CEP systems alone do not provide language constructs to support stateful computation in sliding windows, and thus lack the capability to express stateful anomaly models as our system does.Stream Computation Systems: Stream computation systems allow users to compute various metrics based on the stream data. Our evaluation results on 17 attack queries and 64 micro-benchmark queries show that the SAQL system has a low alert detection latency and a high system throughput, and is more efficient in memory utilization than the existing stream processing systems. starttime, evt3.starttime 8 return p1, i1, p2, f1, p3, f2, p4, i2, evt1.starttime , evt2.starttime, evt3.starttime, evt4.starttime, evt5.starttime Query 10: apt-c4 evt1 // attacker executes osql.exe on the sql server 3 proc p3["%sqlservr.exe"] write file f1["%backup1.dmp" ] as evt2 // attacker dumps the DB content 4 proc p4["%sbblv.exe"] read file f1 as evt3 // malware reads the dump 5 proc p4 read || write ip i1[dstip="XXX"] as evt4 // malware transfers the dump to the attacker 6 with evt1 -> evt2 -> evt3 -> evt4 7 return p1, p2, p3, f1, p4, i1, evt1.starttime, evt2. starttime, evt3.starttime 8 return p1, i1, p2, f1, p3, f2, p4, i2, evt1.starttime , evt2.starttime, evt3.starttime, evt4.starttime, evt5.starttime Query 10: apt-c4 evt1 // attacker executes osql.exe on the sql server 3 proc p3["%sqlservr.exe"] write file f1["%backup1.dmp" ] as evt2 // attacker dumps the DB content 4 proc p4["%sbblv.exe"] read file f1 as evt3 // malware reads the dump 5 proc p4 read || write ip i1[dstip="XXX"] as evt4 // malware transfers the dump to the attacker 6 with evt1 -> evt2 -> evt3 -> evt4 7 return p1, p2, p3, f1, p4, i1, evt1.starttime, evt2.