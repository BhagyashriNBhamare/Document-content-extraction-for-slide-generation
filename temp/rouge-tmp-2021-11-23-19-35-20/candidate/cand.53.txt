While we could have also investigated path exploration, the main focus of Digtool is vulnerability detection.Depending on the detection targets, vulnerability identification tools can be classified into two categories: (1) tools for checking applications in user mode, and (2) tools for detecting programs in kernel mode. However, since they rely on the implementation details and the source code of the OS, it is difficult to port these tools to other OSes, especially to a closed-source OS such as Windows.In Windows OS, a notable tool for checking kernel vulnerabilities is Driver Verifier [28], which is used to detect illegal function calls or actions that might corrupt the system. â€¢ Based on the framework, virtualization-based detection algorithms are designed to discover four types of vulnerabilities, including UNPROBE (no probe, i.e., no checking on the user pointer to the input buffer), TOCTTOU, UAF, and OOB. They can lead to denial-of-service attacks, local privilege escalation, and even remote code execution, which directly affect the stability and security of the victim program.No checking of a user pointer to an input buffer could lead to a vulnerability that is denoted UNPROBE in this paper. While fuzzing based on path exploration can help solve some problems, it is difficult to test all pointer arguments nested in complicated structures.A TOCTTOU vulnerability stems from fetching a value from user memory more than once. Similar to UNPROBE above, TOCTTOU could also result in an invalid memory reference, an arbitrary memory read, or an arbitrary memory overwrite. In addition, the bochs emulator cannot simulate all actual operations and functionalities of a real-world machine (e.g., inability to emulate certain real, hardware-specific kernel modules, such as modern video card drivers). As an alternative, QEMU [11] or the recent extension PEMU [42] could be used to implement kernel program instrumentation for the Windows OS, but it is complicated and has a heavier effect on performance even without monitoring memory access.Therefore, there is a clear need to develop an efficient alternative mechanism for tracing memory access outside a guest OS. In order to build a practical framework that focuses on the virtual address space, a shadow page table (SPT) based on hardware virtualization technology is employed to monitor virtual memory access, which is very different from Xenpwn and Bochspwn in both design and implementation.In kernel space, the major work includes setting the monitored memory area, communicating with the hypervisor, and intercepting specified kernel functions. The loader activates the hypervisor and loads the fuzzer that is used to probe program paths.Thus, the behavior characteristics in the probed paths can be recorded for the log analyzer.Unlike emulator-based tools (e.g., Bochspwn [24]), Digtool is able to run in a physical machine with this architecture design. Digtool does not rely on any current hypervisor such as Xen or KVM, and we implemented our own hypervisor that contains three important components, including VMM infrastructure (VMM, i.e., virtual machine monitor, which is equivalent to a hypervisor), interface detection, and memory detection.To begin with, VMM infrastructure checks the hardware environment and the OS version to ensure compatibility. The initialization of the hypervisor mainly consists of the following tasks: (1) building SPTs to monitor virtual memory access in the guest OS, (2) initializing modules for tracing thread scheduling, and (3) establishing communication between the OS kernel and the hypervisor. In order to focus on vulnerabilities in a limited scope of system calls, interface detection is able to configure the detection scope of system calls through correlative service interfaces. Thus, the hypervisor can detect vulnerabilities in the environment of the fuzzer process.For interface detection, the middleware records all behavior events in log files through a work thread. A higher path-coverage rate can certainly help achieve a more comprehensive test. Thus, access to the monitored virtual page will trigger a #PF (i.e., page fault) exception that will be captured by the hypervisor.When the #PF exception is captured, the page-fault handler in the hypervisor will search for the BitMap. The private interrupt handler stores some information (e.g., the memory address that is accessed, and the instruction that causes the #PF) about the #PF exception, and then it connects to a debug tool by triggering another exception, such as software interruption, in the guest OS. With respect to how to acquire KPRCB, the methods described in ARGOS [43] could be leveraged to uncover this data structure, though currently we use manual reverse engineering and internal Windows kernel knowledge to get it. Thus, the service routines in the hypervisor can handle the requests.The shared memory is applied to exchange data between the hypervisor and kernel code. It also records characteristic information into log files.The following stream of instructions is shown by the thin arrows in Figure 3: (1) When the target module (which is being detected) triggers an event monitored by the hypervisor, a VMEXIT will be captured by the hypervisor. It then decides whether the check or the use of these parameters will create potential hazards.Interface detection monitors the entire execution process of system calls from the point of entering into kernel mode to the point of returning to user mode. These behavior events and their interception methods make up the events monitor.Ten types of behavior events are defined in the event monitor: Syscall, Trap2b, Trap2e, RetUser, MemAccess, ProbeAccess, ProbeRead, ProbeWrite, GetPebTeb, and AllocVirtualMemory events. Particular combinations of these events can help locate potential vulnerabilities in the large amount of log data (e.g., two continuous MemAccess events suggest a potential TOCTTOU vulnerability). The M i and M j under the boxes represent the user memory addresses accessed by the event.In the Windows OS, fast system call, interruption of 0x2b, and interruption of 0x2e are the three entry points that allow user-mode code to invoke kernel functions. It is noticed that, the user-mode pages are monitored only if the processor runs in kernel mode, and this will significantly reduce the performance cost.To improve the efficiency of discovering and analyzing vulnerabilities, interface detection also defines and intercepts some other behavior events, including ProbeAccess, ProbeRead, ProbeWrite, GetPebTeb, and AllocVirtualMemory. These events inform the log analyzer that the access to user memory is legal and that no bug exists.In addition to invoking the ProbeForRead (i.e., ProbeRead event) or ProbeForWrite (i.e., ProbeWrite event) function, kernel code can also adopt direct comparison to check the legitimacy of the user memory address; for example, "cmp esi, dword ptr [nt!MmUserProbeAddress (83fa271c)]" where the esi register stores the user memory address to be checked, and the exported variable nt!MmUserProbeAddress stores the boundary of the user memory space. For this particular type of event, the CPU emulator is proposed.The CPU emulator is placed in the hypervisor to help obtain behavior characteristics that are difficult to obtain through regular methods. The CPU emulator is implemented by interpreting and executing a piece of code of the guest OS. The address of target memory can be set by the configuration file of the loader, and then the hypervisor obtains the target memory through the middleware and monitor the memory access through DR registers. Since the debug exception is a trap event, the start address for the CPU emulator is the instruction directly before the guest EIP register.As the ProbeAccess event adopts direct comparison to check pointer parameters for a system call, the CPU emulator should focus on cmp instructions when it interprets and executes the code of the guest OS. For the Windows kernel and device drivers, user memory (pointed by a user pointer) can be accessed under the protection of structured exception handling (SEH) at any time. If there is no such type of checking event before a MemAccess event, there may be an UN-PROBE vulnerability in the kernel code.To detect an UNPROBE vulnerability, we focus on whether there is a checking event before a MemAccess event, and whether the virtual addresses in the two events are the same. We therefore propose the use of CPU emulator to detect UNPROBE vulnerabilities.Take Figure 4 as an example, at the event time of "n + 3", the kernel code triggers a MemAccess event by accessing user memory. In contrast, if there is a ProbeAccess/ProbeRead/ProbeWrite event or GetPebTeb/AllocVirtualMemory event to suggest that the user address is legal, and the event is trig-gered in the same system call as the MemAccess event, the code is safe.To detect an UNPROBE vulnerability, the fuzzer invokes the test system calls and tries to discover as many branches as possible by adjusting their parameters. Thus, the user-mode code has a chance to change the parameter referenced by the pointer.Take Figure 4 again for instance, if a piece of kernel code accesses the same user memory at the time of "n + 2" and "n + 3," there may be a TOCTTOU vulnerability in the kernel code. After freeing block A, another program allocates a memory block B that covers the entire memory of block A. Then, the first program tries to manipulate block A through the pointer P. Obviously, there is a UAF vulnerability in the first program. Thus, when a monitored page (not a memory area) is accessed (note that the monitoring granularity of memory virtualization is a page, but the size of a memory area may be less than a page; the monitored pages are recorded via the BitMap, while the monitored memory areas are stored in the AVL tree.) A brittle program tries to access block A with a pointer and an offset, but the offset is so large that the accessed address locates in block B. Taking a vulnerability in Avast 11.2.2262 as an example, through the log analyzer, the following data were obtained from the Digtool's log file for Avast 11.2.2262: N t A l l o c a t e V i r t u a l M e m o r y : Eip : 89993 f3d , Address : 0023 f304 , rw : R Eip : 84082 ed9 , Address : 0023 f304 , PROBE ! For security reasons, we only give the system calls for which vulnerabilities exist.When the log analyzer points out a potential UN-PROBE vulnerability, and the tested driver only uses the ProbeForRead and ProbeForWrite functions to check a user pointer (this is a common scenario in third-party drivers), no human effort is needed for further confirmation as the detection is precise due to the facts that the start address and length information of the input buffer can be obtained through the corresponding kernel function. Taking a vulnerability in Dr. Web 11.0 as an example, through the log analyzer the following dynamic characteristics were distilled from Digtool's log file for Dr. Web 11.0:N tC re at e Se ct io n : Count :3 ======= ======= Eip : 83 f0907f Address :3 b963c Sequence :398 rw : R Eip : 89370 d54 Address :3 b963c Sequence :399 rw : R Eip : 89370 d7b Address :3 b963c Sequence :401 rw : R K i F a s t S y s t e m C a l l R e tThe user address 0x3b963c was accessed by the kernel instructions more than once, so there may be a TOCT-TOU vulnerability. Owing to the fact that Bochspwn [24], which is based on the bochs emulator [25], only detects TOCTTOU vulnerabilities among the four types of vulnerabilities by now, we tested Digtool's performance cost in detecting TOCT-TOU vulnerabilities, and compared its performance with that of the bochs emulator in the same environment (i.e., the same hardware platform, OS version, parameters of system calls, and arguments of the test program). "Windows" denotes the performance of a clean OS without any tools, and "bochs" represents the performance cost of the OS running into bochs emulator.In the case of "unrecorded," the result of system calls showed that Digtool is from 2.18 to 5.03 times slower than "Windows," but 45.4 to 156.5 times faster than "bochs." Much more human effort is needed to locate the error.Taking MS16-090/CVE-2016-3252 [2] as an example, Digtool exactly locates the instruction (just before 0x93e34bf9) that causes the vulnerability: However, from Driver Verifier, the captured context is as follows: Driver Verifier only points out a "bad pool" (OOB) error, but does not provide an exact context for the vulnerability. Via virtualization technology, the hypervisor runs outside of the guest OS, which tends to be more portable and has the potential of supporting other OSes. Grosso et al. [19] also presented a method of detecting buffer overflows for C code that does not need human intervention to define and tune genetic algorithm weights, and therefore it becomes completely automated.Static analysis achieves a high rate of code coverage, but its precision may be insufficient when dealing with difficult language constructs and concepts. However, all of the similar tools need to expand the source code of Linux or insert detection code at compile-time, and thus it is difficult to port them to a closed-source OS like Windows.Driver Verifier [28] is the major tool for detecting bugs in the Windows kernel. As part of the kernel, in fact, Driver Verifier also relies on the source code of the OS.Although the above tools can be applied to detect kernel vulnerabilities, they are too tightly coupled with implementation details and the source code of OSes, so they cannot work when no source code is available. With these behaviors, Digtool has identified 45 zero-day vulnerabilities among both kernel code and device drivers.