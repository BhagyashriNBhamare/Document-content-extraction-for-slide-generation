Information hiding (IH) is an important building block for many defenses against code reuse attacks, such as code-pointer integrity (CPI), control-flow integrity (CFI) and fine-grained code (re-)randomization, because of its effectiveness and performance. It employs randomization to probabilisti-cally "hide" sensitive memory areas, called safe areas, from attackers and ensures their addresses are not leaked by any pointers directly. Information hiding (IH) is a software-based security technique, which hides a memory block (called "safe area") by randomly placing it into a very large virtual address space, so that memory hijacking attacks relying on the data inside the safe area cannot be performed. For example, O-CFI [40] uses IH to protect all targets of indirect control transfer instructions; CPI [30] uses IH to protect all sensitive pointers; RERANZ [57], Shuffler [59], Oxymoron [4], Isomeron [15] and ALSRGuard [36] use IH to protect the randomization secrets.For a long time, IH was considered very effective. To address this challenge, after re-randomizing the safe areas, SafeHidden utilizes hardware transactional memory (i.e., Intel TSX [2]) to determine which TLB entries were loaded before re-randomization and preload these entries to avoid future TLB misses.Detecting TLB misses is further complicated by a new kernel feature called kernel page table isolation (KPTI) [1]. Because a safe area is mostly placed in an unmapped area, an attacker can probe its surrounding areas to find its location without causing exceptions or crashes.All probing attacks need to use such covert techniques to probe the memory many times without causing crashes because the size of a user's memory space is very large. As only certain virtual addresses map to a specific cache set, the virtual address of the safe area can be inferred using cache side-channel analysis.However, it is worth mentioning that to successfully determine the virtual address of one memory area, hundreds of such Prime+Probe or Evict+Time tests are needed. We assume the design of the defense is not flawed: That is, before launching code reuse attacks, the attacker must circumvent the defense by revealing the locations of the safe areas (e.g., using one of many available techniques discussed in Section 2.2). • Vector-1: Gathering memory layout information to help to locate safe areas, by probing memory regions to infer if they are mapped (or allocated); • Vector-2: Creating opportunities to probe safe areas without crashing the system, e.g., by leveraging resumable exceptions; • Vector-3: Reducing the entropy of the randomized safe area locations to increase the success probability of probes, by decreasing the size of unmapped areas or increasing the size of safe areas; • Vector-4: Monitoring page-table access patterns using cache side-channels to infer the addresses of safe areas, while triggering legal accesses to safe areas. When the thread-local safe area is protected using such a scheme, the entropy will not be reduced by thread spraying because any thread sprayed by an attacker can only access its own local safe area.To mitigate Vector-4, SafeHidden also monitors legal accesses to the safe area that may be triggered by the attacker. Since they do not have pointers pointing to the safe areas, probing other areas do not leak the locations.To avoid excessive use of the virtual memory space, SafeHidden sets an upper limit on the total size of all trap areas (the default is 1 TB). For accesses to unmapped areas, an immediate alarm may cause false positives because the application may also issue memory management system calls, system calls with an EFAULT return value, or a memory access that touches unmapped memory areas. The modification of the kernel is too complex, which cannot be implemented as a loadable kernel module: For example, to be compatible with kswapd, the reference page table must be synchronized with the private page tables of each thread, which requires tracking of CPU accesses of each PTE (especially the setting of the accessed and dirty bits 2 by CPU). two threads of the same program, both the virtual CR3 registers point to the page table of the program, and both EPT pointers (EPTPs) of VCPUs are pointing to a shared EPT.To implement a thread-private memory, we can instead make each EPTP to point to a separate EPT to maintain its own thread-private memory. Thus, when a TLB miss occurs, it is trapped into the page fault handler and triggers the following actions: (1) It performs one round of randomization for the safe area; (2) It clears the reserved bit in the PTE of the faulting page; (3) It loads the PTE (after re-randomization) of the faulting page into the TLB; (4) It then sets the reserved bit of the PTE again. Nevertheless, two issues may arise: First, the PTEs of a safe area could be updated by OS (e.g., during a page migration or a reclamation), and thus clearing the reserved bits. We abstract the attackers' behavior as a sequence of memory probes, each of which triggers one re-randomization of the safe area and creates a new trap area.P c ith =            (i · P t ) · i−1 ∏ j=1 (1 − P h − j · P t ) i f i ≤ M (M · P t ) · ( M ∏ j=1 (1 − P h − j · P t )) · (1 − P h − M · P t ) i−1−M i f i > M (1)The probability of detecting probes. Then the cumulative probability P c n = ∑ n i=1 P c ith , where P c ith represents the probability that an attacker escapes all i − 1 probes, but is captured in the ith probe when it hits a trap area. P c ith is calculated in Equation (1), where i denotes the number of probes, j denotes the number of existing trap areas, P h denotes the probability that the attacker hits the safe area in a probe, P t represents the probability that the attacker hits one of the trap areas in a probe, M denotes the maximum number of trap areas. In the equation, (i · P t ) or (M · P t ) represents the probability that the probes are detected in the ith probe and (1 − P h − j · P t ) or (1 − P h − M · P t ) represents the probability of escaping the ith probe. P s n = ∑ n i=1 P s ith , where P s ith represents the probability that the attacker escapes in the first i − 1 probes, but succeed in the ith probe. Users could deploy SafeHidden by simply loading the kernel module, and specifying, by passing parameters to the module, which application needs to be protected and which registers point to the safe area. When these two types of events are intercepted, they will request the Checker module to determine if SafeHidden needs to raise a security alarm, or if it needs to notify the Randomizer module to perform randomization. Because the guest is a mirror of the current running system, the default EPT stores a one-to-one mapping that maps each guest physical address to the same host physical address.Task-2: installing hooks in guest kernel. When the guest starts to run, GuestKM will be triggered to install hooks to intercept three kinds of events: 1) To intercept the system calls, GuestKM modifies the system call table's entries and installs an alternative handler for each of them; 2) To intercept the page fault exception, GuestKM uses the ftrace framework in Linux kernel to hook the do page fault function; 3) To intercept context switches, GuestKM uses the standard preemption notifier in Linux, preempt notifier register, to install hooks. As described in Section 4.1 and 4.3, when GuestKM needs to perform randomization, it invokes the customized implementation of do mremap() function in the kernel with a randomly generated address (by masking the output of the rdrand instruction with The 0x7ffffffff000) to change the locations of the safe areas. This is because SafeHidden only runs in the kernel mode-it uses the kernel-mode page table with kPCID, but the TLB entries of the safe areas must be loaded from the user-mode page table using uPCID.An intuitive solution is to map SafeHidden into the kernel space portion of the user-mode page tables. However, this method introduces more pages into the user-mode page tables and thus increases the attack surface of the Meltdown attack.We propose the following alternative solution: SafeHidden still runs in the kernel mode using the kernel-mode page table. Then without switching to the user-mode page table, it accesses the safe area pages to load the target PTEs into the TLB with uPCID.There is no need to switch to the user-mode page table for two reasons: (1) TLB entries are only tagged with PCIDs and virtual addresses; (2) the user-space addresses are also mapped in the kernel-mode page table. The only difference is that SafeHidden encloses the code of line 13 (Listing 1) into a transaction (between xbegin and xend instructions). The MMU notifier provides a collection of callback functions to notify two kinds of page table updates: invalidation of a physical page and migration of a physical page. When initializing an EPT, SafeHidden will configure the entries based on other threads' local safe areas by walking the GPT to find all physical pages in the safe areas. The result shows that all the 10,000 trials failed, but in two different scenarios: In the first scenario (9,217 out of 10,000 trials), the attacks failed to gauge the size of the unmapped areas even when the powerful binary search method is used. In the second scenario, even though the attacks can gauge the exact size of an unmapped area, they always stumble into one of the trap areas when accessing the surroundings of the unmapped area, which triggers security alarms.In the second experiment, we launched 10,000 trials of CROP attacks [19] to probe a Firefox protected by OCFI. This experiment shows that SafeHidden can prevent the continuous probing attacks effectively.In the third experiment, we launched 10,000 trials of the CROP attack using thread spraying to probe Firefox protected by SS. There are two reasons for that: 1) The other threads' local safe areas become the current thread's shielded areas, which increases the probability of the probes being captured; 2) All safe areas will be randomized after each probe, which increases the number of trap areas quickly.In the fourth experiment, we emulated a cache sidechannel attack against page tables using Revanc [54], which is a tool based on [46]. For the experiment of CPU computation, we ran SPEC CPU2006 benchmarks with ref input and multi-threaded Parsec-2.1 benchmarks using native input with 8 threads; For the experiment of network I/O, We chose the Apache web server httpd-2.4.38 and Nginx-1.14.2 web server. This is due to two reasons: (1) All threads need to be blocked when randomizing the thread-shared safe areas or the thread-local safe areas (when not triggered by a TLB miss); (2) When protecting the thread-local safe areas, SafeHidden needs to synchronize the thread-private EPTs with the guest page table, which could introduce VM-Exit events. But for each request to Apache, Apache will invoke the mmap() system call to map the requested file into the virtual memory space which could trigger the extra randomization of all safe areas compared with Nginx; (2) Apache is a multi-threaded program. When TLBleed is used against SafeHidden, by triggering only L1 DTLB misses without L2 TLB misses, TLBleed may reduce the entropy of the safe area location by 4 bits (in the case of a 16-set L1 DTLB), which leads to roughly 20 bits entropy remaining for 8 MB safe area. Variants of existing attacks would also be prevented: (1) The attacker may try to fill up the address space quickly by using the persistent allocation oracle [43] to avoid SafeHidden from creating too many trap areas. By modifying the Intel's simulation, IMIX extends the x86 ISA with a new memory-access permission to mark safe areas as security sensitive and allows accesses to safe areas only using a newly introduced instruction. Please note that most defenses listed in Table 1 (except two) work on COTS binaries. It continuously re-randomizes the locations of safe areas and thus prevents the attackers from probing and inferring the memory layout to find its location. As shown in Table 2, SafeHidden intercepts different types of memory accesses to these areas and applies different security policy accordingly:• If the event is an access to an unmapped area, SafeHidden will randomize the location of all safe areas. Compared to existing methods, this method does not need any modification of kernel source code, thus facilitating adoption.To summarize, this paper makes the following contributions to software security:• It proposes the re-randomization based IH technique to protect the safe areas against all known attacks. Therefore, accesses to unmapped areas only trigger re-randomization of the safe area to restore the randomness (that could invalidate the knowledge of previous probes), but no alarm will be raised. SafeHidden mitigates such attacks by intercepting TLB misses when accessing safe areas.To only intercept the TLB miss occurred in safe areas, SafeHidden leverages a reserved bit in a PTE on X86 64 processors. Obviously, in the real world situation, the attacker's success probability will be even lower, and the attack will be caught much sooner.P s ith =            P h · i−1 ∏ j=1 (1 − P h − j · P t ) i f i ≤ M P h · ( M ∏ j=1 (1 − P h − j · P t )) · (1 − P h − M · P t ) i−1−M i f i > M(2) SafeHidden is designed as a loadable kernel module. If there is an overlap between their access areas with any of the trap areas, the safe areas, or the shielded areas, GuestKM will trigger a security alarm. We implemented SafeHidden on Ubuntu 18.04 (Kernel 4.20.3 with KPTI enabled by default) that runs on a 3.4GHZ Intel(R) Core(TM) i7-6700 CPU with 4 cores and 16GB RAM. • If the event is an access to safe areas through memory management system calls or system calls with EFAULT return value, SafeHidden will trigger a security alarm. The kernel assigns different PCIDs to the user and kernel modes (i.e., kPCID and 