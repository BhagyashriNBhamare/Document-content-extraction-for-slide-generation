Intel has introduced a hardware-based trusted execution environment, Intel Software Guard Extensions (SGX), that provides a secure, isolated execution environment, or enclave, for a user program without trusting any underlying software (e.g., an operating system) or firmware. The root cause of this attack is that SGX does not clear branch history when switching from enclave to non-enclave mode, leaving fine-grained traces for the outside world to observe, which gives rise to a branch-prediction side channel. When we want to run security-sensitive applications (e.g., processing financial or health data) in the public cloud, we need either to fully trust the operator, which is problematic [16], or encrypt all data before uploading them to the cloud and perform computations directly on the encrypted data. Since the OS, in principle, is a part of the trusted computing base of a computing platform, by compromising it, an attacker can fully control any application running on the platform.Industry has been actively proposing hardware-based techniques, such as the Trusted Platform Module (TPM) [56], ARM TrustZone [4], and Intel Software Guard Extension (SGX) [24], that support TEEs. However, these methods prevent only the page-level attack; hence, a fine-grained side-channel attack, if it exists, would easily bypass them.We have thoroughly examined Intel SGX to determine whether it has a critical side channel that reveals finegrained information (i.e., finer than page-level granularity) and is robust against noise. To avoid such problems, Intel SGX hides all performance-related events (e.g., branch history and cache hit/miss) inside an enclave from hardware performance counters, including precise event-based sampling (PEBS), last branch record (LBR), and Intel Processor Trace (PT), which is known as anti side-channel interference (ASCI) [24]. More important, we find that the LBR in a Skylake CPU allows us to obtain the most accurate information for branch shadowing because it reports whether each conditional or indirect branch instruction is correctly predicted or mispredicted. We design proof-of-concept hardware-and software-based countermeasures against the attack and evaluate them. SGX provides a set of instructions to allow an application to instantiate an enclave that secures the code and data inside it against privileged software such as an OS or a hypervisor, hardware firmware, and even hardware units except for the CPU. In addition, SGX leverages an on-chip memory-encryption engine that encrypts enclave content before writing it into physical memory and decrypts the encrypted content only as it enters the CPU package during enclave execution or enclave mode. The causes of an AEX include exceptions and interrupts. During a context switch, SGX conducts a series of checks and actions to ensure security, e.g., flushing the translation lookaside buffer (TLB). Branch instructions can severely reduce instruction throughput since the processor cannot execute past the branch until the branch's target and outcome are determined. While the BPU increases throughput in general, it is worth noting that in the case of a misprediction, there is a pretty high penalty because the processor needs to clear the pipeline and roll back any speculative execution results. In Skylake CPUs, the LBR stores the information of up to 32 recent branches, including the address of a branch instruction (from), the target address (to), whether the branch direction or branch target was mispredicted (it does not independently report these two mispredictions), and the elapsed core cycles between LBR entry updates (also known as the timed LBR). Also, the LBR can selectively record branches taken in user space, kernel space, or both.Since the LBR reveals detailed information of recently taken branches, an attacker may be able to know the finegrained control flows of an enclave process if the attacker can directly use the LBR against it, though he or she still needs mechanisms to handle not-taken branches and the limited capacity of the LBR. We explain our threat model, which is based on the original threat model of Intel SGX and the controlledchannel attack [60]: an attacker has compromised the operating system and exploits it to attack a target enclave program.First, the attacker knows the possible control flows of a target enclave program (i.e., a sequence of branch instructions and their targets) by statically or dynamically analyzing its source code or binary. Self-paging [22] and live re-randomization of address-space layout [15] inside an enclave are outside the scope of our attack.Second, the attacker infers which portion of code the target enclave runs via observable events, e.g., calling functions outside an enclave and page faults. The branch shadowing attack aims to obtain the finegrained control flow of an enclave program by 1) knowing whether a branch instruction has been taken and 2) inferring the target address of the taken branch. [1,[5][6][7][8][9][10], marked with ⋆ in (b)) of the shadowing instance depends on the branching result (i.e., taken or not at [1] in (a)) of the victim instance.nipulate the local APIC timer and the CPU cache ( §3.6) to frequently interrupt an enclave process execution for synchronization, adjust virtual address space ( §3.7), and run shadow code to find a function the enclave process is currently running or has just finished running ( §3.8). To make a BTB entry collision [13], we align the lower 31 bits of the shadow code's address (both the branch instruction and its target address) with the address of the victim code.When the victim code has been executed before the shadow code is executed, the branch prediction or misprediction of the shadow code depends on the execution of the victim code. Instead of using RDTSC, we can use Intel PT to measure a misprediction penalty of a target branch, as it provides precise elapsed cycles (known as a CYC packet) between each PT packet. Since our shadow code has no function calls and is executed in the kernel, we use the LBR's filtering mechanism to ignore every function call and all branches in user space. Second, an attacker can infer the result of the condition evaluation of an if-else statement because an if block's last instruction is an unconditional branch to skip the corresponding else block.Unlike a conditional branch, an unconditional branch is always taken; i.e., a branch prediction is not needed. Unlike the conditional branch shadowing, we make the target of the shadowed unconditional branch differ from that of the victim uncon- n/a ditional branch to recognize a branch target misprediction. Table 2: Branch types and states the branch shadowing attack can infer by using the information of BTB, BPU, and LBR.Taken ✓ ✓ - ✓ Not-taken - ✓ - ✓ Uncond. If the branch shadowing attack could not check a BTB entry before it has been changed, it would lose the information.To solve this problem, we interrupt the enclave process as frequently as possible and check the branch history by manipulating the local APIC timer and the CPU cache. To interrupt an enclave process more frequently, we selectively disable the L1 and L2 cache of a CPU core running the victim enclave process by setting the cache disable (CD) bit of the CR0 control register. If these functions contain entry points that can be invoked from outside (via EENTER) or that rely on external calls, the attacker can easily identify them because they are controllable and observable by the OS.However, the attacker needs another strategy to infer the execution of non-exported functions. In this section, we demonstrate the branch shadowing attack against an implementation of RSA and also describe our case studies of various libraries and applications that are vulnerable to our attack but mostly secure against the controlled-channel attack [60]. Also, to differentiate each loop execution, we shadow unconditional branches that jump back to the loop's beginning.We evaluated the accuracy of branch shadowing by attacking RSA-1024 decryption with the default key pair provided by mbed TLS for testing. The sliding-window size was five.On average, the branch shadowing attack recovered approximately 66% of the bits of each of the two CRT exponents from a single run of the victim (averaged over 1,000 executions). We attacked three more applications: 1) two libc functions (strtol and vfprintf) in the Linux SGX SDK, 2) LibSVM, ported to Intel SGX, and 3) some Apache modules ported to Intel SGX. Since the BTB and BPU benefit from local and global branch execution history, there would be a performance penalty if these states were flushed too frequently.We estimate the performance overhead of our countermeasure at different enclave context switching frequencies using a cycle-level out-of-order microarchitecture simulator, MacSim [30]. The BTB and BPU statistics are also barely distinguishable beyond a flush frequency of 100k cycles.According to our measurements with a 4GHz CPU, about 250 and 1,000 timer interrupts are generated per second in Linux (version 4.4) and Windows 10, respectivelyi.e., a timer interrupt is generated for every 4M and 1M cycles, respectively. Therefore, if there is no I/O device generating many interrupts and an enclave program generates less frequent system calls, which would be desired to avoid the Iago attack [9], flushing branch states for every enclave context switch will introduce negligible overhead. It obfuscates a set of branch instructions into a single indirect branch, as inferring the state of an indirect branch is more difficult than inferring those of conditional and unconditional branches ( §3.5). Since all of the unconditional branches are executed almost simultaneously in sequence, recognizing the current instruction pointer is difficult. Zigzagger's approach has several benefits: 1) security: it provides the first line of protection on each branch block in an enclave program; 2) performance: its overhead is at most 2.19× (Table 5); 3) practicality: its transformation demands neither complex analysis of code semantics nor heavy code changes. The number of branches a single trampoline manages affects the overall performance, so our implementation provides a knob to configure it to trade the security for performance.Our proof-of-concept implementation of Zigzagger, merging every branch in each function, imposed a 1.34× performance overhead when evaluating it with the nbench benchmark suite (Table 5). Since two hyperthreads simultaneously running in the same physical core share the BTB and BPU, a malicious hyperthread can attack a victim enclave hyperthread by using BTB entry conflicts if a malicious OS gives the address information of the victim to it. Also, researchers implemented SGX layers [5,6,51,57] to run existing applications inside an enclave without any modifications. For example, Sinha et al. [52,53] To address the page-fault-based side-channel attack, Shinde et al. [50] obfuscate the memory access pattern of an enclave. Finally, Seo et al. [47] enforce finegrained ASLR on enclave programs, which can raise the bar of exploiting any vulnerabilities and inferring control flow with page-fault sequences. For example, to break kernel ASLR, researchers exploit a TLB timing channel [23], an Intel TSX instruction [28], a PREFETCH instruction [18], and a BTB timing channel [13]. An OS can program it through memory-mapped registers (e.g., device configuration register) or model-specific registers (MSRs) to adjust the frequency of the local APIC timer, which generates high-resolution timer interrupts, and deliver an interrupt to a CPU core (e.g., inter-processor interrupt (IPI) and I/O interrupt from the I/O APIC). The current-count register's value decreases at the rate of the bus frequency, and when it becomes zero, a timer interrupt is generated and the register is re-initialized by using the initial-count register. Figure 11 shows how we modified the lapic_next_deadline() function specifying the next TSC deadline and the local_apic_timer_interrupt() function called whenever a timer interrupt is fired.We made and exported two global variables and function pointers to manipulate the behaviors of lapic_next_deadline() and local_apic_timer_interrupt() with a kernel module: lapic_next_deadline_delta to change the delta; lapic_target_cpu to specify a virtual CPU running a victim enclave process (via a CPU affinity); and timer_interrupt_hook to specify a function to be called whenever a timer interrupt is generated.