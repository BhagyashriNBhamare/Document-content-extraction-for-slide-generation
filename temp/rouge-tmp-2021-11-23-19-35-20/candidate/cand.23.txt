As a software library, Open-SSL provides not only TLS functionality but also cryptographic functionality for applications such as SSH, IPSec, and VPNs.Due to its ubiquitous usage, OpenSSL contains arguably one of the most popular software implementations of the Elliptic Curve Digital Signature Algorithm (ECDSA). Our spy program probes relevant memory addresses to create a timing signal trace, then the signal is processed and converted into a sequence of right-shift and subtraction (LS) operations corresponding to the BEEA execution state from which we extract bits of information to create a lattice problem. This new approach allows us to accurately find the best candidate memory addresses to slow the modular inversion by an average factor of 18, giving a high resolution trace and allowing us to extract the needed bits of information from all of the traces.Unlike previous works targeting the wNAF scalar multiplication code path (for curves such as BitCoin's secp256k1) or performing theoretical side-channel analysis of the BEEA, we are the first to demonstrate a practical cache-timing attack against the BEEA modular inversion, and furthermore OpenSSL's ECDSA signing implementation with constant-time P-256 scalar multiplication.Our contributions in this work include the following:• We identify a bug in OpenSSL that allows a cache-timing attack on ECDSA signatures, despite constant-time P-256 scalar multiplication. Elliptic Curve Cryptography (ECC) became popular mainly for two important reasons: no sub-exponential time algorithm to solve the elliptic curve discrete logarithm problem is known for well-chosen parameters and it operates in the group of points on an elliptic curve, compared to the classic multiplicative group of a finite field, thus allowing the use of smaller parameters to achieve the same security levels-consequently smaller keys and signatures.Although there are more general forms of elliptic curves, for the purposes of this paper we restrict to short Weierstrass curves over prime fields. With prime p > 3, all of the x, y ∈ GF(p) solutions to the equation E : y 2 = x 3 + ax + b along with an identity element form an abelian group. Alice sends (m, r, s) to Bob.Verifying: Bob wants to be sure the message he received comes from Alice-a valid ECDSA signature gives strong evidence of authenticity. At a high level, an established methodology for EC-DSA is to query multiple signatures, then partially recover nonces k i from the side-channel, leading to a bound on the value αt i − u i that is shorter than the interval {1 . The HNP instances are then reduced to Closest Vector Problem (CVP) instances, solved with lattice methods.Over the past decade, several authors have described practical side-channel attacks on ECDSA that exploit partial nonce disclosure by different microprocessor features to recover long-term private keys.Brumley and Hakala [6] describe the first practical side-channel attack against OpenSSL's ECDSA implementation. After collecting 2,600 signatures (8K with noise) from the dgst command line tool and using the Howgrave-Graham and Smart [15] lattice attack, the authors recover a 160-bit ECDSA private key from standardized curve secp160r1.Brumley and Tuveri [7] attack ECDSA with binary curves in OpenSSL 0.9.8o. Mounting a remote timing attack, the authors show the library's Montgomery Ladder scalar multiplication implementation leaks timing information on the MSBs of the nonce used and after collecting that information over 8,000 TLS handshakes a 162-bit NIST B-163 private key can be recovered with lattice methods.Benger et al. [4] target OpenSSL's wNAF implementation and 256-bit private keys for the standardized GLV curve [11] secp256k1 used in the BitCoin protocol. The latency measured in the last step tells whether or not the memory line was accessed by the victim during the second step of the attack, i.e. identifies cache-hits and cache-misses. Aravamuthan and Thumparthy [3] attacked BEEA using Power Analysis attacks, whereas Aciiçmez et al. [1] attacked BEEA through Simple Branch Prediction Analysis (SBPA), demonstrating the fragility of this algorithm against sidechannel attacks.Both previous works reach the conclusion that in order to reveal the value of the nonce k, it is necessary to identify four critical input-dependent branches leaking information, namely: Moreover, both works present a BEEA reconstruction algorithm that allows them to fully recover the nonce k-and therefore the secret signing key-given a perfect side-channel trace that distinguish the four critical branches.Aravamuthan and Thumparthy [3] argue that a countermeasure to secure BEEA against side-channel attacks is to render u and v subtraction branches indistinguishable, thus the attack is computationally expensive to carry out. Under a perfect SPA trace, the authors use an algebraic algorithm to determine a short execution sequence of u and v subtraction branches.They manage to recover various bits of information for several ECDSA key sizes. Finally, using a lattice attack they recover the secret signing key.As can be seen from the previous works, depending on the identifiable branches in the trace and quality of the trace it is possible to recover full or partial information about the nonce k. Unfortunately, the information leaked by most of the real world side-channels does not allow us to differentiate between subtraction branches u and v, therefore limiting the leaked information to three inputdependent branches: OpenSSL has a rich and storied history as a prime security attack target [19], a distinction ascribed to the li-brary's ubiquitous real world application. The implementation computes modular inversions in a way that resembles the classical extended Euclidean algorithm, calculating quotients and remainders in each step by calling BN div updated to respect the BN FLG CON-STTIME flag. Although BN mod exp mont consttime was introduced in the 0.9.7 branch, here we are referring to its use for modular inversion via FLT.OpenSSL version 0.9.6 0.9.7 0.9.8 1.0.01.0.1 1.0.2 BN mod inverse BN FLG CONSTTIME - BN mod inverse no branch - - ec nistp 64 gcc 128 - - - - BN mod exp mont consttime - - - - - EC GFp nistz256 method - - - - -mentation uses fixed-window combing combined with secure table lookups via software multiplexing (masking), and is enabled with the ec nistp 64 gcc 128 option at build time. While speed motivated the contribution, Möller observes 4 : "It seems that the BN MONT CTX-related code (used in crypto/ecdsa for constant-time signing) is entirely independent of the remainder of the patch, and should be considered separately." While ec nistp 64 gcc 128 provides constanttime scalar multiplication to compute the r component of P-256 ECDSA signatures, the s component will compute modular inverses of security-critical nonces with the stock BN mod inverse function, not taking the BNmod inverse no branch code path. Said tree features constanttime P-256 scalar multiplication with callee EC GFpnistp256 method, but inverts ECDSA signing nonces with callee BN mod inverse that fails the same security critical branch, again due to the BN FLG CONSTTIME flag not being set by the caller-i.e. it follows essentially the same code path as OpenSSL. Each CPU core has an 8-way 32KB L1 data cache, an 8-way 32KB L1 instruction cache, an 8-way 256KB L2 unified cache, and all the cores share a 12-way 6MB unified LLC (all with 64B cache lines). To that end, we identify the routines used in the BN mod inverse method leaking side-channel information.TheBN mod inverse method operates with very large integers, therefore it uses several specific routines to perform basic operations with BIGNUMs. Unfortunately there is not always a reliable indicator in the signal for transitions from one right-shift operation to the next, therefore we estimate the number of adjacent right-shift operations by taking into account the latency and the horizontal distance between subtractions. Figure 5 contains sample raw traces captured in our test environment.Our spy process accurately captures all the subtraction operations but duplicates some right-shift operations, therefore we focus on the first part of the sequence to recover a variable amount of bits of information from every trace. This approach requires understanding the code, a task that might not always be possible, takes time and it is prone to errors [26], therefore the authors propose another option.The second and novel approach they propose is to automate code analysis by collecting code coverage information using the gcov tool. The instrumentation skews the performance of the program, therefore this approach is suboptimal since it requires building the target code twice, one with instrumentation to identify code lines and other only with debugging symbols to measure the real performance.Once the "hot" memory addresses are identified, the next step is to evict them from the cache in a tight loop, thus increasing the execution time of the process accessing those addresses. Next, we degrade-by flushing in a loop from the cache-one memory line at a time from the caller BN mod inverse and callees BN rshift1, BNrshift, BN uadd, bn add words, BN usub.The perf command output gives us the real count of cache-misses during the regular execution of BNmod inverse, then under degradation of each candidate memory line. These results suggest that in order to get a quality trace, the goal is to achieve an increased rate of cache-misses rather than a CPU clock cycle slow down because whereas the cachemisses suggest a CPU clock cycle slow down, it is not the case for the opposite direction.The effectiveness of the attack varies for each use case and for each routine called. Overall "hottest" addresses in Table 2 shows the result of choosing the best strategy for our use case, where the addresses degraded in every routine varies from multiple addresses per routine to no addresses at all.For our use case, we observe the best results with 6 degrading addresses across two degrading processes executing in different CPU cores. Figure 6 allows us to draw several conclusions, including but not limited to: (1) Sequences of length 5 or more allow us to extract a minimum of 3 nonce bits per signature; (2) Similarly length 7 or more for a minimum of 4 nonce bits; (3) The average number of bits extracted grows rapidly at first, then the growth slows as the sequence length increases. Table 3 denotes µ l the mean value of l over all successful HNP instancesintuitively tracking how many known nonce bits needed in total to reasonably expect success.We ran 200 independent trials for each set of parameters on a computing cluster with Intel Xeon X5650 nodes. However, as seen in Table 4 and Table 5, while we observe quite high accuracy, in our environment we are unable to realize absolutely perfect traces. Our contributions traverse both practice and theory, recovering keys with as few as 50 signatures and corresponding traces.Stepping back from the concrete side-channel attack we realized here, our improved nonce bit recovery approach coupled with tuned lattice parameters demonstrates that even small leaks of BEEA execution can have disastrous consequences. For example, P-256 takes the constant-time scalar multiplication code path by default, oblivious to the flag, while in stark contrast modular inversion relies critically on this flag being set to follow the code path with microarchitecture attack mitigations.Following responsible disclosure procedures, we reported the issue to the developers of the affected products after our findings.