At each stage, modules are added to the firmware, but typically, for time and cost reasons, nothing is optimized or removed, including any generic modules that do not apply to the specific hardware being delivered.Furthermore, firmware fixes are often neglected even for motherboards only 6-12 months old. This results in a linear reduction of the overall vulnerability surface and availability of exploits.In this work we propose to automatically and dynamically prune significant amounts of unnecessary binary code from a large class of COTS firmware without impacting the functionality of the upper layer of the stack (OS, applications). Many common attack vectors on UEFI have modern mitigations that manufacturers fail to properly configure.In a survey of firmware vulnerabilities [29] covering 2015-2017, not only are the total numbers concerning, but there is also an increasing trend in the number of vulnerabilities due to lack of proper configurations of increasingly numerous security options.Firmware expert Nikolaj Schlej, perhaps best known as the author of the widely used and popular UEFITool [36], has been sounding the alarm for years through various of talks and presentations. This is one of the main motivators behind DECAF, namely empowering non-expert users to easily remove old, unwanted or buggy functionality from their firmware.Since much of the firmware is closed-source, it is difficult to precisely evaluate firmware code quality and whether it is that much better than the abysmal industry average featuring multiple bugs for every hundred lines of code [25]. It utilizes a configurable set of validation tests to tailor the retained functionality to a particular use-case and intelligently performs a dynamic iterative surgery process on UEFI binary firmware to remove a maximal amount of code with no effect on functionality and performance of higher layers in the stack (OS, applications). DECAF operates on binaries (no need for source code) and can easily integrate with and operate on new motherboards.5. The code residing in this stage is generally designed to be as simple as possible, while the more advanced logic is handled later in the DXE stage.The DXE stage loads what could be considered the user space UEFI environment. If the DEPEX expression evaluates to true (i.e., required modules and protocols have already been loaded), the module can be loaded, otherwise it is postponed.Unfortunately, the dependency section is not very helpful in determining which modules actually depend on one another. Protocols may be listed in the dependency section strictly to change the dispatching order, not because the binary actually looks up the protocol and uses it. The selection of a pruning strategy should have two primary concerns: its runtime and the quality of the results it produces.The property of a particular pruning strategy that most affects runtime is the number of test iterations that must be performed. The time required to perform a single test of a particular pruned state is on the order of minutes, so exhaustive searches simply aren't feasible.As for quality, the number of modules removed is the metric most directly affected by choice of strategy; any strategy will remove one module at a time, and the order in which modules are removed determines how many modules are kept, due to the nature of inter-module dependencies. In the context of DECAF, the passing program would be the original firmware image, the failing program would be an empty firmware image, and the deltas would be the UEFI modules.However, these approaches rely on spatial coherence in the input, which in this case is a set of files in the firmware volume whose order have no real correlation to their removability. Assuming that roughly 60% of the firmware modules are removable, it can be observed that as expected, hill-climbing is able to fully prune the firmware regardless of the module connectivity, and the performance of the linear removal and delta debugging approaches is inversely proportional to q.In order to achieve similar levels of module removal, linear removal methods could take on one of two approaches. They could repeat until the dependency tree is fully unwound, raising the complexity on an order of magnitude relative to the height of the DAG, or they could perform a linear removal to remove obvious candidates, followed by hill-climbing to clean up the rest of the removable tree. Since exhaustive searches are infeasible, DECAF makes use of search heuristics: each module is assigned a weight that is updated throughout the runtime of the pipeline.One can imagine a number of search heuristics that can be used to improve the runtime or results of a given pruning strategy. DECAF deploys a single linear pass followed by a few rounds of hill-climbing, as it produces the best performance for firmware that roughly conforms to the model in which modules are either: removable, not removable, or removable if all of their dependencies are removed.The workflow is aimed at finding a minimal image that passes validation targets. The set of modules is then split in half recursively until the set contains only one module, at which point module removal is attempted.Every iteration involves flashing the image to the motherboard, powering the motherboard, waiting for the OS to boot, and running the validation targets. The weighting helps to ensure that less tested modules are more likely to be checked first while still preserving the option to retry previously failed modules. DECAF is composed of multiple modules, each responsible for a subtask of the overall pruning process.DECAF needs to be capable of managing a physical board in order to control and monitor power, flash firmware images, and monitor overall hardware health. It works and is tested on a wide range of firmware across a variety of vendors.We implemented a scriptable Python layer that utilizes the C++ backend of UEFITool, allowing for headless traversal and pruning of firmware images. Given the structure of an EFI image, modules can not only be pruned, but also appended to the binary.DECAF appends two modules to the original image: (i) dependency probe, and (ii) dependency dump. Instead, the probe publishes its own custom communication protocol that exposes a pointer to the data.The dependency dump module is loaded as late as possible, after the network stack has been initialized. 21 modules have an in degree of 147. These statistics will of course vary for different firmware images.Some modules are named, while others are represented by their associated GUID. The first priority in validation is to make sure that a motherboard flashed with modified firmware actually manages to boot into an operating system (ArchLinux 2018-11-01 was used to produce the images described in this paper). It then provides the IP address of the booted host to the validation engine (represented by F in Figure 4), which uses SSH to remotely access the operating system where it can perform tests. Other System Management BIOS (SMBIOS)/Desktop Management Interface (DMI) information (OEM strings, system configuration options, etc.) are not strictly necessary to the functionality of the device, but of course can be easily included if a user desires.As will be discussed further in Section 5, the pruning pipeline was run with two profiles, "aggressive" and "data center." dmidecode is used to decode the DMI table, which is hardware configuration information reported by the firmware to inform the operating system of the hardware present in the system and facilitate management. Further, e.g., our HP server contains four critical errors: one stemming from Spectre-style vulnerabilities, and three from improperly configured protections that may allow an attacker to modify the bootflow, overwrite SMRAM via Direct Memory Access (DMA) attacks, or even overwrite the BIOS through the SPI chip.DECAF prunes modules but does not (yet) patch modules (i.e., to fix such vulnerabilities in remaining modules). This aspect will cause a rather high overlap rate in images, even from different vendors. We are interested in how high the match rate is, and if it supports the claim that firmware is being mass produced and bloated.In order to keep the comparison unbiased, the motherboards models were chosen at random. We can observe that in some cases up to 70% of a firmware image is found on a different model from a different vendor (see Table 6, Asus vs ASRock). Benefits of code reduction include: reduced TCB -at the industry-average of 1.5-5% bugs per line of code [27], this can add up to thousands of (undiscovered) bugs and hundreds of exploits -reduced boot time, the ability to fit the firmware onto a smaller SPI chip etc, removal of physical attack vectors such as over peripherals (e.g., USB), and a reduction in the number of Return Oriented Programming (ROP) gadgets etc. The number of bytes generated from one line of pre-processed C code by an optimized compiler has been estimated [16] at around 14. Rarely used features are more likely to contain errors, since the resulting bugs are less likely to be discovered and therefore less likely to receive development attention beyond in-house testing [22]. This is not the case with a vast majority of DECAF-pruned modules and can be validated by the significant reduction in boot time which shows modules are part of the control flow.Further, there are numerous vectors by which an attacker indirectly gains access to code that is not entirely run in a standard boot sequence. Searches for specific models or product lines we pruned reveal a few more, but virtually all relate to the BMC and not the firmware itself.Nevertheless, in addition to reducing the overall vulnerability surface, DECAF also helps mitigate a number of common attack vectors including: Return Oriented Programming (ROP), USB attacks, SMM attacks, and network attacks. Attacks start with a buffer overflow hijacking the control flow, e.g., by sending malformed network packets processed by a faulty UEFI driver.Using the buffer overflow, a function pointer or some part of the executable memory is overwritten with a malicious sequence. By manipulating the stack, the attacker can then jump into a gadget, and each gadget indirectly branches to another, allowing execution of arbitrary code, subverting the original control flow of the application.Crucially, gadget-style attacks are (sometimes exponentially) easier with increasing code base. This presents two new attack vectors: 1) if an attacker can overwrite SMRAM, she can execute arbitrary code in a highly privileged state, and 2) if she can gain access to the SMM communication buffer, and there exists an exploit in an SMI handler, she can escalate an OS attack into a BIOS attack.Kallenberg et al. [20] construct an attack of the latter type. Simple attacks include, for example, exploiting the lack of signatures and authentication in certain DHCP servers: preempting a legitimate DHCP server, and inducing the BIOS to boot a malicious image and take over the existing operating system. [10] shows that in the case of the source code trimming tools CHISEL and TRIMMER tools, debloating can in fact introduce new gadgets, including some that are even more exploitable than what existed previously.Note, however, that this is only true of intra-source code trimming techniques, which may result in wildly different instructions in the final binary. For example, if the firmware is intended to be used in a NAS box, validation targets will test RAID functionality, read/write speeds, and (simulate) hardware (e.g., disk I/O) failures. We'll use existing work [7] as well as newly designed mechanisms for symbolic execution to further optimize pruning.In addition to analyzing and pruning at sub-module level, DECAF would be greatly enhanced by the ability to patch modules to enable certain platform protections where they are missing, such as the ones described in Section 4.5. The reduction of a program can be done either statically, e.g., by determining the Control Flow Graph and removing unused nodes, or dynamically, e.g., by decomposing the program execution, typically while debugging, and identifying only statements/variables of interest.Debloating software is a mechanism that focuses on determining the unused code of a program and removes it. First, existing research focuses on trimming a self-contained program that can be run independently of other system components, while UEFI firmware initializes system hardware. The EDK II project contains about 1.4M lines of C/C++/Header code and 19K lines of assembly, a small but not insignificant amount.Rastogi et al. use dynamic analysis techniques to automatically debloat and harden docker containers, removing unused resources and partitioning the executeables within the container based on the resources they access [33]. Their testing environment makes use of a generic and open source UEFI implementation, and replicating it on a closed source UEFI might not be possible, given the difficulty in emulating non-generic hardware.The article from [22] presents an extremely similar approach, but focused on debloating the Linux Kernel instead. According to this work the Linux Kernel has roughly 11,000 configuration options, which will be automatically tailored to minimize the code base while maintaining the functionality determined in the usage scenarios, removing up to 70% of it.RedDroid [18] is a project that targets software bloat in the Android world. It is important to note that RedDroid does not necessarily focus on security, but rather on saving hardware resources.The work at [13] presents a large scale experiment on embedded firmware images (note: in this context firmware does not necessarily mean UEFI environments but, rather any form of software that may be found on various embedded/IoT de- vices). Multiple vulnerabilities have been identified in the Intel ME in the past, including CVE-2017-5689 [26], which can give an attacker full access to the host system, including installing persistent malware and modifying firmware. The open source project me_cleaner [12] contains scripts for patching the ME firmware to disable it on a wide variety of motherboards.