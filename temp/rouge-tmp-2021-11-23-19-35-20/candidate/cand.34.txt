In addition to facilitate complex and vast instruction sets, it also provides an update mechanism that allows CPUs to be patched in-place without requiring any special hardware. To this end, our microprograms range from CPU-assisted instrumentation to microcoded Tro-jans that can even be reached from within a web browser and enable remote code execution and cryptographic implementation attacks. Since the 1970s, x86 processor manufacturers have used microcode to decode complex instructions into series of simplified microinstructions for reasons of efficiency and diagnostics [43]. From a high-level perspective, microcode is an interpreter between the user-visible Complex Instruction Set Computer (CISC) Instruction Set Architecture (ISA) and internal hardware based on Reduced Instruction Set Computer (RISC) paradigms [54]. How do real-world systems profit from microcode and how can malicious microcode be leveraged for attacks?In order to answer question (1), we emphasize that information regarding microcode is scattered among many sources (often only in patents). We demonstrate how a microprogram can be utilized to instrument a binary executable on the CPU layer and we also introduce different kinds of backdoors that are enabled via microcode updates.Our analysis focuses on the AMD K8/K10 microarchitecture since these CPUs do not use cryptographic signatures to verify the integrity and authenticity of microcode updates. Even though these works reported the workings of the microcode update mechanism, the purpose of fields within the microcode update header, and the presence of other metadata, none of the works was able to reverse engineer the essential microcode encoding. The microcode sequencer operates the whole decoding process, successively selecting microinstructions until the decode complete indicator comes up. The design process is simplified because changes in decode logic only require adaption of the microcode ROM content. The horizontal encoding designates one bit position in the microinstruction for each control signal of all functional units. The nature of horizontal microcode allows the programmer to explicitly address several functional units at the same time to launch parallel computations, thus using the units efficiently. The operand fields may vary in number and size depending on the opcode and specific flag fields. This advantage can be extended even further: With the introduction of microcode updates, one can alter processor behavior even after production. Furthermore, we present our analysis setup and framework that includes prototype implementations of our concepts and supported our reverse engineering effort in a semi-automated way.Our analysis primarily covers AMD K8 and K10 processors because-to the best of our knowledge-they are the only commercially available, modern x86 microarchitectures lacking strong cryptographic protection of microcode patches. The microcode is responsible for the decoding of vector path macroinstructions and handling of exceptions, such as page faults and divide-by-zero errors. With the K10 microarchitecture, AMD started to publicly release microcode updates, which benefits the Linux open-source microcode update driver. Internally, the update mechanism verifies the checksum, copies the triads to microcode patch RAM, and stores the match register fields in the actual match registers. Furthermore, we present (4) microcode hooking which ultimately enables actual modification of CPU behavior.We would like to emphasize that our methods were developed when we did not have access to microcode ROM, see Section 6.Low-Noise Environment. As described in Section 4.2, match registers hold microcode ROM addresses. Hence, we devised microcode ROM heat maps, a method to discover the corresponding memory location for microcoded macroinstructions.The underlying idea is to generate distinct behavior between the original and the patched macroinstruction execution. Thereby, we generate a heat map for each macroinstruction in an automated way: we store whether the microcode ROM address causes a system crash or not. Hence, we developed a novel technique to reverse engineer proprietary microcode encoding in a semi-automatic way.Since we did not have a large microcode update base on which we could perform fine-grained tests, we merely had a black box model of the CPU. This is indispensable in case macroinstructions are extended with functionality, such as a conditional operand check, while preserving original functionality.We employed two basic concepts to resume macroinstruction computation after interception: (1) pass control back to ROM, and (2) implement the macroinstruction computation. To fulfil our unusual requirements regarding the execution environment (e.g., full control over interrupts and all code being executed), we implemented a simple operating system from scratch. It supports interrupt and exception handling, virtual memory, paging, serial connection, microcode updates, and execution of streamed machine code. A custom message protocol exposes the following operating system features via serial connection: (1) stream x86 machine code, (2) send and apply microcode update, and (3) report back the final or intermediate CPU state. The microcode API exposes all required underlying features such as serial connection handling, serial message protocol, AMD computer power state monitoring and control, x86 assembler, parsing and generation of microcode updates, obfuscation and deobfuscation of microcode updates, microcode assembler and disassembler as well as required data structures. It should be noted that our results originate from reverse engineering include and indirectly measured behavior, assumptions about the microarchitecture, and interpretation of the visible CPU state, which is small in comparison to the whole unobservable CPU state. A heat map of a specific macroinstruction contains a mapping of all microcode ROM addresses to a boolean value that indicates whether the specified triad is executed during the decode sequence of that macroinstruction. We name a heat map that only covers vector instructions from the operating system reference heat map. Unless stated otherwise, all information given afterwards was obtained through reverse engineering.We found four operation classes, namely RegOp, LdOp, StOp, and SpecOp, that are used for arithmetic and logic operations, memory reads, memory writes, and special operations such as write program counter, respectively. We found that LdOp and StOp have their own operation types. In addition to the general-purpose registers, microcode can access a number of internal registers. The flags field decides whether the resulting flags of the current RegOp microinstruction should be committed to the x86 flags register. The sequence word, see Table 3, contains an action field at bit locations 14 to 16 that may indicate a branch to the triad at the given address, a branch to the following triad, or stop decoding of the current macroinstruction. We designed automated test cases that, e.g., permute the bits of an unknown microinstruction field to provoke observable differences in the final CPU state. Currently, we can only intercept vector instructions by writing related triad addresses from the heat maps into the match registers. With this method we found one triad we can skip without visibly changing Index 63 62 54 53 52 51 46 45 40 39 37 36 30 29 24 23 22 16 15 0 RegOp - type sw 3o reg1 -flags - 000 -size reg2 rmod - imm16/reg3 LdOp - type sw 3o reg1 - 001 - reg2 rmod - imm16/reg3 StOp - type sw 3o reg1 - 010 -size reg2 rmod - imm16/reg3 SpecOp - type cc sw 3o reg1 - 000 -size reg2 -imm16/addr12 the result. In contrast to traditional microcontrollers, general-purpose x86 CPUs feature a much larger die size and are stacked up to 12 layers, which increases hardware reverse engineering effort.We expected the targeted non-volatile microcode ROM to be stored in a cell array architecture. Note that hardware reverse engineering of the whole CPU microarchitecture would require a more controlled delayering process and several months to acquire and process the whole layout. Note another property of this ROM type is that only a single via may be set at any time; setting both will result in a short circuit.Overall, we identified three ROM blocks consisting of 8 subarrays. In order to group the bit values into microinstructions, we carefully analyzed the ROM structure and we made two crucial observations: (1) Each alternating column of bits is inverted due to mirroring of existing cells, which saves space on the die. Note that we also had to interleave the subarrays respectively to acquire 64 bits (size of a microinstruction) per memory row. See Listing 1 for a highlevel representation of the instrumentation logic; we refer the interested reader to Listing 7 in Appendix A.3 for a detailed RTL implementation.if ( esi == magic ) { temp = dword [ edi ] temp += 1 dword [ edi ] = temp }Listing 1: High-level description of the instrumentation logic implemented in microcode that counts the div instructions during execution. if ( eax == A && ebx == B ) eip = eip + 1Listing 2: High-level description of the microcode Trojan implemented in microcode that increments the eip to execute x86 instructions in a disaligned fashion.If a div ebx instruction is executed while eax contains the value A (dividend) and ebx contains the value B (divisor), then the instruction pointer eip is increased, and execution continues in a misaligned way after the first byte of the instruction following the div ebx instruction. Hence, legitimate machine instructions as shown in Listing 3 may be misused to hide and execute arbitrary code.B8 0 A000000 mov eax , 0 xA BB 0 B000000 mov ebx , 0 xB F7F3 div ebx 05 909090 CC add eax , 0 xCC909090Listing 3: x86 machine code to trigger the div Trojan in Listing 2. In order to realize microcode Trojans which facilitate such attacks, we have to arm a microcoded x86 instruction (used in scalar multiplication) with (1) an input-dependent trigger and (2) a payload inducing a conditional fault or additional time, see Listing 5. if ( regmd == A ) regmd = regmd + C Listing 5: High-level microcode Trojan description within an x86 instruction to trigger a conditional bug using the first operand (regmd) of the x86 instruction and the immediate constants A and C. For both attacks, we use the constant-time ECC reference implementation from libsodium [35] compiled for 32-bit architectures. Note that in case of a timing-attack, we conditionally execute several nop instructions to induce a data-dependent timing difference.For a detailed RTL implementation of the bug attack, we refer the interested reader to Listing 8 in Appendix A.3. From a hardware Trojan's perspective [58], microcode Trojans provide post-manufacturing versatility, which is indispensable for the heterogeneity in operating systems and applications running on general-purpose CPUs.Even though AMD emphasizes that their chips are secure [25], the microcode update scheme of K8 and K10 shows once more that security by obscurity is not reliable and proper encryption, authentication, and integrity have to deployed. Microcode updates could also enable domain-specific instruction sets, e.g., special instructions that boost program performance or trustworthy security measures (similar to Intel SGX [17]). In this paper we successfully changed the behavior of common, general-purpose CPUs by modification of the microcode. We contacted AMD in a responsible disclosure process more than 90 days prior to publication and provided detailed information about our findings. ROM Addressvector instruction 0x900 -0x913 -0x900 -0x913 -0x914 -0x917 rep cmps mem8 0x918 -0x95f -0x960 mul mem16 0x961 idiv 0x962 mul reg16 0x963 - 0x964 imul mem16 0x965 bound 0x966 imul reg16 0x967 - 0x968 bts imm 0x969 -0x971 -0x972 -0x973 div 0x974 -0x975 -0x976 -0x977 idiv 0x978 -0x979 -0x97a idiv 0x97b -0x9a7 -0x9a8btr imm 0x9a9 -0x9ad -0x9ae mfence 0x9af -09ff - In Section 5.2 we presented the microcode instruction set structure, which is one major result of our reverse engineering effort. We listed the microcode registers with mnemonics and encoding in rdi 000111 t1l t1w t1d t1q 001000 t2l t2w t2d t2q 001001 t3l t3w t3d t3q 001010 t4l t4w t4d t4q 001011 t1h t5w t5d t5q 001100 t2h t6w t6d t6q 001101 t3h t7w t7d t7q 001110 t4h t8w t8d t8q 001111 regmb regmw regmd regmq 101000 regb regw regd regq 101100 pcb pcw pcd pcq 111000 zerob zerow zerod zeroq 111111 Table 6: General-purpose and microcode register encodings.As explained in Section 7.3, we exploit the x86 shrd instruction to implement both the bug attack and the timing attack. We listed the microcode registers with mnemonics and encoding in rdi 000111 t1l t1w t1d t1q 001000 t2l t2w t2d t2q 001001 t3l t3w t3d t3q 001010 t4l t4w t4d t4q 001011 t1h t5w t5d t5q 001100 t2h t6w t6d t6q 001101 t3h t7w t7d t7q 001110 t4h t8w t8d t8q 001111 regmb regmw regmd regmq 101000 regb regw regd regq 101100 pcb pcw pcd pcq 111000 zerob zerow zerod zeroq 111111 Table 6: General-purpose and microcode register encodings.As explained in Section 7.3, we exploit the x86 shrd instruction to implement both the bug attack and the timing attack.