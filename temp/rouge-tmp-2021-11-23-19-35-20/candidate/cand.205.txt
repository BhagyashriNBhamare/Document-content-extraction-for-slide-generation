Commodity software typically includes a large number of functionalities for a broad user population. Unfortunately, programs debloated by this approach only support given inputs, presenting a rather unusable notion of debloating: if the debloated software only needs to support an apriori, fixed set of inputs, the debloating process is as simple as synthesizing a map from the input to the observed output. In the RAZOR framework, we implemented three tracers (two based on dynamic binary instrumentation and one based on a hardware tracing feature), four path finding heuristics, and one binary generator.To understand the efficacy of RAZOR on post-deployment debloating, we evaluated it on three sets of benchmarks: all SPEC CPU2006 benchmarks, 10 coreutils programs used in previous work, and two real-world large programs, the web browser Firefox and the closed-sourced PDF parser FoxitReader. We also analyzed the related-code identified by our path finder and found that different heuristics effectively improve the program robustness.In summary, we make the following contributions:• New approach.We proposed a practical postdeployment debloating framework that works on program binaries. Given a program P that has a set of functionalities F = {F 0 , F 1 , F 2 , ...} and a user specification of necessary functionalities F u = {F i , F j , F k , ...}, our goal is to generate a new program P ′ that only retains functionalities in F u and gracefully refuses requests of other functionalities in F − F u . From the previous example, we can find the gap between the user specification and the code removed: users specify that the functionality of parsing PNG files is necessary (i.e., others are unnecessary), while we finally remove line 6, line 7, and function parseJPEG. How to find more related-code from limited test cases.To address challenge C3, we propose control-flow-based heuristics to infer more related-code that is necessary to support the required functionalities but was missed during our inspection. Tracer executes the bloated program with given test cases and records the control-flow information in three categories:(1) executed instructions, including their memory addresses and raw bytes; (2) the taken or non-taken of conditional branches, like je that jumps if equal; (3) concrete targets of indirect jumps and calls, like jmpq *%rax that jumps to the address indicated by register %rax. As the program only has static code, Tracer does not include the instruction raw bytes.We find that it is worthwhile to use multiple tools to collect the execution trace. When applying the zCall heuristic on the example in Figure 4, PathFinder further includes block L4, and path L3→L4→L5, as this new path merges with the original one at L5 and does not contain any call instruction. These modifications symbolize basic blocks, concretize indirect calls/jumps, and insert fault han- Figure 5: Synthesize debloated assembly file. We leave the original code section inside the debloated program to support the potential read from it (e.g., jump tables in code section for implementing switch [11]). For the sake of simplicity, we use the term indirect call to cover both indirect calls and indirect jumps.With the execution traces, Generator is able to handle indirect calls in two ways. Before each indirect call, we map the old code address to the new one and transfer the control-flow to the new address.Our Generator takes a method similar to the second one, but with different translations for targets within the same module (named local targets) and targets outside the module (named global targets). At runtime, if the target address is outside the current module, we use a global translation function to find the correct module and look up its translation table to get the correct new address to invoke. Running a debloated binary may reach removed code or disabled branches for various reasons, such as a user's temporal requirement for extra functionalities or malicious attempts to run unnecessary code. First, at the beginning of each basic block we record its start address; second, for each conditional jump instruction, we insert two pieces of code between the instruction and its two targets to log the taken information; third, before each indirect call and jump instruction, we record the concrete target for each invocation. We set up three sets of benchmarks to evaluate RAZOR: 29 SPEC CPU2006 benchmarks, including 12 C programs, seven C++ programs, and 10 Fortran programs; 10 coreutils programs used in the CHISEL paper 1 [15]; the web browser Firefox and the close-source PDF reader FoxitReader. We use the software-based tracing tools that rely on Dynamorio and Pin to collect the execution traces of SPEC and CHISEL benchmarks, to get accurate results; for the complicated programs Firefox and FoxitReader, we use the hardware-based tracing tool (relying on Intel PT) to guarantee the execution speed to avoid abnormal behaviors. This result is consistent with the code size reduction, where RAZOR reduces less code, as it can neither remove any executed-but-unnecessary blocks or instructions, nor utilize compiler to aggressively optimize the debloated code. We use two sets of experiments to evaluate the effectiveness of PathFinder on finding the related-code of required functionalities. We tested RAZOR on CHISEL benchmarks as follows: (1) design training inputs and testing inputs that cover the same set of functionalities; (2) trace programs with the training inputs and debloat them with none, zCode, zCall, zLib, and zFunc heuristics; (3) run debloated binaries on testing inputs and record the failed cases. grep fails on all 38 testing inputs, while chown and rm fail more than half of all tests.The zCode heuristic helps mitigate the crash problem, like making grep work on 19 test cases. In the end, debloating with the zFunc heuristic 1 int fillbuf(...) { ... reduces all crashes in all programs.Interestingly, although aggressive heuristics introduce more code to the debloated binary (shown in the top of Figure 8), they do not significantly decrease the code reduction. Note that the zCode heuristic slightly increases the code reduction over the no heuristic case, as it enables more branches of conditional jumps, which in turn reduces the instrumentation of failed branches.We investigated the failed cases mitigated by different heuristics and show some case studies as follows: (1) The zCode heuristic enables the non-taken branch for executed conditional jumps. Meanwhile, it removes the patches of CVE-2008-1372and CVE-2005-1260 in bzip2, and CVE-2012-5667 in grep, rendering the debloated binaries vulnerable to these already-fixed bugs.Compared to CHISEL, RAZOR removes the bloated code in a conservative way. Efficient Debloating.On average, RAZOR takes 1.78 seconds to debloat CHISEL benchmarks, 8.51 seconds for debloating Firefox, and 50.42 seconds to debloat FoxitReader As a comparison, CHISEL has to spend one to 11 hours to debloat the relatively small CHISEL benchmarks. For example, the bank can provide its clients a minimal browser that only supports functionalities required by its website while exposing the least attack surface.To measure the benefit of the per-site browser, we applied RA-ZOR on three sets of popular and security-sensitive websites: banking websites, websites for electronic commerce, and social media websites. We understand that such a heuristic cannot guarantee the completeness or soundness of the path inference, and the debloated binary may miss necessary code (i.e., code for handling different environment variables) or include unnecessary ones (like some initialization code). For example, if function A is designed to be a legitimate target of an indirect call i, CFI will allow the transfer from i to A. However, if the user does not need the functionality in A, software debloating will disable the transfer and completely remove the function code. One reason is that libc.so contains a lot of highly optimized code for memory or string operations (e.g., memcmp), which, based on the argument value, choose the most efficient implementation. Instead of customizing the library for each program, they split the large library into small groups based on the control-flow dependency. Rastogi et al. [41] developed Cimplifier, which uses dynamic analysis to collect resource usages for different programs and partitions the original container into a set of smaller ones based on user-defined policies. Based on the concrete execution context, the return value of malloc (at line 10) may or may not satisfy the alignment requirement. The trace also contains three conditional branch instructions: the one at 0x4004e3 only takes the true target; the one at 0x4004ee only takes the false target; the one at 0x400614 takes both targets. For each conditional branch in the input CFG (line 1), the algorithm invokes the function get_non_taken_branch to get the nontaken branch (line 2). In the extended CFG, it only takes the fall-through branch, which means that jumping to block 0x6 should not be allowed in the debloated binary. Without heuristics, Firefox fails on 13 out of 25 websites and FoxitReader fails on 39 out of 40 PDF files.The zCode heuristic helps reduce FoxitReader crashes to 10 PDF files and increases the code reduction by avoiding faulthandling instrumentation. Specifically, given one executed path p, we aim to find a different path q such that 1) q has no different instructions, or 2) q does not invoke new functions, or 3) q does not require extra library functions, or 4) q does not rely on library functions with different functionalities. Based on the userprovided options (line 4 and 6), the program invokes function parsePNG to parse PNG images (line 5) or invokes function parseJPEG to handle JPEG images (line 7). The first method is to locate constants from the original binary that are used as code addresses and replace them with the corresponding new addresses, as in [52,51]. Intel PT records the change of flow information in a highly compressed manner: the TNT packet describes whether one conditional branch is taken or non-taken; the TIP packet records the target of indirect branches, like indirect call and return. To further reduce the program size and memory usage, we can completely remove the original code section as follows: 1) during the execution tracing, we set the original code section to execute-only [11] so that any read from the code section will trigger the exception and can be logged by Tracer; 2) we perform backward data-flow analysis to identify the source of the data pointer used for each logged memory access; 3) during the binary synthesization, we relocate the data from the original code section to a new data section and update the new code to visit the new location. For conditional branch instructions that only have one target taken (the fall-through target or the jump target), PathFinder checks whether the non-taken target is already in the CFG (i.e., reached through other blocks). For example, one indirect call instruction in perlbench benchmark of SPEC CPU2006 has at least 132 targets, and each target is invoked millions of times. Our problem can be rephrased as follows: given the program binary P b and a set of test cases T = {t i ,t j ,t k , ...}, where each test case t i triggers some functionalities of P b , we will create a minimal program P ′ b that supports and only supports functionalities triggered by the test cases in T . tic adds lines 5 and 8 and related branches to the debloated program, which effectively avoids this crash.The zLib heuristic allows extra calls to native functions or library functions if they have been used in traces. First, previous work performs the binary rewriting at the beginning of each process, leading to performance overhead for each execution, while RAZOR generates the debloated binary through static binary rewriting, which is only performed once and used forever. From the simple code we can easily tell that code in the yellow background (i.e., line 6, 7 and 15) is not necessary, so we remove such code in a safe manner: function parseJPEG will be simply removed; for line 6 and 7, we should replace the code with fault-handling code to prompt warnings and exit gracefully.In this paper, we focus on reducing functionalities from software binaries. How to map functionalities to program code.One possible solution is to rely on end-users to provide a set of test cases for each necessary/unnecessary functionality so we can inspect the program execution to learn the related program code. Our Tracer records the raw bytes of executed instructions to handle dynamically gen- ...... [0x4005c0,0x4005f2] [0x400596,0x4005ae]... Indirect Calls/Jumps erated/modified code. Figure 6b shows the code reduction of CHISEL benchmarks, debloated by CHISEL and RAZOR.On average, RAZOR achieves 68.19% code reduction for SPEC benchmarks and 78.8% code reduction for CHISEL benchmarks. We evaluated RAZOR on commonly used benchmarks and real-world applications, including the web browser FireFox and the close-sourced PDF reader FoxitReader. With the zCode heuristic, P