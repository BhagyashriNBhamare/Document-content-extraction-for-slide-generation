Most systems today, for example, allow software to control the frequency and voltage of the underlying hardware at a very fine granularity to extend battery life. Designing effective energy management solutions, however, is a complex task that demands cross-stack design and optimizations: Hardware designers, system architects, and kernel and application developers have to coordinate their efforts across the entire hardware/software system stack to minimize energy consumption and maximize performance. This is dangerous when these faults can be induced from lower privileged software across hardware-enforced boundaries, where security sensitive computations are hosted.We demonstrate that CLKSCREW can be conducted using no more than the software control of energy management hardware regulators in the target devices. We show how the CLKSCREW attack can subvert the hardware-enforced isolation in ARM Trustzone in two attack scenarios: (1) extracting secret AES keys embedded within Trustzone and (2) loading self-signed code into Trustzone. 3 In a system with a fixed capacitative load, at any time t, the instantaneous dynamic power is proportional to both the voltage, V t and the frequency F t as follows: DVFS regulates frequency and voltage according to runtime task demands. The combined need for accurate layer-specific feedback and low voltage/frequency scaling latencies drives the prevalence of unfettered and software-level access to the frequency and voltage hardware regulators.P t ∝ V 2 t × F t . Voltage regulators supply power to various components on devices, by reducing the voltage from either the battery or external power supply to a range of smaller voltages for both the cores and the peripherals within the device. Privileged software like a kernel driver can use these memory-mapped control registers Figure 2: Separate clock sources for each Krait core.to direct voltage changes. The frequency regulator contains a Phase Lock Loop (PLL) circuit, a frequency synthesizer built into modern processors to generate a synchronous clock signal for digital components. A multiplexer (MUX) is used to select amongst the three clock sources, namely (1) a PLL supplying a fixed-rate 300-MHz clock signal, (2) a High-Frequency PLL (HFPLL) supplying a clock signal of variable frequency based on a N multiplier, and (3) the same HFPLL supplying half the clock signal via a frequency divider for finer-grained control over the output frequency.As shown in Figure 2, the variable output frequency of the HFPLL is derived from a base frequency of 19.2MHz and can be controlled by configuring the N multiplier. Software support for DVFS comprises two key components, namely vendor-specific regulator drivers and OS-level power management services.Besides being responsible for controlling the hardware regulators, the vendor-provided PMIC drivers [5,6] also provide a convenient means for mechanisms in the upper layers of the stack, such as the Linux CPUfreq power governor [46] to dynamically direct the voltage and frequency scaling. To appreciate why unfettered access to hardware regulators is dangerous, it is necessary to understand in general why over-extending frequency (a.k.a. overclocking) or under-supplying voltage (a.k.a. undervolting) can cause unintended behavior in digital circuits.Synchronous digital circuits are made up of memory elements called flip-flops (FF). For the overall circuit to propagate input D src → output Q dst , the minimum required clock cycle period 4 , T clk , is bounded by the following timing constraint (1) for some microarchitectural constant K:T clk ≥ T FF + T max_path + T setup + K (1)Violation of timing constraint. For example, in the attack scenario described in Section § 5.3, we seek to inject a fault into a memoryspecific operation that takes roughly 65,000 clock cycles within an entire RSA certificate chain verification operation spanning over 1.1 billion cycles. On this device, DVFS is configured to operate only in one of 15 possible discrete 5 Operating Performance Points (OPPs) at any one time, typically by a DVFS OS-level service. Using the softwareexposed controls described in § 2.2, while maintaining a low base frequency of 300MHz, we configure the voltage regulator to probe for the range during which the de-5 A limited number of discrete OPPs, instead of a range of continuous voltage/frequency values, is used so that the time taken to validate the configured OPPs at runtime is minimized.6 /d/regulator/kraitX/voltage 7 /d/clk/kraitX_clk/measurevice remains functional. These two measures ensure that our fault injection effects are contained within the core that the target victim code is running on.ATTACK ENABLER (GENERAL) #3: The deployment of cores in different voltage/frequency domains isolates the effects of cross-core fault attack. F θ |T anchor = {F volt , F pdelay , F freq_hi , F dur , F freq_lo } To support execution of trusted code isolated from untrusted one, two leading industry technologies, ARM Trustzone [11] and Intel SGX [9], are widely deployed.They share a common characteristic in that they can execute both trusted and untrusted code on the same physical core, while relying on architectural features such as specialized instructions to support isolated execution. The attacker can repeatedly invoke the Trustzone app from the non-secure environment to decrypt any given ciphertext, but is restricted from reading the AES keys directly from Trustzone memory due to hardware-enforced isolation. To load this app into Trustzone as our victim program, we use a publicly known Trustzone vulnerability [17] to overwrite an existing Trustzone syscall handler, tzbsp_es_is_activated, on our Nexus 6 device running an old firmware 8 . With this feature, we can now measure how long it takes for our Trustzone app to decrypt a single ciphertext, even from the non-secure world.ATTACK ENABLER (TZ-SPECIFIC) #5: Execution timing of code running in Trustzone can be profiled with hardware counters that are accessible outside Trustzone.Using the hardware cycle counter, we track the duration of each AES decryption operation over about 13k invocations in total. This shows that the victim thread does not exhibit too much variability in terms of its execution time.Recall that we want to deliver a fault to specific region of the victim code execution and that the faulting parameter F pdelay allows us to fine-tune this timing. To detect if a fault is induced in the AES decryption, we add a check after the app invocation to verify that the decrypted plaintext is as expected. In this attack, we choose not to do so, because (1) the algorithm of the AES operation is fairly straightforward (one KeyExpansion round, followed by 10 AES rounds [43]) to estimate F pdelay , and (2) the execution duration of the victim thread does not exhibit too much variability. Assuming a fault can be injected during the seventh AES round to cause a single-byte random corruption to the intermediate state in that round, with a corrupted input to the eighth AES round, this DFA can reduce the number of AES-128 key hypotheses from the original 2 128 to 2 12 , in which case the key can be brute-forced in a trivial exhaustive search. Since CCNT target can be profiled beforehand and CCNT attack is controllable via the use of F pdelay , an attacker is able to control which AES round to deliver the fault to for this attack. Given the faulting parameters, F θ , AES-128 = {F volt = 1.055V, F pdelay = 200k, F freq_hi = 3.69GHz, F dur = 680, F freq_lo = 2.61GHz}, it took, on average, 20 faulting attempts to induce a one-byte fault to the input to the eighth AES round. ARMbased SoC processors use the ARM Trustzone to provide a secure and isolated environment to execute securitycritical applications like DRM widevine [28] trustlet 9 and Algorithm 1 Given public key modulus N and exponent e, decrypt a RSA signature S. Return plaintext hash, H. x ← MONTMULT(x, 1, N rev , r −1 ) H ← FLIPENDIANNESS(x) 22: return H 23: end procedure key management keymaster [27] trustlet. The code blob is then distributed together with the signature and a certificate containing the signing modulus N. Subsequently, the code blob C can be authenticated by verifying that the hash of the code blob matches the plaintext decrypted from the signature using the public modulus N: Sig e mod N == H(C). For the Nexus 6 in particular, we use the shamu-specific firmware image (MOB31S, dated Jan 2017 [1]), downloaded from the Google firmware update repository.The RSA decryption function used in the signature verification is the function, DECRYPTSIG 11 , summarized in Algorithm 1. MONTMULT performs Montgomery multiplication of two inputs x and y with respect to the Montgomery radix, r [38] and modulus N as follows: MONTMULT(x, y, N, r −1 ) ← x · y · r −1 mod N.In addition to the use of MONTMULT, DECRYPTSIG also invokes the function, FLIPENDIANNESS 12 , multiple times at lines 4, 14 and 21 of Algorithm 1 to reverse the contents of memory buffers. We observe that N can be corrupted to a predictable N A as follows:N A,rev f ault ← −− − FLIPENDIANNESS(N)Since N A,rev is N A in reverse byte order, for brevity, we refer to N A,rev as N A for the rest of the section. Line 15 marks the beginning of the modular exponentiation of the input signature, and thus, we focus our analysis here.First, since we want DECRYPTSIG(S A , e, N) to result in H(C A ) as dictated by Equation 2, we begin by analyzing the invocation of DECRYPTSIG that will lead to H(C A ). We implement a loop within the fault injection thread to continuously execute dynamically generated dummy instructions in the cache-set-congruent memory addresses (the Prime step) and then timing the execution of these instructions (the Probe step) using the clock cycle counter. By treating this series of eviction gap duration values, g, as a time-series stream, we can approximate the execution profile of the chain validation code running within Trustzone.We plot a snapshot of the cache profile characterizing the validation of the fourth and final certificate in Fig- ure 11. Based on the independent variables feat_cache1 and feat_cache2, we build linear regression models to predict F pdelay that can best target a fault at an intended position within the N rev buffer. Figure 14 shows a significant clustering of faults around positions 140 -148. We use the following faulting parameters to target faults to specific positions within the buffer: where two bytes at positions 141 and 142 are corrupted.F θ , RSA = {F volt = 1.055V, F pdelay = adaptive, F freq_hi = 3.99GHz, F dur = 1, F freq_lo = 2.61GHz}. The use of separate domains, like in the 32-bit ARMv7 architecture explored in this work, expose the 64-bit ARMv8 devices to similar potential dangers from the softwareexposed energy management mechanisms.Cloud computing providers. For example, the PMIC found on the Nexus 6 is also deployed on the Galaxy Note 4. First, while trusted execution technologies like Trustzone and SGX separate execution modes for security, the different modes continue to operate on the same core. While many of these works are demonstrated on FPGAs [58] and ASICs [54], it is unclear how feasible it is on commodity devices and how much chip area and runtime overhead it adds. Since then, many works use the Rowhammer issue to demonstrate the dangers of such softwareinduced hardware-based transient bit-flips in practical scenarios ranging from browsers [30], virtualized environments [50], privilege escalation on Linux kernel [52] and from Android apps [57]. While we use CLKSCREW to induce faults in memory contents, CLKSCREW can conceivably affect a wider range of computation in microarchitectural units other than memory (such as caches, branch prediction units, arithmetic logic units and floating point units). Furthermore, CLKSCREW is the tip of the iceberg: more security vulnerabilities are likely to surface in emerging energy optimization techniques, such as finer-grained controls, distributed control of voltage and frequency islands, and near/sub-threshold optimizations.Our analysis suggests that there is unlikely to be a single, simple fix, or even a piecemeal fix, that can entirely prevent CLKSCREW style attacks. This demands research in a number of areas such as better Computer Aided Design (CAD) tools for analyzing timing violations, better validation and verification methodology in the presence of DVFS, architectural approaches for DVFS isolation, and authenticated mechanisms for accessing voltage and frequency regulators.