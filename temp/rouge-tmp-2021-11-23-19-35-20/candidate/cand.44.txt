Thus, static source code analysis has long prevailed as the most promising technique for kernel code verification and bug-finding, since it only requires access to the source code, which is typically available.Unfortunately, kernel code is a worst-case scenario for static analysis because of the liberal use of pointers (i.e., both function and arguments are frequently passed as pointers). These staggering numbers were attributed to lower overall code quality in drivers and improper implementations of the complex interactions with the kernel core by the third party supplying the driver.In 2011, Palix et al. [39] analyzed the Linux kernel again and showed that while drivers still accounted for the greatest number of bugs, which is likely because drivers make up 57% of the total code, the fault rates for drivers where no longer the highest. Our recent analysis of main line linux kernel commit messages found that 28% of CVE patches to the linux repository in the past year involved kernel drivers (19% since 2005), which is in line with previous studies [17]. These tools evolved to reduce user interaction (i.e., removing the need for manual annotation of source code) by using machine learning and complex data structures to automatically identify potential dangerous portions of code [41,[59][60][61][62][63]. While some have been implemented on top of custom tools and data structures (e.g., Joern [59][60][61][62]), others have been implemented as compiler-level optimizations on top of popular open-source projects (e.g., LLVM [32]). Finally, the memory corruption in a different function (i.e., adjust traffic flow by pkg), which means that that the analysis must be able to handle inter-procedural calls in a context-sensitive way to precisely report the origin of the tainted data. A control flow graph (CFG) of a function is a directed graph where each node represents a basic block (i.e., a contiguous sequence of non-branch instructions) and the edges of the graph represent possible control flow between the basic blocks. Topological sort or ordering of nodes in a directed graph is an ordering of nodes such that, for every edge from node v to u, v is traversed before u. An alias object, ˆ a = {ρ,t}, is a tuple that consists of a map (ρ) between offsets into that object, n, and the other corresponding alias objects that those offsets can point to, as well as a local taint map (t) for each offset. For example, this can be used to represent a structure stored in a static location, representing an alias object, which contains pointers at given offsets (i.e., offsets into that object) to other locations on the stack (i.e., their alias objects). We define it asS = {φ c , τ c },where φ c : ∆ → φ is the map between a context and the corresponding points-to map, and τ c : ∆ → τ is the map between a context and corresponding taint trace map. However, in the worst case, points-to analysis could potentially grow unconstrained,Algorithm 1: Soundy driver traversal analysis function SDTraversal((S, ∆, F)) sccs ← topo sort(CFG(F)) forall the scc ∈ sccs do if is loop(scc) then HANDLELOOP(S, ∆, scc) else VISITSCC(S, ∆, scc) end end function VisitSCC((S, ∆, scc)) forall the bb ∈ scc do forall the I ∈ bb do if is call(I) then HANDLECALL(S, ∆, I) else if is ret(I) then S ← S ∪ {φ ∆ (ret val), τ ∆ (ret val)} else DISPATCHCLIENTS(S, ∆, I) end end end end function HandleLoop((S, ∆, scc)) num runs ← LongestUseDe fChain(scc) while num runs = 0 do VISITSCC(S, ∆, scc) num runs ← num runs − 1 end function HandleCall((S, ∆, I)) if ¬is visited(S, ∆, I) then targets ← resolve call(I) forall the f ∈ targets do ∆ new ← ∆||I φ new ← (∆ new → (φ c (∆)(args), φ c (∆)(globals))) τ new ← (∆ new → (τ c (∆)(args), τ c (∆)(globals))) S new ← {φ new , τ new } SDTRAVERSAL(S new , ∆ new , f ) end mark visited(S, ∆, I) endresulting in everything pointing to everything. When handling loops, we must ensure that we iterate over the loop enough times to ensure that every possible assignment of every variable has been exercised. The client analyses can collect and maintain any required information in the global state, making the information immediately available to each other.To analyze a driver entry point ε, we first create an initial state: S start = {φ start , / 0}, where φ start contains the points-to map for all of the global variables. We use the low-level virtual machine (LLVM) intermediate representation (IR), Bitcode [30], as our IR for analysis. The analysis clients interact with our soundy driver traversal (SDT) analysis by implementing visitors, or transfer functions, for specific LLVM IR instructions, which enables them to both use and update the information in the global state of the analysis. Since SDT is contextsensitive, the instruction location is a combination of the current context and the instruction offset within the function bitcode.Algorithm 2: Points-to analysis transfer functionsfunction updatePtoAlloca (φ c , τ c , δ , I, v, loc x ) map pt ← φ c (δ ) loc x ← (x, / 0, / 0) map pt (v) ← (0, loc x ) function updatePtoBinOp (φ c , τ c , δ , I, v, op 1 , op 2 ) map pt ← φ c (δ ) pto 1 ← map pt (op 1 ) pto 2 ← map pt (op 2 ) set 1 ← {(0, ob) | ∀( , ob) ∈ pto 1 } set 2 ← {(0, ob) | ∀( , ob) ∈ pto 2 } map pt (v) ← map pt (v) ∪ set 1 ∪ set 2 function updatePtoLoad (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) set 1 ← {ob(n) | ∀(n, ob) ∈ pto op } set 2 ← {(0, ob) | ∀ob ∈ set 1 } map pt (v) ← map pt (v) ∪ set 2 function updatePtoStore (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) pto v ← map pt (v) set v ← {ob | ∀( , ob) ∈ pto v } ∀(n, ob) ∈ pto op do ob(n) ← ob(n) ∪ set v function updatePtoGEP (φ c , τ c , δ , I, v, op, o f f ) map pt ← φ c (δ ) pto op ← map pt (op) set op ← {ob(n) | ∀(n, ob) ∈ pto op } set v ← {(o f f , ob) | ∀ob ∈ set op } map pt (v) ← map pt (v) ∪ set v The result of our points-to analysis is a list of values and the set of all of the possible objects, and offsets, that they can point to. function updateTaintAlloca (φ c , τ c , δ , I, v, loc x )Nothing to dofunction updateTaintBinOp (φ c , τ c , δ , I, v, op 1 , op 2 ) map t ← τ c (δ ) set v ← map t (op 1 ) ∪ map t (op 2 ) map t (v) ← set v ||I function updateTaintLoad (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) set op ← {ob t (n)||I | ∀(n, ob) ∈ pto op } map t ← τ c (δ ) map t (v) ← map t (v) ∪ set op function updateTaintStore (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) map t ← τ c (δ ) tr v ← map t (v) ∀(n, ob) ∈ pto op do ob t (n) ← ob t (n) ∪ (tr v ||I) function updateTaintGEP (φ c , τ c , δ , I, v, op, o f f ) UPDATETAINTBINOP(φ c , τ c , δ , I, v, op, o f f )Internal kernel functions. 2 . . . 3 s t a t i c s s i z e t 4 a c c d e t s t o r e c a l l s t a t e 5 ( s t r u c t d e v i c e d r i v e r * d d r i , 6 c o n s t c h a r * b u f , s i z e t c o u n t ) 7 { 8 / / * * I m p r o p e r u s e o f t a i n t e d d a t a * * 9/ / b u f can c o n t a i n more t h a n one c h a r ! The various bug detectors used by DR. CHECKER in our analysis are explained below:Improper Tainted-Data Use Detector (ITDUD) checks for tainted data that is used in risky functions (i.e., strc*, strt*, sscanf, kstrto, and simple strto Listing 3: A zero-day vulnerability discovered by DR. CHECKER in Mediatek's mlog driver using our TAD and TLBD analysis. The example in Listing 3 shows this in a real-world bug, which also triggered on TAD.Listing 4: An information leak bug via padded fields detected by our ULD in Mediatek's FM driver where a struct's memory is not sanitized before being copied back to user space leaking kernel stack data. These types of bugs can result in information leaks or buffer overflows since the tainted size is used to control the number of copied bytes.Uninit Leak Detector (ULD) keeps tracks of which objects are initialized, and will raise a warning if any src pointer for a userspace copy function (e.g., copy to user) can point to any uninitialized objects. Luckily, each vendor has a code-name that is used in all of their options and most of their files (e.g., Qualcomm configuration options contain the string MSM, Mediatek is MTK, and Huawei is either HISI or HUAWEI), which helps us identify the various vendor options and file names. For example, struct file operations on Mediatek's mt8163 kernel has its ioctl function at field 11, whereas on Huawei, it appears at field 9 in the structure.To handle these eccentricities in an automated way, we used c2xml [11] to parse the header files of each kernel and find the offsets for possible entry function fields (e.g., read or write) in these structures. To evaluate the efficacy of DR. CHECKER, we performed a large-scale analysis of the following nine popular mobile device kernels and their associated drivers (437 in total). - - - √ Inter-procedural - - - - √ Handles pointers - - - - √ Kernel Specific - - - √ √ No Manual Annotations √ √ √ - √ Requires compilable sources √ - - √ √ Sound - - - - - Traceable Warnings - - - √ √Ultimately, the tools seemed reasonable for basic code review passes, and perhaps for less-security minded programs, as they do offer informational warning messages:Flawfinder: Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). For example, if a function with a vulnerable condition is called multiple times from different contexts, DR. CHECKER will raise one warning for each context.GlobalVariableRaceDetector suffered from numerous false positives because of granularity of the LLVM instructions. The same overapproximation of points-to affected InvalidCastDetector, with 2 entry points (picolcd debug flash read and picolcd debug flash write) resulting in 66 (80%) false positives in Huawei and a single entry point (touchkey fw update.419) accounting for a majority of the false positives in Samsung. IntegerOverflowDetector also suffered from over-approximation at times, with 30 false warnings in a single entry point hifi misc ioctl for Hauwei.One notable takeaway from our evaluation was that while we expected to find numerous integer overflow bugs, we found them to be far more prevalent in 32 bit architectures than 64 bites, which is contrary to previously held beliefs [58]. Moreover, these 18 entry points produced 63 warnings and took a total of 52 minutes to evaluate, compared to 9 warnings and less than 1 minute of evaluation time using our soundy analysis.Fixed-point Loop Analysis Since we were unable to truly evaluate a sound analysis, we also evaluated our second assumption (i.e., using a reach-def loop analysis instead of a fixed-point analysis) in isolation to examine its impact on DR. CHECKER. Zakharov et al.[65] discuss many of the existing tools and propose a pluggable interface for future staticanalysis techniques, many of which are employed in DR. CHECKER. Johnson et al. [28] proposed a sound CQUAL-based [24] tool, which is context-sensitive, field-sensitive, and precise taint-based analysis; however, this tool also requires user annotations of the source code, which DR. CHECKER does not.KINT [56] uses taint analysis to find integer errors in the kernel. While KINT is sound, their techniques are specialized to integer errors, whereas DR. CHECKER attempts to find general input validation errors by compromising soundness.Linux Driver Verification (LDV) [36] is a tool based on BLAST [27] that offers precise pointer analysis; however, it is still a model-checker-based tool, whereas we built our analysis on well-known static analysis techniques. VCCFinder [41] also used a similar pattern-matching approach, but automatically constructed their signatures by training on previously known vulnerabilities to create models that could be used to detect future bugs.MECA [63] is a static-analysis framework, capable of taint analysis, that will report violations based on user annotations in the source code, and similarly aims to reduce false positives by sacrificing soundness.