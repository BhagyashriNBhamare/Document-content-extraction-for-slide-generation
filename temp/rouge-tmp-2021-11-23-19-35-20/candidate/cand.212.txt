However, a new trend towards a more proac-tive approach seems to be on the rise, where attackers do not search for vulnerable contracts anymore. We develop a tax-onomy of honeypot techniques and use this to build HON-EYBADGER-a tool that employs symbolic execution and well defined heuristics to expose honeypots. In recent years, companies across the globe have poured value into blockchain research, examining how it can make their existing business more efficient and secure. Honeypots are smart contracts that appear to have an obvious flaw in their design, which allows an arbitrary user to drain ether (Ethereum's cryptocurrency) from the contract, given that the user transfers a priori a certain amount of ether to the contract. Moreover, we introduce HONEYBADGER -a tool that uses a combination of symbolic execution and precise heuristics to automatically detect various types of honeypots. In this section, we provide the required background for understanding the setting of our work, including a description of smart contracts, the Ethereum virtual machine, and the Etherscan blockchain explorer. Smart contracts are usually developed using a dedicated high-level programming language that compiles into low-level bytecode. Despite a large variety of programming languages (e.g. Vyper [44], LLL [19] and Bamboo [6]), Solidity [47] remains the most prominent programming language for developing smart contracts in Ethereum. Besides the world state σ , the EVM also holds a transaction execution environment I, which contains the address of the smart contract that is being executed I a , the transaction input data I d , the transaction sender I s and the transaction value I v . It acts as a blockchain navigator allowing users to easily lookup the contents of individual blocks, transactions and smart contracts on Ethereum. Definition 1 (Honeypot) A honeypot is a smart contract that pretends to leak its funds to an arbitrary user (victim), provided that the user sends additional funds to it. The attacker withdraws the bait together with the funds that the victim lost in the attempt of exploitation.An attacker does not require special capabilities to set up a honeypot. We organise the different techniques in a taxonomy (see Table 1), whose purpose is twofold: (i) as a reference for users in order to avoid common honeypots in Ethereum; (ii) as a guide for researchers to foster the development of methods for the detection of fraudulent smart contracts. Etherscan is perhaps the most prominent Ethereum Figure 2: An example of a balance disorder honeypot.blockchain explorer and many users fully trust the data displayed therein. We also assume that: 1) the attacker has placed a bait in form of ether into the smart contract, as an incentive for users to try to exploit the contract; 2) the attacker has a way of retrieving the amount of ether contained in the honeypot. The function multiplicate suggests that the balance of the contract (this.balance) and the value included in the transaction to this function call (msg.value) are transferred to an arbitrary address, if the caller of this function includes a value that is higher than or equal to the current balance of the smart contract. Hence, a naive user will believe that all that he or she needs to do, is to call this function with a value that is higher or equal to the current balance, and that in return he or she will obtain the "invested" value plus the balance contained in the contract. We notice two things though: 1) the function takeAll solely allows the address stored in variable owner to withdraw the contract's balance; 2) the owner variable can be modified by calling the fallback function with a message value that is greater than the current jackpot (line 12). value > 0.1 ether ) { 5 uint256 multi = 0; 6uint256 a m o u n t T o T r a n s f er = 0; 7 for ( var i = 0; i < 2* msg . transfer ( a mo u n t T o T r a n s f e r ) ; 14 } 15 } 16 } Figure 5: An example of a type deduction overflow honeypot.msg receives the value of target, whereas target is given the value of currentOwner, and finally currentOwner receives the default value zero. As a result, the Solidity compiler maps the storage location of the first variable contained in the struct (player) to the storage location of the first variable contained in the contract (randomNumber), thereby overwriting the random number with the address of the caller and thus making the condition at line 14 fail. A naive user will assume that passHasBeenSet is set to false and will try to call the unprotected SetPass function, which allows to rewrite the hash with a known value, given that least 1 ether is transferred to the contract. Since the block numbers on the test networks are smaller, testing this contract on a such a network would transfer all the funds to the victim, making him or her believe that the contract is not a honeypot. Thus, the attacker would simply swap the address of the user contained on the stack with his or her own address and when returning from the delegatecall, the balance would be transferred to the attacker instead of the user. Finally, the honeypot analysis component aims at detecting the different honeypots techniques studied in this paper using a combination of heuristics and the results of the symbolic analysis. The symbolic analysis component starts by constructing a CFG from the bytecode, where every node in the CFG corresponds to a basic block and every edge corresponds to a jump between individual basic blocks. Each program path consists of a list of path conditions (a formula of symbolic expressions), that must be satisfied for execution to follow that path.We reused and modified the symbolic execution engine proposed by Luu et al. [21,20]. This information includes a list of storage writes, a list of execution paths P, a list of infeasible as well as feasible basic blocks, a list of performed multiplications and additions, and a list of calls C. Calls are extracted through the opcodes CALL and DELEGATECALL, and either represent a function call, a contract call or a transfer of Ether. A call consists of the tu- ple (c r , c v , c f , c a , c t , c g ), where c r is the recipient, c v is the call value, c f is the called contract function, c a is the list of function arguments, c t is the type of call (i.e. CALL or DEL-EGATECALL) and c g is the available gas for the call. Receiving funds through a block reward or a selfdestruct makes little sense for a honeypot as this would not execute any harmful code. We iterate over all calls contained in C and report a balance disorder, if we find a call c within an infeasible basic block, wherec v = I v + σ [I a ] b . Detecting an inheritance disorder at the bytecode level is rather difficult since bytecode does not include information about inheritance. Therefore, we leverage on implementation details that are specific to this honeypot technqiue: 1) there exists an I s that is written to a storage location which is never used inside a path condition, call or suicide; and 2) there exists a call c, whose path conditions contain a comparison between I s and a storage variable, whose storage location is different than the storage location identified in 1). We detect a type deduction overflow by iterating over all calls contained in C and checking whether there exists a call c, where c v contains the result of a multiplication or an addition that has been truncated via an AND mask with the value 0xff, which represents the maximum value of an 8-bit integer. Eventually, we report an uninitialised struct, if there exists a call c ∈ C, where either c v contains a value from a storage location of a struct or the path condition of c depends on a storage location of a struct. We detect a hidden state update by iterating over all calls contained in C and checking whether there exists a call c, whose path conditions depend on a storage value that can be modified via another function, without the transfer of funds. Finally, we report a straw man contract if one of the two cases is satisfied: 1) c is executed after c , wherec t = DELEGAT ECALL∧c v = σ [I a ] b ∧c r = I s ; or 2) c is executed before c , where c t = CALL ∧ I s ∈ c a . We aim to determine the reliability of our tool and measure the overall prevalence of honeypots currently deployed on the Ethereum blockchain.Dataset. Thus, after correlating the results with the bytecode of the 2 million contracts currently deployed on the blockchain, a total of 690 contracts were identified as honeypots 5 skip empty string literal (SESL), 5 type deduction overflows (TDO), 80 uninitialised structs (US), 382 hidden state updates (HSU), 14 hidden transfers (HT) and finally 101 straw man contracts (SMC). For the remaining 3 techniques, our tool achieves a decent false positive rate, where the highest false positive rate is roughly 18% for the detection of hidden state updates, followed by 15% false positive rate for the detection of inheritance disorder and finally 12% false positive rate for the detection of straw man contracts. The shortest period was just 4 minutes and 28 seconds after a victim fell for the honeypot. Finally, attackers took an average of 6 days and a median of 22 hours to abort their honeypot after a user had placed a comment.Diversity. Thus, we found that the largest profit in terms of USD, was actually a honeypot with 3.10987 ether, as it was worth 2,609 USD at the time of withdrawal. This is interesting, as it means that users seem to target rather recently deployed honeypots than older ones. For example, while detecting inheritance disorder at the source code level is rather trivial, detecting it at the bytecode level is rather difficult since all information about the inheritance is lost during compilation and not available anymore at the bytecode level. The fact that certain information is solely available at the source code level and not at the bytecode level, obliges us to make use of other less precise information that is available in the bytecode in order to detect honeypot techniques such as inheritance disorder. However, if we take the example of an uninitialised struct honeypot that is disguised as a simple lottery, then we might have the case of a benign user who loses his funds under the assumption that he or she is participating in a fair lottery. [49] introduces ERAYS, a tool that aims to produce easy to analyse pseudocode from bytecode where the source code is not available. Fuzzing techniques have been employed to detect security vulnerabilities in smart contracts [15] and in combination with symbolic execution to discover issues related to the ordering of events or function calls [17]. Moreover, smart contract bytecode cannot grow arbitrarily large due to the gas limit enforced by the Ethereum blockchain.To the best of the authors' knowledge, this paper is the first to consider and discuss honeypot smart contracts, a new type of fraud, and to propose a taxonomy as well as an automated tool using symbolic execution for their detection.