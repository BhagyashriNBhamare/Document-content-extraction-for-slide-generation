For example, they showed that WEP is utterly broken [11,42,4], demonstrated attacks against WPA-TKIP [43,45,47,41], performed security analysis of AES-CCMP [24,39,13], studied the security of the 4-way handshake [17,18,34], and so on.However, most research only focuses on the security of pairwise keys and unicast traffic. This reveals that an attacker can abuse biases to recover an 128-bit group key by capturing 2 30 to 2 32 encryptions of the group key, where the precise number depends on the configuration of the network.Group keys should only be used to protect broadcast or multicast frames. We demonstrate that this allows an attacker to use the group key to inject, and in turn decrypt, any traffic sent in a Wi-Fi network.Finally, we propose and study a novel random number generation tailored for 802.11 platforms. We show our algorithm can generate more than 3000 bits per second, and even when an adversary can predict individual RSSI measurements with high probability, the output of the generator still remains close to uniformly random.To summarize, our main contributions are:• We show that the 802.11 random number generator is flawed, and break several implementations by predicting its output, and hence also the group key. This headers contains the necessary MAC addresses to route the frame: addr1 = Receiver MAC address addr2 = Sender MAC address addr3 = Destination MAC address The Access Point (AP) forwards received frames to their destination, which is either a node on the wired network, or a Wi-Fi client. The PTK is then derived from a shared secret or passphrase, the ANonce and SNonce, and the MAC addresses of the client and AP.In the first message of the 4-way handshake, the AP sends the ANonce to the client (see Figure 2). Finally, the Key IV Key Scheduling (KSA) L = len(key) j, S = 0, range(256) for i in range(256):j += S[i] + key[i % L] swap(S[i], S[j]) return S Keystream Output (PRGA) S, i, j = KSA(key), 0, 0 while True: i += 1 j += S[i] swap(S[i], S[j]) yield S[S[i] + S[j]]Figure 4: Implementation of RC4 in Python-like pseudocode. We use the notations i t , j t , and S t , for the indices i and j and the permutation S after round t. Rounds are indexed based on the value of i after the swap operation. ... We let Z r denote the keystream byte outputted at round r. Whenever it might not be clear whether we are referring to the KSA or PRGA, we use the notations S KSA t and S PRGA t , respectively. Similarly, Mantin discovered a long-term bias towards the pattern ABSAB, where A and B represent byte values, and S a short sequence of bytes called the gap [29]. Letting g denote the length of the gap, the bias can be written as follows:Pr[Z r , Z r+1 = Z r+g+2 , Z r+g+3 ] = 2 −16 񮽙 1 + e (−4−8g)/256 256 񮽙Hence the longer the gap, the weaker the bias.Listing 1: Random number generator as proposed by the 802.11 standard in Python-like pseudocode [21, §M.5].1 def PRF-256(key, label, data):2 R = HMAC-SHA1(key, label + "\x00" + data + "\x00") 3 R += HMAC-SHA1(key, label + "\x00" + data + "\x01") The security enhancements amendment to 802.11, called 802.11i, includes a software-based RNG [22, §H.5.2]. It only states that the send and receive timestamps of frames should use the highest resolution possible, preferably 1 ms or better. In any case, either calling NetworkJitter implies waiting a significant amount of time until there is new traffic, or repeated calls return the same value.When the second clause of the if statement on line 10 is taken, the arrival times of frames transmitted during the 4-way handshake are used. Actual group keys, called Group Temporal Keys (GTKs), are derived from the GMK and key counter using a Pseudo-Random Function (PRF) in new gtk. Hence, once the value of GMK has been leaked, or recovered by an attacker, all subsequent groups keys can be trivially predicted.Since the standard assumes that GenRandom provides cryptographic-quality random numbers, there appears to be no advantage in using this key hierarchy. Instead of initializing gnonce to key counter in line 7 of Listing 2, it generates a new value using GenRandom, and assigns the result to gnonce.We show that this RNG is flawed by predicting the group key generated by an Asus RT-AC51U. Since it is trivial to determine whether AES or TKIP is used, and less than 10 possible initial values are used in both cases, we end up with at most 32 · 10 possible values for the GMK.The second step is to estimate the jiffies count when the GTK, i.e., group key, was generated. In other words, we conjecture that the prediction after a year will be off by at most 200 seconds.We created an OpenCL program to search for the group key on a GPU. Assuming we can estimate time at which the group key was generated with an accuracy of one second, and that the timestamp in the next call to the RNG differs by at most 10 ms, we have to test 1 000 000 · 10 000 ≈ 2 33 keys. Since at this stage no operating system is loaded, we consider it an ideal candidate to investigate how vendors implement RNGs in a constrained (embedded) environment.Currently, the Wi-Fi module of Open Firmware only provides client functionality. It takes the uptime of the device in number of milliseconds, runs this twice through a linear congruential generator, combines it with its own MAC address, and finally expands this data using a Pseudo-Random Function (PRF). This is problematic because, if multiple ciphers can be used to protect the handshake, an adversary can try to perform a downgrade attack to induce the AP into encrypting and transmitting the group key using a weak cipher.Interestingly, the 4-way handshake can indeed be protected by several cipher suites [21, §11.6.2], meaning a downgrade attack is possible. Ciphers Used Fast Transition (FT) AES-CMAC, AES key wrap CCMP without FT HMAC-SHA1, AES key wrap TKIP without FT HMAC-MD5, RC4 particular, when support for fast network transitions is requested, AES-CMAC and and NIST AES key wrap are used to protect messages in the 4-way handshake. Hence the client will be forced to select TKIP, causing the AP use to RC4 for encrypting the group key.We tested this downgrade-style attack against a network that advertised both support for TKIP and CCMP. This matches the construction of the per-message key K in the 4-way handshake, where the public 16-byte IV is prepended to the secret but static 16-byte KEK key. More formally, the per-message key is constructed as follows:K = IV || KEKAlthough the first 256 keystream bytes of RC4 are dropped, Mantin showed this does not prevent key recovery attacks [28]. Mantin proved that applicable IVs leak information about the key byte K [x] through the following relation [28]:Pr[ K[x] = S −1 x−1 [i 257 − z 257 ] − j x−1 − S x−1 [x] ] ≈ 1.1 · 2 −8(1)This relation can be used to recover K[x] with a simple voting mechanism as follows. Fortunately, this is possible by relying on the predictable IEs that are located at the start of the EAPOL Key Data field, meaning we can derive the keystream at these initial positions.We now determine how much effort it takes to collect the required number of applicable IVs. Assuming a random initial IV is used, this will not happen with a probability of The 802.11 standard states that a station must generate an initial random IV at startup, and increment this IV after it is used in a message [21, §11.6.5]. This means around 256 · n messages must be collected in order to have roughly n applicable IVs for all iterations.K[0] + K[1] = x − 1While it is possible to generate many handshakes by forcibly disconnecting clients, new handshakes will use a different KEK key. Hence we examine the biases induced by the public IV contained in EAPOL frames, and then demonstrate through simulations that these can be used to recover the group key.It is impossible to empirically investigate every possible IV, since this would mean inspecting 2 128 values. IV a = 0x2fe931f824ef842bf262dbca357bb31c IV b = 0x48d9859f9fa08bb1599744a20491dd49IV c = 0x6c1924761b03faf8decc0dfc09dd3078IV d = 0xe31257489cbe7d91e5365286c26f5023These keystream distributions were generated using 2 45 RC4 keys for each IV. That is, for 0 ≤ x ≤ 15, we generated datasets for the vectors IV 0 [x] = y, where y ranges between 0 and 255. A more detailed discussion of these biases is out of scope, and is left as future work.We now use the IV-dependent biases to recover repeated plaintext, in order to get an indication of how well a plaintext recovery attack works against the 4-way handshake. For the candidate generation algorithm, which returns a list of plaintext candidates for a sequence of bytes, we first need to determine at which position the group key is stored in the EAPOL Key Data field.The location of the group key depends on which cipher suites are supported. In contrast, if both TKIP and AES are supported, and if the older WPA informa- tion elements are included in addition to the RSN IEs 3 , the group key starts at position 62. Even when an adversary creates a rogue AP advertising TKIP, the real AP will reject any request for TKIP, and hence will never use RC4 in the 4-way handshake. At this point we were able to successfully decrypt these broadcast packets using the group key, and read out the unicast IP packets sent by both the victim and router. If the network is operating in infrastructure mode, the AP should ignore all frames with a broadcast or multicast receiver address. In these environments, connected stations do not trust each other, meaning group keys should not be used at all. Eight of these subcarriers are used as guards to avoid channel cross talk, and are thus not sampled, resulting in 56 usable subcarriers. Since our commodity devices can generate a large number of measurements per second, even when there is no background traffic, we need a fast method to process all these measurements. In other words, our goal is only to design a method to rapidly process RSSI measurements which can be implemented in Wi-Fi radios, and to asses the quality of the resulting output.We start by deriving one (possibly biased) bit out of each RSSI measurement. We do this by relying on the large number of measurements that our commodity devices can generate.To suppress possible biases in the 1-bit per subcarrier construction, we combine several bits using an exclusiveor chain. Assuming that each bit b i is equal to one with probability p, combining n bits in this manner has the following characteristics [10]:Pr[bit = 1] = 0.5 − 2 n−1 · (p − 0.5) n (2) Pr[bit = 0] = 0.5 + 2 n−1 · (p − 0.5) n(3)We can now see that as n goes to infinity, both probabilities approach 0.5, meaning any possible biases will be suppressed. We conjecture that the 1.9% of tests that are marked as weak are statistical flukes: even a random steam of bits can look non-random at times.Finally, we remark that in the normal execution mode of the generator, in total 56 · 16 bits are XOR'ed together. In practice, implementations can then query the Wi-Fi chip for random samples, and properly and securely manage this collected randomness using a model such as the one proposed by Barak and Halevi [3], or one of its improvements [9]. While the random number generators that are used in certain browsers [14], OpenSSL [8], Linux [3,16], GNU Privacy Guard [35], FreeBSD [50], and so on, have been widely studied, we are not aware of any works that study the random number generator of 802.11. Furthermore, it does not discuss how to inject unicast traffic using the group key, nor does it show how all internet traffic can be decrypted using the group key.Several previous works use the RSSI measurements of 802.11 frames, as returned by commodity Wi-Fi radios, to create secret key agreement protocols [32,23,38]. An adversary can abuse this in an attempt to recover the group key.We also showed that the group key can be used to inject any type of packet, and can even be used decrypt all internet traffic in a network.