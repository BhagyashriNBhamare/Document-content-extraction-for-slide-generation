However, more recently, highly sophisticated DoS attacks have emerged, in which a single, carefully crafted request results in significant resource consumption and ties up a web applica-tion's back-end components for a non-negligible amount of time. To evaluate Rampart's effectiveness and efficiency, we demonstrate that it protects two of the most popular web applications, WordPress and Drupal, from real-world and synthetic CPU-exhaustion DoS attacks, and we also show that Rampart preserves web server performance with low false positive rate and low false negative rate. Particularly problematic is that sophisticated DoS attacks are difficult to detect by state-of-the-art defenses, such as source address filtering or traceback mechanisms, because they were designed to mitigate large-scale network-layer DDoS attacks [18, 23- 25, 30, 31, 36, 37]. Since a legitimate request can be mistakenly labeled as suspicious, the defense system has to quickly detect and revoke any false positive filter that blocks legitimate requests, to not reduce the application's availability unnecessarily.To address these challenges, we leverage statistical methods and fine-grained context-sensitive program profiling, which allows us to accurately detect and attribute CPU-exhaustion DoS attacks. To prevent pollution attacks against the statistical models, Rampart collects only profiling measurements of normal requests that do not cause a CPU-exhaustion DoS and that do not deviate much from the norm observed in the past. For example, when launching known attacks without Rampart's protection, then the average CPU usage increases from 32.21% to 95.05% for attacks on Drupal and from 42.21% to 94.14% for attacks on WordPress. Last, we demonstrate Rampart's ability to protect the two applications from unknown vulnerabilities.We make the following technical contributions:• We present Rampart, which is a defense that detects and mitigates sophisticated CPU-exhaustion DoS attacks against web applications by using statistical models and function-level program profiling. • We thoroughly evaluate Rampart with both realworld and synthetic vulnerabilities in two popular web applications, and we demonstrate that it effectively mitigates the impact of low-rate CPUexhaustion DoS attacks and preserves application availability and server performance. She does not, however, send numerous attack requests within a very short time window, i.e., flooding the target server, because volumetric attacks with a high attack rate can be easily detected by complementary network-based defenses, and a low attack rate is already sufficient to overwhelm the web server. To detect and stop low-rate CPU-exhaustion DoS attacks efficiently, we have to address five core challenges: Different from conventional DDoS attacks, low-rate application-layer DoS attacks are difficult to detect because they do not overwhelm a web server with large number of concurrent requests. Relying on hand-crafted features and payload values is similarly problematic because they do not scale across applications or attacks, and because real attack payloads can depend on other parameters and they may even vary per user or time for some (unknown) vulnerabilities [1]. Naturally, any defense mechanism relying on statistical properties may have false positives, i.e., legitimate requests that are blocked by a filter, or requests that might incorrectly be identified as attack requests, and, hence, might cause a false positive filter to be deployed. Therefore, a profile at the application-level or request-level is not suitable to differentiate attack requests from normal requests.To precisely model the resource usage of a web application in different states, Rampart employs contextsensitive function-level program profiling. Specifically, Rampart records the CPU time spent in a function (including time spent by the operating system's kernel on behalf of the function) instead of its wall clock time, because an application instance can be interrupted and rescheduled by the operating system before the function returns. In particular, we encode the execution state (ID) by calculating the hash value of the application's past states and the name of the function being invoked. A straw-man approach to detect CPU-exhaustion DoS attacks is to set a global timeout in the web application because a key characteristic of such attacks is that their requests take considerable time and consume numerous CPU cycles of the victim server. For example, a user may upload a large file that could take a long time to transfer or process.Instead of such a straw-man approach, Rampart monitors the CPU usage of a web server to detect CPUexhaustion DoS attacks, which works because attackers want to occupy as many CPU cores as possible, so that the victim server is less responsive. If r S is greater than a pre-defined threshold R CPU (e.g., 90%), Rampart raises an alarm, thus, indicating that the server is overloaded, and likely victim to a CPU-exhaustion DoS attack.Intuitively, the requests that consumed the most CPU time can be identified as the culprits that caused the CPUexhaustion. If they are not close the means, however, then Rampart aborts these requests if the server is overwhelmed, because they are indistinguishable from attack requests.A limitation of Rampart is that it requires at least one observation of a function call before it can rely on the function to determine if a request is suspicious. Rampart suspends the allowed suspicious requests temporarily to free CPU time for other requests, i.e., allowed suspicious requests have lower priority.Rampart's algorithm to decide whether a request should be aborted or suspended is shown in Algorithm 1. Therefore, Rampart builds filtering policies using the source IP (network) address, the requested URI, and the request parameters (e.g., the query string and post data, i.e., keys and values of PHP's GET and POST arrays) of an attack request. Rampart then immediately rejects a follow-up request matching any filter without further processing it.An attacker cannot evade the filter by supplying decoy parameters because each parameter is matched independently. On the other hand, if the lifespan of a filter is too short, then an attacker can wait and launch another round of attacks.To address the above challenge, we design an exploratory algorithm to adaptively adjust the lifespan of a filter, instead of setting a fixed lifespan. Rampart aborts this request if a CPU-exhaustion DoS attack attempt is detected, and it renews the filter with a longer primary lifespan to penalize the attacker. Rampart decides if it should explore a request (line 12-15) with a probability depending on the current average server CPU usage r, and the parametersˆRparametersˆ parametersˆR CPU , ˇ R CPU , α, and β (line 5-6). Rampart is unlikely to detect a false positive user request it explores as suspicious again, because the server load is expected to be lower than the upper CPU usage threshold that is used to detect attacks. To further mitigate contention, Rampart offloads database operations to a dedicated daemon that regularly processes the measurement data.Rampart also sets a wall clock timer to periodically query for historical profiling records of function frames that have not yet returned. Thus, Rampart can wait until then or until the request was processed, whichever comes first.Finally, Rampart can optionally sample one measurement every X requests, and, in turn, avoid the system calls to write out measurements for X − 1 requests. Following, we first describe our experiment settings and the baseline performance of the two applications (Section 3.1), then we evaluate the performance overhead introduced by Rampart (Section 3.2), and, last, we look at the performance degradation caused by sophisticated DoS attacks with and without Rampart (Section 3.3). Both machines are on the same local area network (LAN) to eliminate any randomness that might result from sending requests over the Internet.We created 256 user accounts after a fresh installation of each application, and we saved the application database to disk so that we can recover the state for reproducibility. It mimics multiple parallel users (replaying multiple interactions in parallel), of whom each is assigned one user account.To evaluate overall server performance, we measure performance of each web application with various traffic loads (number of users). For each request, we record the timestamps when it was sent (T start ) and when the corresponding response was received (T end ), and we compute the request processing time (RPT = T end − T start ). For WordPress, the server performance remains close to its baseline performance (Table 1) while Max_Prof_Depth was less than five, but performance degrades when more function frames are profiled.To investigate how Max_Prof_Depth might influence server performance, we recorded the number of profiled function frames and the time spent processing the measurement results by our analysis daemon. The number of in-flight requests (RIF) in each one-second window are shown in a green solid line, and the average server CPU usage is shown in a blue dashed line in the top figure. Indeed, such sophisticated application-layer DoS attacks require significantly fewer resources to be successful.In our experiments, we configure the user traffic generator to run 32 user sessions (Section 3.2), and the attack traffic generator to operate 8 or 16 attacker sessions. Here, Rampart uses the probabilistic algorithm (Algorithm 1) to lower a suspicious request's priority by either aborting or suspending it, but it does not deploy any filters to block requests. We assign a unique local IP address to each user/attacker session, so that Rampart can distinguish the different instances.We evaluate two threshold values (50% and 75%) for the CPU usage thresholdˆRthresholdˆ thresholdˆR CPU , which Rampart uses to determine if a server is under attack. At the same time, Rampart helps to preserve server performance and availability substantially, compared to the attack results without Rampart (Table 3). Since the attackers sent requests at an interval of five seconds, which is shorter than T s , Rampart incremented the primary lifespan of a filter as penalty each time an exploring request was detected as suspicious.Because Rampart blocked most of the attack requests immediately, it preserved the web server's performance as if no attack had occurred (Table 5). The results for the remaining three experiments withˆR withˆ withˆR CPU = 50%, namely, XML-RPC on Drupal, PHPass on WordPress, and XML-RPC on WordPress, are shown in Fig Compared to static vulnerability analysis tools that look for specific features in the source code, Rampart does not require an application's source code, nor does it require any knowledge about specific CPU-exhaustion DoS vulnerabilities. Overall, the synthetic attacks experiments demonstrate that Rampart can detect and mitigate CPU-exhaustion DoS attacks regardless of the location of the vulnerable code, i.e., it can detect and mitigate attacks not only for front-facing code, but it can also detect and mitigate attacks for (third-party) library functions. We compare Rampart to the most relevant work, i.e., sophisticated DoS vulnerability detection, program profiling techniques, and anomaly detection. Existing research focused on finding vulnerabilities (bugs) that can be exploited to launch sophisticated DoS attacks. SlowFuzz is a dynamic testing tool that generates inputs triggering worst-case algorithmic behavior for several well-known algorithms [27]. Although these systems can detect CPU-exhaustion bugs before the applications are deployed, they commonly rely on additional manual analysis to confirm vulnerabilities or reduce false positives. Rampart achieves a low false positive rate by leveraging a probabilistic algorithm and by updating the filtering rules intelligently with an exploratory strategy, and it exhibits false negatives only if an attack is not severe enough to consume significant CPU resource.Program Profiling. Rampart performs context-sensitive functionlevel program profiling and learns statistical models from historical observations, which it then employs to detect and stop suspicious requests that could cause CPUexhaustion DoS. The views, findings, conclusions or recommendations expressed in this material are those of the authors and should not be interpreted as necessarily representing the official views, policies or endorsements, either expressed or implied, of DARPA, NSF, ONR, or the U.S. Government.