We then propose the Secure Socket API (SSA), a minimalist TLS API built using existing network functions and find that it can be employed by existing network applications by modifications requiring as little as one line of code. As a result, projects have emerged that reduce the size of security APIs [20], enhance library security [1], and perform certificate validation checks on behalf of vulnerable applications [3,18,9,5]. A common conclusion of these works is that TLS libraries need to be redesigned to be simpler for developers to use securely.In this work we present the Secure Socket API (SSA), a TLS API for applications designed to work within the confines of the existing standard POSIX socket API already familiar to network programmers. This effort required an analysis of current security library use to guide our efforts, and careful interaction with kernel network code to not introduce undue performance overhead in our implementation. This and other TLS APIs have been criticized for their complexity [11,12] and, anecdotally, our own explorations find many functions within libssl that have non-intuitive semantics, confusing names, or little-to-no use in applications. If TLS usage can be mapped to existing POSIX API syntax and semantics, then that mapping represents the most simple TLS API possible, in the sense that other approaches would either need to wrap or redefine the standard networking API.Under the POSIX socket API, developers specify their desired protocol using the last two parameters of the socket function, which specify the type of protocol (e.g., SOCK DGRAM, SOCK STREAM), and optionally the protocol itself (e.g., IPPROTO TCP), respectively. Our selection of packages made a total of 24,124 calls to the libssl API.The resulting categories are of two types: those that are used for specifying behavior of the TLS protocol itself (e.g., symbols that indicate which TLS version to use, or how to validate a certificate), and those that relate specifically to OpenSSL's implementation (e.g., symbols used to allocate and free OpenSSL structures, options to turn on bug workarounds). For each category, we employed both automated static code analysis techniques, using Joern [26], and manual inspection to understand the use cases for each of its symbols.Immediately we found that 170 of the 504 API symbols are not used by any application in our analysis. Of the 388 (68%) calls that indicate a singular TLS version to use, only 60 (15%) use the latest version of TLS (1.2), and 83 (21%) specify the use of the vulnerable SSL 3.0. We manually analyzed an additional sample of packages and found that many adopt default settings or retrieve their cipher suite lists dynamically from environment variables and configuration files.Our analysis indicates that, like with version selection, developers want to let the system select cipher suites for them, and that those who choose to hardcode behaviors often make mistakes. Five other extensions-including Online Certificate Status Protocol (OCSP)-are used much less often, and Heartbeats, PRF, Serverinfo, and Supported Curves are not used at all.Our observation is that many extensions should be configured by the system administrator. However, one is used to verify that a given private key corresponds to a particular certificate, and two are used to provide decryption passphrases to unlock private keys.Given that most functions in this category are unused, and that all but three of those that are used are for specifying the locations of certificates and private keys, we recommend the SSA have simplified options for supplying private key and certificate data. Additionally, the SSA can check whether a supplied key is valid for supplied certificates on behalf of the developer, removing the need for developers to check this themselves, reporting relevant errors through return values of key assignment functionality. We make this recommendation with one caveat: if an application would like to validate a certificate based on a hard-coded set or its own root store, then it can supply a set of trusted certificates to the SSA. Manual inspection of these packages found this was used for logging and to pass session data to other processes, presumably to support load balancing for servers.We recommend that session caching be implemented by the SSA, relieving developers of this burden, with options for developers to disable caching and customize session TTLs. Through manual inspection we find that many of these configurations are set by compilation parameters, suggesting that many developers are leaving these decisions to administrators already.Given that the uses of this category are primarily bug workarounds and restricting the use of outdated protocols, and that many of these are already set through compilation flags, we recommend leaving such configurations to the administrator. The allocation category contains functions such as SSL library init and SSL free, whose existence is obviated by the existence of the SSA because all relevant memory allocation and freeing is performed as part of calls such as socket and close. General Behavior Behavior under IPPROTO TLS Create an endpoint for communication utilizing the given protocol family, type, and optionally a specific protocol.Create an endpoint for TLS communication, which utilizes TCP for its transport protocol if the type parameter is SOCK STREAM and uses DTLS over UDP if type is SOCK DGRAM. The SSA enforces global TLS policy for any application, unless a configuration profile for that specific application is present, in which case it enforces the settings from the application-specific profile.We do this in a fashion similar to the application-specific profiles of AppArmor [24], the mandatory access control module used by Ubuntu and other Linux distributions. This option will cause the SSA to use the Server Name Indication in the TLS Client Hello message, and also use the specified hostname to verify the certificate in the TLS handshake. Used to indicate one or more certificates to be a trust store for validating certificates sent by the remote peer. The setsockopt and getsockopt POSIX functions provide a means to support additional settings in cases where a protocol offers more functionality than can be expressed by the limited set of principal functions. The developer simply uses IPPROTO TLS as the third parameter of their call to socket and then calls setsockopt with the TLS REMOTE HOSTNAME option to provide a destination hostname. When supplied with a hostname address type, the connect function will perform the necessary host lookup and perform a TLS handshake with the resulting address, also using the provided hostname for certificate validation and the SNI ex- tension. If the developer wishes to bind to a particular hostname, then they may use setsockopt with the TLS HOSTNAME option on their listening socket.The options listed in Table 3 are useful primarily in special cases, such as for client certificate pinning, or specifying a particular certificate and private key to use in the TLS handshake. Table 4 summarizes the results of these efforts.We modified the command-line wget web client to use the SSA for its secure connections. In porting this and wget, most of the time spent was used to become familiar with the source code and remove OpenSSL calls.We also modified two applications that did not previously use TLS, an in-house webserver and the netcat utility. The TLS upgrade for netcat for both server and client connections required modifying five lines of code and was accomplished in under ten minutes, with the developer not being familiar with the code beforehand.These efforts suggest that porting insecure programs to use the SSA can be accomplished quickly and that porting OpenSSL-using code to use the SSA can be relatively easy, even without prior knowledge of the codebase. The application links to the security library, such as OpenSSL or GnuTLS, and then uses the POSIX Socket API to communicate with the network subsystem in the kernel, typically using a TCP socket.A corresponding diagram, shown in Figure 3, illustrates how our implementation of the SSA compares to this normal usage. The kernel component of our SSA implementation supplies its own functions for TLS behavior, using the kernel to associate these functions with all sockets created using IPPROTO TLS. The supplied functions are then invoked when a user application invokes a corresponding POSIX socket call on a TLS socket, through the system call interface.When an SSA-using application invokes an I/O operation on a TLS socket, the kernel component transfers the plaintext application data to the user space daemon for encryption, and the encrypted data are then transmitted to the intended remote endpoint. In the reverse direction, encrypted data from the remote endpoint are decrypted by the daemon and then sent to the kernel to be delivered to the client application. â€¢ Socket options Throughout a TLS socket's lifetime, an application may wish to use setsockopt or getsockopt to assign and retrieve information about various socket behaviors. In addition to, or replacement of these methods, administrators can defer validation to TrustBase [18], which offers multiple coexisting certificate validation strategies.Creating an internal socket between applications and the daemon provides natural support for existing socket I/O and polling operations. Bates et al. [3] found that 94% of popular TLS-using Ubuntu packages are dynamically linked with their security libraries, indicating that handling the dynamic linking case would be a significant benefit.We supply replacement OpenSSL functions through a shared library for dynamically linked applications to override normal behavior (usable via LD PRELOAD, dropin library replacement, etc.). By hooking functions that operate on file descriptors, we isolate an application's socket behavior from the OpenSSL library, allowing the SSA to control network interaction exclusively.OpenSSL uses an SSL structure to maintain all TLS configuration for a given connection, including the certificates, keys, TLS method (server or client), etc., that the application has chosen to associate with the given TLS connection (which is done through other function calls). Our tool obtains the information needed to perform a TLS connection from this SSL structure.When a connection is made on an SSL-associated socket, our tool silently closes this socket, creates a replacement SSA TLS socket, and then uses dup2 to make the new socket use the old file descriptor. The daemon uses this descriptor as its external socket for the brokered TLS connection, and the SSA provides a new TLS socket descriptor to the application for interaction with the daemon.We abstracted this functionality and added it to our Linux implementation in the kernel component, providing the developer with a TCP TLS UPGRADE option to upgrade a TCP socket to use TLS via the SSA after it has been connected. We also discuss SSA configuration under different deployment scenarios and offer some security considerations. This simplified TLS interface allows developers to focus on the application logic that makes their work unique, rather than spending time implementing standard network security with complex APIs.Because our SSA design moves all TLS functionality to a centralized service, administrators gain the ability to configure TLS behavior on a system-wide level, and tailor settings of individual applications to their specific needs. For example, administrators can set preferences for or veto specific TLS versions, cipher suites, and extensions, or automatically upgrade applications to TLS 1.3 without developer patches. Other languages can be easily modified to use the SSA, as demonstrated with our efforts to add support to Go, Python, and PHP.Adding TLS to the Linux kernel as an Internet protocol allows the SSA to leverage the existing separation of the system call boundary. If the application becomes compromised, the key data (and master secret) remain safely outside the address space of the application, inaccessible to malicious parties (getsockopt for TLS PRIVATE KEY is unimplemented). The Linux Security Module framework, for example, was created to provide a shared kernel API to access control modules, which allowed administrators to pick the best solution for their needs (e.g., SELinux, AppArmor, Tomoyo Linux, etc.). In a similar fashion, our approach in registering a new TLS protocol allows different kernel modules to hook relevant POSIX socket endpoints for TLS connections and provide unique implementations. Such risks are part of operating system services in general, as they constitute single points of failure. We also note that given the popularity of OpenSSL, it can also behave as a single point of failure, as with the Heartbleed vulnerability.Another benefit of centralization is that it vastly simplifies the landscape of security problems we face today. Under the SSA, developer security flaws are likely to be less common, due to the simplicity of invoking the SSA through the POSIX interface and offloading of TLS functionality to the operating system.Regardless of underlying implementation, the SSA should protect its configuration files from unauthorized edits. Here we outline related work that aims at simplifying and securing TLS libraries, and improving administrator control.Simplified TLS libraries: libtlssep is a simplified userspace library for TLS that uses privilege separation to isolate sensitive keys and other data it uses from the rest of the application, which reduces the payoff for malicious parties exploiting application bugs [1]. Collectively, prior work also largely ignores the suitability of their APIs to languages other than C/C++, which limits their utility to a large amount of developers.Administrator control over TLS: Fahl et al. [9], MITHYS [5] and two other solutions, TrustBase [18] and CertShim [3], provide administrator and operating system control over TLS certificate validation. Our analysis of OpenSSL and how applications use it revealed that developers tend to adopt library defaults, make mistakes when specifying custom settings, implement boilerplate functionality that is best implemented by the operating system, and configure TLS usage based on compile-time arguments supplied by administrators. These findings informed the design of our API, and we find that TLS usage fits well within the confines of the existing POSIX socket API, requiring only the addition of constant values to three functions (socket, getsockopt, setsockopt) to support TLS functionality.