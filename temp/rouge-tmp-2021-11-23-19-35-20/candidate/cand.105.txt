Over the past decade, this goal has led the software community to consider shifting from the One Thread Per Client Architecture (OTPCA) used in Apache to the Event-Driven Architecture (EDA) championed by Node.js.Perhaps inspired by Welsh et al.'s Scalable EventDriven Architecture (SEDA) concept [97], server-side EDA frameworks such as Twisted [24] have been in use since at least the early 2000s. Just as OutOfBoundsErrors allow applications to detect and react to buffer overflow attacks, so TimeoutErrors allow EDA-based applications to detect and react to EHP attacks.Our Node.cure prototype ( ยง5) implements first-class timeouts in the Node.js framework. We have developed a guide for practitioners on building EHP-proof systems, updated the Node.js documentation to warn developers about the perils of several APIs, and improved the safety of the fs.readFile API.In summary, here are our contributions:1. Node.cure enables the detection of and response to EHP attacks with application performance overheads ranging from 0% to 24% ( ยง6). The Event-Driven Architecture (EDA) tries the opposite approach and reverses these tradeoffs, with many clients sharing execution resources: client connections are multiplexed onto a single-threaded Event Loop, with a small Worker Pool for expensive operations. For example, with reference to Figure 1, a callback might perform some string operations in CB A1 , then offload a file I/O to the Worker Pool in Task A1 so that another client's request can be handled on the Event Loop. An application's JavaScript code is executed using Google's V8 JavaScript engine [64], the event-driven architecture is implemented using libuv [10], and Node.js has core JavaScript libraries with C++ bindings for system calls. In an AC attack, a malicious client crafts input that shifts the performance of the victim service's data structures and algorithms from average-case to worst-case, reducing throughput to cause denial of service. Because EHP attacks are only concerned with time, AC attacks are just one mechanism by which an EHP attack can be realized; any time-consuming operation, whether computation or I/O, is a potential EHP vector. The attacker knows how to exploit this vulnerability: they know the victim feeds user input to a vulnerable API, and they know evil input that will cause the vulnerable API to block the Event Handler executing it.Not all DoS attacks are EHP attacks. Distributed denial of service (DDoS) attacks are also out of scope; they consume a server's resources with myriad light clients providing normal input, rather than one heavy client providing malicious input. A lifeline is a DAG whose vertices are callbacks or tasks and whose edges are events or task submissions.We define the total complexity of a lifeline as the cumulative complexity of all of its vertices as a function of their cumulative input. This evil input causes the Event Handler executing it to block, starving pending requests.An EHP attack can be carried out against either the Event Loop or the Workers in the Worker Pool. Based on typical Worker Pool sizes, we assume the Worker Pool is small enough that poisoning it will not attract the attention of network-level defenses.Since the EDA relies on cooperative multitasking, a lifeline's synchronous complexity (time) provide theoretical and practical bounds on how vulnerable it is. A string composed of /'s followed by a newline takes exponential time to evaluate in Node.js's regular expression engine, poisoning the Event Loop in a CPUbound EHP attack.The second EHP vulnerability is on Line 3. In the EDA, directory traversal vulnerabilities can be parlayed into I/O-bound EHP attacks, "ReadDoS", provided the attacker can identify a slow file 3 from which to read. Without Node.cure the 3 In addition to files exposed on network file systems, /dev/random is a good example of a slow file: "[r]eads from /dev/random may block" [33]. When attacked, Node.cure's throughput dips until a TimeoutError aborts the malicious request(s), after which its throughput temporarily rises as it bursts through the built-up queue of pending events or tasks.only remedy would be to restart the server, dropping all existing client connections. After client A's benign request is sanitized (CB A1 ), the readFile task goes to the Worker Pool (Task A1 ), and when the read completes the callback returns the file content to A (CB A2 ). We also considered the vulnerabilities in the CVE database and the Node Security Platform database [13], but found that these databases were subsets of the Snyk.io database.We obtained a dump of Snyk.io's npm database in June 2018. A high-level CWE number is given next to each class.The dark bars in Figure 4 show the 403 vulnerabilities (35%) that can be employed in an EHP attack under our threat model ( ยง3.1). Instead of statically bounding an API's synchronous complexity through program refactoring, using timeouts we can dynamically bound its synchronous time. In this approach, the runtime detects and aborts long-running callbacks and tasks by emitting a TimeoutError, thrown from synchronous code (callbacks) and returned from asynchronous code (tasks). For example, desktop and mobile operating systems commonly use a heartbeat mechanism to detect and restart unresponsive applications, and in the OTPCA a client thread can easily be killed and replaced if it exceeds a timeout. If an OS offers truly asynchronous I/O interfaces then these provide an avenue to more fine-grained partitioning, but unfortunately Linux's asynchronous I/O mechanisms are incomplete for both file I/O and DNS resolution.If timeouts are applied systematically across the software stack (application, framework, language), then they offer a strong guarantee against EHP attacks. As the composition of safe APIs may be vulnerable 5 , application 5 For example, consider while(1){}, which makes an infinite sequence of constant-time language "API calls". Just as modern languages offer null pointer exceptions and buffer overflow exceptions to protect against common security vulnerabilities, so too should modern EDA frameworks offer timeout exceptions to protect against EHP attacks.In the remainder of the paper we describe our design, implementation, and evaluation of first-class timeouts in Node.js. If the submitter does not request an extension, the Manager creates a replacement Worker so that it can continue to process subsequent tasks, creates a Hangman thread for the poisoned Worker, and notifies the Event Loop that the task timed timeout-aware Worker Pool, including the roles of Event Loop, executors (both worker pool and priority), and Hangman. If a rapid response is necessary, then done must be able to run before killed finishes, resulting in a dangling worker problem: an API's work implementation may access externallyvisible state after the Event Loop receives the associated TimeoutError. Because the libuv file system and DNS implementations share memory between the Worker and the submitter, we modified them to use message passing for memory safety of dangling workers -wherever the original implementation's work accessed memory owned by the submitter, e.g. for read and write, we introduced a private buffer for work and added copyin/copyout steps. Our TimeoutWatchdog instruments every callback using the experimental Node.js async-hooks module [15], which allows an application to register special callbacks before and after a callback is invoked.Before a callback begins, our TimeoutWatchdog starts a timer. To support a TimeoutError, we modified V8 as follows: (1) We added the definition of a TimeoutError into the Error class hierarchy; (2) We added a TimeoutInterrupt into the list of high-priority interrupts; and (3) We added a V8 API to raise a TimeoutInterrupt. The TimeoutWatchdog calls this API, which interrupts the current JavaScript stack by throwing a TimeoutError.The only JavaScript instructions that V8 instruments to be interruptible are regular expression matching and JSON parsing; these are the language-level vulnerable APIs. If the application workload contains many small callbacks, whose cost is comparable to this synchronization cost, then the overhead of a precise TimeoutWatchdog may be considerable.If the timeout threshold is soft, then the overhead from a TimeoutWatchdog can be reduced by making the Event Loop-TimeoutWatchdog communication asynchronous. If an attacker might re-use the same evil input multiple times, however, we can track whether or not an input led to a timeout and short-circuit subsequent requests that use this input with an early timeout.While evil input memoization could in principle be applied to any API, the size of the input space to track is a limiting factor. In contrast, the evil inputs that trigger I/O-bound EHP attacks such as ReadDoS must name a particularly slow resource, presenting an opportunity to short-circuit requests on this slow resource.In Node.cure we implemented a slow resource management policy for libuv's file system APIs, targeting those that reference a single resource (e.g. open, read, write). Our prototype is for Linux, and we added 4,000 lines of C, C++, and JavaScript code across 50 files spanning V8, libuv, the Node.js C++ bindings, and the Node.js JavaScript libraries.Node.cure passes the core Node.js test suite, with a handful of failures due to bad interactions with experimental or deprecated features. Our suite is comprehensive and conducts EHP attacks using every vulnerable API we identified, including the language level (regular expressions, JSON), framework level (all vulnerable APIs from the file system, DNS, cryptography, and compression modules), and application level (infinite loops, long string operations, array sorting, etc.). Our suite could be used to evaluate alternative defenses against EHP attacks.To evaluate any difficulties in porting real-world Node.js software to Node.cure, we ported the node-oniguruma [12] npm module.This module offloads worst-case exponential regular expression queries from the Event Loop to the Worker Pool using a C++ add-on. Our micro- Overheads LokiJS [11] Server, Key-value store 1.00, 1.00 Node Acme-Air [3] Server, Airline simulation 1.03, 1.02 webtorrent [26] Server, P2P torrenting 1.02, 1.02 ws [27] Utility, websockets 1.00, 1.00* Three.js [23] Utility, graphics library Table 3: Results of our macro-benchmark evaluation of Node.cure's overhead. Matching our micro-benchmark assessment of the TimeoutWatchdog's overhead, the overhead from Node.cure increased as the complexity of the callbacks used in the macrobenchmarks decreased -the middleware benchmarks sometimes used empty callbacks to handle client requests. Node.cure enforces timeouts for all vulnerable JavaScript and framework APIs identified by both us and the Node.js developers as long-running: regular expressions, JSON, file system, DNS, cryptography, and compression. They do not advise developers on the design of Node.js applications, which as we have discussed must fit the EDA paradigm and avoid EHP vulnerabilities.We prepared a guide to building EHP-safe EDAbased applications, including discussions about appropriate work patterns and the risks of high-complexity operations.The pull request with the guide was merged after discussion with the community. Each of fs.readFile, crypto.randomFill, and crypto.randomBytes submits a single unpartitioned task to the Worker Pool, and in each of these cases a large task could be expensive in terms of I/O or computation. First, if the EDA framework uses a garbage collected language for the Event Loop (as do Node.js, Vert.x, Twisted, etc.), then triggering many memory allocations could lead to unpredictable blockage of the Event Loop. We are not aware of any reported attacks of this form, but such an attack would defeat firstclass timeouts unless the GC were partitioned. By definition, first-class timeouts preclude the possibility of undetected EHP attacks (false negatives) with a reasonable choice of timeout, and our Node.cure prototype demonstrates that this guarantee can be provided in practice.Developers can assign tighter timeout thresholds to reduce the impact of an EHP attack. In contrast, first-class timeouts will produce a TimeoutError at some point during the handling of the malicious request, permitting exception handling logic to easily respond by dropping the client and, perhaps, adding them to a blacklist.Other avenues toward EHP-safety. In addition, moving modules to separate processes in order to handle EHP attacks incurs significant performance overheads at start-up and larger performance overheads than Node.cure at run-time, and places more responsibility on developers to understand implementation details in their dependencies.Static analysis can be used to identify a number of vulnerabilities in JavaScript and Node.js applications. Although we prove our point using previouslyreported attacks such as ReDoS, the underlying resource we are exhausting is not the CPU but the small, fixed-size set of Event Handlers deployed in EDA-based services.Practitioner awareness. Wandschneider suggests worst-case linear-time partitioning on the Event Loop [96], while Casciaro advises developers to partition any computation on the Event Loop, and to offload computationally expensive tasks to the Worker Pool [47].