Our results show that ACES' compartments can have low runtime overheads (13% on our largest test application), while using 59% less Flash, and 84% less RAM than the Mbed µVisor-the current state-of-the-art compartmentalization technique for bare-metal systems. These components can be compromised to gain access to higher level systems, as demonstrated by Google P0's disclosure of vulnerabilities in Broadcom's WiFi SoC that enable gaining control of a smartphone's application processor [6]. Likewise, the automated workflow of ACES frees the developer from challenging implementation issues of the security controls.Our work breaks the coupling between the application, hardware constraints, and the security policy, and enables the automatic enforcement of compartmentalization policies. Lack of source code will cause a reduction in precision for the compartmentalization for ACES.ACES applies defenses to: (1) isolate memory corruption vulnerabilities from affecting the entire system; (2) protect the integrity of sensitive data and peripherals. For example, the Cortex-M4 (STM32F479I) [48] device we use in our evaluation has 2MB of Flash in the code area, 384KB of RAM, and uses only a small portion of the peripheral space-and this is a higher end Cortex-M4 micro-controller. Throughout this paper, we use the term, "MPU region" to describe a contiguous area of memory whose permissions are controlled by one MPU register. The requirement that MPU region sizes be a power of two leads to fragmentation, and the requirement that MPU regions be aligned on a multiple of its size creates a circular dependency between the location of the region and its size.Execution Modes: ARMv7-M devices support privileged and unprivileged execution modes. ACES automatically enforces the principle of least privileges on bare-metal applications by providing write and control-flow integrity between regions of the program, i.e., if a given code region is exploited via a vulnerability in it, the attack is contained to that compartment. ACES utilizes the MPU to set permissions on each region and thus, the compartments must satisfy the MPU's constraints, such as starting address and number of MPU regions.The starting point to our workflow is a Program Dependence Graph (PDG) [21]. ACES' design allows PDG creation using static analysis, dynamic analysis, or a hybrid.Using the PDG and a device description, an initial region graph is created. Edges indicate that a function within the code vertex reads or writes a component in the connected data/peripheral vertices.The initial region graph is created by mapping all functions and data nodes in the PDG along with their associated edges directly to the region graph. To illustrate, consider two peripherals vertices that are to be merged and a device description containing four peripherals A, B, C, and D at addresses 0x000, 0x100, 0x200, and 0x300 all with size 0x100. From a security perspective, if two sets of global variables 񮽙 V 1 and 񮽙 V 2 are placed in the same compartment and in the original program code region C 1 accessed 񮽙 V 1 and C 2 accessed 񮽙 V 2 then unnecessary access is granted-now both code regions can access the entire set of variables. Examples of cost functions include: the number of functions that will gain access to unneeded variables in the data regions, how security critical a component is (resulting in a high cost of merging), and the cost of unneeded peripherals included in the merge of two peripherals. ACES generates the appropriate MPU configuration from the final region graph and inserts code during a compilation pass to perform compartment transitions.Ensuring that the proper MPU configuration is used for each compartment is done by encoding each compartment's MPU configuration into the program as read-only data and then on each compartment transition, the appropriate configuration is loaded into the MPU. Then the micro-emulator, using a white-list of allowed locations, enables selective writes to data above the stack pointer.To generate the white-list, static or dynamic analysis may be used. For example, if peripheral P1 is at memory-mapped address [α, α + ∆ 1 ] and peripheral P2 is at address [β , β + ∆ 2 ], then the intermediate node immediately above it will allow access to addresses [α, β + ∆ 2 ]. Code regions dependent on these peripherals must execute in privileged mode; for security, the number and size of such regions should be limited by the policy.To start, we implement two compartmentalization policies, "Peripheral" and "Filename". While the MPU on our target ARMv7-M devices has eight regions, two regions are used for global settings, i.e., making all memory read-only and enabling execution of the default code region, as will be explained in Section 5.3. To instrument the program, all compartment transitions must be identified, each memory region must be placed so the MPU can enforce permissions on it, and the MPU configuration for each region must be added.Using the final region graph, any control edge with a source and destination in different compartments is identified as a compartment transition. The SVC instruction invokes the compartment switching routine, which changes compartments and then, depending on the type of SVC executed, completes the call or return.The compartment pseudo code for the compartment switching routine is shown in Algorithm 1, and is called by the SVC handler. We envision in the future libraries could be distributed as LLVM bitcode instead of machine code, enabling ACES to analyze and instrument the code to create compartments.After instrumenting the binary, ACES lays out the program in memory to enable the MPU to enforce permissions. In addition, the micro-emulator handles all writes where our static analysis under approximates and enables access to areas smaller than the MPU's minimum region size.The micro-emulator can be implemented by modifying the memory permissions to allow access to the fault- ing location and re-executing the store instruction, or emulating the store instruction in software. However, as peripherals often have memory mapped configuration register (e.g., setting clock sources) and other registers for performing is function (e.g., sending data). It reads a pin number over a serial port, hashes it, compares it to a known hash, and if the comparison matches, sends a signal to an IO pin (akin to unlocking a digital lock). We assume a write-what-where vulnerability in the function HAL UART Receive IT that can be used to perform any of these attacks. This means that ACES is always reducing the code that is available to execute.Reduction in Privileged Instructions: Compartmentalization enables a great reduction in the number of instructions that require execution in privileged mode, Table 2, shown as "% Priv." Thus, the Peripheral policy creates a large compartment, containing most of the application.Compartment Connectivity: Compartment connectivity indicates the number of unique calls into (In Degree) or out of a compartment (Out Degree), where a unique call is determined by its source and destination. The Peripheral policy creates many small compartments with very little connectivity and one compartment with high connectivity.Global Variable Exposure: In addition to restricting control-flow in an application, ACES reduces the number of instructions that can access a global variable. Emulating a store instruction replaces a single instruction with an exception handler, authentication, saving and restoring context, and emulation of the instruction.In the results discussion, we use a linguistic shorthand-when we say "compartment exit" or simply "exit", we mean the number of invocations of the compartment exit routine. (1) (2) (3) (1) (2) (3) (1) (2) (3) (1) (2) (3) (1) (2) (3)(The performance results for the three policies are shown in Figure 5. In the case of LCD-uSD with the Na¨ıveNa¨ıve policy which executes over 6.8 million compartment entries, exits, and emulator calls this causes significant overhead.Looking across the policies and applications we see that the Na¨ıveNa¨ıve Filename policy has the largest impact on execution. In addition to runtime overhead, compartmentalization increases memory requirements by: including ACES's runtime library (compartment switcher, and microemulator), adding metadata, adding code to invoke compartment switches, and losing memory to fragmentation caused by the alignment requirements of the MPU. We measure the increase in flash, shown in Figure 6, and RAM, show in Figure 7, for the test applications compiled with ACES and compare to the baseline breaking out the overhead contributions of each component.ACES increases the flash required for the runtime library by 4,216 bytes for all applications and policies. With µVisor, we used two compartments, which logically follows the structure of the application-one compartment handles the IO communication with the serial port and the other handles the computation, i.e., the authentication of the pincode read from the serial port. Averaged across all policies, ACES reduces the Flash usage by 58.6% and RAM usage by 83.9%, primarily because it does not require an OS.ACES runtime is comparable (5.0% increase), thus ACES provides automated protection, increased compartmentalization, and reduced memory overhead with little impact on performance.We investigate the security implications of having code compartmentalization by analyzing the number of ROP gadgets using the ROPgadget compiler [46]. Embedded system specific protections: NesCheck [40] provides isolation by enforcing memory safety. For security, it is desirable to have long compartment chains, resulting in many compartments that must be compromised to reach the privileged compartment.In conclusion, ACES enables automatic application of compartments enforcing least privileges on bare-metal applications. The Optimized Filename starts from the Na¨ıveNa¨ıve policy and then merges groups together, increasing the amount of privileged code, as privileged code is merged with unprivileged code. An attacker with control over the unprivileged compartment may use any interaction between the two compartments to trigger an unlock event.To guard against confused deputy attacks, ACES restricts and validates the locations of all compartment transitions. This results in a daunting challenge for developers, while only achieving coarsegrained data/peripheral compartments.We present ACES (Automatic Compartments for Embedded Systems), an extension to the LLVM compiler that enables the exploration of strategies to apply the principle of least privileges to bare-metal systems. When mapped to memory, a compartment becomes a region of contiguous code, and zero or more regions of data and peripherals. With less restrictive MPUs-e.g., the ARMv8-M MPU only requires regions be multiples of 32 bytes in size and aligned on a 32 byte boundary-this stack protection becomes stronger. They demonstrate the use of different peripherals (LCD Display, Serial port, Ethernet, and SD card) and processing steps that are typically found in IoT systems (compute based on peripheral input, security functions, data sent through peripheral to communicate). Table 4 shows a comparison between ACES and Mbed µVisor for Flash usage, RAM usage, runtime, and number of ROP gadgets. Attacks against IoT devices have already unleashed massive Denial of Service attacks [30], invalidated traffic tickets [14], taken control of vehicles [23], and facilitated robbing hotel rooms [8]. Using the arbitrary read/write primitive, the attacker can perform arbitrary malicious execution, e.g., code in-jection (in executable memory) or code reuse techniques (by redirecting indirect control-flow transfers [47]), or directly overwrite sensitive data. It groups all functions and global variables that are defined in the same file into the same compartment.Two optimizations to the region graph can be applied after applying the Filename policy. TyTan [7] builds on Trustlite and develops a secure architecture for low-end embedded systems, isolating tasks with secure IPC between them. Number of Regions: Recall a compartment is a single code region and collection of accessible data and peripherals. It uses a fixed algorithm to determine the compartments, providing the developer no freedom in determining the best security boundaries for their application. Generally, larger numbers of regions indicate better security.Instructions Per Compartment: This metric measures how many instructions are executable at any given point in time, and thus usable in a code reuse attack. The policies have modest runtime overhead, on average 15.7% for the strongest policy.In summary, our contributions are: (1) Integrity of code and data for unmodified applications running on bare-metal embedded devices. The PDG captures all control-flow, global data, and peripheral dependencies of the application. When executing in enforce mode (i.e., after deployment) the micro-emulator checks if a blocked access is allowed using the white-list and either emulates it or logs a security violation. Another advantage of ACES over Mbed µVisor is its compartments are not hard-coded into the application, enabling them to be automatically determined from high-level policies.We compare ACES and Mbed µVisor by porting PinLock to Mbed µVisor. This attacker model is in line with other control-flow hijack defenses or compartmentalization mechanisms.We assume the system is running a single statically linked bare-metal application with no protections. Securing the rapidly expanding Internet of Things (IoT) is critical. Figure 3 shows several compartments, in