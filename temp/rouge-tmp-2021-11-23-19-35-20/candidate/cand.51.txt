NINJA leverages a hardware-assisted isolated execution environment Trust-Zone to transparently trace and debug a target application with the help of Performance Monitor Unit and Embedded Trace Macrocell. However, sophisticated malware, which is also known as evasive malware, is able to evade the analysis by collecting the artifacts of the execution environment or the analysis tool, and refuses to perform any malicious behavior if an analysis system is detected.As most of the existing mobile malware analysis systems [18,45,52] are based on emulation or virtualization technology, a series of anti-emulation and antivirtualization techniques [29,36,48] have been developed to challenge them. How to build a transparent mobile malware analysis system is still a challenging problem.This transparency problem has been well studied in the traditional x86 architecture, and similar milestones have been made from emulation-based analysis systems [2,40] to hardware-assisted virtualization analysis systems [19,20,32], and then to bare-metal analysis systems [30,31,41,54]. In this system, the Environment is the emulator, which provides access to the system call sequence, and both the system call recorder and the remote server belong to the Analyzer. An Analyzer violating this requirement can be detected.In light of the three requirements, we present NINJA 1 , a transparent malware analysis framework on ARM platform based on hardware features including TrustZone technology, Performance Monitoring Unit (PMU), and Embedded Trace Macrocell (ETM). We evaluate the performance of the trace subsystem with several popular benchmarks, and the result shows that the overheads of the instruction trace and system call trace are less than 1% and the Android API trace introduces 4 to 154 times slowdown.The main contributions of this work include:• We present a hardware-assisted analysis framework, named NINJA, on ARM platform with low artifacts. In ARMv8 architecture, the only way to switch from normal domain to secure domain is to trigger a secure exception [8], and the exception return instruction eret is used to switch back to the normal domain from the secure domain after the exception is handled. The generated elements are encoded into a trace stream and sent to a pre-allocated buffer on the chip.According to Futuremark [23], 21 of the most popular 50 smartphones and tablets are equipped with ARM Cortex-A5x or Cortex-A7x series processors, in which the PMU and ETM components are included. LO-PHI [41] leverages additional hardware sensors to monitor the disk operation and periodically poll memory snapshots, and it achieves a higher transparency at the cost of incomplete view of system states.MalT [54] increases the transparency by involving System Manage Mode (SMM), a special CPU mode in x86 architecture. However, SMM is not designed for security purpose such as transparent debugging (originally for power management); frequent CPU mode switching introduces a high performance overhead (12 µs is required for a SMM switch [54]). The instruction and system call tracing introduce negligible overhead, which is immune to timing attacks while MalT suffers from external timing attack.BareCloud [31] and MalGene [30] focus on detecting evasive malware by executing malware in different environments and comparing their behavior. CopperDroid [45] is a VMI-based analysis tool that automatically reconstructs the behavior of Android malware including inter-process communication (IPC) and remote procedure call interaction. Xen on ARM [50] migrates the hardware virtualization based hypervisor Xen to ARM architecture and makes the analysis based on hardware virtualization feasible on mobile devices. It provides variable-level, message-level, method-level, and file-level taint propagation by modifying the original Android framework.TaintART [44] extends the idea of TaintDroid on the most recent Android Java virtual machine Android Runtime (ART). VetDroid [55] reconstructs the malicious behavior of the malware based on permission usage, and it is applicable to taint analysis. To increase the flexibility, we also use similar technology mentioned in [43] to configure the General Purpose Input/Output (GPIO) buttons as the source of secure Non-Maskable Interrupt (NMI) to trigger the switch. Note that the NMI of GPIO buttons can be replaced by any system events that trigger an interrupt (e.g., system calls, network events, clock events, and etc.), and these events can be used to indicate the start or end of the trace in different usage scenarios.Another advanced feature of ETM is that PMU events can also be configured as an external input source. It establishes a secure channel between the target executing platform and the remote debugging platform, and provides a user interface for human analysts to introspect the execution status of the target application.To interrupt the execution of the target, we configure the PMI to be secure and adjust the value of the PMU counter registers to trigger an overflow at a desired point. Since NINJA is implemented in the secure domain, it cannot understand the semantic information of the normal domain, and we have to fill the semantic gap to learn the current running process in the OS.In Linux, each process is represented by an instance of thread info data structure, and the one for the current running process could be obtained by SP & ∼(THREAD SIZE -1) , where SP indicates the current stack pointer and THREAD SIZE represents the size of the stack. Android maintains a Java virtual machine to interpret Java bytecode, and we need to figure out the current executing Java method and bytecode during the Android API tracing and bytecode stepping. In Android, the bytecode of a Java method is organized as a 16-bit array, and ART passes the bytecode array to the function ExecuteGotoImpl together with the current execution status such as the current thread, caller and callee methods, and the call frame stack that stores the call stack and parameters. The pointer dex cache in the declaring class points to an instance of DexCache which is used to maintain a cache for the DEX file, and the variable dex file in the DexCache finally points to the instance of DexFile, which contains all information of a DEX file. Also, the SELECT bits of the second trace resource selection control register TRCRSCTLR2 (TRCRSCTLR0 and TRCRSCTLR1 are reserved) is configured to 0 to select the external input 0 as tracing resource 2. Since a PMU event BR RETIRED is fired after execution of a branch instruction, we use PMU to trace the BR RETIRED event and reconstruct the semantic information following the approach described in Section 5.1.2 if these functions are invoked.There exist six PMU counters for each processor on Juno board, and we randomly select the last one to be used for the Android API trace and the DS. In the interrupt handler, the ELR EL3 register, which is identical to the PC of the normal domain, is examined to identify whether the execution of normal domain encounters ExecuteGotoImpl or ExecuteSwitchImpl function. In the DS, an analyst pauses the execution of the target application by the secure NMI or predefined breakpoints and send debugging commands to the board via the secure serial port. Once this bit is set, the CPU generates a software step exception after each instruction is executed, and the highest EL that this exception can be routed is EL2. Nonetheless, the modification brings the side effect that the self-checking malware may be aware of it.The PMU event INST RETIRED is fired after the execution of each instruction, and we use this event to implement instruction stepping by using similar approach mentioned in Section 5.3.3. The execution of brk instruction is considered as a software breakpoint while the breakpoint control registers DBGBCR EL1 and breakpoint value registers DBGBVR EL1 provide support for at most 16 hardware breakpoints. Instead of manually walk through the page tables, a series of Address Translation (AT) instructions help to translate a 64-bit virtual address to a 48-bit physical address 2 considering the translation stages, ELs and memory attributes. Although the skid problem cannot be completely eliminated, the side-effect of the skid does not affect our system significantly, and we provide a detailed analysis and evaluation in Section 7.5. Moreover, other anti-debugging techniques like anti-ptrace [53] do not work for NINJA since our analysis does not use ptrace. Since NINJA works in the secure domain, the hardware prevents the target application from detecting the code or memory usage of NINJA. Moreover, as the ATF restores all the general purpose registers while entering the secure domain and resumes them back while returning to the normal domain, NINJA does not affect the registers used by the target application as well. The TPM bit of the MDCR EL3 register and the TTA bit of the CPTR EL3 register help to trap the access to PMU and ETM registers to EL3, respectively; then we achieve the transparency by providing artificial values to the normal domain. Thus, to further defend against these attacks, we intercept the suspicious calls to these functions and redirect the call to return an artificial memory region.The memory size for both the PMU and ETM memory regions is 64k, and we reserve a 128k memory region on the DRAM to be the artificial PMU and ETM memory. To learn the details of the tracing output, we write a simple Android application that uses Java Native Interface to read the /proc/self/status file line by line (which can be further used to identify whether ptrace is enabled) and outputs the content to the console. To reduce the storage usage of the ETM, we can use real-time continuous export via either a dedicated trace port capable of sustaining the bandwidth of the trace or an existing interface on the SoC (e.g., a USB or other high-speed port) [11]. Thus, we use NINJA to set a breakpoint at the address, and the second parameter of the system call, which is stored in register X1, shows that the sample sends a 181 bytes buffer to a remote server. To evaluate whether our mechanism that modifies the local timers works, we write a simple application that launches a dummy loop for 1 billion times, and calculate the execution time of the loop by the return values of the API call System.currentTimeMillis(). The result shows that the average execution time with timer adjusting feature disabled is 116.33s with a standard deviation 2.24s, and that with timer adjusting feature enabled is 54.33s with a standard deviation 3.77s. Performance overhead of the debugging subsystem is not noticed by an analyst in front of the command console, and the debugging system is designed with human interaction.To learn the performance overhead on the Linux binaries, we build an executable that using an open source π calculation algorithm provided by the GNU Multiple Precision Arithmetic Library [46] to calculate 1 million digits of the π for 30 times with the tracing functions disabled and enabled, and the time consumption is shown in Table 2. To reduce the overhead, we can combine ETM instruction trace with data trace, and leverage the trace result to rebuild the semantic information and API usage offline.To measure the performance overhead on the Android applications, we use CF-Bench [16] downloaded from Google Play Store. We evaluate the listed 218 bytecode opcode [24] on the Android official website, and it shows that the shadow region cannot cover the machine code for any of them. For a similar reason, the skid problem has no influence on the Android API tracing.However, the native code stepping and the breakpoint are still affected, and both of them use instruction retired event to overflow the counter. However, using the CPU cycle event may lead to multiple PMIs for a single instruction since the execution of a single instruction may need multiple CPU cycles, which introduces more performance overhead but with more fine-grained instruction-stepping. Since the TZASC only protects the DRAM, we may need additional hardware features to extend the idea of TZASC to the whole physical memory region.Although the instruction skid of the PMI cannot be completely eliminated, we can also enable ETM between two PMIs to learn the instructions in the skid. Our experiment results show that performance overheads of the instruction tracing and system call tracing are less than 1% while the Android API tracing introduces 4 to 154 times slowdown. mw a v Write 8-bit value v to the 64-bit virtual address a and output the address and the 8-bit value stored in the address.