To achieve our objective, AWare binds each operation request to a user input event and obtains explicit authorization for the combination of operation request, user input event, and the user interface configuration used to elicit the event, which we call an operation binding. In addition, AWare is designed to be completely transparent to applications, so applications require no modification run under AWare control, encouraging adoption for contemporary operating systems.We implement a prototype of the AWare authorization framework by modifying a recent version of the An-4 null-byte.wonderhowto.com droid operating system and found, through a study of 1,000 of the most-downloaded Android applications, that such applications can operate effectively under AWare while incurring less than 4% performance overhead on microbenchmarks. We found that the study participants only had to make 2.28 additional decisions on average per application for the entire study period.In summary, the contributions of our research are:â€¢ We identify four types of attacks that malicious applications may still use to obtain access to privacysensitive sensors despite proposed research defenses. These studies report that more than 78% Figure 1: In mobile platforms, once the system authorizes an application to perform a operation, the application may perform that operation at any time, enabling adversaries to stealthily access privacy-sensitive sensors, e.g., record speech using the microphone, at any time.of users could be potentially subject to such attacks. Previous research [6,12,30] and our user study (see Section 8.1.1) show that users frequently fail to identify the application requesting sensor access, the user input widget eliciting the request, and/or the actual operation being requested by an application. Such errors may be caused by several factors, such as users failing to detect phishing [12], failing to recognize subtle changes in the interface [20], and/or failing to understand the operations granted by a particular interface [38]. Figure 2: The user's perception of the operation that is going to be performed differs from the actual operation requested by the application, which abuses a previous granted permission.Operation Switching: A malicious application may try to trick a user into authorizing an unintended operation by changing the mapping between a widget and the associated operation, as shown in Figure 2. The windowing display context surrounding the widget shows a camera preview for photo capturing.Bait-and-Context-Switch: A malicious application may try to trick the user to authorize an unintended operation by presenting a widget in a misleading display context, as shown in Figure 3. Application Spoofing: A malicious application replicates the look-and-feel of another application's interface and replaces the foreground activity of that application with one of its own to gain access to a sensor as shown in Figure 5, similar to a phishing attack. However, inferring user intentions implicitly creates a semantic gap between what the system thinks the user intended and what the user actually intended.Traditionally, access control determines whether subjects (e.g., users and applications) can perform operations (e.g., read and write) on resources (e.g., sensors). Trust Model -We assume that applications are isolated from each other either using separate processes, the sameorigin policy [42], or sandboxing [7,36], and have no direct access to privacy-sensitive sensors by default due to the use of Mandatory Access Control [49,50]. Figure 6 summarizes the steps taken by the AWare to authorize applications' operation requests targeting privacy-sensitive sensors.In a typical workflow, an application starts by specifying a set of user interface configuration, such as widgets and window features, to the trusted software (step 1 ) in charge of rendering such widgets with windows to elicit user input (step 2 ). An authentic user interaction with the application's widgets in a user interface configuration generates user input events (step 3 ), which are captured by the trusted software (step 4 ) together with the current user interface configuration (e.g., enclosing window, window features, ancestors windows, etc.) and forwarded to the application (step 5 ). At this stage, the AWare authorization framework (part of the trusted software layer) has full visibility of: (1) the application's identity; (2) the application's user interface widget; (3) the authentic user input event associated with that widget; (4) the user interface configuration within which the widget is presented to the user; (5) the application's operation request; and (6) the target set of privacy-sensitive sensors for such an operation. The sequence of events in Figure 6 shows that AWare relies on a one-time, explicit user authorization that binds the user input event, the application identity, the widget, the widget's user interface configuration, the operation, and the set of target sensors; then, it reuses this authorization for future operation requests.6 AWare Design As described above, AWare performs authorization using a concept called the operation binding.Definition 1: An operation binding is a tuple b = (app, S, op, e, w, c), where: (1) app is the application associated with both the user interface widget and the operation request; (2) S is the set of sensors (i.e., resources) targeted by the request; (3) op is the operation being requested on the sensors; (4) e is the user input event; (5) w is a user interface widget associated with the user input event; (6) c is the user interface configuration containing the widget.The user interface configuration describes the structure of the user interface when a user input event is produced, which includdes both features of the window in which the widget is displayed and application's activity window call graph, which relates the windows used by the application. AWare prevents operation switching attacks by producing an operation binding that associates a user input event and widget with an application's operation request.Upon a user input event e, AWare collects the widget w, the user interface configuration c in which it is presented, and the application associated with the user interface app. To prevent such attacks, AWare binds the operation request with the user interface configuration used to display the widget, in addition to the widget and user input event.One aspect of the user interface configuration of the operation binding describes features of the window enclosing the widget.Definition 2: A display context is a set of structural features of the most enclosing activity window a w containing the widget w.Structural features describe how the window is presented, excepting the content (e.g., text and figures inside web pages), which includes the position, background, borders, title information, and widgets' position within the window. Similarly, for Baitand-Context-Switch attacks, the same widget presented in a different window (i.e., display context) will not match the previous operation binding, therefore a new operation binding request will be prompted to the user.Once the widget and the display context are bound together and kept fixed, the adversary is left only with the content (e.g., text and figures inside a web page) as possible misleading tool. Note that an application's activity window call graph can be built while the application runs, as the user authorizes operation bindings.If the malicious application has not used this spoofing window previously, then a binding request will be created for the user, which then shows the identity of the application. In fact, AWare does not require any new external libraries, application code annotation or rewriting, which would require significant development effort/burden and impede backward compatibility for existing applications.AWare can be integrated with existing off-the-shelf operating systems, as we show with our AWare prototype discussed in Section 7. In the Appendix, Tables 4 and Table 5 show comprehensive sets of widgets and windows' features used by AWare to authenticate the widgets and their display contexts.Activity Window Call Graph Construction: At runtime, AWare detects inter-activity transitions necessary to construct the per-application activity window call graph by instrumenting the Android Activity Manager and Window Manager components. We discuss nested activity windows in Appendix C.User Input Event Authentication: AWare leverages SEAndroid [49] to ensure that processes running apps or as background services cannot directly read or write input events from input device files (i.e., /dev/input/*) corresponding to hardware interfaces attached to the mobile platform. Also, AWare leverages the Android screen overlay mechanism to detect when apps or background services draw over the app currently in the foreground to prevent input hijacking and avoid processing of any user input event on overlaid GUI widgets. To intercept user input events, we placed twelve hooks inside the stock Android Input Manager.Operation Request Mediation: The Hardware Abstraction Layer (HAL) implements an interface that allows system services and privileged processes to access privacy-sensitive sensors indirectly via well-defined APIs exposed by the kernel. Each security message includes the app identifier (e.g., application name and identity mark) and a text message specifying the ongoing operation and the set of privacy-sensitive sensors being accessed. The use of security messages follows the principle of what the user sees is what is happening [23], in fact, security messages convey ongoing operations targeting privacy-sensitive sensors when authorized by the user.AWare leverages the Compartmented Mode Workstation principle [8] to ensure integrity and authenticity of security messages. We modified the stock Android system user interface (SystemUI), by adding an image view and a text view on the Android status bar to display the AWare security messages specifying the application IDs and the ongoing operations, whenever the AWare MONITOR authorizes system ser- vices to operate on privacy-sensitive sensors on behalf of applications. Reserving a small portion of the screen (5%) to convey a security message is a reasonable trade-off for preventing unwanted user distraction while delivering critical content in a timely and appropriate manner [32]. For all the experiments, we configured the test environment on Nexus 5X smartphones and used a background service, automatically relaunched at boot time, to log participants' responses to system messages/alerts and all user input actions taken by participants while interacting with the testing apps. Participants in Group5 interacted with a modified version of the Android OS implementing the use of access control gadgets [41] including basic user interface configuration checks (i.e., no misleading text, UI background and the text must preserve the contrast, no overlay of UI elements, and user events occur in the correct location at the correct time [39]) and timing checks for implicit authorizations. Group1 (Install-Time): Group2 (First-Use): Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare):100% 93% 100% 100% 0% 0%TASK 2 : Take a picture with the front camera by using the SimpleFilters app.Bait-and-Context-Switch: We make the video camera widget appear in the photo capture window, with a camera preview, to trick the user into allowing SimpleFilters to record audio instead of just take a picture. Group1 (Install-Time): Group2 (First-Use): Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare): 87% 87% 93% 87% 87% 7%TASK 3 : Take six consecutive pictures with the smartphone's front camera by using the SimpleFilters app.Bait-and-Widget-Switch: Before the participants took the fifth picture, the SimpleFilters app replaced the camera widget with the video camera widget to enable video recording instead. Group1 (Install-Time): Group2 (First-Use):Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare): 87% 87% 93% 87% 87% 7%TASK 4 : Record a voice note using the Keep app.Identity Spoofing: We let the participants select the Keep app from the app menu, however, we programmatically triggered the SimpleFilters app to hijack the on-screen activity and spoof the Keep app. Group1 (Install-Time): Group2 (First-Use): Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare):93% 93% 93% 47% 93% 0% Table 1: Experimental tasks for the laboratory-based user study to evaluate the effectiveness of AWare in preventing four types of user interface attacks. Thus, the binding request clearly identifying the operation requested by the app aided them in avoiding to be tricked into granting an unintended operation.The analysis of the subjects' responses to TASK2 and TASK3 revealed that the users were successfully tricked by either switching the user interface configuration within which a widget is presented, or by changing the widget presented within the same configuration, thus, leading them into making mistakes. Thankfully, as described in Appendix A, less than 1% of the 1,000 analyzed apps require programmatic access to privacy-sensitive sensors. We successfully tested it on a Nexus 5X smartphone running the Android OS integrating AWare.Lastly, AWare caused another spurious false positive with the Viber app, which attempted access to the cameras and microphone at each system reboot. Indeed, the Monkey was configured to exercise apps by generating the exact same sequence of events and target all operations on privacy-sensitive sensors on both the Nexus 5X and Nexus 5 smartphones when running both the stock Android OS and the modified version of Android with AWare enabled. Numbers give mean values and corresponding standard deviations after 5 independent runs for the system-wide experiment and after 10,000 independent requests for the device-specific microbenchmark.not have the necessary information regarding higher level events required to associate app requests to user input actions for operations targeting privacy-sensitive sensors. However, the delay introduced for the waiting time (necessary to allow explicit denial) may cause issues for time-constrained applications and may frustrate users.User-Driven Access Control (UDAC) [39,41] proposes the use of access control gadgets to prevent malicious operations from applications trying to access privacysensitive sensors without a user-initiated input. We evaluated the effectiveness of AWare for eliminating ambiguity in a laboratory-based user study, finding that users avoided mistakenly authorizing unwanted operations 93% of the time on average, compared to 19% on average when using proposed research methods and only 9% on average when using first-use or install-time authorizations. Therefore, as long as remote commands are coming from AWare-enabled remote platforms, AWare may pair the AWare modules running on the two platforms by creating a Secure Socket Layer (SSL) connection to allow secure and remote control of the privacy-sensitive sensors by the user.Programmatic Access: There are very rare cases of legitimate applications requiring programmatic access to privacy-sensitive sensors, as shown by our large-scale compatibility analysis reported in Section 8.2. However, as soon as the application goes in the background, any on-screen security message used to notify ongoing operations over privacy-sensitive sensors is replaced with a periodic distinctive sound or a small icon on the system status bar (Section 7.1), if the platform's screen is on, or a hardware sensor-use indicator LED when the platform's screen goes off. However, as soon as the application goes in the background, any on-screen security message used to notify ongoing operations over privacy-sensitive sensors is replaced with a periodic distinctive sound or a small icon on the system status bar (Section 7.1), if the platform's screen is on, or a hardware sensor-use indicator LED when the platform's screen goes off.