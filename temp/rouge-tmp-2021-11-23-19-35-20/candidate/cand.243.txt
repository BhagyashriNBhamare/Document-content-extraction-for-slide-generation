Grey-box fuzz testing has revealed thousands of vulner-abilities in real-world software owing to its lightweight instrumentation, fast coverage feedback, and dynamic adjusting strategies. On the other hand, bugs that appear under specific inputs and interleavings may lead to concurrency-vulnerabilities [5,30], resulting in memory corruptions, information leakage, etc.There exist a line of works on detecting bugs and vulnerabilities inmultithreaded programs. Several techniques like ThreadSanitizer (a.k.a., TSan) [42] and Helgrind [49] have been widely used in practice. Also, by matching unions of keyword patterns "race*", "concurren*" and "thread*" in the MITRE CVE database [48], we found that only 202 CVE records are relevant to concurrency-vulnerabilities out of the 70438 assigned CVE IDs ranging from CVE-2014-* to CVE-2018-*. We categorize the targeted multithreadingrelevant bugs into two major groups:• concurrency-vulnerabilities (V m ): they correspond to memory corruption vulnerabilities that occur in a multithreading context. Given a target program P o and the input else if cov_new_trace(t', res) then 12 Q S ← Q S ⊕ t ; // preserve "effective" seeds seeds Q S , a GBF first utilizes instrumentation to track the coverage information in P o . Then it enters the fuzzing loop: 1) Seed selection decides which seed to be selected next; 2) Seed scheduling decides how many mutations M will be applied on the selected seed t; 3) Seed mutation applies mutations on seed t to generate a new seed t ; 4) During repeated execution, for each new seed t , the fuzzer executes against it N c times to get its execution statistics; 5) Seed triaging evaluates t based on the statistics and the coverage feedback from instrumentation, to determine whether the seed leads to a vulnerability, or whether it is "effective" and should be preserved in the seed queue for subsequent fuzzing. Therefore, different seed files need to be generated to exercise different paths in multithreading context -in fact, this is the starting point that we use fuzzing to generate seed files to test multithreaded programs. Then there are at least three interleavings: i) T1: 1 →T2: 1 →T2: 2 →T1: 2 g_var=4 ii) T1: 1 →T2: 1 →T1: 2 →T2: 2 g_var=4 iii) T1: 1 →T1: 2 →T2: 1 →T2: 2 g_var=2 After the second 2 is executed, the values of g_var may be different (4 and 2, respectively). For example, if check is complicated enough, most of the seeds may fail the check and exit before entering compute -this is quite common due to the low quality of fuzzer-generated seeds [34,61]. As a result, subsequent mutations on this seed will miss important feedback regarding g_var, making it difficult to generate seeds that trigger the vulnerability.To summarize, the challenge of fuzzing multithreaded programs is, existing GBFs have difficulties in generating seeds that execute multithreading context and keep threadinterleaving execution states. According to §2.1, the preservation of seeds is based on the feedback; then we can expect that the fuzzer will preserve more distinct seeds that execute multithreading code segments in the seed queue. For example, during a repeated execution with N c = 40, schedules i) and iii) might occur 10 and 30 times respectively, while schedule ii) do not occur at all; in this scenario, the execution states corresponding to ii) will not be observed by the fuzzer. During A :instrumentation ( §4), for a multithreaded program P o , MUZZ firstly computes thread-aware interprocedural control flow graph (ICFG) and the code segments that are likely to interleave with others during execution [11,45], namely suspicious interleaving scope, in §4.1. 2) Thread-context instrumentation ( §4.3) is a type of lightweight instrumentation that distinguishes different thread identities by tracking the context of threading functions for thread-forks, locks, unlocks, joins, etc. 3) Schedule-intervention instrumentation ( §4.4) is a type of lightweight instrumentation at the entry of a thread-fork routine that dynamically adjusts each thread's priority. For repeated execution ( §5.2), owing to the schedule-intervention instrumentation, MUZZ adjusts the repeating times N c , to maximize the benefit of repetitions and track the interleaved execution states.C :Vulnerability analysis is applied to the crashing seeds found by dynamic fuzzing, which reveals vulnerabilities (including V m ). [34] are the same as typical GBF flows, thus are marked dashed); C (right-bottom) denotes the vulnerability analysis applied on vulnerable seeds; and D (right-top) is the replaying component used to reveal concurrency-bugs from the seed queue. By taking into account the semantics of threading APIs (e.g., POSIX standard Pthread, the OpenMP library), we get an ICFG that is aware of the following multithreading information: 1) TFork is the set of program sites that call thread-fork functions. It includes the call sites of the pthread APIs such as pthread_join, pthread_exit, etc. 3) TLock is the set of sites that call thread-lock functions such as pthread_mutex_lock, omp_set_lock, etc. 4) TUnLock is the set of sites that call thread-unlock functions like pthread_mutex_unlock, omp_unset_lock, etc. 5) TShareVar is the set of variables shared among different threads. According to C3, we exclude the statements that do not access or modify the shared variables g_var, s_var, which means Lines 14 and 16 should also be excluded. However, since lines 10 and 11 have already been put in L m , we consider it sufficient to help provide more feedback to track thread-interleavings, with line 15 excluded from L m . For example, the pointer analysis is flow-and context-insensitive; extraction of thread-aware results such as F f ork (in C1) and TShareVar (in C3) are over-approximated in that the statically calculated sets may be larger than the actual sets; C2 may aggressively exclude several statements that involve interleavings. Then for the instructions within L m , the instrumentation probability is calculated as:P m ( f , b) = min P e ( f ) · N m (b) N(b) , P m0(3)where P m0 is a factor satisfying 0 < P m0 < 1 and defaults to 0.33. Otherwise, 1) for the entry instruction in b, MUZZ always instruments it (i.e., with probability 1.0); 2) for the other instructions, if they are inside L m , MUZZ instruments them with a probability of P m ( f , b). As a comparison, AFL-Ins always instruments evenly at the entry instructions of all the basicblocks.For the example in Figure 1, since the lines 21-25 and line 5 are out of L m , we can expect M-Ins to instrument fewer entry statements on their corresponding basicblocks. As we shall see in §5.1, the occurrence of S ctx determines the results of cov_new_mt_ctx during seed selection.In Figure 1, each time when pthread_mutex_lock∈ TLock is called, MUZZ collects the deputy instruction prior to the corresponding call site (e.g., 3 ) and the thread ID label (e.g., T1) to form the tuple (e.g., 3 , T 1); these tuples form a sequence for TLock, and a hash value H(TLock) will be calculated eventually. It has two purposes: 1) it informs the fuzzer that the current seed is multithreading-relevant; 2) based on the invocation order of F S , each thread can be associated with a unique ID N ctx starting from 1, 2, . . ., which composes "thread ID map" and calculates thread-context in §4.3. In addition to following AFL's strategy by using has_new_trace(Q S ) to check whether there exists a seed, s, in Q S that covers a new transition (i.e., cov_new_trace(s)==true), MUZZ also uses has_new_mt_ctx(Q S ) to check whether there exists a seed in Q S with a new thread-context (S ctx ). For example, a seed may exhibit non-deterministic behaviors when executing compute in Figure 1 (e.g., races in g_var), but it exits soon after failing an extra check inside compute (typically, exit code >0). Conversely, when we provide less feedback for seeds that do not involve multithreading, MUZZ can distinguish less of these states and put less multithreading-irrelevant seeds in the seed queue.3) Large portions of multithreading-relevant seeds in the seed queue benefit subsequent mutations. Owing to more multithreading-relevant seeds in the queue and property 1), we can expect that: a) concurrency-vulnerabilities are more likely to be detected with the new proof-of-crash files mutated from multithreading-relevant files from the seed queue. Other specialization techniques, such as the context-sensitive instrumentation used by Angora [7], or the typestate-guided instrumentation in UAFL [52], provide similar solutions and achieve inspiring results. We try to use their latest versions at the time of our evaluation; the only exception is libvpx, which we use version v1.3.0-5589 to reproduce the ground-truth vulnerabilities and concurrencybugs. Fuzzing Configuration The experiments are conducted on four Intel(R) Xeon(R) Platinum 8151 CPU@3.40GHz workstations with 28 cores, each of which runs a 64-bit Ubuntu 18.04 LTS; the evaluation upon a specific benchmark is conducted on one machine. Considering MAFL, AFL, MOPT apply coverage-oriented instrumentation (M-Ins), we can conclude that other strategies in MAFL, including thread-context instrumentation, schedule-intervention instrumentation, and the optimized dynamic strategies, also contribute to effective seed generation. It is apparent that MUZZ has the best results of N m c in all the benchmarks that have V m vulnerabilities (e.g., for im-cnvt, MUZZ: 63, MAFL: 23, AFL: 6, MOPT: 6). This suggests that MUZZ's and MAFL's emphasis on multithreading-relevant seed generation indeed helps to exercise more erroneous multithreading-relevant execution states.The most important metric is N m v since our focus is to detect concurrency-vulnerabilities (V m ). We also observed that for the 2 vulnerabilities that are detected by all these fuzzers, MAFL's detection capability appears more stable since it detects both in all its six fuzzing runs, while the others can only detect them at most in five runs (not depicted in the table). We consider the reason behind the differences w.r.t. N m c and N m v among the fuzzers to be that, MUZZ keeps more "deeper" multithreading-relevant seeds that witness different execution states, and mutations on some of them are more prone to trigger the crashing conditions.Columns N c , N s c , N s v are metrics less focused. 6 0(+6) 1(0) 0 0 0 0(+6) 0(+1) 0 0 0 0(+6) 0(+1) 0 0 pbzip2-d 15 15 1 0 0 0 0(+15) 0(+1) 0 0 0 0(+15) 0(+1) 0 0 0 0(+15) 0(+1) 0 0 im-1(0) 0 0 78 78(+25) 1(0) 0 0 66 66(+37) 1(0) 0 0 x265 43 0 0 43 1 52 0(0) 0(0) 52 1 62 0(0) 0(0) 62 1 59 0(0) 0(0) 59 1respectively), while MAFL, AFL and MOPT failed to detect it in 15 days (360 hours) in all their six fuzzing runs. Given the fact that there are extremely few CVE records caused by concurrency-vulnerabilities (e.g., 202 among 70438, based on records from CVE-2014-* to CVE-2018-*) [48], MUZZ demonstrates the high capability in detecting concurrency-vulnerabilities. For example, as to N m e in x264, the best result of N m e is achieved with P2 (P1: 68, P2: 91); similarly, the best result of N m B also comes from P2 (P1: 8, P2: 9). In our benchmarks, when we assign P s0 =0.5, P m0 =0.33,• For im-cnvt, the speed slowdown is about 15% compared to default settings, while the capability of detecting concurrency-vulnerabilities and concurrency-bugs are similar; meanwhile, there are a few more multithreadingrelevant seeds (N mt ) but N mt N all is slightly smaller. From Table 4, it is observable that with both P1 and P2, TSan detected four concurrency-bugs (N m B ) by replaying the MAFL generated multithreading-relevant seeds (totally 10784) from Table 2; besides, their N m e results are also similar (P1: 79, P2: 83). For projects with less generated (multithreading-relevant) seeds (e.g., N mt =126 for pbzip2-c when applying MUZZ), traversing the seeds (with both P1 and P2) once are quite fast; however for projects with more generated seeds (e.g., N mt =13774 for gm-cnvt when applying MUZZ), this requires more time. During the evaluation, we found 2h to be moderate since it can traverse all the generated multithreading-relevant seeds at least once for all the projects.Less time budget, e.g., 1h, may make the replay phase to miss certain generated seeds triggering concurrency violation conditions. Therefore, we tend to exclude variance metrics and only choose those that exhibit the "overall results", i.e., N mt , N mt N all , N m c , N m v , N m e , and N m B . The other difference is that MUZZ's thread-aware analyses aim to provide runtime feedback to distinguish more execution states in multithreading contexts, to bring more multithreading-relevant seeds; meanwhile, ConAFL relies on the discovery of sensitive concurrency operations to capture pairs that may introduce the aforementioned three kinds of vulnerabilities. While MUZZ's solution is to distinguish more thread-interleaving states to trap the fuzzing to reveal more multithreading-relevant paths. This includes random testings that mimic non-deterministic program executions [4,25,38], regression testings [47,60] that target interleavings from code changes, model checking [13,57,62] and hybrid constraint solving [20][21][22] approaches that systematically check or execute possible thread schedules, heuristically avoid fruitless executions [10,17,18,66], or utilizing multicore to accelerate bug detection [37]. Experiments on 12 real-world programs demonstrate that MUZZ outperforms other grey-box fuzzers such as AFL and MOPT in generating valuable seeds, detecting concurrency-vulnerabilities, as well as revealing concurrency-bugs.