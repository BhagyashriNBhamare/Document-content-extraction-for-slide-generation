Several vulnerability classes such as memory corruptions, race-conditional memory accesses, and use-afterfree vulnerabilities, are known threats for programs running in user mode as well as for the operating system (OS) core itself. Kernel-level vulnerabilities are usually used for privilege escalation or to gain persistence for kernel-based rootkits.For a long time, fuzzing has been a critical component in testing and establishing the quality of software. In addition, the Windows kernel and many relevant drivers and core components (for Windows, macOS and even Linux) are closed source and cannot be instrumented by common techniques without a significant performance overhead.Previous approaches to kernel fuzzing were not portable because they relied on certain drivers or recompilation [10,34], were very slow due to emulation to gather feedback [7], or simply were not feedback-driven at all [11]. This allows us to obtain up to 17,000 executions per second on an off-the-shelf laptop (Thinkpad T460p, i7-6700HQ and 32 GB RAM) for simple target drivers. We have applied kAFL to Linux, macOS, and Windows and found multiple previously unknown bugs in kernel drivers in those OSs.In summary, our contributions in this paper are:• OS independence: We show that feedback-driven fuzzing of closed-source kernel mode components is possible in an (almost) OS-independent manner by harnessing the hypervisor (VMM) to produce coverage. For example, the virtual memory space of Linux is typically split into kernel space (upper half) and user space (lower half) each with a size of 2 47 due to the 48-bit virtual address limit of current x86-64 CPUs. However, the execution of the different logical CPUs is interleaved by the hardware and therefore the available resources can be utilized more efficiently (e.g., one logical CPU uses the arithmetic logic unit while another logical CPU waits for a data fetch) and the operating system can reduce the scheduling overhead. The VM, also termed guest, is a piece of software that is transparently executed within the virtualized context provided by the VMM.To provide full hardware-assisted virtualization support, Intel VT-x adds two additional execution modes to the well-known protection ring based standard mode of execution. When using hardware-supported virtualization, the CPU switches into the VMX ON state and distinguishes between two different execution modes: the higher-privileged mode of the hypervisor (VMX root or VMM), and the lower privileged execution mode of the virtual machine guest (VMX non-root or VM). With the fifth generation of Intel Core processors (Broadwell architecture), Intel has introduced a new processor feature called Intel Processor Trace (Intel PT) to provide execution and branch tracing information. The processor's output format is packet-oriented and separated into two different types: general execution information and control flow information packets. These events are recorded as FUPs and usually followed by a TIP to indicate the following instruction.To limit the amount of trace data generated, Intel PT provides multiple options for runtime filtering. kAFL focuses on the Table of Physical Addresses (ToPA) mechanism that enables us to specify multiple output regions: Every ToPA table contains multiple ToPA entries, which in turn contain the physical address of the associated memory chunk used to store trace data. When the VM is started, the first part of the user mode agent (the loader) uses the hypercall HC_SUBMIT_PANIC to submit the address of the kernel panic handler (or the BugCheck kernel address in Windows) to QEMU-PT 1 . Then the loader uses the hypercall HC_GET_PROGRAM to request the actual user mode agent and starts it 2. The agent now consumes the input and interacts with the kernel (e.g., it interprets the input as a file system image and tries to mount it 6). One of the bigger design differences to AFL is that kAFL makes extensive use of multiprocessing and parallelism, where AFL simply spawns multiple independent fuzzers which synchronize their input queues sporadically 1 . Example agents are programs that try to mount inputs as file system images, pass specific files such as certificates to kernel parser or even execute a chain of various syscalls.In theory, we only need one such component. QEMU-PT is used to interact with the KVM-PT interface to configure and toggle Intel PT from user space and access the output buffer to decode the trace data. Moreover, QEMU-PT also filters the stream of executed addresses-based on previous knowledge of non-deterministic basic blocks-to prevent false-positive fuzzing results, and makes those available to the fuzzing logic as AFL-compatible bitmaps. In order to do so, we overwrite the kernel crash handler of the OS with a simple hypercall routine. The injected code is shown in Listing 1 and displays how the hypercall interface is used on the assembly level. To the best of our knowledge, no publicly available driver is able to trace only guest executions of a single vCPU using Intel PT for long periods of time. It allows us to trace vCPUs for an indefinite amount of time without any scheduling side effects or any loss of trace data due to overflowing output regions. The physical addresses of this buffer and how to handle full buffers is specified by an array of data structures called Table of Physical Addresses (ToPA) entries.The array can contain multiple entries and has to be terminated by a single END entry 3. To avoid the resulting data loss, we chose the second buffer to be about four times larger than the largest overflowing trace we have ever seen in our tests (4 KB). KVM-PT is accessible from user mode via ioctl() commands and an mmap() interface.In addition to being a userland interface to KVM-PT, QEMU-PT includes a component that decodes trace data into a form more suitable for the fuzzing logic: We decode the Intel PT packets and turn them into an AFL-like bitmap. This is due to the nature of Intel PT decoding since the decoding process is sequential and is affected by previously decoded packets.To ease efforts to implement an Intel PT software decoder, Intel provides its own decoding engine called libipt [4]. Furthermore, libipt does not cache disassembled instructions and has performed poorly in our use cases.Since kAFL only relies on flow information and the fuzzing process is repeatedly applied to the same code, it is possible to optimize the decoding process. Unlike other Intel PT drivers, we do not need to store large amounts of trace data in memory or on storage devices for post-mortem decoding. Each basic block has a randomly assigned ID, and each transition from basic block A to another basic block B is assigned an offset into the bitmap according to the following formula:(id(A)/2 ⊕ id(B)) % SIZE_OF_BITMAPInstead of the compile-time random, kAFL uses the addresses of the basic blocks. When a new interesting input is found, a deterministic stage is executed that tries to mutate each byte individually.Once the deterministic stage is finished, the nondeterministic phase is started.During this nondeterministic phase, multiple mutations are performed at random locations. Similar to AFL, we consider a crashing input to be unique if it triggered at least one basic block transition which has not been triggered by any previous crash (i.e., the bitmap contains at least one new bit). While it does not allow code execution, it is still a denial-of-service vulnerability, as for example, a USB stick with that malicious NTFS volume plugged into a critical system will crash that system with a blue screen. Hence, we assume that the NTFS driver under Windows is a valuable target for coverage-based feedback fuzzing.Furthermore, we implemented a generic system call (syscall) fuzzing agent that simply passes a block of data to a syscall by setting all registers and the top stack region (55 lines of C and 46 lines of assembly code). We did not find any bugs in 13 hours of fuzzing with approx 6.3M executions since many syscalls cause the userspace agent to terminate: Due to the coverage-guided feedback, kAFL quickly learned how to generate payloads to execute valid syscalls, and this led to the unexpected execution of user mode callbacks via the kernel within the fuzzing agent. We evaluated kAFL on the keyctl interface, which allows a user space program to store and manage various kinds of key material in the kernel. So far, eight bugs were reported and three of them were confirmed by the maintainers:• Linux: keyctl Null Pointer Dereference 5 (CVE-2016-8650 6 )• Linux: ext4 Memory Corruption 7• Linux: ext4 Error Handling 8• Windows: NTFS Div-by-Zero 9• macOS: HFS Div-by-Zero 10• macOS: HFS Assertion Fail 10• macOS: HFS Use-After-Free 10• macOS: APFS Memory Corruption 10 Red Hat has assigned a CVE number for the first reported security flaw, which triggers a null pointer deference and a partial memory corruption in the kernel ASN.1 parser if an RSA certificate with a zero exponent is presented. The last reported Linux vulnerability, which calls in the ext4 error handling routine panic() and hence results in a kernel panic, was at the time of writing not investigated any further. One example for high variance is the fact that on Debian 8 (initramfs), the multiprocessing configuration on average needed more time to find the crash than one process.TriforceAFL We used the JSON driver to compare kAFL and TriforceAFL with respect to execution speed and code coverage. However, the results where biased heavily in two ways: TriforceAFL did not manage to find a path that triggers the crash within 30 minutes (usually it takes approximately 2 hours), making it very hard to compare the code coverage of kAFL and TriforceAFL. We also compare raw execution performance instead of overall fuzzing performance, which is biased because of the execution of different paths, the sampling process for the non-determinism-filter, and various synchronization mechanisms. On the other hand, syzkaller would most likely generate a significantly higher code coverage even without any feedback since it knows how to generate valid syscalls and hence is able to trigger valid paths without any learning. In the final experiment (KVM-PT & PT decoder), we tested the whole pipeline including our own decoder and conversion to an AFL bitmap.During our benchmarks, an overhead between 1% -4% was measured empirically. To compare both decoder engines, a small Intel PT trace sample was generated by executing find / > /dev/null 2> /dev/null within a Linux VM (Linux debian 4.8.0-1-amd64) traced by KVM-PT. We sanitized the sample by removing anything but flow information packets (see Section 2.3) to avoid any influence of decoding large amount of execution information packets, since those are not considered by our PT decoder. Figure 9 illustrates the measured speedup of our PT decoder compared to ptxed.The figure also shows that our PT decoder easily outperforms the Intel decoder implementation, even if the PT decoder processes data for the very first time. Somewhere in the middle are so called gray-box fuzzers that will typically use some kind of feedback from the target (such as coverage information) to guide their search, without analyzing the logic of the target program itself. Both approaches have one very important drawback: It is a time-consuming task to use these tools.To improve the performance of black-box fuzzers, many techniques have been proposed. These addresses can be used to limit tracing to the activity of said drivers, which improves performance when only fuzzing individual drivers.None of these functions are necessary and only improve performance in some cases. Consequently, the Intel PT software decoder does not only require control flow information to reconstruct the control flow but also needs the program that was executed during tracing. To bypass this limitation, the decoder requires information about all modifications applied to the program instead of an ordinary memory dump or the executable file. It should be noted though that fuzzing kernel JIT code is a very interesting topic since kernel JIT components, such as the BPF JIT in Linux, have often been part of serious vulnerabilities.Multibyte Compares.