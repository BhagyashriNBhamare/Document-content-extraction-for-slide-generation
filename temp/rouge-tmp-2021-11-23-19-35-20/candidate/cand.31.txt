Many state-of-art solutions focus on runtime detection, requiring abundant inputs to explore program paths in order to reach a high code coverage and luckily trigger security violations. But attackers could utilize techniques like heap spray [16] and heap fengshui [43] to arrange the heap layout and reliably launch attacks, making heap overflow a realistic threat.Several solutions are proposed to protect heap overflow from being exploited, e.g., Diehard [4], Dieharder [34], Heaptherapy [52] and HeapSentry [33]. For example, when analyzing a known vulnerability CVE-2014CVE- -1761 in Microsoft Word with our tool HOTracer, we found two new heap overflows, in the exact same program path which we believe many researchers have analyzed many times. It shows that, even for a vulnerable path in the spotlight, online solutions could not guarantee to find out all potential vulnerabilities in it.On the other hand, offline analysis solutions could explore each program path thoroughly and discover potential heap vulnerabilities in a more proactive way, e.g., by reasoning about the relationship between program inputs and candidate vulnerable code locations. However, neither of these solutions accurately model the root cause of heap overflow, and thus will miss many heap overflow vulnerabilities.We point out that the root cause of heap overflow vulnerabilities is not the controllability of either memory allocation or memory access, but the spatial inconsistency between heap allocation and heap access operations. If either one is controllable (i.e., tainted or affected by inputs), HOTracer reasons about the path conditions and spatial inconsistency to generate a PoC (i.e., proofof-concept) input for the potential vulnerability.In this way, our solution could discover potential vulnerabilities that may be missed by existing online and offline solutions. HOTracer reduces the number of pairs by promoting lowlevel heap access instructions into high-level heap access operations, and prioritizes pairs to explore pairs that are more likely to be vulnerable.Finally, it is challenging to generate concrete inputs to trigger the potential vulnerability in a specific heap operation pair, especially in large real-world applications, due to the program trace size and constraint complexity. As shown in Figure 1, HOTracer could be used to triage vulnerabilities in crashes (or security violations) generated by online dynamic analysis tools (e.g., fuzzers), or even further explore the same path to discover vulnerabilities that may be missed.In summary, we have made the following contributions. It could discover heap vulnerabilities that are missed by online dynamic analysis tools (e.g., AFL and AddressSanitizer), because the testcases may not cause any runtime crashes or security violations at all, or only trigger shallow ones. It could also help clarifying the root cause (i.e., determine if it is a heap vulnerability or not) of a crash or violation.that are hard to detect and prone to miss in benign traces, and able to help identifying the root cause of crashes and security violations in suspicious traces. Even if it is not affected by inputs, e.g., developers use a constant number (e.g., 1020 at line 3) that seems to be big enough as the allocation size, the program may be still vulnerable to heap overflow.Although experienced developers may sanitize inputs before using (e.g., line 5) to stop potential vulnerabilities, it is error-prone to implement such checks. If user inputs could affect either heap allocation or heap access along this execution trace, they could change the spatial attributes of heap objects to satisfy Equation S, cause spatial inconsistency between heap allocation and heap access, and thus trigger a heap overflow vulnerability.We illustrate this possibility using Figure 3. To achieve this goal, we analyze programs' execution traces offline, and explore potential vulnerable states along the binary traces.Furthermore, to make the solution efficient and practical, we select representative testcases to generate a limited number of traces, perform spot checks on a small number of heap <allocation, access> operation pairs that are more likely to be vulnerable, and concretize values in path constraints and vulnerability constraints to speed up the constraint resolving. Based on these attributes, it builds the vulnerability conditions using Equation S for each pair of heap <allocation, access> operations.Finally, it solves the vulnerability conditions, along with the path constraints, to check potential heap overflows, and generates concrete inputs to prove the existence of them.Following this process, we figure out there are many challenges when making it work for real world applications, especially the usability and efficiency of this solution. Based on the trivial knowledge that different subtypes of inputs will exercise different program paths, we could get a set of representative execution traces.For unknown file types, we use fuzzers to generate a set of seed inputs, and distill the inputs to a minimum set which covers most code blocks. It affects the memory allocation in several ways.B1 Custom allocators have to use standard allocation interfaces to get memory from system when the allocator is called for the first time, or when the internal reserved memory pool is drained.B2 Allocators usually keep different memory pools for different allocation sizes to improve allocation efficiency and ease the burden of boundary check.B3 Allocators usually pad extra bytes at the end of objects to make objects aligned (with 4 bytes, 8 bytes etc.). Furthermore, we will remove wrapper functions from the set.It is worth noting that, identifying heap allocators in this way may generate false positives and thus increase the number of candidate pairs. So it will not prevent us from discovering potential heap vulnerabilities.It is an open challenge to accurately identify all heap allocators in binary programs. As a result, it is crucial to reduce the number of candidate pairs.We first abstract low level heap access instructions to high level operations to reduce the number of heap access operations, and then prioritize candidate pairs based on the likelihood of vulnerability in each pair. So the number of pairs grows rapidly in this way.Obviously, we should treat each one of such loops and sequences of memory access as one heap access if possible, in order to reduce the number of heap operation pairs without missing any potential vulnerabilities.On the other hand, it is also helpful to recover highlevel heap access operations for other purposes. We treat each occurrence of these loops in the trace as one heap access operation, but not any instruction within these loops.D2 We then treat each sequence of heap access instructions that corresponds to one REP instruction in the trace as a single heap access operation.D3 We finally treat every remaining instruction in the trace that accessed the heap as a heap access operation. Basically, we will collect the path constraint and the vulnerability condition for each candidate pair, and then query the constraint solver to generate PoC if possible.However, the program path and vulnerability condition constraints may be too complex for solvers to resolve. Our dynamic analysis framework implements a recordreplay mechanism similar to PANDA [18], based on the open-source whole-system hardware emulator QEMU, to improve the performance of recording.It takes a snapshot of the system before execution, and records changes to the CPU state and memory in a changelog file during the execution. For example, the return value of strlen control-depends on the input string, i.e., whether the input character equals to '\0' or not.Classical dynamic taint analysis solutions usually will not propagate taint information for control dependencies [39], due to the concern of taint propagation efficiency. As discussed in Section 3.5, HOTracer will only collect path constraints related to bytes used in the vulnerability conditions, and use concrete values for other input bytes used in the path constraints, to simplify the path constraints.We also notice that, programs may read the same input bytes multiple times via multiple functions. Since our vulnerability conditions only consider heap overflow, the concrete inputs generated by constraint solvers (called candidate PoC inputs) may not trigger crashes or other severe consequences.On the other hand, inputs that could trigger crash would make further analysis easier, e.g., debugging and bug fixing. However, HOTracer could validate these two vulnerabilities if given the correct PoC samples.More interestingly, when analyzing the program path (with a benign input) of the vulnerability CVE-2014-1761 in Microsoft Word 2010, HOTracer found two new vulnerabilities, which even affect the latest version of Microsoft Word. Five other vendors including Microsoft, Apple, and OpenOffice are still reviewing the issues.In summary, vendors are willing to fix security bugs in their products. In other words, there are too many vulnerabilities (or bugs) in daily applications, calling for solutions like HOTracer to help.Due to the time limit, we only manually checked 10 of these vulnerabilities to see whether they are exploitable. Table 4 shows the accuracy of our recognition algorithms.On the left of the table, it shows some statistics of some sample traces that are analyzed, including the snapshot and record size, as well as the record and replay time.On the right of the table, it shows the time cost to identify these heap allocators. So the number of heap operation pairs equals to the heap access operations.As shown in the table, there are too many low-level heap access instructions (i.e., type-D3 access in the table). As our prototype worked in Windows 7, we chose two representative fuzzers on Windows, i.e., WinAFL 3 and Radamsa 4 , to test vulnerable softwares with the same seed inputs.WinAFL is a fork of AFL on Windows, which relies on dynamic instrumentation using DynamoRIO [5] to measure and extract target coverage. Our solution HOTracer could be used to triage the root cause of crashes, and help debugging and fixing bugs which are time-consuming and important to vendors. For example, the access size in vulnerability CVE-2014-1761 is related to lfolevel, but its allocation size is related to another field listoverridecount.A more common case is that, the access size and allocation size are relevant to the same input bytes, but they mismatch due to several causes.First, the allocation size may get smaller than expected if there are integer overflows, e.g., two new vulnerabilities we found in QQPlayer and PotPlayer. Online dynamic analysis solutions usually first instrument target applications with metadata before execution, and then track the metadata and check security violations during the execution.Online detection: AddressSanitizer [40] is one of the most effective solutions to detect heap (and other) vulnerabilities at runtime. And VUzzer enhances the efficiency of general-purpose fuzzers with a smart mutation feedback loop based on applications' control-and data-flow features.Like other online detection solutions, fuzzers also rely on input testcases to trigger vulnerabilities at runtime. Comparing to online dynamic analysis, this type of solutions could perform in-depth analysis for a single dynamic execution, and explore potential vulnerabilities.DIODE [41] targets heap allocation sites in a trace, and extracts and solves integer overflow conditions for allocation sizes to discover potential IO2BO (a special kind of heap overflow) vulnerabilities. But they are over-qualified for our target, i.e., identifying loops used for heap access operations.Recognizing structures in binary is also helpful for our work. Related work (e.g., CryptoHunt [50]) on program semantics comprehension could help HOTracer, e.g., to handle more complex loops.Some heap vulnerabilities may not crash target programs even if they are triggered. Then we prioritize pairs that have access operations of type D1.Second, we will prioritize heap operation pairs depending on the ability of attackers, i.e., how well they could affect the heap operations. We leave it as a future work.Aligot [8] proposes a solution to identify loops in execution traces, and uses it to identify cryptographic functions in obfuscated binary programs. We model heap overflows as spatial inconsistencies between heap allocation and heap access operations, and perform an in-depth offline analysis on representative program execution traces to identify heap overflows. There are a lot of sensitive data stored in the heap, including heap management metadata associated with heap objects (e.g., size attributes, and linked list pointers), and sensitive pointers within heap objects (e.g., pointers for virtual function calls). Our solution could work fine as long as the inputs could exercise any heap allocation and heap access operations.On the other hand, a combination of existing offline solutions, e.g., DIODE and Dowser, seems to be able to achieve the same goal as HOTracer. More specifically, for a heap access via (ptr, o f f set ptr , size access ) and target object (ob j, size ob j ), similar to related work SoftBound [30], we conclude that there is an underflow vulnerability if:ptr + o f f set ptr + size access < ob j.Given that heap pointers ptr always refer to base objects' address obj, it equals to:o f f set ptr + size access < 0. We studied some popular custom allocators (e.g., Jemalloc, Tcmalloc, MMgc), and figured out their work flows share the same pattern as shown in Figure 5, and they have the following features.First, the most important feature is the return values of memory allocators must be heap pointers.A. This provenance will be propagated along the program trace, e.g., via pointer arithmetic operations, to other pointers. It is worth noting that, objects' addresses (i.e., pointers' provenances) are usually lower than a specific value on a given platform, so −provenance EBX is different from any normal taint attribute. What's different is that, we use the position of input bytes as taint attributes, and propagate these attributes along the trace.However, sometimes the inputs will not directly affect values used in heap access or