While a core dump carries a large amount of information , it barely serves as informative debugging aids in locating software faults because it carries information that indicates only a partial chronology of how program reached a crash site. Even though it carries execution history that allows one to fully reconstruct the control flow that a crashing program followed -without an automated tool to eliminate those instructions not pertaining to the failure -software developers and security analysts still need to manually examine each instruction in an artifact and identify those that actually contribute to the crash.To address this problem, recent research [22] has proposed a technical approach to identify program statements that pertain to a software failure. Given that the technique proposed in [22] needs to track data flow using hardware watchpoints in a collaborative manner, this technique is also less suitable to the situation where program crashes cannot be easily collected in a crowd-sourcing manner.In this work, we design and develop POMP, a new automated tool that analyzes a post-crash artifact and pinpoints statements pertaining to the crash. Since POMP relies only upon a post-crash artifact, it is non-intrusive to normal operations and, more importantly, generally applicable to any settings even though crash report collection cannot be performed in a cooperative manner. â€¢ We demonstrated the effectiveness of POMP in facilitating software debugging by using various postcrash artifacts attributable to 31 distinct real world security vulnerabilities.The rest of this paper is organized as follows. As a result, we exclude the program crashes that do not incur the unexpected termination of a running process (e.g., Java program crashes). Up to and including Linux 2.2, the default action for CPU time limit exceeded, for example, is to terminate the process without a post-crash artifact [3]. We believe this is a realistic assumption because a software defect is typically close to a crash site [19,27,39] and 2 While Intel PT does not log unconditional jumps and linear code, a full execution trace can be easily reconstructed from the execution trace enclosed in a post-crash artifact. To diagnose the root cause with backward analysis for the program crash shown in Figure 1, a software developer or security analyst typically follows through the execution trace reversely and examines how the bad value in register eax was passed to the crash site (i. e., instruction A20 shown in Figure 1). As a result, we can restore the value in register eax and thus complete the inverse operation for instruction A19.While the backward and forward analysis provides security analysts with an effective method to construct data Register eax 0x0002 0x0002 0x0000 0x0000 0x0000 0x0000 0xff1c 0xff1c 0xff18 ebp 0xff28 0xff28 0xff28 0xff28 0xff28 0xff08 0xff08 0xff08 0xff08 esp 0xff14 0xff14 0xff14 0xff10 0xff0c 0xff08 0xff08 0xff08 0xff08Memory Address 0xff1c 0x0002 0x0002 0x0002 0x0002 0x0002 0x0002 0x0002 test test 0xff18 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0xff14 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0xff10 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff180xff0c A18 A18 A18 A18 A18 A18 A18 A18 A18 0xff080xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28Execution trace flows, this is not sufficient for completing program failure diagnosis. When backward analysis passes through instruction A15 and reaches instruction A14, through forward analysis, a security analyst can quickly discover that the value in register eax after the execution of A14 is dependent upon both instruction A12 and A13. As we have shown in the section above, it is tedious and tough for software developers (or security analysts) to dig through the trace and pinpoint the root cause of a program crash. Since a post-crash artifact has already carried the control flow that a crashing program followed, the main focus is to reconstruct the data flow from the post-crash artifact that a crashing program left behind.To reconstruct the data flow pertaining to a program failure, POMP introduces a reverse execution mechanism to restore the memory footprints of a crashing program. Not only does it automate the forward-and-backward analysis, making the inverse operations for instructions effortless, but also automatically verifies memory aliases and ensures an inverse operation does not introduce errors or uncertainty.With this reverse execution mechanism, POMP can easily restore the machine states prior to the execution of each instruction. Since instruction A17 can be treated as mov eip, [esp] and then add esp, 0x4, and instruction A16 is equivalent to mov ebp, [esp] and then add esp, 0x4, reverse execution can further restore memory footprints prior to their execution by following the scheme of how it handles mov and arithmetical instructions above. In Figure 1, we illustrate the memory footprints prior to the execution of both instructions.Recall that performing an inverse operation for instruction A15, forward and backward analysis cannot determine whether the use of [ebp+0x8] specified in instruction A12 can reach the site prior to the execution of instruction A15 because [eax] in A14 and [ebp+0x8] in A12 might just be different symbolic names that access data in the same memory location.To address this issue, one instinctive reaction is to use the value-set analysis algorithm proposed in [11]. After the memory footprint recovery at T 14 , reverse execution can further restore earlier memory footprints using the scheme we discussed above, and Figure 1 illustrates part of these memory footprints.With memory footprints recovered, software developers and security analysts can easily derive the correspond- ing data flow and thus pinpoint instructions that truly contribute to a crash. The reason behind the maintenance of these constraints is to be able to perform memory alias verification discussed in the following section.In the process of resolving variables and propagating definitions (or uses), our algorithm typically encounters a situation where an instruction attempts to assign a value to a variable represented by a memory region but the address of that region cannot be resolved by using the information on the chain. For example, by assuming [eax] is not aliased to [ebp+0x8], our algorithm extracts inequility constraint eax =ebp+0x8 and releases the block shown in Figure 3, making A12 use: [ebp+0x8] further propagated.During the propagation, our algorithm walks through each of the nodes on the chain and examines if the newly propagated data flow results in conflicts. The reason is that a new hypothesis test may help remove an additional intervening tag conservatively placed at the first step, and thus provides the holding test with more informative evidence to reject hypotheses accordingly.To illustrate this, we take a simple example shown in Figure 4. In the worse case, when performing execution reversely, the inverse operation of each instruction may require alias verification and each verification may require further alias examination. Thus, our reverse execution can simply ignore the inverse operations for those system calls.For system calls that potentially influence the memory footprints of a crashing program, our reverse execution handles them as follows.In general, a system call can only influence memory footprints if it manipulates register values stored by the crashing program or touches the memory region in user space. For system calls that may influence a register holding a value for a crashing program, our algorithm simply introduces a definition on the use-define chain. This is due to the fact that the starting address and size are typically indicated by arguments which are handled by those instructions prior to the call. POMP treats register eax as a sink in that the program crash results from retrieving an invalid instruction from the address held by register eax.With a sink identified, POMP taints the sink and performs taint propagation backward. With sink eax serving as the initial taint variable, POMP selects A19 def:eax=[ebp-0xc] on the chain because this definition can reach taint variable eax without intervention.From the definition identified, POMP parses that definition and passes the taint to new variables. For example, given a taint variable [R 0 ] and a definition def: [R 1 ] with R 1 unknown, POMP cannot determine whether R 0 and R 1 share the same value and POMP should pass the taint to variable [R 1 ]. Considering the interrupt may have a skid, resulting in a potential loss in PT packets, we further allocated a 2 MB physical memory buffer to hold those packets that might be potentially discarded. For each program crash shown in Table 2, we performed manual analysis with the goal of finding out the minimum set of instructions that truly contribute to that program Table 2: The list of program crashes resulting from various vulnerabilities. The focuses of this comparison include x examining whether the root cause of that crash is enclosed in the instruction set POMP automatically identified, y investigating whether the output of POMP covers the minimum instruction set that we manually tracked down, and z exploring if POMP could significantly prune the execution trace that software developers (or security analysts) have to manually examine.In order to evaluate the efficiency of POMP, we recorded the time it took when spotting the instructions that truly pertain to each program crash. As such, we generally observe more instructions over-tainted for those test cases, where POMP needs to reversely execute more instructions in order to cover the root causes of their failures.As we discuss in Section 4, ideally, POMP can employ a recursive hypothesis test to perform inverse operations for instructions that carry unknown memory access. Since both the size of the data chunk and the address of the memory are specified in registers, which reverse execution fails to restore, POMP treats sys_read as a "super" intervening tag that blocks the propagation of many definitions, making the output of POMP less informative to failure diagnosis.Different from aireplay-ng, the failure for 0verkill results from an insufficient PT log. Depending on how the solver performs on constraint sets corresponding to multiple test runs, the technique proposed automatically determines where to instrument the code to save intermediate values and facilitate reverse execution.Given that state saving requires extra memory space and program instrumentation results in a slower forward execution, recent research proposes to employ a core dump to facilitate reverse execution. Since the effectiveness of these techniques highly relies upon the integrity of a core dump, and exploiting vulnerabilities like buffer overflow and dangling pointers corrupts memory information, they may fail to perform reverse execution correctly when memory corruption occurs.Different from the prior research works discussed above, the reverse execution technique introduced in this paper follows a completely different design principle, and thus it provides many advantages. Rather, our approach identifies the root cause of software failures by reversely executing program and reconstructing memory footprints prior to the crash.Considering the low cost of capturing core dumps, prior studies also proposed to use core dumps to analyze the root cause of software failures. In our work, we introduce a different technical approach which can perform analysis at the binary level without the participation of other parties.In recent research, Xu et al. [36] introduced CREDAL, an automatic tool that employs the source code of a crashing program to enhance core dump analysis and turns a core dump to an informative aid in tracking down memory corruption vulnerabilities. In practice, this assumption however may not hold, and the information held in a post-crash artifact may not be sufficient and even misleading for root cause diagnosis.While this multi-thread issue indeed limits the capability of a security analyst using POMP to pinpoint the root cause of a program crash, this does not mean the failure of POMP nor significantly downgrades the utility of POMP because of the following. For programs assembled with this JIT functionality (e.g., JavaScript engine), POMP is less likely to be effective, especially when a post-crash artifact fails to capture the JIT native code mapped into memory.To make POMP handle programs in this type, in the future, we will augment POMP with the capability of tracing and logging native code generated at the run time. Note that this extension does not require any re-engineering of reverse execution and backward taint analysis because the limitation to JIT native code also results from incomplete execution tracing (i. e., failing to reconstruct all the instructions executed prior to a program crash).