Counter-cryptanalysis, the concept of using cryptana-lytic techniques to detect cryptanalytic attacks, was introduced at CRYPTO 2013 [23] with a hash collision detection algorithm. With the demonstration of a SHA-1 collision, the algorithm presented here has been deployed by Git, GitHub, Google Drive, Gmail, Microsoft OneDrive and others, showing the effectiveness of this technique. Industry's previous de facto choices MD5 and SHA-1 are both based on the Merkle-Damgård construction [18,6] that iterates a compression function that updates a fixed-size internal state called the chaining value (CV) with fixed-size pieces of the input message.In 2004, MD5 was completely broken and real collisions were presented by Wang et al.[33, 35]. In principle the collision attack detection provides strong guarantees: it guarantees detection of any variant collision attack in each tested attack class, whereas the chance of false positives is as negligible as the chance of finding a random second preimage. Our improved implementation is also being used by Google Drive, Gmail and Microsoft OneDrive.Based on the latest results for the complexity of finding a SHA-1 collision, the projected cost of such an attack ranges from US$ 75 K and US$ 120 K by renting low-cost computing resources on Amazon EC2 [22,26], which is significantly lower than Schneier's 2012 estimates. E.g., it excludes retracted CA certificates that are still supported by older systems (and CA certificates have indeed been retracted to circumvent CABForum regulations and continue to issue new SHA-1 certificates 1 to serve to these older systems), and certificates for other TLS applications including up to 10% of credit card payment systems [31]. Even if systems are moved from using SHA-1, verification of signatures of SHA-1 digests may remain necessary for existing signatures, such as deployed binaries or not yet expired certificates.An example is GPG/PGP email and attachment signatures where SHA-1-based signatures remain common. It is infeasible that all deployed Git repositories will be migrated off of SHA-1, but since SHA-1 collisions are now feasible Git might be at risk. As one potentially scenario, consider an attacker that has committed one file of a colliding pair 2 to a Git repository under his control, in which case he could then selectively deliver either contents to targeted users, without the users noticing by looking at Git hashes or verifying signatures on the repository. Extensive studies for message block differences that allow high-probability differential paths for both MD5 and SHA-1 strongly confirm these properties.Collision detection detects near-collision attacks against MD5's or SHA-1's compression function for a given message by 'jumping' from the current compression function evaluation CV out = Compress(CV in , B) to a presumed related compression function evaluation CV out = Compress(CV in , B ). Namely, those differences directly imply values for message block B = B + δ B and state WS i = WS i + δWS i at step i, which are sufficient to compute the related input chaining value CV in and thereby also the related output chaining value CV out . If no collision attack was used to construct B then finding CV out = CV out means that we have found a second pre-image for the compression function by chance. With the 223 known attack classes for MD5, collision detection costs a factor 224 more than MD5. Otherwise, adversaries aware of counter-cryptanalysis could easily bypass this improved collision detection with a carefully chosen variant attack.We provide a formal framework of unavoidable conditions for collision attacks on MD5-like compression functions that can be used to show that indeed conditions are unavoidable, and we show how they can be used to speed up collision detection.Furthermore, we present a conjecture that SHA-1 collision attacks based on a disturbance vector may not deviate from the prescribed local collisions for steps 35 up to 65 to remain feasible. Moreover, we show how we can exploit a significant overlap of unavoidable conditions between DVs that allows a more efficient checking of unavoidable bit conditions for many disturbance vectors simultaneously.Collision detection uses recompressions, i.e., evaluations of the compression function starting from an intermediate state to uniquely determine the input and output chaining value for a given message block. Unavoidable bit conditions allow a significant improvement to collision detection by very quickly checking the unavoidable bit conditions per DV and only performing a recompression when all unavoidable bit conditions for that DV are satisfied.We have implemented the improved SHA-1 collision detection using unavoidable conditions which checks 32 DVs (twice as many as previous work). The correctness of our implementation follows from easily verified attack-class independent code, automatically generated tables for each attack class from a very short identification, and testing its correctness against the known SHA-1 collision.After the demonstration of a SHA-1 collision, the open source implementation of our algorithms was included in Git. As well as reducing cost from computations over two compression function evaluations to only one compression function evaluation, such conditions allows more effective use of early stop techniques and advanced message modification techniques.We define unavoidable conditions as conditions that are necessary for all feasible attacks in a certain attack class. For N, M ∈ N + , let H : {0, 1} N × {0, 1} M → {0, 1}N be a compression function, then a class of attacks C against H is a set of (randomized) algorithms A that produce atuple (CV 1 , B 1 ,CV 2 , B 2 ) ∈ {0, 1} N × {0, 1} M × {0, 1} N × {0, 1} M as output.We model an unavoidable condition for an attack class as a predicate over pairs (CV, B) of a chaining value and message block. For N, M ∈ N + , let H : {0, 1} N × {0, 1} M → {0, 1} N be a compression function and C be an attack class against H. Let u : {0, 1} N × {0, 1} M → { f alse,true} be a non-trivial predicate over compression function inputs. A local collision over 6 steps for SHA-0 and SHA-1 consists of a disturbance δ Q t+1 = 2 b created in some step t by a message word bit difference δW t = 2 b . We denote by (DW t ) 79 t=0 the message word bit differences without sign (i.e., DW t = W t ⊕W t ) for a disturbance vector (DV t ) 79 t=0 : Note that for each step one uses differences δW t instead of DW t . Over steps [35,65) it is unavoidable to use the DV-prescribed local collisions: deviating from the DV over these steps will result in an avalanche that will significantly increase the attack complexity.As published collision attacks only deviate from local collisions in the first 20 steps or the last 5 steps (75 up to 79) for reasons already mentioned, the current state of art solidly supports our conjecture with a safe margin. Looking at SHA-1 attacks, these message bit relations are all of the formW i [a] ⊕W j [b] = c or W i[a] = c, hence this specific form of unavoidable conditions can be checked very efficiently. Therefore if an expanded message does not satisfy all UBCs then this message cannot be a solution for any possible differential path over steps [35,65) based on this DV.To efficiently compute UBCs we will use techniques introduced in [24] that allow efficient computations on large classes of differential paths that are otherwise not possible. A differential path P over steps t ∈ [35, 65) is given asP = ((∆Q t ) 64+1 t=35−4 , (∆F t ) 64 t=35 , (δW t ) 64 t=35 ), with correct differential steps for t ∈ [35, 65):σ (∆Q t+1 ) = σ (RL(∆Q t , 5))+σ (RL(∆Q t−4 , 30)) + σ (∆F t ) + δW t . So we use its 'row reduced form' which results entirely in equations over 2 message bits of the formW i [a] ⊕W j [b] = c.For our improved SHA-1 collision detection implementation we have selected the 32 disturbance vectors with lowest estimated cost as in [24]. As each UBC is a linear equation, the set of UBCs per DV can be further manipulated for our purposes using simple linear operation.In the previous section we analyzed 32 disturbance vectors and found 7 to 15 UBCs per DV with a total of 373 UBCs. Note that for each DV the new set of UBCs remains equivalent to the original set of UBCs.To minimize the overall amount of distinct UBCs we use a greedy selection algorithm to rebuild the set of UBCs per DV. More specifically, for each DV it first generates a list of candidate UBCs by taking all linear combinations of the original set of UBCs and removes all candidates that are a linear combination of the current set of UBCs and thus that are already covered so far. Furthermore, in the directory 'tools' we provide the following:• the original listing of UBCs per DV (directory 'data/3565');• an example partial collision for SHA-1 (file 'test/sha1 reducedsha coll.bin');• the greedy selection algorithm from Sect. 4.7 that optimizes the UBC sets and outputs optimized code (directory 'parse bitrel'), see Sect. 5.1;• a program that verifies the optimized C code with optimized UBC sets against manually-verifiable C code (directory 'ubc check test'), see Sect. 5.2;The collision detecting SHA-1 implementation, including the SHA-1 compression function as well as the collision detection logic and UBC checks, has been heavily optimized to be competitive with the performance of the prior implementation of SHA-1 in Git. For example, the following clause is one of the clauses generated by the parse_bitrel:C &= ((((W[46]>>4)^(W[49]>>29))&1)-1) | ~( DV_I_46_0_bit | DV_I_48_0_bit | DV_I_50_0_bit | DV_I_52_0_bit | DV_II_50_0_bit | DV_II_55_0_bit );The ubc_check function thus consists of initializing the variable C and statements for each unique UBC to update C as described above. Note that at the time of these experiments Raspbian Jessie runs in 32 bit mode only, even though this particular processor model can run in both 32 and 64 bit modes.The performance numbers below vary a bit between different compiler and processor technologies due to different available processor instructions and different compiler optimizations. This table shows that while adding the straight forward collision detection code increases the time of a SHA-1 computation by around 30 to 40 times, using the UBC check optimizations allows a SHA-1 computation with collision detection to be run in about 1.6× the time. More protection against signature forgeries is greatly warranted and our improved SHA-1 collision detection enables protection against digital signature forgeries at a very low cost.As SHA-1 is practically broken, yet SHA-1-based signatures are still used at large and are also widely supported (at least for verification), our improved SHA-1 collision detection enables protection against digital signature forgeries at a very low cost.