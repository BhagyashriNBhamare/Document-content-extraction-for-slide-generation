In response to these challenges, recent research [11,41,48] and industry efforts [1,2,35,43] developed Trusted Execution Environments (TEEs) that feature an alternative, non-hierarchical protection model for isolated application compartments called enclaves. Besides strong memory isolation, TEEs typically offer an attestation primitive that allows local or remote stakeholders to cryptographically verify at runtime that a specific enclave has been loaded on a genuine (and hence presumed to be secure) TEE processor.With the announcement of Intel's Software Guard eXtensions (SGX) [2,27,43] in 2013, hardware-enforced TEE isolation and attestation guarantees are now available on off-the-shelf x86 processors. At its core, Foreshadow abuses the same processor vulnerability as the recently announced Meltdown [40] attack, i.e., a delicate race condition in the CPU's access control logic that allows an attacker to use the results of unauthorized memory accesses in transient out-of-order instructions before they are rolled back. Importantly, however, whereas Meltdown targets traditional hierarchical protection domains, Foreshadow considers a very different attacker model where the adversary's goal is not to read kernel memory from user space, but to compromise state-of-the-art intra-address space enclave protection domains that are not covered by recently deployed kernel page table isolation defenses [19]. Moreover, despite SGX's ambition to defend against strong kernel-level adversaries, present SGX processors cannot even safeguard enclave secrets in the presence of unprivileged user space attackers.All previously known attacks against Intel SGX rely on application-specific information leakage from either sidechannels [30,39,45,51,57,58,60] or software vulnerabilities [38,59]. This separation of responsibilities ensures that enclave-private memory can never be accessed from outside, while untrusted system software remains in charge of enclave memory management (i.e., allocation, eviction, and mapping of pages). Any attempt to directly access private pages from outside the enclave, on the other hand, results in abort page semantics: reads return the value -1 and writes are ignored.SGX furthermore protects enclaves against motivated adversaries that exploit Rowhammer DRAM bugs, or resort to physical cold boot attacks. Specifically, Intel provides (i) a launch enclave that gets to decide which other enclaves can be run on the platform, (ii) a provisioning enclave to initially supply the long-term platform attestation key, and (iii) a quoting enclave that uses the asymmetric platform attestation key to sign local attestation reports for a remote stakeholder.To regulate enclave development, Intel SGX distinguishes debug and production enclaves at creation time. In case of Intel SGX, this may lead to an increased CPU security version number.Micro-operations furthermore enable superscalar processor optimization techniques stemming from a reduced instruction set philosophy. To maximize the use of available execution units, simultaneous multithreading (Intel HyperThreading) technology can furthermore interleave the execution of multiple independent instruction streams from different logical processors executing on the same physical CPU core. In multi-way, set-associative caches, a cache line is located by first using the lower bits of the (physical) memory address to locate the corresponding cache set, and thereafter using a tag to uniquely identify the desired cache line within that set.Since CPU caches introduce a measurable timing difference for DRAM memory accesses, they have been studied extensively in side-channel analysis research [16]. As such, Meltdown represents a critical race condition inside the CPU, which enables an attacker to transiently execute instructions that access unauthorized memory locations.Essentially, transient execution allows an attacker to perform secret-dependent computations whose direct architectural effects are later discarded. However, as explained below and further explored in Appendix A, targeting enclaved execution also presents substantial challenges, for SGX's modified memory access and non-terminating fault semantics reflect extensive microarchitectural changes that affect transient execution.We first present our basic approach for reading cached enclave secrets from the unprivileged host process, and thereafter elaborate on various optimization techniques to increase the bandwidth and success rate of our attack for unprivileged as well as root adversaries. As part of the attack preparation, the untrusted enclave host application should first allocate an "oracle buffer" 1 of 256 slots, each measuring 4 KiB in size (in order to avoid false positives from unintentionally activating the processor's cache line prefetcher [26,40]). Note that, while Meltdown has reportedly been successfully applied to read uncached kernel data directly from DRAM, Intel's official analysis report clarifies that "on some implementations such a speculative operation will only pass data on to subsequent operations if the data is resident in the lowest level data cache (L1)" [29]. We furthermore provide experimental evidence in Appendix A, showing that Foreshadow can indeed transiently compute on kernel data in the L2 cache, but decisively not on enclave secrets residing in the L2 cache.Regarding Intel SGX's hardware-level memory encryption [21], it should be noted that the MEE security perimeter encompasses the processor package, including the entire CPU cache hierarchy. As such, in the absence of an exception, the race condition does not apply and any (transient) instructions following the rogue data fetch will never see the actual enclave secret, but rather the abort page value.Foreshadow overcomes this challenge by taking advantage of previous research results on page table-based enclaved execution attacks [58,60]. In our running example, we proceed by revoking 3 all access permissions to the enclave page we wish to read: 1 mprotect( secret_ptr &~0xfff, 0x1000, PROT_NONE );We verified that the above mprotect system call simply clears the "present" bit in the corresponding page table entry, such that any access to this page now (eventually) leads to a fault. However, the transient instructions at Lines 6-7 will still be executed and compute the secret-dependent location of a slot v in the oracle buffer before fetching it from memory.Phase III: Receiving the Secret. The basic Foreshadow attack of the previous section leaks sensitive information while only leveraging the capabilities of a conventional user space attacker. Unfortunately, we found that the mprotect system call exerts pressure on the processor's cache and may cause the enclave secret to be evicted from the L1 cache.We propose an inventive "page aliasing" technique to avoid mprotect cache pollution for root adversaries. Fig- ure 3 shows how our malicious kernel driver establishes an additional virtual-to-physical mapping for the physical enclave location holding the secret. As caches on modern Intel CPUs are physically tagged [27], memory accesses via the original or alias pages end up in the exact same cache lines. While the transaction's write set is discarded, we did not notice any difference in the read set.That is, accessed oracle slots remain in the L1 cache.Note that, while readily available on many processors, TSX is by no means the only fault suppression mechanism that attackers could leverage. As a true hybrid between Spectre [36] and Meltdown [40], such a technique would deliberately mistrain the CPU's branch predictor to ensure that none of the instructions in Listing 1 are committed to the architecture, and hence no faults are raised.Keeping Secrets Warm (Root). That is, by transiently accessing the enclave secret each time before we reload an oracle slot, we ensure the cache line holding the secret data remains "warm" and is less likely to be evicted by the CPU's least recently used cache replacement policy. Likewise, since L1 and L2 caches are shared among logical processors, cache activity on one core might unintentionally evict enclave secrets on its sibling core.In order to limit such effects, root adversaries can pin the victim enclave process to a specific core, and offload interrupts as much as possible to another physical core.Dealing with Zero Bias. To counteract this zero bias, Foreshadow retries the transient execution Phase II multiple times when receiving 0x00 in Phase III, before decisively concluding the secret byte was indeed zero.Since Foreshadow's transient execution phase critically relies on the enclave data being in the L1 cache, we consistently receive 0x00 bytes from the moment a secret cache line was evicted from the L1 cache. Secrets might be explicitly overwritten, or evicted from the L1 cache by bringing in other data from other cache levels.To improve Foreshadow's temporal resolution, we therefore asynchronously exit the enclave after a secret in memory was brought into the L1 cache, and before it is later overwritten/evicted. Specifically, we found that the bandwidth for concurrently extracting secrets is severely restricted, since each Foreshadow round needs 256 time-consuming FLUSH+RELOAD measurements in order to transfer one byte from the microarchitectural state (Phase II) to the architectural state (Phase III). For this, untrusted operating systems can make use of the privileged ewb and eldu SGX instructions that respectively copy encrypted and integrityprotected 4 KiB enclave pages out of, and back into EPC.We observed that, when decrypting and verifying an encrypted enclave page, the eldu instruction loads the entire page as plaintext into the CPU's L1 cache. In addition, she may reduce cache pollution by pinning the victim thread to as specific logical core and offloading peripheral device interrupts to another core.The unprivileged adversary, on the other hand, is much more constrained and represents an attacker targeting a remote server. While these success rates are somewhat lower, they distinctly show that even much more restrained user-level adversaries can successfully attack SGX enclaves with an impressive success rate.It is crucial for the Foreshadow attack to succeed that the cache line holding the secret remains in the L1 cache. This shows that Foreshadow is substantially more powerful than previous enclaved execution attacks that rely on either side-channels or memory safety bugs.Note that, for maximum reliability, both our attacks against Intel's architectural launch and quoting enclaves assume the root adversary model, and apply all of the optimization techniques described in Section 3.2. A Message Authentication Code (MAC) over the token data furthermore safeguards integrity, such that EINITTOKENs can be freely passed around by untrusted software.As with local attestation (Section 2.1), the security of this scheme ultimately relies on a processor-level secret accessible to both LE and einit. More specifically, current LE implementations enforce that (i) either the enclave debug attribute is set or mrsigner is white-listed by Intel; and (ii) the enclave does not feature privileged, Intel-only attributes, such as access to the long-term platform provisioning key.Attack and Exploitation. LE now uses the launch key to compute 6 the required MAC, and immediately afterwards zeroes out 7 the key buffer.An attacker can get hold of the launch key by targeting either the short-lived tmp buffer, or the longer-lived key buffer. We observed a 100% success rate in practice; that is, our final (online) exploit extracts the full 128-bit key without noise, from a single LE run with only 13 page faults in total -without resorting to the single-stepping or eldu prefetching techniques of Sections 3.3 and 3.5. In an initial platform configuration phase A , Intel deploys a dedicated Provisioning Enclave (PE) to request an EPID private key, from here on referred to as the platform attestation key, from the remote Intel Provisioning Service. Upon receiving the attestation key, PE derives an author-based provisioning seal key in order to securely store B the long-term attestation key on untrusted storage. An attacker getting hold of QE's report key can make QE sign arbitrary enclave measurements, effectively turning QE into a signing oracle.Second, QE relies on SGX's sealing mechanism to securely store the asymmetric attestation key. That is, our exploit reliably extracts the full 128-bit report and provisioning seal keys from a single QE run suffering 14 page faults in total.We validated the correctness of the extracted keys by fabricating bogus local attestation reports, using a previously extracted QE report key, and successfully ordering the genuine Intel QE to sign them. All remotely provisioned secrets can now be intercepted, without even executing the victim enclave or requiring detailed knowledge of its internals -effectively rendering SGX-based DRM or privacy-preserving analytics [44,50] applications useless. Alarmingly, this allows us to use the platform attestation key extracted from our lab machine to forge anonymous attestations for enclaves running on remote platforms we don't even have code execution on. Our work shows, however, that Meltdown-type CPU vulnerabilities also apply to non-hierarchical intraaddress space isolation, as provided by modern Intel x86 SGX technology. Indeed, page table isolation mitigations are ruled out, for SGX explicitly distrusts the operating system kernel, and enclaves live within the address space of an untrusted host process.We want to emphasize that Foreshadow exploits a microarchitectural implementation bug, and does not in any way undermine the architectural design of Intel SGX and TEEs in general. The additional capabilities of a root-level attacker have furthermore been leveraged to construct instructiongranular enclave interrupt primitives [57], and to exploit side-channel leakage from x86 memory paging [58,60] and segmentation [22]. We contributed practical attacks against Intel's trusted architectural enclaves, essentially dismantling SGX's local and remote attestation guarantees as well.While, in the absence of a microcode patch, current SGX versions cannot maintain their hardware-level security guarantees, Foreshadow does assuredly not undermine the non-hierarchical protection model pursued by trusted execution environments, such as Intel SGX.1 void load_in_L2( uint64_t * secret ) { 2 asm volatile ( "mfence\n" ); enclave secrets to secondary cache levels or even to main memory. As edbgrd may inadvertently move enclave data to caches closer to the processor, we only perform this additional verification step after the actual Foreshadow attack attempt.We carefully benchmarked the access times for enclave secrets residing in L1, L2, and main memory. After Foreshadow's transient execution phase, a single oracle slot (the current guess) is reloaded to receive the output of the transient instruction sequence. Out of the 98,610 remaining attack attempts, none succeeded in speculatively loading a secret-dependent oracle buffer slot in the transient execution phase.To rule out the possibility that the transient instructions may need more attempts to elevate the enclave secret from the L2 to the L1 cache, we ran the same benchmark with 1,000 repeated transient executions before actually reloading the oracle buffer. When applying Foreshadow against kernel data, we could indeed trivially extract kernel secrets from the L2 cache without noticing a significant success rate drop.We conclude that both Meltdown and Foreshadow exploit a similar race condition vulnerability in the CPU's out-of-order pipeline behavior, but Intel SGX's abort page semantics apparently have a profound microarchitectural impact. We attribute this condition to SGX's microarchitectural implementation, for previous Meltdown-type exploits targeting hierarchical kernel memory, do not have such strict caching requirements.Placing Secrets at Specific Cache Levels. We rely on Intel's Transactional Synchronization eXtensions (TSX) to ensure that secrets only reside in the L2 and L3 cache levels, but not in L1. Execution is rolled back to Line 3 where from a programmer's perspective rtm_begin() returned âˆ’1 immediately.