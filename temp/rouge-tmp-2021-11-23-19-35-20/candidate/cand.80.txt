Software-based MMU emulation lies at the heart of out-of-VM live memory introspection, an important technique in the cloud setting that applications such as live forensics and intrusion detection depend on. Such an outof-VM introspection then faces the problem of replicating the guest's virtual address (VA) to host physical address (HPA) translation.Existing out-of-VM introspection systems [18,19,33,35] tackle the problem using a software-based address translation whereby the MMU's function is replaced by software. We stress that the cache mechanism does improve performance, however, at the cost of potential mapping and data inconsistency since the cached mappings and data could be stale.In fact, mapping consistency can not be assumed for an in-VM introspection scheme without trusting the guest kernel, even though the memory is introspected at native speed. al [25], hardware-assisted monitor systems such as Copilot [30] and KI-mon [26] are circumvented by using address translation redirection attacks which deceive the monitor into using a faked mapping.In this paper, we propose a novel mechanism to allow the introspection code in the monitor VM to access a target guest kernel's virtual address space at native speed and with mapping consistency, despite the kernel-level attacks from the target. Hence, the ImEE is more attractive to applications desiring strong security, faster response and high speed, for instance, critical data monitoring, virtual machine scanning, and live forensics.CAVEAT. In contrast, it is out of our scope to deal with the high-level issues like which virtual addresses or kernel objects to read and how to reuse the existing kernel code [19]. We expect that, with modest retrofitting, those VMI applications can harness the ImEE as a powerful guest access engine to achieve better performance and stronger security.ORGANIZATION. It is ill-suited for scenarios demanding quick responses such as live forensics and real-time I/O monitoring.The slow speed also affects the mapping consistency as the guest malware in the kernel may make transient changes to the page tables, rather than the data. Since walking the paging structures appears instant to the malware using the MMU, but not to the introspection software, the malware's attack on the page tables causes the VMI tool to use inconsistent information obtained from the paging structures.Caching techniques have been used in order to reduce the latency of guest accesses. It usually has a bulky code base since it has to fully emulate the MMU's behavior, such as supporting 32-bit and 64-bit paging structures as well as different modes and page sizes. The platform administrator runs VMI applications inside the monitor VM to introspect the live kernel states in the targets without modifying or suspending them.To avoid ambiguity, we use the "target" to refer to the virtual machine under introspection, and use "guest" with its hardware virtualization notion as in a "guest physical address" (GPA) which refers to the physical address a kernel uses inside a hardware-assisted virtual machine.Trust Model. The GPAs for the intended introspection are translated with the same mappings as in the target VM; the GPAs for the local usage (indicated by the dotted box in Figure 1) are mapped to the local physical pages via separated GPA-to-HPA mappings. Since the agent code and data are logically different from the target kernel, we need a way to properly split the GPA domain so that VAs for the local uses are not mapped to the target and VAs for introspection are not mapped to the agent memory.This challenge to divide the GPA domain is further complicated by two issues. For example, it is difficult to detect whether a VA for introspection is wrongly mapped to the local data (which could be induced by the target kernel inadvertently or willfully) because it does not violate the access permissions on the page table.Security Challenge. Although access permissions can be enforced via the GPA-to-HPA translation, the adversary can still redirect the memory reference at one page to another with the same permissions.A more subtle, yet important issue, is that the introspection blind spot, namely the set of virtual addresses in the target which are not reachable by the ImEE agent. Although the ImEE agent accesses the target memory at native speed, we aim to minimize the time for setting it up in order to maximize its capability of quickly responding to real-time events and/or adapting to a new introspection target (e.g., another thread in the target VM or even another target VM). In addition, it is also desirable to minimize the hypervisor's runtime involvement, because the incurred VM exit and VM entry events cost non-negligible CPU time.Besides the above three major challenges, there are other minor issues related to the runtime event handling, such as page faults and the target VM's EPT updates. Lastly, we describe the lifecycle of ImEE, focusing on the runtime issues such as transitions between sessions.The approach is to carefully concert system design, e.g., setting the ImEE's EPTs and software design (i.e. crafting the agent) so that the ImEE agent execution straddles between two virtual address spaces: one for the local usage and the other for accessing the target VM. To differentiate them from the target VM's physical memory, we name them as the ImEE frames.According to the CR3 content, the agent runs either in the local address space or the target address space, as depicted in Figure 4. All target frames accessible to the ImEE agent are set as read-only and nonexecutable in EPT T . table directory point to the same page table page which has one PTE points to the data frame and all other to the code frame.Target Address Space. Specifically, EPT T is populated with the GPA-to-HPA mappings from the target VM's EPT, except that all target frames are guarded by read-only and non-executable permissions. Therefore, it feasible to configure the hardware to regulate memory accesses so that any manipulation on the target GPT that attempts to redirect the introspection access to the ImEE memory is caught by a page fault exception.CAVEAT. For the same reason, the agent loads the target memory data into the ImEE floating-point registers as a cache (Line 12), before switching to the local address space to write to the data frame (Line 17).1: while TRUE do poll the interface lock; until the lock is off 6:Read the request from the data frame to general-purpose registers; Set interface lock; 22: end while The agent is loaded at P c in the local address space by the hypervisor. Because GPT L maps the entire VA range (except one page) to the code frame. The EPT settings of the ImEE and of the target ensure that the adversary can only launch sidechannel attacks, which is beyond the scope of our study.The only attack vectors exposed by the ImEE to the adversary are the shared GPT and the target physical memory which are fully controlled by the adversary. Hence, the attack on P c 's mapping, i.e. mapping P c to a page in GP t , is doomed to trigger an EPT violation exception. Specifically, there are three cases for the GP t which virtual page P t which is mapped to by the adversary. If GP t = GP d or GP t = GP c , the attack causes the agent to read from the ImEE frames; otherwise it causes an EPT page fault as the needed mapping is absent. It initializes EPT T as a copy of the entire EPT used for the target, and allocates a vCPU core for the ImEE. If it is the first session, the hypervisor may send out an Inter-Processor Interrupt (IPI) to the target VM, or induce an EPT violation to the target, or passively wait for a natural VM-exit (which is more stealthy). Since the agent code lies within one page, preserving the offset allows it to smoothly continue the interrupted execution.If the agent is in the local address space, the CR3 for the new target address space is saved in a register. The crux of the session transition is to minimize the hypervisor execution time as it hinders the ImEE's performance by holding the core.We use a lazy-allocation method to find GP c for the purpose of setting up EPT C . For common introspection tasks that focus on kernel data structures, the development requires a selection of the agent type, and a set of memory reading parameters including the starting virtual address, the number of bytes to read, and the offset(s) used for traversal. To the best of our knowledge, LibVMI is the only opensource tool that provides a comprehensive set of API for reading the memory of a VM. Lastly, we compare ImEE with LibVMI in a setting with multiple guest VMs.The hardware platform used to evaluate our implementation is a Dell OptiPlex 990 desktop computer with an Intel Core i7-2600 3.4GHz processor (supporting VTx) and 4GB DRAM. It takes a one-time cost of 97 Âµs to prepare the ImEE environment where the main tasks are to make a copy of the target guest EPT as EPT T , to set up GPT L and EPT L , and to allocate and setup the ImEE vCPU context. 1" perl benc h" bzip 2" gcc" mcf" gobm k" hmm er" sjen g" libqu antu m" h264 ref" omn etpp " asta r" xala ncbm k" Score& W/O"IntercepCon" W/"IntercepCon" To understand the impact of CR3 interception in reallife scenarios, we test it with three different workloads on the target VM: idle, online video streaming and file downloading. The result is approximately 265 CPU cycles (or 77 ns) in our setting.To evaluate the memory-reading performance of the ImEE, we run experiments to evaluate the turnaround time with normal read requests. The performance of LibVMI mainly due to the initialization needed for each newly encountered VM.Secondly, we measure the time taken for each solution for switching the introspection target among the four VMs that are already scanned. In contrast, ImEE only needs to fetch the current CR3 on the target VM's vCPU and replace the ImEE CR3, IP and the EPT root pointer of the ImEE vCPU. For example, the TLB can be intentionally made out-of-sync with paging structures in memory, therefore causes the introspection code to use a different mapping from the one currently used by the target. The ImEE is for effective target VM access while in-VM systems are designed for reusing the OS's capability [23,14] or for monitoring events in the guest [34]. It can be based on expert knowledge (e.g., Memparser [12], GREPEXEC [13], Draugr [17], and others [2,4,5,6,8,9,22,32]) and automatic tools (e.g, SigGraph [28], KOP [15], and MAS [16]). To run the monitoring code inside the untrusted guest, it creates a SIM virtual address space isolated from the guest kernel. A taint analysis runs in the monitor VM and relevant data accesses are redirected to the guest's live memory. EXTERIOR [20] is another space traveling approach inspired by VMST, which supports not only guest VM introspection but also reconfiguration and recovery of the guest VM.Process Out-Grafting [35] relocates the monitored process from the guest VM to the monitor VM. ImEE's native access speed allows consistent memory view with that of the target VM.Since the hardware does not automatically maintain the consistency between the TLB entries and the PTEs in the memory, the target VM's adversary can leverage this hardware behavior to defeat introspection. Our basic idea is to load the agent to the trapped vCPU and to set up the identical context used for TLB lookup.The strongest method is that the hypervisor injects the introspection agent to the thread's address space, by either directly modifying the target memory or using EPT redirection as in the ImEE scheme. As shown in Figure 12, the hypervisor creates a new page table directory with all its entries being copied from the target's except that one entry is mapped to a separated page storing the mappings for the agent.