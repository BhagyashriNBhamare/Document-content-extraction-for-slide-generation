By instrumenting the host's USB stack between the device drivers and the USB controller , our system is able to filter packets at a granular-ity that previous works cannot-at the lowest possible level in the operating system. Attackers may also exfiltrate data from the host by leveraging raw I/O (e.g., using libusb [14]) to communicate with the USB device directly, or bypass the security mechanism employed by the USB device controller by sending specific USB packets to the device from the host USB controller [4]. USBFILTER can pin devices (e.g., webcams) to approved programs (e.g., Skype, Hangouts) to prevent malicious software on a host from enabling or accessing protected devices.USBFILTER is different from previous works in this space because it enables the creation of rules that explicitly allow or deny functionality based on a wide range of features. The granularity and extensibility of USBFILTER allows it to perform the functions of existing filters [41] while permitting much stronger control over USB devices.The remainder of this paper is structured as follows: In Section 2, we provide background on the USB protocol and explain why it is not great anymore; in Section 3, we discuss the security goals, design and implementation of our system; in Section 4, we discuss how USBFILTER meets our required security guarantees; in Section 5, we evaluate USBFILTER and discuss individual use cases; in Section 6, we provide additional discussion; in Section 7, we explore related work; and in Section 8, we conclude. A USB device refers to a USB transceiver, USB hub, host controller, or peripheral device such as a human-interface USB Device Interface 0 Interface 1 Interface 2 In Out In In Out Out EP 0 EP 0 EP 1 EP1 EP 0 EP 0 EP 0 EP 0 EP 1 EP 1 EP 1 EP 1 EP 2 EP 2 EP 2 EP 2 EP n EP n Figure 1: A detailed view of a generic USB device. The USB protocol works in a master-slave fashion, where the host USB controller is responsible to poll the device both for requests and responses. When a USB device is attached to a host machine, the host USB controller queries the device to obtain the configurations of the device, and activates a single configuration supported by the device. By parsing the current active configuration, the host operating system identifies all the interfaces contained in the configuration, and loads the corresponding device drivers for each interface. The relative ease with which a USB peripheral can be installed on a host is simultaneously its greatest and most insecure property.The USB subsystem has been expanded in software as well, with Virtio [30] supporting I/O virtualization in KVM, enabling virtual USB devices in VMs, and passing through the physical devices into VMs. Wireless USB (WUSB) [19] and Media Agnostic USB (MAUSB) [16] promote the availability of USB devices by leveraging different wireless communication protocols, making the distinction among local USB devices, virtual ones, and remote ones vanish.Overall, the utility and complexity of USB has been steadily increasing in both hardware and software. Attacks such as BadUSB [27] and TURNIPSCHOOL [1] (itself designed on specifications from nation-state actors) use composite devices to present multiple interfaces to a host. Since operating systems implicitly trust any device attached, these hidden functions are enumerated, their drivers are loaded, and they are granted access to the host with no further impediment.Data exfiltration from host machines may be the main reason why USB storage is banned or restricted in enterprise and government environments. While access controls can be bypassed by raw I/O, which communicates to the device directly from userspace (e.g., using libusb [14]), network-based methods are vulnerable to network spoofing (e.g., ARP spoofing [32] and DNS spoofing [36]). The adversary may also launch network attacks in order Figure 2: USBFILTER implements a USB-layer reference monitor within the kernel, by filtering USB packets to different USB devices to control the communications between applications and devices based on rules configured.to enable or access authorized devices from unauthorized processes or devices. • Unauthorized Access: The adversary may attempt to enable or access authorized devices on a host (e.g., webcam, microphone, etc.) via unauthorized software to gain access to information or functionality that would otherwise inaccessible.We assume that as a kernel component, the integrity of USBFILTER depends on the integrity of the operating system and the host hardware (except USB devices). The core USBFILTER component is statically compiled and linked into the Linux kernel image, which hooks the flow of USB packets before they reach the USB host controller which serves the USB device drivers, as shown in Figure 3. Furthermore, applications generally submit asynchronous I/O requests, causing the kernel to perform the communications task on a separate background thread.This problem also appears when inspecting USB network device packets, including both wireline (e.g., Ethernet) dongles and wireless (e.g., WiFi) adapters. In these cases, USB is an intermediate layer to encapsulate IP packets into USB packets for processing by the USB networking hardware.These cases are problematic for USBFILTER because a naïve traceback approach will often only identify the kernel thread as the origin of a USB packet. Once verified, new rules will be synchronized with the kernel and saved locally.If no user-defined rules are present, USBFILTER enforces default rules that are designed to prevent impact on normal kernel activities (e.g., USB hot-plugs). The TPM provides a root of trust that allows for a measured boot of the system and provides the basis for remote attestations to prove that the host machine is in a known hardware and software configuration. Devices cannot initiate USB packet transmission without permission from the controller.We also instrument the virtual USB host controller (vhci) to cover virtual USB devices (e.g., USB/IP). Future work will add general rules, which can be overwritten by new rules.-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o| --proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action ---------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product, manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop Figure 4. In this setting, malicious devices have to impersonate benign devices to allow communications, which are still regulated by the rules, e.g., no HID traffic allowed for a legit USB storage device. We can write USBFILTER rules to completely shutdown the keyboard and mouse functionalities:usbtables -a teensy1 -v ifnum=2,manufacturer= Teensyduino,serial=1509380 -t drop usbtables -a teensy2 -v ifnum=3,manufacturer= Teensyduino,serial=1509380 -t dropIn these rules, we use condition "manufacturer" and "serial" (serial number) to limit the Teensy's functionality. Then we add following rules into the host machine:usbtables -a mymouse -v busnum=1,devnum=4,portnum=2, devpath=1.2,product="USB Optical Mouse", manufacturer=PixArt -k types=1 -t allow usbtables -a mykeyboard -v busnum=1,devnum=3, portnum=1,devpath=1.1, product="Dell USB Entry Keyboard", manufacturer=DELL -k types=1 -t allow usbtables -a noducky -k types=1 -t dropThe first two rules whitelist the existing keyboard and mouse on the host machine; the last rule drops any USB packets from other HID devices. However, we have leveraged information about the physical interface (busnum and portnum) to write the first two rules, which would require the attacker to unplug the existing devices, plug the malicious device in, and impersonate the original devices including the device's VID/PID and serial number. In this case study, we use a Kingston DT 101 II 2G USB flash drive, and insert the following rule:usbtables -a nodataexfil -v manufacturer=Kingston -l name=block_scsi_write -t dropThis rule prevents modification of files on the storage device. We can also block any writes to USB storage devices:usbtables -a nodataexfil4 -l name=block_scsi_write -t drop USBFILTER logs dropped USB packets, and these logs can easily be used in a centralized alerting system, notifying administrators to unauthorized access attempts. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow usbtables -a nowebcam -v serial=B4482A20 -t dropThe serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. The phone is unable to be used for storage or tethering after the rule is applied.We can construct a more specific charge-only rule:usbtables -a charger -v busnum=1,portnum=4 -t dropThis rule specifies a specific physical port on the host and this port can only be used for charging. The overhead of USB enumeration introduced by USBFILTER is the result of packet filtering and processing performed on each USB packet, since there may be hundreds of packets during USB enumeration, depending on the number of interface and endpoints of the device. The average cost per packet are 2.6 µs and 9.7 µs respectively, including the time to traverse all the 20/100 rules in the kernel, and the time used by the benchmark itself to get the timing and print the result. In this section, we showed how USBFILTER can help administrators prevent access to unauthorized (and unknown) device interfaces, restrict access to authorized devices using application pinning, and prevent data exfiltration. Future work will introduce a new USB networking driver framework to be shared by specific drivers, providing a unified interface for passing PID information into USB packets.Another issue of using process table in USBFILTER rules is TOCTTOU (time-of-check-to-time-of-use) attacks. When process information is crucial to the system, we recommending using USBTABLES to change the default behavior to "drop", make sure that no packet would get through without an explicit matching rule. For example, one can write a LUM to limit the capability of a HID device, such as allowing only three different key actions from a headset's volume control button, which is implemented by GoodUSB as a customized keyboard driver, or disabling sudo commands for unknown keyboards. While BadUSB is the most prominent attack that exploits the USB protocol, we observe that using USB communication as a side channel to steal data from host machines, or to inject malicious code into hosts, is another technically mature and plausible threat. Another solution employed by the Windows Embedded platform [26] binds USB port numbers with the VID/PID/CID (device class ID) information of devices to accept/reject the device plugged in. Similarly, our system can defend processes by denying USB traffic before it reaches its destination.Furthermore, fine-grained filtering has been applied to the usage of filesystem objects by applications [13,35], however, these filters take place after the host and operating system have enumerated the device and loaded any device drivers.