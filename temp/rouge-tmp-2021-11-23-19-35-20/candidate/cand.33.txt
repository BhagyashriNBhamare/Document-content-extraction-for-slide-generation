In a pixel-stealing attack, a malicious web page learns the contents of a web page presented to a user's browser by a different site, in violation of the browser's originisolation guarantees.Andrysco et al. proposed mitigations against floatingpoint timing attacks: * dkohlbre@cs.ucsd.edu † hovav@cs.ucsd.edu• Replace floating-point computations with fixedpoint computations relying on the processor's integer ALU. • Shift sensitive floating-point computations to the GPU or other hardware not known to be vulnerable.At USENIX Security 2016, Rane, Lin, and Tiwari [15] proposed additional mitigations:• Use program analysis to identify floating-point operations whose inputs cannot be subnormal; these operations will not experience subnormal slowdowns. For the purposes of this paper we will refer to floating point, floats, and doubles to mean the IEEE-754 floating point standard (see Figure 1) unless otherwise specified.The floating point unit (FPU) accessed via Intel's single scalar Streaming SIMD (Single Instruction, Multiple Data) Extensions (SSE) instructions adheres to this standard on all processors we discuss. As Andrysco et al. [2] observe, subnormal values do not frequently arise, and special hardware or microcode is used to handle them on most CPUs.Andrysco et al.'s attacks made use of the substantial timing differences between operations on subnormal (or denormal) floating point values and on normal floating point values. Unsurprisingly, double precision floating point numbers show more types of, and larger amounts of, variation than single precision floats.Figures 4, 5, 6, and 7 are crosstables showing average cycle counts for division and multiplication on double and single precision floats on the Intel i5-4460. This apparatus measures the steadystate execution time of each computation.The entirety of our data across multiple generations of Intel and AMD CPUs, as well as tools and instructions for generating this data, are available at https://cs eweb.ucsd.edu/~dkohlbre/floats.It is important to note that the Andrysco et al. [2] focused on the performance difference between subnormal and normal operands, while we observe that there are additional classes of values worth examining. Single Precision Add/Sub - - - Mul S - - Div S - - Sqrt M Z - Double Precision Add/Sub - - - Mul S - - Div M Z Z Sqrt M Z Z The fixed point implementation used in Firefox SVG filters is a simple 32-bit format with no Not-a-Number, Infinity, or other special case handling. Our Firefox SVG timing attack makes use of the feSpecularLighting lighting model with an fePointLight.This particular filter in this configuration is not ported to fixed point, and performs a scaling operation over the input alpha channel.The surfaceScale property in feSpecularLighting controls this scaling operation and can be set to an arbitrary floating point value when creating the filter. Since our measurements show a difference of 7 cycles vs 130 cycles for each multiplication (see Figure 4), we can easily detect this difference once we scale n enough that the faster white pixel case takes longer than 16ms (circa n = 200) in our tests. We need to cross this 16ms threshold as frames take a minimum of 16ms to render (60fps) on our test systems.In our tests on an Intel i5-4460 with Firefox 49+ we were able to consistently obtain > 99% accuracy (on black and white images) at an average of 17ms per pixel. None of the SVG filters had GPU support at the time of this paper, but some CSS transforms could be GPU accelerated.The Webkit feConvolveMatrix filter is implemented in the obvious way; multiply each kernel sized pixel region against the kernel element-byelement, sum, and divide the result by the divisor. We have tested it on Windows 10 (Intel i7-6700k), Ubuntu Linux 16.10 (Intel i5-4460), OSX 10.11.6 (Intel i7-3667U Macbook Air), and a Chromebook Pixel LS ChromeOS 55.0.2883.105 (i7-5500U) on versions of Chrome from 54-56. Unlike Firefox, we cannot trivially supply subnormal value like "1e-41", as the Skia SVG float parsing code treats them as 0s. Since the FTZ and DAZ flags are set only on entering the Skia rendering code, the parsing is not subject to these flags and we can always successfully generate subnormals at parse time.The largest obstacle we bypass is the use of the FTZ and DAZ control flags. Unfortunately none of the current SVG filter implementations we examined have tight division <div id="pixel" style="width:500px;height:500px;overflow:hidden"> <div id="scroll" style="width:1px; height:1px; overflow:hidden; transform:scale(600.0); margin:249px auto"> <iframe id="frame" position="absolute" frameborder="0" scrolling="no" src="TARGET_URL"/> </div> </div> Chrome enables the FTZ and DAZ control flags whenever a filter is set to run on the CPU, which disallows our Firefox or Safari attacks from applying directly to Chrome. Second, they perform a number of basic block linearizations, array access changes, and branch removals to transform the control flow of the program to constant time and minimize side effects.We do not evaluate the efficacy of the higher level control flow transforms and instead evaluate only the elementary operations.Escort's tool is to construct a set of dummy operands (the escort) that are computed at the same time as the Default libdrag Single Precision Add/Sub - - Mul S - Div S Z Sqrt M Z Double Precision Add/Sub - - Mul S - Div M Z Sqrt M ZSingle Precision Add/Sub S S Mul S - Div S - Sqrt S - Double Precision Add/Sub S S Mul S - Div S - SqrtS - Escort will replace most floating point operations it encounters. libdrag can easily fix this, at serious performance cost, by enabling the floating point replacements for all floating point operations with no exceptions.To determine if Escort closes floating point timing side channel when enabled, we measured the timing behavior of Escort's libdrag floating point operations, as well as the end-to-end runtime of toy programs compiled under Escort. (See figure 9)An interesting outcome of this behavior is that subnormal values cause a speedup under libdrag rather than the slowdown observed under scalar operations.We speculate that this is the result of fast paths in the microcode handling for vector operations. By examining the cycle times for each operation in the default and libdrag case we found that the total cycle time for an escorted add or subtract is approximately equal to the sum of the cycle counts for a subnormal,subnormal operation and the test case. We did not test other SVG filters for vulnerability under the Escort/libdrag modifications.Given the observed timing variations in the AMD Phenom II X2 550 in section 7.2.2 we believe that multiple SVG filters would be timing side channel vulnerable under Escort on that CPU. As mentioned in section 7.2.1 we know that any vector operation including a subnormal argument is executed in microcode, and all evidence supports the microcode executing vector operations serially. Thus, extracting timing differences from the occational division they do perform is extremely difficult.If a filter were found to perform tight division loops, or a GPU that has timing variation on non-division operations were found, the same attacks as in previous sections could be ported to the GPU accelerated filters.We believe that even without a specific attack, the demonstration of timing variation based on operand values in GPUs should invalidate "move to the GPU" as a defensive strategy. Van Goethem, Joosen, and Nikiforakis [17] observed that callbacks introduced to support HTML5 features allow attackers to time individual stages in the browser's response-processing pipeline, thereby learning response size more reliably than with previous approaches.The interaction of new browser features -TypedArrays, which translate JavaScript variable references to memory accesses more predictably, and nanosecondresolution clocks -allow attackers to learn whether specific lines have been evicted from the processor's lastlevel cache.