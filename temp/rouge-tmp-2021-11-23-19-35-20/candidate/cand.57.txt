As illustrated by recent leaks of extensive mass surveillance programs 1 , exposing such meta-data leads to significant privacy risks.Since 2004, Tor [20], a practical manifestation of circuit-based onion routing, has become the most popular anonymous communication tool, with systems such as Herd [33], Riposte [11], HORNET [10] and Vuvuzela [46] extending and strengthening this paradigm. However, unless cover traffic is employed, onion routing is susceptible to traffic analysis attacks [7] by an adversary that can monitor network links between nodes. Recent revelations suggest that capabilities of large intelligence agencies approach that of global passive observers-the most powerful form of this type of adversary.It is not sufficient to provide strong anonymity against such an adversary while providing low-latency communication. As such, Loopix considers adversaries with three distinct capabilities, that are described next.Firstly, a global passive adversary (GPA) is able to observe all network traffic between users and providers and between mix servers. This adversary is able to observe the entire network infrastructure, launch network attacks such as BGP re-routing [4], or conduct indirect observa- Corrupt provider Insider Sender-Recipient Third-Party Unobservability Sender online unobservability • Sender anonymity Receiver unobservability• Receiver anonymity • Table 1: The summary of security properties of the Loopix system in face of different threats. We assume that the adversary can control a limited number of such userseffectively excluding Sybil attacks [22] from the Loopix threat model-since we assume that honest providers are able to ensure that at least a large fraction of their users base are genuine users faithfully following all Loopix protocols. We define sender-receiver third party unlinkability as the inability of the adversary to distinguish whether {S 1 → R 1 , S 2 → R 2 } or {S 1 → R 2 , S 2 → R 1 } for any online honest senders S 1 , S 2 and honest receivers R 1 , R 2 of the adversary's choice.Loopix provides strong sender-receiver third-party unlinkability against the GPA even in collaboration with corrupt mix nodes. We define sender online unobservability as the inability of an adversary to decide whether a specific sender S is communicating with any receiver {S →} or not {S →}, for any concurrently online honest sender S of the adversary's choice.Loopix provides strong sender online unobservability against the GPA and even against a corrupt provider. We define receiver unobservability as the inability of an adversary to decide whether any sender is communicating with a specific receiver R {→ R} or not {{ → R}, for any online or offline honest receiver R of the adversary's choice.Loopix provides strong receiver unobservability against the GPA, under the condition of an honest provider. In order for a sender S i , with a key pair (sk S i , pk S i ), to send a message to a receiver R j , with a key pair (sk R j , pk R j ), the sender needs to know the receiver's Loopix network location, i.e., the IP address of the user's provider and an identifier of the user, as well as the public encryption key pk R j . Each message wrapped into the Sphinx packet consists of a concatenation of two separate parts: a header, carrying the layered encryption of meta-data for each hop, and the encrypted payload, which allows for confidential message exchange. The structure of the header consists of (I) a single element of a cyclic group that is re-randomized at each hop, (II) an onion-encrypted vector, with each layer containing the routing information for one hop, and (III) the message authentication code MAC i , which allows header integrity checking. The decryption operation returns the routing commands and a new packet, which should be forwarded to the next hop.We extend the Sphinx packet format to carry additional routing commands in the header to each intermediate relay, including a delay and additional flags.Path selection. For each hop in the path the sender samples a delay from an exponential distribution with parameter µ, and includes it in the vector of routing commends, together with any other auxiliary information, to the corresponding relay. In the case of a provider, the new packet is either forwarded as before or saved in the inbox of one of the provider's clients specified by the address.Message storing and retrieving. If the inbox of a particular user contains fewer messages than this constant number, the provider generates and sends dummy messages to the sender up to that number. In contrast, recall that in Loopix each message is source routed through an independent route in the network.The Poisson Mix functions as follows: mix servers listen for the incoming mix packets and received messages are checked for duplication and decoded using the mix node's private keys. It has a rate λ n depending on the number of clients and the number of mix nodes.Since this input process is a Poisson process and each message is independently delayed using an exponential distribution with parameter µ, the Poisson Mix may be modeled as an M/M/∞ queuing system -for which we have a number of well known theorems [5]. These characteristics, which give the Poisson Mix its name, allow us to calculate the mean number of messages perfectly mixed together at any time, as well as the probability that the number of messages falls below or above certain thresholds.The Poisson Mix, under the assumption that it approximates an M/M/∞ queue is a stochastic variant of a pool mixing strategy [42]. As illustrated in Figure 3, the receiving event i − 1 leads to a pool of messages i − 1, until the sending event i. From the perspective of the adversary observing all inputs and outputs, all messages in the pool i−1 are indistinguishable from each other. Loopix relies on the Sphinx packet format [16] to provide bitwise unlinkability of incoming and outgoing messages from a mix server; it does not leak information about the number of hops a single message has traversed or the total path length; and it is resistant to tagging attacks.For Loopix, we make minor modifications to Sphinx to allow auxiliary meta-information to be passed to different mix servers. Note that, as long as the providers are hon- est, the protection and receiver unobservability is perfect and the adversary cannot learn any information about the inbox and outbox of any client.Corrupt providers: We distinguish the sender's and recipient's providers by calling them the ingress and egress providers respectively. From the properties of Poisson mix, we know that the number of messages in the mix server at a steady state depends on the ratio of the incoming traffic (λ ) and the delay parameter (µ) (from Section 3.3). However, an adversary observing the messages flowing into and out of a single mix node could estimate the exact number of messages within a mix with better accuracy -hindered only by the mix loop cover traffic.We first consider, conservatively, the case where a mix node is not generating any loops and the adversary can count the exact number of messages in the mix. Next, l additional messages arrive at the mix before any message leaves, and the pool now mixes k + l messages. We leverage those results for a single Poisson Mix to simulate the information propagated withing a the whole network observed by the adversary (c.f. Section 4.3). Higher delay also results in an increase in entropy, denoting a larger potential anonymity set, since more messages are mixed together.In case the mix node emits loop cover traffic, the adversary with observation o n,k,l , tries to estimate the probability that the observed outgoing message is a particular target message she observed coming into the mix node. Then,Pr(m = m 1 ) = k n · µ (l + k)µ + λ M , Pr(m = m 2 ) = µ (l + k)µ + λ M . By increasing the rate of cover traffic, λ D and λ L , users can collectively maintain strong anonymity with low message delay. However, once the volume of real communication traffic λ P increases, users can tune down the rate of cover traffic in comparison to the real traffic, while maintaining a small delay and be confident their messages are mixed with a sufficient number of messages.In the previous section, we analyze the security properties of Loopix when the adversary observes the state of a single mix node and the traffic flowing through it. Therefore given a threshold r = λ M s , s ∈ R >1 of expected returning loops when a mix observes fewer returning it deploys appropriate countermeasures.We analyze this strategy: since the adversary cannot distinguish loops from other traffic the adversary can do no better than block traffic uniformly such that a fractionR = λ s = λ R +λ M senter the mix, where λ R is the rate of incoming traffic that is not the mix node's loops. If we assume a steady state, the target message can expect to be mixed with λ R s·µ messages that entered this mix, and λ M µ loop messages generated at the mix node. This is not a substantial attack vector since mix loop messages are evenly distributed among all providers, of which a small fraction are corrupt and providers do not learn which mix node sent the loop to target it. Among them are two challenge senders S 0 and S 1 that send payload messages at a constant rate, i.e, they add one messages to their sending buffer every time unit.Whenever a challenge sender S 0 or S 1 sends a payload message from its buffer, we tag the message with a label S 0 or S 1 , respectively. This is a conservative approximation: we tell the adversary which of the messages leaving senders S 0 and S 1 are payload messages; and we do not consider mix or client loop messages confusing them. We compare our metric for different parameters: depending on the delay parameter µ, the number of layers in our topology l and the percentage of corrupt mix nodes in the network. We implement the Loopix system prototype in 4000 lines of Python 2.7 code for mix nodes, providers and clients, including unit-tests, deployment, and orchestration code. We use the Twisted 15.5.0 network library for networking; as well as the Sphinx mix packet format 6 and the cryptographic tools from the petlib 7 library. First, we evaluate the increase of bandwidth of mix nodes by measuring the rate at which a single mix node processes messages, for an increasing overall rate at which users send messages.We set up the fixed delay parameter µ = 1000 (s.t. the average delay is 1 ms). For the end-to-end measurement, we run Loopix with a setup where all users have the same rates of sending real and cover messages, such that λ P = λ D = λ L = 10 messages per minute and mix servers generate loops at rate λ M = 10 messages per minute. The measurements presented here are for a network of 6 mix nodes, however we can increase the system capacity by adding more servers. is higher than the processing time (∼ 1 ms − 2 ms), the endto-end latency is determined by this delay, and follows the Gamma distribution with parameter being the sum of the exponential distribution parameter over the number of servers on the path. As a defense against traffic analysis, but at the cost of highlatencies, both designs delay incoming messages by collecting them in a pool that is flushed every t seconds (if a fixed message threshold is reached). Moreover, Loopix allows off-line users to receive messages and uses parallel mix nodes to improve the scalability of the network.Stadium [45] and AnonPop [24] refine Vuvuzela; both operating in rounds making the routing of messages dependent on the dynamics of others. In contrast to Loopix, it is suitable for high-latency applications.Dissent [9], based on DC-networks [9], offers resilience against a GPA and some active attacks, but at significantly higher delays and scales to only several thousand clients.Riffle [31] introduces a new verifiable shuffle technique to achieve sender anonymity. Proposals of stand-alone 'presence' systems such as DP5 [6] and MP3 [37] provide efficient lookup methods, however, we anticipate that tight integration between the lookup and anonymity systems may bring mutual performance and security benefits, which is another avenue for future work. = 1 − Pr [X < d 1 ∧ X < d 2 ∧ . . . ∧ X < d n ] = 1 − Pr [X < min{d 1 , d 2 , . . . d n }](7)We know, that d i ∼ Exp(µ) for all i ∈ {1, . . . , n } and X ∼ Exp(λ M ). H t can be computed incrementally given the size of the pool l (from previous mix rounds) and the entropy H t−1 of the messages in this previous pool, and the number of messages k received since a message was last sent:for any t > 0 and H 0 = 0. The adversary observes an outgoing message m and wants to quantify whether this outgoing message is her target message.The adversary knows, that the output of the mix node can be either one of the messages inside the mix or its loop cover message.