Our proposal is hence to allow the developer/user to inform our system what task/unit structure they desire by annotating a small number of data structures (e.g., the tab data structure in Firefox). We integrate it with three different provenance collection systems: the widely adopted Linux audit framework, and two state-of-the-art research projects, ProTracer [46] 2 and the LPM [23] enabled HiFi [55] system (LPM-HiFi) which features secure audit logging.In summary, we make the following contributions:• We propose the novel idea of partitioning execution based on data structures to support different granu-1 MPI is short for "Multiple Perspective attack Investigation" 2 ProTracer is based on BEEP, we replace the BEEP with MPI.larities and facilitate multi-perspective, applicationsemantics-aware attack investigation. After intensive browsing and researching, the developer settles down on a forum that hosts not only the wanted software, but also many other interesting resources, including torrents for a few tutorial videos. He also uses a p2p software Transmission to download the videos described by the torrents.Unfortunately, the forum website was compromised, targeting enterprises whose developers tend to use the forum for technical discussion and information sharing. Traditional techniques such as backtrackers [38,39], audit systems [10] and provenance-aware file systems [50,55] track the lineage of system objects or subjects without being aware by the applications. These techniques collect system subjects (e.g. processes and threads) and objects (e.g. files, network sockets and pipes) information at run time with system call hooking or Linux Security Modules (LSM) [62], and construct dependency graph or causal graph for inspection. In Figure 1, many network sockets point to the Firefox process, and the process points to a large number of files including the torrent files and others like fcopy, which reflect the browsing and downloading behaviors of Firefox.While we only show part of the original graph in Fig- ure 1 for readability, the original graph contains more than 500 nodes in total, with most files and network socket accesses being (undesirably) associated with the Firefox and Transmission nodes. Event loop based partitioning techniques [43,45,46] leverage the observation that long running processes are usually event driven and the whole process execution can be partitioned by the event handling loops (through binary instrumentation). This is because all user interactions like scrolling the web pages, moving mouse pointer over a link and clicking links are processed by unique event loop iterations, each leading to a unit/node. As these events operate on DOM elements, they are connected in the dependency graph due to memory Figure 1: Simplified causal graph for the case in §2.1 generated by traditional solutions (Tool in [16]). Due to the nature of p2p protocol, downloading a single file requires thousands of loop iterations, leading to thousands of units in BEEP.In many situations, there may not be any system events within these small units. While existing techniques [22,44,46,67] can remove redundant events, they cannot prevent these events from being generated in the first place.These limitations are rooted at the misalignment between the rigid and low level execution partitioning scheme based on event loops. In our design, we only require the developer to annotate (a few) task oriented data structures, MPI automatically instruments a much larger number of code places based on the annotations. A number of forum pages are displayed on separate tabs, each of which leads to the download of a torrent file through a Transmission unit. However, such annotations are so low-level that (1) they require a lot of human efforts due to the large number of places that need to be annotated (e.g., the memory dependencies), and (2) they expose low-level and sometimes non-informative semantics such as mouse moves and timer events. The user first annotates the program source code to indicate unit related data structures under the help of the annotation miner, which is essentially a data structure profiler. Observe that at step 1 , the loading of tab1 first dispatches a Domain Name Server (DNS) query to a DNS thread, and then (step 3 ) posts a connection request to the socket thread to download the page. When the main thread tries to load a new URI (step 1), it posts an nsConnEvent to the SocketThread (step 2) by calling the PostEvent method (box C). The resulting set contains the top level data structures and their supporting meta data structures (e.g., the ScrollPos data structure to support scrolling in a tab). Since data structure nsRunnable (box A) is annotated as a delegator and the HTTP connection request nsConnEvent (box B) is a subclass of nsRunnable, MPI propagates the current unit id in the main thread to the worker thread, namely, the socket thread. It takes a program with the four kinds of annotations mentioned in §3.2, and produces an instrumented version of the program that emits additional syscall events denoting unit context switches and channel operations.MPI needs to identify the following a few kinds of code locations: (1) all the updates (i.e., definitions) to indicator variables, including unit indicators and delegator indicators, to add instrumentation for unit context updates; (2) all the creation/initialization locations of delegator data structures to add instrumentation for the inheritance of unit context; (3) reads/writes of channel variables/fields to add instrumentation for channel event emission and redundancy detection; (4) all the system/library calls that may lead to system calls to add instrumentation for unit event emission and redundancy detection. Appendix B discusses how to construct attack graphs from MPI logs.In this section, we present the evaluation results including the annotation efforts needed, the runtime and space overheads of the prototype, and a number of attack cases to show the advantages of MPI compared to the event loop based partitioning technique in BEEP [43] and ProTracer [46]. For the 46 unit data structures that we eventually annotate, 36 of them are ranked at the first place, 8 at the second place, and the remaining 2 at the third place. MPI provides choices that align better with the logical structures of the application, such as the session perspective (box 2), i.e., all the commands/requests from a session belong to a unit, the directory perspective (box 4), i.e., all the commands on a given directory are considered a unit, and the user perspective (box 5), i.e., all commands/requests from a user (not limited to an IP address) belong to a unit. The expressions in the corresponding identifier annotations mean that we can acquire the tab of any given window by getting the second layer outer window, and the top level window by calling GetTop(). We want to point out that the MPI graphs cannot be generated from the BEEP graph by post-processing because of the subtask delegation in this program, i.e., it is difficult to attribute a sub-task to the top level unit that it belongs to with only the low level semantic information in the BEEP graph. This example simulates an important kind of real-world attacks, watering hole attack [18,19], Watering hole is a popular attack strategy targeting large enterprises such as Apple [11] and Google [12]. It is hence highly desirable to directly recognize the logic tasks, which are disclosed by corresponding data structures, instead of chaining low level event loop based units belonging to a logic task through memory dependencies. Traditional approaches consider the entire process execution as a node so that all the input/output interactions become edges to/from the process node, resulting in considerably large and inaccurate graphs. Enabling these perspectives is impossible if the appropriate semantic information is not exposed through MPI.One may argue that event loop based partitioning can be enhanced by annotating event loops and cross-unit memory dependencies. Upon the creation/initialization of a delegator data structure instance, MPI inserts a key-value pair into the delegation table associating the delegator to the current unit context. However , these techniques rely on a low level programming paradigm (i.e., event handling loops) to partition execution , which often results in low level graphs with a lot of redundancy. The results show that MPI is able to correctly identify the root causes with very succinct causal graphs for all cases. □ The problem is formulated as a reaching-definition problem, which determines the set of definitions (of a variable) that can reach a program point. The evaluation results show that our technique generates cleaner attack graphs with rich high-level semantics and has much lower space and time overheads, when compared with the event loop based partitioning techniques BEEP and ProTracer. Most existing techniques [38,46,49,50,59] entail hooking and recording important system level events (e.g. file operations), and then correlating these events during an offline investigation process. The user perspective can aggregate all the behaviors from a specific user over multiple sessions so that the inspector can hold individual users for responsibilities. Provenance tracking is critical for attack investigation, especially for Advanced Persistent Threats (APTs) that are backed by organizations such as alien governments and terrorists. For example in Apache, a remote HTTP request can lead to redirection, and the Apache server needs a few BEEP execution units to handle it. Two more cases are presented in Appendix C to demonstrate the advantages of MPI over BEEP/ProTracer in an insider threat and in tracking complex browsing behaviors in Firefox. Firstly, in these programs, the events handled by the event handling loop are at a very low level, whereas MPI can partition execution at a much higher level. When the user performs a paste operation, it reads data from the variable and puts the data to the expected position. Compared to the BEEP graph in Figure 1, these graphs are much smaller and cleaner, precisely capturing the high level workflow of the execution. Hence, we provide multiple perspectives by annotating the nsPIDOMWindow data structure and using different expressions in the identifier annotations to distinguish the perspectives. In order to perform unit switching, we need to identify the unit data structure that is analogous to task_struct and used to store per-unit information, a field/expression that can be used to differentiate unit instances as the identifier, and a variable that stores the current active unit. Upon an update of the indicator of a delegator data structure (in a worker thread that handles the subtask represented by the delegator), the unit context of the current thread is set to the unit context of the delegator, which is looked up from the delegation table. Note that this mining stage is much less demanding than the training process in BEEP/ProTracer, which requires extracting code locations that induce low level memory dependencies. Instead, the emphasis of MPI is to address dependence explosion caused by long running processes with accuracy and flexibility. Note that providing source code does not address this problem as identifying event handling loops and cross-unit dependencies requires in-depth understanding of low level program semantics, which is much easier through dynamic analysis by observing concrete states than static analysis, in which everything is abstract. For instance, a Firefox process may visit numerous pages over its lifetime while only one page is related to a driveby-download attack.Researchers proposed to partition execution to units so that only the events within a unit are considered causally related [43,46]. In this section, we use an example to illustrate the differences between the classic provenance tracking systems [23,49,50,55], the existing event loop based execution partitioning approaches [43,46], and the proposed approach. Moreover, MPI generates fewer execution units using the perspectives in Table 1, when compared to BEEP/ProTracer. It requires intensive training to identify the event handling loops and memory accesses that disclose dependencies across units (e.g., one event loop inserts a task to the queue which is later loaded and processed by another event loop). In Figure 11, we show a detailed workflow of the main thread posting the connection event to the socket thread. Moreover, attacks that target the underlying audit system, such as audit log blurring and log filling, may inject noise to logs, making log inspection difficult. Event . A naive solution to (1) is to perform a walk-through of the LLVM bitcode to identify all definitions to indicator variables or to their aliases (using the default alias analysis in LLVM). □ Different from BEEP/ProTracer, our solution is to leverage annotations and static analysis to partition directly according to the logic tasks (e.g. tabs). For example, the audit system on Windows, Event Tracing for Windows (ETW) requires the developers to explicitly plant auditing API calls in their source code if they would like to perform any customized logging. If the user has annotated n unit data structures (with n indicators and n identifiers), there are n elements in the vector. We argue these are orthogonal challenges to all existing provenance tracking techniques and a complete solution to all these challenges is not the focus of our paper. As MPI is based on source code level annotation and compiler instrumentation, it cannot find units within dynamic code. The user can choose to annotate multiple indicator variables/fields, one for each perspective. The correlations have multiple types: between two processes such as a process creating a child process through sys_clone(); between a process and a system object, e.g., a process reads a file through sys_read(). Although existing execution partitioning based systems such as BEEP [43]