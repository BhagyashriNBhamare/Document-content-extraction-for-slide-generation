The approach is demonstrated using electromagnetic (EM) emanations on two mobile phones and an embedded system, and after only one decryption in a fixed-window RSA implementation it recovers enough bits of the secret exponents to enable very efficient (within seconds) reconstruction of the full private RSA key. These signals include electromagnetic emanations created by current flows within the device's computational and power-delivery circuitry [2,3,14,21,33,46], variation in power consumption [9,12,15,17,23,26,34,35,36,41], and also sound [6,16,24,42], temperature [13,29], and chasis potential variation [23] that can mostly be attributed to variation in power consumption and its interaction with the system's power delivery circuitry. Finally, not all side channel attacks use analog signals: some use faults [11,25], caches [8,43,44], branch predictors [1], etc.Most of the research on physical side-channel attacks has focused on relatively simple devices, such as smartcards and simple embedded systems, where the sidechannel signals can be acquired with bandwidth much higher than the clock rates of the target processor and other relevant circuitry (e.g. hardware accelerators for encryption/decryption), and usually with highly intrusive access to the device, e.g. with small probes placed directly onto the chip's package [19,35]. They have shown that physical side channel attacks are possible even when signals are acquired with bandwidth that is much lower than the (gigahertz-range) clock rates of the processor, with less-intrusive access to the device, and even though advanced performance-oriented features, such as super-scalar (multiple instructions per cycle) execution and instruction scheduling, and system software activity, such as interrupts and multiprocessing, cause significant variation in both shape and timing of the signal produced during cryptographic activity.To overcome the problem of low bandwidth and variation, successful attacks on high-clock-rate systems tend to focus on parts of the signal that correspond to activity that takes many processor cycles. We further assume that the adversary can bring a relatively compact receiver into close proximity of the system performing these RSA secret-key operation, for example a smartinfrastructure or smart-city device which uses public key infrastructure (PKI) to authenticate itself and secure its communication over the Internet, and which is located in a public location, or that the adversary can hide a relatively compact receiver in a location where systems can be placed in close proximity to it, e.g. under a cellphone charging station at a public location, under the tabletop surface in a coffee shop, etc.). Unlike many prior attacks on RSA, we do not assume that the adversary can choose (or even know) the message (ciphertext for RSA decryption) to which the private key will be applied, and we further assume that the RSA implementation under attack does utilize blinding to prevent such chosen-ciphertext attacks. This is a very realistic assumption because PKI is typically used only to set up a secure connection, typically to establish the authenticity of the communication parties and establish a symmetric-encryption session key, so in scenarios where the attacker's receiver can only be in close proximity to the target device for a limited time, very few uses of the private RSA key may be observed. The lookup tables used to update the result at the end of each window are stored in scattered form to mitigate attacks that examine the cache and memory behavior when reading these tables, and the RSA implementation supports blinding (which we turn on in our experiments) to mitigate chosen-ciphertext attacks. In our experiments we place probes very close, but without physical contact with the (unopened) case of the phone, while for the embedded system board we position the probes 20 cm away from the board, so we consider the demonstrated attacks close-proximity but nonintrusive. The side-channel analysis thus seeks to recover either d or, in CRT-based implementations, d p and d q , using side-channel measurements obtained while exponentiation is performed.The exponentiation is implemented as either left-toright (starting with the most significant bits) or rightto-left (starting with the least significant bits) traversal of the bits of the exponents, using large-integer modular multiplication to update the result until the full exponentiation is complete. A grade-school implementation of BN mod mul thus requires O(n 2 ) limb multiplications, but the Karatsuba multiplication algorithm [30] is typically used to reduces this to O(n log 2 3 ) ≈ O(n 1.585 ), In most modern implementations a significant further performance improvement is achieved by converting the ciphertext to a Montgomery representation, using Montgomery multiplication for BN mod mul during exponentiation, and at the end converting the result r back to the standard representation.Even with Montgomery multiplication, however, the vast majority of execution time for large-number exponentiation is spent on large-number multiplications, so performance optimizations focus on reducing the number of these multiplications. In the naive implementation above, an occurrence of squaring tells the attacker that the next bit of the exponent is being used, and an occurrence of multiplication indicates that the value of that bit is 1, so an attack that correctly recovers the square-multiply sequence can trivially obtain all bits of the secret exponent.To improve performance, most modern implementations use window-based exponentiation, where squaring is needed for each bit of the exponent, but a multiplication is needed only once per a multi-bit group (called a window) of exponent bits. The sliding-window approach chooses a maximum size wmax for the windows it will use, precomputes a table ct that contains the large-integer value c wval modm for each possible value wval up to wmax length, and then scans the exponent, forming windows and updating the result for each window.In this algorithm, a squaring (lines 7 and 26 in Fig- ure 2) is performed for each bit while the multiplication operation (line 29) is performed only at the (1-valued) LSB of a non-zero window. The computation we target is brief and the different values of exponent bits produce relatively small variation in the side-channel signal, so the signals subjected to our analysis need to have sufficient bandwidth and signalto-noise ratio for our analysis to succeed. This is needed because our receiver's sampling is not synchronized in any way to the computation of interest, so two signal snippets collected for the same computation may be misaligned by up to half of the sample period. It includes part of one large-number multiplication (Line 7 in Figure 3), which in OpenSSL uses the Montgomery algorithm and a constant-time implementation designed to avoid multiplicand-dependent timing variation that was exploited by prior side-channel attacks. In this particular portion of the signal, the execution proceeds to lines 8 and 9 Figure 2, where a bit of the exponent is obtained and added to wval, then lines 10 and 6, and then 7 where, at the point indicated by the second dashed vertical line, it enters another Montgomery multiplication, whose signal continues well past the right edge of Figure 4. Therefore, instead of finding instances of relevant snippets by matching them against their reference signals from training, we use as a reference the signal that corresponds to the most prominent change in the signal during Mongtomery multiplication, where the signal abruptly changes from a period with a relatively low signal level to a period with a relatively high signal level. Because this method of identifying the relevant snippets of the signal is based on the signal that corresponds to the Montgomery multiplication that precedes each relevant snippet, the same method can be used for extracting relevant signal snippets for both fixed-window and sliding-window exponentiation -in both cases the relevant snippet is at the (same) fixed offset from the point at which a prominent-enough peak is detected in the derivative of the signal's moving median. In OpenSSL's implementation the ct is kept in a scattered format to minimize leakage of wval through the cache side channel while computing the Montgomery multiplication, so instead the value of wval is used to gather the scattered parts of ct[wval] into a preallocated array that is passed to Montgomery multiplication. We then additionally use timing between these snippets to determine the position of the missing S-S. We alleviate this problem by forming separate references for different bit-positions within the window, e.g. for window size w = 5 each value of bval would have 4 sets of S-S snippets and one set of S-U snippets, because the first for bits in the window correspond to S-S snippets and the last bit in the window to an S-U snippet. Two references are shown for each value of the exponent's bit that corresponds to the snippet.erence snippets for bval recovery is 2 * (w − 1) * 10 -two possible values of bval, w − 1 bit-positions, 10 reference signals (cluster centroids) for each, while for S-U snippets we only have 20 reference snippets because S-U only happens for the last bit-position in the window. The sliding-window implementation of large-integer exponentiation ( Figure 2) has three sites where Montgomery multiplication is called: the squaring within a window at line 26, which we label S, the update of the result at line 29, which we label U, and the squaring for a zero-valued window at line 7, which we label Z. However, in contrast to work in [10] that could only distinguish between a squaring (line 7 or line 26, i.e. S or Z in our sequence notation) and an update (line 29, U in our sequence notation) using memory access patterns within each Montgomery multiplication (which implements both squaring and updates), our method uses the signal snippets between these Montgomery multiplica-tions to recover more detailed information, e.g., for each squaring our recovered sequence indicates whether it is an S or a Z, and this simplifies the rules for recovery of exponent's bits and allows us to extract more of them. Then, after S-U, we observe U-Z, which indicates that the bit after the window is 0-valued (which we have already deduced), then two occurrences of Z-Z indicate two more 0-valued bits (one of which we have already deduced), and finally Z-S indicates that a new non-zero window begins, i.e. the next bit is 1. In our experiments, when using wmax = 5 this analysis alone on average recovers 68% of the secret exponent's bits, and with using wmax = 6, another commonly used value for wmax, this analysis alone on average recovers 55% of the exponent's bits. Such branch-andprune search has been shown to be efficient when up to 50% of the bit-positions (chosen uniformly at random) in d p and d q are erasures, while its running time grows exponentially when the erasures significantly exceed 50% of the bit positions.Henecka's algorithm [27] can be applied with the above pruning equations to recover the private key when some of the bits are in error. Finally, when equal numbers of errors and erasures are injected, the efficiency for each injection rate is close to (only slightly worse than) the efficiency for error-only injection at half that rate, i.e. with a mix of errors and erasures, the efficiency of reconstruction is largely governed by the errors. OpenSSL uses a fixed window size w = 5 for exponentiation of this size.Note that RSA decryption involves another exponentiation, with d q , and uses the Chinese Remainder Theorem to combine their results. In addition to these unknown (but known-to-be-unknown) bits, for the Samsung phone the reconstruction also produced between 0 and 4 incorrectly recovered (error) bits.Finally, for the Alcatel Ideal phone most instances of the encryption had between 13 and 16 unknown bits in each of the two exponents, mostly because activity on the other three cores interferes with the activity on the core doing the RSA decryption), and a similar number of incorrectly recovered bits (errors). The results of this experiment are shown in Figure 10, where the leftmost data points correspond to training and recovery on the same device, while the remaining seven sets of data points correspond to training on one board and recovery on another.These results indicate that training on a different device of the same kind does not substantially affect the accuracy of recovery.Finally, for each RSA decryption instance, the recovered exponent bits, using both the recovered d p and the recovered d q , were supplied to our implementation of the full-key reconstruction algorithm. For each instance, the correct full RSA private key was reconstructed within one second on the Core i7-based Surface Pro 4 tablet, including the time needed to find the k p and k q coefficients that were not known a priori. This is an expected result, given that even the worst bit recovery rates (for the Alcatel phone) correspond to a an error rate of about 1.5%, combined with an erasure rate of typically 1.5% but sometimes as high as 3% (depending on how much system activity occurs while RSA encryption is execu- 1 The OLinuXino boards are much less expensive than the phones, so we could easily obtain a number of OLinuXino boards The maximum, median, and minimum success rate among decryption instances (each with a different randomly generated key) is shown for recovery that only uses the snippet-type sequence (S-M-Z Sequence), and for recovery that also recovers window bits from U-S and Z-S snippets (Overall). The second enabler of our attack approach is the attacker's ability to precisely locate, in the overall signal during an exponentiation operation, those brief snippets of signal that correspond to examining the bits of the exponent and constructing the value of the window. Our evaluation uses signals obtained by demodulating the signal from a relatively narrow band (40 MHz) around the processor's clock frequency (around 1GHz), which is within the capabilities of compact sub-$1,000 software-defined radio (SDR) receivers.Finally, we propose a mitigation where the bits of the exponent are only obtained from an exponent in integersized groups (tens of bits) rather than obtaining them one bit at a time.