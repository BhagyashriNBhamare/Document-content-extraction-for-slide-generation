Moreover, we show that, unlike traditional networks where identifier binding attacks are limited to a small subset of identifiers, in SDN, identifier binding attacks can be so severe that they allow complete takeover of all network identifiers of the victim host at once, in an attack we dub Persona Hijacking. Because of the stack model where layers can access services only from adjacent layers, identifier binding takes place in two forms, explicit -achieved through network protocols or manual configuration, and implicit -achieved through already existing mappings. For additional background on the identifiers discussed here, please see Appendix A. Network location to device: In traditional networks, a device's network location is represented implicitly by the switch and port that packet forwarding rules are bound to and the location of ACL rules or other configuration specific to that device. A single IP address may be associated with multiple hostnames and a single hostname may be associated with multiple IP addresses.In unicast DNS, the hostname to IP bindings are either manually configured by an administrator or automatically updated using the DNS update command. Microsoft Active Directory has its own scheme to authenticate DNS updates to ADintegrated DNS servers while other directory services have the DHCP server update the DNS records for clients when they acquire IP addresses [19]. Username to hostname: This binding occurs either as per-system user accounts or via a directory service, of which Active Directory is the most prominent.Active Directory (and its open-source counterpart Samba) is a directory service that maintains information on users, groups, access rights, and configuration information for an organization and uses this information for centralized authentication and management. The ultimate goal of layer-to-layer bindings is to allow a mapping across the entire stack where higher level identifiers are mapped by transitivity to lower layers and, ultimately, to device identifiers.Definition 1 (Identifier binding attack): We define an identifier binding attack as 1) replacing or creating a binding such that the identifiers bound together are associated with different devices, or 2) utilizing identifiers associated with a known, offline device in a binding.There are several design factors and architectural characteristics that facilitate identifier binding attacks:(1) Reliance on insecure protocols: Many of these bindings are constructed based on broadcast requests that query the entire broadcast domain while others are formed implicitly based on spoof-able identifiers in observed traffic. DNS spoofing is possible because bindings are treated independently, allowing a host to use spoofed packets to send DNS responses as if they came from the legitimate DNS server.Limitations of identifier binding attacks in traditional networks: Identifier management in IPv4 Ethernets must contend with several architectural aspects of the network stack that impact the scope, consistency, and security of identifier bindings between different network identifiers. These include techniques such as Cisco's Dynamic ARP Inspection and DHCP Snooping systems, which maintain local databases of identifier bindings and can drop packets based on coarse-grained heuristics and manually configured trust relationships [10]. This unifies the entire network under a single SDN controller (or communicating set of controllers) and removes most traditional divisions of a network into broadcast domains and subnets. Attackers can take advantage of temporarily inconsistent flow rules to intercept messages meant for another host or blackhole traffic.We have observed the lack of traditional ARP poisoning/DHCP snooping defenses and the presence of delayed rule consistency experimentally in ONOS and Ryu and confirmed both in the Floodlight and POX source code. We assume the attacker has compromised one or more end-hosts on this network and is attempting to use those hosts to impersonate a target server to clients in order to subvert additional end-hosts and move laterally in the network. Specifically, our Persona Hijacking attack allows an attacker in an SDN-based network to take over an IP address and DNS domain name from a victim end-host by progressively breaking the MAC Address to Network Location, IP Address to MAC address, and (in some network configurations) Hostname to IP Address bindings.A key feature of our attack, which is unachievable using traditional identifier binding attacks (e.g., ARP spoofing), is that it affects the network infrastructure such that the attacker becomes the owner of record for the IP address. The first phase, which we refer to as IP takeover, relies on a client-side attack against DHCP to break the IP address to MAC address and hostname to IP address bindings in order to hijack the IP address and hostname of the victim by binding both of them to the attacker's MAC address. Furthermore in networks with high DHCP churn, an attacker can perform strategically timed and limited DHCP starvation to avoid detection by allowing new clients to consume the IP addresses in the unused pool.IP takeover Impact: SDN controllers that use DHCP to manage forwarding rules will redirect traffic bound for the victim's IP address to the attacker's network location. This monitor runs concurrently with the NIB updater responsible for generating packet out events, which introduces an exploitable race condition where the message is sent prior to new flow rules being installed.The attacker can take advantage of this temporary inconsistency to blackhole traffic from a target source s to a target destination d. Figure 3 depicts a timeline of this attack. The Persona Hijacking attack and other identifier attacks are possible because of several network design characteristics of identifier binding in traditional networks: (1) reliance on insecure protocols using techniques like broadcast for requests and responses without any authentication mechanisms, (2) allowing the changing of bindings without considering the network-wide impact to services relying on them, (3) allowing for independent bindings across different layers without any attempt to check consistency, and (4) allowing high-level changes to identifiers that are designed and assumed to be unique. SECUREBINDER leverages SDN and IEEE 802.1x to target the facilitating factors as follows:• It leverages SDN functionality to separate the identifier binding control traffic from the regular data plane, isolating it from an attacker, and creating a binding mediator which can perform additional security checks on identifier bindings. • It protects against readily changed, but supposedly unique, identifiers by leveraging IEEE 802.1x to provide a root-of-trust for network identifiers, binding the MAC address to a cryptographic authentication and eliminating disconnected host race conditions.Assumptions. The port control module is responsible for configuring flow rules on individual network ports to separate binding protocol traffic and enable egress filtering based on identifier binding updates, 802.1x authentication, and changes in port or switch status. It performs dynamic egress (i.e., sourceaddress) filtering on a per-port basis based on the binding information, thus preventing spoofed packets at the first SDN-controlled port and changing this implicit binding to an explicit one controlled by the configuration of the egress filters. The device authenticator addresses this issue by extending IEEE 802.1x, a network access technology supported by all major operating systems and platforms that is designed to enable a network port if-and-only-if an authorized client is connected. We extend the authentication to validate each device's MAC address as well, providing a cryptographic root-oftrust for our network identifier bindings.802.1x operates using an authenticator on the switch which tunnels EAP [1] messages between a supplicant on the client and a RADIUS [42] authentication server on the backend. A client that is able to present a certificate signed by the CA is considered authorized to access the network.We augment 802.1x to validate the client's MAC ad-dress by having the (trusted) 802.1x authenticator, implemented in the SDN controller, pass the client's MAC address to the RADIUS server. Egress filtering is accomplished by inserting flow rules into table 0 such that flows with expected source identifiers (both MAC and IP addresses) are sent directly to table 1 to be routed as normal, while all other traffic is rate limited and sent to the controller.SECUREBINDER takes the form of a privileged SDN controller application which has configured itself to handle all packet in events before any other application. This returned a large set of automatically discovered counter-examples (invariant violations) that correspond to known ARP spoofing, Host-Location Hijacking (also independently and manually discovered by Hong, et al. [24]), and rogue DHCP attacks, as well as our own IP takeover and Flow Poisoning attacks. Once a Promela model is written and the logical properties of its state variables defined, SPIN can then be used to verify that those properties hold over all reachable system states, or to find a counter-example (i.e., an attack violating a security property). A packet consists of an Ethernet frame (containing source and destination MAC addresses) encapsulating either an ARP message or an IP header and DHCP payload.ARP is implemented as defined in RFC 826 [40], but does not include the message fields or associated checks for hardware and protocol types, since our analysis is focused on IPv4 Ethernet networks. This is because we define any DHCP payload from an unauthorized DHCP server to be malicious, regardless of its content.Communication occurs through uni-directional channels, in which senders place packets on a finite-length FIFO queue and receivers remove messages from the head of that queue. No packets after the first in each flow will be diverted to the controller, so any additional latency only impacts the first packet of a flow.We compared unmodified ONOS 1.5.1, providing shortest path routing, proxyARP, and DHCP, with SE-CUREBINDER in a network topology with a single switch. While different packets may take noticeably different amounts of processing to handle, this is a common proxy for controller load and does accurately account for the additional load placed on the network via packet in messages, TLS message encryption load, message parsing, and event loop processing.We measured the number of packet in messages sent to the controller using a Mininet network with 3 switches and 4 hosts in a tree toplogy and compare unmodified ONOS 1.5.1, providing shortest path routing, proxyARP, and DHCP, with SECUREBINDER. Interestingly, in this case DHCP starvation is not required.A number of security features commonly found in traditional switches (e.g., port security [9] and DHCP snooping [8]) make it more difficult to launch a DHCP starvation attack by limiting the number of source MAC addresses originating from a single port; however, a recent starvation technique has been developed to bypass these defensive mechanisms [50]. This technique exploits the DHCP server's IP address conflict detection by answering all the probes used to check if an address is in use, without spoofed MAC addresses.Despite these limitations Persona Hijacking remains a powerful attack that co-opts the network infrastructure to propagate a malicious identifier binding that will reliably last for a significant time even in the presence of a vigilant system administrator running many monitoring tools. This presents network access control systems with a confused deputy problem; a device is identified by its MAC address and any identifiers bound to that address, while the attacker presents a MAC address corresponding to an authorized device. In these networks, all BYOD or public devices are unknown to the network and therefore equally (un)privileged. Port Security [9] is a heuristic defense against MAC spoofing, which limits the number of MAC addresses that can be present on a single network port.To prevent ARP spoofing [11], a wide range of defenses based on replacing ARP with secure variants have been proposed [4,32,35]; however, vendor-supported technologies such as Cisco Dynamic ARP Inspection (DAI) [29], which compares ARP replies with DHCP server records, or monitoring tools like arpwatch [31] are used more often in practice. This defense requires manual configuration of the trusted and untrusted zones and is limited to protecting against attacks on DHCP only.Defenses against DNS spoofing [48] include increasing the randomness in the DNS query, using random source ports and transaction IDs, to protect against blind attackers [48], as well as cryptographic techniques like DNSSEC [2] that protect the authoritative response from tampering. We have thereafter shown how to use SDN capabilities to prevent such attacks by implementing a new defense that exploits SDN's data and control plane separation, programmability, and centralized control to protect network identifier bindings, and builds upon the IEEE 802.1x standard to establish a cryptographic root-of-trust. A Unicast IP address is a unique identifier for a device interface which is constrained to a particular subnetwork (to enable route aggregation). A port connected to another switch, as identified by the controller's topology detection using LLDP, is put into the Internal state, where it sends all traffic directly to table 1 for forwarding. See Figure 7 for the state machine.To protect the MAC address to network location binding, we use egress filtering along with 802.1x such that all packets except 802.1x frames that are not associated with an existing binding on a port are dropped. To account for cases where a host may leave the network without sending a log-off message and without the port going down (e.g., a device behind a hub), we periodically query all idle hosts with an ARP ping; devices that do not respond are removed.We provide support for non-802.1x devices by monitoring the MAC addresses seen on each port and checking whether each one attempts 802.1x authentication within 60 seconds of connecting. We also drop all multicast DNS and NETBIOS traffic because the broadcast nature of these protocols makes them inherently insecure.Finally, to secure the username to hostname binding we separate directory service traffic from the dataplane by inserting high priority flow rules to send this traffic directly to the directory server while dropping all spoofed packets. We thank William Streilein and James Landry for their support of this work as well as our shepherd, Guofei Gu, and anonymous reviewers for their helpful comments on this paper. Such goals, are not only to ensure delivery of packets from a source to a destination, but also to enforce access control and authorization policies (e.g., authority to update a DNS record or to access a service using Kerberos). The key identifiers used at different layers of the networking stack are: network location, MAC address, IP address, hostname, and username.We consider the device as the basic entity with an identifier, be it an end-host, a server, a printer, or an embedded system, etc. We refer to this identifier as the Network Location of a device and define it as a tuple (switch, port), where switch is a unique identifier for a switch, a serial number or management IP address in traditional networks and a Data Path Identifier (DPID) in OpenFlow SDNs, and port is an integer representing the port number on that switch.