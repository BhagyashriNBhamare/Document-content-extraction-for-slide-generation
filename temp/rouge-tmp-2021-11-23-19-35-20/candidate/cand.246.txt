In our evaluation, we demonstrate the applicability of KOOBE by exhaustively analyzing 17 most recent Linux kernel OOB vulnerabilities (where only 5 of them have publicly available exploits), for which KOOBE successfully generated candidate exploit strategies for 11 of them (including 5 that do not even have any CVEs assigned). These studies employ various program analysis techniques to search for a possible exploit path (that can achieve arbitrary code execution) given a Proof-of-Concept (PoC) test case.Exploits of OS kernel vulnerabilities have unique characteristics compared to those of user applications -any kernel exploit is multi-interaction by design, involving a sequence of attacker-chosen inputs (i.e., syscalls and their arguments) where one is dependent on another; this is in contrast with many user applications such as command line programs that take input in one-shot. In practice, many more syscalls are typically added to a PoC to form an exploit that can fully hijack the control flow or escalate privileges.On the other hand, multi-interaction exploits also create opportunities for "divide-and-conquer" where we break down an exploit into a series of goals which can be reasoned about and achieved separately. We demonstrate the applicability of KOOBE by analyzing 17 OOB vulnerabilities (7 CVEs), for which KOOBE successfully generated candidate exploit strategies for 11 of them.We make the following contributions:• We distill key challenges in exploiting Linux kernel OOB vulnerabilities and design an effective analysis framework focusing on capability extraction that captures the intrinsics of this specific type of vulnerabilities. The basic idea in crafting a kernel OOB write exploit is straightforward -when an OOB write access occurs, an adversary would pre-arrange the memory layout such that some critical data is overwritten (e.g., a function pointer), which can be used to perform control flow hijacking. As we will elaborate through a real-world kernel OOB vulnerability, this is because that (1) a PoC program may not fully explore the capability of an OOB vulnerability; (2) there is often a huge search space to locate an appropriate memory layout that can facilitate the exploit. On the other hand, as will be demonstrated later in §4.3, we are able to discover this additional capability and create working exploits.In addition, exploiting heap OOB write vulnerabilities requires knowledge about the kernel heap allocator. By leveraging this knowledge, we can exhaust the current cache (line 1 and 2 in Fig. 1b) to make sure it will ask for new pages in subsequent allocations, and then the vulnerable and target objects handled by the same cache could be allocated adjacent to each other (line 3 and 4 in Fig. 1b respectively). However, given that the heap allocator is deterministic and the fact that an attacker can always set up the heap layout ahead of time through a sequence of syscalls, it is almost always possible to arrange the memory to facilitate OOB write exploits (e.g., vulnerable and target objects adjacent to each other). As shown in Fig. 1b, we select Type3 as the target object since it has the same size of the vulnerable object (easier to perform heap feng shui) and has a function pointer in the first 8 bytes. Type4 on the other hand is not suitable for exploitation as its critical field (i.e., the data pointer sk) is not at the beginning.In the cases where the capability of a specific OOB vulnerability is limited, it is imperative to collect a diverse set of objects containing critical fields. To overcome KASLR, a separate information disclosure vulnerability is commonly used in practice; alternatively, recent CPU side channels such as Meltdown [36], Spectre [34], RIDL [54], and ZombieLand [46] can all accomplish this goal. This way, we simplify the search of exploitable states to the point where we only check whether the target object matches the extracted capabilities in a known memory layout (e.g., the vulnerable and target objects are laid out to be adjacent to each other). This modularity is an important distinction from prior work [44,55,57], where they either consider only the one-shot input exploits which inherently couple the capability and exploitability anal-ysis together (e.g., no additional interactions allowed to select target objects) [44,55], or implicitly consider capabilities by exploring different vulnerability points [57] in the context of kernel UAF vulnerabilities (perhaps due to the nature of this type of bugs). For ease of description, we state the following definitions:Definition 1 OOB write set. We denote the set of all paths as P, the set of all vulnerability points along the path p ∈ P is signified as N p , and the corresponding OOB write set is denoted as T p = {(off pi , len pi , val pi )|i ∈ N p ∧ off, len, val ∈ E}, where off and len denote the starting point of the OOB write relative to the address of the vulnerable object and how many bytes can be written, respectively, and val represents the overwritten values of an OOB write. The capability of p (a particular path) is denoted as C p = {size p , T p , f (p) | size p ∈ E}, where size stands for the size of the vulnerable object, and f (p) is the set of path constraints collected when executing p.We point out that each OOB access can be constrained due to the path constraints along the executed path. ∀e 1 , e 2 ∈ E, e 1 e 2 if e 1 is identical to e 2 or e 1 is a constant whose value can be taken in e 2 ∀p 1 , p 2 ∈ P, T p 1 i T p 2 i if off p 1 i off p 2 i ∧ len p 1 i len p 2 i ∧ val p 1 i val p 2 i ∀p 1 , p 2 ∈ P, C p 1 C p 2 if size p 1 size p 2 ∧ ∀i ∈ N p 1 T p 1 i T p 2 iWe observe that directly comparing symbolic expressions can be tricky as they have intrinsic relationships, especially when coupled with path constraints. Therefore, as shown in Fig. 4, if our system fails to produce a solution (failing to locate a suitable target object) with discovered capabilities, it searches for new PoCs that either extend the existing capabilities or uncover new ones, and then repeats the process of capability summarization and exploitability evaluation until we succeed or a pre-set timeout is triggered. This is because maximizing branch coverage is only a very loose approximation of discovering more OOB capabilities -it often prioritizes the wrong test programs to drive the fuzzing session (simply the ones that achieve new coverage and may not even trigger the OOB) and is insensitive to the actual OOB capabilities discovered. Compared to an existing capability C p 1 , a newly-extracted capability C p 2 is perceived as a new one if C p 2 C p 1 is false.Specifically, whenever a new test program is executed, we collect the concrete values of the OOB write set at runtime as the capability feedback (e.g., how many bytes are written and what values are written). Note that as depicted in Fig. 4, vulnerability analysis (see §4.1) is always performed before capability summarization, avoiding missing any OOB sites that KASAN fails to detect.In our design, we keep a balance of the test programs in the corpus. Fig. 5a depicts a generic model where one or more memory accesses overwrite the target object adjacent to the vulnerable one as we assume heap feng shui could manipulate the heap layout as desired (we illustrate the case where only one OOB write occurs but it generalizes to multiple OOB writes). When a single usage of one capability -which may already consist of multiple OOB accesses -cannot satisfy the requirements of a given target object, it does not necessarily mean it is useless because it is possible that the capability could modify only some portion of the target at a time (e.g., a single bit). Specifically, we perform the heap spray with three different system calls --add_key(), msgsnd(), sendmsg() --by following the techniques introduced in [58] to implement cache exhaustion, and insert the allocation and dereference functions of the chosen target at appropriate positions (see Fig. 2 in Appendix B for more details). As aforementioned, since our goal is to achieve the IP hijacking primitive rather than an end-to-end solution achieving arbitrary code execution (which may involve ROP/JOP to bypass SMEP), we explicitly consider these modern defenses (e.g., KASLR, SMEP) out of scope. It consists of 7,510 LOC of C++ to the S2E for capability summarization and exploitability evaluation, 2,271 LOC of python based on Angr to analyze vulnerabilities, and 1,106 LOC of Go to explore diverging paths with fuzzing and synthesize exploits. However, symbolic length is generally very poorly supported in symbolic execution engines, unlike symbolic indexes and values. In practice, there are several reasons we need to search for a solution among a range of OOB lengths which is best supported if we can handle symbolic length: (1) We often prefer a solution with minimum OOB length to avoid corrupting system data (which may lead to crashes). Specifically, given a summarized OOB write (off, len, val) where all elements are symbolic and the concrete length is 10, our system updates the memory object M with each byte individually as follows:for i in [0, 10]: M[ite(i < len, i+off, offset dummy )] = val[i]where ite represents an if-then-else expression supported by KLEE and Z3 [10], and offset dummy represents the offset of a dummy byte which we introduce to nullify the memory update of a specific byte. The underlying rationale is that memory indexes vary from run to run as the addresses of dynamically-allocated objects are unlikely to remain the same and thus concretizing symbolic indexes in memory access operations by adding a constraint confining the indexes forbids the solver to vary the indexes and unnecessarily over-constrain the search space. Similarly, imagine the argument n in Fig. 6 is a symbolic value (during symbolic tracing) and its concrete value is 64, the for loop increments 'i' for 64 times, resulting in 65 path constraints 0<n, 1<n, ..., 63<n and 64>=n that effectively forces n to be 64. Ideally, we should also obtain the knowledge pertaining to the usage of a target object, such as how to allocate it, how to trigger the deference of its critical data, etc. Out of all 28 distinct syzbot reports pertaining to heap OOB write, eight are not reproducible (i.e., no C code provided to test), eight are considered as one bug since they share the same patch, one is difficult to trigger since it requires fault injection to make the kernel fail to allocate the vulnerable object, one related to KVM already needs root privilege to trigger the vulnerability, one is in fact associated with a CVE (present in the other dataset and considered duplicate), and thus they are excluded from testing. By combining these two capabilities, it figures out a complex solution to manipulate the pointer to point to the kernel space, via leveraging the first capability to zero out a pointer and then setting one bit at a time. Given the concrete input shown in Fig. 7, the last two memcpy() invocations are flagged as two different vulnerability points (i.e., line 6 and 7), which constitute a 4-byte overflow. Though no security violation is reported at line 5, our system could still detect it as one potential OOB site by consulting the constraint solver against the following formula lenA + 4 > lenA + lenB + lenC? Specifically, imagine if the target object requires the size of the vulnerable object to be equal to 64, effectively reducing the length of bufA, the constraint solver would fail to produce a solution if we update the memory object with a concretized length of 120. Similarly, vulnerability 35f7d5225ffcbf1b759f that overflows 4 bytes of arbitrary values cannot be exploited if we want to modify an entire 8-byte pointer, yet our system produced a solution in which we only overwrite the 4 least significant bytes of a data pointer, resulting in a pointer residing in physmap region where we could control its content.CVE-2018-5703. Although our system identifies some satisfying target objects with reference counter, we fail to construct a working exploit due to the lack of knowledge regarding those target objects (e.g., how to allocate, how to trigger free, and how to trigger use) as aforementioned. We also attempted to compare our solution with the vanilla Syzkaller, and it fails to produce a desirable PoC for all four cases even after the 12-hour Time opt nop index tracing solving fuzzing CVE-2016-6187 2 0 2 38s 1s NA CVE-2017-7184 3 2 2 27s 45s 23m CVE-2017-7308 2 1 2 48s 4s NA CVE-2017-7533 1 0 0 160s 164s NA CVE-2017-1000112 2 2 2 36s 132s NA CVE-2018-5703 1 1 1 85s 41s 194m 813961de3ee6474dd570 2 2 2 34s 5s NA 35f7d5225ffcbf1b759f 2 2 2 34s 18s 8m bbeb6e4323dad9b5e0ee 2 2 2 48s 26s 23m eb73190f4fbeedf76239 1 1 1 54s 104s NA 4576cd469d980317c4ed 1 1 1 57s 7s NA nops: No constraint relaxing. A higher probability for selecting the seeds increasing coverage allows us to quickly explore uncovered code but it also slows down finding new seeds extending existing capabilities since uncovered code is mostly irrelevant and thus a substantial amount of seeds do no contribute given the large codebase of Linux kernel. Future work would be to explore different probability configuration and design approaches to dynamically adjust it during the fuzzing execution.Although we only consider defenses deployed in practice in this work, some fine-grained randomization based defenses [3,14,42] would break some of our assumptions in generating exploits (e.g., DieHard [14] and SLAB/SLUB freelist randomization [3] make heap feng shui much less predictable). PrimGen [23] leverages static analysis to discover useful primitives reachable from the vulnerability point and then applies symbolic execution to yield concrete inputs.In addition to these work dealing with vulnerabilities residing in user applications, Lu et al. [37] propose an automated targeted stack spraying approach to produce exploits for uninitialized uses in Linux kernel. Although we have parsed the debug information to extract all the possible candidates and leverage an LLVM pass to filter out those whose allocation sites are not reachable from the syscalls, we still heavily rely on our domain knowledge to construct the database of target objects. The Figure 11: An example of a configuration fed to capability extraction { "key": { // type: reference counter, data pointer, // function pointer, custom data "type": "reference counter", "offset": 0, // The offset to the target field "size": 192, // The value we want to overwrite with "payload": "\x00\x00\x00\x00", "original value": "\x01\x00\x00\x00" "allocate": // Allocate this object "s[0] = syscall(__NR_keyctl, 1, "keyring", 0, 0, 0); syscall(__NR_keyctl, 5, s[0], 0x3f3f3f3f, 0, 0);", // Trigger a dereference of the target pointer "dereference":"syscall(__NR_keyctl, 1, "keyring", 0, 0, 0); do_keyspray(); syscall(__NR_keyctl, 3, 0xfffffffffffffffd, 0, 0, 0);", // Number of objects allocated before the target object "#pre-object": 1 }} Figure 12: Database for target objects "layout" records the sizes of all the heap objects allocated during the execution of the syscall that allocates the vulnerable object, summarizing the side effect we have to cope with when performing heap feng shui. In this case where the syscall that allocates the vulnerable object and the one triggering OOB writes are the same, leaving no room for allocating the target object afterward, we thus proactively reserve three adjacent slots (line 27) for the vulnerable and target objects and one more competing for the memory as declared in the database (i.e., "#pre-object").