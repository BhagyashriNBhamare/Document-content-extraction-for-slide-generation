Finally, we discuss countermeasures against Bleichen-bacher attacks in TLS and recommend to deprecate the RSA encryption key exchange in TLS and the RSA PKCS #1 v1.5 standard. This allows the attacker to decrypt arbitrary ciphertext without access to the private key by using Bleichenbacher's algorithm for exploiting the PKCS #1 v1.5 format.Instead of upgrading to RSA-OAEP [29], TLS designers decided to use RSA PKCS #1 v1.5 in further TLS versions and apply specific countermeasures [2,17,34]. For example, Jager, Schwenk, and Somorovsky showed that the mere existence of a vulnerable implementation can be used cross-protocol to attack modern protocols like QUIC and TLS 1.3 that do not support RSA encryption based key exchanges [23]. Our work makes the following contributions:â€¢ We performed the first large-scale analysis of Bleichenbacher's attack and identified vulnerabilities in high profile servers from F5, Citrix, Radware, Palo Alto Networks, IBM, and Cisco, as well as in the open source implementations Bouncy Castle, Erlang, and WolfSSL. â€¢ Finally, we discuss the countermeasures proposed in TLS 1.2 [34] and whether it is feasible to deprecate RSA encryption based key exchanges.Responsible disclosure and ethical considerations.In collaboration with affected web site owners we responsibly disclosed our findings to vulnerable vendors. This key exchange is used in all cipher suites having names starting with TLS RSA (e.g. TLS RSA WITH AES 128 CBC SHA). PKCS #1 v1.5 padding format that allows an attacker to create valid messages with a high probability.We assume (N, e) to be an RSA public key, where N has byte-length (|N| = ), with corresponding secret key d = 1/e mod Ï† (N). The decryptor uses its private key to perform RSA decryption, checks the PKCS #1 v1.5 padding, and extracts message k. Bleichenbacher's attack allows an attacker to recover the encrypted plaintext m from the ciphertext c. For the attack execution, the attacker uses an oracle that decrypts c and responds with 1 if the plaintext starts with 0x0002 or 0 otherwise:O(c) = 1 if m = c d mod N starts with 0x0002 0 otherwise.Such an oracle can be constructed from a server decrypting RSA PKCS #1 v1.5 ciphertexts.Bleichenbacher's algorithm is based on the malleability of the RSA encryption scheme. By iteratively choosing new s, querying the oracle, and computing new To mitigate the attack it is important that the server always responds with the same alert message and does not provide any information about the PKCS #1 v1.5 validity.r values, the attacker reduces the possible solutions m, until only one is left or the interval is small enough to accommodate a brute force search. This can happen, for example, if the implementation strictly checks the PKCS #1 v1.5 format which prescribes that the first 8 bytes following 0x0002 are non-zero, or if the implementation strictly checks the length of the unpadded key. In order to create a signature with the server's private key, the attacker first uses a proper hash function and encoding to process the message. For example, when creating a PKCS #1 v1.5 signature for message M, the encoded result will have the following format [29]:EM = 0x0001 0xFF...FF 0x00 ASN.1(hash(M))hash() denotes a cryptographic hash function. The challenge of our research was to perform an effective scan using as few requests as possible, but allowing us to trigger all known vulnerabilities and potentially find new ones. This manual analysis allowed us to find new issues and extend further TLS scans which we applied to the Alexa Top 1 Million list.In the following sections we give an overview of our final scanning methodology. This message contains a correctly formatted PKCS #1 v1.5padding with 0x00 at a correct position and correct TLS version located in the premaster secret: M1 = 0x0002 pad() 0x00 version rnd [46] M1 should simulate an attacker who correctly guessed the PKCS #1 v1.5 padding as well as TLS version. This message starts with incorrect PKCS #1 v1.5 padding bytes:M2 = 0x4117 pad()The invalid first byte in the PKCS #1 v1.5 padding should trigger an invalid server behavior as described, for example, in the original paper [11].3. As described in Section 3.4, we say that the oracle is weak if the attacker can only identify valid messages starting with 0x0002 with a validly padded PKCS #1 v1.5 message with the 0x00 byte at the correct position (i.e., message M1 or M5). In order to minimize false positive results due to network conditions or unreliable servers, all servers presumed to be Figure 3: Our final scan considered different cipher suites, connection state, TLS alerts, and shortened protocol flow. This is especially important when detecting timeout based oracles.When testing with the shortened message flow, we found it necessary to set an appropriate socket timeout for the network path between scanner and target. For each vulnerable implementation the table provides information about different server responses triggered by valid and invalid ClientKeyExchange messages, the TLS protocol flow (full / shortened), the oracle type (strong / weak), and a CVE ID. Close analysis of F5 TLS stacks also revealed that some product configurations would send an extra TLS alert depending on the error type.Overall, we discovered five different variations of behavior on F5 hosts. Although Cisco did not reveal to us what products are used for these domains, our belief is that they are likely running out of support ACE devices within their network infrastructure.All cipher suites supported by these devices use the RSA encryption key exchange [14], making it impossible to mitigate this vulnerability by disabling it. Sending a ClientKeyExchange where the zero terminator of the padding was not at the right position led to a TLS alert 80 (internal error). Other errors made the server send a ChangeCipherSpec message.The vulnerability only appears if Bouncy Castle is using the JCE API in Java for cryptographic operations.Bouncy Castle offers an old API (org.bouncycastle.crypto.tls) and a new API (org.bouncycastle.tls). With the shortened message flow, we got a timeout for a correctly formatted message and errors for all messages that had any flaw in their structure (wrong PKCS #1 v1.5 prefix, zeros in the non-zero padding, missing padding zero terminator). Meyer et al. [28] have identified a vulnerability in Java / JSSE (CVE-2012-5081) that affects Oracle Java SE We found a small number of vulnerable hosts that we assume are these vulnerabilities, indicating that individuals or organizations still use unpatched versions of JSSE and MatrixSSL. The "Server" header is unreliable, as in many cases load balancers or security appliances are terminating TLS connections while the header information is generated by the HTTP server itself. The "X-Forwarded-For" header that is supposed to be used by such products is hardly used, as many developers of security appliances think that this information should be hidden.Based on our findings we must assume that more vulnerable products exist. Of particular importance is that this was prior to the availability of updated software for F5 appliances.However these scans did not test with varied cipher suites and therefore missed some vulnerable hosts which do not present with vulnerable behavior when a CBC cipher is negotiated. While our scan tool attempts to minimize inaccuracies by validating vulnerable responses, we have observed that certain non-deterministic behavior can still be falsely identified as vulnerable.According to these scans 22,854 hosts (2.3 %) were vulnerable among the www hosts. We assume that the reason for this low number of vulnerabilities overall is the correct mitigation implementation in OpenSSL, the most widely used TLS library.Among the top 100 domains according to Alexa 27 (thus 27 %) were vulnerable if we combine our best scan result with previous scans of hosts that were already fixed at that point. We try to detect a variety of signals given by the server and automatically adapt our oracle to it.For a successful attack we need many subsequent connections to a server. This has consequences for the impact of the attack.TLS supports different kinds of key exchanges with RSA: Static RSA key exchanges where a secret value is encrypted by the client and forward-secrecy enabled key exchanges using Diffie Hellman or elliptic curve Diffie Hellman where RSA is only used for signing. To attack a key exchange where RSA is only used for signatures, the attacker faces a problem: He could impersonate a server to a client, but in order to do this he has to be able to perform an RSA signature operation during the handshake. This is possible because an attacker can use the oracle from the vulnerable server to sign messages or decrypt static RSA key exchanges with www.example.com. Impersonation attacks are also possible against www.example.com provided there is some vulnerable service using an HTTPS certificate valid for www.example.com and the attacker is fast enough. It allows revoking certificates if one is able to sign a special revocation message with the private key belonging to a certificate.While this does not impact the security of TLS connections, it allows causing problems for web page operators that may see unexpected certificate validation errors. TLS 1.0 [2] proposed that when receiving an incorrectly formatted RSA block an implementation should generate a random value and proceed using this random value as the premaster secret. It is challenging to test and perform timing attacks over the public Internet due to random time differences based on network fluctuations.Meyer et al. have described some timing-based Bleichenbacher vulnerabilities [28]. Given the complexity of the countermeasures in the TLS standard it is very likely that yet unknown timing variants of Bleichenbacher vulnerabilities exist in many TLS stacks.We learned from Adam Langley that various TLS implementations may be vulnerable to timing attacks due to the use of variable-size bignum implementations. There has also been a push to deprecate finite field Diffie Hellman, because clients cannot practically require safe parameters from a server. Therefore server operators can disable RSA encryption based key exchanges and support Elliptic Curve Diffie Hellman exchanges for modern clients and finite field Diffie Hellman for old clients. By asking the affected users we learned that they all used the "Mail" app that came preinstalled on old Android 4 or in one case even Android 2 phones.The algorithm choices on Android depend on the app.On an Android 4.3 phone we were able to observe that the Mail app connected via TLS RSA WITH AES 128 CBC SHA. We would like to point out that OAEP is not fully resilient to padding attacks, see Manger [27] and Meyer et al. [28] for details.When using forward secrecy RSA can be used as a signature algorithm. Jager et al. [22] have shown Bleichenbacher vulnerabilities in XML encryption, Detering et al. have shown vulnerabilities in JSON / JOSE [16] and Nestlerode has discovered vulnerabilities in the Cryptographic Message Syntax (CMS) code of OpenSSL [31]. To our knowledge TLS-Attacker 3 and tlsfuzzer 4 had tests for Bleichenbacher vulnerabilities before our research started. A strict interpretation of the TLS standard demands that all RSA decryption failures are answered with a TLS alert 20 (bad record mac) after the Finished message.Tripwire IP360 added detection 6 for vulnerable F5 devices in ASPL-753 which was released in coordination with F5's public advisory. 7 Before our research, TLS-Attacker had implemented a basic Bleichenbacher attack evaluation with full TLS protocol flows. echo 799e43535a4da70980fada33d0fbf51ae60d32 c1115c87ab29b716b49ab0637733f92fc985f28 0fa569e41e2847b09e8d028c0c2a42ce5beeb64 0c101d5cf486cdffc5be116a2d5ba36e52f4195 498a78427982d50bb7d9d938ab905407565358b 1637d46fbb60a9f4f093fe58dbd2512cca70ce8 42e74da078550d84e6abc83ef2d7e72ec79d7cb 2014e7bd8debbd1e313188b63a2a6aec55de6f5 6ad49d32a1201f18082afe3b4edf02ad2a1bce2 f57104f387f3b8401c5a7a8336c80525b0b83ec 96589c367685205623d2dcdbe1466701dffc6e7 68fb8af1afdbe0a1a62654f3fd08175069b7b19 8c47195b630839c663321dc5ca39abfb45216db 7ef837 | xxd -r -p > sig curl https://crt.sh/?d=F709E83727385F514321 D9B2A64E26B1A195751BBCAB16BE2F2F34EBB08 4F6A9|openssl x509 -noout -pubkey > pub key.key openssl rsautl -verify -pubin -inkey pubkey.key -in sig