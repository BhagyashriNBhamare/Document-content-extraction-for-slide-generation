Unlike the web, where mechanisms such as TLS protect data integrity and allow experts to reason about the identity of a website, the modern telephony infrastructure simply provides no means for anyone to reason about either of these properties.In this paper, we present AuthentiCall, a system designed to provide end-to-end guarantees of authentication and call content integrity over modern phone systems (e.g., landline, cellular, or VoIP). Most critically, AuthentiCall provides these guarantees for standard telephone calls without requiring changes to any core network.Our work makes the following contributions: • Designs Channel Binding and Authentication Protocols: We design protocols that bind identities to phone numbers, mutually authenticate both parties of a phone call, and protect call content in transit. • Evaluates Call Performance in Real Networks: Our prototype implementation shows that the techniques pioneered in AuthentiCall are practical and performant, adding at most only 1.4 seconds to phone call establishment in typical settings.We are not the first to address this problem [2,9,17,21,43,47,56,77]. The remainder of this paper is organized as follows: Section 2 provides background information about the challenges underlying authentication in telephony networks; Section 3 describes our assumptions about adversaries and our security model in detail; Section 4 gives a formal specification of the AuthentiCall system; Section 5 discusses how analog speech digests can be used to achieve call content integrity; Section 6 provides details of the implementation of our system; Section 7 shows the results of our experiments; Section 8 offers additional discussion; Section 9 analyzes related work; and Section 10 provides concluding remarks. There is no simple solution as calls regularly transit multiple intermediate networks between the source and destination.It is increasingly common that modern phones have simultaneous access to at least low-bitrate data channels. VoIP phones naturally have a secondary data channel, the majority of mobile phones allow users to both talk and use data networks simultaneously, and even some circuitswitched connections (e.g., ISDN) provide phones with a data connection. This adversary can act as a man-inthe-middle, and is therefore capable of redirecting calls to an arbitrary endpoint, acting as an arbitrary endpoint, hanging up one side of a call at any point in time, and removing/injecting audio to one or both sides. Given that the bitwise encoding of audio is unlikely to be the same at each endpoint, end-to-end encryption is not a viable means of protecting call content or integrity across the heterogeneous telephony landscape. Moreover, while we argue that the majority of phones have access to at least a low-bandwidth data connection, solutions that demand high-speed data access at all times (i.e., pure VoIP calls) do not offer solutions for the vast majority of calls (i.e., cellular calls). (G4) Integrity Protection of Call Content: R and E will be able to verify that the analog voice content has not been meaningfully altered, or that new content has not been injected by a man in the middle. Although there are risks of adding a centralized point on a distributed infrastructure, our design minimizes them by distributing identity verification to a certificate authority and only trusting a central server to act as a meeting point for two callers. We also assume that all communications between clients and servers use a secure TLS configuration with server authentication.Our protocols have another goal: no human interaction except for choosing to accept a call. (1)Data Channel Audio Channel N N et , ID(C), PhNum(C), ID(S CA ), PhNum(S CA ), T S ID(C), PhNum(C), ID(SCA), K + C NAudio NAudio, NNet, ID(C), PhNum(C)ID(SCA), TS, Sign k 񮽙 C Cert(ID(C), PhNum(C), K + C , Sign K 񮽙 S CA ) (2) (3) (4)(5)Figure 3: Our enrollment protocol confirms phone number ownership and issues a certificate. In message 2, the server sends a nonce N Net , the identities of C and S CA and the phone numbers of C and S CA with a timestamp to ensure freshness, liveness, and to provide a "token" for this particular authentication session.In message 3, the server begins to confirm that C controls the phone number it claims. 2 Using a voice call is important because it will work for any phoneincluding VoIP devices that may not have SMS access.In message 4, C sends both N Net and N Audio along with the IDs of server, clients, a timestamp, and a signature covering all other fields. While the protocol is secure in the presence of passive adversaries on both the data and voice networks, if an adversary can actively intercept a call addressed to a victim phone number (and also supply any out-of-band identity confirmation), they may be able to obtain a certificate for a number they illicitly control. To further protect against the prior attack, our protocol meets an additional goal: human interaction is not required for enrollment and confirming control of the claimed phone number. (1) Call PhNum(E) E 2 AuthentiCall Users Incoming call from R ID(E), PhNum(E), ID(R), PhNum(R) Cert(E), TS2, NE, DHE, Sign K 񮽙 E HMACK ER1 (msg 4a , msg 4b , "Caller") HMACK ER2 (msg 4a , msg 4b , "Callee") Server (S) Caller (R) Callee (E) (2) (3) (4a) (4b) (5a) (5b)TLS to Server Voice Call Message via Server TLS ID(R), PhNum(R), ID(E), PhNum(E) Cert(R), TS1, NR, DHR, Sign K 񮽙 R Figure 4: Our handshake protocol mutually authenticates both parties.connected to S via TLS, meaning S has properly authenticated itself to C. However, this presents a problem: if an adversary tampers or blocks messages from E, it prevents E from participating in the handshake, and R would have to assume (in the absence of outside knowledge) that E is not a participant in AuthentiCall. 4 These messages areServer (S) Caller (R) Callee (E) (0a) (0b) (1a)(1b)Voice Call Message via Server TLS "Call Ended", TS3, ID(R), ID(E)HMACK ER (ID(R), ID(E), TS3, "Call Ended") (Na) (Nb) "Call Ended", TS4, ID(E), ID(R) HMACK ER (ID(E), ID(R), TS4, "Call Ended"). . . . . ."Call Connected", TS1, ID(R), ID(E) HMACK ER (ID(R), ID(E), TS1, "Call Connected") "Call Connected", TS2, ID(E), ID(R) HMACK ER (ID(E), ID(R), TS2, "Call Connected") EncK ER (Index, Audio Digest 1 , AuD2...AuD5),HMACER(EncK ER (P receding))EncK ER (Index, Audio Digest 1 , AuD2...AuD5),HMACER(EncK ER (P receding))Figure 5: Our call integrity protocol protects all speech content.designed to prevent attacks where a call is redirected to another phone. In order to prevent redirection attacks, the messages are bound to the identities of the communicating parties by including the IDs in the HMACs and by using keys for the HMACs that are unique to the call.When the voice call ends, each side sends a "call concluded" message containing the client IDs, a timestamp, and their HMAC. This means that common data digest approaches like cryptographic hashes will fail.While the original phone system used analog transmission of voice, it is now common in every telephone network (landline, VoIP, cellular, etc.) for speech to be digitized and compressed using an audio codec. There are a number of constructions of speech digests, and they all use the following basic process. Finally, to our knowledge we are the first to use any robust speech digest for an authentication and integrity scheme.For space reasons, and because we do not claim the design of the RSH digest as a research contribution, we provide a detailed description of the actual computation of an RSH digest in Appendix A. However, the remainder of this subsection will provide details necessary for the rest of this paper. We also describe how we use digests to detect tampered audio.We implement RSH using Matlab, and we deploy it in our AuthentiCall prototype by using the Matlab Coder toolbox to generate C code that is compiled as an Android native code library. For this test, we use the same key for every hash; this models the situation where an adversary can cause the target to receive audio of its choice but not modify the associated digest.We find that the mean BER between two distinct audio pairs is 0.478. At a BER detection threshold of 0.384 (derived and discussed in the following subsection), the detection rate for different content spoken by the same speaker is 0.901482, while the detection rate for different content spoken by a different speaker is 0.901215. This corresponds to an individual adversary audio true positive detection rate of 0.90, while presenting a 0.0058 false positive rate against our "worst-case" audio and a 0.00089 false positive rate against clean GSM-FR encoded audio. Audio digests will detect the first scenario within five seconds of audio, and it will also quickly detect changes that effect any three seconds in five for the second scenario.In limited circumstances, it may be possible for a man-in-the-middle adversary to make small modifications to the received audio. While voice modification algorithms exist (e.g., Adobe VoCo [10] and Lyrebird [11]), modifying an existing sentence in an ongoing conversation is beyond the abilities of current natural-language processing. In this section, we describe our AuthentiCall client and server implementation, and in the following section evaluate its performance.Server: Our server was implemented in Java, using Twilio's Call API to call clients during the registration phase to share the audio nonce that confirms control of a phone number. Google Cloud Messaging (GCM) is used to generate a push notification to inform clients of incoming calls.Client: Our prototype AuthentiCall client consists of an Android app, though we anticipate that in the future AuthentiCall will be available for all telephony platforms, including smartphones, VoIP phones, PBXs, and even landlines (with additional hardware similar in concept to legacy Caller ID devices that uses a wireless or wired LAN data connection). This consists of a user's claimed identity, phone number, validity, public key and signature of the CA.Audio Nonces: As described in Section 4, the AuthentiCall enrollment protocol sends a nonce through the voice channel to ensure that an client can receive a voice call. The enrollment and handshake experiments were carried out 20 times over both WiFi and 3G, and digest exchange 5 Dual-Tone Multi-Frequency tones are the sounds made by dialing digits on a touch-tone phone. As shown in Figure 10, AuthentiCall only adds 1.07 seconds for WiFi or 1.41 seconds on 3G data to the total call establishment time (error bars indicate standard error). Upon further investigation, we learned that our audio was being transmitted using the AMR-NB codec set to the lowest possible quality setting (4.75kbps); this configuration is typically only used when reception is exceptionally poor, and we anticipate this case will be rare in deployment. AuthentiCall offers a strong method to authenticate users over the phone, increasing security while reducing the authentication time and effort.Another valuable use case is emergency services, which have faced "swatting" calls that endanger the lives of first responders [73] as well as denial of service attacks that have made it impossible for legitimate callers to receive help [8]. In this scenario, certificate lifetime would be determined by the TPKI, which would also issue a certificate revocation list.Why IP data: We chose IP data over other channels because it provides reliable and fast data transmission for most existing devices including smartphones, VoIP phones, and even landlines if provided with suitable hardware. By contrast, audio digests are speaker independent and can be computed locally with no additional knowledge about the other party.Denial of Service Adversaries may attempt to break the security of AuthentiCall by selectively dropping protocol messages, but AuthentiCall can detect these attacks and fail to complete a call or end an in-progress call. During the integrity protocol, the client can enforce tight timeouts of all messages and alert the user of an attack if expected messages do not arrive.User Interface We have developed a complete working prototype of AuthentiCall for Android, including a preliminary simple user interface as shown in Figure 12. In the case of the former, researchers have explored a wide range of solutions: blacklists of phone numbers [6,44,52], call-back verification [47], channel characterization [57], call data analysis [35,45,48,58], carrier level ID extraction [68], timing [47], call provenance [17], name registries [22] and biometrics [14,19,27,37]. Given the increasing number of attacks on machine learning algorithms [33,49,50], such techniques offer uncertain security properties.As for cryptographic solutions, most have been VoIPonly (e.g., Zfone and Redphone) [2,9,21,43,77]. This protocol is not end-to-end (so the protocol is vulnerable to malicious network endpoints like IMSI-catchers [23,24]), requires both endpoints to call from an SS7-speaking network, and most importantly would also require modifying core network entities throughout every network.The solution closest to our own is Authloop [56]. These blocks B 1 and B 2 contain all columns from l 1 : l 1 + w and l 2 : l 2 + w respectively. In AuthentiCall, digests themselves are also authenticated using an HMAC to guarantee digest integrity in transit.Digests of spoken audio are sent by both parties. We begin by computing the probability that in any particular trial, the r-th row is not covered by at least one of the two blocks B 1 , B 2 used in the robust hashing algorithm. To build some intuition for these probabilities, take N = 200 and w = 51 (the average value if w were selected uniformly from its range), Pr X (i) 1 = 0 ≤ 0.98, i.e., the first row is almost certainly not covered in any particular trial. But this quickly decreases as r grows, and when r = w (and beyond) we have Pr X Again, when N = 200, w = 51,t = 64, we have E[X |W = 51] ≥ 198.4; on average, the number of rows missed is less than two.