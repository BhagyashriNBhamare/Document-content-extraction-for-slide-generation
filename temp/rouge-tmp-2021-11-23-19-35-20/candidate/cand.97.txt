We present WPSE, a browser-side security monitor for web protocols designed to ensure compliance with the intended protocol flow, as well as confidentiality and integrity properties of messages. Out of 90 tested websites, we identify security flaws in 55 websites (61.1%), including new critical vulnerabilities introduced by tracking libraries such as Facebook Pixel, all of which fixable by WPSE. Popular examples of web protocols include OAuth 2.0, OpenID Connect, SAML 2.0 and Shibboleth, which are routinely used by millions of users to access security-sensitive functionalities on their personal accounts.Unfortunately, designing and implementing web protocols is a particular error-prone task even for security experts, as witnessed by the large number of vulnerabilities reported in the literature [43,6,5,50,28,27,48,46]. For example, in the context of OAuth 2.0, Bansal et al. [6] discussed token redirection attacks enabled by the presence of open redirectors, while Fett et al. [19] presented state leak attacks enabled by the communication of the Referer header; these attacks are not apparent from the protocol specification alone, but come from the subtleties of the browser behaviour.Major service providers try to aid software developers to correctly integrate web protocols in their websites by means of JavaScript APIs; however, web developers are not forced to use them, can still use them incorrectly [47], and the APIs themselves do not necessarily implement the best security practices [43]. 1 The design of web protocols comes with various security challenges which can often be attributed to the presence of the web browser that acts as a non-standard protocol participant. We focus on the authorization code mode and the implicit mode since they are the most commonly used by websites.The authorization code mode is intended for a RP whose main functionality is carried out at the server side. RP makes a request to IdP with the authorization code, including its identity, the redirect URI and optionally a shared secret with the IdP; IdP answers with an access token to RP;7 RP makes a request for the user's resource to IdP, including the access token;8 IdP answers RP with the user's resource at IdP.The implicit mode differs from the authorization code mode in steps 4 -6 . Next, A creates a page on her website that, when visited, automatically triggers a request to the redirect URI of RP and includes the authorization code. If the page loaded at the redirect URI in step 4 loads a resource from a malicious server, the state parameter and the authorization code (that are part of the URL) are leaked in the Referer header of the outgoing request. Protocol participants are typically expected to perform a number of runtime checks to prove the integrity of the messages they receive and ensure the integrity of the messages they send, but the browser cannot perform these checks unless they are explicitly carried out in a JavaScript implementation of the web protocol.Example in OAuth 2.0. Suppose that RP supports SSO with various identity providers and uses different redirect URIs to distinguish between them. In this case, an attacker controlling a malicious identity provider AIdP can confuse the RP about which provider is being used and force the user's browser to login as the attacker.To this end, the attacker starts a SSO login at RP with an honest identity provider HIdP to obtain a valid authorization code for her account. The protocol specification is given in XML (cf. Appendix A), but for the sake of readability, we use in this paper an equivalent representation in terms of finite state automata, like the one depicted in Figure 2. We represent HTTP(S) requests as ea, where e is the remote endpoint to which the message is sent and a is a list of parameters, while HTTP(S) responses are noted e(h), where e is the remote endpoint from which the message is received and h is a list of headers. To incorporate secrecy and integrity policies in the automaton, we allow for binding parts of message patternsinit start auth access end φ 1 ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 2 :: π S ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 3 ∧ π I ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 1 Gresponse type:code, redirect uri:^( origin (https? For instance, in Figure 2 we require that the value of the authorization code, which is bound to the identifier authcode introduced in φ 2 , can be disclosed only to Google (at https://accounts.google.com) and the relying party (bound to the identifier origin). When the automaton detects an HTTP(S) request including one of the generated placeholders, it replaces the latter with the corresponding original value, but only if the HTTP(S) request is directed to one of the origins which is entitled to learn it. Since the substitution of confidential message components with placeholders changes the content of the messages, potentially introducing deviations with respect to the transition labels, the automaton processes HTTP(S) responses before stripping confidential values and HTTP(S) requests after replacing the placeholders with the original values. if WPSE is enforcing a protocol P i , it must block any message which may be part of another protocol P j , otherwise it would be trivial to sidestep the security policy of P i by first making the browser process the first message of P j . Notice that the semantics of WPSE depends on the order of P 1 , . . . , P n , due to the way we enforce determinism on the compiled automaton: if P i starts with a request to u including two parameters a and b, while P j starts with a request to u including just the parameter a, then P i should occur before P j to ensure it is actually taken into account. We empirically show that this is enough to support existing protocols like OAuth 2.0 and SAML, but other protocols may require more flexibility.Dynamic information flow control deals with the problem of letting programs compute over secret values while avoiding confidentiality breaches and it has been applied in the context of web browsers [21,26,8,36,7]. Protocol flow deviation Session swapping [43] Social login CSRF on stateless clients [6] IdP mix-up attack (web attacker) [19] Secrecy violation Unauthorized login by authentication code redirection [6] Resource theft by access token redirection [6] 307 redirect attack [19] State leak attack [19] Integrity violation Cross social-network request forgery [6] Na¨ıveNa¨ıve RP session integrity attack [19] Table 1: Overview of the attacks against OAuth 2.0. After step 4, the request to the attacker's website is sent, but the monitor does not replace the placeholder with the actual value of the authorization code since the secrecy set associated to authcode in π S does not include the domain of the attacker. The malicious service provider replies to C by providing a redirection address containing a different resource URI, thus causing the browser to send URI i instead of instead of URI as the value of RelayState at steps 2 , 4 . Since Google can act as a Service Provider (SP) with a third party IdP, an attacker registered to a given IdP can simulate a login attempt with his legitimate credentials to obtain a valid POST request to the Google assertion consumer service (step 4). Once accessed, a malicious web page can then cause a victim's browser to issue the attacker's request to the Google assertion consumer service, thus forcing the victim inside the attacker's controlled authenticated session.The vulnerability can be exploited by any web attacker with a valid account on a third party IdP that uses Google as SP. An example of such an attack against OAuth 2.0 is the automatic login CSRF attack presented in [6], which exploits the lack of CSRF protection on the login form of the relying party to force an authentication to the identity provider. This class of attacks can be prevented by implementing appropriate defenses against known web attacks;2. The goal of the present section is assessing the practical security benefits offered by WPSE on existing websites in the wild, as well as to test the compatibility of its browser-side security monitoring with current web technologies and programming practices. Our analysis is not meant to provide a comprehensive coverage of the deployment of OAuth 2.0 on the web, but just to identify a few popular identity providers and their relying parties to carry out a first experimental evaluation of WPSE.We started from a comprehensive list of OAuth 2.0 identity providers 6 and we collected for each of them the list of the HTTP(S) endpoints used in their implementation of the protocol. Finally, we created a dataset of 90 websites by sampling 30 relying parties for each identity provider, covering both the authorization code mode and the implicit mode of OAuth 2.0. More in detail, we identified 41 websites that do not support it, while the remaining 14 websites miss the security benefit of the state parameter by using a predictable or constant string as a value. For instance, according to the Google documentation, 11 the state parameter can be used "for several purposes, such as directing the user to the correct resource in your application, sending nonces, and mitigating cross-site request forgery": we believe that this description is too vague and opens the door to misunderstandings. Here we provide an intuitive description of the formal result, referring the interested reader to [15] for a complete account.The formal result states that given a web protocol that is proven secure for a set of network participants and an uncorrupted client, by our monitoring approach we can achieve the same security guarantees given a corrupted client (e.g., due to XSS attacks). Assume that the following conditions hold:(H1) S orig P ('S orig satisfies P') (H2) M ↓ bs in , bs out S orig ↓ bs in , bs out ('the set of requests/responses on bs in ,bs out allowed by M are a subset of those produced by S orig ') (H3) M does not leak any secrets (i.e., messages initially unknown to the attacker) on ba outThen it also holds that:(C) S new P ('S new satisfies P'). Formally this is captured by projecting the execution traces of the corresponding processes to those components that model the input and output behavior on bs in and bs out and by requiring that for every such execution trace of M there is a corresponding one for S orig . Second, the theorem demonstrates that enforcing the three security properties identified in Section 2 does indeed suffice to protect web protocols from a large class of bugs and vulnerabilities on the browser side: (H2) captures the compliance with the intended protocol flow as well as data integrity, while (H3) characterizes the secrecy of messages.Finally, the three hypotheses of the theorem are usually extremely easy to check. Akhawe et al. used the Alloy framework to develop a core model of the web infrastructure, geared towards attack finding [2]. Fett et al. developed the most comprehensive model of the web infrastructure available to date and fruitfully applied it to the analysis of a number of web protocols, including BrowserID [17], SPRESSO [18] and OAuth 2.0 [19]. The focus of their paper, however, is not on web protocols and is only limited to JavaScript, because input/output operations which are not JavaScript-initiated are not exposed to their security monitor.Guha et al. also used finite state automata to encode web security policies [24]. In the end, we conclude that the browser-side security monitoring of web protocols is both useful for security and feasible in practice.As to future work, we observe that our current assessment of WPSE in the wild only covers two specific classes of vulnerabilities, which can be discovered just by navigating the tested websites: extending the analysis to cover active attacks (in an ethical manner) is an interesting direction to get a better picture of the current state of the OAuth 2.0 deployment. Finally, we plan to identify automated techniques to synthesize protocol specifications for WPSE starting from observable browser behaviours in order to make it easier to adopt our security monitor in an industrial setting.A Sample XML Specification Figure 5 shows the XML specification of the OAuth 2.0 automaton in Figure 2.