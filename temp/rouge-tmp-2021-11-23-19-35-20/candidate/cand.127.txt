Ethereum, the second largest cryptocurrency next to Bitcoin, is the first to provide a Turing-complete language to specify transaction processing , thereby enabling so-called smart contracts. We perform a large-scale analysis of all 38,757 unique Ethereum contracts, 815 out of which our tool finds working exploits for-completely automated. In particular, we identify four critical, low-level EVM instructions that are necessarily involved in a value transfer: One used to create regular transactions (CALL), one for contract termination (SELFDESTRUCT), and two that can allow for code injection (CALLCODE, DELEGATECALL). Most notably we show how to handle hash values symbolically, which are used extensively in smart contracts.To demonstrate the utility of our methodology, we finally perform a large-scale analysis of 38,757 unique contracts extracted from the blockchain. TEETHER finds exploits for 815 (2.10%) of those-completely automated, without the need for human intervention or manual validation, and not requiring source code of contracts. We develop a tool TEETHER that provides end-toend exploit generation from a contract's bytecode only. Ethereum is often described as a second-generation blockchain, due to its support of so-called smart contracts-accounts controlled only by code which can handle transactions fully autonomously. While some attempts have been made to create "updatable" contracts that only act as a front-end and delegate actual execution to another, updatable contract address, in most cases creating a new contract with updated code and transferring funds is the only option-given that funds can still be reclaimed from the old contract 2 . Furthermore, especially the fully automated creation of exploits allows to easily validate whether the found vulnerabilities are actually real-an important step to show the effectiveness and accuracy of any bug finding mechanism.A fundamental downside of largely anonymous blockchain networks like Ethereum, however, is that we cannot reach out to owners of vulnerable contracts. From such vulnerable contracts, an attacker can steal all (or at least parts of) the Ether stored in them, which can result in a total loss of value for the contract owner.We now describe how one can identify such vulnerabilities in Ethereum contracts. in offset, in size, out offset, out sizememory location and length of call data respectively returned data.Thus, if an attacker can control the second stack argument (to) when a CALL instruction is executed with a non-zero third stack argument, they can cause the contract to transfer value to an address under their control. DELEGATECALL does 1 PUSH20 <attacker−controlled address> 2 SELFDESTRUCT Figure 2: EVM "shellcode" the same, but persists the original values of sender and value, i.e., instead of creating a new internal transaction, it modifies the current transaction and "delegates" handling to another contract's code. A contract is in a vulnerable state, if a transaction can lead to the execution of a critical path.We will call a transaction that exploits a contract in vulnerable state by one of the critical instructions as a critical transaction. A contract is vulnerable if there exists a (possibly empty) sequence of state changing transactions that lead to a vulnerable state.From this it immediately follows that a successful exploit always consists of a sequence of state changing transactions followed by a critical transaction. The path generation module explores paths from the root of the CFG leading to these instructions, from which the constraint generation module creates a set of path constraints through symbolic execution. Here, the JUMP instruction is used similar to x86's ret instruction, to resume execution at a "return address" that the caller pushed on the stack before the function call.To address this, TEETHER uses backward slicing to iteratively reconstruct the CFG. This process is repeated until no new edges are found and all jump instructions marked as resolved.In the example in Figure 5, two backward slices can be found for the JUMP instruction at address 19, (PUSH1 0b) and (PUSH1 15), which allows to introduce two out-edges for basic block 17, 17 → b and 17 → 15. E.g. the path 0 → 4 → 17 → 15, while seemingly plausible from the CFG, can never occur in an actual execution, as the edge 17 → 15 can only be taken if 17 was entered from d.To reduce the number of invalid paths considered in further analyses, TEETHER uses an approach we call dependent edges. Referring to Figure 5, the path 0 → 4 → 17 may only be extended via 17 → b. Likewise, in a backwards exploration these annotations form a set of path requirements, restricting the exploration to subpaths that can still reach all required basic blocks. As we require that this argument is potentially attacker controlled, slices are then filtered for those containing instructions whose results can be directly (ORIGIN, CALLER, CALLVALUE, CALLDATALOAD, CALLDATASIZE, CALLDATACOPY) or indirectly (SLOAD, MLOAD) controlled by an attacker.Each of the remaining slices defines an instruction subsequence of a critical path. Fixed-size elements, such as the call value or the caller's address are modelled using fixed-size bitvector expressions, variable-length elements, such as the call data, the memory, and the storage are modeled using Z3's array expressions.Whenever a conditional branch (JUMPI) is encountered whose condition µ s [1] is a symbolic expression, both the jump target and the fall through target are compared to the next address defined by the given path, and a new constraint of the form µ s [1] = 0 respectively µ s [1] = 0 is added accordingly. sender.transfer(this.balance); 7 } Figure 6: Infeasible Paths Example path, the value of x at line 5 will always be a concrete value and, since the path skipped the assignment in line 3, will have value 0. Since such mappings are a common data structure in Ethereum contracts, TEETHER needs to be able to reason about such storage accesses, which requires a symbolic modeling of the SHA3 instruction.To this end, whenever we want to symbolically execute a SHA3 instruction, we introduce a new symbolic 256-bit variable to model the result of the Keccak-256 computation. TEETHER will execute this using assignments of the formµ m [a + i] ← If(i < l, I d [b + i], µ m [a + i])where a = µ s [0], b = µ s [1], and l = µ s [2]. The final output of the constraint generation module for a given path p is a tuple R p = (µ, S, I,C, H, M), where µ is the symbolic machine state after execution S is the symbolic storage of the contract after execution I is the symbolic environment in which path p is executed C is a set of constraints that must be fulfilled to execute path p H is a mapping of Keccak-256 result variables to their respective input data M is a mapping of symbolic read objects to their address, length, and memory state We assume that both µ and S also capture the entire history of the respective states after every instruction. A path sequence v may read from the storage modifications made by a path p iff there exists a write to address e in p and a read from address f in v such that either H p [h e ] = H v [h f ] . If a path sequence with satisfiable combined path constraints is found, this module will output a list of transactions that lead to exploitation of the smart contract. As value is specified by the third stack argument to CALL, formally this givesµ * s [2] > n ∑ i=0 I p i v Having assembled the combined path constraints of a path sequence, including their state inter-dependencies and the attacker's goals, the next step is to find a satisfying assignment, which will give us concrete values to build the transactions required for successful exploitation. Yet we cannot simply pass our set of collected constraints as is, as the constraint solver is unaware of the special semantics of Keccak-256 results and symbolic-read objects.To overcome this problem we apply the iterative approach shown in Figure 7. As long as this queue is non-empty, we compute the subset D of constraints that is not dependent on any of the variables in Q and use a constraint solver to H) in the assignment A. This process is repeated until all variables are resolved.Q ← H ∪ M A ← / 0 while Q > 0 do D ← {c ∈ C|Vars(c) ∩ Q = / 0} A ← Sat(D) for all x ∈ Q do if x ∈ H then e ← H[x] if e ∩ Q = / 0 then v e ← A(e) v x ← Keccak-256(v e ) C ← C ∪ {e = v e , x = v x } Q ← Q \ {x} end if else if x ∈ M then a, l, µ m ← M[x] if (Vars(a) ∪ Vars(l)) ∩ Q = / 0 then v a ← A(a) v l ← A(l) v x ← A(µ m [v a : v a + v l ]) C ← C ∪ {a = v a , l = v l , x = v x } Q ← Q \ {x}The key insight here is that, since the mappings H and M define dependencies between the elements of H and M and the variables involved in their corresponding expressions, they also implicitly define a topological ordering on H and M. Furthermore, as these mappings can never define a cycle, this ordering is well-defined. The network is then run using the unmodified official Ethereum Go client [5], whose scripting interface will also be used to submit the exploit transactions.To reduce computation time by allowing tests on several non-unique contracts at once, we computed the exploit assuming that the contract's storage was set to zero. However, as Solidity does not provide a special keyword to mark the constructor, functions that were meant to be constructors can become regular functions due to ignoring case-sensitivity, spelling mistakes, or oversight during refactoring operations such as renaming. While vulnera- : Flawed onlyOwner modifier bilities due to logic flaws are also common in other domains, others could be prevented through modifications of Solidity. This problem could be alleviated by performing additional checks to match SLOAD and MLOAD to previous writes to create a more precise definition of critical paths, thereby limiting the number of paths considered. This allows us to combine the analysis of contracts that share the same code, reducing the number of tool runs from 784,344 to only 38,757 and has reduced the overall runtime by roughly factor 20. Validation is then often as easy as executing the exploit transactions and checking the final balance.Atzei et al. [7] provide a survey on attacks against Ethereum smart contracts, giving a taxonomy and discussing attacks and flaws that have been observed in the wild. In a similar vein, several works consider the problem of designing good contracts, e.g. Mavridou et al. [21] or Chen et al. [12]. Finally, a policy violation found by ZEUS does not imply practical exploitability of the contract in question, whereas our tool outputs exploits that can be easily validated.Finally, Breidenbach et al. [10] proposed using bug bounties to incentivize security analyses of smart contracts. Huang et al. [17] extends the considered attack surface by including the operating system and libraries a compiled binary uses at runtime, and work by Hu et al. [16] considers non-control-flow hijacking exploits by modelling data-oriented exploits.While all of these share the general idea of symbolic execution, constraint generation, and resolution to generate an exploit-as does the work presented hereinthere are major differences. TEETHER produces the following exploit in 26.74 seconds:-------------------------------------------------Transaction 1 -------------------------------------------------from: 0x0123456789abcdef0123456789abcdef01234567 to: 0x4000000000000000000000000000000000000000 data: c57c 5f60 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 value: 0 -------------------------------------------------Transaction 2 -------------------------------------------------from: 0x0123456789abcdef0123456789abcdef01234567 to: 0x4000000000000000000000000000000000000000 data: c407 6876 0000 0000 0000 0000 0000 0000 0123 4567 89ab cdef 0123 4567 89ab cdef 0123 4567 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0de0 b6b3 a764 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 value: 0The first transaction of this exploit calls function initMultiowned (c57c5f60) with all-zeros as arguments, i.e., an empty owners-array and 0 as required.