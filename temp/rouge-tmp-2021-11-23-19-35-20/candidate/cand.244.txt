Using a combination of manual analysis and black-box testing, we discovered 18 types of evasion exploits and tested them against 10 popular email providers and 19 email clients-all of which proved vulnerable to various attacks. Absent knowledge of our attacks, for many of them even a conscientious security professional using a state-of-the-art email provider service like Gmail cannot with confidence readily determine, when receiving an email, whether it is forged. Modern software systems are commonly built using components made by different developers who work independently.While having wide-ranging benefits, the security research community has recognized that this practice also introduces security concerns. To combat email spoofing, modern email servers employ several SMTP extensions-SPF, DKIM, and DMARCto authenticate the sender's purported identity, as the basis for displaying in email clients assurances of validity to users when they read messages. SMTP's original specification lacked mechanisms to authenticate the sender's identity, enabling any Internet host to impersonate another's identity by sending spoofed emails. If either HELO or MAIL FROM check fails, the mail server enforces the policy specified by domain owner (e.g., hard fail, soft fail) to reject the message.One major problem of SPF is incompatibility with mail forwarders. SPF authenticates the HELO/MAIL FROM identifier and DKIM authenticates the d= field in DKIM-signature header: neither of them authenticates the From header displayed to the end-user, which means that even if an email passes SPF and DKIM validation, its From address can still be forged. The exploited email providers may automatically attach DKIM signatures to their outgoing emails, enabling the attackers to impersonate other users of the email provider.In this work we assume that 1) the targeted legitimate sites configure SPF/DKIM/DMARC mechanisms correctly, and 2) the target email services reject emails that fail DMARC authentication. To achieve this goal, an email system should provide the following basic security requirement: The end-user Bob who uses email client C to receive an email from receiving server R can determine that the message is indeed from user Alice of sending server S, if and only if: (1) The From header of the email that S sends matches the authenticated username (other users of S cannot spoof Alice's address); (2) SPF/DKIM/DMARC components in R can obtain S's DNS correct policy; (3) SPF/DKIM and DMARC components in R consistently authenticate the same identifier; (4) the identifier that R authenticates is consistent with the identifier that C shows to Bob.Challenges in preserving the requirement. Our analysis followed a behavior-oriented methodology that dissects an email authentication workflow, dividing it into four steps.First, we studied SMTP and email specifications (both core protocols and extensions), extracting authentication-related behavior, focusing on the lexical, syntax and semantic rules for different identities. We discovered three techniques to exploit their inconsistencies: (1) HELO/MAIL FROM confusion (A 1 , A 2 ); (2) ambiguous domains (A 3 ); and (3) authentication results injection (A 4 , A 5 ). Ambiguity b/w SPF&DMARCAmbiguity b/w DKIM&DNS Ambiguity b/w DKIM&DMARC Gmail.com (A 3 ) iCloud.com (A 5 ) (A 4 ) Outlook.com Yahoo.com Naver.com (A 4 ) Fastmail.com Zoho.com (A 5 ) (A 4 ) Tutanota.com (A 2 , A 5 ) (A 4 ) Protonmail.com (A 5 ) (A 4 ) Mail.ru"": vulnerable to specific attack(s) due to internal inconsistencies. Some DMARC implementations (e.g., OpenDMARC), however, still use the MAIL FROM domain to perform the alignment test with the From header, because the MAIL FROM address is not empty. RFC 8601 defines the Authentication-Results header to provide a common framework for communicating these Here, "spf=pass" and "dkim=pass" indicate that the message passed both SPF and DKIM verification for the mail server for example.com. Although many applications require domain names to follow specific syntax rules-for example, domain name registrars only allow users to register domain names under the LDH rules (only letters, digits, hyphens)-the DNS protocol does not impose any restrictions on the characters in a domain label.In particular, an attacker can introduce malformed domains that include meta-characters, for example "a.com(. Per Figure 5d, attackers can generate DKIM-Signature headers using their own private keys, with "d=" values that embed a literal open parenthesis, such as "legitimate.com(. Here, the mail server takes the second "@" as the delimiter, and recognizes it as a valid email address, while the SPF component takes the first "@" as the delimiter, and thus queries "legitimate.com'@a.attack.com"-the attacker's domain-to verify the sending IP address. We devised three techniques to exploit ambiguous From headers: 1) multiple From headers; 2) space-surrounded From headers; 3) From alternative headers.1) Multiple From headers (A 6 ). If an attacker violates this syntax structure by inserting whitespace before or after the header name, different implementations handle the ill-formed header differently.We identify three such edge cases: a) a space-preceded From header as the first header; b) a space-succeeded From header; c) a folding-space-succeeded From header. Others recognize the space-surrounded From header as a valid From header, take it as an unknown header or parse the whitespace as the delimiter between email headers and body.Whitespaces open new opportunities for multiple From ambiguities. Mail.ru (Server)'s DMARC component recognizes the folding-space-succeeded From header and authenticates attack.com, but Outlook (Windows) takes it as an unknown header and presents admin@legitimate.com as the validated From header.Sometimes we can even fool the email servers and MUAs that use the same header parsing and processing, by leveraging special forwarding behaviors of the email servers. As shown in Figure 6d, Naver.com (Server) recognizes a folding-spacesucceeded From header and verifies attack.com, but Outlook (Windows) doesn't recognize it and shows the (unverified) Sender header value in the From field.Attackers can also combine different techniques to chain multiple features to bypass strict security validation. The local part can be a string with or without quotes.Route portion is an obsolete feature originally defined in RFC 822 to indicate the delivery path that the message should follow. =, in which the "charset" field specifies the character set of the unencoded text;"encoding" value should be "B" or "Q", representing the encoding algorithm; "encoded-text" is the text encoded by the algorithm. Here we show five attacks that exploit these inconsistencies, as shown in Figure 8.1) Multiple email addresses (A 9 ). Gmail.com (Server) and Mail.ru (Server) reject the messages; Tutanota.com (Web) displays the last address; Zoho.com (Server) and iCloud.com (Web) don't verify or display any address; 2 mail servers and 4 MUAs verify or display all of the addresses; all the others take the first address.Multiple email addresses enable two new kinds of ambiguities. In our experiments, Yahoo.com (Server), Outlook.com (Server), iCloud.com (Server), Fastmail (Server), Zoho.com (Server) and Tutanota.com (Server) don't recognize the encoded address, and use attack.com for DMARC testing; but Gmail.com (Web), Outlook.com (Web), Yahoo.com (Web), Naver.com (Web), Mail (MacOS), Mail (Windows) and Mail (iOS) support this encoding feature, and only display the first address.3) Route portion (A 11 ). As shown in Figure 8c, Fastmail.com (Server) does not recognize the route portion, and treats attack.com as a real address to use for DMARC verification; while 10 MUAs, including Fastmail.com (Web), ignore the route portion, and only show admin@legitimate.com.4) Quoted-pairs (A 12 ). Attackers can also spoof emails with seemingly valid DKIM signatures from legitimate domains, bypassing both DKIM and DMARC authentication safeties to make forged emails more deceptive.DKIM uses digital, cryptographic approaches to prevent tampering with signed content. Second (A 15 ), while including all necessary headers in the signature can prevent attackers from tampering them, a replay attacker can still bypass the checks by using multiple headers, per Section 5.1. An attacker can craft ambiguous emails by adding a new header (e.g., Subject) to the signed mail, if two parties in the email process chain parse and interpret the extra header differently; for example, if the DKIM component uses the original Subject header while the mail client uses the crafted Subject header.While RFC 6376 ยง 5.4.2 states DKIM components must use the last header if a message has duplicate headers, we find that DKIM components and email clients indeed sometimes lack consistency in processing multiple headers. In our testing experiments, all tested DKIM components conformed with the rule-but 10 out of 19 MUAs prefer the first header. When the Gmail web interface displays this message, it uses the MIME boundary defined by the attacker and only shows the attacker's content, because RFC 2046 ยง 5.1.1 specifies that any content before the boundary is treated as preamble and not displayed by email clients.We conducted a preliminary assessment of this problem by collecting emails from wikileaks.org, IETF mailing lists, and our personal emails. In this scenario, the attacker has an account on a legitimate email service, but uses a custom MUA to originate emails sent through the service. If so, the email provider attaches its DKIM signature when forwarding the message.The problem (A 17 ) arises when an email provider does not perform sufficient checks on the From header, enabling an attacker to send a signed message with another user's address (e.g., administrator). They suggested that using a future IMAP extension, instead of the Authentication-Results header, could provie a more reliable way for email providers to report authentication information to MUAs. In addition, text-based protocols introduce flexible formatting and tolerance (e.g., allowing whitespace and comments to be freely inserted in many places), creating ample room for inconsistencies, especially when implementations vary in how they tolerate non-compliant inputs.Finally, the process of sender authentication involves a chain of components, creating strong dependencies on implementation consistency and correctness. RFC 6376 suggests that DKIM signers should include all important headers in DKIM signatures and avoid using the "l=" tag to prevent spoofing attacks.RFC 6376 also suggests that DKIM signers should "oversign", i.e., repeat important headers, to prevent replay attacks, such as using "h=from:from:subject:subject:to:to. . . ". To defend against attackers using accounts on email services, email providers can consistently reset message headers (such as From) to remove potential ambiguities. We also caution that hardening a weak authentication system by composing it with additional security components, such as sanitizers or monitors, itself can introduce complex compositions that create new vulnerabilities, as we showed in Figures 6c and 6e. One possible mitigation solution 7 is for mail servers to provide authentication information to email clients directly, so that email clients can avoid re-parsing and re-verifying complex messages. While the specifics of the attacks reflect the particulars of various email protocols and mechanisms, in abstract terms the attacks leverage several classes of vulnerabilities likely present in other complex multi-component services.In general, it is difficult to make components built by different developers fully consistent: 1) specifications allow for latitude in interpreting details; 2) it is easy to overlook the possibility of deliberate ambiguities in attacker-provided inputs; 3) specifications themselves evolve over time, with some components keeping outdated functionality for compatibility; 4) components can differ in which subset of a suite of complex features they implement; 5) components can vary in how they tolerate non-compliant inputs; and 6) functional equivalencechecking between complex components is intractable.Many of the vulnerabilities we found arise not from programming mistakes but intended features. Our attacks provide a new way to achieve this by combining replay attackers and malicious users of legitimate email providers.These two efforts provided valuable initial considerations of the problem of bypassing email sender authentication mechanisms, and noted some of the complexities in parsing email messages. A recent blog by Davison discusses the possibility of exploiting address parsing inconsistencies between web applications and third-party sending services (e.g., Amazon SES) to bypass web application validation logic [17]. ARC allows each mail forwarder to append their authentication assessment results to the forwarded message, so that the receiving servers can make informed decisions based on authentication results from earlier forwarders. All 10 email providers and 19 MUAs in our experimental testing proved vulnerable to multiple of the 18 attacks that we developed.As our software systems become increasingly complex, the need for building them out of disparate independent components rises.