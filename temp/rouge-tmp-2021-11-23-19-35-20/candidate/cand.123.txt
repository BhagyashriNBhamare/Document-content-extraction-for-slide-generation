Dynamic information flow tracking (DIFT) is a potential solution to this problem, but, existing DIFT techniques only track information flow within a single host and lack an efficient mechanism to maintain and synchronize the data flow tags globally across multiple hosts. More seriously, existing cross-host DIFT mechanisms piggyback metadata (i.e., tags) on network packets and associate them during runtime [50,67], which is another source of huge performance degradation.To perform efficient and accurate information flow analysis in the investigation of cross-host attacks, we propose a record-and-replay-based data flow tagging and tracking system, called RTAG. Second, because a number of processes can run on multiple hosts under analysis, the memory requirement for DIFT instances could become tremendous, especially when multiple processes on different hosts interact with each other.To overcome these two challenges, RTAG decouples the tag dependency (i.e., information flow between hosts) from the analysis with tag overlay and tag switch techniques ( §6), and enables DIFT to be independent of any order imposed by the communication. By allocating an optimal tag size for DIFT based on system-call-level reachability analysis, RTAG also reduces the memory consumption of DIFT by up to 90% compared with previous DIFT engines. §3, §4, and §5 present the challenges, an overview and the threat model of RTAG; §6 presents the design of RTAG; More specifically, §6.1 describes the data structure of RTAG, §6.3 explains how RTAG facilitates the independent DIFT; §6.4 describes how RTAG conducts tag switch for DIFT, and §6.6 presents the tag association module and how RTAG tracks the traffic of IPC. Different systems use different levels of granularity when logging information for their analyses (e.g., system-call level versus instruction level) as the cost of collecting this information changes based on the selected granularity level. Record and replay is a technique that aims to store information about the execution of a software system (record phase) and use the stored information to re-execute the software in such a way that it follows the same execution path and also reconstructs the program states as the original execution (replay phase). However, these techniques either require program source or binary code for instrumentation or have additional space requirements when recording executions of communicating programs (especially through the file system) as the recorded information is stored multiple times. This technique does so by: (1) marking with tags the "interesting" values of a program, (2) propagating tags by processing instructions, and (3) checking tags associated with values at specific points of the execution. (b) depicts that RTAG decouples the tag dependency from the replays of processes by using the tag switch, allocation and association techniques so that each process in the offline analysis can be performed independently.Arnold [25] and RAIN [35] make dynamic information flow tracking feasible by moving the cost of the analysis away from the runtime using a record-and-replay approach that performs DIFT only in the replayed execution. RAIN [35] does so by: (1) maintaining a provenance graph that captures the high-level relations between programs; (2) performing reachability analysis on the provenance to discard executions that do not relate to the security task under consideration and instead pinpointing the part of the execution where the data-dependency confusion exists (i.e., memory overlaps, called interference); (3) performing DIFT only for interferences by replaying the execution and fast-forwarding to that part. We implement this attack using gitolite [12] at the server side and git at the client side.The starting point of the attack is a malicious mirror of a popular git repository, which includes a hooking script that clones a command-and-control (C&C) repository for future communication. 1) The git first forks an ssh process, handling the ssh session with the remote host, and then 2) spawns another git pack process packing the related objects of the push.3) The pack process uses pipe to transfer the packed data to the ssh process. Although the record-andreplay function can faithfully re-construct the program states at replay time, it still takes non-trivial (and errorprone) efforts to serialize and orchestrate the replays of different processes to re-establish the dependencies for tag propagation between different hosts.The tag-dependency challenge becomes outstanding when we aim to replay processes on multiple hosts to investigate cross-host attacks. For example, to enforce the tag dependencies for the operation of searching and downloading a file from a peer-to-peer (P2P) file sharing network (e.g., Gnutella [7]), we need to orchestrate the replays of P2P clients on each node, in which case the approach becomes infeasible particularly when we are faced with hundreds or thousands of nodes. We propose a tagging system, RTAG, that decouples the tag dependency from the analysis (i.e., DIFT tasks), which previously was inlined along with the program execution or its replayed DIFT, and enables DIFT to be independent of any required order-allowing performing DIFT for different processes on multiple hosts in parallel. For tracking the data communication across hosts, RTAG applies a tag association method ( §6.6) to map the data that are sent from one host and the ones that are received at another host at byte level, which facilitates the identification of tag propagation across hosts. This work is under a threat model in which an adversary has a chance to gain remote access to a network of hosts, and will attempt to exfiltrate sensitive data from the hosts or to propagate misinformation (i.e., manipulate data) across the hosts. To track the data flow between files and network flow across different hosts, we build the model of tags as an overlay graph on top of an existing provenance graph (such as RAIN [35]). The tags allow RTAG to trace back to the origin of a file including from a remote host and to track the impacts of a file in the forward direction even to a remote host. Reversely, by recursively retrieving the tag key of a value, the analyst is able to find all the impacts in a tree shape including the ones at a remote host (see Figure 2(b) as an example). For this requirement, RTAG uses a physical hardware address (i.e., mac address) to identify a host, identifiers such as inode, dev, crtime to identify a file, and an offset value to indicate the byte-level offset in the file. RTAG further tracks the data transfer at byte level via socket communication for both TCP and UDP protocols, which enables the extension of tag propagation across hosts.Unlike the runtime DIFT system, RTAG has the comprehensive knowledge of source and sink from the recorded file/network IO system-call trace, thus is able to allocate an optimal size of tag for each individual DIFT task. In addition, to avoid losing any intermediate tag updates to the same resource performed by different processes, RTAG particularly monitors the "overwrite" operations to the same offset of a file and tracks this versioning info, so it accurately knows which version of the tag should be used in the propagation. Such enforcement enables the program to be faithfully replay-able at process level.To extend this approach to capture the end-to-end data flow across multiple hosts, we need to figure out how to coordinate replay programs on different hosts to track tag dependencies between them. The tag for DIFT is local because it only needs to uniquely identify every byte of the source in the current in-process DIFT, rather than identify a single byte of data across multiple hosts.Further, the number of sources in each DIFT depends on the reachability analysis result, which is usually largely reduced by data pruning. However, the storage footprint of tag map, the data structure used by DIFT to maintain the tag propagation status, can still be very high particularly when there are multiple (or many) sources.The cost of tag map in DIFT depends on its supported type of tags and purpose. Figure 3 compares the memory cost for tag map in different DIFT engines: (a) shows that the local tag of RTAG grows in logarithm while others are either linear or constant; (b) presents the total tag map size under different sizes of memories that are tainted (i.e., allocated with tags) where the memory cost introduced by RTAG is the lowest (by significant difference). For TCP, as the data stream delivery is guaranteed between the two hosts, we rely on the order of bytes in the TCP session between source and destination to identify the data flow at byte level, which can be uniquely identified using a pair of IP addresses and port numbers. For example, in Figure 2, a backward query on the attacker's controlled host 5.5.5.5:22 will return the tree-shape data flow overlay depicted in Figure 2(b), consisting of all the segments of the flow from the key to all of its upstream origins. Specifically, our implementation adds 830 lines of C code to the Linux kernel for the tag association module, 2,500 lines of C++ code to the DIFT engine for the tag switch mechanism, 1,100 lines of C++ code for the maintenance of tags, 900 lines of C++ code for the query handler, and 500 lines of Python code for the reachability analysis for tag allocation. If the type is SOCK_DGRAM (i.e., UDP), our implementation embeds a four-byte incrementing sequence number within the same peer IP and port number at the beginning of the payload buffer inside an in-kernel function sendmsg rather than the system call functions such as send and recv to avoid affecting the interface to the user program as well as the checksum computation. We run RTAG based on the Ubuntu 12.04 64-bit LTS with 4-core Intel Xeon CPU, 4GB RAM and 1TB SSD hard drive on a virtual machine using KVM [14] for the target hosts where system-wide executions are recorded. Pruned Graph are the subgraph where nodes and edges that are unrelated to the attack are pruned out; DF Overlay are results from the RTAG tagging system; Tags gives the number of generated tag entries; C-Tags gives the number of tags of which the key and value(s) are Cross-host (i.e., from different hosts); Accuracy shows the percentage of how many data flows are matched with the ground truth.flow paths between the results file on the client side and the objects file on the server side. Tasks stands for the number of processes that are replayed with DIFT; Memory gives the sum of virtual memory cost for each task; Time gives the time duration RTAG spends to perform the DIFT tasks in parallel; TReduc% shows the reduction rate from the time of performing the same DIFT tasks serially.SQL injections. RTAG helps determine the data flow between the user's loaded file and one of the payroll record that is considered to have been tampered.Cross-site scripting.The reflection-based crossscripting relies on dependency of an html element to user input to append a script that reads the sensitive data from the DOM tree of a page, packs some of the data, and sends an email to the attacker's external host. To evaluate RTAG for the cases when the attacker exploits memory corruptions, we additionally modified the GitPwnd attack §3.1 by compiling the ssh daemon with earlier versions containing memory-based vulnerabilities: one integer overflow based on CVE-2001-0144 and one buffer overflow based on CVE-2002-0640. Finally, we perform a backward query from the audio file at the last node to search for the origin of the file, and a forward query from the first node to uncover how the file spread across the network with fine-grainedlevel data flows. The benchmark is composed of four scenarios: using scp to upload a 500MB archive file, using wget downloading a 2GB mov movie file, compiling LLVM 3.8, and using Apache to serve an http service for file downloading. Setting Bandwidth% RTT% TCP Window: 128KB 0% +0.03% 256KB 0% +0.01% 512KB 0% +0.012% UDP Buffer: 512B -0.8% +0.02% 8KB -0.05% +0.01% 128KB -0.01% +0.012% We use iperf3 [13] to test the bandwidth impact of applying RTAG to typical network protocol settings. In the use of RTAG, we observe around 2.5GB-4GB storage overhead per day for a desktop used by a lab student (e.g., programming, web browsing); and around 1.5GB storage overhead per day for a server hosting gitolite used internally by five lab students for version controlling on course projects. "Cross Host" tells whether the system covers cross-host analysis; "Inst Time" represents when the instrumentation is performed (i.e., runtime or replay); "Tag Dep" shows how the tag dependency is handled; "Run Over" shows the runtime overhead; "DIFT Over(T/M)" presents the overhead of performing DIFT in terms of Time and Memory cost in which RTAG both achieves reductions significantly.Dytan [24] provides a customizable framework for multicolor tags. In addition to system-wide tracking, provenance at network level is a well-researched area [64,68,69]. Similar to RAIN [35], RTAG leverages Arnold to provide efficient recording performance, however the goals and functionality of RTAG are unique from to Arnold and could be implemented on other systems. Dynamic taint analysis [24,29,37,49,62] is a well-known technique for tracking information flow instruction by instruction at the runtime of a program without relying on the semantic of a program source or binary. Dynamic taint analysis [24,29,37,49,62] is a well-known technique for tracking information flow instruction by instruction at the runtime of a program without relying on the semantic of a program source or binary.