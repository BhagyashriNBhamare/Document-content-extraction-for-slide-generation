Increasingly, these use cases require the storage of sensitive user data or critical device controls on the BLE device, as well as the access of this data by an aug-mentative mobile application. A more recent addition to the Bluetooth standard is Bluetooth Low Energy (BLE), which differs from Classic Bluetooth in that it incorporates a simplified version of the Bluetooth stack and targets low-energy, low-cost devices.Its focus on resource-constrained devices has made BLE highly suited for IoT applications [18], including personal health/fitness monitoring [22], asset tracking [8], vehicular management [13], and home automation [27]. This application may need to read or write sensitive or critical data on the BLE device (for example, glucose measurement values stored by a continuous glucose meter, or a field that controls a door's locking mechanism in a smart home security system). This information, Figure 1: GATT communications between a mobile phone and a BLE-enabled glucometer.when combined with the download counts for each application, allows us to estimate a lower bound for the number of BLE devices that may be vulnerable to unauthorized data access.The rest of this paper is structured as follows: Section 2 provides an overview of key BLE concepts, particularly with regard to data access mechanisms and restrictions. Attributes are stored and accessed according to rules specified by the Attribute Protocol (ATT) and the Generic Attribute Profile (GATT), both of which are defined in the Bluetooth standard. Every attribute has associated with it three permissions that control how it may be accessed: (1) Access permissions define whether an attribute can be read and/or written. (3) Authorization permissions specify whether end-user authorization is required for access.When a GATT client sends a read or write request for an attribute to a GATT server, the server will check the request against the permissions for that attribute, to determine whether the requested access mechanism is allowed and whether the client is authenticated and/or authorized, if required. We show that the problem remains on newer versions of Android, and also that the situation is worse for BLE, as one of our attacks enables fewer restrictions for access and requires fewer permissions of the malicious application than even of the official application. However, due to restrictions imposed from Android version 6.0 onward, the OfficialApp also needs to request LOCATION permissions to invoke the BLE scanner without a filter (i.e., to scan for all nearby devices instead of a particular device). The simplest form of attack would then be for a malicious application to perform unauthorized reads of personal user data (as an example) and relay this to a remote server.We verified the practicability of this attack by testing a BLE-enabled fitness tracker that implemented the Bluetooth Heart Rate Service. It may also be possible for a malicious application to overwrite values on the BLE device, such that the written data either causes unexpected behavior on the device, or is read back by the legitimate application, thereby giving the user an incorrect view of the data on the peripheral. In their experiments with Classic Bluetooth, Naveed et al. found that an unauthorized Android application would not be able to obtain data from a Classic Bluetooth device if the authorized application had already established a socket connection with the device, as only one application can be in communication with the device at one time. This enables the AttackApp to connect to the BLE device regardless of whether or not another application is also connected, but increases the risk of raising a user's suspicions.In the second attack scenario, the obvious limitation for the AttackApp that requests only the BLUETOOTH permission is that the application will only be able to access data from the BLE peripheral when the peripheral is already in a connection with (another application on) the Android device. Otherwise, it is fairly likely that this measure will result in a fragmented ecosystem, with some devices running the modified operating system with protection mechanisms, and others running older versions of the OS with no protection.Regardless of whether or not the above measure is implemented, we believe that developers should be made aware of the possibility of unauthorized applications accessing their BLE device data. Most modern BLE chipsets implement authorization capabilities by intercepting read/write requests to the protected characteristics, and allowing for developer-specified validation.One advantage of this method is that it gives the developer complete control over the strength of protection that is applied to BLE device data, as well as over the timings of security updates. As discussed in Section 3.3, the only strategy available at present is for developers to implement application-layer security, typically in the form of cryptographic protection, between the Android application and the BLE peripheral.In this section, we identify the proportion of applications that do not implement such security mechanisms, to demonstrate a possible lack of awareness surrounding the issue, and to be able to estimate the number of devices that are potentially vulnerable to the types of attack shown in Section 3.1. Android APKs, on the other hand, are easier to obtain, and a number of decompilers exist that allow for conversion of APKs to a human-readable format.We therefore target Android applications for our analysis and perform the following: (1) obtain a substantial dataset of BLE-enabled Android APKs, (2) determine the BLE method calls and the cryptography libraries of interest, and (3) define a mechanism to determine whether BLE reads and writes make use of cryptographically processed data. Applications are categorized in Google Play according to their primary function, such as "Productivity" or "Entertainment", and it may be possible to gauge the sensitivity of the BLE data handled by an application based on the category it falls under. When considering BLE methods, we focus on those methods that involve data writes and b "% of Total Methods" refers to the percentage of occurrences of a particular method for a particular data access type (i.e., read or write), with respect to all methods that enable the same type of data access.reads. However, we do not include these in our analysis as they are now obsolete.For cryptography, Android builds on the Java Cryptography Architecture [33] and provides a number of APIs, contained within the java.security and javax.crypto packages, for integrating security into applications. For data that is written to the BLE device, we consider the cryptography API calls as sources and the setValue methods as sinks.There are a number of tools available for performing taintanalysis, such as Flowdroid [7] and Amandroid [40]. We therefore developed a custom Python analysis tool called BLECryptracer, to analyze all calls to BLE setValue and getValue methods within an APK.BLECryptracer is developed on top of Androguard [16], an open-source reverse-engineering tool that decompiles an Android APK and enables analysis of its components. Direct trace -Attempt to identify link between BLE and cryptography functions via direct register value transfers and as immediate results of method invocations. Therefore, in order to test our tool against different data transfer mechanisms, we re-factored the DroidBench benchmarking suite [21] for the BLE case.Each DroidBench test application was cloned twice and modified so the data flow between the sources and sinks would be from getValue to a cryptography method invocation, and from the cryptography method invocation to setValue, to emulate cryptographically-processed reads and writes, respectively. For our analysis, we compare the combined True Positive Rate (TPR) and False Positive Rate (FPR), and the combined precision-recall instead, in-line with taint-analysis evaluations [36]. In addition, approximately 90 APKs could not be processed via Androguard's AnalyzeAPK method and were excluded.Due to the differences in performance metrics obtained for the three confidence levels during testing (as mentioned in Section 4.4), we focus on only those results that either identify cryptography at confidence level High or those where no cryptography was identified at all. If the package name uses countrycode second-level domains (e.g., uk.ac.packagename), then we compare the third components as well.Of the APKs that called the setValue method, 63% used BLE functionality solely through libraries, 32% used application-specific methods only, while 4% used both. Within the APKs that used both applicationspecific methods and libraries, around 34% used an external library to provide Device Firmware Update (DFU) capabilities, thereby enabling the BLE peripheral to be updated via the mobile application. Table 4 presents the ten most commonly-encountered BLE libraries, their functionality, the number of APKs that use them, and the presence of cryptographically-processed BLE data within the library itself. This library allows third-party developers to integrate their services into the Flic ecosystem, to allow them to automate certain tasks.Finally, Nordicsemi is a library provided by a BLE chipset manufacturer to enable DFU over the BLE interface. With regard to insecure block cipher modes, we found that explicit use of ECB was prevalent (9 out of 10 cases), but there was also one case where Cipher.getInstance("AES") was used without the mode being specified, which may default to ECB depending on the cryptographic provider. This analysis shows that several real-world applications contain basic mistakes in their use of crypto-libraries and handling of sensitive data, which means that the BLE data will not be secure despite the use of cryptography. The overall downward trend suggests that there has been some improvement in application-layer security between the years 2014 and 2017 (we refrain from making observations about APKs from 2013 as they were very few in number, and about APKs from 2018 as the dataset is not yet fully populated for this year). However, given that the device can be configured to receive notifications from other applications, a malicious firmware could be developed in such a way that, for example, all notifications (including second-factor authentication SMS messages or end-to-end encrypted messages) are routed to the malicious application that installed the firmware.This attack was possible because the BLE peripheral did not verify the firmware (e.g., via digital signatures) nor the source application (via application-layer security). An attacker could easily embed several firmware images within a single mobile application, to target a range of vulnerable devices. As mentioned in Section 4.4, BLECryptracer does not analyze data that is written out to file (including shared preferences), or communicated out to a different application, because it is not straightforward (and many times, not possible) to determine how data will be handled once it has been transferred out of the application under analysis. We show the conditions under which an unauthorized Android application would be able to access potentially sensitive, pairing-protected data from a BLE peripheral, once a co-located authorized application has paired and bonded with a BLE peripheral, without the user being aware of the access. If, for an APK, the input to the setValue method can be backtraced to cryptography directly, via only register value transfers and as immediate results of method invocations, then a confidence level of "High" is assigned to the result. Finally, in the event that no cryptography use is identified at High or Medium confidence levels, the script performs a less stringent search through all the instructions of the methods that it previously analyzed. This risks including instances of cryptography use with functions unrelated to BLE and is therefore assigned a "Low" confidence level. With forward-tracing, the register holding the BLE data is considered to taint another if, for example, the source register is used in a method invocation, or comparison/arithmetic/logic operation, whose result is assigned to the destination register. When a register is used as input to a method, then along with the output of that method, the use of the register within the method is also analyzed.This method of analysis tends to result in a "tree" of traces. We therefore briefly discuss different obfuscation techniques and why they do not impact our tool.One of the most common techniques is identifier renaming, where identifiers within the code are replaced with short, meaningless names. However, because Androguard operates on smali (rather than Java) code, BLECryptracer is able to overcome the challenges posed by this technique. The tool stops processing an APK at the first instance where such a method call is identified. This could be due to simple operations such as aget, aput or move-<> (apart from move-result variants), or it could be as a result of a comparison, arithmetic or logic operation (in which case, the register holding the operand on which the operation is performed is added to the trace list). The second input, parameter register p2, holds the data that is to be written to the BLE device, and is the second argument that is passed to the method a (Line 1). During execution, the BLECryptracer maintains a list of registers (set within the context of a method) to be traced, for each setValue method call within the application code. This could be due to simple operations such as aget, aput or move-<> (apart from move-result variants), or it could be as a result of a comparison, arithmetic or logic operation (in which case, the register holding the operand on which the operation is performed is added to the trace list). However, the script does not analyze the order in which the field is assigned values, as this would require activity life-cycle awareness.Where a register is assigned a value that is output from a method invocation via move-result, if the method is not an external method, then the instructions within that method are analysed, beginning with the return value and tracing backwards.