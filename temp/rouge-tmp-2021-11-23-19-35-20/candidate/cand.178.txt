To achieve this goal, WAVE adopts an expressive authorization model, enforces it cryptographically, protects permissions via a novel encryption protocol while enabling discovery of permissions, and stores them in an un-trusted scalable storage solution. The building manager and/or tenant will also grant ephemeral permissions on subsets of the building infrastructure to contractors (like HVAC commissioning teams) and, especially in our case, to Existing authorization systems fall short in two general areas: they do not meet our Security Goals or they do not provide the features required for IoT usage scenarios. Existing systems do not offer a solution to this requirement: in many centralized systems, for example, whoever operates the server can see all the permissions. This is adequate in the centralized service case where the authority is the service provider, but it does not work in the IoT case where the root authority (the property manager) has nothing to do with the devices needing to verify an action is authorized (for example a thermostat). Nevertheless, we found that representing the authorization model as a graph, such as in SDSI/SPKI [49,24] where a proof of authorization is a path through a graph, is compatible with our requirements, even though the existing systems implementing it fall short. The graph construction allows permissions to be granted in any order, including delegation of permissions one does not yet possess but expects to receive in the future.While WAVE's authorization graph and proofs are structurally similar to SDSI/SPKI, WAVE differs in three important aspects: (1) while in SDSI/SPKI only a central authority (holding an ACL) can verify a proof, in WAVE anyone can independently (with no communication) verify a proof yielding an authorization policy. Unlike Certificate Transparency [41], which cannot form a proof of nonexistance needed for revocations, or Key Transparency [32], which requires users to audit every object at every epoch, a ULDM is both capable of handling revocations and is efficiently auditable. To meet the requirement of protected permissions and Security Goal #2 despite the public ULDM storage tier, there must be a mechanism to prevent the storage servers or the general public from seeing the permissions, while ensuring that parties forming and verifying proofs can see the necessary permissions. Although WAVE's design is agnostic to the specific mechanism used for expressing the authorization policy (i.e., it is compatible with existing policy languages such as [10,12]), in our IoT deployments we use a simple yet widely applicable model: a resource tree (RTree) modelled roughly after SPKI's pkpfs tags [24]. An RTree policy consists of:• A set of permissions (strings such as "schema::read") • A URI pattern describing a set of resources • A time range describing when the grant is valid • An indirections field, which limits re-delegation For example, a building manager entity might grant hvac:: actuate on bldgnamespace/floor4/ * over a time range corresponding with the lease terms, allowing further delegation, to a tenant entity. Attestations are disseminated through the ULDM storage tier ( §5) which allows for entities to discover permissions they have been granted while they were offline and removes the need for any out-of-band online communication between entities. Given that existing systems like SDSI/SPKI [49] use a similar construction, we do not explore this further.To achieve the other two security goals, WAVE introduces two new techniques: Reverse-Discoverable Encryption ( §4) to satisfy Security Goal #2, and Unequivocable Log-Derived Maps ( §5) to satisfy Security Goal #3. Essentially, each entity can see the attestations it can use in a proof by decrypting them in the reverse order as they would appear in a proof.This achieves a simple security guarantee called structural security, which allows an entity e to see any attestation A for which there exists a path from A.subject to e. With policy-aware RDE, we achieve a stronger notion of security that prevents D from decrypting #5 by making two high-level changes to structural RDE.First, whereas structural RDE encrypts each attestation A according to only A.subject, policy-aware RDE encrypts each attestation A according to both A.subject and A.policy. ; ID * i )} ID * i ∈Q(AThe issuer must also include the policy-specific WIBE keys from their own system in the attestations, generated with ID * s Q(A.policy), so that upstream attestations with compatible policies can be discovered. We define Q for RTree as: let E be a set of subtrees, each represented as a prefix of a time vector (i.e., a vector where unused components are wildcards), that covers the time range from the earliest possible encryption start time to the end of the time range of the attestation's validity. First, a WIBE ciphertext hides the message that was encrypted, but not the ID used to encrypt it; an attacker who guesses the ID of a ciphertext can efficiently verify that guess. This is infeasible if n is large, and becomes a vector for denial of service attacks.If Alice knows B's partition, then the problem is solvedAlice can locally index the private keys she has from Bob's system, and efficiently look up a key that can decrypt B.However, B cannot include its own partition in plaintext, because it may leak part of B.policy.We solve this by encrypting the partition and storing it in the attestation. Thus, even though policy-aware RDE permits some entities to see more attestations than strictly needed to create a proof of authorization, it still provides a significant reduction in visibility when compared to structural security. Finally, to maintain integrity, the issuer signs the attestation with a single-use ephemeral key (pk e , sk e ):s 1 = Sign(sk e ; A \ s 1 ), where A \ s 1 denotes the entire attestation except for s 1 . This allows the prover to reveal to the verifier the necessary parts of an attestation by sending it the AES verifier key, without allowing the verifier to decrypt other attestations. In what follows, for every reply that the storage server provides, the storage server provides a signature on the reply along with the relevant version of the Map Root Log. To prove misbehavior when a value is not inserted on time, a client can present a merge promise along with a signed Map Root Log head where the corresponding Object Map does not contain the value and where the version of the head is greater than that in the promise; i.e., a server would need to stop operating completely if it wishes to both avoid merging an object and revealing it is compromised. If the object has been merged or doesn't exist, the server responds with: (1) the object or nil, (2) a proof that the object existed or did not exist in the Object Map at the latest map root, (3) a proof that the latest map root exists in the Map Root Log at the current Map Root Log head, and (4) a consistency proof that the current Map Root Log head is an append-only extension of the version the client passed in its request. Then, by verifying the identity of a single entity out of band (the company), an entity can resolve the names of all employees within the company's departments, such as Alice.Marketing.ACME, without having to manually establish the validity of individual employee entities.The functionality above, proposed by SDSI, does not provide a distribution mechanism for entities to discover the name declarations required to perform resolution, nor a mechanism to ensure the privacy of declarations so that only authorized parties may read them. When creating a name declaration, it is associated with a resource in a namespace (for example, acme/directory/marketing) and an entity must be explicitly granted permission on that resource in order to gain the keys required to decrypt the name declaration. These decryption operations take place only once-when an attestation is added to the perspective graph-so are a one-off cost of re-1 Create attestation uses multiple cores Authentication Authorization LDAP+MySQL 6.3ms 0.8ms OAuth2 JWT 0.3ms WAVE 1 attest.1.2ms WAVE 3 attest.3.6ms Table 2: Latency of LDAP+MySQL, OAuth2 vs. WAVE. Applying WAVE to legacy devices whose firmware cannot be modified is done by using an adaptation layer microservice and ensuring all communication with the legacy device flows through that service [8]. We were able to mitigate unfamiliarity with WAVE's authorization model with careful user interface design (which provides secure defaults such as short expiry times) and with teaching users through familiar analogies (e.g., comparing RTree to file paths). In our deployments we use RTree, based on SPKI's pkpfs [24], but mechanisms like third-party caveats could be introduced with no changes to the underlying layers.Hidden credentials (row 2 in Table 4) [58,37,30,48] address a different privacy problem: allowing a prover and verifier to hide their credentials from each other. The smart building scenario illustrates the necessity for transitive delegation and revocation where, for example, a tenant can further delegate their permissions to a control service or guest and have those permissions predicated on the tenant's permissions. Some existing decentralized systems (e.g. SDSI/SPKI [49] and Macaroons [12]) allow only the authority to verify that an action is authorized. The formalism in Appendix B largely generalizes to other policy types, but the semantics of compatibility (Note 1) will change depending on the encryption schemes used and on the choice of P, Q, L, and M. To avoid centralized trust when storing attestations, we contribute a storage tier that enforces integrity cryptographically. When accessing a service or controlling a device, clients request a proof from the WAVE service; the WAVE service will search for a path through the global authorization graph from the authority for the service or device in question to the client's entity, where each edge grants a superset of the required permissions. Alternatively, the entity forming the proof can include proofs of nonexistence, signed by the storage tier with a timestamp, with the attestations, so that the verifier does not have to perform this lookup. We write A B and say "A is partition-compatible with B" if a key corresponding to one of the ID * s in Q(A.policy) can decrypt a WIBE ciphertext with the ID P(B.policy). Despite relying on cryptography for its security guarantees, WAVE remains performant, competitive to traditional authentication and authorization systems. Observe that the Merge Promises following insert requests by these clients and Map Root Log heads sent with retrieval requests by these clients define a partial ordering L over all requests received by S. Suppose that there exists a nonempty set R of requests made by clients in C, such that there exists no possible history of requests made to S that is consistent with both L and all of S's responses to requests in R. The proof builder, when asked to build a proof, begins at the namespace authority (the entity that created the RTree namespace) for the resource that permissions are being proved on, and then performs a shortest path discovery through the perspective graph terminating at the proving entity. We use the RTree policy type to explain our policy-aware RDE, although the technique applies to other policy types.We identify Wildcard Identity-Based Encryption (WIBE) [5] as a suitable policy-aware encryption scheme to implement RDE for the RTree policy type. WAVE indexes it to allow efficient key retrieval based on a new attestation and efficient attestation retrieval based on a new key. For example, in Fig. 2, #3 contains sk C and is encrypted under pk D (i.e., Enc(pk D ; #3||sk C )). In these systems, delegation is critical: for instance, allowing an assistant to edit your calendar, and letting the assistant further delegate restrictive view access to an event organizer. The measurement is on an Intel i7-8650U AMD64 CPU representative of a standard modern laptop, and on a Raspberry Pi 3, indicative of a low-cost IoT-class ARMv8 platform.The verifier does not perform any WIBE decryption, as it has the AES verifier key. We have also found that this capability leads to safer user practices as "mistakes" like overly narrow permissions and short expiry times are easy to correct.Offline participants. Firstly, WAVE stores name declarations in the ULDM storage tier ( §5) to ensure name declarations are discoverable without compromising on the goals of the system (especially without requiring on-line participants). §4.4 presents our final protocol, which provides both efficient discovery of attestations and a significantly stronger guarantee than structural security.For all the security guarantees stated in this section, we assume that the attacker Adv is computationally-bounded, and that standard cryptographic assumptions hold. This constitutes a depth-first traversal to discover newly visible parts of the authorization graph revealed by A. While structural RDE uses traditional public-key encryption, it differs from systems like PGP in that entities include their long-lived private keys in the attestations they encrypt. In meeting these requirements, WAVE (1) has no reliance on central trust, (2) provides transitive fine-grained delegation and revocation, (3) protects permissions during discovery and at rest, (4) allows for any party to verify a proof of authorization, (5) allows delegations to occur in any order with no communication between granter and receiver, and finally (6) allows for granting permissions to offline participants. Since a proof is represented by a path through the graph, if an entity higher up in the delegation tree is revoked, all entities beneath it will no longer be able to prove they have permissions, even though the party revoking the entity may have been unaware of the delegations lower in the tree. If there exists an auditor A such that each client in C has sent A a Map Root Log head it received from S at least as recent as the one it received for its latest request in R, then one of the following holds:1. This gives us the transitive delegation property. If there exists a partition-compatible path p = (A, P 1 , . . . , P n ) to an entity compromised by Adv, then we say that A is useful with respect to Adv.Otherwise, if there exists a partition-label-compatible path p = (A, P 1 , . . . , P n ) to an entity compromised by Adv, then we say that A is partition-known with respect to Adv.Otherwise, if there exists a partition-compatible path from A.subject to an entity compromised by Adv, then we say that A is interesting with respect to Adv.Otherwise, we say that A is unknown with respect to Adv. From D's perspective in Fig. 2, for example, #1, #4, and #3 are useful, #5 is partition-known, and #2 is unknown. This is not tractable in practice as it requires the coordination of many people and hundreds of devices, leading to extended downtime. To retrieve a value, the client sends the storage server the Map Root Log version that it received in a previous request, along with the object identifier it is retrieving (e.g., the hash of an attestation or revocation commitment). Together, (1) and (2) indicate that (5) the client's entire sequence of Map Root Log heads is consistent with H. Together, (3) and (4) indicate that (6) the response received for each request in R is consistent with the current Map Root Log head at the time of the request. For example, structural RDE allows D to decrypt #5, though this is not necessary to meet the correctness goal; D cannot form a valid proof containing #5 because its policy differs from #4's (they delegate access to different files). The receiving service or device can use the WAVE service to validate a proof, yielding the authorization policy it permits.The WAVE service also allows for mapping human readable names to entity public keys to make the system more usable, as we elaborate in §6.2. Only edges granting a superset of the required permissions are traversed and the maximum depth of traversal is limited by the indirections parameter in the traversed attestations. Alice might be able to form a proof using B and one of the A i , but she does not know which of the A i has a policy that intersects with B.policy. WAVE solves an orthogonal problem: the privacy of credentials in storage and during discovery.The remaining literature can be categorized as relying on a centralized credential store for discovery [19,15,56], or a distributed credential store [44,59,18,57,50]. Our storage layer does not provide any additional confidentiality, so compromised storage servers can see the time of each operation (e.g., when encrypted attestations are stored), which encrypted attestations are fetched, as well as networking information of the packets arriving at the storage servers (which could be protected via Tor [1], a proxy, or other anonymous/secure messaging methods [21]). To express the start and end of this range as a WIBE ID, we define a time-partitioning tree of depth k over the entire supported time range; now any time in the supported time range can be represented as a vector representing a path in the tree fro