We describe a research prototype of TrustBase for Linux, which uses a loadable kernel module to intercept traffic in the socket layer, then consults a userspace policy engine to evaluate certificate validity using a variety of plugins. Second, TLS interception, used by numerous firewall appliances and software (as well as malware), compromises the integrity of end-to-end encryption [24,34], with many firewalls having significant implementation bugs that break authentication [7,11]. These include multi-path probing [31,41,1,23] or other systems that vouch for the authenticity of a certificate [15,2,3], DNS-based authentication [21], certificate pinning [16,32], and audit logs [27,39,14,26]. However, this approach does not provide universal coverage of all existing applications, does not provide administrators singular control over certificate authentication practices, does not protect against several important attacks, and has significant maintenance issues. This approach is well-suited for Android because all applications are written in Java, but it is difficult to extend this approach to operating systems that provide more general programming language support.In this paper, we explore a different avenue for fixing these problems by centralizing authentication as an operating system (OS) service and giving system administrators and OS vendors control over authentication policy. TrustBase also includes a simple certificate validation API that applications call directly, which extends authentication services to new or modified applications, while also providing compatibility with TLS 1.3. All of these improvements can be made without requiring user interaction or configuration.Our contributions include:• An architecture for certificate validation that prioritizes operating system centralization and system administrator control: TrustBase offers standard certificate validation procedures and optionally adds additional authentication services, both of which are enforced by the operating system and controlled by the administrator or OS vendor. Their work follows a similar principle to oursinstead of letting developers implement their own certificate validation code, validation is a service, and it incorporates a pluggable framework for authentication schemes. For example, applications using custom or unsupported security libraries (e.g., BoringSSL, NSS, MatrixSSL, morerecent GnuTLS, etc.), applications statically linked with any security library, and applications spawned without being passed CertShim's path in the LD PRELOAD environment variable (e.g., spawned by execv or spawned by a user without that environment setting) will not have their certificates validated by CertShim. With CertShim, guest users and applications can easily opt out of its security policies by removing CertShim from their LD PRELOAD environment variable, and developers can bypass CertShim by statically-linking with security libraries, using an unsupported TLS library, or spawning child processes without CertShim in their environment. TrustBase is motivated by the need to fix broken authentication in applications and strengthen the CA system, using the two motivating principles that authentication should be centralized in the operating system and system administrators should be in control of authentication policies on their machines. The goal of the attacker is to establish a secure connection with the client.The application under attack may accept the fake certificate for the following reasons:• The application employs incorrect certificate validation procedures (e.g., limited or no validation) and the attacker exploits his knowledge of this to trick the application into accepting his fake certificate. The TrustBase architecture should be designed to work on any major operating system, including both desktop and mobile platforms. Otherwise, traffic is routed normally.The traffic interceptor is needed to secure existing applications. Administrators can con-figure TrustBase to not intercept traffic from applications using this API. The handler will allow or abort the connection, based on the policy engine's response.TrustBase currently has both a TLS handler and an opportunistic TLS handler (e.g., STARTTLS), and due to the design of the traffic interceptor it is easy to add support for new secure transport protocols as they become popular (e.g., QUIC, DTLS). The policy is configured by the system administrator, with sensible operating system defaults for ordinary users.When the policy engine receives a validation request from a handler, it will query each of the registered authentication services to validate the server's certificate chain and host data. Abstain and error responses are mapped to the valid or invalid responses, as defined in a configuration file.To render a decision, the policy engine classifies plugins as either "necessary" or "voting", as defined in the configuration file. TrustBase defines a robust plugin API that allows a variety of authentication services to be used with TrustBase.The policy engine queries each authentication service by supplying host data and a certificate chain, and the authentication service returns a response. We provide both an asynchronous plugin API and a synchronous plugin API to facilitate the needs of different designs.The synchronous plugin API is intended for use by simple authentication methodologies. The query function returns the result of the plugin's validation of the query data (valid, invalid, abstain, or error) back to the policy engine.The asynchronous plugin API allows for easier integration with more advanced designs, such as multithreaded and event-driven architectures. This enables new or modified applications to use the full set of authentication services provided by TrustBase in a natural manner.A second option is to employ a local TLS proxy that can coerce existing applications that rely on the CA system to use new authentication services instead. Similarly to how Netfilter operates at the IP layer, TrustBase can intercept traffic at the socket layer, before data is delivered for TCP handling, and pass it to application-level programs, where it can be (optionally) modified and then passed back to the native kernel code for delivery to the original TCP functionality. When a user program invokes a system call to create a socket, the function pointers within the corresponding protocol structure are copied into the newly-created kernel socket structure, allowing different protocols (TCP, UDP, TCP over IPv6, etc.) to be invoked by the same common socket API. Note that handlers are allowed to report arbitrary values to applications for the amount of data sent or received, including false values, to allow greater flexibility in connection handling, or to maintain application integrity when injecting additional bytes into a stream. Such an architecture allows developers to implement arbitrary protocol handlers as simple finite state machines, as demonstrated by the TLS handler and opportunistic TLS handlers described in the following subsections.Another option for implementing traffic interception would have been to use the Netfilter framework, but this is not an optimal approach. Since the handler is implemented in a LKM, the PID of the socket can be used to obtain any further information about the application such as the command used to run it, its location, and even memory contents.When data is sent on the socket, the handler checks state data to determine whether the connection has initiated a TLS handshake. The policy engine asynchronously handles requests from the kernel module, freeing up the kernel threads to handle other connections while a response is constructed.Native plugins must be written in either C or C++ and compiled as a shared object for use by the policy engine. Since one of the goals of TrustBase is to enforce proper certificate validation on all applications on a system, the traffic interceptor is designed to stand between the transport and application layers of the OS so that it can intercept and access all TLS flows from local applications. Applications that utilize their own custom TCP/IP stack must utilize raw sockets, which require administrator privileges and are therefore implicitly trusted by TrustBase.To obtain complete coverage of TLS, our handlers need only monitor initial TLS handshakes (standard TLS) and the brief data preceding them (STARTTLS). For each, we verified our solution utilizing an "attacker" machine acting as a MITM using sslsplit [38], and a target "victim" machine running TrustBase. • Failure to validate hostnames: Some applications properly validate signatures from a certificate back to a trusted root but do not verify that the hostname matches the one contained in the leaf certificate. TrustBase prohibits this by default, as the policy engine ensures the certificate has a proper chain of signatures back to a trust anchor on the machine and performs the hostname validation described previously. 6 TrustBase also allows the system administrator to configure a strict TLS policy, which disallows plaintext connections even if it has no prior data about whether a remote host supports STARTTLS. Their small code size and limited functionality-handlers are simple finite state machines-make it more likely that formal methods and source code auditing will provide greater assurance that an implementation is correct. The protocol definition takes advantage of the Generic Netlink flag GENL ADMIN PERM, which enforces that selected operations associated with the custom protocol can only be invoked by processes that have administrative privileges for networking (the capability mapped to CAP NET ADMIN in Linux systems). Note that the TrustBase timings for the TLS handshake may increase if a particular plugin is installed that requires more processing time or relies on Internet queries to function, and that this overhead is inherent to that service and not the TrustBase core.The memory footprint in our Linux prototype is also negligible. In the long-term, adding socket-level interception to the Android kernel would be the right architectural choice, The primary engineering consequence of using the VPNService on Android is that TrustBase must intercept IP packets from applications but emit TCP (or UDP) packets to the network. For TCP, this involves maintaining connection state, emulating reliability, and setting appropriate flags (SYN, ACK, etc.) for TCP traffic.To verify compatibility with mobile applications, we tested 16 of the most popular Android applications: Chrome, YouTube, Pandora, Gmail, Pinterest, Instagram, Facebook, Google Play Store, Twitter, Snapchat, Amazon Shopping, Kik, Netflix, Google Photos, Opera, and Dolphin. These services illustrate the types of control that TrustBase can provide to an administrator in securing TLS on a system. Our certificate pinning and certificate revocation services enforce more advanced checks that are usually reserved for individual applications but can now be deployed system-wide. Finally, our cipher suite auditor service allows system administrators to pre- Enforces standard certificate validation using openssl functions and standard practices for validating hostnames, Basic Constraints, dates, etc. Uses Trust On First Use to pin certificates for any host; expired certificates are replaced by the next certificate received by a connection to that domain.Certificate Revocation Checks OCSP to determine whether the certificate has been revoked. Based on ideas presented by Perspectives [41] and Convergence [31], it connects securely to one or more notary servers to validate the certificate received by the client is the same one that is seen by the notaries. This removes the need for developers to explicitly invoke the validation API, and provides the OS with visibility and control over all TLS data, including TLS 1.3 handshakes, as the OS becomes the de facto TLS client. This also allows OS vendors and system administrators an easier upgrade path for TLS versions.Since network application developers are already familiar with the POSIX socket API, we are working on providing TLS as a protocol type in the socket API, the same way the OS provides TCP and UDP protocols as a service. By creating a socket using a new IPPROTO TLS parameter (as opposed to IPPROTO TCP), developers can use the bind, connect, send, recv, and other socket API calls with which thy are already familiar, focusing solely on application data and letting the OS handle all TLS functionality. Following these two principles, we designed the TrustBase architecture for certificate authentication, meeting our design goals of securing existing applications, strengthening the CA system, providing full application coverage, enabling universal deployment, and imposing negligible overhead. Also, this work was supported by Sandia National Laboratories, a multimission laboratory managed and operated by National Technology and Engineering Solutions of Sandia, LLC., a wholly owned subsidiary of Honeywell International, Inc., for the U.S. Department of Energy's National Nuclear Security Administration under contract DE-NA-0003525.