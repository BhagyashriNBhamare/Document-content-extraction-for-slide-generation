However, existing secure allocators, including the OpenBSD allocator [28] (which we will simply refer to as "OpenBSD"), DieHarder [30], Cling [2], and FreeGuard [33], possess their own strong deficiencies.First, these allocators provide either low randomization entropy, or cannot support a stable randomization guarantee, which indicates they may not effectively defend against heap overflows and use-after-free attacks. GUARDER proposes an allocation buffer to track available objects for each size class, then randomly chooses one object from the buffer upon each allocation. The allocation buffer will simultaneously satisfy the following properties: (1) The buffer size can be easily adjusted, where a larger size will provide a higher randomization entropy; (2) The buffer size is defined independently from any size class in order to provide stable entropy for objects of different size classes; (3) It is very efficient to locate an item inside the buffer, even when given an index randomly; (4) It is more efficient to search for an available object by separating available objects from the large amount of in-use ones.However, although it is possible to place deallocated objects into the allocation buffer directly, it can be very expensive to search for an empty slot in which to do so. Instead, GUARDER proposes a separate deallocation buffer to track freed objects: freed objects will be recorded into the deallocation buffer sequentially, which will be more efficient due to avoiding the need for searching; these freed objects will be moved to the allocation buffer upon each allocation, and in a batched mode when the allocation buffer is reduced to half-full. Compared to existing work, as shown in Figure 1, GUARDER achieves the highest security, while also imposing small performance overhead. It is the first allocator to support customizable security guarantees on randomization entropy, guard pages, and over-provisioning, which allows users to choose the appropriate security level based on their performance or memory budget. These memory vulnerabilities can result in information leakage, denial-of-service, illegitimate privilege elevation, or execution of arbitrary code.A buffer overflow occurs when a program reads or writes outside the boundaries of an allocated object, which further includes buffer underflows. Cling only mitigates use-afterfree vulnerabilities through constraining memory reuses to objects of the same type.Based on our understanding, OpenBSD, DieHarder, and FreeGuard share many common design elements. OpenBSD utilizes a bitmap to maintain the status of heap objects, with each bag having a size of 4 kilobytes that is directly allocated from the kernel via an mmap system call. Similarly, a bitmap is used to manage the status of each small object, defined as less than 64 kilobytes, and the same bags may be used to satisfy requests from multiple different threads. To our understanding, this design may hurt performance (compared to OpenBSD), as it may unnecessarily load bitmap words from different cache lines.DieHarder utilizes the over-provisional mechanism to help tolerate buffer overflows. (1) These allocators either have very limited randomization entropy (such as 2.01 bits for FreeGuard), or have unstable entropies that can vary greatly across different size classes, execution phases, executions, and applications. For OpenBSD and DieHarder, their entropies are inversely proportional to size class, and may change during execution or when executed using different inputs. However, the ASLR mechanism is not necessarily required to be valid, since GUARDER manages memory allocations using a separate randomization mechanism, making its layout difficult to predict even if ASLR in the underlying OS is broken. Second, we also assume that the platform will use a 64-bit virtual address space, in order to support the specific layout of this allocator.For the target program, GUARDER assumes the attacker may obtain its source code, such that they may know of possible vulnerabilities within. Compared to the state-of-the-art, GUARDER significantly increases randomization (entropy is increased by 7.8 bits, over 200 : weak implementation * : actual results of entropies can be seen in Figure 4 times), adopts the over-provisional mechanism (first proposed by DieHarder), and discards its deterministic layout. Due to the vast address space of 64-bit machines [26,2], the address space should accommodate all types of applications.Per-thread design: GUARDER employs a per-thread heap design such that each thread has its own heap segment, and always returns freed objects to the heap belonging to the current thread. FreeGuard, although also using a per-thread heap design, returns freed objects to the original owner thread, thus requiring a lock. Further, metadata are randomly allocated using mmap system calls, rather than using a pre-allocated block, as in FreeGuard.More importantly, GUARDER introduces separate allocation and deallocation buffers for each size class of each thread, which is a key difference between GUARDER and other secure allocators. The idea of the allocation buffer is inspired by Stabilizer [11], but with a different design to reduce unnecessary allocations and deallocations, and support customizable securities.GUARDER designs the allocation buffer as follows: its capacity will be set to 2 E+1 (not 2 E ), and ensures it will never fall below half-full. Because there is no need to search for an available slot, the deallocation step will be completed in constant time.The allocation buffer will be filled after each allocation if at least one free object exists in the corresponding deallocation buffer. Second, its strong randomization makes meaningful attacks extremely difficult, with only a 0.11% success rate per try due to its 9.8 bits of entropy, as evaluated in Section 5.4. Currently, 9 bits of entropy are chosen by default, and GUARDER guarantees that the number of available objects will never be less than 512 (2 9 ), where each buffer has 1024 entries.Object selection is performed as follows: upon every allocation, a random index into the allocation buffer is generated. GUARDER implements its over-provisioning by controlling the filling step of allocation buffers. Then, the specified proportion (e.g., 1/8) of these objects will be deleted from this buffer randomly, and will never participate in future allocations or deallocations. This method reduces the amount of computing and comparing by 7/8 compared to the naive method.In contrast to DieHarder, GUARDER's overprovisional mechanism significantly reduces memory footprint and cache loadings, since "skipped" objects will never be accessed in the future. However, accessing these objects may increase the number of physical pages in memory, and involve unnecessary cache loading operations. For this reason, DieHarder has a "weak implementation" listed under "Guard Pages" in Table 2, as it cannot stop heap spraying or buffer overflow attacks that only occur within each bag. OpenBSD designs each bag to occupy a single page, which practically places guard pages between bags.Different from FreeGuard, GUARDER supports a flexible ratio of guard pages, obtained from an environment variable. Due to complexities brought by memalign, GUARDER treats any address within a valid object as a valid free, and consequently frees the object, which is similar to DieHarder.Note that GUARDER may miss a special kind of double free, similar to existing work [23,32], when a de-allocated object has been subsequently reutilized for other purposes. However, the implementation of Thread Local Storage (TLS) (declared using the " thread" storage class keyword) is not efficient [13], and introduces at least an external library call, a system call to obtain the thread ID, and a table lookup. To reduce memory consumption, GUARDER returns memory to the underlying OS when the size of a freed object is larger than 64 kilobytes, by invoking madvise with the MADV DONTNEED flag.GUARDER designs a global deallocation buffer to reduce the memory blowup caused by returning freed objects to the current thread's sub-heap. On average, the performance overhead of these secure allocators are: DieHarder-74%, OpenBSD-31%, FreeGuard-1%, and GUARDER-3%, by comparing to the Linux allocator, while a known performance oriented allocator-TCMalloc-is slightly faster than it, with 1.6% performance improvement. Based on our evaluation, GUARDER and FreeGuard impose much less overhead from mmap system calls, since they obtain a large block of memory initially in order to reduce the number of mmap calls. With a higher entropy, deallocated objects have a lower chance to be re-utilized immediately, which may access more physical memory unnecessarily, causing more page faults and less cache hits.Guard Page Ratio. EB = Entropy Bits, GPR = Guard Page Ratio, OPF = Over-Provisioning Factor pages, including 2%, 5%, 10%, 20%, and 50%, were similarly evaluated. To ensure a fair comparison, we disabled the canary checking functionality for both FreeGuard and GUARDER (and is disabled by default in OpenBSD), since adding even a single-byte canary may cause an object to be allocated from the next largest size class.In total, the memory overhead (shown in Table 5) of FreeGuard is around 37%, while DieHarder and OpenBSD feature slightly less memory consumption than the Linux allocator, with -3% and -6%, respectively. Note that we utilized the maximum number of entries in four bags to compute the entropy for OpenBSD upon each allocation. Taking the size class of 64 kilobytes for example, GUARDER will randomly allocate one object from over 831 objects, while DieHarder and FreeGuard will allocate from just 32 and 4 objects, respectively. Arbitrary-precision numeric processing language interpreter The affected copy of this program was obtained from BugBench [25], and includes a buffer overflow as the result of an off-by-one array indexing error, caused by a specific bad input, which will produce a program crash. The Heartbleed bug exploits a buffer over-read in OpenSSL-1.0.1f. Both GUARDER and FreeGuard will probabilistically guard against this attack, with protection in proportion to the amount of random guard pages installed. GUARDER, FreeGuard, and OpenBSD halt and report each of these bugs, while DieHarder exits normally with no report made. For all evaluated bugs, GUARDER was capable of either probabilistically detecting the attack -such as through the use of random guard pages to thwart buffer overflow -or immediately provided a report to the user when the error condition occurred (e.g., double-free). If there are 128 threads in total, with a heap space of 128 terabytes, every bag will be 64 gigabytes, which can sup-Rather than protecting against a single type of memory error, GUARDER defends against many common errors, achieving this with very little overhead on average. The GUARDER heap combines protections similar to those provided by the mechanisms introduced by these works, including fully-segregated metadata, randomized object reuse, and detection of double/invalid free vulnerabilities, among others.The Low Fragmentation Heap (LFH) is a widely deployed heap policy for Windows-based platforms, introduced in Windows XP [27]. The metadata segregation achieved by these works can protect against metadata-based vulnerabilities, however, they cannot guard against attacks on the actual heap.Blink, a rendering engine for the Chromium project, utilizes PartitionAlloc, a partition-based allocator with built-in exploit mitigations [15]. Lastly, its design could be significantly hardened; for example, its rudimentary detection of double/invalid frees, and free list pointers that occupy deallocated slots [16]. This is achieved by recording the application's use of pointer values, updating their status after the target objects have been freed. However, GUARDER supports more security features and a higher level of entropy, due to its unique and novel design as described in Section 4: (1) GUARDER supports heap over-provisioning, which FreeGuard does not. dnmalloc dedicates a separately allocated area to house object metadata, and also utilizes a table to maintain mappings between these chunks and their metadata, an approach that is not unlike that of DieHarder or OpenBSD [40]. However, they cannot support the randomization of memory allocations.Iwahashi describes a signature-based approach to detect and identify the cause of these and potentially other vulnerabilities [18]. Cabellero et al. describe Undangle, a runtime approach for detecting use-after-free vulnerabilities through the use of object labeling and tracking, which helps discover dangling pointers [10].