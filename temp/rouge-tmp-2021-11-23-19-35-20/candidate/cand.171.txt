Additionally , QSYM loosens the strict soundness requirements of conventional concolic executors for better performance, yet takes advantage of a faster fuzzer for validation, providing unprecedented opportunities for performance optimizations , e.g., optimistically solving constraints and pruning uninteresting basic blocks. Our evaluation shows that QSYM does not just out-perform state-of-the-art fuzzers (i.e., found 14× more bugs than VUzzer in the LAVA-M dataset, and outper-formed Driller in 104 binaries out of 126), but also found 13 previously unknown security bugs in eight real-world programs like Dropbox Lepton, ffmpeg, and OpenJPEG, which have already been intensively tested by the state-of-the-art fuzzers, AFL and OSS-Fuzz. These new techniques and optimizations together allow QSYM to scale to test real-world programs.Our evaluation shows that the hybrid fuzzer, QSYM, -built on top of our concolic executor, and the state-ofthe-art fuzzer, AFL-outperforms all existing fuzzers like Driller [8] and VUzzer [9]. A QSYM-based hybrid fuzzer outperformed state-of-the-art automatic bug finding tools (e.g., Driller and VUzzer) in the DARPA CGC and LAVA test sets. [12] to test angr because angr does not support the fadvise syscall, which is used in the coreutils applications.this significant overhead in symbolic emulation when we execute several programs without branching out to the other paths (no path explosion) or solving constraints on the path in widely-used symbolic executors, KLEE and angr. We describe the details of these in the following.Why IR: IR makes emulator implementation easy.Existing symbolic emulators translate a machine instruction to one or more IR instructions before emulating the execution. For instance, the most popular Intel 64-bit instruction set architecture (i.e., the amd64 ISA) contains 1,795 instructions [13] described in a 2,000-page manual [14]. Because the amd64 architecture is a complex instruction set computer (CISC), whereas the IRs model a reduced instruction set computer (RISC), in most cases, a translation of a machine instruction results in multiple IR instructions. According to our measurement with the real-world software (Figure 2), such as libjpeg, libpng, libtiff, and file, only 30% of instructions in symbolic basic blocks require symbolic execution. In particular, for conventional concolic engines, a snapshot is taken when the engine splits the path exploration from one conditional branch (i.e., the taken and untaken paths). The engine can explore the path without paying overhead for re-executing the program to the branch.On the contrary, the concolic execution engine in hybrid fuzzing fetches multiple test cases from the fuzzer with which they are associated different paths of the program (i.e., sharing no common branch). Thus, concolic execution engines should maintain the states by itself.Existing tools try to solve this problem through either full system concolic execution or external environment modeling, but they result in significant performance slowdown and inaccurate testing, respectively. Although this approach ensures completeness and correctness, the tools cannot test the program in a reasonable time because conventional concolic executors are too slow and the complexity of the external environment is high. Optimize repetitive concolic testing, remove the snapshot mechanism that is inefficient in hybrid fuzzing, and use concrete execution to model external environments. In the lower code of Figure 3, if ch is defined as 'A' by a given concrete input, concolic execution will put the constraint, {ch >= 0x20 ∧ ch < 0x7f}, at looks_ascii() because the native execution will execute the true branch of the if statement. However, if file_tryelf() does not depend on the true branch of looks_ascii(), this is the over-constraint problem because an input generated by concolic execution without caring about the path constraint, ch == 0x7f, will explore a path in file_tryelf(). QSYM aims at achieving fast concolic execution by reducing the efforts in symbolic emulation, which is the major performance bottleneck of existing concolic executors. However, for QSYM, the efficient DBT makes it possible to implement a fine-grained, instruction-level taint tracking and symbolic execution, helping us to avoid unnecessary emulation overheads. For example, in angr, any symbolic arguments to the memset() can prevent its symbolic execution because memset() relies on complex instructions like punpcklbw.QSYM runs both native and symbolic executions in a single process by utilizing the DBT, making such mode switches extremely lightweight (i.e., a normal function call). It is worth noting that this approach is drastically different from most of the existing concolic engines, such as angr, where two execution modes should make nontrivial communications such as updating memory maps to make a mode switch. Unlike QSYM, other concolic executors such as S2E and Driller incrementally solve constraints; that is, they focus on solving the updated parts of constraints in the current run by utilizing lemmas learned from the previous execution. The snapshot approach, which creates an image of a target process and reuses it later, is chosen to overcome the performance bottleneck of the concolic execution; reexecuting a program to reach a certain execution path with a valid state can take much longer than restoring the corresponding snapshot. Thus, as a hybrid fuzzer, it is well justified to formulate potentially new test inputs, regardless of reaching unexplored code via the current path or other paths.QSYM strives to generate interesting new test cases from the generated constraints by optimistically selecting and solving some portion of the constraints, if not solvable as a whole. To mitigate this problem, QSYM attempts to detect repetitive basic blocks and then prunes them for symbolic execution and generates only a subset of constraints. One exception is when a block contains constant instructions that do not introduce any new symbolic expressions, e.g., mov instructions in the x86 architecture and shifting or masking instructions with a constant.QSYM decides to use exponential back-off to prune basic blocks since it rapidly truncates overly frequent blocks. This helps not to lose constraints that are essential to discover a new path and also does not affect much on the symbolic execution because running such basic blocks a small number of times would not make the constraints too complex.Context-sensitivity acts as a tool for distinguishing running the same basic block in a different context for frequency counting. For example, when there are two strcmp() calls, say strcmp(buf, "GOOD") and strcmp(buf, "EVIL"), these two calls must be considered as a different basic block execution for frequency counting. QSYM relies on Intel Pin [24] for DBT, and its core components are implemented as Pin plugins written in C++: 12K LoC for the concolic execution core, 1.9K LoC for expression generation, and 1.5K LoC for handling system calls. To evaluate QSYM, this section attempts to answer the following questions:• We used three cores respectively for master AFL, slave AFL, and QSYM for end-to-end evaluations ( §5.1, §5.2, and §5.4) and one core for testing concolic execution only ( §5.3 and §5.5). We selected libpng as a fuzzing target because it contained various narrow-ranged checks (e.g., checking the 4-byte magic value for chunk identification) that were non-trivial to satisfy without proper seeding inputs in the fuzzing-only approach. On the contrary, QSYM not only formulated and solved the constraints for checking the PNG's magic header identifier but also explored more than 20% of code paths of libpng, which was 3% higher than the code coverage of fuzzing with valid images, i.e., the 20% AFL case. The CGC dataset included a wide range of programs from simple login services to sophisticated programs that attempt to mimic real-world protocols. To make our analysis simpler, we selected the first PoV (only one) as a seeding input for both fuzzers.To show the fuzzing result, we used the code coverage that we measured from all the test cases generated while fuzzing each CGC challenge. The AFL bitmap consists of 65,536 entries to represent code coverage, which is reasonable enough for our comparison purpose.Since the direct comparison of simple code coverage numbers might not properly indicate which fuzzer explored more and different code paths, we relatively compared their code coverage (see below). At a high level, Driller spent 27% of its execution time for creating snapshots and 70% for symbolic emulation (see, Figure 10(a)) In other words, Driller spent 2× more time than QSYM for concolic execution, but most of its time was spent for emulation and snapshot.The instruction-level symbolic execution implemented in QSYM played a major role in speeding up the symbolic emulation. To read a message, an attacker should go through the following process: (1) create a new user (user1), (2) create another user (user2), (3) log in as user1, (4) send a message to user2, (5) logout, (6) log in as user2, and (7) read a message by sending a message id to read. This shows that QSYM's efficient symbolic emulation is effective in discovering sophisticated bugs hidden deeper in the program's path.2) With a limited time budget (5 to 30 minutes), Driller gets more coverage in applications with multiple nested branches within quickly reachable paths (i.e., shallow paths) because its snapshot mechanism is optimized for this case. In such a case, concolic execution concretizes the entire symbolic constraints to the current input because the table lookup over-constrains input symbols to have only one solution that is identical to an initial test case. However, with the optimistic solving, even if the constraint is unsatisfiable, the solver will solve only the last constraint and generate a potential crash input, which helps fuzzer move forward if this optimistic speculation is correct.We also compared QSYM with other state-of-the-art systems; QSYM outperformed them (Table 6). QSYM found 14× more bugs than VUzzer and any other prior techniques in the LAVA-M dataset.To evaluate our decision for optimistic solving that uses only the last constraint among constraints in an execution path, we measured the elapsed time and the number of bugs found in the LAVA-M dataset while changing the number of additional constraints. By adopting this, concolic executors can automatically truncate such complex yet irrelevant logic and stay focused on the input fields that determine a program's control flow.Optimistic solving (in §3.2) could also be applied to other domains to speed up symbolic execution, with a condition if the domain runs an efficient validator like a fuzzer. However, in hybrid fuzzing like QSYM, because the fuzzer can efficiently validate whether the input drives the program to an expected state (i.e., finding a new code coverage) or not, we can quickly extract some useful results from the haystack. Frequency-based analysis step and Markov chain modeling in AFLFast, as well as error-handler detection in VUzzer, could generate more meaningful input, which would result in using QSYM's concolic executor more efficiently. Coverage-guided fuzzing becomes popular especially since AFL [1] has shown its effectiveness. Also, AFLFast [34] uses a Markov chain model to prioritize paths with low reachability, and CollAFL [36] provides accurate coverage information to mitigate path collisions.However, fuzzing has a fundamental limitation: it cannot traverse paths beyond narrow-ranged input constraints (e.g., a magic value). In contrast, QSYM uses (1) fuzzing to explore most paths to avoid the path explosion problem, (2) generic heuristics (e.g., basic block pruning) without assuming any specific bug type, and (3) instruction-level re-execution-based symbolic execution for better performance. More importantly, QSYM found 13 previously unknown bugs in the eight non-trivial programs, such as ffmpeg and OpenJPEG, which have heavily been tested by the state-of-the-art fuzzer, OSSFuzz, on Google's distributed fuzzing infrastructure.