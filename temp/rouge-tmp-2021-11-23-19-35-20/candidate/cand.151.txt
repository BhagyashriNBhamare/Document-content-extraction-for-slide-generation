Second, using Syzkaller directly on mobile systems is challenging due to (i) lack of support for latest fuzzing features, such as new kernel sanitizers [9][10][11][12] and (ii) lack of access to the system's console without using a specialized adapter [8]. That is, since the device driver executes within a virtual machine, it enables the analyst to use various dynamic analyses including manual interactive debugging, record-and-replay, and enhanced fuzzing.Executing a mobile system's device driver within a workstation virtual machine is normally impossible since the driver requires access to the exact hardware of the I/O device in the mobile system. Examples are KASAN [9], which finds use-after-free and out-ofbounds memory bugs, KTSAN [11], which detects data races, KMSAN [10], which detects the use of uninitialized memory, and KUBSAN [12], which detects undefined behavior. For example, we show that we can easily use KASAN in Charm by simply porting our drivers to a KASAN-enabled virtual machine kernel.Finally, Syzkaller can more effectively capture and analyze crash bugs when fuzzing a virtual machine compared to a mobile system. On the other hand, getting the console messages from a mobile system at the time of the crash is more challenging and requires a specialized adapter [8], which is not available to all analysts and is not easy to use. If forced (e.g., by forcing the call to initialize the driver), the driver will immediately throw an error (since it will not be able to interact with the I/O device hardware), potentially resulting in a kernel panic in the virtual machine.In this case, one might wonder whether we can emulate the I/O device hardware for the virtual machine in software. Unfotunately, doing so requires prohibitive engineering effort due to the diversity of I/O devices in mobile systems today.The second approach is to run the device driver in a virtual machine in the mobile system and use the direct device assignment technique [21,24,43,53,54] (also known as device passthrough) to enable the virtual machine to access the underlying I/O device. In this paper, we show that by leveraging native execution of an x86 processor and a customized low-latency USB channel, we can not only eliminate time-outs but also achieve performance on par with the execution of the analysis running directly on the mobile system.The second concern is that the disparity between the ARM Instruction Set Architecture (ISA) used in mobile systems vs. the x86 ISA used in the virtual machine may result in incorrect device driver behavior, which can affect the analysis, e.g., false positives in bugs detected by a fuzzer. To achieve this, a stub module in the workstation's hypervisor communicates with a stub module in the mobile system to support the device driver's interactions with its hardware. Therefore, for a remote device driver to get initialized in the virtual machine, we must enable the kernel of the virtual machine to "detect" the corresponding I/O device as being connected to the virtual machine. In an x86 virtual machine, the ACPI interface is emulated by the hypervisor.The first solution that we considered was to add a remote I/O device to the hypervisor's ACPI emulation layer so that the virtual machine kernel can detect it. Both in the mobile system and in the workstation, our stub modules read and write to these endpoints directly in the kernel (the host operating system kernel in the case of the workstation) hence avoiding costly user/kernel crossings. Instead, it uses the bus driver API.Second, if a module is needed on the mobile system, we keep the module in the mobile system and implement a Remote Procedure Call (RPC) interface for the driver in the virtual machine to communicate with it. At its core, this is similar to porting a driver from one Linux kernel to another, e.g., porting a driver to a different Linux kernel version or to the kernel used in a different platform. We have ported 4 device drivers to Charm: the camera and audio device drivers of LG Nexus 5X, the GPU device driver of Huawei Nexus 6P, and the IMU sensor driver of Samsung Galaxy S7. Regardless, we show in ยง6.2 and ยง6.4 that we can still effectively fuzz the device driver and even find bugs.We use a workstation in our prototype consist-ing of two 18-core Xeon E5-2697 V4 processors (on a dual-socket SeaMicro MBD-X10DRG-Q-B motherboard) with 132 GB of memory and 4 TB of hard disk space. Alternatively, one can use an automated tool for template generation, such as DI-FUZE [36]. The first three setups (standing for Light-weight VM, Medium-weigh VM, and Heavy-weight VM) represent fuzzing the device driver in Charm while the last one represents fuzzing the device driver directly on the Nexus 5X smartphone. While they are close in version, one is for x86 and one is for ARM and hence the coverage in the rest of the kernel cannot be directly compared in these setups.In the second experiment, we choose a benchmark that significantly stresses Charm: the initialization of the camera driver in Nexus 5X. As mentioned in the previous section, the normal initialization of this driver in Charm takes 1760 ms. The results show that (i) recording does not add significant overhead to Charm's execution and (ii) the replay is much faster than the normal execution (indeed, the replay is even faster than the initialization time on the smartphone itself, which is 555 ms). One key question that we would like to answer is whether using an x86 virtual machine for a mobile I/O device driver would result in a large number of false positives, which can make the fuzzing more difficult for the analyst as s/he will have to filter out these false positives manually. Not only it facilitates fuzzing, it enables newer features of the fuzzer that is not currently supported in the kernel of the mobile system.Our analysis showed that these bugs belong to 7 categories: one unaligned access to I/O device registers, 19 NULL pointer dereferences, one invalid pointer dereference, one use-after-free, one out-of-bounds access, one divide-by-zero, and one explicit BUG() statement in the driver.Fuzzing with Charm uncovered 14 previously unknown bugs. To trace the origin of the array vc cfg, we utilize watchpoints to trace its parent structure csid lut params and finally locate another function, msm csid cmd, which is responsible for initializing the structure. This is because starting from line 6, the right side of the assignment statements is also controlled by a parameter stream cfg cmd originated in user space.Together with the user controlled index variable i, this vulnerability becomes an ideal target for privilege escalation, which we show we can achieve next. Such a large memory footprint can destroy the integrity of data stored nearby and cause a kernel crash.To address the first problem, we borrow the heap feng shui idea from the exploit of CVE-2017-7308 [5] to precisely co-locate the "vulnerable object" with one or more "target objects" (where one of their function pointer fields is the target for overwriting). This means that we can potentially spray a large number of target objects and try to arrange the target objects to be at a desired offset from the vulnerable object.To address the second problem, where a 480-byte overwrite may crash the kernel unintentionally, it is necessary to know the size of the target object and how likely they will align with the vulnerable object. The closest to our work are Avatar [77] and SURRO-GATES [50], solutions for dynamic analysis of binary firmware in embedded devices, such as a hard disk bootloader, a wireless sensor node, and a mobile phone baseband chip. In both Rio and M+, the device driver remains in the machine containing the I/O device.Code offload has been an important topic in mobile computing research [35,38,44,45] in an effort to improve performance and reduce energy consumption. In other words, Charm enables all of these dynamic analysis solutions to be applied to device drivers of mobile systems as well.Fuzzing is an effective dynamic analysis technique, which can be applied to the operating system kernel and device drivers as well. Charm can benefit from Slowfuzz since it generally broadens the scope of the fuzzers' use cases.The diversity of device drivers and their direct interactions with physical I/O devices create challenges for dynamic analysis. The former enables security analysts to support new device drivers, while the latter enables them to immediately apply different dynamic analysis techniques to the set of device drivers that Charm already supports.Our current prototype of Charm only supports open source device drivers. Unfortunately, the overhead of instruction interpretation slowed the execution down to a point that our device drivers triggered various time-out errors.This made us realize that native execution is needed to meet the device driver's latency requirements, and hence we used a hardware-virtualized x86 virtual machine and reimplemented Charm in KVM.Note that it is possible to use an ARM workstation in order to have native ARM execution for the Charm's virtual machine. To support the initialization of a new device driver, we only need to copy the device tree entries corresponding to the I/O device of interest from the device tree of the mobile system to that of the virtual machine. Fortunately, it is a one-time effort since the RPC interface is built on top of generic Linux API shared across all Linux-based mobile systems (as mentioned in ยง4.4 Table 1: Device drivers currently supported in Charm.can simply be reused. This initialization phase, among others, reads a large amount of data from an EEPROM chip used to store camera filters and causes many remote I/O operations (about 8800). By single-stepping through the initialization code, we find that if an error occurs during the vc cfg initialization at line 2, it will be freed at line 4 and then the initialization loop will terminate at line 6. For example, Charm can fuzz the device driver fully in a virtual machine.Other forms of remote I/O exists for mobile systems as well, such as Rio [22] and M+ [60]. Therefore, one smartphone vendor might use a powerful camera so that its smartphone would stand out in this market, while another might be the first to incorporate a fingerprint scanner.Such diversity has an important implication for the operating system of mobile systems: a large number of highly diverse and customized device drivers are required to power the corresponding set of distinct I/O devices. Moreover, some other systems, e.g., some Xperia smartphones, have the UART hardware, but accessing it requires opening up the system, finding the UART pins, and soldering connections [14], which is a difficult and error-prone task. Indeed, in our first prototype of Charm, we used a QEMU ARM virtual machine with ARM-to-x86 instruction interpretation on our x86-based workstation and implemented Charm fully in QEMU. For example, when porting the Nexus 6P GPU driver, we noticed that the Linux memory shrinker API in the virtual machine kernel is slightly different than that of the smartphone. Fortunately, since we know struct inet sock objects are allocated sequentially from low addresses to high addresses in a block, we can simply iterate the close() on each and every socket from user space and stop as soon as we notice a redirection of the control flow, ensuring that no one will touch the corrupted object. Specifically, record-and-replay can facilitate the analysis of the bugs triggered by Syzkaller, as discussed earlier.Second, it is easier to leverage new kernel sanitizers of Syzkaller in a virtual machine compared to a mobile system. That is, it enables the device driver to run in a virtual machine on a different physical machine, i.e., a workstation.As mentioned earlier, a device driver needs access to its I/O device for correct execution. In the end, we also set a watchpoint for step boundary and find that its value comes from a function argument passed from user space, which is untrusted.CVE-2016-2061. We also studied a similar issue for bugs #23 and #24, which are also triggered in Charm (but not in the mobile system) for a similar reason.We believe that these results demonstrate that Charm can be used to effectively find correct bugs in device drivers through fuzzing. It leverages the commonly available USB interface and hence makes our solution immediately available to security analysts.Second, in addition to interacting with the I/O device's hardware, a device driver interacts with several other modules in the operating system kernel including a bus driver, the power management module, and the clock management module. Third, we show that Charm enables us to find 25 bugs in drivers including 14 previously unknown bugs (several of which we have already reported) and two bugs detected by a kernel sanitizer not available on the corresponding mobile system's kernel. It uses the Intel Processor Tracer (PT) to collect execution traces in the hypervisor and use that to guide the fuzzer. In this channel, we create a USB gadget interface [13] for Charm and attach five endpoints to this interface. For example, the USB 3.0 standard (used in modern mobile systems) can handle up to 5 Gbps.In Charm, in addition to bandwidth, the latency of the channel between the workstation and the mobile system is of utmost importance. Moreover, we show, through our evaluation, that non-driver developers should also be able to perform the port as long as they have some knowledge about kernel programming, which we believe is a requirement for security analysts working on kernel vulnerabilities.Porting a device driver to run in Charm requires the following steps. The device driver executes fully in the workstation and only the infrequent low-level I/O operations are forwarded and executed on the physical mobile system.In Charm, the latency of remoting the low-level I/O operations to the mobile system is of critical 