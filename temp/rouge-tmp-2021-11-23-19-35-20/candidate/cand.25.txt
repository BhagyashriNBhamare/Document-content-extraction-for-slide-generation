Our findings highlight the intricacies of cache attacks on ARM and suggest that a fair and comprehensive vulnerability assessment requires an in-depth understanding of ARM's cache architectures and rigorous testing across a broad range of ARM based devices. The majority of attacks have been demonstrated on classic desktop and server hardware [25,30,42,51], and with Intel's market share for server processors being over 98% [31], their platforms have been targeted most frequently.With mobile usage skyrocketing, the feasibility of cache attacks on smartphone and IoT processors -which are predominantly ARM-based -has become a relevant issue. This inhibits cross-core LLC evictions, a key requirement for practical Evict+Time, Prime+Probe, and Evict+Reload attacks on multi-core systems, and further limits the number of ARM based attack targets in practice.In literature, Lipp et al. [37], Zhang et al. [54], and Zhang et al. [56] confirmed the general feasibility of flush and eviction based cache attacks from unprivileged code on ARM processors. In summary, our main contributions are:• the disclosure and description of AutoLock, an undocumented and previously unknown cache implementation feature with adverse impact on practical eviction based cache attacks on ARM devices,• a comprehensive test suite to determine the existence of AutoLock on actual devices, as its presence is not documented publicly,• a discussion of AutoLock's implications and its relation to previous literature demonstrating cache attacks on ARM, and• a set of strategies to circumvent AutoLock together with a practical demonstration of a crosscore Evict+Reload attack on a multi-core SoC implementing AutoLock.The rest of this paper is organized as follows. For simplicity, the illustration is based on a two-level cache hierarchy: core-private L1 caches and a shared inclusive last-level cache (L2) with one inclusion bit per cache line. This line is then evicted to allow the allocation of a new one.If the number of ways in the inclusive lower cache level, W l , is higher than the sum of ways in all higher cache levels, i.e., W h,sum = ∑ N i=1 W h,i , it can be guaranteed that at least one line is always selectable for eviction. While not impossible per se, this case is not covered by the patent authors.If an inclusive LLC with AutoLock is targeted in a cache attack, the adversary is not able to evict a target's data or instructions from the LLC, as long as they are contained in the target's core-private cache. Of the four Cortex-A processors we study in this paper, the technical reference manuals do not mention programmable lockdown for any of them [5,6,8,9]. Input: C ... list of set-congruent addresses1 for i = 0..N-1 do /* # of windows */ 2 for j = 0..A-1 do /* # reps/window */ 3 for k = 0..D-1 do /* # addrs/window */ 4 access(C[i + k]); 5 end 6 end 7 endThe idea is to always access a subset of the addresses in C for a number of repetitions, then replace one address in the subset with a new one, and repeat. This is done by creating a list of setcongruent addresses C and exhaustively iterating over multiple choices of N, A, and D. By continuously checking the success of the eviction, the strategy with the least number of memory accesses that still provides reliable eviction can be determined. The second test utilizes the performance monitoring unit, which can count the occurrence of microarchitectural events in a processor. The difference of the access counts before and after reloading the target address T indicates whether the reload fetched the address from the L1 or the L2 cache. The LLCs on the Cortex-A7 and A53 are inclusive to the L1 instruction caches, while the LLCs on the Cortex-A15, A57, and the Krait 450 are inclusive to the L1 data caches. This is derived from the inclusiveness property of the L2 cache.To conduct the tests, we connect each supported board, in turn, to the DSTREAM and use breakpoints to temporarily halt program execution after the eviction algorithm is run. This confirms the results for the A57 derived with the hardware debugger, i.e., that it implements AutoLock. Knowing how the key is involved in the memory accesses, this sequence (or trace) allows to infer bits of the key, which is the basis of so-called tracedriven attacks that have been studied further by Acıiçmez and Koç [2], Fournier and Tunstall [19], and Gallais and Kizhvatov [20]. We believe this can mainly be explained with their selection of test devices: the OnePlus One, the Alcatel One Touch Pop 2, and the Samsung Galaxy S6. However, said flush instruction, unlike on x86 processors, is not available on any ARMv7-A compliant processor and must be enabled in control registers on ARMv8-A compliant processors. While newer cores such as the Cortex-A72 and A73 might be affected as well, it remains unclear whether this also holds for the ARM-compliant cores, such as the Kryo (the successor of the Krait), the Mongoose (M1, M2), as well as the cores integrated into the Apple SoCs.If a device implements AutoLock, adversaries must find and employ circumvention strategies to leverage the full potential of eviction based cache attacks. Despite the restrictions that Automatic Lockdown poses to eviction based cache attacks, its effects can be alleviated with the following strategies:• Pre-select Target SoCs: Our findings suggest that AutoLock is present on Cortex-A cores designed by ARM itself, while it is not implemented by ARM compliant cores, such as Qualcomm's Krait 450. If the attack allows, an adversary can take advantage of the low associativity and simply prolong the waiting time between reloads such that the target line will automatically be evicted from core-private caches by other system activity scheduled on the respective core. As a result, the number of required observations increases, as P na gets smaller.The attack targets the last round of AES, i.e., the 10 th round. For the recovery phase, the last round is re-written asc i = k 10 i ⊕ T [s i ] → k 10 i = c i ⊕ T [s i ] . After all scores have been added for all hypotheses, the recovery phase proceeds as proposed.We implement the original attack and all improvements using Evict+Reload on a multi-core ARM Cortex-A15 processor featuring a data-inclusive LLC with AutoLock. The probability filter (prob_filter) still allows full-key recovery within 100,000 encryptions, if a brute-force search with complexity < 2 32 is added.The results illustrate that even on processors implementing AutoLock cache attacks can still be successful in practice, if multiple cache lines are monitored. Paired with a limited understanding of how ARM's cache architectures function internally, this makes assessing the practical threat of flush and eviction based cache attacks on ARM a challenging task. If no other L1 cache holds a copy of L, the inclusion bit must be reset in L2, which unlocks the copy of L in L2. Irazoqui et al. [28] demonstrated the applicability of cache attacks across CPUs through the cache coherency protocol, which allows the execution of Flush+Reload style attacks by forwarding cache flush and data request messages between two CPU clusters. In the algorithm, N denotes the total number of generated windows, A defines the repetitions per window, and D denotes the number of addresses per window. Due to the versatility of this test, we recommend its use in situations where either adequate debugging equipment is not available or the abilities to conduct the other, more robust experiments are not given (e.g., when root access on a device cannot be gained due to vendor restrictions). This is necessary because the ARM architecture allows memory accesses to be reordered to optimize performance.As a result, we observe that reloading the target in- struction after executing the eviction algorithm causes no additional L2 access. In the upcoming section, we pick up this idea and demonstrate how the attack can be extended to exploit multiple cache lines to successfully circumvent AutoLock.Note that all of the presented strategies increase the chances of successful attacks not only on inclusive caches implementing AutoLock, but also on noninclusive caches. In addition, ARM's highly flexible licensing ecosystem creates a heterogeneous market of systemon-chips (SoCs) that can exhibit significant differences in their microarchitectural implementations. Given an inclusive LLC, it is sufficient to confirm that T either remains in L1 or in L2 to prove that AutoLock is present. For example, the transformation tables (Ttables) of AES software implementations span multiple cache lines due to their size of several kilobytes. The Flush+Reload technique was concurrently used by Benger et al. [12] to recover ECC secret keys, by Zhang et al.[58] to launch cross-tenant attacks on PaaS clouds, and by Gruss et al. [24] to implement template attacks. By exclusively targeting Cortex-A compliant processors not implemented by ARM, chances of not encountering AutoLock might increase. In a patent publication by Williamson and ARM Ltd., the authors propose a mechanism that protects a given line in an inclusive cache level from eviction, if any higher cache level holds a copy of the line [50]. For each processor, we verify that the eviction parameters listed in Table 1 can successfully evict cache lines in a same-core setting. Each row shows one attack technique and the corresponding effect of AutoLock in three different scenarios: same- Table 5: Selection of recent smartphones from manufacturers with high global market share [16]. Furthermore, the presented circumvention strategies implicitly facilitate cross-core eviction based attacks also on non-inclusive caches. The second process then tries to evict the line from the LLC by filling the corresponding cache set with dummy data. Respectively, these mobile phones feature the Krait 400, the Cortex-A53, and a big.LITTLE configuration of the Cortex-A53 and Cortex-A57. On Intel processors, the entire cache hierarchy fulfills the inclusiveness property and is therefore a viable target for eviction based attacks. Access to these control registers is limited to privileged, i.e., kernel or hypervisor code. In the dual-core setting, core 0 is accessing the target address T and core 1 is trying to evict it by using the eviction set C and the processor specific eviction parameters N-A-D. It is shown in Equation 2. Given an AES-128 implementation that uses four 1 kiB T-tables and performs 160 lookups per encryption, which evenly spread over the four tables, n = 40. To leverage observations from all available cache lines, we propose three improvements to the original attack:1. It lists devices from major manufacturers that have high global market shares [16]. This leaves a significant number of ARM processors without a cache flush instruction.For all processors with a disabled flush instruction or an earlier architecture version, e.g., ARMv7, only eviction based cache attacks can be deployed. If the least significant address bits match while the most significant bits differ, the address will map to T 's cache set but will be placed on a different line within the set. This is because in the context of cross-core LLC evictions, inclusive lastlevel caches with AutoLock behave identically to noninclusive ones. If a cache level x is inclusive with respect to a higher level y, then all valid cache lines contained in y must also be contained in x. If a copy of L is present in any other of the coreprivate L1 caches, it can immediately be evicted without updating the inclusion bit in L2. In this case, the patent proposes to fall back to the previous behavior, i.e., evict all copies of a line from higher level caches. The score is based on the absolute difference of the no-access probabilities, d l = abs P na − ˜ P l na . We ran the experiments several times on the A15, A53, and A57 processors. Once the inclusiveness property of the LLC is ensured, AutoLock can be tested as described in the following sections. We therefore provide a detailed description of the feature and propose three methodologies to test for it: using a hardware debugging probe, reading the performance monitoring unit (PMU), and conducting simple cachetiming measurements. In fact, cache attacks have been demonstrated in multiple scenarios in which our personal data is processed, e.g., web browsing [41] or cloud computing [26,58]. In other previous work, Zhang et al.[54] implemented a Prime+Probe attack in an unprivileged Android application on an ARM Cortex-A8. The basic strategy is to flush one cache line per table before an encryption and reload it afterwards. As the underlying attack strategies are more generic, Acıiçmez [1] and Percival [44] utilized Prime+Probe to steal an RSA key while Neve and Seifert used it to perform an efficient last round attack on AES [40]. This is because the last-level caches on our test devices use bits of