Third, attackers might execute a man-inthe-middle attack on the connections between users and update providers (e.g., with DNS cache poisoning [67] or BGP hijacking [6]), thus enabling themselves to mount replay and freeze attacks [15] against their targets. Hence, modern software-update systems should provide efficient and secure means to evolve signing keys and should enable client notification in a timely manner.To address these challenges, we propose CHAINIAC, a decentralized software-update framework that removes single points of failure, increases transparency, ensures integrity and authenticity, and retains efficient verifiability of the software-release process. An additional advantage of this approach is that companies, in order to provide the source-to-binary guarantee to customers, can reveal source code only to third-party build verifiers who sign appropriate non-disclosure agreements.Third, CHAINIAC increases transparency and ensures the accountability of the update process by implementing a public update-timeline that comprises a release log, freshness proofs, and key records. Finally, creating a skipblock of the aggregate update timeline for the full Debian repository of about 52,000 packages requires only 20 seconds of CPU time for a witness server, whereas receiving the latest skipblock on a client introduces only 16% of overhead to the usual communication cost of the APT manager [23]. • We implement CHAINIAC (Section 7) and evaluate (Section 8) a prototype on real-world data from the Debian and PyPI package repositories.In this section, we give an overview of the concepts and notions CHAINIAC builds on, this includes scalable collective signing, reproducible builds, software-update systems, blockchains, and decentralized consensus. Furthermore, we use the witness-cosigned timestamp service [69] as a building block in our design for the protection of clients against replay and freeze attacks [15] (where clients are blocked from learning about the availability of new software updates by an adversary). As each block includes a hash of the prior block, it depends on the entire prior history, thus forming a tamper-evident log.CHAINIAC uses BFT-CoSi, introduced in ByzCoin [42], as a consensus algorithm to ensure a single consistent timeline, e.g., while rotating signing keys. CHAINIAC's skipchain structure is partly inspired by blockchains [41]: Whereas ByzCoin also uses collective signatures to enable lightclient verification, skipchains extend this functionality with skiplinks to enable clients to efficiently track and validate update timelines, instead of downloading and validating every signature. Linear immutable public release history: The software-update system should provide a globally consistent tamper-evident public log where each software release corresponds to a unique log entry that, once created, cannot be modified or deleted. Each release includes source code, binaries (potentially, for multiple target architectures), and metadata such as release description.A snapshot refers to a set of releases of different software projects at a certain point in time. Build verifiers are a subset of the witnesses who execute, in addition to their regular witness tasks, reproducible building of new software releases and compare them to the release binaries. Finally, we assume that users of CHAINIAC are able to securely bootstrap, i.e., receive the first version of a software package with a hard-coded initial public key of the system via some secure means, e.g., pre-installed on a hard drive, on a read-only media, or via a secure connection. Expecting the signing key to be uncompromisable is unrealistic, especially if shared among multiple parties, as attackers need to subvert only a single developer's machine to retrieve the secret key or to coerce only one of the key owners. If an attacker manages to replace a compiled binary with its backdoored version, before it is signed, the developers might not detect the substitution and unknowingly sign the subverted software.Eliminating these assumptions creates the need to track a potentially large number of dynamically changing signing keys; furthermore, checking a multitude of signatures would incur large overheads to end users who rarely update their software. To further unburden users and developers, we use a cothority to validate software releases (check developer signatures and reproducible binaries) and collectively sign them, once validated: steps 2 ⃝ and 3 ⃝ in Figure 1. To ensure update timeliness and further harden the system against key compromise, we introduce a multilayer skipchain-based architecture that, in particular, implements a decentralized timestamp role.Before presenting CHAINIAC in detail in Section 5, we introduce skipchains, one of CHAINIAC's core building blocks, in Section 4. Both B t and F t can store exactly h t links and a reference at index 0 ≤ i ≤ h t − 1 in B t (F t ) points to the last (next) block in the timeline having at least height i + 1. For a forward link from B t to B t+j , we store the cryptographic signature ⟨id t+j ⟩ Et at index i in F t where E t denotes the entity (possibly a decentralized collective such as a BFTCoSi cothority [41,42,69]) that represents the head of trust of the system during time step t. To create the required signatures for the forward links until all slots in F t are full, in particular, E t must "stay alive" and watch the head of the skipchain. If the client has the correct hash of an existing block and wants to obtain a future or past block in the timeline from an untrusted source (such as a software-update server or a nearby peer), to cryptographically validate the target block (and all links leading to it), the client needs to download only a logarithmic number of additional, intermediate blocks.Secondly, suppose two resource-constrained clients have two reference points on a skipchain, but have no access to a database containing the full skipchain, e.g., clients exchanging peer-to-peer software updates while disconnected from any central update server. Provided these clients have cached a logarithmic number of additional blocks with their respective reference pointsspecifically the reference points' next and prior blocks at each level -then the two clients have all the information they need to cryptographically validate each others' reference points. When a user receives an update, she verifies that a threshold of the developers' signatures is valid, as specified in the policy file already stored on user's machine. Therefore in our second step towards CHAINIAC, we transfer the responsibility of building binaries from users to developers.When a new software release is announced, it includes not only the source code but also a corresponding binary (or a set of binaries for multiple platforms) that users will obtain via an update center. Although decentralized developer approval and reproducible builds improve software-update security, running reproducible builds for each binary places a high burden on developers (e.g., building the Tor Browser Bundle takes 32 hours on an average modern laptop [60]). Clients can download and validate the release's source and/or any associated binary by verifying only a single collective signature and Merkle inclusion proofs for the components of interest.To validate a release, each cothority server checks the developer signatures against the public keys and the threshold defined in the policy file. The verified builds enable clients to obtain the guarantee of source-to-binary correspondence without USENIX Association 26th USENIX Security Symposium 1277 the need to accomplish the resource-consuming building work, due to the broad independent validation. Because the hash chain is cothority controlled, we can distribute the witnessing of its consistency across a larger group: for example, not just across a few servers chosen by the developers of a particular package, but rather across all the servers chosen by numerous developers who contribute to a large software distribution, such as Debian. CHAINIAC's transparency provisions not only protect users from compromised developers, but can also protect developers from attempts of coercion, as real-world attackers prefer secrecy and would be less likely to attack if they perceive a strong risk of the attack being publicly revealed. Using one set of keys for signing new releases and for timestamping introduces tradeoffs between security and usability, as online keys are easier compromisable than offline keys, whereas the latter cannot be used frequently. As a result, the ROOT skipchain has a height of one, with only singlestep forward and backward links.The CONFIG role represents the online keys of the update cothority and models CHAINIAC's control plane. This is equivalent to a downward link from the ROOT skipchain to the CONFIG skipchain.The RELEASE role wraps the functionality of the release log, as specified previously, and adds upward links to ROOT and CONFIG skipchains, enabling clients to efficiently look up the latest trusted ROOT and CONFIG configurations required for verifying software releases.Finally, the TIME role provides a timestamp service that informs clients of the latest version of a package, within a coarse-grained time interval. Before signing it off, the rest of the independent servers check that the hash inside the timestamp is correct and that the time indicated is sufficiently close to their clocks (e.g., within five minutes). Finally, the cothority forms a Merkle tree that summarizes all package versions in the snapshot, then collectively signs it.This architecture facilitates the gradual upgrade of large open-source projects, as packages that do not yet have their own skipchains can still be included in the aggregate layer as hash values of the latest release files. If there are such packages, the client accesses their individual release logs, knowing the hash values of the latest blocks.A multi-package project can potentially have several aggregate layers, each representing a certain distribution , e.g., based on the development phase of packages, as stable, testing, and unstable in Debian. As with developer keys, the regular rotation of cothority keys further impedes a gradual compromise.If a threshold of online cothority keys are compromised, then, once this compromise is detected, the developers can use the offline ROOT keys to establish a new cothority configuration (see Section 5.6). In Section 8.5, we simulated four collectively signing servers on a computer with a 3.1 GHz Intel Core i7 processor and 16 GB of RAM and did not include any network-latencies, as we measured only CPU-time and bandwidth.To evaluate the witness cost of the long-term maintenance of an update timeline, we used data from the Debian reproducible builds project [22] and the Debian snapshot archive [19]. We tested three sets of packages: (1) required is the set of Debian required packages [21], 27 packages as of today; (2) popular contains the 50 most installed Debian packages [20] that are reproducible and do not appear in required; (3) random is a set of 50 packages randomly chosen from the full reproducible testing set [22]. As it can be seen, the communication costs for Diplomat and skipchain are similar, even in the worst case where a skipchain has height-1 only, which corresponds to a simple double-linked list.To further investigate the best parameters of the skipchain, we plotted only the skipchain overhead using the same data. We then formed the aggregate Debian-testing skipchain over the same period.In the first experiment, a witness server receives a new repository-state to validate, verifies the signature for all the packages, builds a Merkle tree from the heads of the individual skipchains and signs its root, thus creating a new aggregate skipblock. Other systems [38,47,58] use overlay and peer-to-peer networks for efficient dissemination of security patches, whereas Updaticator [5] enables efficient update distribution over untrusted cache-enabled networks.Certificate, key, and software transparency. EthIKS [12] provides stronger auditability to CONIKS [51], an end-user key verification service based on a verifiable transparency log, by creating a Smart Ethereum Contract [75] that guarantees that a hash chain is not forked, as long as the ethereum system is stable and correct. The distinct layers of skipchains provide, while introducing minimal overhead for the client, multiple functionalities such as (1) tamperevident and equivocation-resistant logging of the new updates and (2) the secure evolution of signing keys for both developers and the set of online witnesses.