In addition, SGX also features sophisticated memory protection techniques that prevent memory snooping attacks: SGX code and data is always encrypted and integrity-protected as soon as it leaves the CPU chip, e.g., when it is stored in main memory. SGX is especially useful in cloud scenarios as it ensures isolated execution of code and data within an untrusted computing environment.SGX was designed to allow developers to protect small parts of their application that handle sensitive data, e.g., cryptographic keys, inside SGX containers called enclaves. Formally verifying or manually inspecting such complex legacy software is not feasible, meaning that the same memory-corruption vulnerabilities that plague legacy software are also very likely to occur in those complex enclaves.However, previous research on SGX has been mainly focused on side-channel attacks [31,29,6] and defenses [28,12,5]. Dark-ROP relies on running the target enclave multiple times to test multiple addresses, so randomizing the memory layout at initialization time makes previous results useless for new invocations.However, SGX-Shield does not randomize the part of the SGX SDK [14,15] that handles transitions between host code and enclave code. Side-channel attacks can leak critical secrets from the enclave, such as cryptographic keys.Controlled-channel attacks [31] employ a malicious kernel to infer memory access patterns at the granularity of pages by triggering page faults in the enclave. In response, Van Bulck et al. [29] proposed an attack that can monitor memory accesses at page granularity without interrupting the enclave. The former is used for kernel-mode operations, while the second for user-mode operations. An enclave can also exit because of a hardware exception (such as an interrupt), which needs to be handled by the kernel in untrusted mode. The programmer can choose which ECALLs are allowed at the zero nesting level, and which are allowed for each specific OCALL. To perform an ECALL, the application calls into the uRTS library, which executes a synchronous enclave entry (EENTER), passing the ECALL index in a register. The tRTS first pushes an OCALL frame onto the trusted thread stack, which stores the current register state (step 2). Thereafter, it executes a special variant of ECALL known as ORET (step 5), which will restore the context from the OCALL frame through a function named asm oret, thus returning to the trusted callsite (step 6). The resulting interrupt is handled by the kernel, which delivers an exception to the untrusted application by means of the usual exception mechanism of the OS (e.g., signals in Linux-based systems, structured exception handling in Windows). The tRTS then copies the faulting state from the SSA to an exception information structure on the trusted stack, and changes the SSA contents so that ERESUME will continue at a second-phase handler in the tRTS, instead of executing the faulting instruction again. The attacker has knowledge of a vulnerability in the enclave that allows her to either corrupt stack memory (e.g., a stack overflow) or corrupt a function pointer on the stack, heap, or other memory areas (e.g., heap overflow, use-after-free or type confusion). An attacker could also possibly achieve this via normal functionality, for example by steering the application or the enclave into allocating attacker-controlled data at predictable addresses. Our ultimate attack goal is to execute a sequence (chain) of gadgets, i.e., existing functions or short instruction sequences, to perform a malicious activity of the attacker's choosing, without crashing the victim enclave. In contrast, existing code-reuse attacks on x86 require the attacker to use specific register-setting gadgets (e.g., pop gadgets) to set registers.Not requiring those gadgets has two major benefits. In fact, our attacks allow the attacker to use whole functions as building blocks instead of small gadgets, allowing her to work on a higher level and making it easier to port the exploit between different versions of a binary.Our attacks abuse functionality in tRTS, a fundamental library of the Intel SGX SDK, which most enclaves use (Section 5). This primitive is based on abusing the function asm oret from the tRTS library in the Intel SGX SDK. The prerequisites for this primitive are control of the instruction pointer (to hijack execution to asm oret) and control of stack contents. This primitive requires the ability to call that function with a controlled rdi, which is achievable by exploiting a memory corruption vulnerability affecting a function pointer (not necessarily located on the stack). Note that, even if the main enclave code is randomized, it is very difficult to randomize all the enclave code (Section 8) and the nonrandomized code contains enough gadgets to successfully mount an attack (Section 7). Since it can be used to set the first function argument register and the instruction pointer, the attacker now has the controlled function call needed for CONT and can trigger the loop.Gadget ORET CONT ORET+CONT loop · · · · · · · · · · · · · · · · · · · · · · · ·Fake stack Fake exc. This function allows controlling parts of the CPU context, and can be a stepping stone to the CONT primitive.The prototype of the function is sgx status t asm oret(uintptr t sp, void *ms). Note that those addresses do not necessarily have to point to stack memory, nor to enclave memory, as enclaves can access untrusted memory.The first operation done by asm oret is shifting the stack pointer to the sp argument, i.e., the top of the OCALL frame. Starting with version 2.0 of the SDK, the code is more complex, as it also handles other tasks (such as restoring the extended processor state) before restoring the registers we are interested in. In the rest of this paper we will assume the attacker to always skip the initial part when reusing asm oret.An attacker who has control over the stack contents can reuse asm oret to set the registers mentioned in ocall context t. In comparison, continue execution provides more control than asm oret as the context it restores encompasses all general-purpose CPU registers.The prototype of this function is void continue execution(sgx exception info t *info), where info is a pointer to the exception information structure that contains the CPU context to restore. This is an essential ingredient for our ORET+CONT loop.We noticed an issue in continue execution on SDK versions prior to 1.6, which results in registers r8-r15 not being restored and rsi being restored with the value of Listing 3: CPU context information structure for continue execution. Since rsi can be controlled anyway (through r15), and r8-r15 are temporary registers that are not typically of interest to an attacker, this issue does not reduce the power of continue execution reuse significantly.As an example, continue execution can be reused by corrupting a function pointer and hijacking it to point to continue execution. Given those preconditions, the attacker can call continue execution with a fake sgx exception info t structure and gain full CPU context control.In another scenario, the attacker only has stack control, for example because of a stack overflow vulnerability. The context is crafted to launch a CONT primitive for the next gadget to continue the loop.Using the ORET+CONT combination is necessary because the attacker might want to control rdi, or the gadget might corrupt it; therefore, chaining CONT to CONT directly might not be possible. The enclave code is split up in 32-or 64-byte chunks, called randomization units, and each randomization unit is placed at an independent, randomized memory position aligned to its size. The SGX-Shield paper describes that backwards-edge CFI can be obtained by instrumenting return instructions and forcing the return address to point to the beginning of a randomization unit. On the other hand, if a call is the last instruction in a randomization unit, then the return address will point to the instruction immediately after the call: there is no guarantee that such an address marks the beginning of a unit. Our chain repeatedly invokes this gadget to write the shellcode 4 bytes at a time, followed by invocation of the shellcode.Since the only gadget we use preserves rdi, we can use the simplification described in Section 6.2.4 to only chain CONTs. A sgx exception info t structure is set up for the shellcode, with rip set to the shellcode's 1 mov dword ptr [ rcx ] , eax 2 mov eax , 1 3 ret Listing 4: Memory write ROP gadget from do rdrand in tRTS. This structure has rdi set to the address of the fake sgx exception info t structure for the first write gadget, and ocall ret set to the address of continue execution. In this case, the write gadget will be executed with the proper rax and rcx to place 4 bytes of the attacker's code at the proper location. Once an attacker is in possession of those keys, she can impersonate the enclave when communicating with the remote server.The keys are obtained with the EGETKEY leaf function. Both the EREPORT and the EGETKEY leafs only operate on enclave memory, so the shellcode has to take care of copying data in and out of the enclave. Our exploitation technique can be applied to a wide range of memory corruption vulnerabilities and significantly eases SGX exploits development. Consequently, we believe future mitigation schemes must take into serious consideration the implications of leaving SDK code easily accessible to attackers.Our attack also draws a parallel to Sigreturn Oriented Programming (SROP) [4] in the SGX world. However, at the callsite, rcx is set based on values that can be controlled via ORET.While analyzing the low-level internals of our primitives in the Linux SDK, we also noticed several differences between SDK versions that influence our exploits:• Setting the instruction pointer in asm oret differs before and after version 2.0. Hence, we believe that even in the presence of backward-edge CFI, a skilled attacker could still be able to launch our exploit, although the reusable code base has been reduced.On another note, we argue that the current Software Fault Isolation scheme deployed in SGX-Shield can be undermined by our attack. Moreover, in our attack scenario, the developer has to be careful that the check cannot be skipped by jumping over it. This method is much stronger than just embedding a secret, and its overhead would be negligible in our case, as the structures we target are not accessed very often.The second mitigation avenue is taking the SDK code base into serious consideration when designing hardening schemes. e1 ; Initial r e g i s t e r state : 2 ; rax = 0 ( EREPORT leaf ) 3 ; rbx = EEXIT return address 4 ; rcx = 5 1 2 + 5 1 2 + 6 4 5 ;( total size of s t r u c t u r e s ) 6 ; rdx = w r i t a b l e 512 -byte aligned enclave 7 ;area for t e m p o r a r y data 8 ; rdi = w r i t a b l e 512 -byte aligned enclave 9 ; area to copy s t r u c t u r e s into 10 ; rsi = address of a t t a c k e r 's K E Y R E Q U E S T + 11 ;T 14 push rbx 15 push rdi 16 ; Copy KEYREQUEST , TARGETINFO , 17 ; R E P O R T D A T A to enclave memory 18 rep movsb 19 ; EREPORT 20 lea rcx 1 ; Initial r e g i s t e r state : 2 ; rax = 0 ( EREPORT leaf ) 3 ; rbx = EEXIT return address 4 ; rcx = 5 1 2 + 5 1 2 + 6 4 5 ;( total size of s t r u c t u r e s ) 6 ; rdx = w r i t a b l e 512 -byte aligned enclave 7 ;area for t e m p o r a r y data 8 ; rdi = w r i t a b l e 512 -byte aligned enclave 9 ; area to copy s t r u c t u r e s into 10 ; rsi = address of a t t a c k e r 's K E Y R E Q U E S T + 11 ;T 14 push rbx 15 push rdi 16 ; Copy KEYREQUEST , TARGETINFO , 17 ; R E P O R T D A T A to enclave memory 18 rep movsb 19 ; EREPORT 20 lea rcx