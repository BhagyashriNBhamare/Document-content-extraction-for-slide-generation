To this end, we first define the problem as cross-principal manipulation (XPM) of Web resources, and then design an automated tool named XPMChecker to detect XPM behaviors in apps. Through a study on 80,694 apps from Google Play, we find that 49.2% of manipulation cases are XPM, 4.8% of the apps have XPM behaviors, and more than 70% XPM behaviors aim at top Web sites. For simplicity of presentation, we call them WebViews throughout the paper.Based on WebViews, mobile systems further provide app developers with Web resource manipulation APIs to customize browser behaviors and enrich Web app functionalities. Luo et al. [32,33] showed that malicious apps can attack WebView by injecting JavaScript code, sniffing and hijacking Web navigation events [32], and hijacking touch events at the Web pages [33]. Overall speaking, lacking such an empirical study may make us misunderstand the impact of the problem and limit the practicalness of proposed solutions.This paper seeks to perform a large-scale empirical study on real-world apps to systematically understand the existence and impact of such threats. Since Android apps are easy to be collected in a large volume and Android platform dominates the mobile market, our empirical study is based on Android platform.First, since not all manipulations cause security issues, we need a clear definition about the threat in Web resource manipulation. In our definition, only manipulating code from a different principal to the manipulated Web resource will be flagged as suspicious.Second, to allow measuring the Web resource manipulation problem on a large scale, we further design a tool to automatically recognize XPM behaviors in real-world apps. To systematically understand the threats of Web resource manipulation, we conduct several experiments and studies from these perspectives: the prevalence of the XPM behaviors, the breakdown of XPM behaviors, the awareness of such risks to service providers and the implications to current defenses. We also find that most of XPM behaviors are necessary to improve the usability for mobile users, some XPM behaviors implement OAuth implicit flow in an unsafe way, and we confirm the Web resource manipulation behaviors with obvious malicious intents for the first time in real-world Android apps and iOS apps. More specifically, we find apps can abuse Web resource manipulation APIs to steal cookies, collect user credentials and impersonate the identities of legitimate parties, and a large number of users have been affected. We also perform several experiments to test the awareness of such risks to service providers, and find that most Web service providers are unaware of these risks and can not effectively prevent users from accessing sensitive pages in WebView. There are three Java classes (C1, C2 and C3) in the two apps which use WebViews to load www.facebook.com and use CookieManager.getCookie API to get cookies from www.facebook.com.For C1 which belongs to the official Facebook app and C2 which belongs to the official Facebook Login SDK, it is quite normal for them to access cookies from www.facebook.com. We define where app code use Web resource manipulation APIs to manipulate Web resources as Web Resource Manipulation Points. At each Web resource manipulation point, there are two participated parties, i.e. the manipulating code and the manipulated Web resource. Specifically, we define the concept of Cross-Principal Manipulation (XPM) of Web resources, when the app principal is not the same as the Web principal at a Web resource manipulation point. However, we do not consider such low-level attacks that may be performed by host apps, since Web resource manipulation APIs are widely supported by mainstream mobile platforms. This paper focuses on measuring the security impact of Web resource manipulation APIs in real-world applications, while does not aim to study all kinds of threats in appweb interaction, which has been well-studied by existing work [32,33,17,23,36,48]. including quite sensitive resources, such as local storage and network traffic.To better understand the impact of the problem of cross-principal Web resource manipulation, we perform a thorough study of the WebView APIs provided by Android and iOS platform. These APIs can provide attackers with the ability to monitor/-modify network traffics between the WebView and the remote server.From Table 1, we can conclude that both Android and iOS provide powerful APIs for developers to manipulate quite sensitive Web resources. To support a large-scale empirical study of Web resource manipulation behaviors in real-world apps, this paper designs an automatic tool, named XPMChecker to recognize this behavior in apps. Although there is no existing identifiers to represent app principal, we find some indicators extracted from the code can represent app principal.For example, we can use Java package name, app name, etc. • Static Analyzer accepts an Android APK file as input, locates all possible Web resource manipulation points and collects manipulation information for each manipulation point. • XPMClassifier gives a final decision about whether a Web resource manipulation point is crossprincipal or not by leveraging nature language processing techniques and search engines.Since our study mainly targets Android, XPMChecker is implemented for Android. We do a forward data flow analysis from the "url" parameter, and collect all branch statements having string operations with the "url" parameter as the inferred positions.It is more complicated to handle Type II APIs, where the manipulated URLs are actually loaded by the base WebView instances. • META, the meta-information of the app, including application package name and developer information;• DP, the declaring package name of the manipulating code;• SIG, the signature for the manipulating code;The META and DP information can be directly extracted from the APK file and app market. To calculate the code signature, we first need to determine the boundary of the manipulating code and then extract its signature based on code feature inside the code boundary.Manipulating Code Union. Otherwise, we compare the Merkle trees for the two manipulating code signatures from top to bottom.In summary, the static analyzer module locates all manipulation points in each APK, extracts the manipulated URL and manipulating context for each point, and saves this information into a database. Since the protocol and port element defined in the Web origin are hard to compare with app principal, our solution uses the domain name at each manipulation point as the Web principal.Before extracting domains from Web resource URLs, we need to normalize the extracted URLs as there may be some abnormal URLs, such as short URL, IP address. Our insight is that Android developers usually include reverse domain name in the package name of their code.To distinguish library code and host app code, we use the signature for the code union (SIG). For example, if the app principal is "fb" and the Web principal is "facebook", it is obvious to recognize them as same principal by manual inspection while there is no straightforward way to automatically give the same result.As it is difficult to strictly tell whether two principals are the same, we perform some relaxation on this problem. Note that in rare cases where search engine returns no results, we use literal edit distance between Web principal and app principal to calculate the similarity.1. Firstly, we remove noise words in < AP mp ,W P mp > such as suffixes [5] and stop words [6] (e.g. remove "com" and "get" from "get.appdog.com"), since they make little contribution to XPM classification. Secondly, we use AP mp and W P mp as search keywords to query Google search engine and get search results as R ap and R wp respectively. Fourthly, we calculate the similarity of the two principals as cosine similarity between the two vectors using the following equation.Sim(AP mp ,W P mp ) = n ∑ i=1 A i W i n ∑ i=1 A 2 i n ∑ i=1 W 2 i(3)5. If the similarity does not exceed the threshold, we regard the Web principal and app principal are from different parties and classify the manipulation point (mp) as XPM. As a result, the static analyzer module successfully recall 91.7% of all manipulation points with correctly labeled manipulating information. Therefore, the precision and recall of Principal Identifier and XPMClassifier are 98.9% and 97.9% respectively.We further manually inspect the false positives and false negatives. Fig- ure 6(a) shows the standard and secure OAuth 2.0 implicit grant flow, where an external user-agent is used and third-party app can only access data in step 1 and step 7. For example, we find a library called "com.magzter" that uses onPageFinished API to intercept access token when doing OAuth on Twitter.According to previous research on OAuth security [41,16,43] and RFC OAuth 2.0 specification [4], it is unsafe to use internal user-agent. apps impersonate another relying party in OAuth by providing the client ID of the victim in step 1 (see Figure 6(b)) and intercepting access token of the victim in step 5. The Instaview app described above also steals user credentials in step 2 of Figure 6(b) using similar methods.A3: Stealing and Abusing Cookies. Our empirical study shows that the Web resource manipulation capability of WebView brings huge risks to service providers. In theory, WIREFRAME is quite useful in preventing the abuse of Web resource manipualation APIs found in our case studies. For example, they can hide the invocations of Web resource manipulation APIs using Java reflection, or obfuscate the identifiers for recognizing Web principals and app principals. Several works point out that malicious JavaScript code from unauthorized Web origin can get sensitive data from the host apps through several ways, including abusing the JavaScript bridge (exported Java functions using addJavascriptInterface API) [32,17,36,23], accessing file system [17,23,45], abusing HTML5 geolocation API [23] or postMessage API [24]. Luo et al. [32] show that malicious apps can attack Web pages by injecting JavaScript code or sniffing and hijacking Web navigation events. When using WebView as the user-agent in OAuth, Shehab et al. [43] show that user credentials and authorization interface may be attacked, while Chen et al. [16] point out that access token sent in redirection URI may be leaked by the host app. This work was supported in part by the National Natural Science Foundation of China (U1636204, 61602123, 61602121, U1736208) and the National Program on Key Basic Research (NO. 2015CB358800). The IU author is supported in part by the NSF 1408874, 1527141, 1618493 and ARO W911NF1610127.