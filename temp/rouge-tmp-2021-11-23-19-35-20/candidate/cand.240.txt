In this paper, we formally study the problem of inconsistencies in framing control policies across different browsers and we implement an automated policy analyzer based on our theory, which we use to assess the state of click-jacking protection on the Web. In this paper, we are concerned about inconsistencies in framing control, a cornerstone of Web application security, which pioneered the adoption of client-side security mechanisms.Framing control constrains the inclusion of Web content inside iframes (sub-documents) opened by malicious pages and it is particularly useful to prevent click-jacking attacks [7]. These scripts, placed in pages for which framing should be forbidden, merely checked conditions like self == top to assess whether they were loaded in the top-most frame. Unfortunately, since XFO was not standardized a priori, different browser vendors provided different implementations, leading to differing support of its directives and attacks like double framing in some browsers [20]. In 2014, the second iteration of the CSP specification introduced the frame-ancestors directive to control framing, with the goal of obsoleting XFO and to offer a comprehensive, uniform protection mechanism for all CSP-compliant browsers.The way in which the Web platform evolved hints at the fact that the state of click-jacking protection on the Web is brittle. This feature, which is one of the core pillars of the Web's success, can, however, be abused by attackers to their advantage. Then, the attacker adds an iframe pointing to a page with a Like button (e.g., from Facebook) at the same coordinates, and use CSS to make the iframe fully transparent. Starting from 2009, browser vendors picked up on the increasing danger of click-jacking and similar attacks, and Internet Explorer was the first browser to implement the so-called X-Frame-Options (XFO) header [9]. According to the specification, the check can be based "on the origin of the framed page and the top-level browsing context", on "the framed page and the framing page", or on "the whole chain of nested frames in between". When the XFO specification was originally written, the first practice was the most common, yet such implementation is potentially insecure because it opens the way to double framing attacks, where the attacker relies on multiple nested frames to circumvent existing defense mechanisms [20]. Hence, we can define the semantics of every framing control policy on top of the CoreCSP framework, which provides a simple denotational semantics for the content restriction fragment of CSP [4]. To understand how the CoreCSP denotational semantics is defined, assume that http://www.foo.com deploys the following CSP:frame-ancestors *.foo.com https://* Since the protected page is served over HTTP, the semantics of the policy is formalized by the directive value {(http, * . More generally, since the same policy might be enforced differently by different browsers and the same Web page may also send different policies to different user agents, we let w b stand for the directive value representing the framing restrictions enforced on the page w by the browser b. The policy of the Web page w is consistent for the set of browsers B if and only if, for all b 1 , b 2 ∈ B, we have w b 1 w b 2 and w b 2 w b 1 . Note that since the XFO policy is less permissive than the CSP policy, this might lead to compatibility issues in legacy browsers, e.g., if framing is required from https://mail.example.com, yet users of such browsers are protected against click-jacking. The last class of policies we consider still arises from the expressiveness gap between XFO and CSP yet makes the opposite choice of security-oriented policies: while it is still true that legacy browsers all give the same semantics to the policy, as well as modern browsers, the policy interpretation given by legacy browsers might be more liberal than one of the modern browsers. The policy of the Web page w is compatibility-oriented for the set of browsers B if and only if it is possible to partition B in two sets B l , B m such that all these properties hold true:• B l only includes legacy browsers and B m only includes modern browsers;• the policy of w is consistent for both B l and B m ;• for all b 1 ∈ B l and b 2 ∈ B m we have w b 2 w b 1 . Instead, the original policy of Example 1 is not even compatibilityoriented, since two modern browsers like Chrome and Edge give different interpretations to the policy, due to Chrome's lack of support for ALLOW-FROM. Inconsistent policies which are neither security-oriented nor compatibility-oriented are generally hard to justify as correct because they fall in one of the following cases:• two legacy browsers interpret the policy differently;• two modern browsers interpret the policy differently;• none of the above is true, yet legacy browsers and modern browsers give two incomparable interpretations of the same policy.We refer to such policies as unduly inconsistent. This means that every Web page which adopts the ALLOW-FROM directive, but does not deploy a corresponding CSP, implements inconsistent protection against click-jacking and leaves (at least) 7 browsers unprotected.We also tested what happens when the ALLOW-FROM directive is not followed by a valid serialized origin (e.g., https://example.com), as mandated by the XFO specification. This behavior has a particularly subtle implication on the interpretation of policies like:X-Frame-Options: ALLOW-FROM <orig1>, <orig2>Firefox parses this policy as two separate headers, one allowing framing from the first origin and the other one containing an incorrect value, which does not enforce any framing restriction: as a result, framing is only allowed from the first origin. However, there are still 3 browsers that are susceptible to double framing attacks: Edge, Internet Explorer, and UC Browser.In the rest of the paper, we do not consider inconsistencies arising from double framing, because otherwise even trivial XFO policies like SAMEORIGIN would be considered inconsistent and bias our study. Out of the 10 tested browsers, Firefox 69 is the only one that faithfully implements the specifications we checked, while Opera Mini offers little to no protection against click-jacking, because it does not implement CSP, it does not support ALLOW-FROM, and even basic XFO directives like SAMEORIGIN and DENY can be incorrectly enforced due to other quirks in the treatment of HTTP headers. Finally, we performed a de-duplication of the collected framing control policies by removing all the duplicate combinations of XFO and CSP policies collected within the same origin, to avoid biasing the dataset construction towards origins with hundreds of pages all using the same policy.At the end of the data collection process, we visited 989,875 URLs overall. Number Table 5: Defenses used in the inconsistent policies Table 5 provides the breakdown: the relative majority of the inconsistencies (45%) occur when XFO and CSP are used together, which suggests that having two different mechanisms for the same purpose is potentially dangerous. Moreover, note that 805 out of the 1,484 pages (54%) which make use of both XFO and CSP together implement inconsistent protection against click-jacking, i.e., it is more likely to get the combination of the two defenses wrong than right.Another interesting insight from our analysis is that 84% of the inconsistent policies make use of CSP. The other policies all take advantage of the additional expressive power of CSP over XFO for fine-grained whitelisting: specifically, we observed 99 cases (17%) where CSP was used to whitelist all the subdomains of the host whitelisted via XFO, while in all other cases CSP whitelisted at least two source expressions.To the best of our knowledge, these look like legitimate use cases, where policy inconsistency is not necessarily dangerous for security. In particular, we observe the following distribution of (possibly overlapping) classes:• 315 policies are interpreted differently by at least two legacy browsers (76%);• 289 policies are interpreted differently by at least two modern browsers (69%);• 29 policies are given the same interpretation by all legacy browsers and all modern browsers, yet these two interpretations are incomparable (7%). For example, the Web site https://es.sprint.com sets an XFO header to ALLOW-FROM https://www.sprint.com, but does not ship a companion CSP: this leaves browsers without support for ALLOW-FROM unprotected. Luckily, our experiments also show that users of modern browsers enjoy a significantly higher level of protection than users of legacy browsers since only 16% of the inconsistencies actually void any form of security enforcement in a modern browser, where undue inconsistencies are essentially the only threat. 7 Moreover, Microsoft announced that Edge will move to the Chromium architecture in 2020, which likely means that it will drop support for ALLOW-FROM and fix the problems with XFO headers. Unfortunately, we also showed that 322 out of 465 policies that use ALLOW-FROM do not come with any CSP (69%), which implies that these changes are weakening the state of click-jacking protection on the Web.At the end of the day, we believe that the problem of inconsistencies in click-jacking protection is far from solved. In our opinion, the widespread adoption of framing control policies (33% of all crawled URLs, spread across 58% of the sites we looked at) motivates that click-jacking is perceived as an important security threat. Our analysis acts as a cautionary tale aimed at raising awareness of the potential issues that arise from policy inconsistencies.In addition to this, we also remark that our study specifically focuses on the 10,000 most popular sites at the time of writing the paper. Worse, the combination of the two mechanisms proved hard to get right for Web developers, as 54% of such policies are inconsistent.The other crucial recommendations are about the use of XFO. When visiting a page that sends an XFO header containing such a directive, Firefox merely notes an invalid header and points the developer to the generic Mozilla Developer Network page on XFO. At the very least, a candidate value for frame-ancestors combined with a clear warning about the unprotected state of the site should be reported in the JavaScript console.On more general terms, we think that our paper shows the importance of implementing only client-side security mechanisms that come with a clear and precise specification. As Web developers might not be aware of the intricacies of the two mechanisms available to control the framing of their sites, we developed a server-side proxy designed to enforce consistency in framing control policies, i.e., to ensure all browsers enforce the same level of protection. This is straightforward, since CSP is more expressive than XFO, and does not conflict with other CSP headers possibly present in r, since, when multiple CSP headers are sent, their conjunction is enforced and no other frame-ancestors directive is present.If r contains CSP headers with a frame-ancestors directive, the proxy instead behaves as follows:1. the proxy computes the union of the source expressions whitelisted in all the frame-ancestors directives contained in the CSP headers of r;3. Otherwise, the proxy checks if the Referer header of r contains a URL whitelisted by any of the source expressions identified at step 2: if this is the case, r is extended with an XFO header containing an ALLOW-FROM directive set to the origin of the Referer header; otherwise, the XFO header is set to DENY. In this section, we present related work, and for the work closest to ours, we explain the main differences.CSP and XFO for Framing Control In their 2019 paper, Luo et al. [14] studied the evolution of mobile browsers and their support for client-side security mechanisms over time. They also evaluated the dangers coming from the inconsistent support for ALLOW-FROM and CSP in different browsers, most notably by leveraging the well-known observation that the ALLOW-FROM directive is not supported in Chrome.Though both these studies have been inspiring starting points for our work, we extend the mere analysis of the potential problems by building a comprehensive framework to reason about inconsistencies. Our analysis of 10,000 Web sites from the Tranco list showed that the problem of inconsistencies is widespread on the Web, since around 10% of the (distinct) framing control policies in the wild are inconsistent and most often do not provide any form of protection to at least one browser. Given the insights of the dangers caused through inconsistencies, we proposed different countermeasures in terms of recommendations for Web developers and browser vendors, as well as the implementation of a server-side proxy designed to retrofit security to existing Web applications.