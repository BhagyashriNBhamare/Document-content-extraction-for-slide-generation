Our approach has been adopted by the Coccinelle team and is currently being integrated into the Linux kernel patch vetting. The wide use of multi-core hardware is making concurrent programs increasingly pervasive, especially in operating systems, real-time systems and computing intensive systems. It occurs when two threads are accessing one shared memory location, at least one of the two accesses is a write, and the relative ordering of the two accesses is not enforced by any synchronization primitives [30,15]. A double-fetch bug occurs when the kernel reads and uses the same value that resides in the user space twice (expecting it to be identical both times), while a concurrently running user thread can modify the value in the time window between the two kernel reads. In particular, it cannot be applied to code that needs corresponding hardware to be executed, so device drivers cannot be analyzed without access to the device or a simulation of it. Thus, auditing kernels, in particular drivers, for doublefetch vulnerabilities has become urgent.Device drivers are critical kernel-level programs that bridge hardware and software by providing interfaces between the operating system and the devices attached to the system. Furthermore, Ryzhyk et al. [29] found that 19% of the bugs in drivers were concurrency bugs, and most of them were data races or deadlocks.Because drivers are such a critical point of failure in kernels, they must be analyzed for security vulnerabilities even when their corresponding hardware is not available. Based on our study, we propose five solutions to anticipate double-fetch bugs and we implemented one of the strategies in a tool that automatically patches double-fetch bugs.The rest of the paper is organized as follows: Section 2 presents relevant background on memory access in Linux, specifically in Linux drivers, and on how doublefetch bugs occur. We provide readers with a reminder of how data is exchanged between the Linux kernel and its drivers and the user space, and of how race conditions and double-fetch bugs can occur within this framework. In Windows, we can use the device input and output control (IOCTL) method, or a shared memory object method to exchange data between kernel and user space 2 which is very similar to shared memory regions. Device drivers are kernel components responsible for enabling the kernel to communicate with and make use of hardware devices connected to the system. However, only the first fetch (line 152) of ucmlen is checked (lines 156-161) before use, whereas after the second fetch (line 185) there are no checks be- Plenty of approaches have been proposed for data race detection at memory access level. Unfortunately, none of the existing data race detection approaches (whether static or dynamic) can be applied to double-fetch bug detection directly, for the following reasons:(1) A double-fetch bug is caused by a race condition between kernel and user space, which is different from a common data race because the race condition is separated by the kernel and user space. In Linux, fetching data from user space to kernel space relies on the specific parameters passed to transfer functions (e.g., copy_from_user() and get_user()) rather than dereferencing the user pointer directly, which means the regular data race detection approaches based on pointer dereference are not applicable anymore. As shown in Figure 3, a double-fetch bug in Linux requires a first fetch that copies the data, usually followed by a first check or use of the copied data, then a second fetch that copies the same data again, and a second use of the same data. Coccinelle was initially targeted for collateral evolution in Linux drivers, but now is widely used for finding and fixing bugs in systems code.Coccinelle's strategy for traversing control-flow graphs is based on temporal logic CTL (Computational Tree Logic) [3], and the pattern matching implemented on Coccinelle is path-sensitive, which achieves better code coverage. In the second phase, based on the knowledge gained from the manual analysis, we developed a more precise analysis using the Coccinelle engine to systematically detect double-fetch bugs and vulnerabilities throughout the kernel, which we also used to additionally analyze FreeBSD and Android. As shown in Figure 4, we implemented the basic pattern matching in the Coccinelle engine.Our approach examines all source code files of the Linux kernel and checks whether a kernel function contains two or more invocations of transfer functions that fetch data from the same user pointer. From the 39,906 Linux source files, 17,532 files belong to drivers (44%), and 10,398 files belong to non-x86 hardware architec-tures (26%) which cannot be analyzed with Jurczyk and Coldwind's x86-based technique. We manually analyzed the matched kernel functions to infer knowledge on the characteristics of double fetches, i.e., how the user data is transferred to and used in the kernel, which helped us to carry out a categorization of double-fetch situations, as we discuss in Section 3.2. If, for example, the size information is used to control buffer access, the double-fetch bug turns into a vulnerability.The double-fetch situations where a message header is copied twice could easily be avoided by only copying the message body in the second fetch and then joining the header with the body. We have observed that it is very common in the Linux kernel that one single function in a driver is designed to handle multiple types of messages by using a switch statement structure, in which each particular message type is fetched and then processed. The message header is copied to the kernel first to get the message size (first fetch), check it for validity, and Figure 6: A Double-Fetch Situation Belonging to the Type Selection Category in cxgb3 main.c allocate a local buffer of the necessary size, then a second fetch follows to copy the whole message, which also includes the header, into the allocated buffer. However, if the size is retrieved from the header of the second fetch and used, the kernel becomes vulnerable as a malicious user could have changed the size element of the header.One such double-fetch bug (CVE-2016-6480) was found in file commctrl.c in the Adaptec RAID controller driver of the Linux 4.5. The function also uses the size element of the header a second time in line 130, causing a double-fetch vulnerability as a malicious user could have changed the Size field of the header between the two fetches.We observed 30 occurrences of such size checking double-fetch situations, 22 of which occur in drivers, and four of them (all in drivers) are vulnerable. In order to copy the data, it first fetches the header of the data structure into the newly created kernel space pointed to by sccb (line 68) to get the data length in sccb->length which is checked for validity in line 72. While the first phase of our study was to identify and categorize scenarios in which double fetches occur, the second phase exploited the gained knowledge from the first phase to design an improved analysis targeted at specifically identifying double-fetch bugs and vulnerabilities.As shown in Figure 9, in addition to the basic doublefetch pattern matching rule (Rule 0), which is triggered when two reads fetch data from the same source location, we added the following five additional rules to improve precision as well as discover corner cases. In some cases, the user pointer is assigned to another pointer, because the original pointer might be changed (e.g., processing long messages section by section within a loop), while using two pointers is more convenient, one for checking the data, and the other for using the data. For instance, in the size checking scenario, a user pointer is first used to fetch the message length by get_user(len, ptr->len), then to copy the whole message in the second fetch by copy_from_user(msg, ptr, len), which means the two fetches are not using exactly the same pointer as the transfer function arguments, but they cover the same value semantically. 57 out of 90 (63%) of the candidates were driver related and 22 out of 30 (73%) of the size checking cases, 9 out of 11 (82%) of the type selection cases and 19 out of 31 (61%) of the shallow copy cases occur in drivers.2. In Table 2, the size checking cases of the Linux kernel also includes one case that occurred in a shallow copy scenario.3 From GitHub as of July 2016 (https://github.com/freebsd/freebsd) In this section, we discuss the discovered double-fetch bugs and vulnerabilities in Linux 4.5 and how doublefetch bugs can be prevented in the presence of doublefetch situations. Five of them are previously unknown bugs that have not been reported before (CVE-2016-5728, -6130, - 6136, -6156, -6480), and the sixth one (CVE-2015(CVE- -1420) is a double-fetch bug present in the newest Android (version 6.0.1) which is based on an older Linux kernel (version 3.18) containing the bug, which has been fixed in the mainline Linux kernel since Linux 4.1. However, even though the cases we call benign double-fetch situations are not currently faulty, they could easily turn into a double-fetch bug or vulnerability when the code is updated without paying special attention to the doublefetch situation. A double-fetch situation turns into a bug when there is a use of the "same" data from both fetch operations because a (malicious) user can change the data between the two fetches. Four out of the five new bugs belong to size checking scenarios, indicating that variable length message processing needs vetting for double-fetch bugs.In the Linux kernel, double-fetch bugs are more complex than in Windows because transfer functions separate the fetches from the uses in a double-fetch bug, making it harder to separate benign from vulnerable double fetches. A previous dynamic approach has not found any double-fetch bug in Linux, where our static approach found some, demonstrating the power of a simple static analysis.Our approach requires manual inspection, however, the manual inspection does not have to be repeated for the full kernel as future analyses can be limited to changed files. Therefore, the manual analysis part of our approach is inevitable but highly beneficial.As for prevention, all of the four size checking bugs are patched by the Compare Data method, indicating the double fetches are not avoided completely as the patched situations still abort the client program by returning an error. Wilhelm [37] recently found such a compiler-generated double-fetch bug in the Xen Hypervisor, which is because the pointers to shared memory regions are not labeled as volatile, allowing the compiler to turn a single memory access into multiple accesses at the binary level, since it assumes that the memory will not be changed. One of the discovered vulnerabilities does not exist in the source code but is introduced through compiler optimization (see the discussion in Section 5.5). Moreover, another discovered vulnerability in the source code is usually not exploitable because the compiler optimizes the code in a way that the second fetch is replaced with a reuse of the value of the first fetch.Double-fetch race conditions are very similar to TimeOf-Check to Time-Of-Use (TOCTOU) race conditions caused by changes occurring between checking a condition and the use of the check's result (by which the condition no longer holds). One solution is used to automatically patch double-fetch bugs, which is able to automatically patch all discovered bugs occurring in the size-checking scenario.Where a known dynamic analysis of the Linux, FreeBSD, and OpenBSD kernels found no double-fetch bug, our static analysis discovered six real double-fetch bugs, five of which are previously unknown bugs, and three of which are exploitable double-fetch vulnerabilities. This work is partially supported by the The National Key Research and Development Program of China (2016YFB0200401), by the program for New Century Excellent Talents in University, by the National Science Foundation (NSF) China 61402492, 61402486, 61379146, 61472437,and by the laboratory pre-research fund (9140C810106150C81001).