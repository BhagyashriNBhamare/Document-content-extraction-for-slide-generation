To do so with high fidelity, we develop novel techniques to determine the physical address mapping in DRAM modules at runtime (to improve the effectiveness of double-sided row hammer attacks), methods to exhaustively hammer a large fraction of physical memory from a guest VM (to collect exploitable vulnerable bits), and innovative approaches to break Xen paravirtualized memory isolation (to access arbitrary physical memory of the shared machine). For instance, operating system security relies on the assumption that data and code stored in the memory subsystems cannot be altered without mediation by the software running with system privileges (e.g., OS kernels, hypervisors, etc.). However, the recently demonstrated row hammer attacks [23], which are capable of inducing hardware memory errors without accessing the target memory regions, invalidate this assumption, raising broad security concerns.Row hammer attacks exploit a vulnerability in the design of dynamic random-access memory (DRAM). Moreover, the same memory controller may map physical addresses to DRAMs in different ways, depending on how DRAM modules are configured.To address this issue, we developed a novel algorithm to determine the memory mapping at runtime (Section 3). Then, in order to guarantee that sufficient exploitable bit flips (i.e., located at specific memory locations and can be repeatedly induced in row hammer attacks) are found, we conduct exhaustive row hammer attacks from a guest VM to test all DRAM rows that are accessible to the VM. Unlike prior work, which sprays large numbers of page tables and conducts random row hammer attacks hoping that bit flips will occur in a page table entry (PTE) [4], in our approach (Section 5), we use hypercalls to map page directories in the OS kernel of our own VM to physical pages containing memory cells that are vulnerable to row hammer attacks. We emphasize that with the attack techniques we propose in this paper, the attacker's capability is only limited by imagination.We note our attacks primarily target Xen paravirtualized VMs, which, although are gradually superseded by hardware-assisted virtualization, are still widely used as cloud substrates in public cloud like Amazon EC2. We will then describe a novel graph-based algorithm for detecting physical address mapping in DRAMs (Section 3). Modern memory systems are generally organized in multiple memory channels, each handled by its own dedicated memory controller. DRAM chips are large arrays of memory cells with additional support logic for data access (read/write) and refresh circuitry used to maintain data integrity. Unlike our work, brute-force approaches were taken to (1) collect sets of memory addresses that are mapped to the same banks by randomly selecting addresses from a large memory pool and conducting the timing-based tests to cluster them, and (2) to determine the XOR-schemes (see Section 3) that are used by memory controllers, by testing all possible combinations of XOR-schemes against all sets of addresses.The advantage of their approach over ours is that it exhaustively searches XOR-schemes without the need to reason about the complex logic behind them, as is done in our paper. Independent of Intel's effort, Kim et al. [23] also reported that random bit flips can be observed by specially crafted memory access patterns induced by software programs.The first practical row hammer exploit was published by Seaborn from Google [4], who demonstrated privilege escalation attacks exploiting row hammer vulnerabilities to break the sandbox of Google's NaCl, and to obtain kernel memory accesses from userspace programs running on Linux operating systems. The study was quickly followed up by others [10,16,20], who demonstrated row hammer attacks using Javascript code, which meant that the attacks could be conducted without special privileges to execute binary code on target machines. This paper follows the same line of research, but our focus is serverside row hammer attacks, although some of the proposed techniques will also be useful in other contexts.It has been claimed that server-grade processors and DRAM modules are less vulnerable to row hammer attacks [23], especially when the server is equipped with ECC-enabled DRAM modules. The most commonly used ECC memory modules implement single errorcorrection, double error-detection mechanisms, which can correct only one single-bit of errors within a 64-bit memory block, and detect (but not correct) 2-bit errors in the same 64-bit block. More precisely, we hope to determine which bits in a physical address specify its mapping to DRAM banks, rows and columns.This information, however, is not available in the system configuration or in the memory controller or DRAM datasheets. Intel never discloses the mapping algorithm in their memory controllers; moreover, the same memory controller will likely map the same physical address to a different DRAM location if the number or size of DRAM chips is changed. LATENCY() randomly selects 100 pairs 1 of memory addresses from a large memory buffer, so that each pair of addresses differs only in the bit positions that are specified by the input, I: in each pair, one address has '1's at all these bit The algorithm enumerates each pair of addresses by measuring the average access latency to read each address once from memory. Specifically, we consider each bit in a physical address as a node in a graph; the edges in the graph are closely related to the results of LATENCY(): The set of bits are connected by edges, if, when used as the input to LA-TENCY(), yields high access latency. In the following discussion, we use b i to refer to an address bit position and a node interchangeably.Our bit detection algorithms works under the assumption that Intel's DRAM address mapping algorithms may use XOR-schemes to combine multiple bits in physical addresses to determine one of the bank bits. An XORscheme is a function which takes a set of bits as input and outputs the XORed value of all the input bits. As will be discussed in Section 5, only bit flips at certain positions within a 64-bit memory block can be exploited; also, only a fraction of them are repeatable in row hammer attacks (we will empirically evaluate the fraction of vulnerable bits that are both exploitable and repeatable in Section 6.2.3). To enumerate as many DRAM rows as possible to look for vulnerable bits, we developed the following data structure and algorithm to conduct double-sided row hammer attacks on every row in every bank: Especially, as will be shown later in Table 1, some of the 12 least significant address bits are bank bits, which means the same 4KB memory page are not always mapped to the same row. For example, on a Sandy Bridge processor with 2 memory channels, 1 DIMM per channel, 1 rank per DIMM, and 8 banks per rank (totally 4GB memory), there are 2 4 = 16 elements (i.e., 2 × 8 banks) in the first dimension, 2 16 = 65536 elements (i.e., number of rows per bank) in the second dimension, 2 7 = 128 elements (i.e., number of memory units per row) in the third dimension.Another observation we had for conducting efficient row hammer attacks is to avoid hammering on rows in sequential order. To be compatible with native OS kernels, a paravirtualized OS kernel (e.g., already a part of mainstream Linux kernel) maintains a contiguous pseudo-physical memory address space; the mapping between pseudo-physical memory addresses and virtual addresses are maintained at page-granularity, following the same semantic as its non-virtualized counterparts. Whenever a page table hierarchy is loaded into the CR3 register upon context switch, the hypervisor validates the memory types of the page tables to ensure the guest VM does not subvert the system by modifying the content of the page tables. We propose a novel attack that achieves this goal by replacing the entire page tables in a guest VM without issuing hypercalls, which we call the page table replacement attacks.For the convenience of discussion, we first define the following primitives:• Addr(v) returns the machine address of a vulnerable bit. • Virt(p) returns the virtual address of the beginning of a page p.• Differ(P 1 , P 2 ) returns a set of indices of bits in which the machine addresses of two memory pages P 1 and P 2 differ.Specially, when the vulnerable bit v satisfies Position(v) ∈ [12, M], where M is the highest bit of the physical addresses on the target machine, the attacker could exploit the flippable bit to replace an existing page table with a carefully-crafted page table containing entries pointing to physical pages external to the guest VM via the following steps (Figure 8): • Step 1: In the attacker's VM, allocate and map one virtual memory page (denoted p), so that the vulnerable bit v has the same page offset as one of the PFN bits in p's corresponding PDE. • Step 2: In guest kernel space, select two physical pages, P 1 and P 2 , where Differ(P 1 , P 2 ) = {Position(v)} and Position(v) of P 1 is the original state of the vulnerable bit (e.g., 0 if Direction(v) = 0 → 1). For instance, on a machine equipped with an Intel Westmere processor, Xeon E5620, and one DRAM chip (with 2 memory channels, 1 DIMM, 2 ranks, 8 banks, and 2 15 rows per bank), we ran our algorithm and found the bits that determine bank indices are b 6 ⊕ b 16 , b 13 , b 14 , b 20 , b 21 , and the bits that determine row indices are bits b 16 to b 19 , and bits b 22 to b 32 (totally 15 bits). For example, on an Intel Xeon E5-2640 v3 processor we tested on, the row bits are b 15 ∼ b 17 andb 7 ⊕ b 12 ⊕ b 14 ⊕ b 16 ⊕ b 18 ⊕ b 26 and b 8 ⊕ b 13 ⊕ b 15 ⊕ b 17 ⊕ bb 21 ∼ b 35 . Although our VM were only allocated 6.25% (in the EC2 test) and 3.125% (in the Cloudlab test) physical memory initially, after several reboots, our VM could access as much as 17.8% (in the EC2 test) and 22.3% (in the Cloudlab test) of the total memory. We first report the fraction of vulnerable bits we found on the four machines, machine A, B, C and D (configurations listed in Table 2), that are usable in the page table replacement attacks we discussed in Section 5. Particularly, we demonstrated the power of the cross-VM row hammer attacks in two examples: In the first example, we demonstrated a confidentiality attack where the adversary exploited the techniques to steal TLS private keys from an Apache web server; in the second example, we showed an integrity attack, in which the attacker altered the program code of an OpenSSH server to bypass the user authentication and logged in the server without knowledge of credentials.Arbitrary memory accesses. To do so, the adversary controlling a guest VM first runs the bit detection algorithm described in Section 3 to determine the row bits and bank bits of the machine, and then performs row hammer attacks until he finds a exploitable and repeatable bit flip at desired bit positionthe PFN range of a PDE. We assume the adversary has knowledge of the username and public key of the legitimate user, as such information is easy to obtain in practice.To initiate the attack, the adversary first attempted to log in as a legitimate user of the OpenSSH server from a remote client using public/private keys. Then the OpenSSH server awaits the client to decrypt his encrypted private key file and then use the private key to decrypt the challenge and send a response back to the server. Note here even though the memory page is read-only in the victim VM, Dom0, the adversary may have arbitrary read/write access to it without any restriction. Then password authentication would be used as a fallback authentication method, in which the adversary can log in the server with any password, because it was not really checked by the server.Again, the time to complete the OpenSSH attack depends on the number of physical pages scanned before meeting the targeted one. cloud instance types Amazon EC2 [7] t1, m1, m2, m3, c1, c3, hi1, hs1Rackspace [28] General purpose, Standard Single/Multi-tenant Virtual Server Cloudlab d430, d810, d820, C220M4, C220M4, c8220(x), r320, dl360 In this section, we discuss the existing software and hardware countermeasures against the demonstrated cross-VM row hammer attacks.Row hammer resistance with hardware-assisted virtualization. As discussed in Section 2, the most commonly implemented ECC mechanism is single error-correction, double error-detection. Particularly, if the true physical address of an extremely vulnerable rows is known to the adversary, hammering around this specific row will greatly increase the adver- In conclusion, we explored in this paper row hammer attacks in the cross-VM settings, and successfully demonstrated software attacks that exploit row hammer vulnerabilities to break memory isolation in virtualization.