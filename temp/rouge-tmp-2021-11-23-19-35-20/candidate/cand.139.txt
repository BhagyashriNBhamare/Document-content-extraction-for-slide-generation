Moreover, any bug in system call implementations might allow an unprivileged user-level process to completely compromise the system.OS fuzzers usually start with a set of synthetic seed programs, i.e., a sequence of system calls, and iteratively mutate their arguments/orderings using evolutionary guidance to maximize the achieved code coverage. Ideally, the synthetic seed programs for OS fuzzers should each contain a small number of system calls that exercise diverse functionality in the OS kernel.However, the behavior of each system call heavily depends on the shared kernel state created by the previous system calls, and any system call invoked by the seed programs without the correct kernel state will only trigger the shallow error handling code without reaching the core logic. For example, a seed program using the read system call must ensure that the input file descriptor is already in an "opened" state with read permissions using the open system call.Existing OS fuzzers [11,37] rely on thousands of hand-coded rules to capture these dependencies and use them to generate synthetic seed programs. The system call traces must be distilled while maintaining the correct dependencies between the system calls as mentioned earlier to ensure that their achieved code coverage does not go down significantly after distillation. Next, it greedily selects the calls that contribute the most new coverage and for each such call, identifies all its dependencies using lightweight static analysis and groups them into seed programs.We demonstrate that MoonShine is able to distill a trace consisting of a total of 2.8 million system calls gathered from 3,220 real programs down to just over 14,000 calls while still maintaining 86% of their original coverage over the Linux kernel. Finally, MoonShine's approach led to the discovery of 17 new vulnerabilities in Linux kernel, none of which were found by Syzkaller while using its manual rule-based seeds.In summary, we make the following contributions:â€¢ We introduce the concept of seed distillation, i.e., distilling traces from real world programs while maintaining both the system call dependencies and achieved code coverage as a means of improving OS fuzzers. A dynamic test minimization strategy similar to that of afl-tmin might take up to 256 iterations for finding the minimal distilled sequence of calls.To avoid the issues described above, we use lightweight static analysis to identify the potential dependencies between system calls and apply a greedy strategy to distill the system calls (along with their dependencies) that contribute significantly towards the coverage achieved by the undistilled trace. We define a system call c i to be explicitly dependent on another system call c j if c j produces a result that c i uses as an input argument. For example, in Figure 1, the open call in line 2 is an explicit dependency of the mmap call in line 3 because open returns a file descriptor (3) that is used by mmap as its fourth argument. This grouping of distilled calls is added to our collection of seeds S (line 16) for OS fuzzing.In Algorithm 1, we demonstrate that MoonShine constructs seeds from the calls that contribute the most new coverage and captures those calls' implicit and explicit dependencies. MoonShine iterates over all the result nodes stored in the map for the specific type and value and adds one edge from the argument node to each result node in the graph.Once the argument dependency graph is constructed, MoonShine identifies explicit dependencies for a given call by enumerating the call's list of arguments and for each argument MoonShine visits the corresponding argument node in the dependency graph. As such, a call c a is an implicit dependency of c b if the intersection of c a 's write dependencies and c b 's read dependencies is nonempty.MoonShine is able to identify the collection of read and write dependencies by performing control flow analysis on the target kernel. If MoonShine encounters an assignment expression or unary assignment expression containing a global variable, it marks that global variable as a write dependency.Note that for a given trace this approach may overestimate or underestimate the number of implicit dependencies for a given call. We present MoonShine's workflow in Figure 3. An edge from node A to node B indicates that B is a child of A. MoonShine determine this relationship by examining the return value of the clone system call. If process A calls clone and the result is B > 0 then we know A is a parent of B. Each edge also stores the position of the last call in A's trace before B was created, and this is important because some resources produced by A can be accessed by B, e.g. file descriptors or memory mappings. Each node in the dependency graph also stores the position of the call in that processes trace. In order to track this, MoonShine requires the aid of a template that identifies for a given system call, which argument has its values set by the kernel. For any pointer values that do not fall within an active mapping, such as those on the stack or produced through brk, MoonShine tracks the memory required for all such arguments and adds a large mmap call at the beginning of the distilled trace to store their values. MoonShine's implicit dependency tracker is build on Smatch [16], a static analysis framework for C. Smatch allows users to register functions which are triggered on matching events while Smatch walks the program's AST. On a match, the hook notifies MoonShine which struct and field are the read dependency along with the line and function name, which MoonShine records.MoonShine tracks write dependencies by registering a Unary Operator Hook and Assignment Hook. We constructed seeds from 3220 programs from the following sources 1) Linux Testing Project (LTP) [7] Kselftests is a testing suite contained within the Linux source tree that tests specific subsystems in the kernel. The test suite includes regression tests against previously discovered bugs, and tests which exercise components of the C Standard Library such as processing ELF files, io, and networking calls. Lastly, we use the term default Syzkaller to describe Syzkaller fuzzing without any seeds, using only it's hardcoded rules to generate input programs. For each set of seeds, we fuzz the latest kernel release candidate for 24 hours 3 times each and do the same using the default Syzkaller. We note that default Syzkaller was unable to find any vulnerabilities during these experiments but when using seeds generated by MoonShine it found 17. This shows Syzkaller's coverage improves noticeably when it starts with either of MoonShine's generated seeds; however, when seeded with programs that have been distilled with both explicit and implicit dependencies, Syzkaller achieves 13% coverage improvement compared to the 9% when using explicit dependencies alone.Breakdown By System Call. This fact that Moonshine(I+E) noticeably outperformed Syzkaller on these standard system calls suggests that Syzkaller's hard coded rules are insufficient to capture dependencies for common calls.Coverage and Bugs Found. These findings imply that the composition of seed programs is able to influence Syzkaller to focus on fuzzing particular regions of the kernel it otherwise would not, and in extension discover bugs in these regions.Result 2: MoonShine achieves 13% higher edge coverage than default Syzkaller Tracking Dependencies. This suggests that capturing dependencies is crucial to improving Syzkaller's performance and that MoonShine is able to do so effectively.Result 3: MoonShine distills 3220 traces consisting of 2.9 million calls into seeds totaling 16,442 calls that preserve 86% of trace coverage. Prior to benchmarking our components, we preloaded all seed programs on a custom Google Cloud image running linux-4.13-rc7 compiled with kcov. When using seeds whose average call length is 730, Syzkaller performed less than 100 mutations in one hour, which is prohibitively slow.We now assess the impact that MoonShine's seeds have on Syzkaller's overall performance. When Thread 1 resumes, dentry->d_name.name is different so the subsequent strcpy will overflow the struct if the size of the name has increased.After 4.5 hours of fuzzing with seeds distilled using Moonshine(I+E), Syzkaller reported a KASAN: slab out of bounds in strcpy crash in inotify_handle_event(). When using only its manual rules, Syzkaller never generated the relevant sequence of calls for this bug to trigger. Default Syzkaller was unable to detect the bug because it is unable to understand that the command F_SETPIPE_SZ is meant to take After Thread 1 computes alloc_len, Thread 2 increases the length of filename by copying a larger string to dentry->d_name.name, causing the overflow in strcpy. While the programs producing the traces used in this paper contained very few such interprocess/thread dependencies, more complex programs like databases or Web servers may have such dependencies as their processes/threads often share sockets and memory regions. Note that these false positives do not affect the coverage achieved by the distilled corpus but might make the traces slightly larger than they need to be.In our experiments, we observed that imprecise pointer analysis is a major source of false positives. MoonShine's static implicit dependency analysis can also be easily extended to other open source OS kernels such as FreeBSD.For closed-source operating systems like Microsoft Windows, MoonShine can potentially support trace distillation of by leveraging recent works [29,33] using virtualization-based approaches to capturing system call traces and kernel code coverage albeit with higher performance overhead. By contrast, MoonShine distills the seed traces while preserving both syntactic and semantic integrity and the achieved code coverage.Lastly, IMF [22] is a model-based macOS kernel fuzzer that programatically infers an API model from the call trace of real-world programs. Like Syzkaller, all of these OS fuzzers can potentially benefit from the coverage improvements offered by the MoonShine framework.Finally, the class of evolutionary fuzzers that target semantic bugs (e.g., SlowFuzz [35], NEZHA [30], Frankencerts [17], and Mucerts [41]) may also similarly benefit from domain-specific seed distillation techniques that maximize coverage or path diversity.Implicit Dependencies.