Later, when this end user logs in with a candidate password, the server cooperates with the rate-limiter again to check if the candidate password is identical to the one encrypted in the corresponding record.Due to the cooperation requirement above, PH essentially performs a double encryption of the passwords. Lastly, if either the server or the rate-limiter is compromised, or if the secret keys are in use for quite some time, the parties can jointly execute a key-rotation mechanism to refresh their secret keys. To solve this problem, we propose passwordhardened encryption (PHE) services, which is an extension of PH services that goes beyond authentication and uses the passwords to secure general data in addition to the passwords. This makes PHE an appealing approach, for example, to conform to PCI DSS which requires credit card information to be encrypted by a mechanism supporting key rotation.With per-user secret messages, each user can now enjoy the benefit of encrypting their respective data using an independent key. More importantly, if the server decides to rotate not only its own secret key but also some of the (data-)keys, the rotation is not as costly as re-encrypting the whole database.In a nutshell, PHE is a one-package data-security solution for online service providers who employ passwordbased authentication and store sensitive user data. Our contributions can be summarized as follows:• We introduce and formalize the notion of PHE in order to protect arbitrary user data while retaining the functionality and security features of the underlying PH. The definitional framework encompasses dedicated cryptographic games as well as a soundness property that is stronger than the one previously adopted in PH services, inasmuch as it puts less trust on the good behavior of the rate-limiter. • Our PHE instantiation is between 30% and 50% more efficient than previous PH (without E) constructions. Distributed password verification (DPV) protocols [6] also require the online service provider to seek help from external crypto servers for verifying user passwords. Yet, it is still vulnerable to brute-force attacks by an attacker who obtained the salts database. Let 1 λ be a λ -bit unary string of 1 which represents the security parameter. We denote the empty string by ε.A password-hardened encryption (PHE) scheme consists of the efficient algorithms and protocols (Setup, KGen S , KGen R , Encrypt, Decrypt, Rotate, Update), which we define as follows:Setup and Key Generation. When an end user registers for an account with password pw ∈ P and a secret message M ∈ M (e.g., an AES key, which can also be chosen by the server on behalf of the end user), the server engages in the (labeled) encryption protocol with the rate-limiter R to compute a record T with label :(( , T ), ε) ← Encrypt S(sk S , pw, M), R(sk R ). When an end user logs in to the service provided by the server with a candidate password pw ∈ P, the server retrieves the corresponding encryption record T and label for the user, and engages in the (labeled) decryption protocol with the rate-limiter:(( f , M), ε) ← Decrypt S(sk S , pw, T ), R(sk R ). The server S and the rate-limiter R may decide to rotate their keys and update the records, which can be due to a regular routine or a compromise on either side. In each round, the attacker can compromise either the rate-limiter or the server and use whatever he learned in the next roundHid b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk R , sk R ) ←$ KGen R (pp) 2 : O := {P·, R(sk R , . . .) :3 : P ∈ {Encrypt ε , Decrypt , Rotate : ∈ {0, 1} * }} 4 : / / All rate-limiter outputs are given to adversary, 5 : / / except for sk R from Rotate·, R(skR).6 : / / Rotate·, R(skR updates skR embedded in all oracles to sk R . Practically this implies using a TLS connection between rate-limiter and server, and updating long-term keys and certificates during key-rotation.7 : (sk * S , χ, M * 0 , M * 1 , st) ←$ A O 1 (pp, pk R ) 8 : pw * ←$ χ 9 : (( * , T * ), ε) ←$ Encrypt ε S(sk * S , pw * , M * b ), R(sk R ) 10 : b ←$ A O 2 (st, * , T * ) 11 : return bWe formalize the security properties of PHE, extending those from password-hardening [16]. Eventually, A 1 outputs a server secret key sk * S , a password distribution χ, two messages M * 0 and M * 1 , and a state st. The challenger picks a random password pw * from the distribution χ, and encapsulates M * b into a record T * with label * honestly using sk * S and pw * by locally emulating the encryption protocol. Definition 2 (Partial Obliviousness) A PHE scheme PHE is partially oblivious if, for any three-stage PPT adversary A = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ ) such thatPr Obl 0 PHE,A (1 λ ) = 1 − Pr Obl 1 PHE,A (1 λ ) = 1 ≤ negl (λ ) ,where each probability is taken over the random coins of the experiment.Soundness (Figure 4 and Figure 5). Definition 3 ((Strong) Soundness) A PHE scheme PHE is sound if, for any PPT adversary A = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ ) such that SoundnessPHE,A (1 λ ) = 1 ≤ negl (λ ) . This definition seems not to be equivalent to the single-record variant, as an adversary against the single-record variant cannot simulate a challenger of the multi-record variant without knowing the update token chosen by the challenger of the single-record variant.Definition 4 (Forward Security) A PHE scheme PHE is forward secure if for any two-stage PPT adversary A = (A 1 , A 2 ) there exists a negligible function negl (λ ) withPr FwdSec 0 PHE,A (1 λ ) = 1 − Pr FwdSec 1 PHE,A (1 λ ) = 1 ≤ negl (λ ) ,where each probability is taken over the random coins of the experiments. Below, we discuss why these approachesFwdSec b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk S , sk R , {( i , pw i , T i )} n i=1 , st) ←$ A 1 (pp) 3 : / / for some n = poly (λ ) 4 : ∀i ∈ [n], (( f i , M i ), ε) ← Decrypt i S(sk S , pw i , T i ), R(sk R ) 5 : if b = 0 then 6 : ((pk S , sk S , τ), (pk R , sk R )) ←$ RotateS(sk S ), R(sk R ) 7 : ∀i ∈ [n], T i ←$ Update i (τ, T i ) 8 : else 9 : (pk S , sk S ) ←$ KGen S (pp), (pk R , sk R ) ←$ KGen R (pp) 10 : ∀i ∈ [n], (( i , T i ), ε) ←$ Encrypt i S(sk S , pw i , M i ), R(sk R ) 11 :/ / By the assumed convention,i = i ∀i ∈ [n]12 : endif 13 : b ←$ A 2 (st, sk S , sk R , T 1 , . . . , T n ) 14 : return ((∀i ∈ [n], f i = 1) ∧ b ) At first glance, a PHE scheme might be built on top of a PH scheme, by additionally encrypting the message in the enrollment protocol, in such a way that it can be decrypted if and only if a valid candidate password is provided. The server additionally requests the ratelimiter to decrypt a possibly blinded / rerandomized version of the ciphertext.One can immediately notice that the above construction suffers from a mix-and-match attack: The server can request decryption of arbitrary combinations of enrollment records and ciphertexts in the decryption phase. The problem with this approach is that, after key-rotation (from k to rk where r is a random field element), the corresponding ciphertext becomes C = C r = e(H 1 (un), H 2 (pw)) rk · M r , which encrypts M r instead of M.Another idea is to use the output of a PO-PRF as the secret key of a key-homomorphic encryption (KHE) scheme. Assuming the decryption algorithm of the KHE scheme only uses generic group operations, it seems rather difficult to "protect" the secret key, i.e., one may infer the secret key from the ciphertext and its corresponding decryption result by "undoing" the generic group operations involved in decryption. We believe that the use of PKE in PHOENIX is inherited from the scheme [20] the authors were trying to fix.In the following, we construct an extremely simple PHE scheme by taking the core idea of PHOENIX, stripping off the PKE operations, and adding a (symmetrickey) encryption mechanism for messages. Let the password space and message space to be P := {0, 1} * and M := G respectively. Next, the parties jointly create the ciphertext(H x R,0 H y S,0 , H x R,1 H y S,1 M y ) 6, where H S,b = H S (pw, n S , b) and H R,b = H R (n R , b) for b ∈ {0, 1} 7 . Recall that the record T is in the form(T 0 , T 1 ) = (H x R,0 H y S,0 , H x R,1 H y S,1 M y ). The latter then verifies the proof, recovers M as (T 1 H −x R,1 H −y S,1 ) 1/y , and outputs the flag f = 1 and the message M. Otherwise, the rate-limiter proves that C 0 and H x R,0 are not equal. When either one of the server and the rate-limiter is compromised, or due to a regular routine, they may engage in a key rotation protocol to rotate their (public and) secret keys such 6 The purpose of encrypting M y instead of M is to "absorb" the effect of key-rotation to y, so that M does not change after key-rotation. Note that the update is done without knowing the passwords and messages corresponding to the records.In the key rotation protocol, the rate-limiter generates a tuple of random integers (α, β ) and sends it to the server 8 . To update each encryption record T without knowing the encrypted message and the corresponding password, the server runs the update algorithm on each record T with its label = (n R , n S ). Full proofs are postponed to Appendix A.Theorem 1 (Partial Obliviousness) Assume that DDH is hard in G. Then, in the random oracle model, our construction achieves partial obliviousness.Proof 1 (Proof sketch) The proof is based on the observation that the adversary can only obtain (pseudorandom) hashes of(pw * b , M * b ) but not (pw * 1−b , M * 1−b ), since (essentially) the only way to obtain the latter is by querying the decryption oracle on (, pw) where = ( * S , ·) and pw = pw * 1−b , which is refused by the oracle.Theorem 2 (Message Hiding) If Π is zero-knowledge and DDH is hard in G, then our construction achieves message hiding in the random oracle model. We can thus use such an adversary as a black-box to break the soundness of Π.Theorem 4 (Forward security) Our construction is perfectly forward secure.Proof 4 (Proof sketch) The truth of the claim follows from the fact that, for any tuples (x, y) and (x , y ) in Z 2 q , there exists a unique mapping (x , y ) = (αx + β , αy) defined by (α, β ) in Z 2 q which maps (x, y) to (x , y ). This expectation is indeed confirmed by the evaluation Figure 12, in which the server is utilizing the same set of machines as were used for the rate-limiter-side evaluation. To convert the system in a single batch conversion step, assuming the existing system stores passwords in the form of salted hashes (n S , H(n S , pw)), the server samples a random message M, further hashes each record to compute (n S , H y S,0 H y S,1 ) = (n S , H(H(n S , pw), 0) y , H(H(n S , pw), 1) y M y ) (modeling H as a random oracle and interpreting its output as a group element), and communicate with the rate-limiter to complete the PHE record.Either way, the random message M is used as a symmetric key (e.g., for AES) to encrypt the existing (plaintext) profile of the end user, and is discarded after encryption. Otherwise, it outputs a simulated proof of the statement that C 0 and C 0 = H R (n R , 0) x are not equal.Recall that the challenge record is computed asT * 0 T * 1 = H R (n * R , 0) x H S (pw * , n * S , 0) y H R (n * R , 1) x H S (pw * , n * S , 1) y (M * b ) ywhere H R (n * R , 0) x and H R (n * R , 1) x are all uniformly random values in the view of A. Thus, in the experiment Exp b,3 , the only information of (pw * , M * b ) available to A, apart from the challenge record, is obtained via interacting with the decryption oracle, which always rejects unless A guesses the uniformly random value H R (n * R , 0) x correctly, which equivalently means guessing the value H S (pw * , n * S , 0) correctly. If Π is sound and has the proof of knowledge property, then PHE is strongly sound.To prove such claim, we observe that if there exists an adversary A which causes either of the soundness experiments to output 1, then the challenger can extract two proofs for two contracting statements respectively, which breaks the soundness of Π. It means that the challenger receives a proof for the statement "∃(α, β ) s.t. (C 1 , I) = (C α 0 H β R,0 , X α G β )", which equivalently means "∃x s.t. C 0 = H x R,0 ∧ X = G x )". This means that the challenger has a proof of "∃x s.t. (C 1 , X) = (H x R,1 , G x )" for some C 1 = C 1 , another contradicting statement.For the second case, since pw = pw , the challenger sends C 0 which is not equal to C 0 except with negligible probability to A in the decryption protocol. For the first case, since (, pw) = ( , pw ) the same message C 0 is sent from the challenger to A in the decryption protocols. However, if H S is invoked by the challenger when executing the encryption protocol on the password pw and the message M (and the empty label ε), it samples n S ←$ {0, 1} λ and programs H S such that H S (pw, n S , 0) = G a 0 and H S (pw, n S , 1)M = G a 1 for random integers a 0 , a 1 ←$ Z q , assuming H S has not been programmed on (pw, n S , 0) and (pw, n S , 1). In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 . In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 .