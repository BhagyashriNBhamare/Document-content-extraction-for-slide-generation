Researchers demonstrated sophisticated attack techniques, such as (just-in-time/blind) return-oriented programming and counterfeit object-oriented programming, which enable the attacker to execute arbitrary code and data-oriented attacks that are commonly used for privilege escalation. Unlike previous work, IMIX is not tailored towards a specific defense (technique) but can be leveraged as a primitive to protect the data of a wide variety of memory-corruption defenses. Prominent examples include: WâŠ•X [44,48] which prevents data from being executed, and hence, code-injection attacks; Control Flow Integrity (CFI) [1] and Code-Pointer Integrity (CPI) [38] which protect code pointers to prevent code-reuse attacks; and Data Flow Integrity (DFI) [2,10] mitigating data-only attacks by restricting data access. Hence, to pre-vent the adversary from accessing the data some form of in-process memory isolation is needed, i.e., a mechanism ensuring access only by the defense code while denying access by the potentially vulnerable application code. Instrumentation-based memory isolation inserts run-time checks before every memory access in the untrusted code in order to prevent accesses to the protected region. For instance, Intel has recently announced Control-flow Enforcement Technology [33] and Memory Protection Keys [34] (already available on other architectures, e.g. memory domains on ARM32 [4]). However, these technologies either provide hardware support limited to a specific mitigation, or cause unnecessary performance overhead. In contrast to other recently proposed hardwarebased approaches we provide an agnostic ISA extension that can be leveraged by a variety of defenses against code-reuse attacks to increase performance and security. Further, we extend the Linux kernel to support our ISA extension and the LLVM compiler infrastructure to provide primitives for allocation of protected memory, and access to the former. In contrast, during a control-flow hijacking attack, the attacker overwrites code pointers, which are later used as a target address of an indirect branch, to change control flow to execute injected code [3] or to conduct a code-reuse attack [50,52,54]. To mitigate controlflow hijacking attacks, these techniques prevent the corruption of code pointers [38], verify code pointers before they are used [1], or ensure that the values of valid code pointers are different for each execution [16]. As we argue in Section 8, IMIX is most likely to be adapted for Intel-based x86 CPUs, hence, we focus in this section on memory protection features that are implemented or will be implemented for Intel-based x86 CPUs. Nevertheless, many mitigations [6,18,38,41] leverage segmentation to implement information hiding by allocating their data TCB at a random address, and ensure that it is only accessed through segmentation. The paging permission system enables the operating system to assign memory to either itself or to the user mode.To isolate different processes from each other, the operating system ensures that each process uses its own page table. MPK introduces a new register, which contains a protection key, and enables programmers to tag memory (the tag is stored in the page table) such that it can only be accessed if the protection key register contains a specific key. Throughout our work, we use the following standard adversary model and assumptions, which are consistent with prior work in this field of research [21,38,53,54]. Arbitrary code execution is prevented by hardening the target application with techniques such as CPI [38], CFI [1], or code randomization [16]. We add our smov instruction to the instruction set, reusing the logic of regular memory access instructions, so that the smov instruction has the same operand types of regular memory-accessing mov instructions, mov instructions without a memory operand do not need to be handled. The kernel manages virtual memory using page tables that map the address of each page to the physical page frame that contains it. Userspace programs access normal memory using regular instructions, e.g., mov, while accesses to protected memory must be performed using the instruction smov 3 . The CPU already has a data structure to store information about every page, which is called a Page access regular pages, while smov can only access isolated pages. Modern MMUs are divided into three major components: logic for memory protection and segmentation, the translation lookaside buffer (TLB) which caches virtual to physical address mappings, and page-walk logic in case of a cache miss [49]. Processes can request the kernel to mark a page as an isolated page by using the existing mprotect system call, which is already used to manage the existing memory access permissions: PROT_READ, PROT_WRITE, and PROT_EXEC. The IR provides two memory accessors, specifically load and store, which represent respectively a load instruction from the memory to a temporary register, and a store instruction from a temporary register to the memory. We implemented our IR instructions to as subclasses of their regular counterparts in order to reuse the existing translation functionality from LLVM IR to machine code, called lowering in LLVM parlance.To allocate memory in the isolated pages, we implemented an LLVM function that can be called from an optimization pass, which allocates memory at page granularity using malloc and immediately sets the IMIX permission using mprotect. CPI uses a safe region in memory to guarantee integrity of code pointers and prevent code-reuse attacks.All code pointers, pointers to pointers, and so on, are moved to the safe region, so that memory corruption vulnerabilities cannot be exploited to overwrite them. CPI places the safe region at a random address and stores this address in a segment, which is selected using the segment register %gs. In order to access the safe region, CPI provides accessors that use mov instructions with a %gs segment override, which access the safe region using %gs as the base address and an offset. Since IMIX provides deterministic protection of the safe region, we do not need to prevent spilling of the safe region base address (stored in %gs), which IMIX makes CPI leakage resilient. As IMIX is a hardware extension, an attacker cannot directly bypass it, i.e., use a regular memory access instruction to access the isolated memory. Thus, the attacker relies on creating or reusing trusted code, or manipulating the data flow to pass malicious values to the trusted code, or access to the configuration interface of IMIX.Attacks on Trusted Code. The latter heavily depends on the ability of the defense developer to correctly block inputs that would allow the attacker to manipulate the data within the protected memory in a malicious way: IMIX merely provides a primitive to isolate security critical data. There are two ways for an attacker to re-configure IMIX: 1) leveraging the interface of the operating system to change memory permissions, or 2) manipulating page table entries.For the first case, we assume that the attacker is able to manipulate the arguments of a benign system call to change memory permissions (mprotect() on Linux). To evaluate the performance of our approach, we ported the original implementation of CPI by Kuznetsov et al. [38] to leverage IMIX to isolate the safe region and applied it to the SPEC CPU2006 benchmark suite. We performed our evaluation using Ubuntu 14.04 LTS with Linux Kernel version 3.19.0 on an Intel Core i7-6700 CPU in 64-bit mode running at 3.40 GHz with dynamic voltage and frequency scaling disabled, and 32 GB RAM.Baseline. Similar to IMIX, CET requires modifications to the TLB, semantic changes to the page table, and the introduction of new instructions. As expected, generalizing CET's shadow stack to support arbitrary memory accesses still allows implementation of an isolated shadow stack [18]. Yet, this reduces the available address space significantly, and allows linked libraries to access protected memory.Another way of protecting data against malicious modifications is to enforce data-flow integrity (DFI) [2,10,55]. However, the performance overhead of DFI, which e.g. is on average 7% for WIT [2], prevents it from being used to safeguard protection secrets of code-reuse mitigations, since it would further increase the mitigation's performance overhead. IMIX can be used for both protecting sensitive data (like DFI does) and enabling efficient protection of safe regions for control-flow hijacking mitigations.Retrofitting Existing Memory Protection. On the surface, re-enforcing legacy segmentation seems to be an attractive solution, however, IMIX is easier to implement from a hardware perspective: segmentation requires arithmetic operations, IMIX only one check. However, regularly switching between trusted and untrusted code is expensive because of 1) two added mprotect() system calls, and 2) the following invalidation of TLB entries for each of them [60]. Hence, to isolate memory, the hypervisor maintains two EPT mappings [16] (regular and protected memory) and trusted code invokes the vmfunc instruction instead of mprotect()). Protecting CPI's safe region with MPX using the opensource implementation by Koning et al. [37] results in a total performance overhead of 36.86% with a maximum of 203.71% for mcf, which cannot be considered practical, especially since we were not able to execute the benchmarks that show the highest overheads across all techniques. Another encryption feature, AES-NI [35], reduces overhead associated with encryption dramatically, which can be used to encrypt and decrypt safe regions as needed. Even with hardware encryption support, solutions like CCFI still induce a performance overhead of up to 52% [42], and keeping the encryption key safe requires relying on unused registers and ensuring that this key is never spilled to memory [14,37]. As a consequence, many mitigations rely on information hiding via segmentation, on expensive software-based isolation, or on retrofitting memory-isolation features that require compromises in the design of the mitigation.With IMIX we design a mitigation-agnostic in-process memory-isolation feature for data that targets the x86 architecture. We implement a fullyfledged proof of concept of IMIX that leverages Intel's Simulation and Analysis Engine to extend the x86 ISA, and we extend the Linux kernel and the LLVM compiler framework to provide interfaces to IMIX.