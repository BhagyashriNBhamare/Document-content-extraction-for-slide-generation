The prevalence of techniques like return-oriented programming (ROP) in attacking real-world systems has prompted major processor manufacturers to design hardware-based countermeasures against specific classes of run-time attacks. Such data-oriented programming (DOP) attacks [16] are difficult to defend against, and are an appealing attack technique for future run-time exploitation.Software defenses against run-time attacks can offer strong security guarantees, but their usefulness is limited by high performance overhead, or requiring significant changes to system software architecture. However, the prevalence of advanced attack techniques (e.g, ROP) in modern run-time exploitation has prompted major processor vendors to integrate security primitives into their processor designs to thwart specific attacks efficiently [17,29,31]. Practical PA-based defenses must minimize the scope of such substitution.Goals and Contributions In this work, we further the security analysis of ARMv8-A PA by categorizing pointer reuse attacks, and show that PA enables practical defenses against several classes of run-time attacks. • Design: A scheme for using pointer integrity to systematically defend against control-flow and data-oriented attacks, and run-time type safety, a scheme for guaranteeing safety for data and code pointers at run-time (Section 5). DOP may compromise the input of individual program operations and chain together a chosen sequence of operations to achieve the intended functionality.A data-oriented attack can in principle corrupt arbitrary program objects, but corrupting data pointers is often the preferred attack vector [12]. In Chen et al.'s attack against the GHTTPD web server [11], a stack buffer overflow is used to corrupt a data pointer used in input string validation in order to bypass security checks on the input under the attacker's control. PA, on the other hand, uses either QARMA [5] or a manufacturer-specific MAC, and performs the MAC comparison in hardware.64-bit ARM processors only use part of the 64-bit address space for virtual addresses (Figure 2). The keys are stored in hardware registers configured to be accessible only from a higher privilege level: e.g., the kernel maintains the keys for a user space process, generating keys for each process at process exec. The modifier value is not necessarily confidential (see Section 4) but ideally such that it 1) precisely describes the context of use in which the pointer is valid, and 2) cannot be influenced by the attacker.PA is used by instrumenting code with PAC creation and authentication instructions. The corresponding PA authentication instruction (in this case, autia) removes the PAC from the pointer if authentication is successful, i.e., if the current pointer value, key and modifier for autia yields a PAC that matches the PAC embedded in the pointer. ;  a u t h e n t i c a t e r e t ; r e t u r n Listing 1: Return address signing using PA. This effectively prevents any attack that relies on corrupting pointers, resisting even attackers with arbitrary access to program memory.The modifier value used in computing a PAC can depend on both static (e.g., a hard-coded value) and dynamic (e.g., the SP) information. In particular, an attacker may attempt to brute-force either the PA keys themselves, or individual PAC values. However, the following concerns for the security of PA-based defenses remain: 1) an attacker controlling the creation of PAC values, or 2) an attacker reusing previously authenticated pointers.Malicious PAC generation. The attacker can read authenticated pointers (including PAC values), and later reuse them to either:• rollback an authenticated pointer to a previous value, or • substitute an authenticated pointer with another using the same PA modifier.For instance, in GCC's return address signing scheme (Section 2.2), the return address is bound to the location of the stack frame by using the current SP value as the PA modifier. We identify the following requirements that our solution should satisfy: R1 Pointer Integrity: Detect/prevent the use of corrupted code and data pointers.R2 PA-attack resistance: Resist attempts to control PAC generation, and pointer reuse attacks.R3 Compatibility: Allow protection of existing programs without interfering with their normal operation.R4 Performance: Minimize run-time and memory overhead and gracefully scale in relation to the number of protected pointers and dereferences/calls. However, PAC values for authenticated pointers cannot be calculated before program execution, as PA keys are set only at program launch. At run-time, the PARTS runtime library, PARTSlib, processes the relocated variables and invokes the generated initializer function to ensure that any defined pointers are furnished with a PAC. Instead, PARTS uses a combination of the current stack pointer value, and a compile-time nonce (function-id) ensuring that the authenticated return address cannot be reused across invocations of different functions, while the stack pointer values effectively compartmentalizes return addresses to callers with different stack layouts. Because data pointer PAC creation and authentication is done at store/load, PARTS handles conversions by; (a) if loading the pointer from memory, validating and stripping the PAC using the type-id of the original object, and (b) on store, creating a new PAC using the destination object type-id. However, the behavior when calling a function pointer cast to a non-compatible type is undefined [18] The PARTS compiler is based on LLVM 6.0 but modifies and adds new passes to the optimizer and the AArch64 backend ( Figure 3). Our modifications consist of added optimizer and backend passes, minor modifications to the AArch64 backend, and new PARTS-specific intrinsics. The function-id is guaranteed to be unique within the current compilation unit or, with link time optimization (LTO), the whole program. For instance, when instrumenting the store due to register spilling ENDM f u n c t i o n : mov Xd , SP ;  g e t SP m o v F u n c t i o n I d Xd ;  g e t i d p a c i b LR, Xd ;  PAC s t p FP , LR, [ SP , #0 ] ; s t o r e ; f u n c t i o n body l d p FP , LR, [ SP , #0 ] ; l o a d LR mov Xd , SP ;  g e t SP m o v F u n c t i o n I d Xd ;  g e t i d a u t i b LR, X ;  a u t h r e t Listing 2:The PARTS return address signing binds the PAC to the SP (,) and unique function id (,). ;  g e t i d p a c i a c P t r , Xd ;  PAC ; no i n t e r m e d i a t e c P t r i n s t r u m e n t a t i o n movTypeId Xd ;  g e t i d b l r a a c P t r , Xd ; b r a n c h a pointer variable, the correct type-id can be fetched from the original load. As discussed in Section 2.2, no explicit error handling is added by PARTS; instead, an authentication failure will set specific high-order bits in the pointer, thus triggering a memory translation fault on subsequent dereference or call using the pointer that failed authentication. Our code listings use two macros for setting up PA modifiers for return address signing and type-id based PACs, these are shown in Listing 2 and Listing 3. The function-id is generated at compile-time using LLVM's random number generator, and is guaranteed to be unique withing the LLVM Module (i.e., the whole program, when using link time optimization). Instead, PARTS uses the combined authenticate and branch instructions -e.g., blraa -to perform the branch directly on an authenticated pointer ( ), again using the same PA modifier (). All data pointer stores and loads are instrumented such that a PAC is created immediate before store and authenticated immediately after load (Listing 4). PA keys for each task are stored in a process-specific mm_context_t structure (in the process' memory descriptor in the kernel) which contains architecture-specific data related to the process address space. This prevents a large class of attacks (e.g., typical ROP/JOP gadgets) that rely on redirecting the control flow to code in the middle of functions, i.e., addresses that never were valid targets of benign control-flow transfers.PARTS restricts forward-edge code pointer reuse by enforcing run-time type safety for signed pointers ( R2 ). PARTS data pointer signing protects all data pointers and prevents an attacker from loading a forged data pointer to program memory ( R1 ). On our simulator setup where b = 16, achieving a 50%-likelihood for a correct guess requires 45425 attempts.Note that ROP/DOP attacks require an environment where a set of jumps (gadgets) can be set up, each requiring a separate PAC to be broken. Consequently, success probability of a complete attack will decrease exponentially with the number of jumps necessary.Pre-forked or multithreaded programs will share the same PA key between the parent and all sibling threads/processes. We adopt the same methodology as Brasser et al. [6] and run each test a constant number of iterations for the following cases: a) uninstrumented baseline b) each PARTS scheme (return address signing, forward-edge code pointer integrity, and data pointer integrity) enabled individually, and c) all schemes enabled simultaneously. The tests were performed on a 96boards Kirin 620 HiKey (LeMaker version) with a ARMv8-A Cortex A53 Octa-core CPU (1.2GHz) / 2GB LPDDR3 SDRAM (800MHz) / 8GB eMMC, running the Linux kernel v4.18.0 and BusyBox v1.29.2. Because return address signing only affects the instrumented function, it can be safely applied without interfering with the operation of other parts of programs, or uninstrumented code.PARTS forward-edge code pointer integrity and data pointer integrity can be safely applied to complete code bases. Code-pointer integrity (CPI) [21] protects access to code pointers -and data pointers that may point to code pointers -by storing them in a disjoint area of memory; the SafeStack 8 . Here we describe mechanisms available in commercial off-the-shelf processor architectures.Only a few commercial processors, such as the SPARC M7 9 , support tagged memory, which can be used to realize variety of security models (including pointer integrity). ASAN / HWASAN are complementary to PARTS, as they provide spatial and temporal safety for data accesses via pointers.Intel Memory Protection Extensions (MPX) is a hardware feature for detecting spatial memory errors that debuted in the Intel Skylake microarchitecture. Carlini et al. [8] define fullyprecise static CFI as follows: "An indirect control-flow transfer along some edge is allowed only if there exists a non-malicious trace that follows that edge." We compare PARTS to CFI solutions in Section 9.2.9 Comparison with other integrity policies As discussed in Section 4.1, Pointer Integrity can be loosely defined as a policy ensuring that the value of a pointer at the time of use (dereference or call) corresponds to the value of the pointer when it was created. "Kuznetsov et al's CPI [21] (Section 8) provides fully precise integrity guarantees for code pointers by ensuring that accesses to sensitive pointers are safe (sensitive pointers are code pointers and pointers that may later be used to access sensitive pointers). However, ensuring the uniqueness of PA modifiers is not possible in practice due to the following reasons: 1) program semantics may require a set of pointers to be substitutable with each other (e.g., pointers to callback functions) 2) the choice of allowed pointers may depend on run-time properties (e.g., which callback function was registered earlier). The policy that prevents pointer reuse can suffer from limitations similar to those present stateless CFI.PARTS return address signing provides strong guarantees even when subjected to pointer reuse. PARTS additionally requires matching SP values, and that the reused return address originates from a prior function invocation of the same function within the same process for an attack to succeed.PARTS forward-edge code pointer integrity provides similar guarantees (under reuse attacks) as LLVM's type-based protection (when subjected to any forged pointer). For shared pointers or complex data structures, annotations can disable authentication of selected pointers, allowing programmers to manually adjust pointer conversion to and from legacy code.Currently, the PARTS compiler assumes shared libraries to be uninstrumented. We then instrument the nbench benchmarks using our PA-analogue (Section 7.3.1) and measure the relative execution time between non-instrumented and instrumented nbench tests on the HiKey development platform using the BusyBox time utility.Each individual benchmark test was run 200 times using the pre-determined number of iterations. We therefore only consider user time when measuring the overhead of the instrumentation, and exclude context switches and system calls.The run-time overhead of PARTS is dependent on specific run-time events, such as the number of function invocations in the case of return address signing. If a test run finishes before the minimum execution time has been reached, the test dynamically adjusts its workload, and tries again. We then instrument the nbench benchmarks using our PA-analogue (Section 7.3.1) and measure the relative execution time between non-instrumented and instrumented nbench tests on the HiKey development platform using the BusyBox time utility.Each individual benchmark test was run 200 times using the pre-determined number of iterations. We then extracted the bitcode -created by whole-program-llvm during compilation -and used it to instrument and compile the binaries we used for evaluation: one uninstrumented, one instrumented with PA instructions, and one instrumented with our PA-analogue. Performance benchmarks, for baseline and PA-enabled binaries, were run on the HiKey devices, using the same setup as our nbench evaluation.