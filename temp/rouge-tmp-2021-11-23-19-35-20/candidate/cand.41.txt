The most significant one is link hijacking, where one app can register another app's scheme and induce the mobile OS to open the wrong app. This allows the malicious apps to perform phishing attacks (e.g., displaying a fake Facebook login box) or steal sensitive data carried by the link (e.g., PII) [19,35]. Our goal is to detect and measure link hijacking vulnerabilities across the web and mobile apps, and understand the effectiveness of new linking mechanisms in battling hijacking attacks.We perform extensive measurements on a large collection of mobile apps and websites. To measure the adoption of different mobile deep links, we collected two snapshots of 160,000+ most popular Android apps from Google Play in 2014 and 2016, and crawled 1 million web pages (using a dynamic crawler) from Alexa top domains. We confirm a subset of mistakes in iOS App links too: 1,925 out of 12,570 (15%) fail the verification due to server misconfigurations, including popular apps such as Airbnb.Second, we uncover a new vulnerability in App links, which allows malicious apps to stealthily intercept HTTP/HTTPS URLs in the browser. Through deep links, websites can initiate useful interactions with apps, which is instrumental to many key user experiences, for example, opening apps, sharing and bookmarking in-app pages [49], and searching in-app content using search engines [5]. Unlike app-to-app communication, mobile deep link can only launch front-end Activity in the app.Mobile deep links work in two simple steps: 1) Registration: an app "foo" should first register its URIs ("foo://" or "https://foo.com") to the mobile OS during installation. This allows a malicious app to hijack the request to the Facebook app to launch itself, either for phishing (e.g., displaying a fake Facebook login box), or stealing sensitive data in the request [19,35]. Suppose a malicious app "bar" also wants to register "http://foo.com/*", the verification will fail, assuming the attacker cannot access the root of foo.com server to modify the association file and the fingerprint.The iOS version of App links is called universal link, introduced at iOS 9.0 [9], which has the same verification process. While the hijacking risk of scheme URLs has been reported by existing research [18,19,55], little is known about how prevalently this risk exists among apps, and how effective the new mechanisms (App links and Intent URLs) are in reducing this risk in practice. If mobile OS redirects the user to the malicious app, it can lead to phishing (e.g., the malicious app displays forged UI to lure user passwords) or data leakage (e.g., the deep link may carry sensitive data in the URL parameters such as PII and session IDs) [19,35]. Intent URLs will not prompt users at all since the target app is explicitly specified.Our Goals.Our study seeks to answer key questions regarding how mobile deep links are implemented in the wild and their security impact. How much do App links and Intent URLs contribute to mitigating such links?To answer these questions, we first describe data collection ( §3), and measure the adoption of App links and scheme URLs among apps ( §4). For each app in App2016, we also obtained the developer information, downloading count, review count and rating.Our app dataset is biased towards popular apps among the 2.2 million apps in Google Play [48]. Interestingly, 434 apps actually have the association file ready on their web servers, but the developers seem to forget to configure the apps to turn on the verification.Even for apps that turn on the verification, only 194 out of 415 can successfully complete the process as of January 2017. On the server-side, 177 apps turn on the verification, but the destination domain does not host the association file; 11 apps host the file under an HTTP server instead of the required HTTPS server; 10 apps' files are in invalid JSON format; 60 apps' association files do not contain the App link (or the app) to be verified. Manual examination shows that new mistakes are introduced when the developers update the association files.Misconfigurations for iOS and Android.To show that App links verification can be easily misconfigured, we put together 1,012,844 web domains to scan their association files. In 2016, out of all 23,830 apps that adopt deep links, 23,636 apps either use scheme URLs or unverified App links. The key observation is that App links introduce orders of magnitude more hijacked links than scheme URLs, as shown in Figure 12 (log scale y-axis). Our study identifies new vulnerabilities and attacks, and we are taking active steps to notifying the related parties for the risk mitigation.First, regarding the over-permission vulnerability, we have filed a bug report through Google's Vulnerability Reward Program (VRP) in February 2017. We suspect that users install Redirector apps because of the convenience, since these apps allow users to open the destination apps (without bouncing to the browser) even if the destination apps have not yet adopted App links. Meanwhile, among these websites, App links drastically increase the number of links that have hijacking risks compared to existing vulnerable scheme URLs To the best of our knowledge, our study is the first empirical measurement on the ecosystem of mobile deep links across web and apps. The app's developer needs to set up an association file "assetlinks.json" beforehand under the root directory ("/. The corresponding numbers for 2016 are higher: 697 schemes and 3,272 web hosts from 8,961 apps.Our result is a lower bound of actual collisions, biased towards popular apps. Our The high-level intuition is: 1) third-party schemes/hosts often have official documentations to teach developers how to use the library, which are searchable online; 2) functional schemes are well-documented in public URI standard. This extremely low adoption rate indicates that Intent URLs have little impact to mitigating hijacking risks in practice.Challenges to Intent URL Adoption.Since Android still supports scheme URLs, it is possible that developers are not motivated to use Intent URLs to replace the stillfunctional scheme URLs. Second, according to Google's report [11], over 60% of Android devices are still using Android 5.0 or earlier versions, which do not support App link verification. A more practical solution should prohibit per-app schemes, while not crippling the widely deployed functional/third-party schemes on the web.Second, App links and Intent URLs were designed with security in mind. Android, however, leaves the decision to users: if an unverified link is clicked, Android prompts users to choose if they want to open the link in the app or the browser. If a user clicks on an unverified App link, the mobile OS will prompt the user to choose whether he/she would like to open the link in the browser or using the app. We extract App Link URIs as those with http/https scheme. While most existing works focus on vulnerabilities in scheme URLs [18,19,55], little is known about how widely App links and Intent URLs are adopted, and how effective they are in mitigating the threat in practice. We rank features based on the information gain, and identify top 3 features: average number of apps from the same developer (apDev), number of unique no-prefix components (npcNum) and number of unique components (ucNum). Android OS prompts users when unverified App links are clicked, and users can choose between a browser and the matched app. We provide an overview of deep link adoption by analyzing 1) how widely the scheme URLs are adopted among apps, and 2) whether App links are in the process of replacing scheme URLs for better security. Third, we only focus on the link hijacking threat, because this is the security issue that App links and Intent URLs were designed to address. Within App2014, we identify 394 schemes, 1,547 web hosts from 5,615 apps involved in link collisions. Redirection (and MITM) can be automated without prompting users by exploiting the over-permission vulnerability (see §5.2) -if the user once sets a preference for just one of those links.Hijacking a Competitor's App.Many apps are competitors in the same business, and we find targeted hijacking cases between competing apps. To remove and mitigate vulnerabilities, researchers propose to automatically generate app patches [39,45,58], enforce strict policies [16,17,31,51,59] and provide guidelines for writing safer apps [31]. Then for each group, we filter out apps that have no conflicting URIs with any other apps in the group, and produce apps with link collisions. However, for App links, scheme-level permission means attackers can hijack any HTTP/HTTPS links.To successfully exploit this vulnerability, a malicious app needs to trick users to set the preference (e.g., using benign functionalities). We manually filter them out and get 175 standard functional schemes. Note that for these failed apps, we do not distinguish whether they are malicious apps attempting to verify with a domain they do not own, or simply mistakes by legitimate developers.We confirm all these mistakes lead to failed verifications by installing and testing related apps on a physical phone. Next, we move to the web-side to examine how mobile deep links are distributed on the web, and estimate the likelihood of users encountering hijacked links. These apps are not malicious, but may cause confusions -a user is going to open the Citi Bank app, but a non-related app shows up (and vice versa). Clicking an intent URL will launch an "explicit intent" to open the specified app.Compared to scheme URLs and App links, Intent URL does not need special URI registration on the app. We perform extensive security analyses to understand how effective App links can prevent hijacking ( §5), and then describe the method to detect hijacking attacks among apps ( §6). When an App link is clicked, users can set "preference" for always opening the link in the native app without prompting again. For each visit, the crawler loads the web page and waits for 300 seconds allowing the page to load the dynamic content, or perform the redirection. We crawled two snapshots of the association files for each domain in January and May of 2017 respectively. These schemes are expected to be registered • Third-party scheme/host (T) is used by thirdparty libraries, which often leads to (unintentional) link collision. This crawling is also biased towards popular websites, assuming that deep links on these sites are more likely to be encountered by users. With the wide adoption of smartphones, mobile websites and native apps have become the two primary interfaces to access online content [10,44]. Intuitively, there are not many restrictions on how developers register their URIs, and thus it is possible that the patterns of per-app schemes are not that strong.Since fully automated classification is not yet feasible, we then explore useful heuristics to help app market admins to conduct collision auditing. Our analysis is based on the deep links extracted from two snapshots of 160,000+ top Android apps from Google Play (2014 and 2016), and 1 million webpages from Alexa top domains. For customized scheme URLs that are still used on the web, Android needs to handle their failure gracefully without severely degrading user experience. Then, to label third-party schemes, we manually search for their documentations or tutorials online. We use the January snapshot to discuss our key findings, and then use the May snapshot to check if the identified problems have been fixed. Inter-app Communication & Deep Links.Researchers have discovered various vulnerabilities in the inter-app communication mechanism in Android [19,23] and iOS [52], which leads to potential hijacking and spoofing attacks. In August 2016, we crawled a second snapshot of top 160,000 free apps using an Android 6.0.1 client. Our results showed strong evidence that the newly proposed deep link methods (App links and Intent URLs) fail to address the existing hijacking risks in practice. These apps are content-heavy and often handle user personally identifiable information (e.g., social network app) and financial data (e.g., shopping app). A quick keyword search returns 74 sensitive parameter names related to authentications (e.g., authToken, sessionid, password, access token, full list in Appendix). Careem is more popular (5M+ downloads), which uses scheme "careem" for many functionalities such as booking a ride (from hotel websites) and adding credit card information. In addition, we identify s