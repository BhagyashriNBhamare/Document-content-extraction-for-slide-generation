The hackers of a decade past employed simple tactics -stack-based buffer overflows were leveraged to jump to shellcode on the stack, the constructors, destructors, and Global Offset Tables of binaries were fruitful targets to achieve execution control, and an incorrect bounds-check most of the times guaranteed successful execution. The stack was made non-executable, leading to hackers developing the concept of return oriented programming (ROP) [43] and the resulting war between ROP attacks and defenses [36,37]. The application heap, which is responsible for dynamic memory allocation of C and C++ programs (including the runtimes of other higher-level languages), is extremely complex, due to the necessity to balance runtime performance, memory performance, security, and usability. In turn, the corruption of heap metadata may cause heap handling functions to fail in an attackercontrollable way, leading to increased attacker capabilities, and, potentially, a complete application compromise.This weakness has not gone ignored: Heap implementation developers have introduced hardening mechanisms to detect the presence of heap metadata corruption, and abort the program if corruption is present. Most of them were developed with the sole purpose of providing dynamic memory management with the best performance in terms of both minimal execution time and memory overhead.Memory-corruption issues (such as buffer overflows), have been shown to be exploitable by attackers to achieve, for instance, arbitrary code execution in vulnerable software. Examples of such allocators are: ptmalloc [22], used by glibc (the implementation of libc commonly used in Linux distributions), dlmalloc [31] (originally used in glibc, now superseded by ptmalloc), and the heap implementation used in musl [2] (a libc implementation typically used in embedded systems). This allows an attacker to execute, at will, instructions such as the following (allocating some memory, filling it with attacker-controlled data, and then freeing it): c = malloc(data size); read(stdin, c, data size); ... free(c);Additionally, an attacker may be able to exploit any vulnerabilities in the code, such as double free, use-after-free, buffer overflows, or off-by-one errors. To exemplify how modern libc libraries contain checks to detect and mitigate memory corruptions and how these B.size=0x200To bypass the check, set to B.size & (~0xFF) (during Step 1) 0x100 0x80Overlapping Chunks ERRONEOUS C.prev_size Figure 1: Graphic representation of how to exploit a 1-byte NULL overflow in the current version of glibc (using ptmalloc). Allocating B1, which is placed between A and C, should trigger the update of the field prev size 2 of C. However, the allocator computes the location of C.prev size by doing B+B. prev size == X.size, where X is an arbitrary freed chunk and next chunk is a function returning the next chunk of a given chunk by computing next chunk = X + X.size.Interestingly, similar to other security checks present in glibc, Chris Evans' patch was added with some degree of uncertainty about its effectiveness, stated by the author himself in his blog post: "Did we finally nail off-by-one NULL byte overwrites in the glibc heap? Given the premise that an attacker can utilize the 1-byte NULL overflow to perform this technique, the same primitive could be used to set the memory contents at the end of a chunk, hence, this constraint does not pose a new restriction to the attack. However, their effectiveness is, in general, limited and, most importantly, not systematically tested.Our work aims exactly at targeting this third point, by creating HEAPHOPPER, a tool to perform bounded model checking of libc implementations to detect if and how memory corruption bugs can be exploited.As an example, in Section 7.7, we will show how our tool was able to automatically understand that the aforementioned glibc patch was bypassable. The input of HEAPHOPPER is a compiled binary library (in the format of a shared object file) implementing a heap and a configuration file specifying:List of transactions: A list of operations that an attacker is allowed to perform, such as malloc, free, buffer overflows, use-after-free, etc. Using symbolic execution HEAPHOPPER can, at the same time, verify such properties and determine the content that attackercontrollable data (e.g., the content of legitimately malloced buffers or the value of overflowing data) should have to achieve a detected security property violation.The use of symbolic execution obviously requires HEAPHOPPER to have access to the compiled binary code of the analyzed library. As a consequence, the only branches encountered by our execution are those within the heap implementation.At the same time, we lower the complexity of the generated constraints by minimizing the amount of symbolic data and using specific symbolic memory handlers when an access to symbolic memory is encountered (see Section 5.3 and Section 5.4). Indirect interactions are modifications of the allocated memory, such as buffer overflows, presumably caused by flaws in the program using the allocator.We define a transaction as an operation that modifies the heap's state directly or indirectly. For this reason, the symbolic execution unit will use symbolic-but-constrained values for the size parameter of malloc.To choose the range of that constrain values, we rely on the fact that most of the allocator implementations execute different code paths for certain ranges of sizes, typically called bins [35]. In a heap scenario, the buffer is represented by an allocated chunk, and the overflow happens into the memory right after the chunk. For allocators that make use of inline metadata, this can have severe consequences regarding the integrity of internal data, which often leads directly to exploitation primitives and further memory corruptions.There are two common paths that lead to a heap overflow. Most often, this is the result of an integer overflow when calculating the allocation size.In our model, an overflow represents an indirect interaction with the heap. The action becomes even more powerful if the reference to the freed chunk is used for a write access, because it lets an attacker manipulate data stored inside the freed chunk, and this modified data might be used later by the vulnerable program.We model a UAF transaction by writing symbolic memory into any freed chunk. Nevertheless, in case of a successful double-free, the chunk is stored inside the allocator's internal structures for freed chunks twice, which can lead to further corruption of the heap structure.The double-free is modeled as a call to free with any formerly freed chunk, which entails a different sequence for each of them.fake-free (FF). The symbolic execution unit will automatically determine, if possible, the values that this symbolic area must contain in order to pass the allocator's checks.At this stage we do not know, for instance, the correct allocation sizes or the value of overflowing data that is necessary to reach an exploitation primitive. Consequently, the main focus here is to minimize the amount of sequences, while simultaneously avoiding missing sequences of transactions that could lead to exploitation primitives.Therefore, we only consider permutations with at least one misuse of the heap (direct or indirect), as we assume that a completely benign usage of the heap will not lead to any malicious state. Formally, in order to detect an OA when a new memory chunk is allocated at address A, HEAPHOPPER uses an SMT solver to check if the following condition is true:∃B : ((A ≤ B) ∧ (A + sizeo f (A) > B)) ∨ ((A ≥ B) ∧ (B + sizeo f (B) > A))where B is the location of any already-allocated memory chunk.Non-Heap Allocation (NHA). A NHA can be further exploited by, for instance, obtaining a malloced region on the stack and use it to change a saved return pointer, taking control of the program counter.To detect this condition, first of all, we detect when the brk or mmap syscalls (used to ask the kernel to allocate memory) are called by the heap allocator. This second scenario is common when it is possible to force the allocator to perform a write operation, but, in order to bypass the allocator's checks, the content of the memory where the write happens needs to satisfy certain constraints (e.g., it needs to contain data looking like a legitimate chunk's header). In cases where the retrieved value ends up in the condition of a branching instruction, this large solution space can cause a substantial workload for the SMT solver, and ultimately lead to a state explosion, slowing down the symbolic execution significantly. To mitigate this issue, we developed a three-step procedure, including a new approach designed specifically for the type of analysis that HEAPHOPPER performs.In the first step, we filter out symbolic memory accesses that are in fact well-bounded and need no specific treatment. Therefore, we ask the SMT solver to check if the number of solutions for the target of a symbolic access is less or equal than a threshold T 1 (in our experiments, 16). If this is true, we add proper constraints to the memory locations where the memory access happened, and we continue with the symbolic execution.The second strategy was specifically designed to handle an allocator's symbolic metadata, and attempts to concretize resulting memory accesses to attacker-controlled regions. In the final step, HEAPHOPPER generates a proof-of-concept program for each sequence that reached an exploitation primitive, based on the interaction sequence's source code (which contains placeholder, undefined variables) and the data from the symbolic execution.The generated PoC program serves two purposes: First, it provides a concrete execution example of how a specific exploitation primitive is reached, supporting the manual analysis of HEAPHOPPER's result. In order to solve this issue, we use our knowledge about the runtime environment during the symbolic execution to identify pointers and their offsets with respect to the base of their particular memory segment.Additionally, we utilize this knowledge to identify constants that represent offsets between objects in memory. Furthermore, we chose two different overflow sizes to simulate a full 64-bit overflow (which is the register's size of the architectures targeted by the analyzed allocators) and a one-byte overflow. Finally, we display each set for every exploitation primitive in the table, together with one of the paths with the shortest size, as an example of a list of transaction violating the considered security property.For instance, consider dlmalloc 2.7.2, where a NHA exploitation primitive can be reached with three different sets of transactions. The fact that a lot of the newer allocators are still inspired by dlmalloc or even based on the original code, makes this result an even better measurement of the allocator's evolution.Since the first release of dlmalloc in 1993, there have been multiple changes to the code base, including a couple of security hardening in 2005. To get more insights into this issue we specifically studied the influence of tcache in the overall ptmalloc security, as described in Section 7.8 Our results show that a "textbook implementation" of a heap allocator, such as the one used by dlmalloc version 2.7.2, does not offer an effective protection against memory corruption. fastbin dup NHA M-M-F-UAF-M-M 9.93s house of einherjar NHA M-M-O-F-M 51.10s house of spirit NHA FF-M 9.22s overlapping chunks OA M-M-M-F-O-M 14.05s unsafe unlink AWC M-M-O-F 13.80s unsorted bin AW M-M-F-UAF-M 9.54s poison null byte OA M-M-M-F-O-M-M-F-F-M 603.40s house of lore NHA M-M-F-M-UAF-M-M 18.72sIn the last column we give HEAPHOPPER's runtime to find a path that reaches the exploitation primitive based on an interaction model representing this technique. For the interested reader, the resulting PoC is provided in Appendix A.3 Given this result, we analyze the shortcomings of the patch and identified that the problem stems from the fact that the consistency check uses values obtained by using the manipulated offsets in the previous size. This structure is designed to keep track of freed chunks, and it is placed as a cache before the traditional list of free chunks.In order to analyze its effects on the overall security of ptmalloc, we compiled the newest release of ptmalloc once with tcache enabled and once without. Specifically, it is possible to achieve an AW using a fake-free operation.After manually analyzing the implementation of tcache, we found that it completely omits all the security checks on the traditional list of free chunks, by establishing another layer of free-lists that is used before the original structures.With this result, HEAPHOPPER exposed the significance of this design change in ptmalloc. These two issues cause some of the PoCs generated by HEAPHOPPER to attempt to read from or write to invalid memory or to process incorrect data, resulting in segmentation faults or heap implementation assertions rather than producing an actual attack. The sequence of transactions for the 1-byte NULL technique in C source code, as it is passed to the symbolic execution engine. /* * List of transactions : M -M -M -F -O -M -M -F -F -M */ # include < malloc . // ... size_t write_target [4]; size_t offset ; size_t header_size = 0 x20 ; size_t mem2chunk_offset = 0 x10 ; size_t malloc_sizes [6] = {0 x100 , 0 x200 , 0 x100 , 0← x100 , 0 x80 , 0 x200 }; size_t fill_sizes [6] The resulting PoC for the same sequence showed in Appendix A.2, but executed with ptmalloc including Chris Evans' patch. // ... size_t write_target [4]; size_t offset ; size_t header_size = 0 x20 ; size_t mem2chunk_offset = 0 x16 ; size_t malloc_sizes [6] = {0 x100 , 0 x200 , 0 x100 , 0← x100 , 0 x80 , 0 x200 }; size_t fill_sizes [6] = {0 x100 , 0 x200 , 0 x100 , 0← x100 , 0 x80 , 0 x200 }; size_t overflow_sizes [1] The sequence of transactions for the unsafe unlink technique (see Table 3), as it is passed to the symbolic execution engine.