In fact, it has been shown that this effect is more severe with embedded software than with regular desktop software, due to the frequent lack of hardening of embedded software and hardware support for memory access controls such as memory management units [23]. From left to right: logical (e.g., arithmetic, logic), memory (load, store, barrier), hardware (supervisor call, co- Figure 1: Presence of assembly instructions in realworld embedded software.processor registers access), control-flow (branch and conditional). In summary, in this paper we present the following contributions:• A new methodology to automatically merge lowlevel LLVM bitcode, poor in semantic information and relying on the features of a target architecture, with high-level LLVM bitcode, rich in semantic information useful to detect vulnerabilities during symbolic execution • A modified symbolic virtual machine, able to run the resulting bitcode code and to handle peripherals' memory and interrupts using different analysis strategies • A fast debugger to connect the peripherals on the real device with the virtual machine, preserving event synchronization • A thorough validation of the system to guarantee meaningful and reproducible results, and an evaluation of the approach on both synthetic and realworld cases • A tool based on affordable off-the-shelf hardware components and source code that will be fully published as open-sourcePaper organization. Second, the Inception Symbolic Virtual Machine, which is able to execute this mixed-level LLVM-IR, and to handle interrupts and memory-mapped peripherals with different strategies, to adapt to different use cases. It provides high-speed access to the peripherals and could be easily extended for multiple targets.In the following we give an overview of our lift-andmerge approach, of how KLEE performs security checks, and on how we extended it to support interrupts and peripheral devices.2.2 Lift-and-merge process Figure 2 shows the main stages of our bitcode merging approach and how source code with inline assembly 1 is transformed into a consistent bitcode 3 that can be executed by Inception VM. Indeed, the original purpose of LLVM-IR bitcode is to enable advanced optimizations before code lowering to the target architecture, whereas assembly is already at a low semantic level that cannot be represented or optimized by the LLVM compiler.To solve this problem, we introduce a novel liftand-merge approach, which we implement in InceptionTranslator. We call the resulting bitcode a Mixed Semantic Level bitcode (mixed-IR), shown in 3 , which contains:High Semantic Level IR (high-IR) obtained from C/C++ source code. All security analyses mainly rely on the Memory Monitor of KLEE, which is able to perform security check for each access, based on the semantic information associated to it. In order to be able to glue assembly and binaries with source code into a unified LLVM-IR representation (mixed-IR), we apply two distinct processes.The lifting process takes machine code (compiled assembly or binaries) and produces an equivalent intermediate representation (low-IR). Another advantage of KLEE allocation is that it can detect memory management errors such as invalid free of local or global variables.The normal KLEE stack is used when high-IR code is running. Indeed, when the high-IR allocates data, the resulting memory object is typed and allocated at the same address as indicated by the symbol table, to keep the compatibility with assembly code. Therefore, whenever the Static Binary Translator finds a call or return that crosses the IR levels, it invokes the ABI adapter to generate some glue-IR that adapts parameters and return values.When a high-IR function calls a low-IR function, the high-IR arguments (typed objects) must be lowered to the architecture-dependent memory (stack/CPU registers). This process is similar to serializing and deserializing the LLVM typed objects, to store them as words in the LLVM variables that represent the CPU registers and the stack, where they are used by low-IR. A glue-IR prologue takes the input arguments from the KLEE stack (where the high-IR caller stored them) and brings them to the CPU registers and/or low-IR stack (where the low-IR callee expects them).2. Before calling the high-IR function, some glue-IR takes the input arguments from the CPU registers or the low-IR stack (where the low-IR caller stored them) and promotes them to typed objects on the KLEE stack (used by the high-IR callee).4. The main challenge when dealing with control flow consists in finding a good mapping between high-level control flow operators present in LLVM-IR (e.g., call, if/else) and low-level ARMv7-M instructions, which are at a lower abstraction layer (they directly modify the program counter, and sometimes rely on implicit hardware features). We translate to an LLVM call instruction any Arm instruction that saves the program counter before changing its value (i.e., direct and indirect branch-and-link instructions) to an LLVM call instruction. It would be possible to enforce stricter control flow integrity checks by retrieving the control flow graph with a static analysis or a compiler pass.We translate all instructions that restore the previous program counter, for example bx lr and pop pc, to return instructions. We rather detect the corruptions by relying on the memory checks, e.g., to detect buffer overflows.We implement all other direct (conditional) branches and it-blocks 6 with simple direct branches available in LLVM-IR. Interrupts are used very frequently in embedded programs to synchronize the peripherals with the embedded software in an event-driven fashion, or to implement multithreading.Inception VM can receive interrupts from the real device (when real peripherals are used and generate interrupts) or generated by the user using helper functions (e.g., to stress specific functions in a deterministic way). In this case, KLEE executes an LLVM-IR helper function that accesses the interrupt vector table in the firmware memory to resolve the address of the interrupt handler to call, based on its identifier (ID). If the vector is fixed, a slight speedup in execution can be obtained by storing the vector in a configuration file, loaded by KLEE at startup.Before giving control to an interrupt handler, and when returning from it, a Cortex-M3 processor performs several seamless operations (e.g., stacking and unstacking the context, managing two stack modes). Context switching is pos- sible because when a thread is interrupted, its context is saved to its stack, and the context of the resuming thread, including the program counter, is pulled from another stack. To collect interrupts on the real device, we insert a stub on the device that registers one handler for each possible interrupt. On the left, we can observe the switch between threads enabled by the seamless context stacking and unstacking.In summary, Inception Debugger fully handles interrupt synchronization with the host virtual machine, while previous work had only limited interrupt support [34]. Our debugger is able to communicate with the stub running on the device and handle interrupts using a dedicated asynchronous line and shared memory locations.In summary, we provide a clean slate design for an efficient, cheap , and open-source solution, which can be used to experiment and replicate research that requires customizable debuggers (e.g., [25]). For example, we compared single instructions against the real Cortex-M3 processor, assembly functions against the C code from which they originate or alternative implementations, and complete applications against their behavior on the native hardware. While some of the examples we use below are proprietary, we also built a large set of validation and evaluation examples, sometimes based on existing open-source code. In particular, we explore if KLEE can detect memory corruptions on a vulnerable path, depending on how variables are allocated and accessed by different types of IR. The same mechanism is applied to local (static) allocation and global allocation.Second, when using KLEE dynamic allocation functions, all vulnerabilities can be detected in both high-IR and low-IR, whereas if we use some implementation in the code of the application, the detection rate drops to almost zero for both high-IR and low-IR. One of the vulnerabilities could be detected, but it is not triggered because of state explosion (47k states) and the constraint solver (using 67.5% of the time), which are problems inherent to symbolic execution and common to KLEE. For this, it uses small assembly routines that strongly interact with the features of the target processor and it is, therefore, a good test case for Inception. We experiment with the injection of vulnerabilities in one thread, symbolic execution with producers and consumers, and corruption of the context of a thread.We take the injected vulnerabilities from the NSA Juliet Test Suite 1.3 for C/C++, which collects known security flaws for Windows/Linux programs. We skip tests that cannot run on our target STM32L152RE (e.g., those that require a file system or a network interface) and those that the LLVM 3.6 bitcode linker cannot handle (poor support of the C++ name mangling feature) for a total of 10384 and 1214 deletions, respectively. We obtain 1562 tests which we embed in FreeRTOS threads.To trigger the vulnerabilities, Inception has to first execute low-level code containing assembly, and in some cases also to flag as symbolic the output of a software or hardware random generator. To show the potential of Inception in these conditions, we analyzed a bootloader under development, and we found a problem that would have been difficult to detect on FPGA-based prototypes.Our target is a secure bootloader with several options, stored in a One Time Programmable (OTP) memory. Inception found a test case in which a bit-wise shift depended on an untrusted value (overshift), which we confirmed by manual inspection. Early detection is useful to avoid expensive fixes later.Commercial payment terminal To show the potential of Inception when hardware is available, we tested a payment terminal under development, using the FPGA prototype to redirect most peripherals and their interrupts. However, symbolic exploration visits the higher-level logic of the application rather than the drivers, making the problem less common. However, the detection level for the bitcode generated from low-IR could be improved, for example, reconstructing typed objects from assembly, using DWARF debug information, and adding extra detection heuristics (e.g., from [23]). define i32 @foo ( i32 %a , i32 % b ) #0 { entry : // PROLOGUE BB store i32 %a , i32 * @R0 store i32 %b , i32 * @R1 br label %" i32x4_reti32 +0" " i32x4_reti32 +0": ... // EPILOGUE %0 = load i32 * @R0 ret i32 %0 } 2. Low-IR to high-IR parameter passing.void @high_fu nction (){ ... // High IR code % R0_2 = load i32 * @R0 % R1_1 = load i32 * @R1 % R2_1 = load i32 * @R2 % R3_2 = load i32 * @R3 % SP15 = load i32 * @SP % SP16 = inttoptr i32 % SP15 to i32 * % SP17 = load i32 * % SP16 %0 = call i32 @low_function ( i32 % R0_2 , i32 % R1_1 , i32 % R2_1 , i32 % R3_2 , i32 % SP17 ) store i32 %0 , i32 * @R0... // High IR code } define i32 @foo ( i32 %a , i32 %b , i32 %c , i32 %d , i32 % e ) #0 { ... // low -IR } 1. Low-IR to high-IR parameter passing.void @high_fu nction (){ ... // High IR code % R0_2 = load i32 * @R0 % R1_1 = load i32 * @R1 % R2_1 = load i32 * @R2 % R3_2 = load i32 * @R3 % SP15 = load i32 * @SP % SP16 = inttoptr i32 % SP15 to i32 * % SP17 = load i32 * % SP16 %0 = call i32 @low_function ( i32 % R0_2 , i32 % R1_1 , i32 % R2_1 , i32 % R3_2 , i32 % SP17 ) store i32 %0 , i32 * @R0... // High IR code } define i32 @foo ( i32 %a , i32 %b , i32 %c , i32 %d , i32 % e ) #0 { ... // low -IR }