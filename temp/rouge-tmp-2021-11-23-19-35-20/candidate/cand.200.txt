Thus, the simple usage of SGX would still leak the client's addresses to malicious full node.Given such limitations of SGX, the primary research problem and contribution of this paper is how to design and implement a solution that enables private processing of light client request in the presence of enclave leakage without compromising the system's overall performance. We emphasize that in our application the assisting full node needs to process a large blockchain database to serve client requests, and thus straightforward usage of generic SGX side-channel protection systems, such as Raccoon [47], Cloak [28] or ZeroTrace [49], would result in either excessive performance overhead or imperfect side-channel protection. In the extreme cases, the filter matches everything, i.e., the client downloads the full blocks, or the filter only matches the client's addresses, i.e., she has no privacy at all.Gervais et al. [25] have shown that using Bloom filters in Bitcoin light clients leaks more information than was previously thought. In short, SGX provides a set of security enhancements in the processor that allow creation of small applications, called enclaves, whose data confidentiality and code integrity is protected from any malicious software running on the same platform, including the privileged OS.A simple way to leverage SGX would be a solution where the light client sends its wallet private key to an enclave on the assisting full node. Such approach might give the owners of full nodes an undesirable economic incentive to break their own SGX processors, e.g., using physical attacks.To avoid such incentives, we choose a different approach. Although swapping memory pages is supported (swapping requires expensive encryption and integrity verification [17]), the complete blockchain (BC) and the database of unspent transaction outputs (UTXO) are significantly larger (as of Jan 2019, 200GB [12] and 2.8GB [13] or more, respectively) than the enclave's memory limits . Although externally stored data can be sealed (encrypted by the CPU such that only the same enclave can decrypt), the OS can infer information about the accessed element by observing access patterns to individual records, such as files or database entries. In a simple implementation of our approach, the adversary could infer the client's addresses by observing which entries the enclave reads from a (sealed) UTXO database when processing a client request.Similarly, enclaves rely on the OS to perform communication operations which allows it to infer information about the enclave's communication patterns. For example, if our solution would simply return each matching transaction (and the corresponding Merkle Tree) in the specified range of blocks, based on the size of the response the adversary could deduce how much information of interest Depending on the number of requested blocks (up to x) and the number of matching transaction in them, we read potentially extraneous blocks (up to y) to keep the ratio between the read blocks and the response message size constant.for the client was contained within the scanned blocks. However, if the adversary is able to mount high-granularity digital side-channel attacks (e.g., one that allows her to observe execution paths with instructionlevel granularity), she will be able to determine the transactions that were accessed, and thus infer the client's addresses.To make our system more robust against such attacks, we optionally add side-channel protections at the expense of performance (cf. Section 6). To protect against timing leakage we compute the Merkle path for all transactions in each of the scanned block in contrast to only computing the path for The data is copied in an oblivious fashion from the block to a temporary array, i.e., every transaction is conditionally moved using cmov to every possible destination. This means that for every transaction we access every entry in the array and since the same instruction is used for each possible copy -independent of whether the data is actually copied -even an attacker with an instruction level view of the control flow cannot determine which data is actually copied. Specifically, for a block of size m, a temporary array of size t m and n requested blocks, this method requires O(m · t m + t m · n · t) instead of O(m · n · t) operations when naively copying the data obliviously from the block to the response. In particular, this UTXO set is encrypted on the disk as sealed storage, indexed for easy and fast access depending on the client request, and accessed using ORAM to prevent information leakage through disk accesses. Responses are always of constant size, i.e., shorter responses are padded and if a response is too large, the client is informed of missing outputs, such that she can later retrieve the rest of the outputs (e.g., from a different node). To ensure completeness, the client can compare the latest block hash from received response to information from other sources.An adversary that controls the OS of the full node server can deliver incomplete blocks to BITE enclave or decide to not deliver specific new blocks to the enclave. In the worst case the maximum index size involves the lower and upper limits for addresses (20B) and transaction hashes (32B) for every ORAM block resulting in a maximum of (8GB/32kB) · (32B * 2 + 20B * 2) ≈ 19.5MB.To set the response size, we analyzed the typical unspent outputs per active address in the Bitcoin network. Blocks 100 0.7s (± 0.2s) 1.3s (± 0.5s) 2.7s (± 0.9s) 200 0.7s (± 0.2s) 1.4s (± 0.5s) 2.8s (± 0.9s) 300 0.7s (± 0.2s) 1.5s (± 0.5s) 3.0s (± 0.9s) Table 2: Processing time per block with oblivious execution for Scanning Window depending on the number of requested blocks and the temporary size, averaged over 100 blocks.Processing. If all of the above conditions are met, although the adversary controlling the full node does not learn the client's address from a single verification request, he might be able to correlate the timing of the verification re-quest events and the Bitcoin addresses visible in the ledger at roughly the same time, and thus construct a set of candidate addresses that may belong to the served client. However, we stress that such correlation would require long-term tracking of verification requests from the adversary and that the same limitation applies to any light client payment verification scheme.In recommended usage of BITE, the client (i) uses different full nodes for payment verification, (ii) regularly uses fresh Bitcoin addresses (e.g., using an HD wallet [57]), and (iii) introduces unpredictability to the timing pattern of payment verification requests like a small number of extra requests at random time points. However, if future versions of Intel SGX would allow more enclave memory (i.e., currently the limit is 128MB without the expensive page swapping) ranging up to the RAM limit on the residing platform, one could keep the UTXO database and all other security critical data in the memory and not on the disk, similar to recently proposed SGX-based in-memory database systems like EnclaveDB [46]. The main difference between Raccoon and our solution is that by tailoring our implementation, we avoid the need for taint analysis and extra decoy paths enabling a more efficient solution.Other related systems include Cloak [28] that prevents cache leakage using hardware-based transactional memory features in processors; ZeroTrace [49] and Obliviate [14] that provide a library for data structures protected using ORAM; DR.SGX [19] that randomizes and periodically rerandomizes all data locations in enclave's memory with cache-line granularity; and, T-SGX [51] and Deja Vu [22] that detect and prevent side-channel attacks based on repeated interrupts. A small amount of entries is stored in a local (i.e., memory) structure -stash.Every access involves reading all buckets of a path from the root to a leaf into the stash and then writing back new or old re-randomized data from the stash to the same path resulting in an overhead of O(log N) read/write operations. At the time of writing, the UTXO size (indexed by Bitcoin address) is around 3GB while our ORAM overhead accounts for 2 times the original size, totaling around 6GB.We use Path ORAM to store the UTXO set and have evaluated various chunk sizes for the implementation. This can be used to establish a secure communication channel to an enclave.In addition, SGX enables enclaves to store data for persistent storage in an encrypted form through a process called sealing. Our adversary model assumes that side-channel leakage from enclave's execution may happen, but the adversary cannot fully break SGX, i.e., the adversary cannot read all enclave's secrets and modify its control flow arbitrarily. The SPV with no privacy protections performs slight less effective than the Oblivious Database of BITE as it was the case when the processing performance was compared. A malicious user might attempt DoS by asking for a very long scan window, incurring large processing times for full nodes and making the service momentarily unavailable for other clients. Hearn and Corallo later introduced Bloom filters [18] in BIP 37 [31] that allow a client to probabilistically request a subset of all transactions in a block to mask which addresses are owned by the client. If the client does not request the filter headers from multiple entities and then requests the blocks from a different one, she can be easily tricked into revealing her addresses by using forged filters: A node prepares a filter matching half of all addresses and sends it to the client. During the last few years, the research community has studied information leakage from SGX enclaves extensively and proposed a number of defenses. We propose leveraging commonly available trusted execution capabilities of SGX enclaves for improved lightweight Bitcoin client privacy. If the given response size r is greater, then the enclave has to scan up to block y (or y − x more blocks), such that r = (n − y) * t. For client update requests over the last 100 blocks, the current SPV mode takes 0,62s, 1.06s, 1.06s, 1.5s, with the false positive rates of Bloom filters set to 0.0% 0.1%, 0.5% and 5%, respectively. In ORAM, the adversary does not learn any information about which data is being accessed and when, whether the same data is being repeatedly accessed (i.e., unlinkability), the pattern of the access itself, and lastly the purpose, type of the access (i.e., write or read). Observation of the control flow and memory access does not leak whether the operation performed by the enclave was a read or a write, and since there is a single control flow without creating multiple branches depending on the condition, we effectively hide the execution path and thus protect this variant from internal leakage in full. To ensure that the enclave always uses the latest version of the sealed UTXO database, SGX counters or rollback-protection systems such as ROTE [39] can be used.Database Update. First, when accessing the security critical data structures, specifically, the position map, stash, and the indexes containing information about which chunks contain unspent transactions of a certain Bitcoin address we pass over them entirely in the memory to hide the memory access pattern. Our solutions also fail gracefully: even if the used SGX processor would be completely broken (e.g., through a physical attack), the adversary cannot double spend or steal users' coins or wallets.In terms of performance, our solution is comparable to the SPV scheme. The threshold indicates the maximum response size per block such that if we are to scan n − x blocks, the maximum response size for the client can be r = (n − x) * t. If we consider the most powerful attacker that can perform all digital sidechannel attacks (see Section 3.3), this variant would be forfeit due to the leakage of the code access patterns, specifically, execution paths in the if statements when the stash, indexes and the position map is being accessed. As the full node has to learn all transactions issued and received by the requesting client to confirm them, such payment verification obviously violates user privacy.To improve user privacy, several clients support filters (e.g., Bitcoin's BIP37 [31] and Ethereum's LES [6]). However, such verification leaks critical information about clients' transactions , thus defeating user privacy that is often considered one of the main goals of decentralized cryptocurrencies. This variant scans complete blocks from the blockchain database, instead of accessing individual transactions within them, and thus prevents direct information leakage from disk access patterns. Since the adversary controls the OS, she can schedule and restart enclaves, start multiple instances, and block, delay, read, or modify all messages sent by enclaves, either to the OS itself or to other entities over the network. Note that the numbers regarding standard SPV with the Bloom filter false positive rate of 0.0% actually indicates a solution with no privacy, e.g. the light client sends only his addresses in the request without any masquerading. The false positive rate can be set by the creator of the filter.In Bitcoin light clients, Bloom filters are used to encode transactions or addresses, and allow a full node to determine which transactions to send to a lightweight client without letting the full node know the exact addresses. We note that ZeroTrace [49] also provides similar external leakage protection as Obliviate, but since the ZeroTrace paper does not report performance overhead numbers suitable for comparison, we exclude it from our discussion. Encrypting each data record before storing it on the server provides confidentiality, but access patterns to stored encrypted records can leak information, such as correlation of multiple accesses to the same record. For example, LC i receives the first response containing x transaction outputs with an indication that there is more, and in a consequent request specifies the same address as in the first request along with the x-th transaction hash and transaction number. For readers unfamiliar with this algorithm, a brief description is in Appendix B.Database Initialization. While BITE is designed for Bitcoin, we stress that it finds direct applicability in various other blockchain platforms as well.Contributions. Our solution can be integrated into existing full nodes and lightweight clients with minor modifications to the existing software. Enclave memory is handled in plaintext only inside the processor and is encrypted by the processor whenever it leaves the CPU (e.g., to DRAM) to ensure that neither the OS nor malicious hardware can access it.Even though the OS is untrusted, it is responsible for starting and managing enclaves. They also show that, even with a larger number of addresses, the attacker is able to correctly identify a client's addresses with high probability if she is in possession of two distinct Bloom filters from the same client (e.g., due to a client restart). Oblivious RAM (ORAM) [26], is a well-known technique that hides access patterns to an encrypted storage medium. In this variant, the enclave on the full node maintains a specially-crafted version of the unspent transaction outputs (UTXO) database and when a client sends a verification request, it checks for the presence of client's outputs in this database using oblivious database access (ORAM [52]) and responds accordingly. This is in contrast to the naive solution of storing the clients' private keys in the enclave and using it as a remote wallet. Since a lightweight client can choose any available node to connect to, she can choose to send requests to different nodes to hide the number of sent requests. That is, the adversary cannot access processor-specific keys (e.g., attestation or sealing key) and she cannot access enclave runtime memory that is encrypted and integrity-protected by the CPU. We propose BITE (for BItcoin lightweight client privacy using Trusted Execution), a solution in which a potentially untrusted entity runs a full node with an SGX enclave that serves transaction confirmation requests fr