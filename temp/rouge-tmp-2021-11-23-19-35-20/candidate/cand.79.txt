One fundamental impediments to the widespread adoption of decentralized or "permissionless" blockchains is that Proofs-of-Work (PoWs) in blockchains are wasteful.PoWs are nonetheless the most robust solution today to two fundamental problems in decentralized cryptocurrency design: How to select consensus leaders and how to apportion rewards fairly among participants. In a PoUW system, users can utilize their CPUs for any desired workload, and can simultaneously contribute their work towards securing a blockchain.There have been several attempts to construct cryptocurrencies that recycle PoW by creating a resource useful for an external goal, but they have serious limitations. Other consensus approaches, e.g., BFT or Proof of Stake, are in principle waste-free, but restrict consensus participation or have notable security limitations.Intel recently introduced a new approach [41] to eliminating waste in distributed consensus protocols that relies instead on trusted hardware, specifically a new instruction set architecture extension in Intel CPUs called Software Guard Extensions (SGX). Otherwise, compromised SGX-enabled CPUs would allow an attacker to generate PoUWs at will, and both unfairly accrete revenue and disrupt the security of the blockchain [24,70,73]. For REM, we set forth a rigorous statistical testing framework for mitigating the damage of broken chips, provide analytic security bounds, and empirically assess its performance given the volatility of mining populations in real-world cryptocurrencies. Our techniques, which combine static and dynamic program analysis techniques, are of independent interest.We have implemented a complete version of REM, encompassing the toolchain that instruments tasks to produce PoUWs, compliance checking code, and a REM blockchain client. • A broken-chip countermeasure consisting of a rigorous statistical testing framework that mitigates the impact of broken chips ( §4). • A methodology for trustworthy performance instrumentation of SGX applications using a combination of static and dynamic program analysis and SGXbacked trusted compilation ( §5). Compensation to miners is granted per block generated, leading to an expected miner revenue that is proportional to the miner's hashrate.As the mining power that is invested in a cryptocurrency grows, the cryptocurrency's cryptopuzzle difficulty rises to keep the block generation rate stable. This choice of primitive is significant in our design of REM, as Intel made the design choice that attestations can only be verified by accessing Intel's Attestation Service (IAS) [44], a public Web service maintained by Intel whose primary responsibility is to verify attestations upon request.REM uses attestations as proofs for new blocks, so miners need to access IAS to verify blocks. As we suggest in Section 5.4, a simple modification, to the IAS protocol, which Intel is currently testing, can eliminate this overhead entirely.Randomness As operating systems sit outside of the trusted computing base (TCB) of SGX, OS-served random functions such as srand and rand are not accessible to enclaves. It is only partially decentralized, though, in that it relies for security on two key assumptions about the hardware manufacturer's behavior.First, we must assume that Intel correctly manages identities, specifically that it assigns a signing key (used for attestations) only to a valid CPU. In particular, as we shall see, she can falsify random number generation and lie about work performed in REM.Even this strong adversary, though, does have a key limitation: As signing keys are issued by the manufacturer, and given our first assumption above, it is not possible for an adversary to forge identities. There are three types of entities in the ecosystem of REM: A blockchain agent, one or more REM miners, and one or more useful work clients.The useful work clients supply useful workloads to REM miners in the form of PoUW tasks, each of which encompass a PoUW enclave and some input. Intuitively, REM may be viewed as simulating the distribution of block-mining intervals associated with PoW, but REM does so with PoUW, and thus eliminates wasted CPU effort.When a PoUW enclave determines that a block has been successfully mined, it produces a PoUW, which consists of two parts: an SGX-generated attestation demonstrating the PoUW enclave's compliance with REM and another attestation that a block was successfully mined by the PoUW enclave at a given difficulty parameter. The blockchain agent concatenates the PoUW to the block template, forming a full block, and publishes it to the network.When a blockchain participant verifies a fresh block received on the blockchain network, in addition to verifying higher-layer properties (e.g., in a cryptocurrency such as Bitcoin, that transactions, previous block references, etc., are valid), the participant verifies the attestations in the associated PoUW.Intel's PoET scheme looks similar to REM in that its enclave randomly determines block intervals and attests to block production. While no real practical attack is known, researchers have demonstrated potentially dangerous side-channel attacks against applications [73] and even expressed concerns about whether an attestation key might be extracted [24]. While she could not spend other people's money, which would require access to their private keys, she could perform denial-of-service attacks, selectively drop transactions, or charge excessive transaction fees.In principle, a broken attestation key can be revoked through the Intel Attestation Service (IAS), but this can only happen if the break is detected to begin with. An adversary A controls a static subset M A ∈ M, where |M A | = k. rate(m i ) specifies the mining rate of m i , the number of mining operations per unit time it performs.We define a candidate block to be a tuple B = (t, m, d), where t is a timestamp, m ∈ M the identity of the CPU that mines the block, and d is the block difficulty. Let C be the space of all possible blockchains C. Let C m denote blockchain C restricted to blocks mined by miner m ∈ M.In REM, a blockchain-acceptance policy is used to determine whether a block appears to come from a legitimate miner (CPU that hasn't been compromised). (Blockchain-Acceptance Policy) A blockchain-acceptance policy (or simply policy) P : C × B → {reject, accept} is a function that takes as input a blockchain and a proposed block, and outputs whether the proposed block is legitimate. Note that E[π ˆ m (C S (τ))]is equal for all suchˆmsuchˆ suchˆm, as they all use strategy Σ A and can emit blocks as frequently as desired (ignoring rate( ˆ m)). P stat rejects H 0 if |C m | is greater than the (1−α)-quantile of the Poisson distribution. An important property that differentiates P stat from canonical statistical tests is that P stat repeatedly applies a given statistical test to an accumulating history of samples. We also assume that the difficulty d(t) is stationary over the period of observation.Waste Under P stat , a miner generates blocks according to a Poisson process; whether a block is accepted or rejected depends on whether the miner has generated more blocks than a time-dependent threshold. Indeed, as we show, we can represent waste in P stat using a discrete-time Markov chain that is periodically identical to the process it models, meaning that its expected waste is identical at any time nτ, for n ∈ Z + and τ a model parameter specified below. (1)The transition probabilities in our Markov chain are:P[i → j | i ∈ C \C rej [α]] = P( j − i + 1) if j ≥ i − 1 0 otherwise (2) P[i → j | i ∈ C rej [α]] = P( j + 1) if j ≤ −1 0 otherwise. If so, the enclave produces an attestation that includes the input block hash and difficulty.Why Count Instructions While instructions are reasonable estimates of the CPU effort, CPU cycles would have been a more accurate metric. First, it completes in a single cycle, and second, it doesn't change flags and therefore does not affect con- 4 PoUW := ⊥ /* simulating n Bernoulli tests */ 5 l ← U[0, 1] /* query SGX RNG */ 6 if l ≥ 1 − (1 − diff) n then 7 PoUW = Σ intel [ hash | diff | 1 ] 8return outcome, PoUW ditional jumps. The PoUW runtime serves as an "in-enclave" loader that launches the useful work program with proper input and collects the result of instruction counting. If a block should be generated, the PoUW runtime produces an attestation recording the template hash that it is called with and the difficulty.The last step of the toolchain is to compile the resultant assembly and link it (using linker GNU ld) with the PoUW runtime (PoUWruntime.so), to produce the PoUW enclave. This PoUW enclave is finally signed by an Intel SGX signing tool, creating an application PoUWEnclave.so that is validated for loading into an enclave.The security of instruction counting relies on the assumption that once instrumented, the code cannot alter its behavior. section text ... enclave_entry: xor %rax, %rax xchgl ENCLAVE_MTX(%rip), %rax cmp %rax, 0 jnz enclave_entry Figure 8: Code snippet: a spinlock to allow only the first thread to enter enclave entry not enforced by the hardware. When one thread is swapped out, the register value stored in an SSA is subject to manipulation by another thread.While more complicated techniques such as Address Space Layout Randomization (ASLR) for SGX could provide a general answer to this problem, for our purposes it suffices to enforce the condition that an enclave can be launched by at most one thread. Beyond the computational effort, just placing all programs on the blockchain for verification would incur prohibitive overhead and enable DoS attacks via spamming the chain with overly large programs. Finally, it calculates the program's fingerprint and outputs an attestation including this fingerprint.Every PoUW then includes two parts: The useful work program attestation on the mining success, and an attestation from the compliance checker of the program's compliance (Figure 9). PoUW Enclave's output should match the block template (namely the hash of the block prefix, up to the proof) and the prescribed difficulty.Generalized Hierarchical Attestation The hierarchical attestation approach can be useful for other scenarios where participants need to obtain attestations to code they do not know in advance. Moreover, a simple modification to the IAS protocol, which is being tested by Intel [3], could get rid of the reliance on IAS completely on verifiers' side.Recall that the IAS is a public web service that receives SGX attestations and responds with verification results. We evaluate the overhead of REM with four examples of useful work benchmarks in REM as mining programs: a protein folding algorithm [1], a Support Vector Machine (SVM) classifier [22], the zlib compression algorithm (iterated) [2], and the SHA3-256 hash algorithm (iterated) [7]. We evaluate each benchmark in three modes:Native We compile with the standard toolchain.SGX We port to SGX by removing system calls and replacing system libraries with SGX-compliant ones.Then we compile in SGX-prerelease mode and run with the SGX driver v1.7 [43]. These works, and the line of hybrid blockchain systems starting with Bitcoin-NG [32,51,63], can all utilize PoUW as a low-waste alternative to PoW.Another line of work on PoW for cryptocurrencies aims at PoWs that resist mining on dedicated hardware and prevent concentration of mining power, e.g., via memory-intensive hashing as in Scrypt [54] and Ethereum [19]. In particular, allowing for secure instruction (or cycle) counting would reduce PoUW overhead, and a secure chip-model reading instruction would allow for PoPW implementation.We reported on a complete implementation of REM, swapped in for the consensus layer in Bitcoin core in a prototype system. In summary, our results show that REM is practically deployable and promising path to fair and environmentally friendly blockchains in partially-decentralized blockchains.A Tolerating Compromised SGX Nodes: Details We start by discussing how to statistically infer the power of a CPU from its blocks in the blockchain. Therefore in a given time interval of length T , the number of blocks mined by a specific CPU obeys Poisson distribution (since CPU rates are high and the win probability is small, it's appropriate to approximate a Binomial distribution by a Poisson distribution,) and with rate rate i T d(t). To this end, instead of finding the strongest CPU directly, we approximate rate best based on rate ρ (e.g. f 90% ), namely the ρ−percentile fastest miner.Bootstrapping. At this early stage, it makes sense to hardwire a system estimate of the maximum mining power of honest miners into the system and set conditions (e.g., a particular mining rate or target date) to estimate rate best as we propose above. As we don't know M A a priori, though, the only policies we consider operate on individual miner block-generation history.As a wrapper expressing implementation by A of Σ A , we model A as a program prog A , specified in Figure 12. Every honest miner m ∈ M − M A follows an identical strategy, a probabilistic algorithm denoted Σ h . To understand the security of REM, we consider a security game that defines how an adversary A interacts with honest miners, a blockchain consensus protocol, , and policy P, a security game S(P) is a tuple S(P) = ((M, M A , rate(·)); (Σ A , Σ h )). It is known that as λ for a Poisson distribution goes to infinity, it converges in the limit to a normal distribution with mean and variance λ .