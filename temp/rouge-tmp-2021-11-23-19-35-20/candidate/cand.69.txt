Protected module architectures, such as Intel SGX, enable strong trusted computing guarantees for hardware-enforced enclaves on top a potentially malicious operating system. Recent research convincingly demonstrated that adversarial system software can extract sensitive data from enclaved applications by carefully revoking access rights on enclave pages, and recording the associated page faults. With the advent of Intel SGX [32], support for Protected Module Architectures (PMAs) is now available on mainstream consumer hardware, and can be used to defend against malicious or compromised system software, both in an untrustworthy cloud environment [3,36] as well as for desktop applications [18]. An essential aspect of enclaved execution is that the hardware prevents privileged system software from reading or writing a module's private memory directly, or from tampering with its internal control flow. The PRM region is subdivided into two data structures: the Enclave Page Cache (EPC) and the Enclave Page Cache Map (EPCM). Since PRM is a limited system resource, untrusted system software is in charge of assigning protected memory pages to enclaves, and is allowed to oversubscribe the EPC. Furthermore, a page fault is signaled to the untrusted OS for EPC accesses that either do not belong to the currently executing enclave, are accessed through an unexpected virtual address, or do not comply with the read/write/execute permissions imposed by the EPCM.To speed up subsequent memory accesses, SGX employs the processor's Translation Lookaside Buffer (TLB) as a trusted cache of already checked page permissions. That is, SGX's memory access protection is entirely implemented in the Memory Management Unit (MMU) hardware that consults the untrusted page tables and the EPCM whenever a provided virtual address was not found in the TLB [32,9]. SGX therefore flushes the TLB and internal paging-structure caches whenever entering or exiting an enclave, and requires the OS to engage in a hardwareverified protocol that ensures proper TLB invalidation before evicting an EPC page.SGX's dual permission lookup scheme prevents malicious system software from mounting active memory mapping attacks [9]. In case of a page fault, SGX also takes care of zeroing out the twelve least significant bits of the faulting address, revealing only the page number, but not the 12-bit offset within that page.Importantly, SGX enclave threads are unaware of interrupts by design, and have to be resumed explicitly by invoking eresume from the unprotected application context. Since eresume cannot be intercepted however, an enclave has no way of enforcing its internal exception handler to be actually called.SGX's exception model ensures that the untrusted operating system remains in control of shared platform resources such as memory or CPU time, and prevents direct information leakage of register contents. Like previous SGX attacks [48,40,13,37,28], we finally assume knowledge of the (compiled) source code of the target application.At the system level, we assume a classical MMU-based architecture where the system software maintains a multilevel page table data structure in OS memory to control virtual to physical page mappings. In addition, to stay under the radar of remote attestation schemes [39] that require the user's approval for each enclave invocation, our stealthy adversary should extract information from a single run of the victim enclave. A malicious OS can exploit this property to obtain a page-level trace of enclave execution by clearing the "present" bit in the Page Table Entries (PTEs) that form the enclave's virtual address space. The controlled-channel attack relies on an exhaustive offline analysis of the target application binary to identify page fault sequences, and afterwards uses this information to extract rich information (full text and images) without noise from a single run of the victim enclave. This defense technique overlooks however that page faults can also be caused by directly modifying PTE attributes controlled by the OS. The hardware is modified to report page faults directly to the enclave, without OS intervention, so as to enable protected enclave programs to detect contract violations. The T-SGX compiler wraps each basic block in a TSX transaction, and uses a carefully designed springboard page to hide page faults across transactions. Since the OS is made unaware of page faults, an adversary learns at most one page access by observing early program termination. T-SGX prevents reruns by requiring the remote enclave owner's consent before starting the enclaved application.Note that T-SGX does not consider frequent enclave preemptions suspicious (up to 10 consecutive transaction aborts are allowed for each individual basic block). Between the submission and acceptance of this paper, however, more recent work was published [7] that leverages TSX to not only hide page faults, but also monitor suspicious interrupt rates. We finally explain how to infer conditional control or data flow in large programs by correlating subsequent page accesses in page sets as a more stealthy alternative to the page fault sequences introduced by Xu et al. [48]. Our attacks are based on the important observation that a processor in enclave mode accesses unprotected page table memory during the address translation process.1 void inc_secret (int s) { 2 if (s) 3 * a += 1; 4 else 5 * b += 1; 6 } 1 int compare_and_swap ( int old, int new) { 2 if ( * a == old) 3 return ( * a=new);The key intuition is to exploit side-effects of the page table walk to identify which page has been accessed. Cache memories introduce a measurable timing difference for DRAM accesses and enable a powerful class of microarchitectural side-channel attacks, for they are shared among all software running on the platform.A reliable and powerful class of access-driven cache attacks based on the FLUSH+RELOAD [50] technique exploits the availability of physical shared memory between the attacker and the victim, as is often the case with shared libraries. However, since the data cache hierarchy remains explicitly untouched, an adversarial OS can perform a FLUSH+RELOAD-based cache timing attack on the page table itself.In our inc_secret running example, a kernel-space attacker uses clflush to evict the last-level PTEs referenced by a as well as b, before entering the enclave. More realistic scenarios, however, repeatedly operate over the same code or data in a single start-to-end run.As an example, consider the pseudocode for elliptic curve scalar point multiplication in Fig. 3, where a provided point P is multiplied with a secret scalar d to obtain another point Q. Previous fault-driven attacks [40] recovers the private scalar by observing different page fault sequences for iterations corresponding to a one (P 1 , P 2 , P 1 , P 3 , P 1 , P 2 ) or zero (P 1 , P 2 , P 1 , P 2 ) bit.The key difference in our stealthy attacker model, as compared to the page fault channel, is that we are not notified in case of a memory access. If the adversary only probes PTEs after enclave execution, she is left with aggregated information only (e.g., all pages P 1 , P 2 , and P 3 have been accessed). She can either periodically interrupt the enclave with a timer-based preemption, or she can conditionally interrupt the victim CPU from a snooping thread. In this respect, note that concurrent, unpublished work [46] has demonstrated that Intel's HyperThreading technology can be abused to evict TLB entries from a co-resident logical processor in real-time, without interrupting the victim enclave.Our spy thread monitors one or more page table entries in a tight loop, preempting the victim enclave CPU after a page access has been detected. The latter can be easily achieved in multiprocessor systems through a directed Inter-Processor Interrupt (IPI), specifically designed to a.o., synchronize address translations across cores. From the point of view of the enclave, IPIs are directly handled by the CPU's local Advanced Programmable Interrupt Controller (APIC), and are thus indistinguishable from regular interrupts sent by a benign operating system.Monitoring A/D Bits. Naturally, the probability of an overlapping victim access increases as the length of the time slot decreases, whereas a longer time slot increases detection latency and might miss subsequent memory accesses by the victim. As such, a trade-off is presented between attack resolution and accuracy.When reloading PTEs after the enclave has been exited, as in the start-to-end examples of Fig. 2, our measurement cannot be destroyed by a concurrent victim access. Spying on page table memory the FLUSH+FLUSH way thus ensures we can see all page accesses with a minimal detection latency.FLUSH+FLUSH also confronts us with a new challenge however, since the microarchitectural timing differences of the clflush instruction are inherently more subtle than the apparent timing penalty for a DRAM access in FLUSH+RELOAD [16]. Since a PF-aware attacker does not have to cope with latency in the measurement process, she may construct page access sequences at instruction-level granularity.In the running example of Fig. 3, the ec_mul function on P 1 serves as a trampoline to redirect control flow to either point_double on page P 2 or point_add on page P 3 , based on the secret scalar bit under consideration. Where a page fault only leaks one bit of information (i.e., the trigger page was accessed), our notion of page sets allows a spy to capture the maximum information for every trigger page interrupt.Applying our page set theory to the running example of Fig. 3, the spy thread monitors the trigger page P 2 holding a.o., point_double, and matches the page set {P 1 , P 3 } on every interrupt. Finally, in case P 1 as well as P 3 were both not accessed, P 2 must have been accessed from an execution context other than the targeted point_double invocation, and we classify the interrupt as a false positive.After identifying secret-dependent control flow or data accesses in the victim application, a successful attack comes down to designating specific pages to be tracked in the spy thread, and recognizing the associated page set patterns. The libOS relies on a small Platform Adaptation Layer (PAL) to translate platform-independent host ABI calls into a narrow set of system calls to the underlying host operating system, which remains, however, explicitly trusted from a security perspective.Graphene-SGX [45] -like other recently proposed SGX-based shielding systems including Haven [3], Panoply [41], and SCONE [2] -improves over this situation by not only protecting libOS instances from each other, but also from a malicious host operating system. Since SGX prohibits enclaves from making system calls directly, the PAL is split into a trusted part that calls out to an untrusted runtime in the containing application to perform the system call to the untrusted host OS. We run our core attacker code in kernel mode to be able to easily send IPIs, inspect PTE attributes, and monitor page 6 Upon detecting an access on the trigger page, the spy interrupts the victim thread as soon as possible. To easily discover executable base addresses, we propose to first deploy the target application binary in an attacker-controlled libOS instance that we minimally modified to leak load addresses. We furthermore found the technique to be reliable, for FLUSH+FLUSH recorded all 10,000 page accesses, without false positives, and with significantly less noise (smaller standard deviation) than an A/D spy.The increased advantage of a FLUSH+FLUSH spy, as opposed to a spy monitoring A/D bits, can be understood from the effects on the caching behavior of the page table walk. The security of elliptic curve public key crypto systems critically relies on the computational intractability of the elliptic curve discrete logarithm problem: given an elliptic curve with two points A and B, find a scalar k such that A = kB. Recall that our running example in Fig. 3 provides an efficient algorithm for the inverse operation, i.e., multiply a point with a known scalar. We rely on a robust PTE set of nine additional code pages whose combined A bits unambiguously identify an unconditional execution point in add_points as well as the conditional point_set invocation on line 10. We can therefore see improved, heuristic defenses using suspicious interrupt rates as an artefact of an ongoing attack.Indeed, Déjà Vu [7], which was first published after we submitted this work, explores the use of TSX to construct an in-enclave reference clock thread that cannot be silently stopped by the OS. Furthermore, when applying Sanctum's enclave-private page table design to modern x86 processors [23], an adversary could still leverage the Extended Page Tables (EPTs) set up by the hypervisor. Masking A/D attributes in enclave mode is neither sufficient nor desirable, as it cannot prevent our cache-based attacks, and disrupts benign OS memory management decisions.At the application level, we believe the academic community should investigate different defense strategies based on the type of enclave. A recent line of work has developed PMA security architectures that support secure isolated execution of protected modules with a minimal trusted computing base, either via a small hypervisor [31,30,42,19], or with trusted hardware [29,32,11,10,34,27]. Finally, between submission and publication of this paper, the SGX research community has witnessed a steady stream of microarchitectural side-channel attacks; either by abusing the branch prediction unit [28], or in the form of finegrained PRIME+PROBE [13,37,5,33] cache attacks.In a more general, non-PMA context, there exists a vast amount of research on microarchitectural cache timing vulnerabilities [35,50,17].