Detecting differences between two binary executables (binary diffing), first derived from patch analysis, have been widely employed in various software security analysis tasks, such as software plagiarism detection and malware lineage inference. Our approach improves existing semantics-based binary diffing by 1) inferring whether two executable bi-naries' behaviors are conditionally equivalent; 2) detecting the similarities or differences, whose effects spread across multiple basic blocks. We have developed a prototype , called BinSim, and performed empirical evaluations against sophisticated obfuscation combinations and more than 1, 000 recent malware samples, including now-infamous crypto ransomware. At a high level, it represents the input-output relations of a basic block as a set of symbolic formulas, which are later proved by either a constraint solver [41,15,25,43], random sampling [54] or hashing [37] for equivalence. Although these tools are effective against moderate obfuscation within a basic block, such as register swapping, instruction reordering, instruction substitution, and junk code insertion [51], they exhibit a common "block-centric" limitation [13,37]; that is, it is insufficient to capture the similarities or differences that go beyond a single basic block boundary. Note that the behaviorrelated instruction segments typically bypass the boundary of a basic block so that we are more likely to detect similarities or differences that spread across basic blocks.More precisely, we run two executables in tandem under the same input and environment to record their detailed execution data. determining whether two matched system calls are truly equivalent under current path conditions boils down to a query of equivalence checking.We have developed a prototype of BinSim on top of the BitBlaze [66] binary analysis platform. We believe BinSim is an appealing method to complement existing malware defenses.Scope and Contributions BinSim is mainly designed for fine-grained individual binary diffing analysis. • BinSim presents a novel concept, System Call Sliced Segment Equivalence Checking, that relies on system or API calls to slice out corresponding code segments and then checks their equivalence with symbolic execution and constraint solving. • Unlike previous work that evaluates the efficacy of binary diffing either on different program versions [7,25,49], different compiler optimization levels [21,41] or considerably moderate obfuscation [37,41], we evaluate BinSim rigorously against sophisticated obfuscation combinations and recent malware. Binary diffing methods based on behavior features (e.g., system call sequence or dependency graph) are prevalent in comparing obfuscated programs, in which the accurate static analysis is typically not feasible [48]. However, if we take a closer look at line 3 and 4 in Figure 1(b), the two statements are used to calculate the absolute value of x. When a basic block produces multiple output variables, existing block-centric binary diffing approaches try all possible permutations [54,41,25] to find a bijective mapping between the output variables. ROP has been used as an effective obfuscation method [40,55] to clutter control flow.4. Given two programs P and P 񮽙 , our approach performs dynamic analysis as well as symbolic execution to compare how the matched system call arguments are calculated, instead of their exhibited values. To walk around this obstacle, we identify the possible cryptographic functions from the sliced segments and decom- out (a, b) in (a, b) out (c) = (i+1) -(j << 2) BB1:BB2:a = i + 1 b = j << 2 c = a -b (b) in (i', j') out (a', b') in (b', a') out (c') = (j' << 2) -(i' + 1) BB1':BB2':a' = i' + 1 b' = j' << 2 c' = b' -a'Semantically different pose them from equivalence checking (step 3). The results of the three programs are shown as follows.ψ 1a : x + x ψ 1b : 2 × ((x ∧ (x >> 31)) − (x >> 31)) ψ 1c : x << 1To verify whether ψ 1a = ψ 1b , we check the equivalence of the following formula:x + x = 2 × ((x ∧ (x >> 31)) − (x >> 31)) (1)Similarly, we check whether ψ 1a = ψ 1c by verifying the formula:x + x = x << 1 (2)The constraint solver will prove that Formula 2 is always true but Formula 1 is not. The online stage, as shown in the left side of Figure 6, involves two plug-ins built on Temu [66], a whole-system emulator: generic unpacking and ondemand trace logging. Figure 5: System call sliced segment equivalence checking steps: (1) system call alignment; (2) dynamic slicing and weakest precondition calculation; (3) cryptographic function detection; (4) equivalence checking; (5) cryptographic function approximate matching. The logged trace data consist of three parts: 1) instruction log contains each executed instruction's x86 opcode and values of operands; 2) memory log stores memory access addresses, which facilitate binary code slicing; 3) system calls invoked and their data flow dependencies. Our generic unpacking plug-in, similar to the hidden code extractor [30], supports recording the execution trace that comes from real payload instead of various unpacking routines.One common attack to system call recording is adding irrelevant system calls on purpose, which can also poison the system call sequences alignment. Kolbitsch et al. [36] have observed three possible sources of a system call argument: 1) the output of a previous system call; 2) the initialized data section (e.g., . The static single assignment (SSA) style of Vine IL will facilitate tracking the use-def chain when performing backward slicing. The output for each processing: (1) unpacked code, instruction log, memory log, and system call sequences; (2) IL traces and initial matched system call pairs; (3) weakest preconditions of system call sliced segments; (4) identified cryptographic functions.morphism [14] and tree automata inference [3] are orthogonal to our approach. To this end, commencing at a tainted system call's argument, we perform dynamic slicing to backtrack a chain of instructions with data and control dependencies. Our solution is to split data dependencies and control dependencies tracking into three steps: 1) index and value based slicing that only consider data flow; 2) tracking control dependencies; 3) remove the fake control dependencies caused by virtualization obfuscation code dispatcher.BinSim shares the similar idea as Coogan et al. [19] in that we both decouple tracing control flow from data flow when handling virtualization obfuscation. In contrast, value based slicing in Figure 7(c) contains the instructions that is relevant to the computation of memory value A[j] = a + b, which is exactly the expected slicing result. In addition to explicit conditional jump instructions (e.g., je and jne), obfuscators may hide control flow into indirect jumps by using encoding function to calculate the real branch [78]. To identify these implicit control transfers, our approach trace the data flow of eflags bit value; that is, the instructions that calculate the bit value of the eflags are added into the slice. Virtualization obfuscation, a great challenge to binary code slicing [61,79], replaces the original binary code with new type of bytecode, and a specific interpreter is attached to interpret each bytecode. For each instruction sequence ending with an indirect jump, we mark the input registers as a 1 , a 2 , ...a n and output registers as After that, we will remove the fake control dependencies caused by virtualization obfuscation code dispatcher. In addition to the generic detection methods based on monitoring file system anomalies [32,58], it is very interesting to investigate this emerging threat with BinSim, such as identifying ransomware variant relationships and investigate ransomware evolution. Our backward slicing step will produce a quite long instruction segment, and the corresponding equivalence checking will become hard to solve as well [67]. We apply the advanced detection heuristics proposed by Gröbert et al. [27] (e.g., excessive use of bitwise operations, instruction chains, and mnemonic const values) to quickly match known cryptographic function features. The resultant WP formula for a program point can be viewed as a conjunction of predicates accumulated before that point, in the following form:WP = F 1 ∧ F 2 ∧ ... ∧ F k . To this end, we perform validity checking for the following formula.wp 1 ≡ wp 2 ∧ arg 1 = arg 2(3)Different from existing block-centric methods, whose equivalence checking is limited at a single basic block level, our WP calculation captures the logic of a segment of instructions that go across the boundaries of basic blocks. Therefore, we maintain a HashMap structure to cache the results of the previous comparisons for better performance.To quantitatively represent different levels of similarity and facilitate our comparative evaluation, we assign different scores (0.5 ∼ 1.0) based on the already aligned system call sequences. The precision is to measure how well BinSim identifies different malware samples; while recall indicates how well BinSim recognizes the same malware samples but with various obfuscation schemes. 4 Different implementations BitCount (Figure 3) isPowerOfTwo (Appendix Figure 12) flp2 (Appendix Figure 13) 5 Covert computation [59] Synthetic benchmarks 6 Single-level virtualization VMProtect [69] 7 Multi-level virtualization Synthetic benchmarks collected from the reference [79] 5 We conduct our experiments with several objectives. They abstract system call sequence to a set of features (e.g., OS object, OS operations, and dependencies) and measure the similarities of two feature sets by Jaccard Index. The heuristics-based comparisons adopted by BinDiff and DarunGrim can only handle mild instructions obfuscation within a basic block. Our semantics-based equivalence checking can show that the new sliced segment is equivalent to the original instructions.Next, we evaluate BinSim's cryptographic function approximate matching, which allows equivalence checking in the presence of cryptographic functions that could otherwise be hard to analyze. After investigating BinSim's output, we find out that CryptoWall.d reveals three distinct behaviors: 1) "query-then-infect": it will terminate execution if the infected machine's UI languages are Russian, Ukrainian or other former Soviet Union country languages (via GetSystemDefaultUILanguage). We report our experience of applying BinSim and other six binary diffing tools on 1, 050 active malware samples (uncontrolled dataset) 5 . Because BinDiff, DarunGrim, and CoP cannot directly work on the packed binary, we provide the unpacker binaries preprocessed by BinSim's generic unpacking.In most cases, dynamic-only methods and BinSim are able to find small distances among intra-family samples. This optimization can frustrate "block-centric" binary diffing methods, and we have seen such cases repeatedly in our dataset. However, correctly implementing a cryptographic algorithm is not a trivial task, and most cryptographic functions are reused from open cryptographic libraries, such as OpenSSL and Microsoft Cryptography API [75]. This research was supported in part by the National Science Foundation (NSF) under grants CCF-1320605 and CNS-1652790, and the Office of Naval Research (ONR) under grants N00014-16-1-2265 and N00014-16-1-2912.