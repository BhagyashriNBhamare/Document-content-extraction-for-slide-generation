The main reason for the increased scalability is the ability of the dynamic execution component to reduce the complexity faced by the static analysis component.An additional goal of our approach is that of enabling automatic exploit generation for different classes of vulnerabilities with minimal analysis setup overhead. To address the scalability challenge, we prioritize only those modules that contain potentially vulnerable sinks where an attacker 'may' be successful in injecting malicious values or in exploiting other types of vulnerabilities, and analyze them further in the successive search.In the second step, we construct the actual exploits. To maximize the coverage of the code during dynamic analysis, the crawler and concolic executioner are aided by a constraint solver, which generates the (exploit) sequence of HTTP inputs.Our contributions in NAVEX include an exploit generation framework that can easily scale to large applications and many classes of vulnerabilities and a novel method that combines dynamic execution and static analysis to address scalability issues affecting previous works, mainly due to the dynamic features of web applications.We evaluate NAVEX on 26 applications having a total of 3.2M SLOC and 22.7K PHP files. Based on the query results, $ SESSION ['ISBN'] is initialized and an HTTP link to hold.php is printed on the browser.1 <?php 2 if(!isset($_SESSION['username'])) 3 header( "Location: index.php" ); 4 if (isset($_POST['book_name'])) 5 $book_name = mysql_real_escap_string($_POST['book_name']); //sanitization 6 else 7 $book_name =""; 8 if (isset($_POST['edition'])) 9 $edition = (int)$_POST['edition']; //user input is sanitized 10 else 11 error(); 12 if (isset($_POST['publisher']) && strlen($_POST['publisher'])<=35) 13$publisher = str_replace(""", "\"", $_POST ['publisher'] Listing 1: selectBooks.php, find books to borrow.Hold.php (Listing 2) performs additional checks and, if they are satisfied, an HTTP link guides the user to the next step (line 7). When the link is clicked the superglobal $ GET ['step'] is set and the module checkout.php is therefore included by hold.php and executed. Checkout.php completes the borrowing process by providing a link (line 19) to the user for confirmation. The link sets two superglobals ($ GET ['step'] and $ GET ['msg']), which will be checked by the module (line 6). Finally, a confirmation function (line 13) is called to notify the user that the book was successfully reserved.1 <?php 2 if(!isset($_SESSION['username'])) { 3header( "Location: index.php" );4 exit(); 5 } 6 if (isset($_SESSION['ISBN'])){ 7echo "<a href='".BASE_URL."hold.php?step=checkout'> Checkout</a>";8 if (isset($_GET['step']) && $_GET['step'] == "checkout") 9include_once( "checkout.php");10 } 11 ?> An attacker may thus be able to run a SQLI exploit without needing to log in first.1 <?php 2 if(!isset($_SESSION['username'])) { 3 header( "Location: index.php" ); 4 exit(); 5 } 6 if (isset($_GET['msg']) && isset($_SESSION['ISBN'])){ 7 $sql = "SELECT name FROM USERS WHERE username='$_SESSION['username']'" ; 8 $result = mysql_query($sql); 9 $name = $db->sql_fetchrow($result); 10 $msg = $_GET['msg'] As illustrated by the example, typical web applications have client-side logic that consists of forms, links, and JavaScript code, which may be dynamically generated by the server-side code, as well as a complex serverside logic that frequently interacts with the client-side and with the database backend. However, sanitizations are available in many flavors, including builtin sanitizations (e.g., htmlspecialchars()), implicit sanitizations (e.g., cast operators as shown in the running example), custom sanitizations (e.g., custom use of str replace()), and sanitizations induced by database constraints (e.g., NOT NULL constraints). For this simple application, to construct an exploit for the vulnerable sink in Listing 3, we have to process a total of 44 execution paths in the 3 modules (i.e., 32 paths in selectBooks.php, 4 in hold.php, and 8 in checkout.php) to find candidate exploitable paths to the sink.Another scalability challenge we need to tackle is related to the goal of generating exploits for multiple classes of vulnerabilities. Our goal is to build a precise, scalable, and efficient exploit generation framework that takes into account the dynamic features of web applications and the navigational complexities that stem from dependencies among the client-side, server-side and database backend.Our approach is implemented in a system called NAVEX, as shown in Figure 1. Specifically, injection vulnerabilities typically need a backward traversal, while vulnerabilities such as EAR need a forward one. Specifically, our graph model is based on Code Property Graphs (CPGs) [9,33], which combine abstract syntax trees (AST), control flow graphs (CFG), call graph, and data dependence graphs (DDG) under a unique representation to discover vulnerabilities, which are modeled as graph queries. For instance, san-sql and unsan-sql represent presence (or non-presence) of SQLI sanitization, respectively.The values of the sanitization tags are inferred and added to the graph during its construction. Note, we add sanitization tags that resolve the sanitization status of different types of PHP statements such as assignment, cast, binary, unary statements, built-in functions, etc.To demonstrate how NAVEX assigns sanitization tags, let us consider the statement at line 9 in Listing 1. Note, $name is not a user input (holds values from the database) and therefore the algorithm only returns the inter-paths of $msg as vulnerable paths to XSS.The FilterSanNodes function uses the sanitization and DB tags to prune out unpromising paths for exploit generation. These values are retrieved from the Attack Dictionary based on the type of vulnerability under consideration.The augmented formula (i.e., F path ∧ F db ∧ F attack ) is next sent to a solver, which provides a solution (if it exists) over the values of the input variables, that is an exploit string. To determine its feasibility, NAVEX needs to uncover the sequence of HTTP requests that must be sent to the application to execute the attack described by the exploit strings. In particular, the approach of [7] uses static analysis to discover links and forms and does not deal with the dynamic features of web applications, whose semantics are challenging to be captured statically.In contrast, NAVEX uses a dynamic execution approach. Having a mechanism that automatically generates valid form inputs greatly improves the crawling coverage of web applications since web forms are common constructs that influence the navigation structure.To address this problem, our crawler extracts the forms' input fields, buttons, and action and method attributes (i.e., GET or POST) using an HTML parser and generates a set of constraints over the form values implied by the form attributes. For instance, in Listing 1, the server-side code introduces an additional check over the string length of $publisher, which is not present in the JavaScript validation.Typically, when the server constraints are satisfied, the execution proceeds and the state of the application is changed, while in the opposite case, the application rejects the form inputs and the state of the application does not change. NAVEX uses the produced trace information to determine whether a request is successful by checking if the application is (i) changing its state (i.e., creating a new session, setting a new variable and superglobal values, etc.) and (ii) performing sensitive operations such as querying the database.When a request is not successful, NAVEX utilizes the trace information to perform a concolic execution. As an example, the above inference constructs the following constraints that yield to a successful form submission (book name=="intro to CS by author1" ∨ book name=="intro to Math by author2") ∧ length(publisher)<=35 ∧ edition >0Finally, for each accepted form, NAVEX stores the full HTTP request that led to the successful submission. It is a directed graph G = (N, E) where each node n ∈ N represents an HTTP request and each edge e = (n i , n j ) ∈ E represents a navigation from n i to n j , which can be of type link or form. It is important to note that the previous identification of vulnerable sinks that 'may' be exploitable greatly reduces the cost of such search and increases the likelihood of finding executable exploits.The search method is summarized in Algorithm 2. Finally, for each found path, it replaces the values of the HTTP parameters in the last edge with the malicious values generated by the solver.Applying the algorithm to our running example, yields to considering http://localhost/App/selectBooks.php as a SeedURL, and the node with id 6 in Figure 4 as DestURL, because that node matches the vulnerable module, whose corresponding (XSS) exploit contains an assignment of a malicious value to the HTTP variable msg. Our criteria for selecting the applications include: (i) evaluation on the latest versions of popular, complex and large PHP applications such as Joomla, HotCRP, and WordPress, and (ii) comparison of NAVEX on the same test applications used by state-of-the-art work in exploit generation (e.g., Chainsaw [7]) and vulnerability analysis (e.g., RIPS [15], [16]). The deployment process includes: installing each application on a server, creating login credentials for each role, and populating the application database with initial data by navigating the application and submitting forms when necessary. myBloggie 2m 2 SchoolMate 0 5 WebChess 1m 36sec 2 Eve 1m 5sec 1 geccbblite 57sec 1 Scarf 1m 44sec 2 FAQforge 47sec 1 WeBid 9m 29sec 2 DNscript 51sec 1 phpBB2 2m mssql query, mysql query, mysqli query, and sqlite query as sinks for SQLI vulnerability.14sec 2 HotCRP (2.60) 30m 13sec 4 osCommerce (2.3.3) 2hr 6m 32sec 2 CPG 24m 40sec 2 MediaWiki 15m 30sec 1 LimeSurvey 46sec 2 osCommerce (2.3.4) 2hr 19m 1sec 2 OpenConf 2m 1sec 2 Gallery3 5m 51sec 2 Collabtive 24m 2sec 3 Total time 6hr 27m 18sec Graph database size 104.44 MiBIt reported a total of 155 SQLI exploitable sinks with a running time of 37m and 45sec. In the following, we demonstrate one of these exploits, which illustrates the precision of our analysis in capturing the effect of custom and built-in sanitization functions along different paths to sinks.Listing 6 shows the vulnerable sink (echo) where user input $HTTP GET VARS['page'] passes through 3 different functions and it is finally processed by either htmlspecialchars or strtr PHP func-tions. NAVEX inferred the semantics of this function (through its modeling of many PHP functions as solver specifications) and used the solver to find an XSS attack string that does not include double quotes from our XSS attack dictionary. We found out that the number of unique forms in all applications ranges from 3 (as in geccbblite) to 186 (as in WeBid) with an average of 45 form/application. NAVEX differs from Chainsaw in 2 aspects: (i) it performs a combination of dynamic and static analyses, which enables it to better scale to large applications and to find more exploits, (ii) it supports finding exploits for multiple classes of vulnerabilities. Additional related works include Ardilla [25], which uses concolic execution and taint tracking to construct SQLI and XSS attack vectors; CRAXweb [22], which employs concrete and symbolic execution supported by a constraint solver to generate SQLI and XSS exploits.