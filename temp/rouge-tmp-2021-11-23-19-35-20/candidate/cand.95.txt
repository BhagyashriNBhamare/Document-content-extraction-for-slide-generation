Operating systems provide various inter-process communication (IPC) mechanisms. The vulnera-bilities can be exploited in enterprise environments with centralized access control that gives multiple users remote or local login access to the same host. The UI may even be implemented in JavaScript and run in a web browser.We assume the attacker to have login access as nonadministrator or, at minimum, the ability to keep nonprivileged processes running in the background. We therefore use the name man in the machine (MitMa) to describe these attackers.During the analysis of case-study applications, we observed that application developers have an ambiguous attitude towards local attackers and the security of IPC channels. On the other hand, the application implementations often make some attempt to authenticate or encrypt the communication, but rarely with the same prudence as seen in communication over physical networks.Our main contribution is to highlight the importance of the adversary model where a nonprivileged user intercepts communication inside the computer. This section describes the adversary model and explains its relevance in everyday information systems.We consider multi-user computers that may have processes of two or more users running at the same time. Linux and macOS workstations are commonly integrated into AD or other centralized directory services.In addition to having its own user account, the MitMa attacker needs to be able to run a process in the background when the victim user is working on the computer. Personal computers generally have not been designed for multiple simultaneous users, but they do support fast user switching [41], that is, leaving login sessions in the background and resuming them later. Authenticated userConsole login SSH Remote desktop N/A N/A Guest account Console login Table 1: MitMa attackers on different OSsThe MitMa attacks can also be launched using guest accounts. The vulnerabilities presented in this paper were found in IPC methods where a server process or device listens for connections from client processes. Some servers might accept only one client connection, and in that case the malicious process needs to connect before the legitimate client.The network-socket server typically listens for TCP connections on one or more predefined ports. This enables the attacker to receive client connections on the primary port and connect itself to a secondary port on the legitimate server.Even if the application uses one fixed port for IPC, the attacker may be able to replay messages by alternating between the client and server roles. Both Windows and Unix systems support named pipes, but the implementation details differ significantly. Some important details are that, if an instance of the named pipe with the same name already exists, only processes with the FILE CREATE PIPE INSTANCE access to the pipe object can create a new instance, and that a process can set the FILE FLAG FIRST PIPE INSTANCE flag to ensure that it is creating the first instance.Attack vectors. The pipe server would have to configure the DACL on the named pipe object carefully to allow access for only legitimate clients.The default security descriptor does not allow the attacker to create new pipe instances. It helps to know that Windows connects new clients to the server instances in round-robin order.To summarize, it is easy to overlook the necessary security controls for named pipes, thus creating vulnerabilities, but on the other hand, careful configuration can avoid most of the issues. Thus, it is attractive to use the more client-server oriented but less safe methods described above.On macOS, apart from the same IPC methods that are available on Windows and Linux, there are also Mach IPC methods that are based on the Mach kernel, such as CFMessagePort. The RoboForm [7] password manager (S) and its browser extension (E) communicate via the loopback network interface with HTTP without any authentication. The attacker then runs its malicious WebSocket server on port 11456 before the benign server starts, which effectively forces the benign server to fail over to another port (the user is not notified about this). The very first time when the browser extension communicates with the WebSocket server, the server verifies the client binary and user in the same way as Dashlane does. By analyzing the JavaScript code of the 1Password browser extension, we found commands that the app can issue to the extension, such as collectDocuments, which tells the browser extension to collect data on the page the user is visiting including the URL and data entered into web forms. If the port is already occupied by another process, the server fails to run.To start using the browser extension, the user needs to cut and paste an authorization token from the app to the extension. E ‚Üê S: [(description 1 , username 1 , password 1 ), ..., (description n , username n , password n )]The browser extension requests the app for password entries that match a given URL. More seriously, the attacker could collude with one of the websites, identify its encrypted URL at the MitMa process by correlating the timing of the encrypted message with the user's login on the colluding site, and then leak the user's passwords to that site one by one. The web browser starts the NMH in a child process and lets the browser extension communicate with it.Native messaging can be used to implement a password manager that is only accessed through the web browser and the browser extension. The attacker can thus sit between the two pipe instances forwarding messages and reading their content, including passwords.The above attack does not work if the attacker only has guest access to the victim's system because the named pipe's security attributes allow only authenticated users to create and access instances. When the browser extension starts up, it uses native messaging to obtain an AccessKey from the NMH, which gets it from the standalone Sticky Password app with the CFMessagePort IPC method. By impersonating the server, the attacker may be able to capture data that the extension sends to the app, including new passwords that the user is attempting to save to the password vault.Another important piece of data that the attacker can obtain with the above attack is the AccessKey. FIDO U2F [23] is an open authentication standard that enables strong two-factor authentication to online services with public-key cryptography and a USB hardware device called security key. The device generates a service-specific key pair and stores it together with a key handle (i.e. identifier) and the origin URL of the service. The user may notice that the first button press had no effect, but such minor glitches are normal in computers and typically ignored.In experiments with FIDO U2F Security Key, our malicious Python client in the background was 100% suc- Figure 5: MitMa attack on DigiSign smart card reader through SCS interface cessful in snatching the first button press and spoofing the second authentication factor to services such as Facebook and GitHub. This attack is not possible in Linux or macOS because they would prevent the malicious background process form accessing the USB device.Another approach to strengthening the security of critical login sessions is the TLS Channel ID [13,21]. Its main user base is healthcare professionals, but all citizens can acquire an electronic identity card for strong authentication to government services.The DigiSign application implements the so-called Signature Creation Service (SCS) interface [34] specified by the Finnish Population Register Centre. The card-reader app with the SCS interface has an HTTP server running on port 53951 and HTTPS server on port 53952 (during installation, the card reader app creates a self-signed certificate for the local HTTPS server and adds it to the trusted certificates). A malicious process could opportunistically send signing requests to the card reader app and hope that the timing is right, or a confused user might enter the PIN by mistake. The solution was to check that the Host header on the incoming HTTP requests is localhost and not something else.We see a deeper problem behind the vulnerability: there is no access control to limit which processes can connect to the update agent, and the implemented solution trusts the client process to provide the correct information (Host header). Moreover, the MitMa attacker can hijack the server port and capture the username and password from the client, before releasing the port and waiting for the legitimate server to start. Spotify, a music streaming service, runs an HTTP server on the localhost port 4381 to accept streaming commands, such as playing a song. The server whitelists clients based on the Origin header in order to allow selected web pages to open in the user's browser to access the HTTP API. After this, the attacker can act as the man in the middle and forward messages between the two pipe instances.The above attack allows the attacker to read all messages between the client and the server and to modify the SQL queries and responses. Keybase [5] is an open-source messaging app with endto-end encryption, which is available for both phones and desktop computers. The app launches a background process that handles all of the application's tasks, such as encrypting and sending messages.On Windows, the client accepts commands from the user and sends them to the Keybase background process over a named pipe. Thus, the background process will not start if the named pipe already exists.To use Keybase on a new device, the user must first sign in to the Keybase background process with his Keybase credential and then approve the new device from a previously registered device. Since the Keybase is open source, the attacker can simply modify the Keybase source code so that the named pipe allows full access from everyone. The goal is to present a taxonomy that brings order to the concepts, rather than to cover all technical details.Spatial and temporal separation of user sessions. The critical trick here to perform the checks both at the server for the client and at the client for the server.JavaScript clients running in a web browser, including browser extensions, pose special challenges for such attack detection. Lessons for more secure user-assisted pairing methods could be learned, for example, from Bluetooth device pairing and other userassisted out-of-band authentication and pairing protocols [12,16,45]. The safe IPC methods (unnamed pipes and socket pairs, see Section 3.4) can still be used between related processes without exposing the applications to MitMa attacks.Such architectural solutions work well when they are a good match for the goals of the application developer. As a further case study, we looked at cloud-storage applications (e.g. Dropbox, SpiderOak, Box), which tend to have a local backend component that is accessed over IPC. Because of such positive examples, our view of the future is not entirely bleak.The well-designed applications set up strict DACLs or permissions to ensure that the IPC channel is accessible only to the authorized user(s) and configure the IPC channel options carefully rather than relying on the default settings. Fully automated vulnerability scanning, however, does not seem possible because the automated tools cannot not evaluate the security of application-level cryptographic protection.In some sense, the idea of protecting the users of a multi-user computer system from each other takes us back to the early days of computer security. The MitMa attacks are one way for a non-privileged process to circumvent isolation boundaries within the computer, and we believe that the observations of this paper will prove useful in the design of application-isolation mechanisms.We have focused on the threat model where the attacker and victim are two nonprivileged users. Li et al. [37], on the other hand, found that password managers suffer from traditional web vulnerabilities (e.g. XSS, CSRF), poor userinterface design, and problems related to poorly understood threat model.