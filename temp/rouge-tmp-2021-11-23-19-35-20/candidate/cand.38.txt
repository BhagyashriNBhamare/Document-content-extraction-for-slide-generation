Thus, a fundamental question remains: What are the consequences and dangers of having a memory corruption vulnerability in enclave code? This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave's SGX crypto keys. The consequences of Dark-ROP are alarming; the attacker can completely breach the enclave's memory pro-tections and trick the SGX hardware into disclosing the enclave's encryption keys and producing measurement reports that defeat remote attestation. This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave's SGX crypto keys.The consequences of Dark-ROP are alarming; the attacker can completely breach the enclave's memory protections and trick the SGX hardware into disclosing the enclave's encryption keys and producing measurement reports that defeat remote attestation. Since SGX prevents all access to enclave code and data from outside the enclave, we cannot directly apply typical ROP attacks.To overcome these challenges, we construct a novel method for finding a vulnerability and useful ROP gadgets in fully encrypted binaries (unknown code) running under SGX. Dark-ROP can chain the gadgets found in this way and utilize them to invoke security-critical functions such as data sealing and generating measurement reports for remote attestation.In addition, we construct a shadow application (i.e., SGX Malware) that runs outside an enclave but fully emulates the environment of an SGX enclave. When a remote server requests a measurement report to check the integrity of the victim enclave, the shadow application first receives the request (as a man-in-the-middle), and then invokes an ROP call that generates the correct measurement report in the victim enclave and sends a reply to the remote party to complete the attestation protocol. Specifically, page miss handler (PMH) [23] checks an access permission of the EPC pages when any software requests read or write access to the enclave memory.In addition, a memory encryption engine (MEE) [11,15] that is a extension of the memory controller encrypts enclave code and data before they are being written to main memory. The purpose of attestation in SGX is twofold: ensuring that an enclave is running an expected program on a certified SGX platform with a correct configuration and securely sharing a secret to build a secure communication channel between an enclave and a remote entity (e.g., the owner of the enclave). That would allow the deployment of encrypted binaries without requiring pages to be both executable and writable.In summary, SGX makes it possible to deploy encrypted binaries, which means that attackers may never be able to see the code running inside the enclave they are Figure 1: ENCLU instruction and its leaf functions. To invoke a leaf function of interest through the ENCLU instruction, an application developer can load the index of the function into the rax register and then execute ENCLU. To call the function in the enclave, the untrusted program can set the rbx register as the address of the Thread Control Structure (TCS), which is a data structure that contains the entry point of the enclave (e.g., the import_data_to_enclave() function in this case) and its argument (i.e., the attack buffer as out_of_enclave_memory) as a pointer of the untrusted memory. To launch the ROP attack on the vulnerability, the attacker can fill the attack buffer to more than the size of the buffer in the enclave, which is 0x100, to overwrite the return address and then build the stack with ROP gadgets and function arguments to control the program execution at the attacker's will.However, the ROP attack against enclaves will not simply work in the typical way because the information for the execution environment as well as the program itself is encrypted, so it is hidden to attackers.Challenge: encrypted binary makes the ROP attack difficult. To successfully exploit the vulnerability and take control of the program, the attacker is required to launch a code reuse attack (if there is no code injection vulnerability) through return-oriented programming (ROP). In other words, the attacker has to find gadgets for their execution and chain them together under the blindness condition.Although a recent work on Blind ROP [7] demonstrates an ROP attack against unknown code, the attack relies critically on properties of certain server applications that are based on the fork() system call, which does not hold for SGX enclaves. Since an enclave program runs as a user-level program, which cannot handle processor exceptions, when it encounters memory corruption (i.e., page fault) on its execution, the enclave gives back the execution to the untrusted operating system to handle the fault. Without having the instruction, the enclave cannot enjoy the features provided by SGX.Second, the code should have the ROP gadgets that consist of one or multiple "pop a register" (i.e., pop rbx) instructions before the return instruction, especially for the rax, rbx, rcx, rdx, rdi, and rsi registers. The reason we require pop gadgets for such registers is that these registers are used for the index of the leaf function (rax), for arguments passing (the other registers) for the leaf function, and a library function in the x86-64 architecture. To this end, we construct three oracles that give the attackers a hint of the binary code to find the useful gadgets: 1) a page-fault-based oracle to find a gadget that can set the general purpose register values; 2) the EEXIT oracle can verify which registers are overwritten by the gadgets found by 1); and 3) the memory oracle that can find the gadget has a memory copy functionality to inject data from untrusted space to the enclave or to exfiltrate the data vice versa. SGX and the enclave application are configured correctly. That is, the application that runs in the enclave is distributed in an encrypted format and removing the loader program after launching the payload, which makes it completely hidden to the attacker, and the application uses data sealing for protecting application data as well as remote attestation to verify the running status of the enclave. The target application is built with a standard compiler (e.g. Visual Studio for SGX, or gcc), with the standard SDK that is supplied by Intel.The threat model of Dark-ROP is pragmatic because it assumes the standard, and secure configuration of SGX for the attack target, as well as assuming only the softwarelevel attacker. For instance, a pop gadget like pop rbx; pop rcx; pop rdx; retq; can change the value of the rbx, rcx, and rdx registers at once if values are set at the attack stack by exploiting a buffer overflow vulnerability.To find such gadgets, we turn the Asynchronous Enclave Exit (AEX) and page fault handler into an oracle for detecting the gadgets. Finally, we put the 0x80000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x80000018 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00Application address space 0xF7500000: 7f 45 4c 46 02 01 01 00 0xF7500008: 00 00 00 00 00 00 00 00 0xF7500010: 03 00 3e 00 01 00 00 00 0xF7500018: d0 ad 00 00 00 00 00 00Enclave address space ④ ② ③ ④ Figure 5: An overview of finding memcpy() gadget. (1) The attacker exploits a memory corruption bug inside the enclave and overwrites the stack with a gadget chain. For the combinations of pop gadget candidates and the address of probing, the enclave will trigger EEXIT if the address of a gadget that changes rax and the address of ENCLU sits on the stack. If the handler is invoked and the value of rax is 0x4, then the return address placed at the end of the attack stack points to the ENCLU instruction.After we find the method to invoke EEXIT, we exploit the EEXIT gadget to identify which registers are popped by the pop gadget. Thus, if we put a pop gadget, and put some distinguishable values as its items to be popped, for instance, 0x1, 0x2, and 0x3, and then run the EEXIT at the end, we can identify the popped registers by the values.For example, if the pop gadget is pop rdi; pop rsi; pop rdx; ret, then at the handler, we can see the value of 0x1 at rdi, value of 0x2 at rsi, value of 0x3 at rdx. Accordingly, we can determine that the gadget pops the rdi, rsi, and rdx registers.By using this oracle, we probe all candidates of pop gadgets until we can control all six registers that are required to launch the Dark-ROP attack.Untrusted memory as a read/write gadget oracle. The probing finishes when we detect any change in the untrusted memory because the change proves that the memory copy is executed.The memcpy() ROP gadget allows attackers to have an arbitrary read/write in both directions in between the enclave and the untrusted memory space because the attacker can set the source and destination addresses arbitrarily at the attack stack. In this section, we demonstrate how the Dark-ROP attack can be applied in the real world to completely disarm the security guarantees of SGX.From the proof-of-concept attack, the attacker can obtain the ability to call any leaf functions of SGX within the enclave to extract the secret data and inject data into the (trusted) enclave space. In addition to calling leaf functions to invoke the security-critical functions of SGX, we present techniques to implement the SGX malware, which can perform the man-in-the-middle (MiTM) attack to mimic the real enclave program for running securitycritical operations within the enclave and to freely run attackers' code outside the enclave without any restrictions.To achieve full control of the enclave, we construct the SGX malware as follows: 1) By using the memcpy() gadget, the attacker can extract any secret data in the enclave, including the program binary and data. This can be achieved by hijacking remote attestation by calling the EREPORT leaf function and constructing the correct measurement data outside the enclave.In the following, we illustrate how we construct the SGX malware with preserving such requirements so that the SGX malware can run at the attacker's discretion while bypassing attack detection using the remote attestation.Extracting the hidden binary/data from the enclave. Next, the SGX malware loads the required parameters of the leaf function at the general purpose registers by using pop gadgets, and then jumps into ENCLU to call the leaf function. The purpose of remote attestation is to ensure the correct settings and running of the enclave before conducting secret operations such as provisioning secrets and establishing a secure communication channel with the enclave in the remote machine.The Intel SGX SDK uses the protocol in Figure 6 for the remote attestation of the enclave and establishing a secure communication channel between the remote server and the enclave. After that, SGX malware launches the Dark-ROP attack (3-1, 3-2 and 3-3) to copy prepared parameters (TARGETINFO and REPORTDATA) from the untrusted app to the enclave and generate REPORT with the ECDH public key that the SGX malware generated at the first step. Additionally, we use the standard Intel SGX SDK and compiler (gcc-5) to compile the code for the enclave for both attacks.To launch the Dark-ROP attack on the real SGX hardware, we use the RemoteAttestation example binary in the Intel SGX SDK, which is a minimal program that only runs the remote attestation protocol, with slight modification, to inject an entry point that has a buffer overflow vulnerability, as mentioned in Figure 2. To show the generality of finding gadgets, we find gadgets from the standard SGX libraries that are essential to run enclave programs such as the library for controlling the enclave (libsgx_trts.a), the library that handles remote attestation protocol (libsgx_tkey_exchange.a), and the standard C library for SGX (libsgx_tstdc.a) because these libraries will be linked regardless of the program logic.From the example binary, we found that four gadgets are enough to fulfill the gadget requirement described in §3 to launch the Dark-ROP attack against the RemoteAttestation example. To set the registers for calling the memcpy function, we chained three gadgets, pop rsi; pop r15; ret and pop rdi; ret to set the destination and source address of memory copy, and pop rdx; pop rcx; pop rbx; ret to set the length of the data to be copied. To call the EGETKEY leaf function, we should call the memcpy() function to copy the KEYREQUEST structure first, set the register arguments for EGETKEY, and then call the memcpy() function again to move the generated key out to the untrusted area. Therefore, if the CFI implementation uses one of the general registers to point to the reference table that defines allowed target blocks, it can be easily bypassed by the attacker's manipulating the context saved in the stack of the trapped thread.Fine-grained ASLR. Town Crier [39] isolates the crypto functions for the smart contract in the enclave. As described in [18,24,30], an enclave binary can be distributed as a cipher text to preserve the confidentiality of the code and data deployed in the enclave.