Current state-of-the-art deobfuscation approaches operate on instruction traces and use a mixed approach of symbolic execution and taint analysis; two techniques that require precise analysis of the underlying code. Code obfuscation can be leveraged in many application domains, for example in software protection solutions to prevent illegal copies, or in malicious software to impede the analysis process. While these protections are not perfect and in fact are broken regularly, attacking them is still a time-consuming task that requires highly specific domain knowledge of the individual Virtual Machine implementation. On the other hand, obfuscated malware stays under the radar for a longer time, until concrete analysis results can be used to effectively defend against it.To deal with this problem, prior research has explored many different approaches to enable deobfuscation of obfuscated code. Instead of manually analyzing the instruction handlers used in virtualization-based (VM) obfuscation schemes in a complex and tedious manner [44] or learning merely the bytecode decoding (not the semantics) of these instruction handlers [53], we aim at learning the semantics of VM-based instruction handlers in an automated way. While there exists a variety of program synthesis approaches [21], we focus on SMT-based and stochastic program synthesis in the following, given its proven applicability to problem domains close to trace simplification and deobfuscation. Then, an SMT solver returns a permutation of the components that forms a well-encoded program following the previously specified intent [22,24], if it is satisfiable, i. e., such a permutation does exist.Instead of relying on a logical specification of program intent, oracle-guided program synthesis uses an inputoutput (I/O) oracle. Finally, to show applicability to areas more focused on security aspects, we further automatically learn the semantics of ROP gadgets.Contributions In summary, we make the following contributions in this paper:• We introduce a generic approach for trace simplification based on program synthesis to obtain the semantics of different kinds of obfuscated code. It is initialized by sequence called VM entry, which handles the context switch from native code to bytecode.After initialization, the VM dispatcher fetches and decodes the next instruction and invokes the corresponding handler function by looking it up in a global handler table (depicted in Figure 1). To exemplify, consider the following Intel x86 code: [ eax ] This might get translated into VM-ISA as follows: It favors many small, simple handlers over fewer more complicated ones.1 mov eax , dword ptr [0 x401000 + ebx * 4] 2 pop dword ptr1 vm_mov T0 , vm_contextBytecode Blinding. An alternative is proposed by Bell with Threaded Code (TC) [4]: He suggests inlining the dispatcher routine into the individual handler functions such that handlers execute in a chained manner, instead of returning to a central dispatcher. In particular, the chained invocation of gadgets is reminiscent of handlers in VM-based obfuscation schemes following the threaded code principle.In addition to its application to exploitation, ROP has seen other fields of applications such as rootkit development [59], software watermarking [34], steganography [33], and code integrity verification [1], which reinforces the importance of automatic ROP chain analysis. Depending on the approach, multiple traces are used for simplification or one single trace is reduced independently.Coogan et al. [13] propose value-based dependence analysis of a trace in order to track the flow of values into system calls using an equational reasoning system. This allows them to reduce the trace to those instructions relevant to the previously mentioned value flow.Graziano et al. [19] mainly apply standard compiler transformations such as dead code elimination or arithmetic simplifications to reduce the trace.Yadegari et al. [62] use bit-level taint analysis to identify instructions relevant to the computation of outputs. The algorithm builds a search tree through reinforcement learning by performing random simulations that estimate the quality of a node [5]. The core algorithm iteratively builds the decision tree in four main steps that are also illustrated in Figure 2: (1) The selection step starts at the root node and successively selects the mostpromising child node, until an expandable leaf (i. e., a non-terminal node that has unvisited children) is reached. Selecting the most-promising child node can be treated as a so called multi-armed bandit problem, in which a gambler tries to maximize the sum of rewards by choosing one out of many slot machines with an unknown probability distribution. It is obtained byX j +C ln n n j ,(1)where X j represents the average reward of the child node j, n the current node's number of visits, n j the visits of the child node and C the exploration constant. For inputs, we apply a read-before-write principle: inputs are only registers/memory locations that are read before they have been written; for outputs, we consider the last writes of a register/memory location as output.Following this principle, the code above has three inputs and two outputs: The inputs are the memory read M 0 in line 1, rcx (line 2) and rdx (line 4). We use Monte Carlo Tree Search, since it has been proven to be very effective when working on infinite decision trees without requiring much domain knowledge.We consider program synthesis as a single-player game whose purpose is to synthesize an expression whose inputoutput behavior is as close as possible to given I/O samples. To evaluate the quality of the new node, we perform a random playout: First, we randomly derive a terminal expression by successively applying random production rules. Working with bit-vectors of size 3 (i. e., modulo 2 3 ), we observe for an expression with two inputs and one output the I/O relations: (2, 2) → 4 and (4, 5) → 1. As described in Section 2.3, the UCT (cf. Equation 1) provides a good balance between exploitation and exploration for many MCTS applications.However, we observed that it does not work for our use case: if we set the exploration constant C to a higher value (focus on exploration), it does not find deeper expressions; if we set C to a lower value, MCTS gets lost in deep expressions. Since the sentential forms represent partial expressions, we will use the term expression to denote the (partial) expression that is represented by a given sentential form. Conversely, the unary operator extract transforms larger data types into smaller data types by extracting the respective least significant bits. If we, in-+ U3 * U2 U1 Figure 6: The left-most U in U 3 U 2 U 1 * + is the topmost-right-most non-terminal in the abstract syntax tree. This maximum playout depth defines how often a non-terminal symbol can be mapped to rules that contain non-terminal symbols; at the latest we reached the maximum, we map non-terminals only to terminal expressions. Assuming a maximum playout depth of 2 and the expression U U * , the first top-most-right-most U is randomly substituted with U U * , the second one with U U +. After that, the remaining non-terminal symbols are randomly replaced with variables: We set terminal nodes to inactive after their evaluation, since they already are end states of the game; there is no possibility to improve the node's reward by random playouts. We describe in the following section how to measure the similarity to the outputs.U U * ⇒ U U U * * ⇒ U U + U U * * ⇒ · · · ⇒ a a + b a * * . Contrary, there exist four parameters that can be configured by a user to improve the effectiveness and speed: the initial SA-UCT value, the number of I/O samples, the maximum number of MCTS iterations and the maximum playout depth.The SA-UCT parameter T configures the trade-off between exploration and exploitation and depends on the maximum number of MCTS iterations; if the maximum number of MCTS iterations is low, the algorithm focuses on exploiting promising candidates within a small period of time. Finally, the MCTS synthesis is more precise since the different node rewards are expected to be informative.Since the search space for finding good algorithm configurations for different complexity classes is large, we approximate an optimal solution by Simulated Annealing. The experiments have been evaluated on a machine with two Intel Xeon E5-2667 CPUs (in total, 12 cores and 24 threads) and 96 GiB of memory. As described in Section 4.7, we approximate an optimal algorithm configuration with Simulated Annealing. We set a timeout of 120 seconds for each synthesis task and prune non-successful tasks by a constant factor of the timeout. By transforming simpler expressions and constants into MBA expressions over Boolean-arithmetic algebras, they can generate semantically-equivalent, but much more complex code which is arguably hard to reverse engineer. With n a positive integer and B = {0, 1}, the algebraic system (B n , ∧, ∨, ⊕, ¬, ≤, ≥, >, <, ≤ s , ≥ s , > s , < s , =, =, s , , , +, −, ·), where , denote left and right shifts, · (or juxtaposition) denotes multiply, and signed compares and arithmetic right shift are indicated by s , is a Boolean-arithmetic algebra (BA-algebra), BA [n]. For example, the rather simple expression x + y + z is transformed into the layer 23 expression (((x ⊕ y) + ((x ∧ y) 1)) ∨ z) + (((x ⊕ y) + ((x ∧ y) 1)) ∧ z) using its arithmetic encoding option. The arithmetic encoding is applied to highlight that our approach is invariant to the code's increased symbolic complexity and is only concerned with semantical complexity.Based on a concrete execution trace it can be observed that the 500 functions use, on average, 5 memory inputs (as parameters are passed on the stack) and one register output (the register containing the return value). Sharif et al. successfully mounted such an attack to recover the CFG of the virtualized function [53], but do not take semantics other than virtual instruction pointer updates into account.We recognize the latter approach as promising and note how Syntia allows us to automatically extract the highlevel semantics of arithmetical and logical instruction handlers. Consequently, if we succeed in recovering the semantics of these integral building blocks, we are at the same time able to recover other variations of native instructions using these handlers as well.This motivates the design of our evaluation program, which aims to have a wide coverage of all possible arithmetic and logical operations. For example, the 449 instruction handlers contain 12 instances performing 8-bit addition, 11 instances for each of addition (for each flavor of 16-, 32-, 64-bit), nor (8-, 64-bit), left and right shift (32-, 64-bit); amongst multiple others. Even though the central handler table lists 1, 111 handlers, we identified 106 unique trace windows along the concrete execution trace.Themida implements a register-based architecture and stores intermediate computations in one of many register available in the VM context. While in the case of VMProtect, inputs and outputs are directly taken from two slots on the stack, Themida has a significantly higher number of potential inputs and outputs (i. e., all virtual registers in the VM context, 10 to 15 in our case). At 1, 092 synthesis tasks, this amounts to roughly 9.1 seconds per task. Our synthesis results include 58 assignments, 17 binary additions, 5 ternary additions, 4 unary minus, 4 binary subtractions, 4 register increments/decrements, 2 binary multiplications and 1 bitwise and. Current research on deobfuscation [13,53,61,62] operates on instruction traces and uses a mixed approach consisting of symbolic execution [61] and taint analysis [60]; two approaches that require a precise analysis of the underlying code. We stress how VM-based obfuscation schemes do this to the extreme: a relatively small number of unique trace windows are used over the whole trace.In general, the synthesis results may not be precise semantics since we approximate them based on I/O samples. By design, their code only produces Intel x86 code.In our case, stochastic techniques have additional properties that are not achieved by previous tools: we obtain partial results that are often already "close" to a real solution and might be helpful for a human analyst who tries to understand obfuscated code. Furthermore, we can encode arbitrary complex function symbols in our grammar (e. g., complex encoding schemes or hash functions); a characteristic that is not easily reproduced by SMT-based approaches.In the context of non-academic work, Rolles applied some of the above mentioned SMT-based approaches to reverse engineering and deobfuscation [45]. Lim and Yoo [32] describe an early exploration on how MCTS can be used for program synthesis and note that it shows comparable performance to genetic programming. However, we demonstrated that a synthesis-based approach allows finetuned simplification, irrespective of syntactical complexity, while producing approximate intermediate results.