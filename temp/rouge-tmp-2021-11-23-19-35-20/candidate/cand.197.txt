Then, we summarize the security goals of Miranda. We consider an anonymous communication system consisting of a set of users communicating over the decryption mix network [12] operating in synchronous batches, denoted as rounds. We denote the result of encoding a message as Pack(path, routingInfo, rnd, recipient, message), where rnd (c) Miranda applies community detection (Section 6) to further detect dishonest nodes and disconnect them from the honest nodes. We allow arbitrary number of malicious clients but assume that there are (also) many honest clients -enough to ensure that any first-mix in a cascade, will receive a 'sufficient' number of messages in most rounds -say, 2ω, where ω is sufficient to ensure reasonable anonymity, for one or few rounds.In addition, Miranda assumes reliable communication between any pair of honest participants, and ignores the time required for computations -hence, also any potential for Miranda-related DoS. In practice, communication failures will occur; see discussion in Section 9 of this and other practical challenges.We denote by n the total number of mixes in the network (|M| = n), n m of which are malicious and n h are honest (n = n m + n h ). As we explain in Subsection 2.2, a practical system deploying Miranda should use a lower-layer protocol to deal with (even severe) packet losses, and we developed such efficient protocol -see [5]. The loop message is encapsulated into the packet format as follows:p K ← Pack(path = C, routingInfo = routing, rnd = H(K S ) recipient = S, message = "loop")The tuple (S, K S , C, routing) acts as the opening value, which allows recomputing p K as well as all its intermediate states p i K that mix M i should receive and emit. To achieve that, if Alice sends β messages in round r, then α·β 1−α additional loop messages are sent alongside the genuine messages.This may seem to only ensure α in the context of the messages that Alice sends but not against an attack on messages sent to Alice. However, notice that if a corrupt mix M i drops messages sent to Alice by an honest sender Bob, then M i faces the same risk of detection -by Bob.If Alice can sample and estimate an upper bound γ on the number of messages that she will receive in a particular round, then she can apply additional defense. Let's assume that Alice knows bound γ on the maximal number of messages from honest senders, that she will receive in round r + x. Then, to detect a mix dropping messages sent to her with probability α, it suffices for Alice to send α·γ 1−α loop messages in round r. In that case, the client can simply choose another witness; in fact, if desired, clients can even send via multiple witnesses concurrently to reduce this risk -the entry mix can easily detect the 'duplicate' and handle only one message. To allow clients to easily confirm that they use the correct set of cascades, the directory authorities collectively sign the setGraph G Graph G (thresh = n m + 1) Graph G M 1 M 2 Detected M 1 M 2 M 1 Detected Remove M 2 Deg(M 1 ) < thresh(= 3) Deg(M 2 ) ≥ thresh(= 3) Remove M 1 Deg(M 1 ) ≥ thresh(= 2)Figure 3: An illustration of the simple malicious mix filtering (without community detection). To achieve this, while preventing the faulty directory authorities from biasing the choice of the seed bits, we can use a cointossing protocol, e.g., [7], among the directory authorities 5 . Encouragingly, many other techniques can be employed; yet, we hope that the following algorithms will be also useful in other applications where applicable, e.g., where community detection is needed.We begin with the following observation.Observation 1. A more sophisticated picking strategy might yield better results; however, when we experimented with some possible strategies, we did not notice a significant improvement over the random picking strategy.The techniques discussed in this section provide Miranda a significant advantage, since malicious mixes can be detected even if they do not pass thresh. A malicious entry mix may drop packets from clients, since losing a link to a client is not a serious 'penalty'; but in Miranda, clients then use a witness mix (see Section 4.4) -forcing the mix to either relay their packets, or -lose a link to a mix or risk discovery, as discussed above.Miranda enforces a minimum number of ω packets for mixing by the entry mix. Attackers can try to maximize their chances by: (1) increasing the probability that fully malicious cascades are included in the set C produced by the directory authorities during the inter-epoch process, and/or (2) increasing the probability that clients pick a fully malicious cascade from C during an epoch. Figure 6 and Figure 7 present the probability of picking a fully malicious cascade depending on the number of mixes colluding with the adversary and the percentage of lost links.Once n c cascades are generated, the adversary could try to bias the probability of clients choosing a fully malicious cascade. For example, if a client did not send packets in round r, then all the packets it is about to receive in round r + x (where x is the number of rounds it takes to complete a loop) are genuine traffic sent by other clients. Therefore, these messages can be dropped without detection.However, dropping of messages by the last mix can also be done against the ideal mix (see Section 2.4), e.g., by a man-in-the-middle attacker. However, if this is the case, then Deg G (M i ) ≥ thresh, which implies Deg G (M i ) ≤ n − thresh ≤ n h − 1, which means that at least one honest mix disconnected from M i , contradicting the assumption that honest links never fail.Claim 8. In order to detect misbehaviors of malicious nodes, the nodes send test messages and verify later via a snapshot from the last mix, whether it was successfully delivered. However, the key assumption of the proposed mechanism is limited only for anonymity among mix peers.Mixmaster [39] and Mixminion [14] employed an infrastructure of pingers [43], special clients sending probe traffic through the different paths in the mix network and recording publicly the observed reliability of delivery. On the other hand, the more 'efficient' proofs restrict the size of messages to a single group element that is too small for email or even instant messaging.An alternative approach for verifying the correctness of the mixing operation were mix-nets with randomized partial checking (RPC) [30]. These include (1) a fixed set of mixes (no churn), (2) a majority of benign mixes (no Sybil), (3) reliable communication and efficient processing (even during DoS), and (4) synchronized clocks. In the beginning, before any reports of faults have arrived at the directory authorities, G is a complete graph and G is an empty graph. For example, the new Loopix [44] mix-network system uses loop cover traffic to detect (n-1) attacks, both for clients and mixes. The increasing number of bombshell stories [27,19,10] regrading mass electronic surveillance and illicit harvesting of personal data against both ordinary citizens and high-ranking officials, resulted in a surge of anonymous and private communication tools. Similarly, Denial-of-Service (DoS) attacks can be used to enhance de-anonymization [9], and (n − 1) attacks allow to track packets over honest mixes [45]. Namely, consider an undirected graph G = (V, E) where the vertices map to the mixes in the system (V = M), and an edge (M i , M j ) ∈ E means that the link between mixes M i and M j was not dropped by either mix. After that, the algorithm invokes the procedure SIMPLEMALICIOUSFILTERING again on the updated G graph, i.e., without the pair of mixes that were virtually removed by the VIRTUALPAIRREMOVAL procedure. Since the algorithm runs in a loop, when the algorithm will re-check G 2 , it will discover that µ 2 = 2 and thus Deg G (M 2 ) = 2 > 1 = n m − µ 1 , which results in removal of M 2 . Therefore, the delaying attack also causes the mix to either lose a link or to be expelled from the system.The combination of packet receipts, link disconnection notices, the isolation process and loop messages, forces malicious mixes to immediately lose links when they perform active attacks. However, although the honest mix drops the packet, it still sends back a receipt for that packet. Hence, even if the mix would know the identity of the sender, e.g., by being the first mix, the packet can still be a loop message with probability at least α.Note that a malicious non-last mix that drops a loop message, yet sends a receipt for it and remains connected to the next mix, would be proven malicious and excluded from the network. The input to this protocol, for each directory authority, includes the set of mixes M, the desired number of cascades to be generated n c , the length of cascades and the set of faulty links F L ⊂ M × M. For simplicity, M, n c and are fixed throughout the execution.The goal of all directory authorities is to select the same set of cascades C ⊆ M , where C is uniformly chosen from all sets of cascades of length , limited to those which satisfy the selected legitimate cascade predicates, which define a set of constraints for building a cascade. The inter-epoch process selects a new random set of cascades to be used in the coming epoch, avoiding the links reported by the mixes, as well as any mixes detected as corrupt.Until the inter-epoch terminates and the mixes move to the new epoch, the mixes continue with the intra-epoch process as before; the only difference is that newly detected failures, would be 'buffered' and handled only in the following run of the inter-epoch process, to avoid changing the inputs to the inter-epoch process after it has begun.The inter-epoch process consists of the following steps. Miranda uses both the detection of corrupt mixes, as well as detection of faults related to a pair of mixes, without detection of the faulty one among the two. Epochs are used to manage Miranda; the beginning of each epoch includes announcement of the set of cascades to be used in this epoch, after a selection process that involves avoidance of mixes detected as corrupt -and of links between two mixes, where one or both of the mixes reported a problem.The process of selecting the set of cascades for each epoch, is called the inter-epoch process, and is performed by a set of d servers refered to as directory authorities, following [14], which maintain a list of available mixes and links between them. Loose bound cascade length 3 4 5 6Figure 6: The maximum probability of picking a fully malicious cascade as a function of the cascade length and the power of the adversary.However, senders report these (rare) under-ω receipts to the directories, who would quickly detect that this mix is corrupt. More precisely, although the communication is over cascades that might contain malicious mixes, the Miranda design aims to provide protection which is indistinguishable from the protection provided by an 'ideal mix', i.e., a single mix node which is known to be honest.The key goals of Miranda relate to alleviating and discouraging active attacks on mix networks, as they have a significant impact on the anonymity through traffic analysis. The architectural building blocks behind Miranda have been studied by previous research, but we combine them with a novel approach which takes advantage of detecting failure of inter-mix links, used to isolate and disconnect corrupt mixes, in addition to direct detection of corrupt mixes. If a loop message did not complete the loop because a malicious mix dropped it and did not send a receipt back, the honest preceding mix would have already disconnected from the misbehaving mix. As discussed in Section 4, a malicious mix that drops a packet sent from a preceding mix or destined to a subsequent mix, loses at least one link; in some cases, the malicious mix gets completely excluded. However, other packet formats can be used, as long as they fulfill certain properties. Our results support the findings of previous works on statistical disclosure attacks [4] and DoS-based attacks [9], arguing that the traffic analysis advantage gained from dropping messages is significant. Otherwise, if malicious mixes do not cooperate with the directory authority, it excludes those mixes from the system.We note that a malicious client may trick the directory authorities into performing the isolation process on its behalf repeatedly, against honest mixes. For simplicity, we denote a receipt for a single packet p as receipt ← Sign(p || receivedFlag = 1), where Sign(·) is a secure digital signature algorithm, and Verify(·) is its matching verification function 3 . The mere threat of loop messages forces malicious mixes to drop a link with an honest mix for each message they wish to suppress, or risk exposure. However, we find it useful to maintain thresh as a separate value, to allow the use of larger value for thresh to account for a number of failures of honest mixes or links between honest mixes, when the Miranda design is adopted by a practical system.Significant, although not prohibitive, processing and communication is involved in the inter-epoch process; this motivates the use of longer epochs. See [34]. Miranda rather than focusing on a single mix, looks at the link between the mixes.In the extended reputation system proposed in [22] the reputation score is quantified by decrementing the reputation of all nodes in the failed cascade and incrementing of all nodes in the successful one. Therefore, an execution of theM 2 M 3 M 4 M 5 M 6 M 7 M 8 M 9Detected Detected (e) If M 2 and M 3 were not detected as malicious as explained in (b), then after the removal of M 1 in (c) they will be detected, because the removal of M 1 causes n m = 4 → n m = 3. After receiving a packet, the mix decodes a successive layer of encoding and verifies the validity of the expected round r and well-formedness of the packet. Therefore, if a loop message fails to complete the loop back to the sender as expected, the client initiates an isolation process, during which it detects and isolates the specific problematic node or link in the cascade. Algorithm 2 CommunityDetection(G = (V, E)) 1: n m ← n m 2: while E = ∅ do 3: for each M i ∈ V s.t. Deg G (M i ) > 1 do 4:Construct G i = (V i , E i ) from G. µ i ← 0 6:while E i = ∅ do 7:Invoke VIRTUALPAIRREMOVAL(G i ).8:µ i ← µ i + 1 9: if Deg G (M i ) > n m − µ i then 10:M i is malicious (remove from G, G, M). We believe that future work may deal with this significant challenge by both minimizing failures, by designing robust underlying mechanisms such as highly-resilient transport layer; and refined assumptions and analysis, e.g., considering incentives and game-theory analysis, to ensure that the system is robust to 'reasonable' levels of failures.These issues are significant challenges for future research, essential towards the implementation of Miranda in practical systems. A sequence {G j } µ j=0 of subgraphs of G 0 is a removal sequence of length µ ≥ 1 of G 0 , if for every j : µ ≥ j ≥ 1, G j = G j−1 − v j . In particular, we assume that the adversary cannot arbitrarily drop packets b