The openness of npm has enabled its growth, providing packages for any situation imaginable, ranging from small utility packages to complex web server frameworks and user interface libraries.Perhaps unsurprisingly, npm's openness comes with security risks, as evidenced by several recent incidents that broke or attacked software running on millions of computers. We show that about 140 of such maintainers (out of a total of more than 150,000) could halve the risk imposed by compromised maintainers. The version constraint either gives a specific version, i.e., the dependency is locked, or specifies a range of compatible versions, e.g., newer than version X. Each time an npm package is installed, all its dependencies are resolved to a specific version, which is automatically downloaded and installed. Often they choose the later, which leads to a technical lag [12] between the latest available version of a package and the one used by dependents.Heavy Reuse Recent work [11,18] provides preliminary evidence that code reuse in npm differs significantly from other ecosystems. This excessive fragmentation of the npm codebase can thus lead to very high number of dependencies.No Privilege Separation In contrast to, e.g., the Java security model in which a SecurityManager 3 can restrict the access to sensitive APIs, JavaScript does not provide any kind of privilege separation between code loaded from different packages. Instead, known vulnerabilities are mostly reported by individuals, who find them through manual analysis or in recent research work, e.g., injection vulnerabilities [30], regular expression denial of service [9,29], path traversals [16], binding layer bugs [6]. The following discusses threat models that either correspond to attacks that have already occurred or that we consider to be possible in the future.Malicious Packages (TM-mal) Adversaries may publish packages containing malicious code on npm and hence trick other users into installing or depending on such packages. Strongly related to malicious packages are packages that violate the user's privacy by sending usage data to third parties, e.g., insight 5 or analytics-node 6 . Even though the creators of these packages clearly document the tracking functionality, transitive dependents may not be aware that one of their dependencies deploys tracking code.Exploiting Unmaintained Legacy Code (TM-leg) As with any larger code base, npm contains vulnerable code, some of which is documented in public vulnerability databases such as npm security advisories 7 or Snyk vulnerability DB 8 . Previous work shows that typosquatting attacks are easy to deploy and effective in practice [31]. While we are not aware of how the account was hijacked in this case, there are various paths toward account takeover, e.g., weak passwords, social engineering, reuse of compromised passwords, and data breaches on npm.Collusion Attack (TM-coll) The above scenarios all assume a single point of failure. Definition 3.1 Let t be a specific point in time, P t be a set of npm package names, and E t = {(p i , p j )|p i = p j ∈ P t } a set of directed edges between packages, where p i has a regular dependency on p j . We call G t = (P t , E t ) the npm dependency graph at a given time t.We denote the universe of all packages ever published on npm with P . Definition 3.2 For every p ∈ P t , the set of maintainers M(p) contains all users that have publishing rights for p.Note that a specific user may appear as the maintainer of multiple packages and that the union of all maintainers in the ecosystem is denoted with M . Definition 3.3 We say that a given package p ∈ P is vulnerable at a moment t if there exists a public advisory for that package and if no patch was released for the described vulnerability at an earlier moment t < t.We denote the set of vulnerable packages with V ⊂ P . We extract the data from the publicly available npm advisories 10 .10 https://www.npmjs.com/advisories We introduce a set of metrics for studying the risk of attacks on the npm ecosystem. To address this, we also consider the average package reach:PR t = ∑ ∀p∈P t |PR(p)| |P t |(1)Using the bounds discussed before for PR(p), we can calculate the ones for its average 0 ≤ PR t < |P t |. The inverse of package reach is a metric to quantify how many packages are implicitly trusted when installing a particular package.Definition 3.5 For every p ∈ P t , the set of implicitly trusted packages ITP(p) contains all the packages p i for which p ∈ PR(p i ). Vulnerabilities For reasoning about TM-leg, we need to estimate how much of the ecosystem depends on vulnerable code: Definition 3.9 Given all vulnerable packages p i ∈ V t at time t, we define the reach of vulnerable code at time t asVR t = ∪ p i ∈V t PR(p i ). In these conditions, the speed at which vulnerabilities are reported is an important factor to consider: Definition 3.10 Given all vulnerable packages p i ∈ V t at time t, we define the vulnerability reporting rate VRR t at time t as VRR t = |V t | |P t | . However, the availability of many packages may also cause developers to depend on more and more third-party code, which increases the attack surface for TM-pkg by giving individual packages the ability to impact the security of many other packages. When using the package, calls into third-party modules may execute any of the code shipped with the depended upon packages.When installing an average npm package, a user implicitly trusts around 80 other packages due to transitive dependencies.One can observe in Figure 3 a chilling effect on the number of dependencies around the year 2016 which will become more apparent in the following graphs. The graph at the bottom shows the package reach of the top-5 packages (top in terms of their package reach, as of 2018). For example, the red line shows that in 2018, about 24,500 packages have reached at least 10 other packages, whereas only about 9,500 packages were so influential in 2015. Variants of the event-stream attack could easily be repeated with other packages.In order to perform a similar analysis for the eslint-scope security incident, we need to use a slightly modified version of package reach. Therefore the modified version of package reach considers both transitive regular dependencies and direct dev dependencies.We observe that eslint-scope has a modified reach of more than 100,000 packages at the last observation point in the data set. Hence, the discussion that follows, about the security risks associated with maintainers, should be considered a lower bound for the overall attack surface.Attacks corresponding to TM-acc in which maintainers are targeted are not purely hypothetical as the infamous eslintscope incident discussed earlier shows. This is not unexpected, since multiple people are involved in developing the most popular packages, while for the majority of new packages there is only one developer.Next, we study in more detail the evolution of the number of packages a maintainer controls. We further analyze five different maintainers in top 20 according to number of packages and plot the evolution of their package count over the years in Figure 7. If an attacker manages to compromise the account of any of the 391 most influential maintainers, the community will experience a serious security incident, reaching twice as many packages as in the eventstream attack.391 highly influential maintainers affect more than 10,000 packages, making them prime targets for attacks. This is a sign of a healthy security community that reports vulnerabilities at a very good pace, keeping up with the growth of the ecosystem.When analyzing the type of reported vulnerabilities in details, we observe that almost half of the advisories come from two large-scale campaigns and not a broader community effort: First, there are 141 advisories published in January 2017 involving npm packages that download resources over HTTP, instead of HTTPs. Nevertheless, this shows the feasibility of large-scale vulnerability detection and reporting on npm.Publishing an advisory helps raise awareness of a security problem in an npm package, but in order to keep the users secure, there needs to be a patch available for a given advisory. When manually inspecting some of the unpatched advisories we notice that a large percentage of unpatched vulnerabilities are actually advisories against malicious typosquatting packages for which no fix can be available.To better understand the real impact of the unpatched vulnerabilities we analyze how much of the ecosystem they impact, i.e., vulnerability reach as introduced in Section 3.2. Similar to other ecosystems, such as mobile app stores, whenever a new release of a vetted package is published, npm could analyze its code. Orthogonal to automated code analysis tools, the npm community could establish crowd-sourced package vetting, e.g., in a hierarchically organized code distribution model similar to the Debian ecosystem.Another challenge for code vetting is that npm packages, in contrast to apps in mobile app stores, are used across different platforms with different security models. While some of this work studies the npm ecosystem, to the best of our knowledge, we are the first to analyze in depth the role maintainers play in the ecosystem and the impact of different types of attacks, as well as the potential impact of vetting code.Server-side JavaScript Security There are many studies that investigate problems with dependency management for the JavaScript or other ecosystems. Similarly, Decan et al. [11] analyze three package ecosystems, including npm, and evaluate whether dependency constraints and semantic versioning are effective measures for avoiding breaking changes. Brown et al. [6] discuss bugs in the binding layers of both server-side and client-side JavaScript platforms, while Wang et al. [33] analyze concurrency bugs in Node.js Finally, Gong [16] presents a dynamic analysis system for identifying vulnerable and malicious code in npm. They conclude that nine in ten websites leak data to third-parties and that six in ten spwan third-party cookies.Studies of Software Ecosystems Software ecosystem research has been rapidly growing in the last year. Serebrenik et al. [28] perform a meta-analysis of the difficult tasks in software ecosystem research and identify six types of challenges. For example, how to scale the analysis to the massive amount of data, how to research the quality and evolution of the ecosystem and how to dedicate more attention to comparative studies. A similar study that includes the JavaScript ecosystem by Kikas et al. [18] collects data until May 2016 and focuses on the evolution of dependencies and the vulnerability of the dependency network. The security risk are "high" in the sense that vulnerable or malicious code in a single package may affect thousands of others, and that a single misbehaving maintainer, e.g., due to a compromised account, may have a huge negative impact.