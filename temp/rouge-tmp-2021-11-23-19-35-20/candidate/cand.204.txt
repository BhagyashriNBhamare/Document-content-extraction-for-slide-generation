As users have on average 80 apps installed on their phones, 4 most of them being free, there is a high chance of untrusted third-parties obtaining the list of installed apps.Since 2015, Android has classified as potentially harmful apps (PHA) 5 the apps that collect information about other apps without user consent [1]. We go beyond their work, however, by systematically investigating all possible information leaks that nosy apps can exploit to fingerprint other apps and by performing a dynamic analysis and privacy-policy analysis.Existing mechanisms for preventing apps from learning about the presence of another app are not sufficient (Section 6). More importantly, even with 50 queries, a nosy app can still check if a specific app or small set of apps are installed on the phone.A possibly better approach is for Android to include a new "sensitive" flag that enables users to hide sensitive apps from other apps in the same phone, i.e., other apps will not be able to use Android API methods to infer the existence of apps flagged as sensitive. Our analysis focuses on API calls that directly retrieve the list of installed apps (hereafter called LIA): getIA() and getIP(), because these two methods clearly show the intent of developers to learn about other apps, whereas the other methods presented in Section 4 can be used in valid use cases. This might be because developers copy the privacy policies from other apps, or because the apps will make these calls in the future.Besides the generic declared purposes of the collections of LIAs by apps, e.g., for improving the service (e.g., [14,21]), some apps explicitly state that they collect LIAs for targeted ads (e.g., [3,12]), and targeted ads by third-party ad networks (e.g., [15]). For instance, a sensitive app will not have access to a user's calendar or contacts (unless the user replicates them on each account) or access to other apps for certain tasks, e.g., sending a message or picture via Whatsapp or Facebook, accessing files in Dropbox, sending an e-mail or SMS, and authenticating users with Google or Facebook accounts. Another important problem is that some popular phone manufacturers (e.g., Samsung, LG, Huawei, Asus) disable multiple users in some of their devices, 20 thus affecting the availability of this solution to many users.We have also found experimentally that the implementation of multiple users in the latest (Android 9) and earlier versions of Android does not effectively prevent nosy apps from learning what other apps are installed in different user accounts. • On Android 9 or earlier, a nosy app can use multiple PackageManager methods, such as getPackageUid(), getPackageGidS(), checkPermission(), checkSignatures(), or getApplicationEnabledSetting(), as oracles to check if an app is installed on a secondary account or on a work profile. Such an approach could be used to hide sensitive apps, however, it only supports a limited subset of permissions, and it does not support features that are crucial for mHealth apps such as storing users' data or connecting to Bluetooth-enabled devices. To allow the HMA Manager app to install apps downloaded from the HMA App Store, similarly to other Google Play Store alternatives e.g., Amazon 25 and F-Droid [9], users need to enable the "allow apps from unknown sources" setting on their phones. In Section 9, we discuss mechanisms for preventing more advanced fingerprinting attacks by malicious apps; a malicious app has more capabilities than a nosy app, i.e., it can have special permissions (e.g., PACKAGE_USAGE_STATS or BIND_ACCESSIBILITY_SERVICE) and the debugging privilege (adb), thus it can perform more advanced attacks, such as fingerprinting apps using their runtime information.We assume that apps belonging to hospitals are nosy, i.e., these apps are also curious about what other apps are installed on the user's device. This set of generic names is shared by all sensitive apps, thus there is no one-to-one mapping between a sensitive app and a generic name or a subset of generic names. To launch the APK of a sensitive app without installing it, its container app generates a randomly named child-process in which the APK will run, i.e., the APK is executed under the same UID as its container app. To prevent fingerprinting attacks based on the number of components declared in the container app, the HMA App Store adds dummy random components during the generation of the container app such that all the container apps declare the same number of components.A nosy app might try to fingerprint sensitive apps by using the sets of permissions declared by their container apps. To prevent an app with VPN capabilities from fingerprinting sensitive apps based on the IP addresses in the header of the IP packages, the sensitive apps can relay their traffic through the HMA App Store servers; this protection is provided at the cost of additional communication delays for the apps and it requires collaboration with app developers.A malicious app cannot fingerprint a sensitive app by using the list of running processes, because the sensitive app runs inside the child process of its container app with a random name. To pre-vent nosy apps from fingerprinting sensitive apps by using their UI states, the container apps can also obfuscate the UI states by overlaying transparent frames on the real screens of the sensitive apps. Also, the malicious app cannot retrieve the APK files of the sensitive apps, because the APKs are stored inside the private directories of their container apps.To prevent advanced attacks by malicious apps, e.g., fingerprinting sensitive apps by reading the log of the phone, HMA requires collaboration from app developers. Next, we launched all the runnable activities declared by the app for 10 minutes.Although this approach has limitations, as it only has a short period of time per app and it cannot emulate all the activities a user could do, it is sufficient to estimate a lower-bound on the number of apps that query for LIAs at runtime, as shown in our results.Our results, shown in Table 2, show that 190 apps (6.54%) called getIA(), 436 apps (15.0%) called getIP(), and 19.2% of the apps called at least one of these two methods. In future work, we will explore mechanisms for enabling container apps to verify the signatures of sensitive apps at runtime, in order to prevent unauthorized access to signature-protected components of their sensitive apps.HMA container apps prompt users only for permissions requested by sensitive apps. Therefore, assuming that the metadata of the network and the lower communication layers cannot be used to identify users, e.g., by using a proxy or Tor, the HMA App Store cannot link a set of sensitive apps to a user. For a baseline, we measured the delays when the mHealth apps were executed without HMA.To measure warm-start delays, due to the lack of Android supports for profiling warm starts, we have to instrument the source code of the sensitive apps to log the time that the app enters different stages in its lifecycle. Also, these apps support features that are crucial for mHealth apps, e.g., a Bluetooth connection with external medical devices (e.g., Beurer HealthManager app [4]) and an internet connection (e.g., Cancer.Net app [5]). From a high-level point of view, HMA achieves its aforementioned design goals by enabling its users to install a container app for each sensitive app (as illustrated in Fig. 1). A malicious app might try to fingerprint sensitive apps based on, for instance, the runtime information produced by their container apps. Following the approach used in previous work, (e.g., [35] and [53]), we manually tested each app in our dataset with HMA. Users employ a client app called HMA Manager to anonymously (un)install, use, and to update the apps selected from the HMA app store; an the HMA App Store does not learn about the set of apps that a user has installed from the store. Moreover, we are the first to identify the security and functional limitations of using app virtualization for the purpose of hiding apps.Our evaluation of HMA on a diverse set of both free and paid mHealth apps on the Google Play Store shows that HMA is practical, and that it introduces reasonable operational delays to the users. • The HMA App Store creates an empty app with a generic app icon, a random package name and label, and it imports into the app the lib and the code for the user-level virtualization, i.e., to launch the APK from the container app. For each mHealth app, we extracted its APK, created a container app using HMA App Store, and installed the container app on the phone. 14 API calls can be located in three parts of the decompiled code: in the code of Android/Google libs and SDKs, in the code of third-party libs and SDKs, or in the code of the app itself. Any app can execute shell commands; however, depending on its privilege, i.e., default app privilege, debugging (adb) 10 or root, the outputs of the same shell commands are different.Android Apps and APK Files. Zhou et al. [55] show thatAndroid's open design has made publicly available a number of seemingly innocuous phone resources, including the list of installed apps; these resources could be used to infer sensitive information about their users, e.g., users' gender and religion [40,46]. To relax the trust assumptions on the HMA App Store and HMA Manager, the HMA App Store can provide an API so that anyone can implement her own HMA Manager app, or the HMA Manager app can be opensource, i.e., anyone can audit the app and check if it follows the protocols as prescribed. The rest of the apps are less related to HMA's use case, e.g., apps for medical doctors and nurses, apps for managing accounts with health providers, and apps for managing gym subscriptions. To do so, HMA requires the hospitals to bootstrap the system by setting up the HMA App Store and distributing the HMA Manager app to users (Section 8.1 and 8.2). This, however, can be solved by using the direct share targets feature in Android -a feature that enable apps to show finer-grained internal content in the chooser dialog window. Here, we present an analysis of HMA to show that it effectively achieves its privacy and security goals w.r.t. different capabilities of the nosy apps (i.e., their granted permissions and privileges) as shown in Table 1. Note that such organizations and their own app stores already exist, e.g., the VA App Store set up by the U.S. Department of Veterans Affairs.To enable the users to manage the apps provided by the HMA App Store, the HMA App Store provides the users with a client app called HMA Manager. However, it is needed to prevent the sensitive app from being fingerprinted: If the sensitive APK was included in the resources or assets folders of its container app so that the container app could copy and store the APK in its private directory at installation time, a nosy app would be able to obtain the sensitive APK. To provide unlinkability between users and their sensitive apps w.r.t. the HMA App Store, the HMA Manager app never sends any identifying information of the users to the HMA App Store, and all the communications between the HMA App Store and the HMA Manager are anonymous. Still, this represents only a small number of the apps found through our analysis.Our static and dynamic analysis shows that a significant number of free apps actively queries for LIAs: between 19.2% (dynamic analysis) and 57% (static analysis) of the tested apps. But, there are two apps (Mole Mapper and Alzheimer's Speed of Processing Game) that initially failed to run on our Nexus 5X (Android 7.1.1) due to the incompatibility between 32-bit and 64-bit systems. The notations +, and indicate the resources that our system (HMA, see Section 8) can protect by default, by collaborating with app developers or by randomizing runtime information of the container apps, respectively. Table 2: Proportion of free apps that invoke getIA() and getIP(), to collect LIAs w.r.t. different call origins. To mitigate app-fingerprinting attacks, Android could follow an approach similar to iOS, i.e., to remove or restrict API methods and OS resources that leak identifying information of apps. For instance, the PACKAGE_USAGE_STATS permission permits an app to obtain the list of running processes (method getRunningAppProcesses()), and statistics about network and storage consumption of all installed apps, including their package names, during a time interval (method queryUsageStats()). 26 For each sensitive app, the HMA App Store can generate beforehand P container apps corresponding to P predefined generic package names and store them in its database. By using a diverse dataset of both free and paid mHealth apps, our experimental evaluation shows that HMA supports the main functionalities in most apps and introduces acceptable overheads at runtime (i.e., several milliseconds); these findings were validated by our user-study (N = 30). Still, HMA preserves the key functionalities of mHealth apps, e.g., connecting to external devices via Bluetooth, sending information over the Internet, and storing information in databases.With HMA, users launch a sensitive app inside the context of a container app, without requiring the sensitive app to be installed. Also, the HMA Manager saves, in its private directory, a record of the package name of the container app and the package name, the original icon and the label of the sensitive app.App Launch. Permissions defined by apps to control access to their components can be used to fingerprint them (e.g., they typically include the app name), as any app can list the permissions of other apps. An app can also infer the UI states (e.g., knowing that another app is showing a login screen) [26], memory footprints (sequences of snapshots of the app's data resident size) [36] and power consumption [27] of other apps. With special permissions, an app can obtain certain identifying information about other apps at their runtime. It is also unclear if such an approach will be able to prevent more subtle attacks, where a nosy app checks for the existence of a specific app or a small set of sensitive apps by using more advanced fingerprinting techniques (Section 4). Android's source code shows that these methods check the user ID of the app calling the method to show only information of apps in the same user profile, but our experimental evaluation shows that currently deployed versions of Android do not enforce such checks. • A nosy app can guess the UIDs of the apps installed on all the accounts and work profiles, by looking at the /proc/uid directory to learn the ranges of current UIDs in the system. Such information can be obtained through a number of methods in Table 1: Identifying information about installed apps that an app can learn, w.r.t. its permissions and privileges, through the Java API framework and the Linux-layer kernel. 1 For instance, more than a third of physicians in the US recommend mHealth apps to their patients [23], and there are around 325,000 mHealth apps available in major mobile app stores. 19 This feature could be used to prevent fingerprinting of sensitive apps by installing sensitive apps in one or more secondary accounts, thus isolating sensitive apps from nosy apps. Similarly to the case of other runtime statistics discussed above, the container apps can also randomly generate dummy data to obfuscate the memory footprints and power consumptions of the sensitive apps.Malicious Apps with the Debugging Privilege (adb). Second, the resources, shared libraries, developers' signatures and developers' signing certificates of the sensitive app cannot be learnt by the nosy app, because they are not declared or included in the container-app's APK; instead they are dynamically loaded from the sensitive APK at runtime. Nevertheless, this solution is device specific and only hides apps from other apps in a different isolated environment, but not from apps in the same environment (apps in the same isolated environment can come from different, untrusted sources). First, a nosy app cannot obtain the package name of a sensitive app, because the sensitive app is never registered on the system; instead, its container app with a generic package name is installed. Therefore, the user can easily identify and select her sensitive apps.The first time a container app runs, it needs to obtain the sensitive APK from the HMA App Store; then it stores the APK in its private directory. From the list of 20 apps that we filtered out, we found that 3 apps (Hearing Aid, What's Up and Cardiac diagnosis) 