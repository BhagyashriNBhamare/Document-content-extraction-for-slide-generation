For the first time in the literature, we introduce a novel attack against SDN networks that can cause serious security and reliability risks by exploiting harmful race conditions in the SDN controllers, similar in spirit to classic TOCTTOU (Time of Check to Time of Use) attacks against file systems. However, referencing network states is under the risk of introducing concurrency vulnerabilities because external network events can concurrently update the internal network states.In this paper, we present a new attack, namely state manipulation attack, in the SDN control plane that is rooted in the asynchronism of SDN. The asynchronism leads to many harmful race conditions on the shared network states, which can be exploited by the attackers to cause denial of services (e.g., controller crash, core service disruption) and privacy leakage, etc. If the operation at line 4 is executed before that at line 8, it will trigger a Null-Pointer Exception (NPE) when the null switch object is dereferenced at line 9, which leads to the crash of the thread and eventually causes Denial-ofService (DoS) attacks on the controller.The root cause of this vulnerability is a logic flaw in the implementation of Floodlight that permits a harmful race condition. The key insight of State Manipulation Attack is that we can leverage the existence of such harmful race conditions in SDN controllers to trigger inconsistent network states. • Second, how to trigger the harmful race conditions by an external attacker who has no control of the controller schedule?For the first problem, the key challenges are that it is generally unknown if a race condition is harmful or not, and that detecting race conditions in a program is generally undecidable. Therefore, conventional data race detectors are inadequate to find race conditions in SDN controllers.To address this problem, we develop a technique called adversarial state racing to detect harmful race conditions in the SDN control plane. An adversary can then generate many sequences of these network events repeatedly to increase the chance of hitting a right schedule to trigger the harmful race condition.We have designed and implemented a framework called CONGUARD for exploiting concurrency vulnerabilities in the SDN control plane, and we have evaluated it on three mainstream open-source SDN controllersFloodlight, ONOS, and OpenDaylight, with 34 applications in total. By the time of writing, we have already assisted the developers to patch 12 of them.The rest of the paper is organized as follows: Section 2 introduces background. In this section, we introduce the necessary background of SDN in order to understand the harmful race conditions in this domain.The heart of SDN is a logically centralized control plane (i.e., SDN controllers) that is separated from the data plane (i.e., SDN switches). It will update its managed network states when it receives corresponding network events.Also, some applications, namely service applications, in the SDN control plane paraphrase external network events (i.e., OpenFlow messages) to its own internal network events and dispatch them to other applications' event handlers. We then discuss two vulnerabilities related to harmful race conditions that we discovered in existing SDN controllers, and we show how an attacker can exploit them to steal privacy information and disrupt important services of SDN networks. That is, we consider operating systems of SDN controllers and switches are well protected from the adversary, and the control channels between SDN controllers and SDN switches, as well as administrative management channels between administrators and SDN controllers, e.g., REST APIs, can be properly protected by SSL/TLS, which is particularly important when the SDN network is configured to use in-band control messages. Even control messages are well protected by SSL/TLS, the attacker could still find important communication information (e.g., TCP header fields and types of control messages) between an SDN controller and switches by utilizing legacy techniques such as TCP/IP header analysis, size-based classification (given fixed size of control messages), etc. We found a harmful race condition in this application, i.e., a concurrent SWITCH_LEAVE event from any switch along the routing path can trigger an internal exception of the Floodlight controller and further violate the policy enforcement from step 3 to step 4 . However, due to a harmful race condition, a conflicting HOST_LEAVE event can manipulate the internal state of the host, which may result in an unexpected exception and further disrupt the packet processing service when the DHCPRelay application relays DHCP response/offer messages to the sender, as illustrated in Figure 5. CONGUARD contains two main phases: (i) locating harmful race conditions in the controller source code by utilizing dynamic analysis and adversarial state racing, (ii) triggering harmful race conditions in the running SDN controller by remotely injecting right external network events with the proper timing. Then, for each pair of such operations, we re-run the SDN controller but force it to follow an erroneous schedule to check if a race condition is harmful or not.In this step, there are two major challenges:• First, how to avoid reporting a myriad of race warnings that are in fact false alarms? For example, in Figure 1, without reasoning the causality order between line 3 and line 5 for the internal event dispatching, the state update operation at line 1 and state reference at line 10 will be reported as a false positive. Different from general multi-thread programs, there are a number of distinct types of operations and domain-specific causality rules in the SDN control plane.Execution Trace: First, we model an execution of the SDN control plane as a sequence of operations as listed following:• read(T,V): reads variable V in thread T.• write(T,V): writes variable V in thread T.• init(A): initializes the functions of application A in the SDN control plane. • end(TA): terminates a singleton task TA.Happens-Before Causality: In this paper, we utilize happens-before relations [28] to model the concurrency semantics of the SDN controller. app id = A.app id α ≺ β α.app id = A.app id β ∈ terminate(A) α ≺ β Event Dispatching α ∈ dispatch(E) β ∈ receive(H, E) α ≺ β Sequential Event Handling α = receive(H 1 , E) β = receive(H 2 , E) α < τ β α ≺ β Switch Event Dispatching α = receive(H, E 1 ) β = dispatch(E 2 ) E 1 . reason = OFPPR_DELETE α ≺ β Explicit Link Down and Host Leave α = (H, E 1 ) β = dispatch(E 2 ) E 1 . The SDN control plane monitors OFP_PORT_STATUS OpenFlow messages to detect the addition and deletion of switch ports in the data plane. Removing such redundant events significantly improves the efficiency of race condition detection.We note that standard vector-clock based techniques [19] for computing happens-before relation is difficult to scale to the SDN domain, which typically contains a large number of network events and threads. In addition to utilizing the waypoint to ensure execution context, we also add four atomic control points (P1, P2, P3, and P4) and one flag (F1) to enforce the deterministic scheduling between the state reference operation and the state update operation with consistent runtime information. To launch the attack, an adversary, who has no control of the SDN controller except sending external network events, first needs to figure out what external events to trigger a harmful race condition. For example, a schedule in which the update on the switch state happens before the dereference. In contrast, for observer-based scheme, we log the invocations of event handler functions with the context of application name as receive operations upon the event.We track schedule and end task operations by monitoring the life-cycle of run() method for singleton tasks. For all the three controllers, the offline analysis was able to finish in less than two minutes.To evaluate the effectiveness of the SDN domainspecific happens-before rules, we compared the following two configurations on running race detection of CONGUARD with Floodlight version 1.1: (1) enforces only thread-based happens-before rules; (2) enforces both thread-based and SDN-specific rules. We use Cbench to generate a sequence of OFP_PACKET_IN events and test the delay. Although apparently 8X-30X latency is not small, we note that our tool is for offline bug/vulnerability finding purpose in the development and testing phase instead of online use in the actual operation phase. The connection disruption is a serious issue in SDN domain since: (1) by default, the victim switch may downgrade to traditional Non-OpenFlow enabled switch and then traffic can go through it without controller's inspection; (2) an SDN controller may send instructions to clear the flow table of the victim switch when the controller recognizes a connection attempt from the switch 5 . We also found several bugs that could interrupt the enforcement of services inside the SDN control plane, which may lead to serious logic bugs that hazard the whole SDN network.In Floodlight, we found 3 bugs (Bug-1, Bug-2, and Bug-3) in the LinkDiscoveryManager application that can violate the operation of link discovery procedure. In Floodlight, we found 5 such bugs (Bug-5, Bug-6, Bug-7, Bug-8 and Bug-9) in the LoadBalancer application that <REST_REQUEST, SWITCH_LEAVE> * exploitable if the network is configured with in-band control, or if the adversary has access to the out-of-band network † exploitable if the adversary can send authenticated administrative events (REST APIs) to the controller could break the service chain for OFP_PACKET_IN event handlers. An attacker with the control of compromised hosts/virtual machines in SDN networks can easily trigger three harmful race conditions (i.e., Bug-11, Bug-12 and Bug-14 ) by generating OFP_PACKET_IN , HOST_JOIN, HOST_LEAVE, PORT_UP, and PORT_DOWN. Moreover, the attacker can remotely exploit 6 more harmful race conditions (i.e., Bug-1, Bug-2, Bug-3, Bug-4, Bug-5 and Bug-6) by utilizing SWITCH_JOIN and SWITCH_LEAVE events when the SDN network utilizes in-band control messages. In particular, the vulnerable windows of Bug-1 and Bug-4 include the dispatch of all previous updates of Floodlight controller as shown in Figure 1, where the more unprocessed network events (e.g., SWITCH_JOIN, PORT_UP, and PORT_DOWN) and the more event handler functions of SDN applications can enlarge the window. In particular, we updated the source IP address of a host and sent out ICMP echo requests (with the destination IP address of the public service 10.10.10.10) into the network to trigger the OFP_PACKET_IN messages. As a result, the harmful race condition is triggered by injecting an attack event sequence, which actually disrupts the packet processing service (as shown in Figure 12) to dispatch the incoming packets to OFP_PACKET_IN event handlers of SDN controller/applications. Designing a deterministic execution runtime system to mitigate concurrency errors in the SDN control plane with minor performance overhead is a meaningful future research direction.Sanitizing External Events. One important factor of successful exploitation of harmful race conditions lies in that an attacker can intentionally inject various control plane messages (e.g., HOST_LEAVE, SWITCH_LEAVE) to modify the internal state inside the SDN control plane. One infamous category of concurrency vulnerabilities is TOCTTOU (Time of Check to Time of Use) vulnerabilities widely identified in file systems, which allow attackers to violate access control checks due to non-atomicity between the check and the use on the system resources [46,14,12]. In contrast to existing threats, in this paper we study a new threat to the SDN, i.e., harmful race conditions in the SDN control plane.To fortify SDN networks, AvantGuard [44] and FloodGuard [48] propose schemes to defend against unique Denial-of-Service attacks inside SDN networks.