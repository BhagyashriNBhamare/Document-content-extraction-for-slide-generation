We also evaluate TIRO on a corpus of 2000 malware samples from VirusTotal and find that runtime-based obfuscation techniques are present in 80% of the samples, demonstrating that runtime-based obfuscation is a significant tool employed by Android malware authors today. However, because of its prevalence among malware, it is crucial that malware analyzers have the ability to deobfuscate Android applications in order to determine if an application is indeed malicious or not.There exist a variety of obfuscation techniques on the Android platform. Our study of obfuscated malware suggests that authors almost universally employ language-and runtime-based methods to hide their use of Android APIs in Java.To study both language-and runtime-based obfuscation in Android malware, we propose TIRO, a tool that can handle both types of obfuscation techniques within a single deobfuscation framework. This iterative mechanism enables it to work on a variety of obfuscated applications and techniques.TIRO's hybrid static-dynamic design is rooted in an integration with IntelliDroid [31], which implements targeted dynamic execution for Android applications. In this synergistic combination, IntelliDroid improves TIRO's efficiency by targeting its dynamic analysis toward obfuscation code and TIRO improves IntelliDroid's completeness by incorporating deobfuscated information back into its targeting. We also run TIRO on 2000 obfuscated malware samples downloaded from VirusTotal to measure the prevalence of various runtimebased obfuscation techniques in the wild and find that 80% use a form of runtime-based obfuscation.We begin by providing background on the Android runtime and classical language-based obfuscation techniques in Section 2. ART, a separate runtime introduced in Android 4.4 and set as the default in Android 5.0, adds ahead-of-time (AOT) compilation (using the dex2oat tool) to a DEX interpreter. Because the target of reflected method invocations is only known at run-time, this frustrates static analysis and can make the targets of these calls unresolvable (e.g. by using an encrypted string), thus hiding call edges and data accesses.Value encryption. The primary drawback to this approach is that access to Android APIs, which can reveal the user's location and give access to various databases containing the user's contacts, calendar and browsing history, can only be reliably accessed via API stubs in the Java framework library provided by the OS. As a result, applications that use native code obfuscation still need obfuscation for Java code if they want to be able to make Android API calls reliably. lang.DexFile object is returned to the application if it uses the DexFile.loadDex() API; in normal cases, this object is passed to a class loader so that ART can later load classes from the new DEX bytecode.The class loading process, Stage B , is triggered when a class is first requested (e.g. when it is first instantiated). We describe these techniques in more detail below:1 2 DEX file hooking.When loading a DEX file, the dalvik.system.DexFile class is used in Java code to identify the loaded file; however, the bulk of the actual loading is performed by native code in the runtime, using a complementary native art::DexFile class. In most cases, the malicious DEX file is loaded using non-API methods and classes within native code, or is dynamically generated in memory, further hiding its existence.Similarly, instead of modifying the mCookie field, the obfuscation code can also modify the begin_ field within the art::DexFile native class and redirect it to another DEX file. Modifying the class data pointer allows the obfuscation code to replace the class definition with a different class while modifying the method definition allows the obfuscation code to change the location of the code implementing a method. We note that there are no bounds checks on the pointers, so while class and method pointers normally point to definitions and code within the DEX file, obfuscation code is free to change them to point to objects (including dynamically created ones) anywhere in the application's address space.Class declarations (class_def_item) are not normally modified by obfuscation code since this top level object is often read and cached into an in-memory data structure for fast lookup. Alternatively, instruction overwriting can be achieved by accessing the memory referenced by this pointer and performing in-place modification of the code-this normally requires the original instruction array to be padded with NOPs (or other irrelevant instructions) to ensure sufficient room for the newly modified code. The output is a set of deobfuscated information (such as statically unresolvable run-time values, dynamically loaded code, etc.) that can be passed into existing security analysis tools to increase their coverage, or used by a human analyst to better understand the behaviors of an Android application.The main design of TIRO is an iterative loop that incrementally deobfuscates applications in four steps:T arget: We use static analysis to target locations where obfuscation is likely to occur. This instrumentation reports the dynamic information necessary for deobfuscation.R un: We execute the obfuscated code dynamically and trigger the application to deobfuscate/unpack and execute the code.O bserve: We observe and collect the deobfuscated information reported by the instrumentation during dynamic analysis. If TIRO discovers that the deobfuscation reveals more obfuscated code, it iterates through the above steps on the new code until it has executed all targeted locations that could contain obfuscation.TIRO's iterative process allows for deobfuscation of multiple layers or forms of obfuscation used by an application, since the deobfuscation of one form may reveal further obfuscation. While recent Android obfuscators generally automatically unpack application code at startup (and thus require no special inputs), an added benefit of targeting is that we can use IntelliDroid to generate inputs to trigger paths in future obfuscated code that may only unpack sections of code under specific circumstances [25]. As a result, we instead target all Java entry-points into application-provided native code, such as invocations to native methods and to native code loading APIs (e.g. System.load(), which calls the JNI_ OnLoad function in the loaded native library). Since the result of this modification is the execution of unexpected code on a method invocation, one approach might be to record the code that was loaded into the runtime for a given method and check whether this code has been modified at the time of invocation. As a result, to detect runtime-based obfuscation, TIRO instruments transitions between native to Java and Java to native code to detect whether runtime state has been modified while the application was executing native code.The runtime state monitored is specific to the objects used to load and execute code, as described in Section 3.3. To reduce this cost we: (1) only monitor runtime state used in the code loading and execution process, and that are retrievable via the dynamic loading or reflection APIs (i.e. state stored within DexFile, Class, and Method objects); (2) only monitor the objects for methods and classes used by the application, as determined by reachability analysis during TIRO's static phase. To avoid conflicts with any runtime state modification that may be performed by obfuscation code, TIRO checks if any state modifications target instrumented code and if so, TIRO aborts execution of the instrumented code and allows the modifications to be performed on the original application code instead. In order to access the private DexFile::mCookie field for DEX file hooking, applications must use reflection or JNI, but the mCookie field type has changed from an int in 4.4, to a long in 5.0, and finally to an Object in 6.0. Most of these changes were in the call graph generation code, where we tag locations at which deobfuscated values were obtained and add special edges to the call graph representing dynamically resolved/deobfuscated invocations. The dynamic portion was executed on a Nexus 5 device running TIRO's instrumented versions of Android 4.4, Android 5.1, and Android 6.0. First, all of the malware samples employed basic language-based obfuscation such as reflection and native code usage, while roughly 53% (18/34) of the samples also employed the more advanced runtime-based obfuscation techniques. The methods and classes that were executed had undergone DEX bytecode modification, and TIRO successfully extracted the new non-empty implementations.apkprotect: In the first iteration, TIRO found several classes in the APK file, none of which were the components declared in the manifest. From the run-time information gathered, TIRO reported that a number of class objects were requested via reflection, but only one was instantiated via a reflected call to the constructor method.In the second iteration, TIRO found that only the class that was instantiated was actually present in the dynamically loaded code. Since TIRO retrieves modified code in a piecemeal fashion as the modification is detected for each class (rather than taking a single snapshot of the buffer), it was able to handle the multiple code modifications and the subsequent mangling of class metadata.dexprotector: This sample highlights how TIRO deobfuscates multiple layers of obfuscation and is described in Appendix A. Since TIRO's feedback system of relaying dynamic information to static analysis depends on instrumented log messages, this initially posed a problem for deobfuscation. The hooked method getClassNameList() does not actually play a part in the class loading process nor was it used by the application; however, it is useful for code analysis as it returns a list of loaded classes and its redefinition made such interactive analysis more difficult.For completeness, we also found two publicly available method hooking libraries: Legend [18] and YAHFA [19], and used these to create our own application obfuscated with method hooking. Since the majority of obfuscation occurs in the application launch phase (i.e. when the application unpacks its main activity and other components), we compare the launch time of the application when running in TIRO against the launch time in an unmodified version of AOSP. Reusing the existing runtime on Android makes it easier for commercial obfuscation tools to reliably support all forms of Android applications.In addition, system services are normally accessed through their RPC interface, which would require a transition back into the runtime and would be detected by TIRO's monitoring of native-to-Java transitions. As a result, for the foreseeable future, language-and runtime-based obfuscation techniques will likely still be relevant techniques for obfuscated code on Android.Another form of obfuscation may be to embed a natively-implemented interpreter within the application that executes a secret bytecode. While we currently cannot prevent this, due to the shared address space between the application and the runtime environment, future work may explore the separation of application and runtime memory, which would also prevent tampering of runtime state and disable runtime-based obfuscation.Since TIRO relies on dynamic analysis to report deobfuscated values, full deobfuscation of an application would require executing all of its obfuscation code. StaDynA [38] uses a hybrid iterative approach similar to TIRO to deobfuscate reflection and retrieve dynamically loaded code. Similarly, Ripple [37] also targets reflection but does so through static resolution, which is less precise. By focusing on obfuscation for the Android runtime via languagebased and runtime-based deobfuscation, we account for the environment in which Android applications are run and produce effective results that can be integrated with existing Android security tools. Through an iterative process of static instrumentation and dynamic information gathering that uses Target, Instrument, Run and Observe, we show that TIRO is able to deobfuscate malware that have been packed using state-of-the-art Android obfuscators. The research in this paper was supported by an NSERC CGS-D scholarship, a Tier 2 Canada Research Chair, and a Google Faculty Research Award. Deobfuscation in these cases requires multiple iterations to resolve the reflection target and, if the target is used for another form of obfuscation, to resolve the reflected obfuscation API.As an example, Figure 2 shows how TIRO iteratively applies the T-I-R-O loop to deobfuscate the combination of techniques used by the dexprotector packer and to extract a complete application call graph. Deobfuscation in these cases requires multiple iterations to resolve the reflection target and, if the target is used for another form of obfuscation, to resolve the reflected obfuscation API.As an example, Figure 2 shows how TIRO iteratively applies the T-I-R-O loop to deobfuscate the combination of techniques used by the dexprotector packer and to extract a complete application call graph.