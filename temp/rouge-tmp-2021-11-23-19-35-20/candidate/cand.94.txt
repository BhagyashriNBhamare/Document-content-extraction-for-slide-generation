Several papers [33,21] criticize traditional N-version programming, observing that multiple versions of a program often exhibit correlated faults-an ostensible hitch in our framework.We revisit these papers and show that NNVP achieves an appealing cost-benefit trade-off, by abandoning faulttolerance in favor of error detection. Thus, withholding carries no cost for the hacker, removing incentives for early disclosure.We propose Submarine Commitments, a countermeasure of independent interest that temporarily conceals a bounty claim among ordinary transactions, preventing a hacker from observing and front-running a claim. From a state s, running f on input x produces output y and updates s. For an input sequence X = [x 1 , x 2 , . . . ], we denote by run( f , X) := [y 1 , y 2 , . . . ] a serial execution trace of f starting at the initial state and outputting y i on input x i . The set of fallback traces is thenY ⊥ := Y | ∃i.[y 1 , . . . , y i ] run(I, X) ∧ n j=i+1 (y j = ⊥) ,We define an exploit against f as any input sequence X for which f 's output is neither that of the ideal program nor a fallback trace. A program transformation T( f 1 , f 2 , . . . , f N ) := f * introduces an affirmative exploit gap for a distribution D over inputs sequences X if gap := Pr X∈D X ∈ N i=1 E( f i , I) Pr X∈D [X ∈ E( f * , I)] > 1 . That is, a transformed program may fallback on inputs that are exploits for some of the original programs.Given a transformation T that induces an exploit gap, a natural bug bounty for a deployed program f * rewards bugs in the original programs f i . This setup is not suitable for smart-contracts: As in centralized financial institutions (e.g., stock-markets [48]), the cost of a fault typically trumps that of a temporary loss of resource availability.Ethereum's community exemplified its preference for safety in this trade-off, when attackers found an exploit in the Parity Multisig Wallet [11] and stole user funds. Yet, such correlated failures only invalidate the N-version paradigm if increased development costs outweigh failure rate improvements.Unfortunately, in an experiment at NASA, Eckhardt et al. [21] found that the correlation between individual versions' faults could be too high to be considered costeffective, with a majority vote between three programs reducing the probability of some fault classes by only a small factor (as we show in Appendix A, some of the workloads in [21] yield an exploit gap of gap ≈ 5 using majority voting between three programs). The waiting times for both events are exponentially distributed with respective rates λ i andλ i · Pr x∈D x ∈ E( f * , I) | x ∈ N i=1 E( f i , I) = λ i · Pr x∈D x ∈ E( f * , I) ∧ x ∈ N i=1 E( f i , I) Pr x∈D x ∈ N i=1 E( f i , I) = λ i · Pr x∈D [x ∈ E( f * , I)] Pr x∈D x ∈ N i=1 E( f i , I) = λ i · gap −1 . We analyze two cases: (1) A finds an exploit against f * , and (2) A finds a bug for a strict subset of the heads.In the first case, it is clear that A has no incentive to disclose, unless the bounty exceeds the contract's value. In our model, A can mount strong history-revision attacks, overwriting blocks at the head of the blockchain, and can delay any transaction by a bounded number of blocks.This reflects an adversary's ability to monitor transactions, mount network-level attacks, control client accounts, and even corrupt or bribe miners to alter legitimate blocks. A can reorder P 0 's transactions by: (1) Rewinding the blockchain from its head, i.e., mounting a history-revision attack, for a sequence of up to ρ blocks ; and (2) Delaying the posting on the blockchain of a transaction by P 0 by up to δ blocks. Via DepositCollection, Contract recovers $val thus avoiding unnecessary burning of funds.Thus if A does not know P's address (honest bounty hunters could use a mixer), and $val is sampled from an appropriate distribution of values $val ≥ $deposit, A cannot distinguish transaction τ from other sends to fresh addresses. P * posts a "reveal" in block revblock P * = commblock P * + ρ.A wins the game if she posts a valid "commit" before P * does, and also posts a corresponding "reveal" to claim Experiment Exp bntyrace A (n , δ , ρ, s; ∆, $deposit, $bounty)Init: n ← n − ∆, $cost ← 0, commblock P * ←$ [1, n]A {B←F withhold ({P 0 =P * ,P 1 },n,δ ,ρ,s)} //A interacts with F withhold for i = 1 to n if ("commit", $deposit) ∈ B i then . As a first goal, an economically rational adversary A's aims to maximize its expected payoff, namely$cost ← $cost + $deposit //Every commit costs $deposit if ∃(1 ≤ i ≤ commblock P * ∧ i ≤ j ≤ min(i + ∆, n)) s.t. ∃ (τ = "commitE[$payoff] = p wins · $bounty − E[$cost]. While we could also run a bounty program off-chain (for a single deployed contract), this would not provide an exploit gap, a key property in our analysis of attacker incentives.The main challenge is the implementation of the "Execution Environment" [17,6], the agent that coordinates the N heads and combines their outputs. However, most smart contracts also interact with the blockchain, e.g., by accessing information about the current transaction (such as the sender's address) or by calling other contracts, and the MC must thus guarantee consistency among the heads.We illustrate the issue in Figure 5 with a Solidity code snippet (top-left) and corresponding EVM opcodes (bottom-left). With N heads, g(x) is called N times instead of once.The heads might also obtain different return values.To resolve these issues, the heads are instrumented prior to deployment so that all interactions with the blockchain are mediated by the MC. While these modifications could be made in a high-level language (e.g., Solidity), we opt for a more generic, automated, and globally applicable solution that operates on the EVM opcodes of a compiled contract (the instrumentation is thus agnostic to the language used to develop the heads). If heads request different callbacks, the MC throws an exception, reverting all changes and triggering the bounty payment.To maintain consistency between heads, and avoid potential read-write inversions (e.g., if heads send ether and read contract balances in different orders), the program specification is required to define a total-ordering of the read and write operations issued by the heads.Tail-call optimization. Rewriting opcodes also modifies the layout of the bytecode, so all JUMP instructions are updated accordingly.The instrumentation applies to contracts written in any high-level language that compiles to the EVM, and requires no changes to the EVM. To test soundness, applicability and performance of Hydra contracts, we use three workloads: (1) The official suite of test contracts for the EVM 1 ; (2) All contracts used in Ethereum between Dec. 7 2017 and Feb. 7 2018; and (3) two representative smart-contract applications developed by the authors. Implementations of Submarine Commitments in Ethereum, and a thorough analysis of the resulting anonymity sets for bounty claiming transactions are in Appendix B.We developed a generic ERC20 contract [55] for token transfers, and a Monty Hall Lottery, wherein two participants play a multi-round betting game [56]. Research on smart contract security is burgeoning and includes: Analysis of common contract bugs [19,38,5], static analysis and enhancements for Solidity [38], formal verification tools [9,28,3], design of "escape hatches" [41], DoS defenses for miners [39], trusted data feeds [58], formal EVM semantics [27,29], and automated exploitation tools [36]. We have modeled strong bug-withholding attacks against on-chain bounties, and analyzed Submarine Commitments, a generic defense to front-running that hides transactions in ordinary traffic.Finally, we have designed and evaluated a Hydra Framework for Ethereum, and rigorously tested its soundness and applicability to the majority of Ethereum contracts today. We have gap ma j = ˜ P one˜P one˜ one˜P maj and gap NNV P ≥ ˜ P one˜P one˜ one˜P all ,where the inequality for gap NNV P is because NNVP only fails if all programs fail identically (the results in [21] only give us an upper bound for this probability In all cases, the lowest exploit gap is obtained for the third work-load (denoted S 1,0 in [21]), which has the lowest failure rate overall.If we combine all work-loads into one, and assume that hackers sample uniformly from the test inputs used in the experiment, we obtain:N Majority Voting NNVP 2 N.A. gap NNV P ≥ 79 3 gap ma j = 7gap NNV P ≥ 4409 5 gap ma j = 709 gap NNV P ≥ 282,605Note that NNVP makes sense even in the case N = 2, and yields gaps that are multiple orders of magnitude greater than the ones obtained with majority voting. Unlike CREATE, which does not include a user-supplied value, CREATE2 computes the address of the created contract C as H(addrCreator, salt, codeC), where addrCreator is the address of the contract's creator, salt is a 256-bit salt value chosen by the creator, codeC is the EVM byte code of C's initcode, and H is Keccak-256. In the Hydra Framework, these program versions, or heads, are executed in parallel within a meta-program called a Hydra program.In stark contrast to N-version programming's goal of fault tolerance (i.e., where the program attempts to produce a correct output even in the face of partial failures), NNVP focuses on error detection and safe termination. These transformations operate on N > 1 programs and aim at full availability (i.e., no fallback outputs), a natural requirement in mission-critical systems.We focus on N-version (or multiversion) programming, which we build upon in Section 3. The simple escape hatch in this scenario (i.e., move funds to a safe account) was deemed a successful alternative to an actual exploit.We propose trading availability for safety in N-version programming, by replacing the goal of fault-tolerance by one of error detection and safe termination. We thus let λ H be the rate at which honest parties find bugs that affect 1≤ k < N heads.To analyze economic incentives of bounties, we consider malicious parties which, if given an exploit, would deplete the contract's balance. Intuitively, this is because front-running is expensive: Since A observes a "commit" message from P * too late to remove it by rewinding, A must post "commit" messages continuously to ensure that it can front-run P * . Indeed, for m (noncolluding) adversaries with work rates λ 1 , . . . , λ m , it suffices to analyze the party with rate λ M = max 1≤i≤m λ i . However, front-running has the potential of removing incentives for early disclosure, as A can ensure a payout of $bounty by front-running the honest bounty hunter.If A conceals a bug, she finds a full exploit before the bounty is claimed with probability q := Pr[T M < T H ]. The T Bounty transformation described in Section 3.3 is implemented as a simple wrapper around the MC, which catches the above exception, pays out a bounty, and enters an escape-hatch mode.Maintaining consistent blockchain interactions. While promising, none of these tools and techniques have yet seen mainstream adoption, nor do they relate directly to our explorations in this paper.In a closely related work, Tramèr et al.[53] consider using smart contracts for bug bounties (using SGX), but not the converse, i.e., bounties for smart contracts.Bug withholding is related to selfish-mining [25], where a miner withholds blocks to later nullify other miners' work. Generically, dynamic runtime checks (e.g., stack canaries, under-or overflow detection) can yield an availability-preserving exploit-gap: the checks result in a fallback output (e.g., a runtime exception), where the original program had an exploit. We assume w.l.o.g. that P 0 is honest and the other m players are controlled by A. Within the F withhold -hybrid model, we specify a contract BountyContract to administer a single bug bounty, using a simple commit-reveal scheme to prevent adversarial copying and resubmission of bugs. Achieving Submarine Commitments is challenging in systems like Ethereum, however, because message contents and currency in all transactions are in the clear.Briefly, in Ethereum, to commit in a Submarine Commitment scheme, P posts a transaction τ that sends (nonrefundable) currency $val ≥ $deposit to an address addr. That is, x is an exploit if run(f * , X [x]) = run(I, X [x]), where X is the sequence of all inputs previously submitted to f * and denotes concatenation.If an honest party finds an input x that yields an exploit for at least one of the heads (∃i ∈ [1, N] : x ∈ E( f i , I)), then the party is awarded a bounty of value $bounty and the contract's escape hatch is triggered. This address is itself a commitment of the form addr = H(addr(Contract), H(addr(P), key), data) , for H a commitment scheme (e.g., hash function in the ROM), key a randomly selected witness (e.g., 256-bit string), and data other ancillary information. The game is played between an honest user P * = P 0 , and a user P 1 controlled by A. W.l.o.g., P * models a collection of honest players, while P 1 models players controlled by A. N-version programming traditionally uses majority voting between programs to induce an exploit gap [17,6].3 N-of-N-version Programming N-version programming assumes that heterogeneous implementations have weakly correlated failures [17]. If a malicious party finds an exploit against the full Hydra contract (x is an exploit for each head), the party can use this exploit to steal the entirety of the contract's balance, $balance.We model bug finding as a Poisson process with rate λ i , which captures a party's work rate towards finding bugs. • The Hydra ERC20 token: The ERC20 token-transfer API has been thoroughly peer reviewed [55], and is supported by most of the highest-dollar contracts in Ethereum (as of February 2018, the combined market cap of the top ten Ethereum tokens is over 20 billion USD [1]). Applying the tail-call optimization results in significant savings for these callback-heavy functions.Completing a game of Monty Hall requires long-term storage of many game parameters which overshadows the base fee costs (each stored word costs 20,000 gas). Following the notation and analysis for majorityvoting in [21], we define the empirical probability˜Pprobability˜ probability˜P maj that a majority of the N programs (randomly chosen from the 20) fail simultaneously (see [21, Equation 6]):˜ P maj = 20 ∑ y=0 20 N −1 N ∑ l= N+1 2 y l 20 − y N − l g(y) . Our thesis is that smart-contract ecosystems present a number of key properties that render multiversion programming and derived bug-bounty schemes attractive.The main differentiator between the traditional setting of N-version programming, and ours, is the role of availability. A then knows that P 0 is trying to claim a bounty, and can front-run P 0 's commitment by posting her own "commit" ahead in the blockchain.This problem arises in many other scenarios, e.g., token sales or auctions, where a user must send funds 