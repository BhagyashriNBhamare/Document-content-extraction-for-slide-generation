Simple path tracing tools such as traceroute allow malicious users to infer network topologies remotely and use that knowledge to craft advanced denial-of-service (DoS) attacks such as Link-Flooding Attacks (LFAs). Link-flooding attacks (LFAs) [26,38] are more sophisticated and work by having a botnet generate lowrate flows between pairs of bots or towards public services such that all of these flows cross a given set of network links or nodes, degrading (or even preventing) the connectivity for all services using them. NetHide consists of two main components: (i) a usabilitypreserving and scalable obfuscation algorithm; and (ii) a runtime system, which modifies tracing traffic directly in the data plane.The key technical insight behind NetHide is to formulate the network obfuscation task as a multi-objective optimization problem that allows for a flexible trade-off between security (encoded as hard constraints) and usability (soft constraints). LFAs assume that the attacker can discover the network topology, usually using traceroute-like tracing.on arbitrary IP Time-to-Live (TTL) values; (ii) change the source and destination addresses of packets (e.g., UDP packets for traceroute) depending on the original destination address and the TTL; and (iii) restore the original source and destination addresses when replies (e.g., ICMP packets) to modified packets arrive. The attacker aims to congest links by creating low-volume flows from many different sources (bots) to many destinations (public servers or other bots) such that all these flows cross the targeted links (illustrated in Fig. 1). More specifically, traceroute leverages the fact thatNetwork components (Nodes) N ⊆ N = {n 1 , . . . , n N } (Links) L ⊆ N × N (Forwarding tree) T n = (N, L n ), tree rooted at n (Forwarding trees) T = n∈N T n (Flows) F ⊆ N × N Network topologies (Physical) P = (N, L, T ) (Virtual) V = (N , L , T ) N ⊆ N Metrics (Flows per link) f (T, l) = {(s, d) ∈ F | l ∈ T d } (Flow density) fd(T, l) = | f (T, l)| (Capacity) c : L → N (Accuracy) acc : ((s, d) , P,V ) → [0, 1] (Utility) util : ((s, d) , P,V ) → [0, 1]Figure 2: NetHide notation and metrics TTL values are decremented by one at each router, and that the first router to see a TTL value of 0 sends a response to the source of the probe. NetHide allows to extend a topology with virtual nodes, i.e., nodes v ∈ N \ N.Given a node n, we use a tree T n = (N, L n ) rooted at n to model how packets are forwarded to n. A flow (s, d) ∈ F is a pair of a source node s and destination node d. Note that the budget of the strongest attacker is given by the total number |F| of possible flows. In the style of [26], we define the flow density fd for a link l ∈ L as the number of flows that are routed via this link (in any direction). For the similarity between the physical topology P and the obfuscated topology V , we refer to §3 where we present metrics which represent the accuracy of paths reported by traceroute and the utility of link failures in P being closely represented in V . Specifically, we consider the task of obfuscating a network with 6 routers: A, . . . , F in which the core link (C, D) acts as bottleneck and is therefore a potential target for an LFA.Inputs NetHide takes four inputs: (i) the physical network topology graph; (ii) a specification of the forwarding behavior (a forwarding tree for each destination according to the physical topology and incorporating potential link weights); (iii) the capacity c of each link (how many flows can cross each link before congesting it); along with (iv) the set of attack flows F to protect against. In addition to enabling NetHide to scale, this random selection also acts as a secret which makes it significantly harder to invert the obfuscation algorithm.NetHide obfuscates network topologies along two dimensions: (i) it modifies the topology graph (i.e., it adds or removes links); and (ii) it modifies the forwarding behavior (i.e., how flows are routed along the graph). As illustration, V 2 is more accurate than V 1 in Fig. 3 as the reported paths have more links and routers in common with the physical topology.The utility metric measures the physical similarity between the paths actually taken by the tracing packets in the physical and the virtual topology. Deploying the obfuscated topology NetHide obfuscates the topology at runtime by modifying tracing packets (i.e., IP packets whose TTL expires somewhere in the network). Since the link between A and D does not exist physically, the packet needs to be sent to D via C, and it would thus expire at C. To prevent this and to ensure that the packet expires at D, NetHide increases the TTL by 1. Given a topology P = (N, L, T ), a set of flows F, and capacities c, the network obfuscation problem is to generate a virtual topology V = (N , L , T ) such that: (i) V is secure; and (ii) the accuracy and utility metrics are jointly maximized; we define these metrics shortly.NetHide generates V by modifying P in three ways: (i) NetHide can add virtual nodes to the topology graph that do not exist in P; (ii) NetHide adds virtual links to connect physical or virtual nodes in V ; and (iii) NetHide can modify the forwarding trees for all nodes in V . In the algorithm, given a virtual pathT s→d = s → n 1 → · · · → n k → d, we write T s→d [0 : n i ]to denote the prefix path s → n 1 → · · · → n i . For computing the forwarding trees, NetHide builds a complete graph G with all nodes from V , that is G = (V, E) where V = N and E = N × N , and assigns each edge the same weight w(e) = 1 ∀e ∈ E. Then, NetHide uses Dijkstra's algorithm [21] to compute forwarding trees towards each node n ∈ N . This is repeated until the specified number of forwarding trees per node is obtained while the weights are randomly chosen w(e) ∼ Uniform(1, 10) for each iteration.As NetHide pre-computes a fixed number of forwarding trees per node, the ILP solver later only needs to find an optimal combination of O(|N |) forwarding trees instead of O(|N | 2 ) links and O(|N | |N | ) forwarding trees.We point out that the reduction from individual links or paths to forwarding trees and the small number of considered forwarding trees does not affect the security of V as security is a hard constraint and thus, NetHide never produces a topology that is insecure. That is, the estimation step would require a large number of samples, obtained by running T using the obfuscation function.Choosing an attack In principle, even if the attacker cannot reconstruct P, she may still attempt to attack the network by selecting a set of flows and checking if these cause congestion or not. This can potentially be used to identify obfuscated parts of a path.While packets forwarding is usually done in hardware without noticeable delay, answering to an expired (TTL=0) IP packet involves the router control plane and causes a noticeable delay. Besides table lookups, P4 also supports a limited set of operations such as simple arithmetic operations or computing hash functions and checksums.For our implementation, we use P4_14 [14] and leverage P4's customizable header format to rewrite tracing packets at line rate without requiring to keep state (per packet, flow or host) at the devices. Instead, it purely relies on the TTL value, the source and destination of a packet and-if needed-it obfuscates traffic of all applications.Encoding the virtual topology If a packet needs to be modified, NetHide queries the match+action table which returns the required changes for the packet. As described above, NetHide sometimes needs to modify the TTL value in production traffic (which does not impact latency or delay and is already done by routers today) and it needs to send tracing packets to different routers (which has an impact on the observed RTT; but only for tracing packets whose TTL expires before reaching the destination). As deploying a system that needs to run on all devices is difficult, we design NetHide such that it can fully protect a network while being deployed on only a few devices.The key enabler for this is that NetHide only needs to modify packets at most at one point for each flow.NetHide can obfuscate all traffic as soon as it has crossed at least one NetHide device. Metrics To be able to compare the results of our evaluation with different topologies, we use the average flow density reduction factor, which denotes the ratio between the flow density in the physical topology P = (N, L, T ) and in the virtual topology V = (N , L , T ): FR = 1 − avg l∈L fd(V, l) avg l∈L fd(P, l)The flow density denotes the number of flows that are carried at each link (cf. §2.3). For the forwarding behavior, we assume that traffic in P is routed along the shortest path or a randomly picked shortest path in case there are multiple shortest paths between two nodes.Parameters We run all our experiments with the following parameters: All nodes in P can act as ingress and egress for malicious traffic (which is the worst case when an attacker is everywhere). While adding enough links randomly will eventually result in a complete graph, the small number of forwarding trees considered by NetHide does not always contain enough links to build a complete graph.In Fig. 8 (right), we show the percentage of flows that do not need to be modified (i.e., have 100 % accuracy and utility) depending on the flow density reduction factor. We specify the capacity of each link to 10 % of the maximum flow density listed in Table 1 and observe that w acc has a relatively small impact for our accuracy and utility metrics especially for large topologies. As the results in Fig. 11 show, virtual paths are shorter than physical paths (the ratio is ≤ 1)-intuitively because removing a node from a path has a smaller impact on our accuracy and utility metrics than adding one) andfor the medium and large topology-the virtual paths are less than 10 % shorter both on average and in the 10 th percentile for a flow density reduction of 80 %. Therefore, the key challenge for the attacker is to select the flows such that they result in a successful attack on P.Besides the attacker's budget, her chances of success also depend on the robustness of P: If P is weak (i.e., the capacity of many links is exceeded), it either needs to be obfuscated more or attacks are more likely to succeed.In this experiment, we simulate three feasible strategies for an attacker to select b flows:• Random: Samples b flows uniformly at random from the set of all flows F.• Bottleneck+Random: Identifies the link with the highest flow density in V (a "bottleneck" link l b ) and attacks by initiating all the fd(l b ) flows that cross this link plus (b − fd(l b )) random additional flows. • Bottleneck+Closeness: Identifies the link l b with the highest flow density in V and attacks by initiating all the fd(l b ) flows that cross this link plus (b − fd(l b )) nearby flows (according to the metric in Algorithm 2). To obtain the simulation results in Fig. 14 and Fig. 15, we simulated 10k attempts (Random and Bottleneck+Random) and 1k attempts (Bottleneck+Closeness) for each virtual topology from §6.2 and each combination of the link capacity and attacker budget.In Fig. 14 we compare the Random attacker with Bottleneck+Random and in Fig. 15 we compare Random with Bottleneck+Closeness. But since V contains links that are not in P or vice-versa, a physical link failure can be observed as multiple link failures or as the failing of another virtual link.In Fig. 13, we show that the vast majority of physical link failures is precisely reflected in the virtual topology. Though, the propagation time can leak information in topologies where the propagation delay of some links is significantly higher than of others.However, extracting information from the propagation time in geographically small networks is hard for three reasons: (i) it is impossible to measure propagation time separately. It allows an AS to route traffic from and to another AS along a path that is not affected by an LFA.On the other hand, proactive solutions-including NetHide-aim at preventing LFAs from happening and are typically based on obfuscation. The core idea is to phrase the obfuscation task as a multi-objective optimization problem where security requirements are encoded as hard constraints and usability ones as soft constraints using the notions of accuracy and utility.As a proof-of-concept, we built a system, called NetHide, which relies on an ILP solver and effective heuristics to compute compliant obfuscated topologies and on programmable network devices to capture and modify tracing traffic at line rate.