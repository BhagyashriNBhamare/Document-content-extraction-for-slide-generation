For instance, in case of a criminal investigation, the RHS provider can offer law-enforcement agencies with the location trace of a particular ride and the identities of the participants.To offer such services, however, RHSs collect a vast amount of sensitive information that puts at risk the privacy of riders and drivers. As a result, the SP, or any entity with access to this data, can infer sensitive information about riders' activities (such as one-night stands [35]), monitor the locations of riders in real-time for entertainment [18], track the whereabouts of their exlovers [42], look up trip information of celebrities [25], and even mount revenge attacks against journalists critical of such services [46]. For this purpose, ORide relies on state-of-the-art somewhathomomorphic encryption system [16] (SHE), to which we apply optimizations for ciphertext packing and transformed processing [38], hence enabling a notable boost in performance and a reduction in overhead w.r.t. naive cryptographic solutions.Accountability and usability are often considered as important as privacy in RHSs [11,15]; this introduces challenges in resolving the uneasy tension between privacy, accountability and usability. ORide also provides large anonymity sets for riders at the cost of acceptable bandwidth requirements for the drivers: e.g., for rides in the boroughs of Queens and Bronx, a ride would have an anonymity set of about 26,000, and the drivers are only required to have a data-connection speed of less than 2 Mbps. For instance, the anonymity set is smaller for ride requests in areas outside a city center. We assume that most riders and drivers do not collude with the SP, as drivers are independent contractors rather than SP's employees. • (A2) The SP uses its knowledge about side information about riders and drivers, including their home/work addresses, together with protocol transcripts, to perform large-scale inference attacks to profile riders' and drivers' activities [35]. Also, for all location-based computations, the apps use a coordinate system such that the Euclidean distances correspond to the great-circle distances, e.g., by using map-projection systems for local areas such as UTM [47] to convert a pair of (latitude, longitude) to planar coordinates (x, y). For this, ORide relies on somewhathomomorphic encryption (see Section 4.1) where the riders and drivers send their encrypted locations to the SP, from which the SP computes the encrypted squared Euclidean distances between them. For plaintext elements in a polynomial quotient ringm ∈ R t = Z t [X]/(X d + 1) and ciphertext elements in R q = Z q [X]/(X d + 1), where q and t are positive integers q > t defining the upperbound of the ciphertext and plaintext coefficients, respectively. Decryption of a ciphertext c c c = [c 0 , c 1 ] works asm = FV.Dec(k s , c c c) = (t · [c 0 + c 1 · s mod q]/q) mod t.The scheme enables us to seamlessly add (FV.Add), subtract (FV.Sub) and multiply (FV.Mul) two encryp- ) between the rider and available drivers as opposed to one ciphertext per driver (naive approach). tions to obtain the encryption of the added, subtracted, and multiplied plaintexts respectively; multiplications consider the encryptions as polynomials in v:[c 0 , c 1 ] → c o + c 1 · v,such that the product between c c c and c c c is evaluated as:[c 0 , c 1 ] · [c 0 , c 1 ] → c 0 · c 0 + (c 0 · c 1 + c 1 · c 0 )v + c 1 · c 1 · v 2 → [c 0 , c 1 , c 2 ], which results in a ciphertext in R 3q , with one extra polynomial. When this information arrives at the SP, the SP broadcasts the public key to all drivers available in that zone. The SP computes, based on their encrypted coordinates, the encrypted distances between the rider and the drivers, and it returns the encrypted distances to the rider, from which the rider can decrypt and select the best match, e.g., the driver who is the closest to her pick-up location.However, due to the high ciphertext expansion, a naive use of SHE would incur impractical computational and bandwidth costs for the riders and the SP. Furthermore, for each ride request, the SP would need to separately compute the encrypted distances between the rider and each of the drivers: For n drivers, this would mean n distance calculations between encrypted polynomials of d coefficients each, and n ciphertext distances returned to the rider. From here on, we assume that d ≥ n, which will usually be the case due to the security bounds on d (see Section 8); in other cases, n/d encryptions can be used to pack the whole set of distances analogously.First, ciphertext packing enables the SP to pack n ciphertext distances into one ciphertext, hence reducing the bandwidth overhead, but this is not enough for our goal. To make operations in Z t simulate operations in N on our values, we choose d = 2 l as a power of two and t as a sufficiently large Proth prime (of the form k2 l + 1, see [38]) such that all squared-Euclidean distances are less than t. As a result, we improve on both the bandwidth and the computation overhead.Moreover, due to the low degree of the evaluated operations (squared Euclidean distances), we avoid the use of re-linearizations at the SP, which (a) reduces the need to generate and to send the relinearization key from the rider to the SP, (b) reduces the noise inside the encryptions, and (c) enables more efficient operations at the SP, at the cost of one extra polynomial to represent the encrypted distance returned to the rider. We assume each rider and driver has a digital certificate denoted as cert R or cert D , issued by the SP at registration time. Each AC X contains the average reputation score rep X , an expiration date exp X , and the secret key sk X associated with the public key pub X in the digital certificate of the AC holder. To differentiate between riders and drivers in the system, an AC also contains a role attribute role X , i.e., role X = 1 if X = D, and role X = 0 if X = R.Note that to prevent the SP from de-anonymizing users by correlating the time an AC is issued with the time it is used, or by relying on the AC's expiration date, the user's app could automatically request ACs from the SP at a certain time (e.g., at midnight), and the expiration date is coarse-grained, e.g., all ACs issued in a day expire at the end of that day. The SP confirms with the rider and the driver that they have been assigned to each other.Rider: anonymous session s R SP Driver: anonymous session s D Generate (k k k p , k s ) p x R = ∑ d−1 i=0 x R X i p y R = ∑ d−1 i=0 y R X i c c c x R = FV.Enc(k k k p , NTT −1 (p x R )) c c c y R = FV.Enc(k k k p , NTT −1 (p y R )) q i x D = x D i X i q i y D = y D i X i c c c i x D = FV.Enc(k k k p , NTT −1 (q i x D )) c c c i y D = FV.Enc(k k k p , NTT −1 (q i y D )) c c c x D = ∑ n−1 i=0 c c c i x D c c c y D = ∑ n−1 i=0 c c c i y D c c c dist = (c c c x R − c c c x D ) 2 + (c c c y R − c c c y D ) 2 d d di i is s st t t = NTT(FV.Dec(k k k s , c c c dist )) Select driver, denoted ibest (1) z, dt, c c c x R , c c c y R , k k k p (2) k k k p , i(7a. Also, the driver can reveal to the rider the public key k k k p that she used to encrypt her locations; this helps to detect possible man-in-the-middle attacks at Step 2 of the protocol by the SP.The driver drives from her current location loc D to the pick-up location loc R , using an off-line navigation app or a third-party navigation app (such as Google Maps or TomTom). When the rider and the driver are in proximity, the driver performs a proximity check to verify the physical presence of the rider before releasing her identifying information: they use a short-range wireless technology (e.g., Bluetooth or WiFi Direct) to set up a proximity channel using the pairing PIN. Therefore, it is needed when the rider is about to enter the car, i.e., the required communication distance between the phones of the rider and the driver is small (e.g., several meters).10. The rider and driver then sign a message consisting of the day of the ride, the fare and their certificates, i.e., fare report = sig R−D {day, fare, cert R , cert D }, using the private keys associated with their cert R and cert D . Also, to prevent the SP from inferring the starting time of the ride based on the interactions between the rider and the driver over the secure channel, the rider and driver can randomly send dummy information to each other through the secure channel. From an economic perspective, ridehailing service SPs would have incentives to deploy ORide because it provides privacy and security for the riders and still preserves their business models (i.e., the SP can still charge a commission for each ride). Similarly to current RHSs, ORide enables the riders to retrieve lost items (i.e., items forgotten in the car), as drivers' certificates cert D and car information are provided during the ride set-up procedure. Our protocol can cope with this malicious behavior by adding one extra step in which the SP homomorphically multiplies each driver ciphertext by a mask m i = NTT −1 (X i ) for the driver's index i (see notations from Section 5.4), which preserves only the contents in the allocated slot. A PoR is a random number rand generated by the rider, signed by the driver by using the secret key associated with her cert D , and then blindly signed by the SP by using blind-signature schemes such as [13], i.e., PoR = Bsig SP {sig D {rand}}. Also note that, the payment operation in ORide reveals some information about the riders, but it cannot be used to break the anonymity of the rides (see Section 8). For improved anonymity, anonymouspayment methods, such as e-cash or regular cash, could be used to decouple the riders' identities from the fares, thus preventing the SP from learning about rides between home and work of the riders.By using the Ride DB, the SP might be able to guess the identities of the riders, only if the pick-up zone has a limited number of ride activities and riders, e.g., a zone where only one rider lives. Note that the SP would be detected if it lied about the activity densities in the zones, because these densities are public knowledge [43], and the drivers would notice if they received very few ride requests from a certain zone.In the case where the SP knows that a rider makes ride requests from a specific zone (e.g., the zone that contains her home/work addresses) and it wants to know the pickup times of these rides, the anonymity set of a ride is the number of rides that occurred on the same day from that zone. In the case where the SP knows the precise pick-up location and time of a ride, it still cannot know the drop-off location and time of the ride, because, in ORide, the drop-off event is not reported to the SP. However, a malicious outsider might attempt to triangulate drivers, to obtain a snapshot of the locations of all drivers in a zone: It could make three fake ride requests from different locations at the same time to obtain the distances, and cancels these requests immediately. The GPS traces of the rides are not given; however, the precise pickup and drop-off locations and times, and pseudo-IDs of the taxi drivers associated with the rides are provided.In addition, the data-set provides mapping between latitude/longitude coordinates to NYC census tracts (CTs), neighborhood tabulation areas (NTAs) and boroughs in NYC.We make the following assumptions. Compared to the naive SHE approach S1, optimized approaches (S2 and S3) significantly reduce the bandwidth requirements for the riders Our ORide prototype features the main cryptographic operations for the ride matching in the ride set-up procedure (Section 5.4). In this section, we describe our experimental setup, and presents the bandwidth and computational overhead per ride request for a rider and a driver.We used ORide's prototype to estimate the overhead added for ride-matching operations in three settings: (S1) the naive SHE approach (Section 4.2) without using re-linearizations at the SP, (S2) ciphertext-packing optimizations and honest-but-curious drivers (i.e., drivers Table 4: Per-ride computational overhead of ORide (without AVX/SSE optimizations), for d = 4096, log 2 (q) = 124, and there are 4096 drivers available for a request. • Bandwidth overhead for a driver: In all three settings, for each request: (1) on the downlink, the SP forwards to each driver a public key, 2 polynomials of size 124 KB, and (2) on the uplink, each driver sends back to the SP her encrypted planar coordinates, totaling 4 polynomials of size 248 KB. It also significantly reduces the decryption overhead for the rider, from 7823 ms in setting S1 to 2.2 ms in settings S2 and S3.Note that the results for the rider and driver are optimistic, as we used a laptop instead of a smartphone (however, as stated before, CPU optimizations were not used to reduce the difference). Fig. 3b shows the CDF of the upload speed required for the drivers; the upload speed is computed by multiplying the number of requests a driver receives per second with the size of the ciphertexts she has to upload per request. To minimize the extra costs for both the drivers (e.g., gas and driving time to pickup) and the riders (e.g., waiting times at pick-up locations), ideally, the ride-matching algorithm should take into account the road networks and real-time traffic conditions. We have also shown that, even in the extreme case of targeted attacks, i.e., a curious SP wants to know the destination of a rider given the time and location of a rider's pick-up event, the location privacy of the rider's destination is still guaranteed. Assuming the area is discretized into a grid of v × v cells, the largest possible squared-Euclidean distance between any two points on the grid is 2 × v 2 , and this has to be at most 2 b . Therefore, the area can be represented by a grid with cells of sizeFor example, with 20-bit plaintext space, a geographical area of size 60 km 2 , such as the borough of Manhattan in NYC, would be quantized into a grid of resolution approximately 10 m × 10 m. A.3 Cryptographic PrimitivesIn this section, we briefly describe the cryptographic building blocks used in ORide.Blind signatures. An anonymous credential (AC) is a cryptographic token with which the credential owner can prove to another party that she satisfies certain properties without revealing her real identity. An NTT is the finite ring version of a Discrete Fourier Transform; an n-point NTT of a vector x x x ∈ Z n t and its inverse operation NTT −1 have the formwhere n −1 is the modulo inverse of n in Z t , and α is a principal n-th root of unity in Z t , whose existence is a necessary condition for the transform. The NTT presents a convolution property, that relates the circular convolution () of two vectors with the component-wise product (·) of their transformed versions, such thatTherefore, an O(n 2 ) operation like the convolution gets reduced to the complexity of the transforms (O(n log n)) and the component-wise product (O(n)). Assuming the area is discretized into a grid of v × v cells, the largest possible squared-Euclidean distance between any two points on the grid is 2 × v 2 , and this has to be at most 2 b . The NTT presents a convolution property, that relates the circular convolution () of two vectors with the component-wise product (·) of their transformed versions, such thatTherefore, an O(n 2 ) operation like the convolution gets reduced to the complexity of the transforms (O(n log n)) and the component-wise product (O(n)).