Unfortunately, officially patching an Android device is a long process involving multiple parties with disparate interests: Google/the vendor verifies a reported vulnerability and creates a patch for it.The patch is then thoroughly tested and released to carriers; carriers test the update again for compatibility with their networks and release it to their users as an overthe-air (OTA) update. 2 KARMA is a part of the OASES (Open Adaptive Security Extensions, https://oases.io) project, an initiative founded by Baidu to enable fast and scalable live patching for mobile and IoT devices. The main contributions of our paper are four-fold:• We analyzed the fragmentation issue that hinders existing kernel live patching solutions to be ubiquitously applied on Android devices, and brought the need of an adaptive Android kernel patching solution to light. These observations can serve as a foundation for future systems tackling this problem.Observation A: most kernel functions are stable across devices and Android releases.Android (Linux) kernel is a piece of large and mature software. Most (exported) kernel functions follow the official coding style and return error codes -even kernel functions that return pointers often return out-of-range "error codes" using the ERR_PTR macro.Based on these observations, our approach is as follows: for each applicable vulnerability, we create a patch that can be placed on the vulnerable function to filter malicious inputs. The security is enforced by the following two technical constraints:Rule I, a patch can only be placed at designated locations, and its patched function must be able to return error codes or return void (i.e., no return value). Our experiment with 76 critical kernel vulnerabilities shows that level 1 can patch 49 (64%) vulnerabilities, level 2 can patch 22 (29%) vulnerabilities, and we have to fall back to level 3 in only 5 cases (7%). Similarly, we allow functions that return void to be patched.Rule II, a patch can read any valid kernel data structures, but it is prohibited from writing to the kernel.Even though KARMA's patches are vetted before deployment, they may still contain weakness that can be exploited by attackers. This rule is enforced by providing a set of restricted APIs as the only interface for the patches to access the kernel data.By combining these two rules with a careful vetting process and the memory-safety of the patches, we can strictly confine the run-time behaviors of patches to prevent them from potential misuse. Specifically, KARMA first roughly identifies potentially vulnerable functions in kernel K t , and applies symbolic execution to compare the semantics of each candidate function (F t ) against reference function F r . Semantic matching also provides a scheme to customize reference patch P r for target kernels.In the second phase, the KARMA client in the user device downloads and verifies the patches for its device and applies them to the running kernel. In the unlikely event that a patch causes the device to malfunction, the user can reboot the device and skip the problematic patches 1 function kpatcher ( patchID , sp , cpsr , r , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r1 , r11 , r12 , r14 ) 2 if patchID == xca5269db5f4 then 3 uaddr1 = r 4 uaddr2 = r2 5 if uaddr1 == uaddr2 then by holding a hardware key. They allow the patch to access function argu-1 s t a t i c i n t sock _diag _rcv_m sg ( s t r u c t sk_buff * skb , s t r u c t nlmsghdr * nlh ) 2 { 3... CVE-2013-1763: Figure 5 shows the original source code patch for CVE-2013-1763. However, since __sock_diag_rcv_msg does not appear in the kernel's symbol table (because it is a static function), KARMA instead hooks the entry point of its parent function and screens the arguments there.CVE-2013-6123: this is a vulnerability in function msm_ioctl_server, which reads an untrusted data structure (u_isp_event) from the user space with copy_from_user. This terminates the execution gracefully.CVE-2016-0802: this is a buffer overflow in the 1 s t a t i c l o n g msm_ioctl_server ( s t r u c t file * file , v o i d * fh , bool valid_prio , i n t cmd ,v o i d * arg ) 2 { 3 ... 4 i f ( copy_from_user (& u_isp_event , 5 ( v o i d __user *) ioctl_ptr -> ioctl_ptr , 6s i z e o f ( s t r u c t m sm_ is p_ ev en t_ ct rl ) ) ) { 7... 8 } 9. However, this fix is less favorable because the patch has to parse the packet structure by itself and it is placed differently from where the source-code patch modifies the control flow, i.e., where the error handling is guaranteed to work. raw , 7 + len -2 , 8 & event , & data ) ; 9... 10 } 11 s t a t i c i n t dhd _wl_ho st_eve nt (...) 12 { 13...14 - if ( dngl_host_event ( dhd_pub , pktdata ) == BCME_OK ) { 15 + if ( dngl_host_event ( dhd_pub , pktdata , pktlen ) == BCME_OK ) { 16 ... 17 } 18 i n t dngl_host_event (...) 19 { 20 ... 21 + if ( datalen > pktlen ) 22 + return ( BCME_ERROR ) ; 23... 24 } Figure 7: Source-code patch for CVE-2016-0802 Given a target kernel K t , we first identify candidate functions (F t ) in K t that may contain the same vulnerability as reference function F r . To find matches of function F r in target kernel K t , we first extract the symbol table from K t 's binary 3 and search in it for the name of F r . We collect callers and callees of function F r in the reference kernel's graph, and try to locate nodes in the target kernel's graph that have similar call relations to these two sets of functions. We do not take stack writes into consideration because the same function may have different stack layouts in two kernels.To compare their semantics, we symbolically execute the basic blocks of F r and F t and generate constraints for memory writes and function calls. External inputs to these two functions, such as initial register values, non-local memory reads, and sub-function returns, are symbolized.KARMA supports two modes of operation: in the strict mode, we require that two matching constraints are exactly the same, except for constants. If they are more restrictive in F t than in F r (i.e., conditional checks are added in F t ), the function may have already been patched. Free the allocated memory for live patching get_callee Locate a callee that can be hooked search_symbol Get the kernel symbol address current_thread Get the current thread context read_buf Read raw bytes from memory with the given size read_int_8Read 8 bits from memory as an integer read_int_16Read 16 bits from memory as an integer read_int_32Read 32 bits from memory as an integer read_int_64Read 64 bits from memory as an integer used by patches to read kernel data. Table 4 lists these APIs, which provide the following functionalities: 1) symbol searching: return the run-time address of a symbol; 2) function hooking: hook a given function/sub-function in order to execute the patch before/after the function is called; 3) typed read: given an address, validate whether the address is readable and return the (typed) data if so; 4) thread-info fetching: return the current thread information, such as its thread ID, kernel stack, etc. If no malicious inputs are detected, the patch returns zero to the trampoline, which in turn restores the context, executes KARMA supports two methods to dispatch a patch, one for each of the two execution contexts: the interrupt context or the thread (or process) context. In the following, we describe how KARMA can prevent some interesting kernel vulnerabilities used in one-click rooting apps and recent malware incidents [5,17,18,21]. KARMA can patch this vulnerability by validating whether the memory to be mapped is within the user space.CVE-2013-2596 (MotoChopper): an integer overflow in the fb_mmap function allows a local user to create a read-write mapping of the entire kernel memory and consequently gain the kernel privileges. Specifically, the function has a faulty conditional check: if((vma->vm_end -vma->vm_start + off)>len) return -EINVAL; Because off is a user-controlled variable, an attacker can pass in a really large number to overflow (vma->vm_end -vma->vm_start + off) (the result is interpreted as a negative number) and bypass the validation. Specifically, the opcode-based clustering classifies kernel functions by types and frequencies of instruction opcodes; the syntax-based clustering classifies kernel functions by function calls and conditional branches; and the semantic-based clustering classifies kernel functions according to KARMA's semantic matching results. Considering the fact that most critical kernel vulnerabilities exist in less-hot code paths (e.g., device drivers' ioctl interfaces as shown in Table 6), we consider KARMA's performance is sufficient for real-world deployment.The first benchmark measures the whole system performance with CF-Bench. We tested the performance of the following four configurations: the original kernel without any patches, the kernel with the patch for Towelroot, the kernel with the patch for PingPong root, and the kernel with both patches. We inserted a hook point in the execution path of a selected syscall (i.e., the patch was always executed for this syscall) and measured the execution time of the syscall under the following conditions:• The patch simply returns 0. In addition, Android O formalizes the interface between the Android framework and the vendor implementation so that, eventually, the Android framework can be updated independent of the vendor implementation (aka. Executing patches on the Lua engine also negatively impacts the performance, especially if the system is under heavy load (in reality, this is not a concern because most Android kernel vulnerabilities are on the kernel's cold paths, such as device drivers' ioctl functions, as shown in Table 6). We are investigating alternative designs that can achieve similar security guarantees, such as BPF [8] and sandboxed binary patches.Third, KARMA leverages the existing error handling code in the kernel to handle filtered malicious inputs, in order to keep the kernel as stable as possible. If KARMA's automated adaption cannot find a proper function to patch, we can fall back to the binary patch for this particular vulnerability.Lastly, KARMA is a third-party kernel live patching system. They differ in how patches are applied: kpatch stops all the running processes and ensures that none of these processes are running inside the function to be patched (similar to KARMA). Specifically, the kernel code active at the time of patching (e.g., system calls, kernel threads, and interrupt handlers) is dispatched to the original version until it reaches a completion point; all other code is dispatched to the patched version. Compared to existing kernel live patching systems, the unique features of KARMA are that it can automatically adapt a reference patch for many Android devices, and it strictly confines the run-time behaviors of its patches. Case Studies A. 1 CVE-2014-3153 (Towelroot) this vulnerability is the second most-used one to root Android devices, known as "Towelroot". Therefore, Android kernel vulnerabilities pose a serious threat to user privacy and security.Tremendous efforts have been put into finding (and exploiting) Android kernel vulnerabilities by both whitehat and black-hat researchers, as evidenced by the significant increase of kernel vulnerabilities disclosed in Android Security Bulletin [3] in recent years. If the function has been inlined, the target kernel's call graph contains direct edges from the caller set to the callee set (instead of connected through F r ). This data set is representative of the current Android market: these images come from 520 popular old and new devices, feature Android versions from 4.2 to 7.0, and cover kernels from 2.6.x to 3.18.x. For example, a single reference patch for the largest cluster of perf_swevent_init can be applied to 96.3% of the vulnerable kernels.We randomly picked some functions to manually verify the outcome of semantic matching. However, restoring external resources (e.g., sockets) is often problematic for checkpoint-and-restore systems, including KUP.Semantic matching: the second category of the related work includes systems that compare semantics or similarity of two functions [31,32,39,40]. They can be protected by filtering these inputs.Kernel vulnerabilities, especially exploitable ones, are often triggered by malicious inputs through syscalls or external inputs (e.g., network packets). Furthermore, we added the support to name spaces in our Lua engine and extended the Lua