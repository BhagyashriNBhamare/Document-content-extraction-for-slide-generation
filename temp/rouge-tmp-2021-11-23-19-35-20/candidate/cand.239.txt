Chrome fuzzers run 24/7 on over 25,000 machines [21] and are combined with dynamic tools that look for low-level memory errors, while Firefox runs at least six fuzzers just for its JavaScript engine [88]. To address the drawbacks of both approaches, we combine them: static analysis, cheap and imprecise, achieves high recall in identifying possible errorsites, and symbolic analysis, expensive and thorough, achieves high precision in reasoning about those errorsites.Sys first uses a static analysis pass to identify potential errorsites. Fine-grained value reasoning means that symex can find bugs that static can't, but also makes symex routinely intractable, even for small programs: it reasons about all possible values, whereas simple static analysis reasons primarily about dataflows.Sys sidesteps the symex bottleneck by only symbolically executing small snippets of code that the static analysis pass flags as potentially buggy. Finally, the mystery patch row indicates patches that are unaccounted for: they patch bugs that Sys found, but because of backports, we can't tell when they were patched.Finally, we designed Sys to be flexible, because real-world checking is a game of iterative hypothesis testing: in our experience, it takes many tries to express a property (e.g., use of uninitialized memory) correctly, and many more to suppress false positives-and both tasks often take advantage of ad hoc, program-specific information. We wanted Sys to combine the flexibility of a standard static checking framework (e.g., the Clang Static Analyzer [87,151]) with the power of a symbolic execution engine.The challenge of building a flexible symbolic checking tool is that symex is inherently complicated-it has to reason about each individual bit in the program under test-but flexibility requires that using and changing the system be easy. Finally, Sys is different enough from other checking tools that it can be used to check the checkers themselves (and vice versa): one of our bug reports [12] helped Firefox developers fix a configuration problem in the Coverity commercial checking tool. The design of a simple, extensible, DSL-based symbolic checking system that makes it possible to experiment with new checking techniques. As a rough measure of complexity, Sys is only 6,042 lines of code ( §3). It is easy to write new checkers (our static extensions are < 280 LOC; our symbolic checkers are ≤ 110 LOC), add false positive suppression heuristics ( §5.1,5.2), and even extend the core system ( §3). We walk through Sys's three steps below: (1) statically scanning the source and marking potential errors, (2) jumping to each marked location to check it symbolically, and (3) reasoning about state that Sys misses because it skips code.Static Clients write small static extensions-similar to checkers that identify patterns in source code-to quickly scan all checked code and mark potential errorsites (Figure 4). It receives either UNSAT if the path's constraints can never evaluate to true, or SAT if the path's constraints can.The symbolic checker, in Figure 5, uses information that the static extension marked to figure out if an out-of-bounds write is possible. Sys applies this particular checker once it has finished symbolically executing a path.Symbolic checkers have control over which code to skip, where to start executing along the marked possible-error path, and even which functions to enter or avoid. 5 For example, the checker in Figure 5 runs on each function with a marked malloc call, and it runs after Sys has finished symbolically executing the whole path; other checkers match on specific LLVM IR instructions and run at different points along the path. For example, Sys will find the bug in Figure 2 even if the elided code does many different memory operations, as long as these operations don't touch the nColumn field.3. For example, the checker that found the SQLite bug makes different assumptions about integer inputs compared to object fields: it assumes that integer inputs can be anything, while object fields have been vetted, and so must not be massive ( §5.2). Everything from prototyping checkers to hacking on the core system to suppressing false positives with ad hoc information-like the massive-value suppression in the previous section-had to be easy and fast. Even turning an LLVM variable into a solver's internal representation-a fixed-width vector of bits called a bitvector-is complicated: if the variable is a struct, is it padded, and if so, how much padding goes between each element? In contrast, many checking systems have a special, internal interface that built-in checkers use, and a bolted-on, external interface for "extensions." Running checkers on bytecode is even more suboptimal in some ways, but we do it because: (1) it makes communication between the static and symbolic passes simple; (2) we can check any language that emits LLVM IR; (3) it lets us "see inside" complicated C++ code for free; and (4) it allows our checkers to comprehend and take advantage of compiler optimizations ( §6). We ran into similar problems using angr [131] (e.g., solver crashes due to adding variables of incompatible bitwidth), but with the addition of Python dynamic type errors. In particular, with SysDSL, users can create symbolic variables and constants from LLVM ones; perform binary op- erations, assignments, comparisons, and casts on these variables and constants; set and get fields in symbolic aggregate structures; and, load and store to symbolic memory. Given address addr and value val, the LLVM atomicrmw instruction: (1) reads the value, oldValSym, at address addr; (2) performs the given operation (e.g., addition) with oldValSym and val; (3) writes the result back to addr; (4) returns oldValSym.First, and most importantly, SysDSL eliminates a whole class of type and logic bugs that arise from operating on raw SMT bitvectors. If, say, addr is 32-bits in an LLVM file that specifies 64-bit pointers, the SysDSL will exit with an error.Second, SysDSL exposes functions that are polymorphic over LLVM types to reflect LLVM's polymorphism-e.g., that rmwOp (line 10) operates on all widths of integer and vectors-and to simplify both the symex engine and checker implementations. First, modern constraint solvers have much better support for arrays, and second, Sys's much smaller window size means that there are simply many fewer memory accesses to handle. Double-, triple-, quadruple-(or more) indirect pointers take no special effort; ***p == 0 simply becomes mem[mem[mem [p]]] = 0. Checking tools often need to associate metadata with memory locations. This restriction goes a long way to defeating the point of symbolic checking, since (among other issues), the checker will miss all errors where a pointer could point to both initialized and uninitialized locations.The standard approach that dynamic tools like Valgrind [106], Purify [82], and Eraser [123] take is to associate each memory location m with a corresponding shadow memory location m that stores metadata about m. To the best of our knowledge, UC-KLEE is the only symbolic tool with shadow memory, and it was a 5-10KLOC effort that no tool (that we know of) has since replicated.Sys implements shadow memory as well-easily, in twenty lines and an afternoon, because it represents memory as a single flat array. Effectiveness: can we use Sys to find new security bugs in aggressively tested, huge codebases without sieving through thousands of false positives?We answer these questions by implementing three checkers that look for two kinds of classic memory safety bugs-use of uninitialized memory and out-of-bounds reads and writesin browser code, and one system-specific checker that finds unvalidated use of untrusted user data in the FreeBSD kernel.Workflow We built and debugged checkers on parts of browser code (e.g., the Prio or Skia library) on our laptops. They direct developers to use sanitizers [24] and Valgrind [106], and recently rolled out the ASan Nightly project, where regular users browse the web with ASan enabled-any error triggers an automatic bug report, and any cash bounties are awarded to the user [67]. Firefox also runs the Infer static analyzer [15] alongside their Coverity scans (integrated in 2006) [20], which resulted in many thousands of bug fixes.How good are the bugs we find? Our checkers focus on low-level errors like uninitialized memory and buffer overflows because these are the same bugs that almost every tool we mention in this section detects-so finding these bugs is a better test for Sys than finding errors that other tools have never tried to find. The Prio bugs have existed since Prio's introduction last year ( §5.1), the SQLite pattern has existed for at least nine years ( §5.2), and the Opus codec bug has existed for three and a half years ( §5.3). Symbolic checker: uses Sys's shadow memory ( § 4) to detect uses of uninitialized memory, similar to concrete tools like Valgrind [106] and Purify [82]-with the advantage that it can reason about many possible locations at once (e.g., all locations that a symbolic pointer or a symbolic array index could refer to). A benefit of checking IR: checking IR means that we see any compiler-generated code, and thus can detect errors in it, or errors in assumptions programs make about it. For example, this uninitialized memory bug from Firefox's Prio library for privacypreserving data aggregation [83] Here, P_CHECKCB checks that upk is null and, if so, goes to cleanup. After looking an NSS bug Sys found [12] (and an audit of NSS for more occurrences of the bug), a triage developer said "at the very minimum, the problem in PRZoneCalloc should be found by something. Our guess for why Sys found so many errors is because this check requires both complicated reasoning (hard for static) and edge case values to trigger problems with bit-widths and integer wrapping (hard for static, dynamic, and humans). The checker approximates this split by assuming that any value coming from inside a data structure has already been checked to be "small." Because they are flexible, we can use them to implement programmatic annotators: rather than manually, laboriously marking each field as safe, we use a few lines of code to mark them all.Section 2 presented the most serious bug this checker found. One of these bugs is in Chrome's LibDRM, an interface for communicating with GPUs [6]: For realistic values, size_items can be large enough to wrap a 32-bit integer but not a 64-bit integer: the size passed to drmMalloc will wrap around to a small value and become the target of huge overflow when memcpy copies the unwrapped number of bytes. The static pass currently ignores indices into: parent class objects, since these objects may have a different layout than child object; dynamically-sized struct fields (i.e., in C++ accesses off the end of arrays of size [1 x type] in structs); single-index out-of-bounds (because of C++ iterators); and union types. In line with previous work [39], this shows how false positives can turn into false negatives: if no one is motivated to go through hundreds of mostly false reports, bugs that a tool finds will never get fixed.Semmle We also ran Semmle's default stack uninitialized memory checker-the cpp/uninitialized-local queryon Firefox commit cbd75df. It spent roughly twenty-four hours in a profiling function before we stopped it, and it did not detect any errors.We did not run KLEE on Firefox largely because our angr experiment: since UC symbolic execution doesn't scale to the browser, full symbolic execution is even less likely to. The false-positive suppression ignores UAFs in reference counting code.The final checker (110 LOC extension, 80 LOC symbolic) flagged a true positive bug in Firefox (in the HarfBuzz text shaping engine), which was fixed within a few hours of our report [14]. We consider these improvements future work.Using Sys to check other systems Though we explicitly designed Sys to be extensible, existing Sys checkers can be used without modification, too. For example, the program analysis team at a large company used Sys to check their custom operating system, which has been analyzed and tested for seven years since its initial release. We ran each of these experiments on Firefox's Prio library, since it contains at least three uninitialized memory bugs, and Sys found these bugs in its default configuration.Optimization level We ran the uninitialized memory checker on optimization levels O0-O3, Os, and Oz, because LLVM IR for the same program looks different across levels. Sys does not find bugs at the lowest optimization levels because its static analysis pass matches on patterns more common in production builds; future work is understanding if Sys can find additional bugs at different, higher optimization levels in the browser, and determining whether building static analysis specifically for lower optimization levels can yield new bugs, as well. Moreover, angr (for example) could implement our scaling strategies, or we could modify Sys to symbolically execute whole functions or programs.Though Sys has a lower false positive rate than other UC implementations-angr's version has "a false positive rate of 93%, in line with . . . UC-KLEE['s]" [131]-it still produces false reports. In the future, we plan to eliminate the easy half by jumping back to callers and re-checking for bugs.Sys, like all extensible checking systems (e.g., Pin [98], angr [131], Semmle [126], etc.), requires users to write new checkers if they want to find new styles of bugs; users may obviously re-use any existing checkers to find new bugs in different systems. Though Saturn found many locking bugs in the Linux kernel, the tool is not designed to check large C++ codebases (e.g., it relies on a custom front-end compiler and IR that models C, and does not let users encode heuristics or false positive suppressions). In our experience these low-level interfaces also make it hard to use for bug-finding (e.g., from debugging checkers and heuristics to modifying the tool itself to adding support for multi-threaded execution; §3). This problem matters less for them, since they check code that is orders of magnitude smaller than browsers.The Dowser system finds buffer overflow vulnerabilities by combining fuzzing, program analysis, and symbolic execution: it performs static analysis to identify complicated program pieces, and then uses combined symbolic execution and fuzzing to steer the program towards the target lines [81]. Gadelha et al. [71] implement an extension to the Clang Static Analyzer that reduces false positives by encoding the path constraints leading to a bug as SMT constraints; if the constraints are unsatisfiable, it suppresses the bug report (e.g., they find 7% of bugs to be unreachable). Our work can be seen as a response to UC-KLEE's (and later, angr's) open challenge to reduce the false positive rate of underconstrained symbolic execution of single versions of functions.Chopper [140] deals with undefined state by avoiding it: it lazily executes any state that the path under analysis requires. Bergan et al. [38], like our work, allows symbolic execution to start at any program point; they, however, tackle the undefined state challenge by using context-specific data-flow analysis to soundly over-approximate the state. Finally, for more information on the benefits and drawbacks of underconstrained symbolic execution compared to traditional symbolic execution-in other words, information on the impact of skipping code-Ramos [113] directly compares KLEE and UC-KLEE along a number of axes (e.g., scalability, false positives, etc).