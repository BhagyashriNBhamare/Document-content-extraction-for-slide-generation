üSpark comprises two key ideas: (i) endowing low-level system software with abstractions found in higher-level languages (e.g., objects, interfaces, function-call semantics for implementations of interfaces, access control on interfaces , concurrency and serialization), enforced using a combination of commodity hardware mechanisms and lightweight static analysis; and (ii) interfacing with platform hardware by programming in Assembly using an idiomatic style (called CASM) that is verifiable via tools aimed at C, while retaining its performance and low-level access to hardware. Problem -The unbridled growth of these extensible hypervisors, while enabling useful functionality, † In the fictional Transformers universe, the AllSpark is a powerful object capable of creating a new Transformer by bestowing ordinary machinery with sparks -the building blocks of a Transformer. In a similar vein, ÜBERSPARK bestows ordinary hypervisors with verifiable objects (ÜOBJECT) for automated compositional security analysis. Solution -We address this challenge by developing überSpark (üSpark), an architecture for building extensible hypervisors that: (a) is compatible with commodity systems; (b) enables automated compositional verification of security properties; and (c) produces performant systems. A third group of special üAPI üobjects allow access to shared resources enabling state-of-the-art tools for automatic verification of sequential C code to be soundly applied to verifying security properties, while still allowing multithreaded high-performance applications.In keeping with our first and second design goals, üSpark enforces verifiable-object abstractions using a combination of commodity hardware mechanisms (pagetables and de-privileging) and light-weight static analysis, leveraging off-the-shelf C99 source-code analysis and certified-compilation tools. We use standard and custom Frama-C plug-ins to perform static verification checks that include: per-üobject behavioral contracts (via a standard weakest-precondition plug-in); abstract variable assertions that enable behavioral asserts as well as üobject control-flow integrity (via a standard abstract-interpretation plug-in on stack frames and other variables); syntactic checks that ensure conformance with a restricted C99 syntax and logical de-privileging of üobjects (via a standard abstract syntax tree analysis plug-in); and, composition checks that enable client üobjects that share a common server üobject to compose soundly (via a custom composition-check plug-in). Static analysis enforces logical deprivileging of those objects -e.g., a hypervisor module running in host-mode ring 0 is precluded from accessing page-table structures, thereby being "logically" deprivileged -while control transfer between them does not involve a context switch, thereby significantly helping with system performance, our third design goal. Contributions -(a) We present üSpark, an innovative architecture providing verifiable object abstractions for automated compositional verification of hypervisor security properties while targeting commodity compatibility and performance ( §4, §5). The hypervisor and extensions are written in C and Assembly.The hypervisor leverages CPU capabilities, such as memory-mapped I/O (MMIO) and legacy I/O, for system-to-device interaction; it initializes boot CPU (BSP) state; it sets up memory page tables, as well as device allocations and DMA protections (e.g., via an IOMMU); it initializes multi-CPU support via the Local Advanced Programmable Interrupt Controller (LAPIC) and activates other CPUs and sets up their memory page tables and appropriate protections. Consider now adding two new verified extensions to the hypervisor: hyperdep, which ensures that guest-VM data pages are non-executable; and (b) sysclog, which ensures that every system call issued by the guest is logged via a dedicated network card to an external trusted entity on the network. Goals -Our overarching goal is to enable development of performant extensible hypervisors offering proofs of wide-ranging properties on their code, including low-level memory safety, control-flow guarantees, and information flow, as well as higher-level properties such as trusted network logging (sysclog) and data execution prevention (hyperdep), going all the way up to security properties spanning both hardware and software states (IOMMU, LAPIC, network-card and CPU). Our development and verification approach must integrate into the existing hypervisor C and Assembly language programming ecosystem, and cover the entire source code base including commodity hardware and guest OS. This separates the concerns of showing how a complex low-level system achieves low-level formal properties from how those low-level properties refine a high-level abstract model; we focus on the former, since it is a hard and as yet open problem, whereas much on-going work tackles the latter [31], [42]. We assume that our hardware TCB is functionally correct, and we have load-time integrity, i.e., the verified hypervisor is the one securely loaded onto the hardware at boot time. In contrast to prior code-level verification approaches ( §10), CASM supports two-way nested C to Assembly calling with full device modeling. Prime is verified to satisfy its contract which is: to set up the required system interfaces and associated policies, establish operating stacks, prepare the platform CPU cores, invoke the init methods of other üobjects to initialize their state, and kick-start üobject interactions. For example, an extension can be split between a top half and a bottom half as with traditional device drivers (in our case study, sysclog could shed its networking code into a separate üobject, sysclognw, that only takes transmission requests from sysclog, and is the only authorized user of a separate NIC dedicated to logging), ensuring that only the top half may invoke the bottom half at runtime, while still keeping the two isolated from each other and independently verifiable. It is held to the property that it can only use the resources declared in its manifest.For verified üobjects, üSpark employs a hardware model identifying CPU interfaces to system resources (e.g., I/O and designated memory instructions interface to system devices, instructions that can modify CPU model specific register states, etc.) and static analysis to ensure that access to those interfaces respects the üob-ject's manifest ( §7). Client üobjects must satisfy the property that whenever they invoke a üAPI call, they obey their own use manifest, and üSpark discharges this property via static analysis on verified üobjects or runtime sentinel checks for unverified üobjects. The üBP is a high-level control-flow graph that divides hypervisor execution into three phases: startup, intercept, and exception handling which can in turn be customized based on the actual number of system üob-jects and their interactions (Figure 2; §6). Each invariant is proved by reducing it further to a set of proof-assumptions on hardware (PAHs) and proof-obligations on code (POCs) using the üSpark blueprint (üBP; Fig. 2). A üobject CASM program is a CC99 program such that: (i) all Assembly code appears only in CASM functions; and (ii) these CASM functions preserve the caller C functions' CPU register state.Given a üobject CASM program, we are interested in verifying two kinds of properties: (1) invariant properties: whether ϕ holds at every state (after every instruction), and (2) individual state assertions: whether ϕ holds at specific program points. Verification tools such as Frama-C ( §7) take programs annotated with properties to be checked and decide whether the properties hold on all execution traces of the program.We begin by stating two üSpark theorems essential for the correctness of our approach, which follow directly from the üSpark programming invariants (Appendix A). Finally, for each CPU in the system, prime: (a) activates protected-mode with paging and hypervisor-mode via control registers CR0 and CR4 and the VMXON instruction; (b) sets up SYSENTER MSRs, interrupt descriptor table and VM control structure (VMCS) to transfer control to the sentinel; and (c) loads vh page tables in CR3 and transfers control to xcstrt core startup üobject. üObject Runtime Library -üObjects rely on a set of common functionality implemented in the following libraries: (a) libuc with memory and string functions; (b) libucrypt with SHA-1 functionality; (c) libustub with üobject entry and sentinel CASM stubs; and (d) libuhw for platform hardware access. We built üSpark-specific plugins on top of Frama-C as follows: (a) übp -enforces üSpark blueprint; (b) ühwm -embeds hardware model during verification; (c) ücasm -substitutes Assembly mnemonics corresponding to CASM instructions after verification; (d) ücc -enforces general üSpark coding rules; (e) ümf -parses üobject manifest; and (f) ücvf -performs composition check ( §7.2.1). First, since current state-of-the-art static analyzers including Frama-C largely assume sequential execution, we treat all reads to DMA memory and all memory reads by a concurrent üobject as non-deterministic, for verification to soundly model interference from devices and other cores. POC Verification: For brevity, we choose a sampling of POCs from a few üSpark invariants (Inv 4 ü , Inv 6 ü , Inv 6 üprog , Inv 7 üprog , and Inv 10 ü ; see Appendix A and [73]) that showcase the importance of all the verification techniques described in §7.1.1. Note that examples described below are necessary (but not sufficient since they are a sample) for the high-level proofs; for example the NESTEDCALL theorem ( §5) cannot be proved if there is no non-overlapping, unity-mapped memory (Inv 4 ü ) or DMA protection (Inv 6 ü ). Similar AST-based techniques are employed to: (a) embed hardware model statements, (b) substitute Assembly mnemonics, and (c) ensure soundness of the hardware model by precluding C functions from touching hardware model functions and variables and vice-versa. Frama-C üSpark specific plugins (totaling 1021 SLoC of OCaml; Fig- ure 7) are modular, simple, and built upon the existing Frama-C kernel and plugins making them amenable to manual audits. A fraction of the time was spent adding implementation support for multiple hypapps with a greater part spent on porting to the üSpark hypervisor architecture by creating required üobjects and adding verification related harnesses and annotations. For transitions involving unverified üobjects the sentinel overhead is broken up into: (a) software overhead such as register saving, parameter marshalling, and call-policy enforcement; and (b) hardware deprivileging overhead. Verified sandboxing -SFI [52], [54], [60], [76], [82] is a software-based approach for application-level memory isolation but lacks support for low-level privileged instructions and hardware device access, which are necessary for hypervisor and its extensions. Singularity [36] sacrifices legacy compatibility with a complete redesign of a OS written in type-safe languages (MSIL/TAL) and uses software mechanisms to isolate processes (SIP) and supports only memory and type-safety properties. Lastly, both mCertiKOS and seL4 require the developer to write line-for-line specifications for C/ASM code in a different abstract language (Isabelle/HOL or Coq/Ocaml/Lasm) with a very steep learning curve. Further, that effort assumes interface confinement and leaves out 422 C and 388 ASM SLoC due to limitations of CBMC with largeloops and lack of a hardware model. Verified System Stack -In Verve [81], a simplified OS and applications are verified for type and memory safety using a Hoare-style verification condition (VC) generator and automated theorem proving. Verisoft [6] integrates hardware and software, with high-level specifications written in C0 (a tiny subset of C semantics) and refined down to a custom CPU semantics. In the future, we plan on leveraging recent developments with Compcert such as the ability to compile and link multi-module source programs [68] to cleanly extend the bi-simulation proof of the CompCert compiler to encompass hardware state and Assembly code. Future work also involves proving (e.g., via bi-simulation) the semantic equivalence between the hardware model and the corresponding Assembly instructions and demonstrating the semantic synergy between CompCert, CASM and the Frama-C kernel more rigorously for proved properties to translate to the binary. However, we do realize the importance of relaxing our serialized execution model especially in high-performance computing environments and plan on leveraging source-level multi-threaded verification (e.g., Frama-C mthread plugin [24]) to address concurrency in the future. We incrementally developed and verified a commodity x86 micro-hypervisor using üS-park, and performed a comprehensive evaluation which shows automated compositional verification with modest development effort and minimal runtime overhead.Availability: ÜBERSPARK and ÜXMHF sources are available at: http://uberspark.org Inv 1 ü üSpark begins execution with the entry point of a distinguished initial "prime" üobject sI in singlecore mode with just core 1 activated Inv 2 ü A special "asynchronous" function startcores(s) activates all cores i > 1 and begins executing a designated üobject s immediately thereafter; all cores remain active thereafter for the system lifetime. On system call trap intercept, log syscall information to network log buffer sysclognw vh Log info in network log buffer and transmit buffer when full aprvexec uh Guest OS approved code pages are always marked read-only and executable For the ugmpgtbl üobject we verify that the setentry method's entry parameter does not fall within hypervisor memory regions.