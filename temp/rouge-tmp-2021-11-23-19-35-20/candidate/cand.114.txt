To stop side channel attacks on CPU caches that have allowed attackers to leak secret information and break basic security mechanisms, the security community has developed a variety of powerful defenses that effectively isolate the security domains. In this paper, we revisit this assumption and show for the first time that hardware translation lookaside buffers (TLBs) can be abused to leak fine-grained information about a victim's activity even when CPU cache activity is guarded by state-of-the-art cache side-channel protections, such as CAT and TSX. However, exploiting the TLB channel is challenging, due to unknown addressing functions inside the TLB and the attacker's limited monitoring capabilities which, at best, cover only the victim's coarse-grained data accesses. Our prototype implementation , TLBleed, can leak a 256-bit EdDSA secret key from a single capture after 17 seconds of computation time with a 98% success rate, even in presence of state-of-the-art cache isolation. Given that attackers can find many new sources of timing [17,34,49], CPU cache partitioning is currently the only known generic mechanism that stops existing attacks.Unfortunately, as we will show, protecting only the shared data and instruction caches is insufficient. Armed with this information, we build TLBleed, a side-channel attack over shared TLBs that can extract secret information from a victim program protected with existing cache defenses [9,21,31,37,52,62] Implementing TLBleed is challenging: due to the nature of TLB operations, we can only leak memory accesses in the coarse granularity of a memory page (4 KB on x86 systems) and due to the TLB architecture we cannot rely on the execution of instructions (and controlled page faults) to leak secret information similar to previous page-level side-channel attacks [58]. To overcome these limitations, we describe a new machine learning-based analysis technique that exploits temporal patterns of the victim's memory accesses to leak information.Contributions In summary, we make the following contributions:â€¢ The first detailed analysis of the architecture of the TLB in modern processors including the previously unknown complex function that maps virtual addresses to TLB sets. For instance, if the adversary first occupies all the n ways in a cache set and after some time observes that some of these cachelines are no longer in the cache (since accessing the data now takes much longer), it must mean that another programa victim process, VM, or the kernel-has accessed data at addresses that also map to this cache set. Closely related is FLUSH+RELOAD, which relies on the victim and the attacker physically sharing memory pages, so that the attacker can directly control the eviction (flushing) of a target memory page. We again discuss the most prominent ones here.Isolation by partitioning sets Two processes that do not share a cache cannot snoop on each others' cache activity. As the mapping from to a cache set involves the physical memory address, this can be done by the operating system by organizing physical memory into non-overlapping cache set groups, also called colors, and enforcing an isolation policy. All the existing cache side-channel attacks and defenses focus on exploitation and hardening of shared CPU caches, but ignore caching mechanisms used by the Memory Management Unit (MMU). For performance reasons, the result of these translations are aggressively cached in the Translation Lookaside Buffer (TLB). More specifically, how do virtual addresses map to multi-level TLBs found in modern processors?Q2 How do sibling hyperthreads share the TLB sets for translating their code and data addresses?Once the attacker knows how to access the same TLB set as a victim, the question is whether she has the ability to observe the victim's activity:Q3 How can an unprivileged process (without access to performance counters, TLB shootdown interrupts, etc.) monitor TLB activity reliably?Finally, once the attacker can reliably measure the TLB activity of the victim, the question is whether she can exploit this new channel for attractive targets:Q4 Can the attacker use the limited granularity of 4 kB "data" pages to mount a meaningful attack? As we shall see, we found that even on a single processor, the mapping algorithms in the different TLBs vary from very simple linear translations to complex functions that use a subset of the virtual address bits XORed together to determine the target TLB set.To understand the details of how the TLB operates, we need a way to reverse engineer such mapping functions on commodity platforms, recent Intel microarchitectures in particular. The smallest w generating evictions is 4, and the smallest cor- Complex-mapped TLB If our results prove inconsistent with the linear mapping hypothesis, we must reverse engineer a more complex hash function to collect eviction sets (Q1). Thus, we assume that the TLB set number can be expressed as an XOR of a subset of bits of the virtual address, similar to the physical hash function for CPU caches.To reverse engineer the hash, we first collect minimal eviction sets, following the procedure from [42]. As shown in the table, most TLB levels/types on recent Intel microarchitectures use linear mappings, but the L2 sTLB on Skylake and Broadwell are exceptions with complex, XORbased hash functions. This implicitly means that attacks that require L1 TLB evictions are challenging in absence of L1 TLB sharing, similar, in spirit, to the challenges faced by cache attacks in noninclusive caching architectures [18]. Moreover, as shown in the figure, only the L1 dTLB and the L2 sTLB show a clear interference between matching pairs of sets, demonstrating that such TLB levels/types are shared between hyperthreads while the L1 iTLB does not appear to be shared. We proceed as follows: asm volatile ( "lfence\n" "rdtsc\n" "mov %%eax, %%edi\n" "mov (%2), %2\n" "mov (%2), %2\n" "mov (%2), %2\n" "mov (%2), %2\n" "lfence\n" "rdtscp\n" "mov %%edi, %0\n" "mov %%eax, %1\n" : "=r" (time1), "=r" (time2) : "r" (probe) : "rax", "rbx", "rcx", "rdx", "rdi"); : Memory access latency determining TLB hit or misses. We can now rely on unprivileged memory access latency measurements to reliably distinguish TLB misses from TLB hits and hence monitor the activity of the victim over shared TLBs in practical settings. When targeting sensitive cryptographic applications, previous work on controlled channels focused on leaking the secret using code pages due to the difficulty of extracting secrets using page-granular data accesses [58]. In other words, this is a non-trivial challenge, especially given our side-channel rather than controlled-channel attack scenario.To investigate the extent of this challenge, we pick an example target, libgcrypt, and target its elliptic curve cryptography (ECC) multiplication function, shown in Figure 9. Hence, due to (page-level) sidechannel coarsening, TLB attacks cannot easily rely on traditional spatial access information to leak secrets in real-world attack settings.Looking more carefully at Figure 8, it is clear that some sets are accessed at different times within the execution of each side of the branch. Our monitoring code uses the information provided by the instrumented victim to measure the activity of the target TLB set for each of the two functions that we wish to differentiate.To extract suitable features from the TLB signal, we simply encode information about the activity in the targeted TLB set using a vector of normalized latencies. The peak detection merges spurious peaks/-valleys into one as seen in the first valley, and turns the continuous classification into a discrete bitstream.Identifying the Target TLB Set For the libgcrypt target, we only need to use a single TLB set for training and testing. In this section we select a challenging case study, and evaluate the reliability of TLBleed.Testbed To gain insights on different recent microarchitectures, we evaluated TLBleed on three different systems: (i) a workstation with an Intel Skylake Core i7-6700K CPU and 16 GB of DDR4 memory, (ii) a server with an Intel Broadwell Xeon E5-2620 v4 and 16 GB of DDR4 memory, and (iii) a workstation with an Intel Coffeelake Core i7-8700 and 16 GB of DDR4 memory. 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 Predicted label Figure 11: Classification reliability for distinguishing TLB sets using temporal access patterns. As shown previously in Figure 9, we are interested in distinguishing between the duplication (i.e., _gcry_mpi_ec_dup_point) and addition (i.e., _gcry_mpi_ec_add_points) operations, so that we can distinguish key bits in the secret used in the signature. Given that TLBleed requires a very small capture time, existing re-randomization techniques (e.g., Shuffler [57]) do not provide adequate protection against TLBleed, even if they re-randomized both code and data. Whenever these pointers fall in different TLB sets, TLBleed can detect whether or not this swapping operation has happened, by distinguishing the access activity in the swapped and unswapped cases, directly leaking information about the secret exponent. To validate our hypothesis, our goal is to show that TLBleed can still detect the victim's activity with successful transactions and leak information even when Intel TSX is in effect.Porting libgcrypt's EdDSA algorithm to run inside a TSX transaction requires major source changes since its working set does not fit inside the CPU cache. The second we do the same, but generate two heavy sources of interference: one, we run the libgcrypt signing binary target in a tight loop on the same core; and two, we run stress -m 5 to generate a high rate of memory activity throughout the machine.We find the usable bandwidth under intense load is roughly halved, and the rate of errors that was not caught by the framing protocol does increase, but remains low. This is, however, challenging since almost all applications rely on contiguous virtual addresses for correct operations, which is no longer possible if certain TLB sets are not accessible due to partitioning.It is easier to provide adequate protection against TLBleed in hardware. Aside from the cache attacks and defenses extensively discussed in Section 2.1, there is literature on other microarchitectural attacks exploiting shared resources. The research leading to these results has received funding from the European Union's Horizon 2020 Research and Innovation Programme, under Grant Agreement No. 786669 and was supported in part by the MAL-PAY project and by the Netherlands Organisation for Scientific Research through grants NWO 639.023.309 VICI "Dowsing", NWO 639.021.753 VENI "PantaRhei", and NWO 629.002.204 "Parallax".