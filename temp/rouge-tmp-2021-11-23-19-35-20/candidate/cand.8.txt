Broadly, all existing techniques either require (1) manual effort-API-specific specifications (e.g., SSL in SSLint [26], setuid [10,15]), code annotations (e.g., lock operations in Sparse [41]), correct models (e.g., file system in WOODPECKER [11]), or (2) an accurate analysis of source code [6,7], which is hard to scale to complex, real-world system software written in C/C++. Once APISAN extracts such semantic beliefs, it reports deviations from the beliefs as potential errors together with a probabilistic ranking that reflects their likelihood.A hallmark of APISAN compared to existing approaches [1,18,28,29] for finding bugs by detecting contradictions in source code is that it achieves precision by considering semantic constraints in API usage patterns. We describe eight such cases in APISAN that are tailored to check a variety of properties with security implications, such as cryptographic protocol API misuses, integer overflow, improper locking, and NULL dereference.Our evaluation shows that APISAN's approach is scal- Figure 1: (a) A memory leak vulnerability found by APISAN in OpenSSL 1.1.0-pre3-dev. To find API usage errors, APISAN automatically infers semantic correctness, called semantic beliefs, by analyzing the source code of different uses of the API.We motivate our approach by means of an example that illustrates an API usage error. For example, considering the use of the OpenSSL API in Figure 1(a) together with other uses of the API shown in Figure 1(b), APISAN infers the majority pattern as freeing the allocated context after initialization failure (i.e., EVP_PKEY_keygen_init() <= 0), and thereby reports the use in Figure 1(a) as an error. These specifications are not expressive enough to capture correct API uses inferred by APISAN; for example, type-state specifications can capture finite-state rules but not rules involving a more complex state, such as the rule in the box in Figure 1(a), which states that EVP_PKEY_CTX_free() must be called if EVP_PKEY_CTX_init() <= 0. Moreover, techniques for checking such rules must track the context of the API use in order to be precise, which limits their scalability. However, functions such as EVP_PKEY_keygen_init() in Figure 1 contain a function pointer, which is hard to resolve in static analysis, and cryptographic functions have extremely complex path constraints that pose scalability challenges to symbolic execution based approaches. Finally, it locates API misuses in the programs' source code using the inferred beliefs and domain-specific knowledge if necessary ( §3.3, §4). We formalize our approach as a general framework, shown in Figure 5, which can be tuned using two parameters: the context checking function, which enables tailoring the checking of symbolic contexts to different API usage aspects, and an optional hint ranking function, which allows customizing the ranking of bug reports. These results, represented in the form of symbolic constraints, on one hand contain precise semantic information about each individual use of an API, and on the other hand are abstract enough to compare across uses of the API even in different programs. The key insight behind our approach is that the "correctness" of API usages can be probabilistically measured from existing uses of APIs: that is, the more API patterns developers use in similar contexts, the more confidence we have about the correct API usage. APISAN automatically infers correct API usage patterns from existing source code without any human intervention (e.g., manual annotation or providing an API list), and ranks potential API misuses based on the extent to which they deviate from the observed usage pattern. The key challenge of building symbolic contexts in large and complex programs is to overcome the path-explosion problem in symbolic execution.We made two important design decisions for our symbolic execution to achieve scalability yet extract accurate enough information about symbolic contexts. = NULL d→ports[0] == NULL return IRQ_HANDLED spin_lock(&lock) external call symbolic constraints spin_unlock(&lock)... these two design decisions within the context of finding API misuses, and provide a performance optimization that memoizes the predominant symbolic states. This helps scalability because APISAN can deterministically explore the symbolic execution tree, and all intermediate results can be cached in interior nodes; most importantly, the cached results (i.e., predominant symbolic contexts) can be safely re-used because there is no control flow from a child to its ancestors. APISAN reports such cases that the probability of constraints is below a certain threshold as potential bugs; the lower the probability of correctness, the more likely those cases are to be bugs.Our framework can be easily instantiated to capture return value context by defining the context function returnValueContexts(t, i), as shown in Figure 6, which extracts all checks on the return value of the function called at t[i] (i.e., the i th event in trace t). Typical examples are memory copy APIs, such as strncpy(d,s,n) and memcpy(d,s,n); for correct operation without buffer overrun, the size of the destination buffer d should be larger or equal to the copy length n.APISAN uses a simple heuristic to capture possible relations between arguments. Both direct and constrained causality relationships can be effectively captured in the APISAN framework by defining a parametric context function causalityContexts⟨ ¯ r⟩ shown in Figure 6, which extracts all pairs of API calls with ¯ r as the context constraints between them. Based on the observation that the more the majority patterns repeat, the more confident we are that these majority patterns are correct specifications, APISAN uses the ratio of majority patterns over "buggy" patterns as a measure of the likelihood. A recent study shows that SSL/TLS APIs are very errorprone-especially, validating SSL certificates is "the most dangerous code in the world" [22]. The checker classifies such function calls into three categories: (1) correct check, (2) incorrect check, and (3) Figure 10: An integer overflow vulnerability found in Linux by APISAN. However, detecting a broken relation does not mean that it is always a bug, because there might be an implicit relation between two arguments that cannot be captured by APISAN (e.g., complex pointer aliasing of the buffer). However, in the case of programs that have their own printf-like functions (e.g., PHP), compilers cannot detect such errors.To infer whether a function argument is a format string, we use a simple heuristic: if the majority of symbolic expressions for an argument is a constant string and contains well-known format codes (e.g, %s), then the argument is considered as a format string. As a result, APISAN found 76 previously unknown bugs: 64 in Linux, 3 in OpenSSL, 4 in PHP, 1 in Python, and 5 in the debian packages (see Ta- ble 2 for details). In addition, we found that the vulnerable Python module is in the whitelist of Google App Engine and reported it to Google. Users can generate symbolic execution databases by simply invoking the existing build command, e.g., make, with apisan.1 # generate DB 2 $ apisan makeWith the database, users can run various checkers, which extract semantic beliefs from the database and locate potential bugs in order of their likelihood. For eight types of API misuses described at §4, we developed five checkers: return value checker (rvchk), causality checker (cpair), argument relation checker (args) implicit pre-and postcondition checker (cond), and integer overflow checker (intovfl).1 # run a causality checker 2 $ apisan --checker=cpair 3 @FUNC: EVP_PKEY_keygen_init 4 @CONS: ((-2147483648, 0),) 5 @POST: EVP_PKEY_CTX_free 6 @CODE: {'req.c:1745'} 7 ...APISAN can also be run against multiple databases generated by different project code repositories. APISAN found 7 memory leak bugs and 11 NULL dereference vulnerabilities; two memory leak bugs (marked ⋆) were previously unknown, and our two patches have been applied to the mainline repository. UC-KLEE found five memory leak bugs related to OPENSSL_malloc() with the help of users' annotations.Interestingly, there is no common bug between UC-KLEE and APISAN. To understand what causes false positives, we manually investigated all false positive cases in the top 445 reports, and found a few frequent reasons: diverse patterns of return value checking, wrapper functions delegating return value checking to callers, and semantically correct, but rare patterns.Some kernel APIs, such as snd_pcm_new() [40], return zero on success or a negative error code on failure. We believe that it shows that bug fixing is the essential activity during the entire life cycle of any software, and automatic bug finding tools such as APISAN should be scalable enough for them to be integrated into the daily software development process.Incorrect bug fixes. Unlike these solutions, which are highly specialized for a certain domain (or an API set) and rely on hand-coded rules, APISAN is generally applicable to any domain without manual effort.Inferring semantics. These approaches would be useful in APISAN as well.Automatic generation of specifications has been explored by Kremenek et al. [28] for resource allocation, by PRMiner [29] for causal relations, by APIMiner [1] for partial ordering of APIs, by Daikon [19] from dynamic execution traces, by Taghdiri et al. [43] for structural properties, by PRIME [33] for temporal specifications, by Nguyen et al. [35] for preconditions of APIs, by Gruska et al. [23] for sequences of functions, by JIGSAW [44] for resource accesses, by MERLIN [31] for information flow specifications, and by Yamaguchi et al. [47] for taint-style vulnerabilities. It is defined as follows:if e ≡ uop e ′ argvars(e 1 ,t) ∪ argvars(e 2 ,t) if e ≡ e 1 bop e 2 Function retvars(e) returns all ⟨ret, i⟩ variables in e, which is defined as follows:Function argvars(e,t) returns all ⟨arg, i⟩ variables in e, consulting t to recursively replace each ⟨ret, i⟩ variable by its associated function call symbolic expression.