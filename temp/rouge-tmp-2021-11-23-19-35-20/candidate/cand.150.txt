The security namespace relaxes the global and mandatory assumption of kernel security frameworks, thus enabling containers to independently define security policies and apply them to a limited scope of processes. To preserve security, we propose a routing mechanism that can dynamically dispatch an operation to a set of containers whose security might be affected by the operation, therefore ensuring the security decision made by one container cannot compromise the host or other containers. Containers cannot apply local security policies to govern integrity measurement, code execution, mandatory access control, etc. to prevent application specific security problems. In studying the two popular kernel security frameworks, namely IMA [53] for integrity and AppArmor [41] for mandatory access control, we make the following observations: first, we find that the common challenge for containers to obtain autonomous security control is the implicit global and mandatory assumptions that kernel security frameworks often make. Our second insight is that we can relax the global and mandatory assumptions in a secure way by checking if the autonomous security control of a container may compromise the security of other containers or the host system. • We show that widely used container systems (e.g., Docker and LXC) can easily adopt the IMA and AppArmor security namespace abstractions to exercise full functionality of kernel security frameworks with modest overhead. In the above example, a bank would benefit from IMA to maintain a tightly controlled environment of its servers and enforce that only approved code could be run.In this section, we discuss the need for containers to have autonomous security control, and the fundamental challenges of achieving it. As more critical applications are deployed in containers, container owners want to utilize kernel security frameworks to govern integrity measurement, code execution, mandatory access control, etc. to prevent application specific security problems. Security frameworks need to exercise their control over a limited scope of processes specified by the container owner and security states need to be maintained and accessed separately; this relaxes the global assumption of security frameworks. In this case, the strawman design assigns security control of P 0 to NS native , control of P 1 and P 2 to NS 1 , and control of P 2 to NS 2 . A remote verifier may be tricked into believing the system is of sufficient integrity to use even though a malware was once loaded on the system.this case, the measurements of the malware are stored onto the measurement list of NS 1 , which will be deleted after the namespace exits, leaving no traces behind. Integrity attestation of the native system, in this case, will cause a remote party to believe that the system is of sufficient integrity to use, despite the fact that the malware was once executed on the system. In this example, P managed to execute a malware without leaving a footprint on the system, due to that the native security namespace NS native no longer controls P 1 , and the security namespace NS 1 that controls P 1 is created and controlled by adversary. This example demonstrates that, in a security namespace design, if mandatory assumption of security framework is relaxed in a naive way (e.g., by allowing two or more principals to apply security policies freely), adversary may leverage that fact to launch attacks. Each involved security namespace independently makes a security decision, and the operation is allowed if all involved security namespaces allow the operation.above attack examples show that how to relax the global and mandatory assumption of security frameworks represents a control point in the tussle. It is the design goal of security namespace abstraction to prevent one principal from abusing the abstraction to compromise security of another principal.In this paper, we do not aim to provide an unified abstraction for all kernel security frameworks. The strawman design shown in Figure 2 provides a straightforward way for containers to achieve autonomous security control. This boils down to two security invariant that we believe must be maintained when global and mandatory assumption are relaxed:• Given an operation from a process, all security namespaces that have an opinion about the operation (i.e., expressed via its security policy) should be made aware of the operation. The key challenge in this step is to ensure that every security namespace whose security might be affected by an operation is made aware of the operation; this underpins security while allowing relaxation of the global assumption of security frameworks. Thus, only if all security namespaces that were made aware of the operation allow an operation will it be allowed by the system.Finally, we added a component named Policy Engine that detects and identifies policy conflicts among security namespaces at policy load time. Since a security namespace cannot (and should not) inspect security states of another, debugging the cause of the denial becomes a problem. To decide which security namespace may have an opinion about an operation, we leverage a simple insight: a security namespace may have an opinion about an operation if by not routing the operation to the security namespace, the two security assumptions, global and mandatory, might be broken for the security namespace. P 1 is a descendant of P. However, by assigning security control of P 1 to a new security namespace, security namespace NS Native no longer confines P 1 , therefore breaking the implicit global assumption of NS Native . Therefore, when subjects from NS 1 access the file, security of NS 1 is compromised without NS 1 is being aware of.Due to the assumption of complete control over objects, a security namespace may have an opinion about an operation even if the subject of the operation is not under its control. As a result, theoretically, the Operation Router needs to account for the object's perspective by routing an operation to all security namespaces whose subjects may ever access the object of the operation to ensure that all their security expectations are met.To decide if an object may ever be accessed by subjects of a security namespace, the Operation Router leverages the resource visibility defined by the resource namespaces (e.g., mount, network and etc.). In a security policy, if a security namespace declares authority over an object, its policy over the object becomes mandatory-all the operations over the object, either from subjects associated with the security namespace or other security namespaces, will be routed to the security namespace for mediation. In contrast, if a security namespace does not have authority declared for an object in its security policy, the policy over the object will only be locally effective, meaning that the security namespace will not be able to control how subjects from other security namespaces access the object. However, label {a} will be universal for all the invisible subjects of the security namespace, because from the security namespace's perspective, those subjects are invisible therefore indistinguishable.To prevent a security namespace from arbitrarily declaring authority therefore launching denial of service attacks to other security namespaces, the ability to declare authority is tightly controlled by the system. Combining the two perspectives and the practical constraint, we can then define a routing algorithm for the Operation Router that meets our goal: given an operation, all security namespaces that may have an opinion about an operation are made aware of the operation. The algorithm is constructed around two data structures, namely a security namespace graph and an object authority table which are maintained and updated in the kernel while new security namespaces are being created and security policies are being loaded.A security namespace graph is a graph that maintains the <subject ↔ namespace> and <namespace ↔ namespace> mappings. Between security namespace vertices, there is a directed edge, pointing Input: subject s and object o, security namespace graph G, object authority table T Output: set of security namespaces Φ 1: Φ ←native Native is the ancestor for any security namespace 2: n ←CURRENT(s, G) Get the namespace that s is associated with 3: while n = native do Recursively add all n's ancestors 4:Φ ← Φ ∪ n 5:n ←GET PARENT(n, G) 6: Φ ← Φ∪AUTHORITY(o, T ) Get namespaces that declared authority over o 7: return Φ Figure 6: An algorithm for routing an operation to security namespaces who may have an opinion about the operation.from the child to its direct parent 3 . The object authority table helps capture the object's perspective under the practical constraint when the Operation Router routes and operation.Using these two data structures, we define the routing algorithm as shown in Figure 6. The algorithm takes as input the subject and object of an operation, and produces a set of security namespaces that need to be made aware of the operation. If subjects of a security namespace are forked from subjects of another security namespace, then the two security namespace has a parent and child relationship. At a high Input: set of existing security policies S, new security policy s Output: set of conflicting rules Φ 1: Φ ← / 0 2: S ←ROUTING ALG(S) Set of policies that need to be considered 3: P o ←PERMISSIONS(S ) Projected permissions of S 4: P n ←PERMISSIONS(s) Projected permissions of s 5: if P n ⊆ P o then 6:Φ ←CONFLICTING RULES(P o , P n ) 7: return Φ level, the algorithm takes as input the security policies of existing security namespaces and the new one, and try to identify if the newly loaded security policy would introduce additional access permissions for the subjects. As its name suggests, the expectation conflicts represent that the existing system cannot possibly meet the security expectation of a new security namespace, therefore the owner of the new namespace should either revise her policy, or abort using the system.In practice, there are two types of expectation conflicts, both of which can be easily detected by the Policy Engine using the object authority table. The first type of expectation conflicts is shown in Figure 7(c), where in its security policy a security namespace declares authority over an object but it does not have the capability to declare the authority. Conceptually, each IMA namespace would measure a file independently. Instead, we only virtualized the data structures and interfaces that are exposed to userspace to make it appear that they have their own isolated instance of IMA.File Appraisal and Policy Engine. tect any changes to the base profile so that the Operation Router can be notified to parse the base profile and update its object authority table accordingly.Pathname Collision. By creating a profile namespace per AppArmor namespace and assigning it an identifier, we therefore enable AppArmor namespaces to specify a policy using the combination of profile namespace identifier and the relative pathnames in the profile.Policy Engine. In order for userspace program to create an IMA or AppArmor namespace, we extended the clone and unshare system call. To evaluate autonomous security control, we emulate a security setting identical to most commercial container clouds where container host applies a very lenient integrity policy (i.e., allow any immutable files to be run within the containers). We created three types of malicious code that an attacker may run within a container, i.e., code that was not signed, code signed with unknown key, and modified code with an invalid signature. This experiment demonstrates that IMA namespace enables containers to have their autonomous integrity control, independent from the integrity policy that host system applies.The second experiment evaluates security, by demonstrating that containers cannot leverage IMA namespace to violate the integrity policy of the host. The coarse granularity of policy may be due to the large amount of information on those filesystems, but it creates conflicts.To avoid conflicts, one way is to fine tune security policies, at both application side and container host side. Currently, the AppArmor policies enforced by container hosts are less well understood-it is not thoroughly clear which files under shared filesystems are required by applications at runtime and whether or not they might lead to attacks that can break container isolation. Ideally, we can design a better container host security policy by examining each and every file under these shared filesystems and fine tune it to fit the application 9 , but this can be an extremely challenging task given the large amount of information stored on those shared filesystems and the diversified requirements from the containerized applications. The overhead is almost linear as the number of security namespaces grow 10 , because in our current implementation we used a sequential routing to avoid intrusive modifications to the kernel (i.e., system calls are routed sequentially to all affected security namespaces). However, for small number of security namespaces (e.g., one or two), our experience suggests that the added complexity of synchronization can often outweigh the mediation latency.We also evaluated the macro performance of AppArmor namespace by measuring the throughput of a containerized Apache with and without a default AppArmor profile(on top of a host profile). 10 Here the number of security namespaces is not referring to the total number of security namespaces on a system, but rather the number of security namespaces that the Operation Router routes to. As an example, an web server running in a container can be attached with two labels, native:svirt lxc net t | container:httpd t.The label svirt lxc net t is used by the host system during enforcement of the host's SELinux policy and the label httpd t is used by the container during enforcement of the container's SELinux policy.This approach requires dynamic manipulation of security attributes associated with files during runtime. To address these concerns, solutions were proposed to enhance container management program with authority check [67] and run it with reduced privilege. However, these modifications are often adhoc; they do not provide full functionality of kernel security frameworks to container, and they still rely on a centralized authority (i.e., system owner) to specify a global policy, leaving containers no true freedom in enforcing their security independently 11 .