Further, the study showed that half of the analyzed apps transmit out at least three different sensitive data sources (e.g., device info, device state, user input) via messaging or Internet.Similarly, approximately two-thirds of the apps define at most two separate sensitive sink interfaces and recipients (e.g., remote hostname or URL for Internet and contact information for messaging). If the data flow is deemed malicious or dangerous for the domain or environment, the app can be rejected (from the market) or modified (by the developer) as needs dictate.We make the following contributions:• We introduce the SAINT system that automates information-flow tracking using inter-and intra-data flow analysis on an IoT app. SAINT analyzes the source code of an IoT app, identifies sensitive data from a taint source, and attaches taint labels that describe sensitive data's sources and types. SAINT does not determine whether the data leaks are malicious or dangerous; however, the output of SAINT can be further analyzed to verify whether an app conforms to its functionality and notify users to make informed decisions about potential privacy risks, e.g., when a camera image is transmitted.We focus on home automation platforms, which have the largest number of applications and consumer products [19]. Our discussion is based on a survey, which was performed by reviewing the platforms' official documentation, running their example IoT apps, and analyzing their app construction logic. The cloud backend creates software wrappers for physical devices and runs the apps.The permission system in SmartThings allows a developer to specify devices and user inputs required for an app at install time. They subscribe to device events or other pre-defined events such as clicking an icon; when an event is activated, the corresponding event handler is invoked to take actions.Users can install SmartThings apps in two different ways using a smartphone companion app called SmartThings Mobile. Second, while all taint tracking systems have to be configured with a set of taint sources and sinks, identifying taint sources and sinks in IoT apps is quite subtle, since they access a diverse set of devices, each of which has a different set of internal states. To obtain precision in taint propagation, we start from event handlers to propagate taint when tainted data is copied or used in computation, and we delete taint when all traces of tainted data are removed (e.g., when some variable is loaded with a constant). A broad investigation of existing IoT environments showed three types of common building blocks: (1) Permissions grant capabilities to devices used in an app; (2) Events/Actions reflect the association between events and actions (when an event is triggered, an associated action is performed); and (3) Call graphs represent the relationship between entry points and functions in an app. // Entry point h1(){ x() } // Entry point h2(){ s.off() d.lock() def between= y() if (between){ z() } } x(){ s.on() d.unlock() } y(){ return timeOfDayIsBetween(fromTime, toTime, new Date(), location.timeZone) } z(){ sendSms(c, "...")We also include in the permission block a set of common interfaces designed for all apps that may leak sensitive data. Turning to our example, the event of state changing to "present" is associated with an event handler method named h1() and the event of changing to "not present" with the h2() method.We also found that events are not limited to device events, and can be generated in many other ways: (1) Timer events; event handlers are scheduled to take actions within a particular time or at pre-defined times (e.g., an event handler is invoked to take actions after a given number of minutes has elapsed or at specific times such as sunset); (2) Web service events; IoT programming platforms may allow an app to be accessible over the web. This allows external entities (e.g., If This Then That (IFTTT) [18]) to make requests to the app, and get information about or control end devices; (3) App touch events; for example, some action can be performed when the user clicks on a button in an app; (4) what actions get generated may also depend on mode events, which are behavior filters that automate device actions. Turning to IR depicted in Fig. 4, we have two entry points h1() and h2() Input: ICFG : Inter-procedural control flow graph Output: Dependence relation dep 1: worklist ← / 0; done ← / 0; dep ← / 0 2: for an id in a sink call's arguments at node n do 3:worklist ← worklist ∪ {(n, id)} 4: end for 5: while worklist is not empty do 6:(n, id) ← worklist.pop() 7:done ← done ∪ {(n, id)} 8:for node n with id def. in assignment id = e do 9:ids ← {(n , id ) | id is an identifier in e} 10:worklist ← worklist ∪ (ids \ done) 11:dep ← dep ∪ {(n : id, n : ids)} 12:end for 13: end while (Lines 12 and 16). From the inter-procedural control flow graph (ICFG) of an app, SAINT's backward taint tracking consists of two steps: (1) it first performs taint tracking backward from taint sinks to construct possible data-leak paths from sources to sinks; (2) using path-and context-sensitivity, it then prunes infeasible paths to construct a set of feasible paths, which are the output of SAINT's static taint tracking.In the first step, SAINT starts at the sinks of the ICFG and propagates taint backward. This is confirmed by checking the ratio of sinks over sources in analyzed IoT apps (see Fig. 7 in Sec. 5 for taint source analysis and see Fig. 9 in Sec. 5 for taint sink analysis). The algorithm then takes an entry (n, id) from preferences { section("Select thermostat device") { input "ther", "capability.thermostat"} section("threshold value"){ input "thld", "number"} } def initialize() { subscribe(app, appHandler) } def appHandler(evt) { f() } def f(){ temp=ther.latestValue("temperature") temp_cel=convert (temp) + thld bar(temp_cel) } def convert(t){ return((t-32)*5)/9) } def bar(t){ ther.setHeatingSetpoint(t) sendSMS(phone, "set to ${t}") } the worklist and finds a definition for id on the ICFG; it adds identifiers on the right-hand side of the definition to the worklist; furthermore, the dependence between id and the right-hand side identifiers are recorded in dep. We found that the predicates used in IoT apps are extremely simple in the form of comparisons between variables and constants (such as x == c and x > c); thus, SAINT implemented its simple custom checker for path conditions. For example, a method foo() can be invoked by declaring a string name="foo" and thereafter called by reflection through $name; Figure 6: Our SAINT data flow analysis tool designed for IoT apps. Out of 168 official apps, SAINT flags nine apps using call by reflection, 74 declaring state variables, 37 implementing closures, and 23 using the OAuth2 protocol; out of 62 third-party apps, the results are one, 34, nine, and six, respectively. Finally, although user inputs and state variables may over-approximate sources of sensitive information, during manual checking, we made sure the reported data flows do include sensitive data.SAINT labels each piece of flow information with the sink interface, the remote hostname, the URL if the sink is the Internet, and contact information if the sink is a messaging service. Out of 92 official apps, 28 apps (O1-O28) send one single kind of sensitive data, 16 apps (O29-O44) send two kinds of sensitive data, and the remaining 48 apps (O45-O92) send more than two and at most four kinds of sensitive data. Our investigation suggests that apps at the top of the Table 3 implement simpler tasks such as managing motion-activated light switches; the apps at 1 2 3 4 5 O1 O47 T1 O2 O48 T2 O3 O49 T3 O4 O50 T4 O5 O51 T5 O6 O52 T6 O7 O53 T7 O8 O54 T8 O9 O55 T9 O10 O56 T10 O11 O57 T11 O12 O58 T12 O13 O59 T13 O14 O60 T14 O15 O61 T15 O16 O62 T16 O17 O63 T17 O18 O64 T18 O19 O65 T19 O20 O66 T20 O21 O67 T21 O22 O68 T22 O23 O69 T23 O24 O70 T24 O25 O71 T25 O26 O72 T26 O27 O73 T27 O28 O74 T28 O29 O75 T29 O30 O76 T30 O31 O77 T31 O32 O78 T32 O33 O79 T33 O34 O80 T34 O35 O81 T35 O36 O82 T36 O37 O83 T37 O38 O84 T38 O39 O85 T39 O40 O86 T40 O41 O87 T41 O42 O88 T42 O43 O89 T43 O44 O90 T44 O45 O91 T45 O46 O92 Table 3: Data flow behavior of each official (O1-O92) and thirdparty (T1-T46) app. For instance, a security and safety app managing few devices may send more types of sensitive data than an app designed for convenience that manages many devices.In general, we found that there is no close relationship between the number of devices an app manages and the number of sensitive data flows. For instance, a web-service app connects to a user's devices, accesses their events and commands, and uses their state information to perform actions, and an app allows users to stream their device events to a remote server for data analysis and visualization. The messaging rows of the table tell that, in official apps, users specify recipients 154 times, while contents are specified by users five times and 149 times by developers; for third-party apps, users define recipients 67 times, while message contents are specified by users five times, and 63 times by developers. As detailed in Sec. 4 Messaging Official 154 0 0 5 149 0 Third-party 67 0 0 4 63 0 Internet Official 2 48 44 0 54 40 Third-party 0 13 12 0 13 12 Table 4: Recipient and content analysis of data flows.endpoints and respond to requests from external services. For example, in one app, x gets the state of a device x=currentState("device") and, when a user is present, x is sent out via an SMS message; even though there is an implicit flow (because sending the message depends on whether the user is present), there is also an explicit flow as the device information is sent out. We note that turning on implicit flow tracking increases the tracking overhead as more identifiers need to be tracked; however, based on the results, turning on implicit flow tracking on SmartThings IoT apps does not lead to an unmanageable number of false positives. IOTBENCH can be used to evaluate both static and dynamic taint analysis tools designed for SmartThings apps; it enables assessing a tool's accuracy and effectiveness through the ground truths included in the suite. Since one of the methods leaks the state of a door (locked or unlocked) to a malicious URL and the mode of a user (away or home) to a hard-coded phone number, SAINT produces warnings. Even though our evaluation results on SmartThings apps show that tracking implicit flows does not lead to over-tainting and false positives, whether this holds on apps of other IoT platforms and domains would need further investigation. These works have found that apps can be easily exploited to gain unauthorized access to control devices and leak sensitive information of users and devices.Many of previous efforts on taint analysis focus on the mobile-phone platform [9,48,15,7,5,12]. 10-Multiple Devices 3 A taint source is obtained from device state and device information and they are leaked via messaging services.Permissions 11-Implicit 1 A malicious URL is hard-coded, and device states (implicit permission) are leaked to the hard-coded URL.12-Implicit 2 A hard-coded phone number leaks the user inputs (implicit permission). Various sensitive data is obtained from state variables and devices, and they are leaked via more than one hard-coded contact information.Side Channel 18-Side Channel 1 A device is misused to leak information (e.g., turning on/-turning off a light to signal adversary). Listing 1: An example home-automation app48 } 49 50 def initialize() { 51 log.debug "initialize configured" 52 subscribe(presenceSensor, "present", h1) 53 subscribe(presenceSensor, "not present", h2) 54 } 55 56 def h1(evt) { 57 log.debug "presence active called: $evt" 58x ( def latestValue = theDoor.latestValue("door") 97 log.debug "message sent, the door status is $latestValue" 98 } Our first app "Implicit Permission 1" (ID: 11) sends a short message to household members when everyone is away. Because SAINT adds all methods in an app as possible call targets, it detects a data leak in updateApp(), which disables alarm by unsubscribing the "smoke-detected" event and sends this information to a hardcoded phone number. B IoTBench Apps Listing 4: Leak via a reflective call1 def attack(){ 2 httpGet("http://maliciousServer.com"){ 3 resp -> 4 if(resp.status == 200){ 5 state.method = resp.data.toString() 6 } 7 "$state.method"() // reflective call 8 } 9 updateApp() { 10 unsubscribe() // revoke smoke detector events 11 sendSms(attacker phone,"$detector is revoked") 12 } C Taint Source and Taint Sink APIsWe present SmartThings APIs that are taint sinks in Table 1 and APIs that are taint sources in Table 2. 48 } 49 50 def initialize() { 51 log.debug "initialize configured" 52 subscribe(presenceSensor, "present", h1) 53 subscribe(presenceSensor, "not present", h2) 54 } 55 56 def h1(evt) { 57 log.debug "presence active called: $evt" 58x ( def latestValue = theDoor.latestValue("door") 97 log.debug "message sent, the door status is $latestValue" 98 } Our first app "Implicit Permission 1" (ID: 11) sends a short message to household members when everyone is away. 1 def attack(){ 2 httpGet("http://maliciousServer.com"){ 3 resp -> 4 if(resp.status == 200){ 5 state.method = resp.data.toString() 6 } 7 "$state.method"() // reflective call 8 } 9 updateApp() { 10 unsubscribe() // revoke smoke detector events 11 sendSms(attacker phone,"$detector is revoked") 12 } We present SmartThings APIs that are taint sinks in Table 1 and APIs that are taint sources in Table 2.