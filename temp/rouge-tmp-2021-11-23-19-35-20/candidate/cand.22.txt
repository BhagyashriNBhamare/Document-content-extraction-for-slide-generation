Current techniques assume that the application's database tables contain a column that enables mapping a user to rows in the table. However, not all database tables contain sufficient information to map a user to rows in the table, as a result of database normal-ization, and thus, require the joining of multiple tables. Unfortunately, securing web applications has remained a challenge, mainly for three reasons: (i) the incompatibility of modern web architecture and the security mechanisms of database systems, (ii) limitations of the automated techniques for enforcing a security policy, and (iii) failure to write secure, non-buggy code when implementing access contol logic within the application.1. Using an overprivileged account, the web application can simply maintain a pool of active database connections that can execute queries on behalf of any end user.To use a DBMS' mechnisms, (1) each application user must be assigned a unique database account, and (2) a separate database connection (using the assigned account) must be used for processing each user's requests. Before issuing a query, the application rewrites the query to use the restricted portion of the datbase based on the authenticated user. Unsecure and Buggy Code -In today's web application architecture, developers cannot rely on databases to enforce access control policies due to the reliance of the applications on a pool of persistent connections. Unsecure or buggy code leave web applications vulnerable to numerous access control bypass attacks, such as SQL injection [8,25,28,34,35,38,42] and insecure direct object reference attacks [14,44]. Generality: The access control policy can be enforced for all read (SELECT) and write (UPDATE, INSERT, and DELETE) queries on any table (whether it contains the user id as a column or not);C2.Correctness: The application user should only be able to access and modify authorized information as defined by the developer's policy;C3. Connection Sharing: For compatibility with existing web applications, the solution should allow for reusing a set of persistent and over-privileged database connections to serve requests of multiple end users.Our Approach -We introduce the phantom extraction technique for enforcing access control on write queries, while being robust to policies that involve joins. Once SafeD deems the phantom's modifications on the temporary table to be safe, the changes are copied over to the original table.The view update problem does not apply to phantom extractions because database views are not used in any part of the process. We surveyed 10 popular open-source web applications and show that complex row-level access control policies with joins queries are required for, on average, 21% of the tables to define per-user policies (Section 3).2. On Postgres, SafeD provides comparable performance to Postgres' access control for simple policies, but outperforms it by an order of magnitude for row-level access control policies with joins in terms of transaction latency and throughput (Section 8.2). Defining these functions via procedural code offers flexibility, but is also more error-prone compared to simply writing declarative policy statements as in SafeD.More recently, Postgres 9.5 has added support for fine-grained access control, whereby administrators define two policy conditions for each table and each role. SafeD does not make this assumption, decoupling a user's read and write permissions.As mentioned in Section 1, the key advantage of SafeD over access control features of database systems is that the former is compatible with today's web application architecture. These types of policies, which we call join policies, occur when a database table does not contain a field corresponding to a user, such as user id, which enables a mapping of rows in the table to a user. The lack of explicit foreign key declarations required us to infer the implied parent and grandparent relationships based on the database schema and structure.In general, any table that has the user information table as its grandparent requires a join policy to define a per-user access control policy. In Total Tables Tables Requiring Join Policy Wordpress [10] 12 4 (33%) hotCRP [40] 24 6 (25%) LimeSurvey [3] 36 18 (50%) osCommerce [7] 40 4 (10%) MediaWiki [4] 48 10 (21%) WeBid [9] 55 Table 2: Summary of the number of tables in 9 web applications that require a join query to define a per-user policy declaratively. The application developer (or the system administra- Figure 2: Given a query and a user context, SafeD obtains the user's security policy and creates a safe version of the query, which is executed on the database.tor) specifies the desired security policy via a set of declarative rules. We implement our prototype by extending a JDBC driver (Section 7), and evaluate it using the TPC-C benchmark. In other words, the web application is assumed to reliably verify the enduser's identity and make it available to SafeD along with the issued query, but the query itself can be arbitrarily over-privileged, due to bugs or remote exploits. 4 Read sets are defined similarly, except that the READSET keyword is used instead of WRITESET.DEFINE WRITESET FOR ROLE customer USER $i ONThe definition of the read and write sets for a Next, we define read and write sets formally. Furthermore, given any subset s ⊆ S, we denote its complement as s c = S \ s.Given a set of users U, we define a security policy as a pair of two functions (p r , p w ), where p r is the read policy and p w is the write policy, defined below.Definition 1 (Read/Write Policy). (Read/Write Set) Given a user u ∈ U and a table T ⊆ S,• The read set of T , V r (T, u) = T ∩ p r (u), represents the set of tuples in T that user u can read. The above corollary implies the following: if in a query R, each table T i of the database accessed in the FROM clause is replaced by a table T i where T i = T ∩ p r (u), then the resulting query R will be readsafe. Intuitively, a write query by a user u that updates a table T is write-safe if 1) it does not modify anything outside table T 's write set, and 2) any nested SELECTs within it are also read-safe (so that it does not leak data via the writes). Given a user u ∈ U, a tuple space S, a set of tuples s ⊆ S, a table T ⊆ S, a write operation W that is read-safe, the write policy p w , and the write set V w (T, u), the following conditions,(1) V w (W (T ), u) = W (V w (T, u)) (2) W (T ) = W (V w (T, u))are necessary and sufficient to ensure W is write-safe, i.e.,NV w (T, u) = NV w (W (T ), u). If T is replaced by V w (T, u) in Theorem 1, it can be shown that the condition in the corollary implies both conditions of the theorem. The transformation module automatically transforms a query Q into a safe query that is guaranteed to satisfy the two conditions in Theorem 1 for read-safety and writesafety, while providing the illusion that the query operates on the view of tables that are in the user's read set and write set. Read policy intersection automatically transforms a SELECT query in Q into one that is read-safe by appending additional tables and conditions to each query based on the read policy.Nested Queries (read-safety) -SELECT queries can be nested within other queries, including write queries. if (Q is a Select query) then 5: return Execute(rsQ) T ← GetWriteTable(rsQ) 7: writesetde f ← GetWriteSetDef(u, T) 8: return PhantomExtract(rsQ, T, writesetdef) SafeD uses one of two strategies for implementing the PhantomExtract function: V-Copy or No-Copy. For DELETE queries, due to the Corollary 3, No-Copy executes the DELETE query on the subset of T that is within its write set, ensuring that only writable tuples are deleted.Write set intersection is also used to transform rsQ into phantom if rsQ is an UPDATE. Since the query's phantom only modifies tuples in the write set by definition, the number of changes made by phantom on T is equal to W (V w (T, u)) where W is the write operation representing phantom. Setup -In all experiments, we used two machines running Ubuntu 12.04 with 32GB of memory, configured as a client and a database server. When the target tables do not contain the necessary attributes to map the current user to tuples in the table, i.e, the New Order and Order Line tables, a join between the target table(s) and the OOrder table is necessary to obtain the set of order ids (O ID) that the current user can access. These results indicate that when a user's write set contains joins, SafeD using No-Copy significantly outperforms Postgres's built-in access control.While SafeD outperforms the built-in access control, the performance of both strategies could be improved. Thus, to reduce the performance overhead, we repeated the experiment with a denormalized database, i.e, we added a new column, NO C ID, to the New Order table. For example, Table 6 reports the number of lines of code needed to define Policy 1 in SafeD, Oracle (which also offers rowlevel access control), and Postgres. Database-backed application developers often implement their access control policies procedurally in code because the access control mechnisms of database systems are not adequate for enforcing access control for multi-user applications. As our survey of 10 popular open-source web applications showed, on average, 21% of the tables require a join query to define a security policy. That is, for any tables or other subsets A, B ⊆ S ,V (A ∪ B, u) = V (A, u) ∪V (B, u) V (A ∩ B, u) = V (A, u) ∩V (B, u) V (A \ B, u) = V (A, u) \V (B, u)Proof. Also, these results apply for NV ∈ {NV r , NV w }, since NV (A, u) = A\ p u (u) = A∪ p c (u), where p c (u) = S\ p(u) and S represents the tuple space for the database.Lemma 2. Given a policy p w , a user u ∈ U, a write set V w , a table update operation W , and any table T ⊆ S , the following conditions are equivalent:(1) NV w (A, u) = NV w (D, u) = ∅, (2) NV w (T, u) = NV w (W (T ), u)where A and D are the set of tuples added and removed from T.Proof. Then we find thatNV w (W (T ), u) = NV w ((T ∪ A) \ D, u) def of W = (NV w (T, u) ∪ NV w (A, u)) \ NV w (D, u) Lemma 1 = NV w (T, u) by condition (1)Conversely, suppose that condition (2) holds. Applying these two results, along with condition (2), we find that|A v | + |D v | = W (V w (T, u)) = W (T ) = |V w (A, u)| + |NV w (A, u)|+ |V w (D, u)| + |NV w (D, u)| = |A v | + |NV w (A, u)| + |D v | + |NV w (D, u)|Removing |A v | and |D v | from both sides, we are left with|NV w (A, u)| + |NV w (D, u)| = 0. Focusing on V w (A, u), we find V w (A, u) = V w (W (T ) \ T, u) def of A = V w (W (T ), u) \V w (T, u) Lemma 1 = W (V w (T, u)) \V w (T, u) condition (1)With a similar procedure, we can show thatV w (D, u) = V w (T, u) \ W (V w (T, u)). If we define A v = W (V w (T, u)) \ V w (T, u) and D v = V w (T, u) \ W (V w (T, u)), then from the definition of W (T ), we have W (V w (T, u)) = |A v | + |D v |With this, we findW , T = |V w (A, u)| + |V w (D, u)| = |W (V w (T, u)) \V w (T, u)| + |V w (T, u) \ W (V w (T, u))| = |A v | + |D v | = W (V w (T, u))Since conditions (1) and (2) imply NV w (T, u) = NV w (W (T ), u) and vice versa, the conditions are necessary and sufficient. Suppose a customer with current id=2 manages to (e.g., by exploiting a bug in the application) cause the web application to issue the following query:SELECT * FROM reviews WHERE products_id IN ( SELECT products_id FROM orders_products OP , orders O WHERE O . Given that the current write-safe query is a DELETE, SafeD performs write set intersection by appending additional conditions to the outer query's WHERE clause Since the write set includes a join (see Listing 5, an additional nested query is added to obtain a list of products purchased by the current customer. ( reviews_id , products_id , customers_id , customers_name , reviews_rating , date_added , last_modified , reviews_read ) VALUES ( -1 , 1 , 1 , 'John', 5 , 1 -1 -2016( -1 , 1 , 1 , 'John', 5 , 1 -1 - , 1 -1 -2016 Listing 12: Original INSERT query issued by the application Similar to the DELETE query example, the original INSERT query is read-safe by definition.