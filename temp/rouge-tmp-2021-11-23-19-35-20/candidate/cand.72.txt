Among all side-channel attacks, cache-based timing attacks steal confidential information based on the program's runtime cache behaviors. Cache-based timing attacks are perhaps the most practical and important ones, since those attacks does not require any physical access to the confidential computation, yet the timing signal carries enough information to break RSA [3,45,59], AES [8,11,42,53,27] and ElGamal [63,34]. In contrast, access-driven attacks [24,53] and tracedriven attacks [2] exploit more fine-grained cache behavior and require fewer measurement samples, but they are based on more sophisticated threat models and require deep knowledge about the hardware and software system under attack [53,39,45]. Thus it is of great practical value to develop an automated tool that can help developers reason about the cache behavior of a memory access.In this paper, we propose a general trace-based method with symbolic execution and constraint solving to detect potential cache variations at each program location. In this way, the CPU can speed up data retrieval with limited hardware resources, based on the observation that memory accesses in computer programs are usually temporarily and spatially coalesced.The topmost three layers of the hierarchy are processor registers, caches, and the main memory, the latter two of which share the same address space. If the tag matches, the line offset is used to locate the data inside the cache line; otherwise, accessing memory at that address leads to a cache miss, and the processor will have to retrieve the data from the lower layers of the memory hierarchy.The low L bits of the address used to access the cache is irrelevant to timing, since the CPU always retrieve a whole cache line at a time. Such leakage is best illustrated in the square-andmultiply implementation (shown below) of modular exponentiation, the core computation of cyphers such as RSA and ElGamal.The pseudo-code computes b e mod m, where we assume the n-bit secret exponent e is in its binary representation and e [i] is the i-th bit of e. Note that in this implementation, the branch condition at line 4 depends on one bit of e. Moreover, the real implementation of r = r * b mod m involves memory reads since b and e consist of multiple words in RSA and ElGamal. Consequently, an attacker that probes the cache usage of this victim program can recover the exponent, and hence, reveals the private key of RSA [1,59] and ElGamal [63,34].1 r = 1; 2 for i from n−1 to 0 { 3 r = r * r mod m;4 if (e[i] == 1) { 5 r = r * b mod m; 6 } 7 }Previous work shows that secret-dependent control flow can be identified via information flow analysis, and be mitigated by removing secret-dependent branches or balancing branches conditioned on confidential data [4,25,38,7,17]. Given a non-zero window value, say v, this implementation computes b v via a table lookup:T [(v − 1)/2], where T is a precom- puted table such that T [i] = b i * 2+1 mod N.Note computing b v involves no secret-dependent branch, but different cache lines are accessed given different values of v, hence, leading to practical cache-based timing attacks (e.g., [34]). This strong threat model captures most cache-based timing attacks in the literature, such as an attacker who observes cache accesses by measuring the latency of the victim program (e.g., cache reuse attacks [43,11,10,24] and evict-and-time attack [42]), or the latency of the attacker's program (e.g., prime-andprobe attacks [42,53,11,63,34]). Compared with previously categorized threat models based on the abstraction of cache hit and miss (namely, the time-based, trace-based and access-based models [19,51]), our more detailed model using the abstraction of cache lines has a couple of benefits. Secondly, working on the cache line abstraction makes the vulnerability analysis more general, since unlike cache hit/miss, the abstraction is independent of cache implementation details, such as cache-replacement policies, cache associativity and so on. With the help of constraint solvers, we can logically deduce whether sensitive data would affect the cache behavior of the program and hence, reveal potential timing channels.Operationally, given a program point where a memory access occurs, we can model the memory address being accessed as a symbolic formula F( k), where k, as the only free variables in F, stands for program secrets. Actually, by feeding different secrets (1 or 30) to this function, memory access in the above case hits cache line 0 or 1, which enables attackers to launch cache probing attacks (e.g., prime-and-probe attacks [42,53,11,63,34]) to infer the value of the secret.Another obvious secret dependent memory access is at line 10, which holds the memory access formula (also for the first iteration of the loop) as:G(k) ≡ 10 + 4 · (k mod 128) mod 4According to constraint solving, G(k) 6 = G(k ) 6 is unsatisfiable at this time. Previously, finding such vulnerabilities are challenging-if possible at all-towards industrial-strength cryptosystems.The trace-based analysis is usually unable to cover all program points; in other words, to produce execution traces that can cover the vulnerable code, it might require deliberate selection of proper program inputs to trigger the vulnerability. There are also techniques, such as concolic testing [49,22,23], developed in the software testing and verification community that can be leveraged.On the other hand, considering the research objective in this paper (i.e., cryptosystems), most critical procedures (where vulnerabilities could exist) can indeed be triggered by following the standard routines defined by the cryptographic libraries. The trace is then fed into CacheD to perform taint analysis; we mark the secret as the taint seed ( §4.2) and propagate the taint information along the trace to identify instructions related to the usage of the secret.CacheD then symbolizes the secret into one or several symbols (each symbol represents one word), and performs symbolic execution along the tainted instructions on the trace ( §4.3). As aforementioned, we check the satisfiability of (F( k) L = F( k ) L) ∧ C; if satisfiable, the solution to k and k represent different secret values that can lead to different cache behavior of this program point. This information serves as the seed for the taint analysis and symbolic execution in later stages.While the secrets (e.g., the private key or a random number) are usually obvious in the source code, it may not be straightforward to identify the location of the secret in an execution trace, since variable names are absent in the assembly code. With further reverse engineering effort in small regions, we can eventually recognize the location of the secret in the assembly code, as a register, or a sequence of memory cells in the memory.Although currently this step is largely manual, it is likely that it can be automated by a secret-aware compiler, which tracks the location of secrets throughout the compilation; however, we leave this as future work. After the taint analysis, we keep the instructions whose operands are tainted.Taint propagation rules define how tainted information flows through instructions, memories and CPU flags, as well as what operations introduce new taint or remove existing taint. Hence, the memory address is always a concrete value and memory-related taint propagation is considered accurate.Memory addressing defined in the x86 instruction set can be divided into the base address and the memory offset, each of which is maintained by a register or a concrete value. To precisely track the secret information flow, CacheD record taint propagations towards CPU flags.In general, CPU flags could be modified according to the computation results of certain instructions, for example, flag ZF will be set to one if the result of an SUB (subtraction) operation is zero. Consistent with our taint propagation rules which captures information flow through memory accesses ( §4.2), for a memory load operation whose addressing formula containing key symbols (i.e., either the base address or the memory offset is computed from secrets), we would symbolize the memory cell with a fresh key symbol if it is visited for the first time. Instead, our current design develop a memory model that reasons symbolic pointers with their concrete values on the trace, which is conceptually the same as other commonly used binary analysis platforms (e.g., the tracebased analysis of BAP [14]). There exist three different cases regarding the solution of our constraint solver:• To test whether the array index, and hence the fetched content, may differ in two executions with different keys, CacheD checks the formula (F( k) = F( k )) ∧ C. Hence, we create a fresh key symbol and use it to update the memory load output.In general, we consider independent vulnerabilities are highly informative to attackers; independent vulnerabilities probably indicate the most-likely attack surface of the victim, because stealing secret through "dependent" vulnerabilities need additional efforts to learn the program memory layout. While this rule reasonably captures the information flow through memory accesses, we terminate the taint propagation for one specific case, given the domain knowledge of cryptosystems being analyzed.To speed up processing, the sliding-window based modular exponentiation algorithm leverages a two-level "precomputed table" to store the modular exponentiation values of the base regarding some predefined windowsized value. Given such observation, CacheD is optimized to terminate the taint propagation towards the precomputed size the same procedure which has been well-studied from different angles in the literature makes it easier to compare our experiment results (in terms of re-discover existing issue and identify unknown issue) with existing work. While our current implementation (including CacheD and the Pin plugin) analyzes binaries on the 32-bit Linux platforms (i.e., binaries with the ELF format), we emphasize that the proposed technique is mostly independent with the underlying architecture details, and hence not difficult to port to other platforms (e.g., Windows or 64-bit Linux). We present the breakdown of the positives reported by CacheD in In general, existing research has pointed out potential issues that can lead to the cache based side-channel attacks on the implementation of sliding-window based modular exponentiation [20], and such implementation is leveraged by both RSA and ElGamal decryption procedures. We present a detailed study of two independent vulnerable program points found in RSA implementation of Libgcrypt 1.6.1 in §7.3, and also compare our findings of RSA and ElGamal with existing literatures in §7.4.1. Although trace-based analysis is in general not sufficient to "prove" a cryptosystem as free of information leakage, considering related research as less scalable ( [19]), CacheD presents a scalable and practical way to study such industrial strength cryptosystems. We interpret the processing time of CacheD as very promising, and this evaluation faithfully demonstrates the high scalability of CacheD in terms of real-world cryptosystems.Our evaluation also shows the proposed optimizations ( §5) are effective, which surely improve the overall scalability of CacheD. Since the key length by bit may not be a multiple of the key length by byte, the code uses a lookup table in BN num bits word to determine the exact number of bits in the last entry of a->d. CacheD points out that accessing this lookup table will lead to a cache difference, thus leaking information about the most significant several bits of the secrete key which are stored in a->d [a->top -1]. We also find the same implementation that could lead to timing channels in its most recent releases (released in late Sep. 2016): version 1.0.2j, version 1.1.0b, and version 1.0.1u. Another vulnerability found by CacheD is in the Botan (1.10.13) implementation of RSA, whose source code is shown in Appendix D. Since the seminal paper of Kocher [30], attacks that exploit timing channels have been demonstrated on RSA [13,30,3,45,59], AES [24,42,53] and ElGamal [63]. Recently, advanced program analyses are proposed to identify those subtle cachebased timing channels [6,19,20,60], but they only provide an upper-bound on timing-based information leakage; it is unclear what/where the vulnerability is when those tools report a non-zero upper bound.At the system level, Düppel [64] clears L1 and L2 cache before context switching; but it cannot mitigate the last-level cache-based attack, such as [34].