As well as enhancing the accuracy and nuance of our predicted traces relative to previous work, our systematic method of selecting and testing potential explanatory variables provides valuable insights into the leakage features of the ARM Cortex devices examined, which are of independent interest.The second part of our contribution is a procedure to extract the data flows of arbitrary code sequences which can subsequently be mapped to trace predictions via our carefully refined models. We then demonstrate the utility of the simulator for flagging up even unexpected leaks in cryptographic implementations, by performing leakage detection tests against simulated and real measurements associated with an imperfectly-protected code sequence.The remainder of the paper proceeds as follows: in Section 2 we review the previous work on leakage modelling, and provide a very brief overview of the key features of the ARM Cortex architecture and the Thumb instruction set, alongside some information about our tailored acquisition procedure. In this section we aim to provide enough context for our paper to be reasonably self-contained for a reader not familiar with the tasks of leakage modelling and model evaluation (Sect. 2.1), the ARM Cortex-M processor family (Sect. 2.2), assembly code instructions (Sect. 2.3) and/or typical side-channel measurement setups (Sect. 2.4). Note that even these most exhaustive of strategies, which may be collectively classed as 'white box' modelling due to their reliance on comprehensive implementation details, fail to account for influences on the leakage outside the information provided by the netlist (for instance crosstalk) and therefore represent simplifications of varying imperfection. An approach popular in the side-channel evaluation literature is to estimate the amount of information (in bits) in the true leakage which is successfully captured by an evaluator's model for that leakage with a metric called the perceived information (PI) [21,8]. The F-test can also be used to test overall model significance, which is useful in our case where the exploitable (i.e. data dependent) variation may only represent a small fraction of the total variation in the traces (which includes noise and unrelated processes). In this work we focus on profiling a select number (21) of Thumb instructions that are highly relevant for implementing symmetric cryptography, which run on both the Cortex-M0 and M4 processors: ldr, ldrb, ldrh, str, strb, strh, lsls, lsrs, rors, muls, eors, ands, adds, adds #imm, subs, subs #imm, orrs, cmp, cmp #imm, movs and movs #imm. However, mov and cmp instructions each have only two registers: r d , r n and r n , r m respectively.To simplify our configuration for modelling instructions, and to ensure enough registers for the analysis of three instructions (where each register must be fixed beforehand), r d was the same as r n for all of these, limiting the number of registers required for each instruction to 2. They typically have the form "inst r t , [r n , r m /#imm]" where r t is the register to which the data is to be stored or from which it is to be loaded (according to the functionality of the instruction), r n is the memory address and r m /#imm is the offset to this memory address which can either be in a register r m or input as an immediate value (#imm). We work with implementations of the two processors by ST Microelectronics on STM Discovery Boards, with the ARM Cortex-M0 being implemented on an STM32F0 (30R8T6) Discovery Board and the ARM Cotex-M4 on the STM32F4 (07VGT6). To measure the EM emissions on the Cortex-M4 processor we placed a small EM probe over the output of one of the capacitors leading to one of the power supply pins of the processor.We used a Lecroy Waverunner 700 Zi scope at a sampling rate of 500 MS/S for both the power and EM analyses. To lower the independent noise, we averaged over five acquisitions per input for the power measurements for the M0 (as this was found to be the lowest number that brought the most signal gain) and 10 for the EM measurements for the M4 (to further reduce the additional noise associated with this method of taking traces). We concentrate on predictor variables that can be derived from assembly sequences (i.e. input data, register locations), but we also want to potentially account for board-specific effects. We fit models of the following form (written in matrix notation) to the measured leakage of different instructions via OLS estimation (see, e.g., Chapter 3 of [12]):y = δ + [ O 1 | O 2 | T 1 | T 2 ] β β β + ε ε ε(1)whereO i = [ x i [0] | x i [1] | . . . | x i [31] ]is the matrix of operand bits across bus i = 1, 2, [31] ] is the matrix of bit transitions across bus i = 1, 2 (i.e., [b] denotes the b th -bit, x i denotes the i th operand to a given instruction, z i denotes the i th operand to the previous instruction, and '|' denotes matrix concatenation). Consider two models, A and B, such that A is 'nested' within B-that is, it has p A < p B parameters associated with a subset of model B's fitted terms (e.g. y = δ + [ O 2 | T 1 | T 2 ] β β β + ε ε ε versus (1) above). If then, for a given significance level (usually α = 5%, as we opt for throughout) 2 , F is larger than the 'critical value' of the F p B −p A ,n−p B distribution 3 we reject the null hypothesis and conclude that the tested terms do have an effect. 5 Although we caution in the background section that overinterpreting the 'raw' value of resulting R-squareds is not advisable, their relative values can provide some evidence about the relative quality between (same-type) models obtained via e.g. different setups and devices.Hence we now discuss same-type models for the M4, which we obtained using traces from a deliberately weaker measurement setup. • Bus transitions contribute to the instructions on immediate values, and also to cmp.Whilst we again advise against over-interpreting the Rsquareds (see Section 2.1), a comparison between the first rows of 3 and 4 indicates that, in the case of the ALU and shift instructions, model (1) accounts for substantially less of the variation in the M4 EM traces than it does of the variation in the M0 power traces. For instance, we might expect instructions invoking the same processor components (as visualised in Fig. 1) to leak similarly: ALU instructions as one group (i.e. adds, adds #imm, ands, eors, movs, movs #imm, orrs, subs, subs #imm, cmp, cmp #imm), shifts as another, albeit closely-related group (lsls, lsrs, rors), loads (ldr, ldrb, ldrh) and stores (str, strb, strh) that interact with the data in/out registers as two more groups, and the multiply instruction (muls) as a group on its own with a distinct profile due to its single cycle implementation. In the case of the M0, these align nicely with our intuitive grouping: at threshold 0.9 the match is exact; at a threshold of 1.1 the shifts join the ALU instructions; at a threshold of 1.2 the instructions form a single cluster. The coefficients on the first operand are large for just six of the bits while the second operand coefficients are mediumsized across all bits of the first two bytes.In summary, our exploratory analysis of the datadependent form of the instruction leakages confirms many of our a priori intuitions about the architecture and supports our model building approach as sensible and meaningful. From this point forward we concentrate on the M0 and seek to build more complex, sequence-dependent models for five instructions chosen to represent the groups identified by the clustering analysis of Sect. 4.2: eors, lsls, str, ldr and muls. As we would hope, they can be observed (by comparing with Fig. 3) to match well the mean coefficients for the groups that they represent, with the possible exception of str, which has smaller coefficients on the first byte than the average within its group.We are confident that these five are adequate for understanding the leakage behaviour of all 21. We then fit model (1) with the addition of a dummy for (level) board effects and we compare this against a model with the further addition of board/data interaction dummies, in order to test the joint significance of the latter.We find a remarkable degree of consistency in the data-dependent leakage of the different boards. For the purposes of future extensions to our methodology, we propose modelling high register movs as an additional distinct instruction.We test for variation between the eight low registers by collecting 5,000 traces for each source register (r n ) and destination register (r d ) (evenly distributed over the possible source/destination pairs, making 625 per pair) as movs are performed on random inputs. We then fit model (1) with the addition of dummy variables for source register and for destination register, and compare this against a model with the further addition of register/-data interaction dummies, in order to test the significance of the latter.We find that the registers do have a jointly significant effect on the leakage data-dependency (see LHS of Tab. In this section we work towards extending our instruction level models to control (and test) for the possible effects of the previous and subsequent instructions in a given sequence.To achieve this we acquired 1,000 traces for each of the possible 125 combinations of three out of the five instructions, with random data inputs. • DxI p = [ O 1 xI p | O 2 xI p | T 1 xI p | T 2 xI p ]:The Hamming weights of the two 32-bit operands and their Hamming distances from the previous two inputs, interacted with the 'previous instruction' dummies (i.e. the products of the four summarised data terms with each of the four instruction dummies). • DxI s = [ O 1 xI s | O 2 xI s | T 1 xI s | T 2 xI s ]:The Hamming weights of the two 32-bit operands and their Hamming distances from the previous two inputs, interacted with the 'subsequent instruction' dummies, as above.The extended model, in our matrix notation, is therefore:y = δ + [ I p | I s | D | DxI p | DxI s ] β β β + ε ε ε(3)For the purposes of building comprehensive instruction-level models we are especially interested in confirming (or otherwise) the presence of sequence-varying data-dependency, which we again achieve by performing F-tests for the contribution of the interaction terms. Furthermore, our methodology clearly indicates model quality: the models derived from a dedicated setup for monitoring the power consumption showed much better statistics then the models derived from the much less sophisticated EM setup. In this context we expect that leakage simulations based our newly constructed models enable to detect leaks that relate to the modelled instructions, but also (maybe more simply) that our models correlate well to measured traces. Of course, any of the other emulators could be equally incorporated within our methodology.The Thumbulator takes as input a binary program in Thumb assembly, and decodes and executes each instruction sequentially, using a number of inbuilt functions to handle loads and stores to memory and reads and writes to registers. They can thereby be used to spot 'subtle' leaks -that is, leaks that would be difficult for non-specialist software engineers to understand and pinpoint.To aid readability we briefly overview the leakage detection procedures proposed by Goodwill et al. [10]. In all cases the Welch's twosample t-test for equality of means is then performed; results that are larger than a defined threshold, which we indicate via a dotted line in our figures, are taken as evidence for a leak. An experienced and side-channel aware implementer who has detailed leakage information about the M0 would now be able to spot a problem with this code: because the ror instruction also leaks a function of the Hamming distance to its predecessor, there could be problem if the prior instruction is protected by the same mask. This capability suggests a variety of highly beneficial possible uses, such as the automated detection of leakages in the software development stage and the automated insertion (and testing) of countermeasures, as well as hugely promising prospects for optimisation with respect to protection level and energy efficiency.