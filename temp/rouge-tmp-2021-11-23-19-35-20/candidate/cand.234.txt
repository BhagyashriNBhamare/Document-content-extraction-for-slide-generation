"SYN cookies" [4] address SYN flooding, but from a broader security perspective they are highly unsatisfactory, as we now explain.Recall that in a normal TCP connection, say an HTTP connection, the client sends a TCP "SYN" packet to the server containing a random 32-bit initial sequence number (ISN); the server sends back a "SYNACK" packet acknowledging the client ISN and containing another random ISN; the client sends an "ACK" packet acknowledging the server ISN. The bottom line is that DNS can, and at some sites does, serve any number of clients using a constant amount of server memory.Another classic example is NFS, Sun's Network File System [28]. Tiny servers are not necessarily stateless, and in fact the protocol introduced in this paper periodically updates a small amount of state to support key erasure ("forward secrecy"), but we emphasize that this is not per-client state.Tiny network servers are compatible with reliable delivery of data despite dropped packets: for example, DNS clients retry requests as often as necessary. Tiny network servers provide extra robustness against server power outages; trivial migration of connections across high-availability clusters of identically configured servers; and the ability to run on low-cost "Internet of Things" platforms. The pursuit of other security requirements has created, for example, DNS over TLS and DNS over HTTPS, and all implementations of these protocols allow attackers to trivially deny service by filling up server memory, while the original DNS over UDP allows tiny network servers that are not vulnerable to this attack.In this section we highlight three fundamental security requirements, and analyze the difficulty of building a tiny network server that meets these requirements. The "Trickles" network stack from Shieh, Myers, and Sirer [31,32] stores all of the server's TCP-like metadata as a cookie, and also provides an interface allowing higher-level applications to store their own state as part of the cookie. Historically, some network links had even smaller packet-size limits, and technically the IPv4 standard still allows routers to split packets into much smaller fragments, but it is difficult to find evidence of problems with 1280-byte packets on the Internet today. This paper focuses on clients and servers connected by a network that delivers 1280-byte packets.It is not entirely inconceivable that all essential details of an HTTPS state could be squeezed into such a small packet, with enough restrictions and modifications to HTTPS. This protocol takes advantage of the small size of public keys in elliptic-curve cryptography (ECC), specifically 32 bytes for Curve25519.A DNSCurve client starts with knowledge of the server's long-term public key sG, previously retrieved from a parent DNS server. Both ciphertexts are encrypted and authenticated under a shared secret key, a 256-bit hash of the point csG; the server computes csG from s and cG, and the client computes csG from c and sG. The server frequently replaces its short-term public key with a new short-term public key, erasing the old key.What makes these protocols easy to design, within the constraint of tiny network servers, is the fact that ECC keys and ciphertexts fit into a small corner of a network packet. The system uses error correcting codes and the public and private keys are different representations of the same code; the private one allows efficient decoding while the public one resembles a random code which makes it hard to decode. Niederreiter's original proposal involved some codes which turned out to be weak, but using Niederreiter's short ciphertexts with the binary Goppa codes [16] proposed by McEliece in his encryption scheme combines the benefits of both schemes.McBits, by Bernstein, Chou, and Schwabe [7], extends this public-key primitive into a full IND-CCA2 secure encryption scheme, combining it with a KEM-DEM [13] construction. The description is independent of the exact parameters; we use these for illustration purposes whenever concrete sizes are necessary and because these parameters are recommended for long-term security.The codes considered in this paper are binary codes, meaning that all entries are in {0, 1} and that computations follow the rules of IF 2 , i.e., 0 + 0 = 1 + 1 = 0, 0 + 1 = 1, 1 · 1 = 1, and, as always, 0 · a = 0 for any a. This computation takes the first row k 1 of K and computes the dot product with e, resulting in the first bit of Ke, takes the second row k 2 to similarly produce the second bit of Ke, etc.Example 2 Continuing in the setting of Example 1 and choosing e = (0, 1, 0, 0, 0, 1, 0) ⊥ gives c = (0, 0, 1) ⊥ , the sum of the second and the sixth column.Decapsulation uses the private representation of the code to recover the vector e from Ke. For a small example like Example 1 it is easy to check all possibilities of low-weight vectors e but the complexity of these attacks grows exponentially with n and t. For code-based cryptography based on binary Goppa codes the key-size (n − k) · k grows with the security level λ (meaning an attacker takes 2 λ operations) as (c 0 + o(1))λ 2 (lg λ) 2 , with c 0 ≈ 0.7418860694, for the best attacks known today. It splits K and uses that the computation Ke can naturally be composed using parts of K and e. Let K = (I|K ) and writeK =      K 1,1 K 1,2 K 1,3 . . . K 1, K 2,1 K 2,2 K 2,3 . . . K 2, . . . . . . . . . . . . . . . K r,1 K r,2 K r,3 . . . K r,      ,where the submatrices K i, j are chosen to be approximately equally sized and small enough to fit into a network packet along with other message parts described in the next section.For ease of exposition assume that each K i, j has x columns and y rows, so k = x · and n − k = y · r; in general the pieces may have different sizes as specified by the system parameters. Then c 1 = e 1,0 + c 1,1 + c 1,2 = (0) + (1 1)(0, 0) ⊥ + (0 1)(1, 0) ⊥ = 0, matching the first coordinate of c computed earlier.Note that each part c i j poses a decoding problem for e j which is much easier than breaking McEliece. McTiny makes it possible for the server to compute Ke, for a big matrix K and chosen weight-t vector e (see Section 4), without requiring the server to allocate any per-client memory and without needing more temporary memory than what fits into a network packet. The client and the server use S to encrypt and authenticate all following messages.In phase 1 the client sends the matrix parts K i, j to the server and the server replies with encryptions of the partial encryptions c i, j . Bytes N 0 and N 1 are determined by the phase the protocol is in, information regarding positions, and N 0 is even for messages from the client to the server and odd for messages the other way. The server can decrypt cookies returned to it during z time intervals, while it is using s m , s m+1 , s m+2 , s m+3 , . . . , s m+z−1 . In mctiny6960119 we specify the time interval as one minute and specify that the server remembers 8 cookie keys in any time interval, i.e. while it uses s m it also remembers s m−1 , s m−2 , . . . s m−7 but not s m−8 or earlier keys. Here we detail the cryptographic protections for this computation.For every partial matrix K i, j the client sends AE(K i, j : N, 2(i − 1), 64 + j − 1 : S),C 0 , (N, 2(i − 1), 64 + j − 1) to the server, where 1 ≤ i ≤ r is the row position and 1 ≤ j ≤ is the column position. Finally, it computes a client-specific cookie key s = hash(s m , S) and the cookie matching the partial encryption C i, j = (AE(c i, j : N, 2i − 1, 64 + j − 1 : s), b). It picks a fresh 22-byte random nonce M, sends AE(C 0 ,C i, j : M, 2i − 1, 64 + j − 1 : S), (M, 2i − 1, 64 + j − 1) to the client, and forgets all data related to the client.The client verifies, decrypts, updates C 0 , and stores C i, j for future use. The server checks the authenticator and, for each j from iv − v + 1 through iv, decrypts C j,1 , . . . ,C j, to obtain the pieces c j,1 , . . . , c j, of c j . As described in Section 5, the server computes c j = e j,0 + c j,1 + c j,2 + · · · + c j, , with e j,0 the matching y positions of e. Finally it sends AE(C 0 , c iv−v+1 , c iv−v+2 , . . . , c iv :M, 2i − 1, 64 + 32 : S), (M, 2i − 1, 64 + 32). The McTiny key exchange ends at this point, and the client communicates securely with the server using session key Z. Details of a session protocol are outside the scope of this paper, but the main point is that the client can include (C Z , M) in subsequent packets so that the server can reconstruct Z. Any packet back includes an updated cookie (C Z , M) using a fresh nonce; the session protocol can update Z here for prompt key erasure within a session. Each reply includes a fresh C 0 or C Z but these cookies are superencrypted under S or Z which the attacker does not know, yet.The client is assumed to maintain state, so will no longer reply (and provide fresh versions of C 0 or C Z ) after the connection was closed. If AE is AES-GCM, and an attacker sees AE(T 1 : N : S) and AE(T 2 : N : S) for T 1 = T 2 , then the attacker can also produce authenticators for arbitrary ciphertexts under (N : S) for any N . If a step is repeated due to packet loss, the server will make a fresh choice of M. Hence, the attacker will not observe nonce reuse for different plaintexts.The subsequent messages from the client to the server are encrypted and authenticated using S and a nonce which depends on the first random nonce N chosen by the server. This makes the choice of nonce deterministic for each encryption and the same nonce and key are used when retransmitting in the same phase, but only to encrypt the same plaintext.The attacker also sees C 0 = (AE(S, E : N, 1, 0 : hash(s m )), m mod 8) using several cookie keys s m under the same nonce N, 1, 0. The server accepts cookies under its most recent cookie keys s m , s m−1 , . . . , s m−z+1 and uses the symmetric key S provided in C 0 to decrypt and check the rest of the message.The attacker can replay a valid client message and cause the stateless server to handle it again. This means that even an active attacker with a quantum computer cannot break the public-key encryption.All of the keys for symmetric cryptography are 32 bytes, providing ample protection against Grover's algorithm and the choice of XSalsa20-Poly1305 for AE follows recommendations for post-quantum security. Our software provides four main tools:• master creates a new mctiny6960119 server identity: a long-term public key and a long-term secret key. • client performs one run of the client side of the mctiny6960119 protocol, communicating to a server at a specified address and port, using a specified server public key.The decomposition of server-side tools is meant to easily support replicated server deployments as follows. The problem is that we also use some OS libraries that were not designed to be small: we use stdio for file management and printing error messages, we call getaddrinfo to determine the local IPv4 or IPv6 address to use, etc. On an unloaded network we saw (as expected-see Table 1) 971 packets from the client to server, plus 971 packets from the server to the client, for a complete mctiny6960119 key exchange. SUPERCOP's latest benchmarks report the following speeds for mceliece6960119 on one Haswell core: 0.71 · 10 9 cycles median for keygen (with high variance: the quartiles are 0.50 · 10 9 and 1.31 · 10 9 ), 153 944 cycles for enc (much less variance: quartiles 148 612 and 169 396), and 305 880 cycles for dec (quartiles 304 616 and 306 232). In our server software, the maximum cycles per byte are spent in McEliece decapsulation for the first packet, about 400 cycles per byte to handle 810 bytes of application-layer data (and slightly fewer cycles per byte when bandwidth overhead is taken into account). In short, this is a tiny network server, making it immune to server-memory denial of service.The previous sections have shown that at very little overhead in the number of packets and a few extra round trips, the conservative McEliece system can be fit into tiny network servers for forward secrecy without using any per-client memory.Server operators might be concerned about the generous usage of randomness on the server side. Routers often provide large buffers (bufferbloat) to try to avoid congestion loss, but these buffers allow congestion delay to increase even more.TCP senders impose various limits upon their packetsending rates to try to reduce congestion when there are signs of congestion, and to try to avoid creating congestion in the first place. Many more packets are ready to send, and could be sent given the available bandwidth, but the server is not yet confident about the available bandwidth.These 10 packets are acknowledged slightly after time Overall this TCP server sent 769 packets, including 1 packet to accept the connection, 766 packets that each sent 1368 bytes of application-layer data (the maximum amount the client was willing to accept; note that this was over IPv4 rather than IPv6), 1 packet that sent the remaining 688 bytes of application-layer data, and 1 packet to acknowledge the client closing the connection (which this client did not do until after receiving all the server data). Comparing the figures also shows that BBR sent slightly more acknowledgment traffic (590 packets from the client, consuming 46 028 bytes including per-packet overhead) than CUBIC did, and also that BBR sent more data between time 0.702 and time 0.819 than CUBIC did, saving time overall.The bottom line is that, because of congestion control, TCP takes about 9.1 round-trip times to send 1MB using CUBIC, or 8.5 round-trip times to send 1MB using BBR. There is more data sent and received in Figure 4 than in Figure 3-there is more overhead in each packet for cryptographic protection, data is sent in somewhat smaller packets, and each packet is acknowledged-but this makes relatively little difference in latency.To summarize, our McTiny software is using the network in this example with similar efficiency to TCP, plus two roundtrip times for final cleanup in the McTiny protocol. This work was supported by the U.S. National Science Foundation under grant 1913167, by the European Commission under Contract ICT-645622 PQCRYPTO, and CHIST-ERA USEIT (NWO project 651.002.004), by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy -EXC 2092 CASA-390781972, by the Netherlands Organisation for Scientific Research (NWO) under grant 628.001.028 (FASOR), and by the Cisco University Research Program.