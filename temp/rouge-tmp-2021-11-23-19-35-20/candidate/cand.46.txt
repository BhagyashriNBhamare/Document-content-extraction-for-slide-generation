Security architectures such as Intel SGX need protection against rollback attacks, where the adversary violates the integrity of a protected application state by replaying old persistently stored data or by starting multiple application instances. We construct a model that captures ad-versarial ability to schedule enclave execution and show that our solution achieves a strong security property: the only way to violate integrity is to reset all participating platforms to their initial state. Server replication using standard Byzantine consensus protocols [9] avoids a single point of failure, but requires high communication overhead and multiple replicas for each faulty node.In this paper we propose a new approach to protect SGX enclaves from rollback attacks. Our adversary model combines commonly considered network control based on the standard DolevYao model [10] and Byzantine faults [11,12], but additionally captures the the ability of the adversary to restart trusted processes from a previously saved state and to run multiple instances of the same trusted process. The enclave generates a random and unique instance identifier i for the enclave instance that executes the code that was assigned to it during creation. When an enclave is suspended, its program counter and runtime memory retain their values. The enclave can verify that it previously created the seal, but the enclave cannot distinguish which seal is the latest. The OS can write message m e to an enclave instance i. Only an enclave with enclave identity e can read the written message m e . The read message m e identifies the enclave identity e that wrote the data.Note that remote attestation identifies the enclave identity, but not the platform identity, because the attestation protocol is either anonymous or returns clientspecific pseudonyms (see Appendix A for details). Based on the SGX model, the adversary can schedule enclaves and start multiple instances of the same enclave, offer the latest and previous versions of sealed data, and block, delay, read and modify all messages sent by the enclaves.The adversary cannot read or modify the enclave runtime memory or learn any information about the secrets held in enclave data. When the sealed data captures the state of the enclave at the time of sealing, we say that the rollback attack reverts the enclave back to its previous state.Another approach is a forking attack, where the adversary leverages two concurrently running enclave instances. We performed a detailed analysis of SGX counters and report our findings in Appendix B.To summarize, we found out that counter updates take 80-250 ms and reads 60-140 ms. The non-volatile memory used to implement the counter wears out after approximately one million writes, making the counter functionality unusable after a couple of days of continuous use. 1 Writing to NVRAM takes approximately 1 The TPM 2.0 specifications introduce high-endurance non-volatile 100 ms and the memory becomes unusable after 300K to 1.4M writes (few days of continuous use) [2]. The goal of our work is to design a rollback protection mechanism that overcomes the performance and security limitations of SGX counters and other known solutions.In particular, our solution should support unlimited and fast state updates, considering a strong adversary model without a single point of failure. The operation returns the last written value or an empty value if no counter was previously written.When an enclave performs a security-critical state update operation (e.g., modifies an account balance or extends a transaction history), it distributes a monotonically increasing counter value over the network to a set of enclaves running on assisting processors (WriteCounter), stores the counter value to its runtime memory and seals its state together with the counter value for local persistent storage. When an enclave needs to verify its state freshness (e.g., upon receiving a request to return the current account balance or transaction history to a remote client), it obtains the counter value from the network (ReadCounter) and compares it to the one in its runtime memory. On the compromised SGX nodes the adversary can freely modify the runtime memory (code and data) of any enclave, and read all enclave secrets and the SGX processor keys.This adversarial model combines a standard DolevYao network adversary [10] with adversarial behaviour (Byzantine faults) on a subset of participating platforms [11,12]. In such a system, some of the assisting enclaves may have outdated counter values, and the system must ensure that only the latest counter value is ever recovered, assuming an adversary that can block messages, and partition the network by choosing which nodes are reachable at any given time.Coordinated enclave restarts. The adversary can launch coordinated attacks where he restarts assisting enclaves to trigger recovery while the target platform is distributing its current counter value.Multiple enclave instances. This approach provides a strong security property (no rollback to any previous state), but if the enclave crashes between the increment and store operations, the system cannot recover from the crash.The second technique is store-then-inc, where the enclave first saves its state on the disk together with the latest input value, after that increments the trusted counter, and finally performs the state update [4,2]. The ROTE system consists of a system service that we call the Rollback Enclave (RE) and a ROTE library that ASEs can use for rollback protection.When an ASE needs to update its state, it calls a counter increment function from the ROTE library. Having a separate RE increases the TCB of our system slightly, but we consider easier application development more important.The ROTE system has three configurable parameters: • n is the number of assisting platforms, • f is the number of compromised processors, and • u is the maximum number of assisting platforms that can be unreachable or non-responsive at time of state update or read for the system to proceed. As an example, a system administrator can select the desired level of security f and robustness u which together determine the required number of assisting platforms n. Alternatively, given n assisting platforms, the administrator can pick f and u. Recall that standard Byzantine consensus protocols require always at least 3 f + 1 replicas.To avoid shared-fate scenarios due to power outages or communication blockades, the participating platforms would ideally have independent or redundant power supply, battery backup, networking and OS maintenance. The RE adds the established shared key k ASEi to a local ASE counter table together with a locally unique enclave identifier id ASEi and adds the same key to its own state. When an ASE is ready to update its state (e.g., a financial application has received a new transaction and is ready to process it and update the maintained account balances), it starts the state update protocol shown in Fig- ure 4. The ASE can now safely perform the state update (e.g., update account balance), save the counter value to its runtime memory for later comparison, and seal its state with the counter. The session key refresh mechanism prevents nodes from communicating with multiple RE instances on one platform (see Section 5 the protection group is that sufficiently many nodes return non-zero counter values (step 6 below). Since group updates are typically infrequent, they can be protected using SGX or TPM counters.At system initialization, the RE creates a monotonic counter using SGX counter service or on a local TPM. Our system is designed to provide the following security property: an ASE cannot be rolled back to a previous state. 5 Finally, the adversary can offer any other data (OfferSeal(arbitrary)) which moves the RE to State 5 where unsealing fails and RE halts (Halt-1 or Halt-2). The required quorum for responses at the time of counter writing and reading is q = f + u + 1 = n+ f +1 2 . Session key establishment procedure is explained below under Forking attacks; the main take-away is that up to u nodes may restart simultaneously and after the nodes are online again the RE needs to establish session keys with every node in the group before proceeding with MC recovery. If the session's keys are outdated, communication with other nodes is disabled and RE knows another instance has run in parallel.The session key refresh mechanism allows us to uniquely identify the latest running instance and prevents parallel communication with two instances running on one platform. Also, by forcing state retrieval and freshness verification after each instantiation and for all ASE requests, the running instance on each platform will always have the latest state and highest MC, thus preventing rollback.Our system also ensures that the adversary cannot establish a parallel protection group on the same platforms and re-direct ASEs to the rogue system causing a rollback. We implemented the RE (950 LoC), an accompanying rollback relay application (1600 LoC), ROTE library (150 LoC), a simple test ASE (100 LoC), and a matching test relay application (100 LoC). The update time between two locations takes 654 ms while between five the update time is 1.37 seconds. For every update transaction, the enclave updates its state, creates a new seal, and writes it to the disk, while the read transaction includes reading from the disk, unsealing and retrieving the counter for comparison. In all three cases the ROTE system provides significantly better state update performance than using SGX counters (e.g., 190 over 6 tx/s for 1KB) while suffering a 20-25% performance drop in comparison to systems which have no rollback protection (e.g., 260 over 190 tx/s for 1KB). A single SGX platform cannot prevent rollback attacks efficiently, but in many practical scenarios the owner or the owners of processors can assign multiple processors to assist each other. The counter value is maintained in RAM and the value is flushed to non-volatile memory periodically (e.g., mod 100) and at controlled system shutdown. 3 The weaker security guarantee is sufficient in applications where the execution of the same input on the same state provides no advantage for the adversary.3 While some enclaves that require random numbers can be made deterministic by using a stateful PRNG and including its state to the saved enclave state, this may be difficult for enclaves that reuse code from existing libraries not designed for this. The purpose of this secret key for initialization is to indicate a legitimate group establishment operation and to prevent a later, parallel group creation by compromised operating systems on the same certified platforms (see Section 5). The RE saves the list of certified public keys PK REi to a group configuration table and runs an authenticated key agreement protocol to establish pair-wise session keys k REi with all REs, and adds them to the group configuration table. On the receiving processor, the RE passes the enclave data to an instance of the same ASE (based on attestation using the received measurement) which can seal it. Combined with group updates (Section 4.7), such enclave data migration enables flexible management of available computing resources. From State 7 the execution moves to State 2 for verifying freshness if a Read() request is received, while the Write() request moves execution to State 8. Because each platform reports a different pseudonym, this process guarantees that the protection group consists of n + 1 separate platforms in contrast to multiple instances on one compromised CPU. Later, when the enclave needs to recover its state, it obtains counter values from assisting enclaves to verify that the recovered state data is of the latest version.We consider a powerful adversary that controls the OS on the target platform and on any of the assisting platforms. We distinguish three such cases: Halt-1 where the system may be able to proceed automatically by simply trying again later (e.g., temporary network issue); Halt-2 where manual intervention from the system administrator is needed (e.g., faulty node that needs to be fixed); and Halt-X where the complete system has to be re-initialized and the latest state of enclaves will be lost (e.g., simultaneous crash of all nodes). Unsealing is successful and the counter value in the seal matches the MC value in the runtime memory, bringing the RE back to State 7. We consider an example where the adversary performs network partitioning by blocking messages during writing and reading.On the first write, the attacker allows the counter value 1 to reach the right side of the group by blocking the messages sent to the left side. For symmetric message encryption and authentication we use 128-bit AES-GCM in encrypt-then-MAC mode. Through these security mechanisms (isolation, sealing, attestation) SGX enables development of various applications and online services with hardened security.The architecture has also its limitations. The second set of operations is related to sealing data for local persistent storage. We tested larger groups of up to 20 platforms using a simulated implementation over a local network and geographically distributed enclaves. Our main idea is to realize rollback protection by storing enclave-specific counters in a distributed system of collaborative enclaves on distinct nodes. The number of remaining platforms is insufficient for RE recovery and the distributed system no longer provides successful MC access, but no rollback is possible (Halt-X, since there is no guarantee that the non-restarted nodes have the latest counter, thereby risking a rollback. • OfferSeal(i, s). The adversary can also restart assisting REs after they have sent the final ACK which will result in successful state update, and successful state recovery of the restarted REs since a sufficient number of the assisting nodes already have the updated counter value. Intel Software Guard Extensions (SGX) enables execution of security-critical application code, called enclaves, in isolation from the untrusted system software [1]. • e ← Create(code). (4) To verify the freshness of its runtime state, the RE performs the steps 4-6 from the RE Restart protocol, to obtain the latest MC from the network. An enclave can save data for local persistent storage. The enclave repeatedly processes incoming transactions at high speed and maintains an account balance for each user or a history of all transactions in the system. The RE reads the counter value from the secure storage using ReadCounter(). SGX-enabled processors are equipped with certified cryptographic keys that can issue remotely verifiable attestation statements on the software configuration of enclaves. The main components of our solution are a state update mechanism that is an optimized version of consistent broadcast protocols [15,16], and a recovery mechanism that obtains lost counters from the rest of the protection group upon enclave restart. After an enclave has sealed at least two data elements s 1 ← Seal(d 1 ) and s 2 ← Seal(d 2 ), the adversary performs Terminate() and Start() to erase the runtime memory of the enclave. The first figure shows ROTE performance for protection groups that are connected over a local network, the second figure shows the simulated performance for a larger group also over a local network, while the third fig