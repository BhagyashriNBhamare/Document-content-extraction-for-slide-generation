Previous proposals on rowhammer mitiga-tions either require hardware changes or follow heuristic-based approaches (based on CPU performance counters). Our extensive evaluation shows that our mitigation (i) can stop available real-world rowhammer attacks, (ii) imposes virtually no run-time overhead for common user and kernel benchmarks as well as commonly used applications, and (iii) does not affect the stability of the overall system. Other attacks can be either mitigated by disabling certain system features, or are impractical for real-world attacks: rowhammer attacks on virtual machines [18,26] heavily depend on memory deduplication which is disabled in most production environments by default. For this, we extend the operating system kernel to enforce a strong physical isolation of user and kernel space.In detail, our main contributions are:• We present a practical software-based defense against rowhammer. In particular, our performance measurements indicate no computational overhead for common user and kernel benchmarks.For a more comprehensive version of this paper with other rowhammer defense solutions, options and more technical details we refer to our full technical report available online [5]. The row buffer is also used to write back the content into the row of memory cells to restore their content.It is noteworthy to mention that there exists the mapping between physical memory address and the rank-, bank-and row-index on the hardware module is nonlinear. As mentioned before, memory access control is an essential building block of modern computer security, e.g., to achieve process isolation, isolation of kernel code and data, and manage read-write-execute permission on memory pages. Modern systems feature a variety of mechanisms to isolate memory, e.g., paging [10], virtualization [1,9], IOMMU [2], and special execution modes like SGX [10] and SMM [10]. 1 To do so, the attacker has to overcome the following challenges: (i) undermine memory caches to directly perform repetitive reads on physical DRAM memory, and (ii) gain access to memory co-located to data critical to memory isolation.Overcoming challenge (i) is complicated because modern CPUs feature different levels of memory caches which mediate read and write access to physical memory. Through alternating accesses to addresses which reside in the same cache line, the attacker can force the memory contents to be fetched from physical memory.The attacker's second challenge (ii) is to achieve the physical memory constellation shown in Figure 2. • The attacker controls a low-privileged user mode process, and hence, can execute arbitrary code but has only limited access to other system resources which are protected by the kernel through mandatory and discretionary access control. Our defense, called CATT, 2 tackles the malicious effect of rowhammer-induced bit flips by instrumenting the operating system's memory allocator to constrain bit flips to the boundary where the attacker's malicious code executes. With CATT in place, the rows which are controlled by the attacker are grouped into the security domain A, whereas memory belonging to higher-privileged entities resides with their own security domain (e.g., the security domain B). We define and maintain two security domains: a security domain for kernel memory allocations, and one security domain for user-mode memory allocations (see also Figure 3). We chose Linux as our target OS for our proof-of-concept implementations for two reasons: (1) its source code is freely available, and (2) it is widely used on workstations and mobile devices. As we described in Section 2.1, DRAM hardware consists of much smaller units of memory, i.e., individual memory cells storing single bits. Hence, our implementation of CATT changes low-level components of the kernel to make the operating system aware of the concept of memory rows.In the following, we describe how we map individual memory pages to domains, keep track of different domains, modify the physical memory allocator, and define partitioning policies for the system's DRAM hardware. The Page Frame Number (PFN) of a physical page is used as an offset into this array to determine the corresponding struct page object. For our case, where we aim at separating kernel and user-space domains, CATT utilizes the call site information, which is propagated to the memory allocator by default. We leverage this information and separate the two domains by setting the domain field of the respective page frame.When processes request memory, the kernel initially only creates a virtual mapping without providing actual physical page frames for the process. In contrast to higherlevel allocators, the buddy allocator only allows for allocating sets of memory pages with a cardinality which can be expressed as a power of two (this is referred to as the order of the allocation). While our policy implementation for a target system largely depends on its architecture and memory configuration, this does not represent a fundamental limitation. Indeed, independent research [15,26] has provided the architectural details for the most prevalent architectures, i.e., it shows that the physical address to DRAM mapping can be reverse engineered automatically for undocumented architectures. To achieve physical separation of user and kernel space we adopt the following strategy: we divide each bank into a top and a bottom part, with a separating row in-between. However, this would likely result in a severe increase of memory latency, since reads and writes to a specific memory bank are served by the bank's row buffer.The benefit of our partitioning policy stems from the fact that we distribute memory belonging to the kernel security domain over multiple banks thereby not negatively impacting performance. Since the row size is the same for all Intel architectures prior to Skylake [7], our implementation for this policy is applicable to a wide range of system setups, and can be adjusted without introducing major changes to fit other configurations as well. We tested 6 The default values for DDR3 on x86 are 4K for the page size, 2 pages per row, 8 banks per rank, 2 ranks per DIMM and between 1 and 4 DIMMs per machine. For the first scenario, we systematically search for reproducible bit flips based on a tool published by Gruss et al. 7 Our second attack scenario leverages a realworld rowhammer exploit published by Google's Project Zero. Because user space only has access to the virtual addresses of these mappings, the tool exploits the /proc/pagemap kernel interface to retrieve the physical addresses. For this, the potential victim page is initialized with a fixed bit pattern and "hammered" by accessing and flushing the two associated aggressor pages. Executing the rowhammer test on these three times and rebooting the system after each test run, we found 133 pages with exploitable bit flips for S1, 31 pages for S2, and 23 pages for S3.To install CATT, we patched the Linux kernel of each system to use our modified memory allocator. Due to vast allocation of memory, the attacker also increases her chances that aggressor pages are co-located to the victim page.Once the preconditions are satisfied, the attacker launches the rowhammer attack to induce a bit flip in victim page. Rowhammer exploits rely on the fact that such a cross domain bit flip is possible, i.e., in the case of our exploit it aims to induce a bit flip in the kernel's page table entries.However, since the exploit by itself is probabilistic, an unsuccessful attempt does not imply the effectiveness of CATT. In particular, we used the SPEC CPU2006 benchmark suite [8] to measure the impact on CPU-intensive applications, LMBench3 [14] for measuring the overhead of system operations, and the Phoronix test suite [16] to measure the overhead for common applications. In particular, we selected a subset of benchmarks 11 that, on one hand, aim to measure memory performance (IOZone and Stream), and, on the other hand, test the performance of common server applications which usually rely on good memory performance.To summarize, our rigorous performance evaluation with the help of different benchmarking suites did not yield any measurable overhead. However, we attribute such results to measuring inaccuracy.SPEC2006 CATT perlbench 0.29% bzip2 0.00% gcc -0.71% mcf -1.12% gobmk 0.00% hmmer 0.23% sjeng 0.19% libquantum -1.63% h264ref 0.00% omnetpp -0.28% astar -0.45% xalan -0.14% milc -1.79% namd -1.82% dealll 0.00% soplex 0.00% povray -0.46% lbm -1.12% sphinx3 -0.58% Mean -0.49% Phoronix CATT IOZone 0.05% Unpack Kernel -0.50% PostMark 0.92% 7-Zip 1.18% OpenSSL -0.22% PyBench -0.59% Apache -0.21% PHPBench 0.35% stream 1.96% ramspeed 0.00% cachebench 0.05% Mean 0.27% LMBench3 CATT Context Switching: 2p/0K -2.44% 2p/16K 0.00% 2p/64K 2.00% 8p/16K -1.73% 8p/64K 0.00% 16p/16K -1.33% 16p/64K 0.99% Mean -0, CATT prevents the operating system from allocating certain physical memory. In their first attack, they use rowhammer to escape the Native Client (NaCl) [27] sandbox. Combined with the first attack, the attacker can remotely compromise the kernel without exploiting any software vulnerabilities. Since the physical memory is filled with page-table entries, there is a high probability that an individual page-table entry is modified by the bit flip in a way that enables the attacker to access other page-table entries, modify arbitrary (kernel) memory, and eventually completely compromise the system. Since the memcpy function of libc -which is linked to nearly all C programs -utilizes the movnti instruction, the attacker can exploit the rowhammer bug with code-reuse attack techniques [21]. Later, Bosman et al. [4] extended this work by exploiting the memory deduplication feature of Windows 10 to create counterfeit JavaScript objects, and corrupting these objects through rowhammer to gain arbitrary read/write access within the browser. While the authors conclude that it is challenging to mitigate rowhammer in software, we present a viable implementation that can mitigate practical user-land privilege escalation rowhammer attacks.Note that all these attacks require memory belonging to a higher-privileged domain (e.g., kernel) to be physically co-located to memory that is under the attacker's control. Therefore, a higher refresh rate alone cannot be considered as an effective countermeasure against rowhammer. The authors thank Simon Schmitt for sacrificing his personal laptop to the cause of science, and Victor van der Veen, Daniel Gruss and Kevin Borgolte for their feedback.This work was supported in part by the German Science Foundation (project P3, CRC 1119 CROSSING), the European Union's Horizon 2020 Research and Innovation Programme under grant agreement No. 643964 (SUPERCLOUD), the Intel Collaborative Research Institute for Secure Computing (ICRI-SC), and the German Federal Ministry of Education and Research within CRISP.