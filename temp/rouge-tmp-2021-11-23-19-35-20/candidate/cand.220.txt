Using OBSERVER, we identified three different techniques to intercept user clicks on the Alexa top 250K websites, and detected 437 third-party scripts that intercepted user clicks on 613 websites, which in total receive around 43 million visits on a daily basis. Nevertheless, Chrome still cannot detect and prevent other possible ways to intercept user clicks, including but not limited to links modified by third-party scripts, third-party contents disguised as first-party contents, and transparent overlays.A systematic study on click interceptions is necessary to deeply understand this emerging threat to web users. Finally, we analyze our measurement results, and explore the intents and consequences hidden behind the click interception practices.However, it is challenging to perform the aforementioned systematic study because of the dynamic and event-driven characteristics of web applications. It also helps us understand the reason why a particular user click is of the interest of a script.In this work, we developed OBSERVER, a prototype of the aforementioned analysis framework by customizing and extending the Chromium browser. Akhawe et al. [1], however, identified that such mechanisms are not comprehensive or suffer from an unacceptable usability cost.Our research complements these studies by investigating new practices of intra-page click interception by third-party scripts, which intercept a victim's clicks on components (including iframes) within the same page/frame. Nikiforakis et al. [24] investigated ad-based URL shortening services and discovered link hijacking by an embedded third-party iframe on a "waiting page" through automatic tab redirects, which the new Chrome browser can prevent [8]. OBSERVER focuses on three fundamental actions that JavaScript code might rely on to intercept clicks: 1) modifying an existing hyperlink in a page; 2) creating a new hyperlink in a page; and 3) registering an event handler to an HTML element to hook a user click. Further, OBSERVER logs the reaction (i.e., navigation) of a page after it intentionally clicks a hyperlink or an element associated with an event handler in the page, to know the URLs to which a click interceptor aims to lead a user.In the following, we first demonstrate our threat model ( ยง3.1). In HTML, JavaScript code is usually enclosed between <script> and </script> tags as an inline script, or stored in an external JavaScript file and loaded with <script> tags as an external script. This kind of inline scripts that are not wrapped within a <script> tag are also compiled into separate JavaScript objects, which are identified by the unique scriptIDs.OBSERVER associates the scriptID of a script with its sourceURL, which is the URL the browser uses to load the remote JavaScript code. To distinguish the dynamically generated script, or the child script (either an inline script or an external script), from the generating script, or the parent script (the one that generates the script), OBSERVER records the scriptID of the parent script as the parentScriptID attribute of the child script. Therefore, OBSERVER aims to monitor all event listeners registered by JavaScript code in a page to identify whether they will navigate a user to a different URL according to a user click.OBSERVER first monitors event listener registration by hooking the addEventListener() API and monitoring accesses to the on-event listeners, to identify the scripts that are interested in user interactions. OBSERVER detects the bottom frame in the JavaScript call stack and further constructs and logs the navigation URL in these APIs in the shadow data store of the target element.One challenge we met in our design is that one event handler can be activated multiple times. They are updated in the DOM tree only when the attributes are first accessed by JavaScript.We hook the above DOM APIs by inserting custom monitoring code in the C++ implementation of the V8 binding layer between the V8 JavaScript engine and the DOM implementation in WebKit. To this end, we run our analysis framework on a 64 core CPU Linux server and collect data from the Alexa top 250K websites.We collect data in two phases for each web page: 1) collecting default data right after page rendering; and 2) collecting reaction data by interacting with a rendered page. We aim to solve this problem using domain substring matching and DNS record matching.Domain substring matching is a heuristic technique to infer that a remote script is a first-party script if the remote script's domain name is similar to the current page's domain name. Specifically, we inspect the DNS SOA records [36] and the DNS NS records [34] We address this limitation by further examining if the name server (NS) records of a script/URL and the first-party web page have an intersection. In general, a script can intercept user clicks with hyperlinks in two ways: modifying one existing (first-party) hyperlink, and adding one hyperlink to a huge element. In particular, it can enclose a significant part of its web page within one <a> tag such that a click on any of the enclosed contents would result in a page navigation that is controlled by it. We do not consider first-party contents with similar characteristics malicious because the first-party websites have the complete freedom to design their contents.This last click interception category could be controversial in our opinion, as some third-party developers may argue that they do not intend to deceive the end users. The only visual hint for discriminating them is the text Sponsored, which was displayed in a very small font size just as the first-party sub captions in the red rectangles. When a user clicked within the area of yellow rectangle, an ad link was opened in a new window.Although third-party scripts can deceive a user with different tricks, the effectiveness can vary dramatically depending on their implementation and the end user's technical background. Next, a third-party script is dynamically included by the first-party website, if it is loaded through a <script> tag that is dynamically created by a first-party script, including those first-party scripts hosted on a different domain. This indicates that these websites deliberately included the click interception scripts, even though they may not intercept user clicks by themselves. In particular, we were directed to some fake anti-virus (AV) software and drive-by download pages when we manually examined some of the click interception URLs.For instance, we were forced to visit an ad click URL by the script https://pndelfast.com/riYfAyTH5nYD/4869 on the website https://torrentcounter.to/. OBSERVER can cover all these wrapper libraries because they would still need to call the above APIs defined in the DOM standard, which is implemented by all browsers to ensure cross-browser compatibility.OBSERVER hooks all these DOM APIs to monitor modifications to the href attribute of <a> tags in the DOM. Each <script> tag is compiled into an individual JavaScript object in the JavaScript engine. In addition, we revealed that these third-party scripts intercepted user clicks in order to monetize user clicks, which is a new practice we observe as committing ad click frauds. We deobfuscate the script (Listing 1), and search for the keyword cookie. Although first-party websites might exhibit similar activities to intercept USENIX Association 28th USENIX Security Symposium 943 user clicks, we do not consider them as malicious, because they have the full privilege to control their own applications. Since some third-party scripts may implement components allowing a user to cancel out the overlay elements, we further exclude those that no longer significantly overlap with any first-party element after our automatic clicks, which must include a click on one of such cancel-out buttons if there are any. The user's browser would open a new URL (the specific URL changes upon each user click) when a user clicks any element on this page 7 . We determine a third-party script as a click interception script if it (indirectly) calls either one of the above two C++ methods in its click event listener that is added to a first-party element. We observed the interception only when we visited the page with a clean cookie, which suggests the script used a cookie to log click interception status. In particular, a script can intercept user click by 1) using an existing hyperlink or creating a new hyperlink; 2) registering a click event handler with an element; and 3) manipulating the UI to deceive a user into clicking elements controlled by the script.In the following, we explain the methods to detect the three classes of click interception. As a result, we cannot use pixel-wise comparison to detect such mimic elements.We utilize the structural information as well as the display properties of a third-party element group to detect mimicry. OBSERVER applies an artificial way to interact with websites, i.e., using a script to click all the elements on a page, in order to automate the analysis. We click custom user interface components (e.g., the video or audio player controls) to command various web applications.Since clicks are important in modern web applications, attackers have launched UI redressing attacks, namely Clickjacking [26], to hijack user clicks. We classify scripts loaded directly from Facebook on Instagram as third-party scripts even though Instagram is owned by Facebook. Next, we calculate a similarity score between the two groups of elements using: 1) the CSS class names of the two root nodes, which are primarily used to describe the representations of HTML elements; 2) the numbers of each kind of media tags, which indicate how media contents are implemented; and 3) the relative sizes of media contents in two groups and the sizes of the largest container nodes, which represent the visual layout of an element group.We set a threshold learned from our training phase to keep only third-party element groups that are very similar to some first-party element groups. Normally, a user may explicitly click a hyperlink to navigate to another web page, or click some components such as images or buttons to interact with the current web page. We designate such undesired click manipulation caused by privilege abuse as click interception in web applications. We discovered that 437 third-party scripts exhibited the activities of intercepting user clicks on 613 websites. Thus, OBSERVER needs to track the dynamic creation of <a> tags in the browser.OBSERVER attaches a shadow initiator attribute to each anchor element in the DOM tree to represent the creator of the object. Overall, we find 203 elements across 172 websites were attached with navigation event handlers, which would drive a user to a third-party URL upon click. The event handlers are the second technique that a script can use to intercept user clicks. Nikiforakis et al. [23] investigated the Alexa Top 10K websites to discover how many remote JavaScript libraries they include and from which library hosting servers they include the scripts. Note that although a first-party script may modify a third-party hyperlink, we think this is legitimate because the first party as the owner of the web page is entitled to include or remove any third-party contents. Last but not least, a web page may contain a large number of event handlers that respond to user clicks. As discussed earlier, we do not consider click interceptions exhibited by first-party scripts as malicious.Based on how a user click could be manipulated, we categorize click interception into three classes-interception by hyperlinks, interception by event handlers, and interception by visual deception. In click spam, unethical content publishers or ad injection attackers [32,37] either trick the users into clicking ads, or use malware to click ads on behalf of the users. For instance, some scripts would activate the page navigation code in their event handlers only when a user first visits a page. We use the keyword a to represent an HTML Anchor Element object and the keyword url to represent a URL string in the following examples. According to our experiment, OBSERVER introduces negligible performance overhead on navigation. To boost ad revenue, the straightforward and effective approach is to leverage real user clicks, as modern ad networks can accurately detect bot-based click frauds [2,6,9,38]. JavaScript code can dynamically create any HTML elements, including an anchor element, in a web page. For example, in the capturing phase, an event is propagated from the root node in the DOM tree-the <html> node, then through any intermediate parent nodes, before finally reaching the target node. In particular, the navigation URL was under the full control of this unknown third-party script and could take the user to any (potentially unsafe) page. Although our approach to determining the relationship between two hosts is not complete, it is good enough for achieving our goal and provides better results compared with a similar approach using only whois records [4]. This script also defines several variables, e.g., "certain_click ", "every_x_click", "delay_before_start_clicks", "click_num", "interval_between_ads_clicks", which we believe to be used to control click interception. One possible reason is that the attaching scripts were loaded after the other third-party scripts had inserted those elements, so that they mistakenly attached event handlers to the other third-party elements.We do not find any third-party script intercepting user clicks by registering navigation event handlers with huge third-party elements. We consider it as a limitation and plan to leverage knowledge in computer vision to develop a better automated testing method in our future work.Next, we detect third-party transparent overlay element groups by comparing the opacity value collected in the display properties with a small threshold (e.g., 0.1). If an external script file is loaded from a remote host into a dynamically inserted <script> element, getting its identity is not different from getting the sourceURL of one static <script> element. In particular, the short URL monetization script https://cdn.adf.ly/js/link-converter.js was found to be statica