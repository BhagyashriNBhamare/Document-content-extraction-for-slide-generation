We find that the design, implementation, and deployment of CORS are subject to a number of new security issues: 1) CORS relaxes the cross-origin "write" privilege in a number of subtle ways that are problematic in practice; 2) CORS brings new forms of risky trust dependencies into web interactions; 3) CORS is generally not well understood by developers, possibly due to its inexpressive policy and its complex and subtle interactions with other web mechanisms, leading to various misconfigurations. But such a workaround approach introduces a number of inherent security issues.Cross origin resource sharing (CORS) is proposed to solve the problems of JSON-P, and to provide a protocol support of authorized access cross-origin network resources. We found that by leveraging this relaxed sending permission, an attacker could exploit previously unexloitable CSRF vulnerabilities, remotely infer victim's accurate cookie size of any website, or use a victim's browser as a stepping-stone to attack binary protocol services inside victim's internal network. By conducting a large-scale measurement on Alexa top 50,000 websites including their 97, 199, 966 distinct sub-domains, we found insecure CORS misconfigurations in 132,476 sub-domains, accounting for 27.5% of all the CORS configured sub-domains across 13.2% of all CORS configured "base domains" (the first lower-level domains of public domain suffixes 1 , sometimes referred to as "public suffix plus one"). In the next three sections (Section 4 to 6), we detail three categories of CORS security issues separately and also demonstrate their security implications with case studies. In order to ensure that different web applications cannot interfere with each other, Netscape introduced the Same Origin Policy (SOP), the fundamental isolation strategy for client-side web application security. Below is an example showing how SMTP commands are encapsulated into a POST request:POST / HTTP/1.1 Host: 192.168.1.1 Content-type: multipart/form-data; boundary=--123 --123 Content-Disposition: form-data; name="foo" HELO example.com MAIL FROM:<somebody@example.com> RCPT TO:<recipient@example.org> --123--There are currently no effective protocol-level solution for these two types of attacks. Second, a JSON-P resource needs to have application-level access control to prevent unauthorized read, which complicate web application implementations.In order to provide a safer and more powerful solution for authorized cross-origin resource sharing, W3C designed Cross-Origin Resource Sharing (CORS) [38] protocol to replace JSON-P. In August 2011, CORS was included in Fetch standard [37] by Web Hypertext Application Technology Working Group (WHATWG) [40], another web standard organization founded by browser vendors including Mozilla, Opera and Apple. In addition to the access control for origins, CORS also provides fine-grained access control for HTTP methods, HTTP headers, and credentials (including cookies, TLS client certificates, and proxy authentication information). The browser then checks whether the policy in the response headers allow for sending the actual cross-origin request.To reduce the performance impact due to preflight requests, CORS provides the Access-Control-Max-Age response header to allow a browser to cache the results of preflight requests. In this model, a requesting website script initiates a resource access request from a user's browser, which automatically adds an Origin header to indicate the requester's identity; then the third-party website returns the access control policy; Finally, the browser enforces the access control policy to determine whether the requester can access the requested network resources. Absent consideration of backward compatibility, CORS could have addressed all cross-origin access to solve and unify the defenses against CSRF, HFPA, and other cross-origin network resource access at the protocol level. Thus, an attacker can still craft malicious content in Content-Type headers by appending an attack payload to a valid value.These implementation flaws open new attack surface in that a web attacker can manipulate a victim's browser to craft exploitation payloads using a CORS simple request, using the browser as stepping-stone to compromise vulnerable yet nominally internal-only services.Case study: In order to demonstrate the threat, we conducted an experiment to exploit an internal service by crafting a malicious Content-Type header. Chrome >16MB/>16MB Apache 8KB/<96KB Edge >16MB/>16MB IIS 16KB/16KB Firefox >16MB/>16MB Nginx 8KB/<30KB IE >16MB/>16MB Tomcat 8KB/8KB Safari >16MB/>16MB Squid 64KB/64KBCase Study: web attackers can exploit header size differences between browsers and web servers to launch side-channel attacks, remotely determining the presence of a victim's cookies on any website. In Chrome, the Performance.getEntries() API directly exposes whether or not a request is successful: if a response has status code 400, the API will return empty response time.Attackers can further infer more details about victim's cookies, such as the size of cookies with specific path attribute by comparing cookie size under different directories, or the size of cookies with the secure flag by comparing the cookie size in HTTP and HTTPS requests. As web applications usually use different amounts and attributes of cookie to keep different states for clients, cookie size information in different dimensions can potentially indicate a victim's detailed status on target website, such as whether the user has visited, logged-in, or is administrator on the target website.The presence of a cookie can leak private information about the victim. For the first type, the browser separates the form data with "=" and joins it with "&", such as "name1 = value1&name2 = value2"; for the second, the browser splits the form data with "=" and joins it with CRLF; for the third, the browser divides each instance of form data into different sections, each separated by a boundary string and a ContentDisposition header like Content-Disposition: form-data; name = "title"; filename = "myfile". By taking advantage of the CORS interfaces, an attacker can craft a cross-origin request, making its header size a multiple of 16 bytes, which is ignored by the AFP server, and constructing its binary body in AFP protocol format for communication with the AFP Server. However, if an HTTPS site is configured with CORS and trusts its own HTTP domain, then an MITM attacker can first hijack the trusted HTTP domain, and then send a crossorigin request from this domain to the HTTPS site, and indirectly read the protected content under the HTTPS domain.Case Study: Fedex.com (Alexa Rank 470), has fully deployed HTTPS and enabled the secure and httponly flag in its cookies to protect against MITM attacks. We found an XSS vulnerability on its subdomain, https://lipidium.lady.mail.ru.By exploiting 3 this XSS vulnerability, we could successfully read sensitive content of the top domain, including the user name, email address, and the number of unread mails information.Trusting third-party domains. If a secure site is configured with CORS and trusts a third-party domain, an attacker could exploit the vulnerability on the third-party domain to indirectly attack the secure site.Case study:The Korean e-commerce site (faceware.cafe24.com) and the Chinese house decoration website (www.jiazhuang.com) trust third-party websites crossdomain.com and runapi.showdoc.cc respectively, but the third-party websites have security issues. By analyzing CORS standards, web frameworks, and web software, we found three reasons for the first risk: 1) The standards don't explicitly emphasize the security risk. This approach improves compatibility and can make Wordpress run in both HTTP and HTTPS environment without any extra configuration, but it introduces new security risks.We also do not find any explicit security warnings for the second risk (trusting third-party domains) in either of the standards (W3C or Fetch). The W3C CORS standard states that an Access-ControlAllow-Origin header value can be either an origin list, "null", or "*", whereas in the WHATWG's Fetch standard, it can only be a single origin, "null", or "*". We found a number of misconfigurations are rooted in this category.In general, we can classify the misconfigurations into two sub-categories: 1) blindly reflect requester's origin in response headers; 2) attempt to validate requester's origin but make mistakes.1). In our measurement, 15,902 websites (about 3.3%) out of 481,589 CORS-configured websites have this permissive configuration, including a number of popular websites such as account.sogou.com, analytics.microsoft.com, account.nasdaq.com.2). Due to the poor expressiveness of CORS policies, web developers have to dynamically validate the request Origin header and generate corresponding CORS policies. For example, www.example.com wants to allow any example.com subdomain, but it only checks whether the Origin header value ends with "example.com", leading to allow attackexample.com, which can registered by attackers. RFC 6454 [8] states that if a request comes from a privacy-sensitive context, the Origin header value should be null, but it does not explicitly define what is a privacy-sensitive context.CORS reuses the Origin header, but CORS standards also lack clear definition of null value. Although CORS made attempt to restrict the default sending permission such as restricting Content-Type to three white-list values, it unintentionally relaxed the permissions in subtle ways, leading to various new cross-origin attacks.Under web rapid iterative development model, new protocols aren't fully evaluated before deployed. Due to web developers' requirements or browsers' competitions, in January 2009, some vendors have implemented this immature protocol into browsers as new features, which include some immature design, such as CORS policies only support a single origin [10]. For example, originally, CORS limited Content-Type to three specific values excluding "application/json", so many web applications used this restriction as CSRF defenses against JSON APIs. To address attacks against intranet services, Chrome is also considering preventing access to localhost/RFC1918 addresses from public websites [13]. Safari: Apple informed us that their investigation revealed that comprehensive changes are required to address these issues, and they are testing those changes with a beta testing program.Edge/IE: Microsoft acknowledged and thanked our report, but provided no further comment to date.CORS frameworks: Tomcat, Yii and Go-CORS frameworks have modified their software to not reflect origin header when configured to '*'. Revay found POST body format was relaxed in XMLHttpRequest API, which could lead to file upload CSRF [30], and we further provided a real world case to demonstrate this threat.In the past, there have been some security studies on exploiting and mitigating cross origin sending attacks [4,9,14]. Johnson measured the reflecting origin misconfiguration in the Alexa top 1M sites [20], and Mller [26] measured different misconfigurations mentioned in Kettle's work. To aid in identifying CORS misconfiguration issues, we also provide an open-source tool 6 , to help web developers and security-practitioners to automatically evaluate whether a website is vulnerable to the misconfiguration problems we found.The reality of CORS security is an unfortunate epitome of web security. This work was partially supported by the Joint Research Center of Tsinghua University and 360 Enterprise Security Group, and was also funded by National Natural Science Foundation of China (grant #U1636204 and #61472215), the National Key Research and Development Program of China (#2017YFB0803202), the US National Science Foundation(grant #CNS-1237265), and by generous support from Google and IBM.