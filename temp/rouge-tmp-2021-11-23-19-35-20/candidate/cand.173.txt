The main approach used to combat vulnerabilities is patching; however, it is challenging to ensure that a security patch gets propagated to a large number of affected software distributions, in a timely manner, especially for large projects that have multiple concurrent development branches (i.e., upstream versus downstream). Bug search, on the other hand, does not make assumptions on which of the target functions are affected and simply look for all functions or code snippets that are similar to the vulnerable one, e.g., "which of the functions in a software distribution looks like a vulnerable version of tls1 process heartbeat()." In fact, most of the binary-only bug search studies include software such as Linux and openssl.Second, many open-source code or components are widely reused in closed-source software, e.g., libraries and Linux-based kernels in IoT firmware [13,26]. This is a critical change that allows us to leverage the source-level insight that can inform the binary patch presence test.Unfortunately, the closely related work on binary-only bug search misses an important link in order to be twisted to perform accurate patch presence test. However, since security patches are mostly small and subtle changes [30], similarity-based approaches cannot effectively distinguish patched and un-patched versions.In this paper, we propose FIBER, a complementary system that completes the missing link and takes the similarity-based bug search to the next level where we can perform precise and accurate patch presence test. We address this problem in two steps: First, inspired by typical human analyst's behaviors, we will pick and choose the most suitable parts of a patch as candidates for binary signature generation. As more advanced solutions, Genius [13] and Gemini [31] extract feature representations from the control flow graphs and encodes them into graph embeddings (high dimensional numerical vectors), which can speed up the matching process significantly. BinHunt [14] and iBinHunt [24] use symbolic execution and theorem provers to formally verify basic block level semantic equivalence.FIBER is in a unique position that leverages the source-level information to answer a more specific question -whether the specific affected function is patched in the target binary.To our knowledge, Pewny et al.'s work [26] is the only one that claims source-level patch information can be leveraged to generate more fine-grained signatures for bug search (although no implementation and evaluation). The "to arm pmu()" used by the assignment is a small utility macro, which will result in few instructions without changing the control flow graph (CFG), making it difficult to be located at binary level. Now we have decided to search in the target binary function for the existence of line 11 in Fig 1, typically we will start from matching the CFG structure since it is easy and fast. Specifically, by tracking the register's origin (listed at the bottom of Fig 1), we can finally tell the differences of the two "cmp" instructions and correctly decide that the bolded basic block is the one that maps back to line 11. Fig 2 illustrates the system architecture, which is abstracted from human analysts' procedure.It has four primary inputs: (1) the source-level patch information; (2) the complete source code of a reference; (3) the affected function(s) in the compiled reference binary; (4) the affected functions in the target binary. Fortunately, these similarity-based approaches solve this very problem by identifying functions in the target binary that look similar to a reference one, thus the symbol table of the target binary can actually be inferred -in addition to research studies [13,31], BinDiff [2] also has a built-in functionality serving this purpose.We leave the integration of such functionality into FIBER as future work, since all kernel images as test subjects in our evaluation have embedded symbol tables.This shows that the similarity-based bug search and the more precise patch presence test are in fact not competing solutions; rather, they complement each other. A patch can either add or delete some lines, thus we can either changes based on either the absence of patch (i.e., existence of deleted lines) or presence of patch (i.e., existence of added lines). For instance, the example source signature in Fig 1 at line 11 encodes the fact that the first function parameter is compared against a field of the last parameter, and this semantic relationship is unique (which we need to preserve in binary signatures). If no single statement is unique, we consider all its adjacent statements as potential context choices.The "adjacent" is bi-directional and on the control flow level (e.g., the "if" statement has two successors and both of which can be considered the context), thus there can be multiple context statements. Theoretically, we can label the type of every variable in the reference binary (registers or memory locations in the binary) and make sure the types inferred in the target match (more details in ยง4.3.1). If the only change in a patch is related to the content of the string, then both binary signature generation and matching should dereference the char* pointer and obtain the actual string content; otherwise, the signature will simply contain a const memory pointer whose value can vary across different binaries. Unlike statements such as a function call, which may get inlined depending on the compiler options, structural changes in general are much more robust.We categorize the source changes into several general types: (1) function invocations (new function call or argument change to an existing call), (2) condition related (new conditional statement or condition change in an existing statement), (3) assignments (which may involve arithmetic operations). Generally, we rank "new function call" (if FIBER determines that it is not inlined in the reference binary 5 ) the highest because one can simply decide the patch presence by the presence of the function invocation, which is straightforward with the symbol table.We also rank "condition" related signatures (e.g., "if" statement) high because it introduces both structural changes and semantic changes. We will then construct a local CFG that includes all the nodes containing the identified instructions, which is straightforward if these nodes are connected to each other, otherwise, we need to add some padding nodes to make a connected local CFG, which by nature is a steiner tree problem [15]. For function call instructions, the root instructions will include the push (assuming x86) of arguments (as they each become the last instruction in a Table 1: Types of root instructions data flow chain to prepare a specific argument), and the call instruction (to complete the function invocation semantic). Now we need to make sure that the root instructions are sufficiently labeled (which is our binary signature) such that they can be uniquely mapped to source changes.Following the observation mentioned earlier in ยง4.1 that the target and reference function should share variable-level semantics (as they are simply different versions of the same function), we formulate the goal as mapping the operands (registers or memory locations) of the root instructions back to source-level variables. This is sufficient because if the target function indeed Note that from a function's perspective, any operand in an instruction can really be derived from only four sources:(1) a function parameter (external input), e.g., ebp+0x4 if it is x86, X0 or X1 if it is aarch64;(2) a local variable (defined within the function), e.g., ebp-0x8 in x86 or sp+0x4 in aarch64 (which use registers to pass arguments); (3) return values from function calls (external source), e.g., a register holding the return value of a function call; (4) an immediate number (constant), e.g., instruction/data address (including global variables), offset, other constants;These sources all have meaningful semantics at the source level. We need to conduct additional binary-level analysis to infer if a target address is pointing to the right basic block (e.g., by checking the similarity of the target basic block), or the offset is pointing to a specific field (e.g., by type inference [21,10]). In our experience, we find that even without having a precise knowledge of these basic elements in the signature, the semantic formula that describe them is typically already unique enough to annotate the operands; ultimately allow us to uniquely map the root instructions to source-level statements. Interestingly, even if we do not perform the above analysis, the fact that there is a root instruction storing a unique formula X0*X1+0x2 to a local variable (any) is already unique enough to be a signature that lead to a correct match in the target.Second, to show that isolated basic block level analysis is not sufficient, we note the mov instruction in the first basic block of the target binary which saves X0 to X3 to free up X0 for the return value of do sth(). This requires generating the data flow graph for each basic block in target function binary, which is more expensive than previous steps but still manageable.With above features, we can quickly narrow down the search space in the target function. Further, since we use Angr which lifts the binaries into an intermediate language VEX (which abstracts away instruction set architecture differences), most of our system works flawlessly without the need of tailoring for architectural specifics. Un-constrained inputs may also lead the execution engine to include infeasible paths in real world execution, however, our goal for semantic formulas is to make them comparable between reference and target binaries, as long as we use the same procedure for both sides, the extracted formulas can still be compared for the purpose of patch presence test. To probe the compilation configuration used for the target binary, we first compile multiple reference binaries with all combinations of common compilers (we use gcc and clang) and optimization levels (we use levels O1 -O3 and Os 7 ), then use BinDiff [2] to test the similarity of each reference binary and the target binary, the most similar reference binary will finally be used for binary signature generation. Following this procedure (which is yet to be automated), we observed in our evaluation that kernel 6 and 7 as shown in table 2 use gcc with O2 optimization level, while all other 6 kernels use gcc with Os optimization level, which is confirmed by our inspection of the source code compilation configurations (e.g., Makefile). It is worth noting that our patch collection is oriented to "angler" kernel, which will run on the Qualcomm hardware platform, while kernel 6 and 7 intend to run on a different platform (i.e., Kirin), thus many device driver related patches do not apply for kernel 6 and 7 (we cannot even locate the same affected functions). In patch presence test, we assume that all patches are not applied by default. We list the time consumption of the offline phase in table 3 and that of online phase in table 2. This illustrates the value of tools like FIBER.Besides, we also identify 4 vulnerabilities in table 4 that eventually got patched in a later kernel release but not in the earliest kernel release after the patch release date, indicating a significant delay of the patch propagation process.It is worth noting that FIBER intends to test whether the patch exists in the target kernel, however, the absence of a security patch does not necessarily mean that the target kernel is exploitable. There are 5 patches in our collection that intend to change only the format strings as function arguments.Take the patch for CVE-2016-6752 in Fig 6 as an example, the specifier p is changed to pK. The patch for CVE-2016-3858 (shown in Fig 6) has a prior patch in the upstream (which deletes a "if-then-return" statement) for the same affected function, which was not applied to our reference kernel, making the two functions look different although both patched. However, with the insights of the fine-grained change site, FIBER can correctly figure out that only the value of the 2nd function argument matters in the matching and it should be non-zero if patched, thus effectively handle such cases.Similar Basic Blocks.