We propose three FUZZIFICATION techniques: 1) SpeedBump, which amplifies the slowdown in normal executions by hundreds of times to the fuzzed execution, 2) BranchTrap, interfering with feedback logic by hiding paths and polluting coverage maps, and 3) AntiHybrid, hindering taint-analysis and symbolic execution. Our evaluation on popular fuzzers and real-world applications shows that FUZZIFICATION effectively reduces the number of discovered paths by 70.3% and decreases the number of identified crashes by 93.0% from real-world binaries, and decreases the number of detected bugs by 67.5% from LAVA-M dataset while under user-specified overheads for common workloads. First, it should be effective for hindering existing fuzzing tools, finding fewer bugs within a fixed time; second, the protected program should still run efficiently in normal usage; third, the protection code should not be easily identified or removed from the protected binary by straightforward analysis techniques.No existing technique can achieve all three goals simultaneously. However, software diversification is powerless on hiding the original vulnerability from the attacker's analysis; thus it is not a good approach for FUZZIFICATION.In this paper, we propose three FUZZIFICATION techniques for developers to protect their programs from malicious fuzzing attempts: SpeedBump, BranchTrap, and AntiHybrid. The AntiHybrid technique aims to thwart hybrid fuzzing approaches that incorporate traditional fuzzing methods with dynamic taint analysis and symbolic execution.We develop defensive mechanisms to hinder attackers identifying or removing our techniques from protected binaries. We reuse existing binary code to realize BranchTrap to prevent an adversary from identifying the injected branches.To evaluate our FUZZIFICATION techniques, we apply them on the LAVA-M dataset and nine real-world applications, including libjpeg, libpng, libtiff, pcre2, readelf, objdump, nm, objcopy, and MuPDF. We also perform an analysis to show that data-flow and control-flow analysis techniques cannot easily disarm our techniques.In this paper, we make the following contributions:• We first shed light on the new research direction of antifuzzing schemes, so-called, FUZZIFICATION. Our results show that the proposed techniques hinder these fuzzers, finding 93% fewer bugs from the real-world binaries and 67.5% fewer bugs from the LAVA-M dataset, and 70.3% less coverage while maintaining the user-specified overhead budget. Current research highlights several fast execution techniques, including (1) customized system and hardware to accelerate fuzzed execution and (2) parallel fuzzing to amortize the absolute execution time in large-scale. This fuzzing strategy is based on two empirical observations: (1) a higher path coverage indicates a higher chance of exposing bugs; and (2) mutating inputs that ever trigger new paths is likely to trigger another new path. First, fuzzers do not distinguish input bytes with different types (e.g., magic number, length specifier) and thus may waste time mutating less important bytes Developers create a protected binary with FUZZIFICATION techniques and release it to public. One is compiled with FUZZIFICATION techniques to generate a protected binary, and the other is compiled normally to generate a normal binary. The trusted parties can launch fuzzing on the normal binary with the native speed and thus can find more bugs in a timely manner. Pack & obfuscation ✔ ✔ ✗ ✔ Bug injection ✔ ✔ ✗ ✗ Fuzzer identification ✔ ✗ ✔ ✗ Emulator bugs ✔ ✗ ✔ ✔ FUZZIFICATION ✔ ✔ ✔ ✔ We consider motivated attackers who attempt to find software vulnerabilities through state-of-the-art fuzzing techniques, but with limited resources like computing power (at most similar resources as trusted parties). Adversaries who have access to the unprotected binary or even to program source code (e.g., inside attackers, or through code leakage) are out of the scope of this study. Injecting arbitrary code snippets that trigger non-exploitable crashes can cause additional bookkeeping overhead and affect end users in unexpected ways [31]. Second, BranchTrap fabricates a number of input-sensitive branches to induce the coverage-based fuzzers to waste their efforts on fruitless paths ( §4). Also, it intentionally saturates the code coverage storage with frequent path collisions so that the fuzzer cannot identify interesting inputs that trigger new paths. Third, AntiHybrid transforms explicit data-flows into implicit ones to prevent data-flow tracking through taint analysis, and inserts a large number of spurious symbols to trigger path explosion during the symbolic execution ( §5). Our tool automatically determines the number of code paths to inject delays and the length of each delay so that the protected binary has overhead under the user-defined budget during normal executions. These blocks are treated as cold paths in delay injection.Our profiling does not require the given test cases to cover 100% of all legitimate paths, but just to trigger the commonly used functionalities. We perform the following two steps repeatedly to determine the set of code blocks to inject delays and the length of each delay:• We start by injecting a 30ms delay to 3% of the leastexecuted basic blocks in the test executions. For example, CSmith conducts pointer analysis to detect any access to an out-of-scope stack variable or null pointer dereference, uses explicit initialization to prevent uninitialized usage, applies math wrapper to prevent unexpected integer overflow, and analyzes qualifiers to avoid any mismatch. Recent fuzzing proposals, like VUzzer [52] and T-Fuzz [48], identify errorhandling basic blocks through profiling and exclude them from the code coverage calculation to avoid repetitive executions. Once a fuzzed execution triggers the fabricated branch, the fuzzer will set a higher priority to mutate that input, resulting in the detection of more fake paths. In this way, the fuzzer will keep wasting its resources (i.e., CPU and memory) to inspect fruitless but bug-free fake paths.To effectively induce the fuzzers focusing on fake branches, we consider the following four design aspects. Finally, BranchTrap cannot be easily identified or removed by adversaries.A trivial implementation of BranchTrap is to inject a jump table and use some input bytes as the index to access the table (i.e., different input values result in different jump targets). Our idea is inspired by ROP, which reuses existing code for malicious at- = arg1^arg2 index jmp table [index] ... tacks by chaining various small code snippets. 4 Finally, the execution returns to the original return address.The ROP-based BranchTrap has three benefits:• Effective: Control-flow is constantly and sensitively changed together with the user input mutation; thus FUZZIFICATION can introduce a sufficient number of unproductive paths and make coverage feedback less effective. • Low overhead: BranchTrap introduces low overhead to normal user operations (e.g., less than 1% overhead) due to its lightweight operations (Store argument; XOR; Resolve jump address; Jump to gadget). We provide developers an interface to configure ROP-based BranchTrap and coverage saturation for optimal protection. For binaries with fewer functions, we provide an option for developers to split existing basic blocks into multiple ones, each connected with conditional branches. Once injected codes are run by the fuzzer multiple times, QSym identifies the repetitive basic blocks (i.e., injected hash function) and performs basic block pruning, which decides not to generate a further constraint from it to assign resources into a new constraint. We set up the evaluation on two machines, one with Intel Xeon CPU E7-8890 v4@2.20GHz, 192 processors and 504 GB of RAM, and another with Intel Xeon CPU E7-4820@2.00GHz, 32 processors and 128 GB of RAM.To get reproducible results, we tried to eliminate the nondeterministic factors from fuzzers: we disable the address space layout randomization of the experiment machine and force the deterministic mode for AFL. The nine real-world programs include four applications from the Google fuzzer test-suite [24], four programs from the binutils [20] (shown in Table 2), and the PDF reader MuPDF. For AFL, the reduction rate varies from 14% to 97% and FUZZIFICATION reduces over 90% of path discovery for libtiff, pcre2 and readelf. We analyzedSpeedBump BranchTrap AntiHybrid All AFL-QEMU -66% -23% -18% -74% HonggFuzz (PT) -44% -14% -7% -61% QSym (AFL-QEMU) -59% -58% -67% -80%Average -56% -31% -30% -71% Table 5: Reduction of discovered paths by FUZZIFICATION techniques. The result of libjpeg shows an interesting pattern: QSym finds a large number of real paths from the original binary in the last 8 hours, but it did not get the same result from any protected binary. Therefore, FUZZIFICATION can effectively hinder fuzzers and makes them spend significantly more time discovering the same number of crash-inducing inputs. Specifically, we used tiny delay primitives (i.e., 10 µs to 100 µs), tuned the ratio of basic block instrumentation from 1% to 0.1%, reduced the number of applied AntiHybrid components, and injected smaller deterministic branches to reduce the code size overhead. Note that the fuzzing result on the original binaries is different from the ones reported in the original papers [67,52] for several reasons: VUzzer and QSym cannot eliminate non-deterministic steps during fuzzing; we run the AFL part of each tool in QEMU mode; LAVA-M dataset is updated with several bug fixes 3 . To understand the practicality of FUZZIFICATION on large and realistic applications, we choose six programs that have a graphical user interface (GUI) and depend on tens of libraries.As fuzzing large and GUI programs is a well-known challenging problem, our evaluation here focuses on measuring the overhead of FUZZIFICATION techniques and the functionality of protected programs. When applying the SpeedBump technique, we have to skip the basic block profiling step due to the lack of command-line interface (CLI) support (e.g., readelf parses ELF file and displays results in command line); thus, we only insert slow down primitives into error-handling routines. Note that the code size overhead is much smaller than that of previous programs (i.e., 62.1% for eight relatively small programs Table 2 and over 100% size overhead for simple LAVA-M programs Table 6). Control Data Manual matching analysis analysis analysis SpeedBump ✔ ✔ ✔ - BranchTrap ✔ ✔ ✔ - AntiHybrid - ✔ ✔ - We evaluate the robustness of FUZZIFICATION techniques against off-the-shelf program analysis techniques that adversaries may use to reverse our protections. We confirm that no specific patterns can be found in SpeedBump and BranchTrap because we leverage CSmith [66] to randomly generate a new code snippet for each FUZZIFICATION process.Second, control-flow analysis can identify unused code in a given binary automatically and thus automatically remove it (i.e., dead code elimination). We run protected binaries inside the debugging tool, GDB, to inspect data dependencies between the injected code and the original code. However, since the injected code is functionally similar to normal arithmetic operations and has control-and data-dependencies on the original code, we believe that the manual analysis is time-consuming and error-prone, and thus we can deter the time for revealing real bugs. Existing mitigation efforts either aim to avoid program bugs (e.g., through type-safe language [32,44]) or aim to prevent successful exploits, assuming attackers will find bugs anyway (e.g., through control-flow integrity [1,16,30]). It is possible that attackers who know the details of our FUZZIFICATION techniques propose a specific method to effectively bypass the protection, such as by utilizing our implementation bugs. Fortunately, the protection by FUZZIFICATION is quite flexible, where we provide various configuration options for developers to decide the optimal trade-off between security and performance, and our tool will automatically determine the maximum protection under the overhead budget. Various fuzzing techniques and tools have been proposed [57,52,29,21,34], developed [72,37,25,23,18,9], and used to find a large number of program bugs [51,72,59,26,10]. Recently, researchers have been using fuzzing as a general way to explore program paths with specialties, such as maximizing CPU usage [49], reaching a particular code location [5], and verifying the deep learning result empiri-cally [47]. Among them, Göransson et al. evaluated two straightforward techniques, i.e., crash masking to prevent fuzzers finding crashes and fuzzer detection to hide functionality when being fuzzed [27]. Software diversity instead provides different implementations of the same program for different execution environments, aiming to either limit attacks on a specific version (usually a small set of all distributions), or significantly increase the effort to build generic exploits [35,3,53,50].