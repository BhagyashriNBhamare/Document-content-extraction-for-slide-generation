However, contexts based on the recent execution history are often inadequate in breaking down large ECs due to the limited number of incoming execution paths to an indirect control transfer instruction (ICT).1 In this paper, we propose a new context for CFI, origin sensitivity, that can effectively break down large ECs and reduce the average and largest EC size. Our evaluation shows that OS-CFI can substantially reduce the largest and average EC sizes (by 98% in some cases) and has strong performance-7.6% overhead on average for all C/C++ benchmarks of SPEC CPU2006 and NGINX. Similarly, 2-call-site sensitive CFI uses two levels of return addresses as the context.Execution history based context can substantially reduce the average EC size, but is much less capable in reducing the largest EC size. It supports both C-style indirect calls and C++ virtual calls with slightly different definitions for them: the origin for the former is the code location where the called function pointer is most recently updated; that for the latter is the location where the receiving object (i.e., the object for which the virtual function is called) is created. Our evaluation with SPEC CPU2006, NGINX, and a few real-world exploits shows that the prototype can significantly reduce the average and largest EC sizes, and incurs only a small performance overhead: 7.6% on average for the SPEC CPU2006 and NGINX benchmarks.In summary, this paper makes the following contributions:• We propose the concept of origin sensitivity that can substantially reduce both the average and largest EC sizes to improve the security of CFI. • We have built a prototype of OS-CFI with the following design highlights: we re-purpose the bound table of MPX to securely store and retrieve origins, and use TSX to protect the integrity of reference monitors; we piggyback on the analysis of SUPA, a precise static points-to algorithm, to built the origin-sensitive CFGs. Line 1 -10 shows how simulated networks are initialized: it creates an ExecuteOnStartup object for each network to call the network's initialization code; The constructor of ExecuteOnStartup sets the private member code_to_exec (a function pointer) and adds itself to a linked list (Line 18 -23). Figure 1: Example to illustrate origin sensitivity sensitivity can distinguish individual calls to code_to_exec (because it records each iteration of the while loop); but it is difficult to decide which target is valid because that depends on the unspecified order in which the constructors are called. The origin is propagated through the program along with the function address when it is assigned to variables or passed as an argument, in a way similar to how the taint is propagated in taint analysis [33]. Moreover, this example clearly demonstrates that CFI systems for C++ programs must fully support C-style ICTs because many C++ programs use them (they may even have the largest ECs). The origin can now be represented as a tuple of (CS, I o Other execution contexts such as last-branch record and processor trace can only be accessed in the kernel. C++'s constructors cannot be called virtually or indirectly.3 As such, a call to the constructor can create an object of just one class. We report the largest EC sizes in Table 1 for all the benchmarks having the largest EC size greater than or equal to 10 (ten other benchmarks have less than 10 targets for every ICT). A similar case is shown in Fig. 4 of Section 4 with the code snippet.3Bjarne Stroustrup's C++ Style and Technique FAQ: "To create an object you need complete information. Large ECs are the weakest link in a CFI system since they provide the most leeway in "bending" the control flow within the CFI policy• Security: context-sensitive CFI systems, including OS-CFI, have more complex reference monitors to collect and maintain the contextual information. We adopt this policy to improve the performance without sacrificing the security: origin sensitivity is a powerful context that can substantially break down large ECs, but it has to collect and maintain more metadata at the run-time. We represent these CFGs as a set of tuples:• Call-site sensitive CFG: each tuple of this CFG has the following form: (CS 1/2/3 , I i , T last store to the related function pointer; while I i is where the function pointer is actually called. It is an on-demand context-, flow-, and field-sensitive points-to analysis based on the SVFG. Next, we describe how OS-CFI generates the related tuples for the indirect calls in Fig. 2 since they are the more complex cases.In Fig. 2, Base has a protected member function pointer fmt, which is called by Base.print and Child.print. SUPA can create a def-use chain from Line 18 to the assignment of the fmt field at Line 12 because it is field-sensitive. Specifically, we create a hash table for each CFG and instrument the program (at the LLVM IR level) to collect the run-time metadata at the origins. The context for the former is the return addresses on the call stack, which can be fetched from the shadow stack at the ICT sites. Io is the address of the origin (i.e., the instruction that last writes to the function pointer), and CS o is the most recent return address on the call stack. Fig. 2 has been annotated with the calls to store metadata at Line 13 and 31 for Base.fmt function pointer.Virtual calls: the origin for virtual calls is the location where the object is created (I o ). Each virtual function of a class has a fixed offset in vTable. After an object is created, its vTable will not be changed.The reason we use vPtr's address as the key (instead of the base address of the object, even though they both can uniquely identify the object) will be clarified as we discuss the metadata storage. Note that the constructor of a sub-class calls the constructor of its base classes first. We thus add the code near the end of the constructor so that the metadata will not be mistakenly overwritten.Metadata storage: the storage of the contextual information (i.e., the metadata) is a key design component of OS-CFI. We store the (key, value) pair at each origin site, and query the storage with the same key to retrieve the origin information at each ICT site. The bound table is organized and operates like a two-level page table, as shown in Fig. 3: the bounds directory points to the second-level bounds tables; each bounds table contains a number of bound entries. To locate a bound entry, MPX first indexes into the bounds directory to retrieve the base of the related bounds table, and then uses the second index to locate the related bound entry. Even though we are supposed to store the lower and upper bounds in this table, the hardware does not perform any validations on the bounds, as confirmed by both the official document and our experiments. Therefore, we can detect any manipulation of these pointers, after they have been stored, without the extra performance penalty.For virtual calls, OS-CFI uses the address of the receiving object's vPtr pointer, which points to the object's vTable, as the key. The instrumentation at each ICT site is rather straightforward: it first queries the metadata storage with the key and its content to retrieve the origin. Use the indirect call as an example, we need to reconstruct the tuple of ((CS o , I o ), I i , T ). (CS o , I o )is the origin fetched from the metadata storage; I i represents the address of indirect call instruction; T is the target, i.e., the value of the function pointer. Note that this use of the bound check does not conflict with OS-CFI's use of the MPX table since the bound check can be performed with just the bound registers.The hash tables for CFGs are protected as the read-only memory and thus cannot be changed by the attacker. We found that, even with a generous budget on a relatively powerful machine (a 16-core Xeon server with 64GB of memory), SUPA can still run out of budgets for complex programs, such as gcc and perlbench. In addition, SUPA may return empty results because of the language features it does not yet support (e.g., C++'s pointers to member functions). We suspect SUPA is still more scalable and/or precise than other publicly available points-to analysis algorithms, and expect these problems to be solved soon. Even µCFI can only provide the same precision as context-insensitive CFI in this case because the constraint data (piecet(i)) can potentially be compromised before being captured by µCFI using processor trace [17]. We expect OS-CFI to substantially break down most of these ECs once the problems in SUPA are resolved.Next, we present a few case studies to illustrate how OS-CFI can successfully break down largest ECs in some programs of SPEC CPU2006.6Table 3 and 4 cannot be compared directly because Table 4 includes the ICTs SUPA failed to resolve while Table 3 does not. omnetpp with the largest number of targets -35 targets in context-insensitive CFG. As such, OS-CFI can uniquely identify the specific destructor to be called; i.e., it can enforce a perfect CFI policy at Line 5 since the EC size is 1. I o is the location of the instruction that last writes to the function pointer (Line 7), while CS o is the call sites of the store function (Line 18 Because HMMFileRead is called in the main function, callsite sensitivity is not useful for this case at all because there is just one call site. Our system also successfully prevented this exploit.In both cases, OS-CFI not only blocked the exploits but also constrained the vulnerable ICTs to a single target at run-time. All the experiments were conducted on a server with the Xeon E3-1275 processor and 64 GB of memory, running the 64-bit Ubuntu 16.04.5 LTS Server system. Other return protection can be integrated with OS-CFI too, such as shadow stack [10] and Intel CET [19], with different security and performance impacts. The performance of OS-CFI is better than PathArmor (8.5%) [38] and PittyPat (12.7%) [14], even though OS-CFI is a whole program protection while PathArmor only protects a few selected syscalls and PittyPat uses separate threads to parse processor traces (this reduces the number of available CPU cores by half). Because all three systems cannot enforce the CFI policy at every ICT, their focus is to protect the other part of the system from attacks. OS-CFI uses the stock kernel, whose general MPX support is sufficient.OS-CFI derives its CFGs from a context-, flow-, and fieldsensitive static points-to analysis. Burow Table 6: Comparison between OS-CFI and recent (context-sensitive) CFI systems independently discovered the way to re-purpose the MPX table as a generic key-value store [5].