A typical case might look like the following: char * password = malloc(PASSWORD_SIZE); // ... read and check password memset(password, 0, PASSWORD_SIZE); free(password);The memset is intended to clear the sensitive password buffer after its last use so that a memory disclosure vulnerability could not reveal the password. In this case, because the buffer is passed to free after being cleared, the compiler determines that the memory scrubbing memset has no effect and eliminates it.Removing buffer scrubbing code is an example of what D'Silva et al. [30] call a "correctness-security gap." Security-conscious developers have been left to devise their own means to keep the compiler from optimizing away their scrubbing functions, and this has led to a proliferation of "secure memset" implementations of varying quality.The aim of this paper is to understand the current state of the dead store elimination problem and developers' attempts to circumvent it. While not a perfect solution, we believe ours combines the best techniques available today and offers developers a readyto-use solution for their own projects.We also developed a scrubbing aware C compiler based on Clang. Our performance evaluation shows that our modified compiler introduces virtually no performance penalty.In total, our contributions are as follows:O We survey scrubbing techniques currently found in the wild, scoring each in terms of its availability and reliability. They developed a static checker called STACK that identifies such code in C/C++ programs and they used it to uncover 160 new bugs in commonly deployed systems.Our work examines how developers handle the correctness-security gap introduced by aggressive dead store elimination. While the soundness and security of dead store elimination has been studied formally [28,31,29], the aim of our work is to study the phenomenon empirically.Bug reports are littered with reports of DSE negatively affecting program security, as far back as 2002 from Bug 8537 in GCC titled "Optimizer Removes Code Necessary for Security" [3], to January 2016 when OpenSSH patched CVE-2016-0777, which allowed a malicious server to read private SSH keys by combining a memory disclosure vulnerability with errant memset and bzero memory scrubs [10]; or February 2016 when OpenSSL changed its memory scrubbing technique after discussion in Issue 445 [22]; or Bug 751 in OpenVPN from October 2016 about secret data scrubs being optimized away [26]. The CERT C Secure Coding Standard [37] recommends SecureZeroMemory as a Windows solution, memset_s as a C11 solution, and the volatile data pointer technique as a C99 solution. Fails in at least one configuration.In Section 4 we also compare the performance of a subset of the surveyed techniques.The scrubbing techniques we found can be divided into four groups based on how they attempt to force memory to be cleared:Rely on the platform. Annex K of the C standard (ISO/IEC 9899-2011) introduced the memset_s function, declared as errno_t memset_s(void* s, rsize_t smax, int c, rsize_t n);Similar to memset, the memset_s function sets a number of the bytes starting at address s to the byte value c. It may also lead to incorrect usage, for example, by setting smax or n to 0, and thus, while preventing a buffer overflow, would fail to clear the buffer as intended.While memset_s seems like the ideal solution, it's implementation has been slow. Also, specifying the whole list of optimization passes instead of a simple optimization level like O2 is cumbersome.Many compilers, including Microsoft Visual C, GCC and Clang, provide built-in versions of some C library functions, including memset. When this scrubbing function is called in a different compilation unit than the defining one, the compiler cannot remove any calls to the scrubbing function because the compiler does not know that it is equivalent to memset. In fact, the OpenBSD explicit_bzero function (Section 3.1.2) uses this technique also:__attribute__((weak)) void __explicit_bzero_hook(void *buf, size_t len) { } void explicit_bzero(void *buf, size_t len) { memset(buf, 0, len); __explicit_bzero_hook(buf, len); }The compiler can not eliminate the call to memset because an overriding definition of __explicit_bzero_hook may access buf. OPENSSL_cleanse of OpenSSL 1.0.2, shown below, is one implementation that uses this technique: typedef void *(*memset_t)(void *,int,size_t); static volatile memset_t memset_func = &memset; void OPENSSL_cleanse(void *ptr, size_t len) { memset_func(ptr, 0, len); } The C11 standard defines an object of volatile-qualified type as follows:An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. The reasoning goes that because the compiler does not know the value of memset_func at compile time, it can't recognize the call to memset and eliminate it.We have confirmed that this technique works on GCC, Clang and Microsoft Visual C, and we deem it to be effective. Because optimizations often take place at compiler's intermediate representation level, it is possible to hide the semantics of a memory scrubbing operation by implementing it in assembly language. Since the two calls to BF_crypt are in the same scope and the stack pointer points to the same position of the stack before the two calls, the sensitive data left on the stack by the first run should be cleared by the second run. Cryptography Coding Standard's Burn [9] is one of the implementations based on this idea: void burn( void *v, size_t n ) { volatile unsigned char *p = ( volatile unsigned char * )v; while( n--) *p++ = 0; } In the function above, the memory to be scrubbed is written via a pointer-to-volatile p in the while loop. We have found that this technique is effective on GCC, Clang, and Microsoft Visual C. Unfortunately, this behavior is not guaranteed by the C11 standard: "What constitutes an access to an object that has volatile-qualified type is implementation-defined." A more reliable way to define memory barrier is illustrated by Linux's memzero_explicit below:#define barrier_data(ptr) \ __asm__ __volatile__("": :"r"(ptr) :"memory")void memzero_explicit(void *s, size_t count) { memset(s, 0, count); barrier_data(s); }The difference is the "r"(ptr) argument, which makes the pointer to the scrubbed memory visible to the assembly code and prevents the scrubbing store from being eliminated. Unfortunately, this means that creating a scrubbing function requires relying on platform-specific functions rather than a standard C library or POSIX function.Of the remaining techniques, we found that the volatile data pointer, volatile function pointer, and compiler memory barrier techniques are effective in practice with the compilers we tested. The performance of the C library implementation represents the expected performance of non-inlined platform-provided solutions (Section 3.1) and the separate compilation (Section 3.3.1) and weak linkage (Section 3.3.2) techniques without link-time optimization. We also measured the performance of the volatile function pointer technique (Section 3.3.3), the volatile data pointer technique (Section 3.4.2), the custom assembly implementation of OpenSSL 1.1.0b (Section 3.3.4), and the complicated computation technique of OpenSSL prior to version 1.0.2 (Section 3.4.1). Program executions were tied to the same CPU core to ensure that consistent hardware was used across tests.The tests were done on an Intel Xeon E5-2430 v2 processor with x86_64 architecture and a 32KB L1d cache, 32KB L1i cache, and 256K L2 cache running Ubuntu 14.04 with Linux kernel 3.13.0-100-generic. The largest determining factor of an implementation's efficiency is the size of its move instructions: "plain memset" and "volatile function pointer" both jump to libc's memset, which performs a loop of movdqa instructions (2 4 bytes/instruction); "custom assembly" performs a loop of movq instructions (2 3 bytes/instruction); and "volatile data pointer" performs a loop of movb instructions (2 0 byte/instruction). "custom assembly" improves from 2 3 to 2 4 byte block sizes because above that threshold it qword-aligns its pointer in order to perform movq instructions.Furthermore, at some point (≥ 2 9 bytes for Clang; ≥ 2 14 bytes for GCC) the built-in memset defers to using libc's memset, hence it is identical to "volatile function pointer" given large block sizes. Additionally, for the "volatile data pointer" technique, unrolling occurs for sizes ≤ 2 6 bytes on Clang and sizes ≤ 2 2 bytes on GCC. All eleven projects used one or more of the techniques described in Section 3 to clear sensitive data, and seven of them relied on a combination of at least two techniques.If a project relied on more than one technique, it automatically chose and used the first technique available on the platform in order of preference specified by the developer. - - - - - - - - - 1 OpenVPN 8 8 2 6 0 - - - - - - - - - 1 Kerberos 10 2 9 0 1 1 - - - 2* - - - - 3 Libsodium 0 0 0 0 0 1 3 2 - - 5 - - 4 - Tarsnap 11 10 10 1 0 - - - - - 1 - - - - Libgcrypt 2 2 0 2 0 - - - - - 1 - - - - Crypto++ 1 1 0 1 0 - - - 1 - 2 - - - - Tor 4 0 4 0 0 1 2 3 4 - - 5 6 - - Bitcoin 0 0 0 0 0 - - - 1 - - 2 3 - - OpenSSH 0 0 0 0 0 - 1 2 - - - 3 - - - OpenSSL 0 0 0 0 0 - - - 1 - - 2 3 - -Removed ops. The Heap, Stack, and H/S columns indicate whether or not the cleared memory was allocated on the heap, on the stack stack, or potentially on either heap or stack.Of the eleven projects examined, four had an effective scrubbing function but did not use it consistently, resulting in a score of inconsistent, denoted in Table 1. Note that none of the issues resulted in CVEs because to exploit, they must be used in conjunction with a separate memory disclosure bug and these types of bugs are outside the scope of this work.In the remainder of this section, we report on the open source projects that we analyzed. We found 10 sites where scrubbing was done using memset, which is not effective; 2 of these sites deal with sensitive data. Function free_lucid_key_data in Fig- ure 3 is used in Kerberos to free any storage associated with a lucid key structure (which is typically on the heap) and to scrub all of its sensitive information. Tor defines memwipe, which reliably scrubs memory: it uses Windows' SecureZeroMemory if available, then RtlSecureZeroMemory if available, then BSD's explicit_bzero, then memset_s, and then OPENSSL_cleanse, which is described below. NSS does not have a reliable memory scrubbing implementation since it either calls memset or uses the macro PORT_Memset, which expands to memset. Function PORT_ZFree is used throughout the NSS code for freeing sensitive data and is based on function PORT_ZFree_stub in Figure 5. Out of the eleven reported issues, the 10 in keyfile.c were already patched on July 2, 2016 but were not in the latest stable version. Function invert_key in Figure 7 is used in Libgcrypt's IDEA implementation to invert a key for its key setting and block decryption routines. Crypto++ defines SecureWipeBuffer, which reliably scrubs memory by using custom assembly if the buffer contains values of type byte, word16, word32, or word64; otherwise it uses the volatile data pointer technique. The project defines memory_cleanse, which reliably scrubs memory by using OPENSSL_cleanse, described below. OpenSSH defines its own explicit_bzero, which is a reliable way of scrubbing memory: it uses BSD's explicit_bzero if available, then memset_s if available. We consider a store, either a store IR instruction, or a call to LLVM's memset intrinsic, to be a potential scrubbing operation if O The stored value is a constant, O The number of bytes stored is a constant, and O The store is subject to elimination because the variable is going be out of scope without being read.The first two conditions are based on our observation how scrubbing operations are performed in the real code. We released it into the public domain so that developers can use it freely and collaborate to adapt it to future changes to the C standard, platforms or compilers.Third, even if a well-implemented secure scrubbing function is available, developers may forget to use it, instead using the standard memset which is removed by the compiler. This observation makes compiler-based solutions, for example the secure DSE, more attractive because they do not depend on developers correctly calling the right scrubbing function.Finally, it's important to note that sensitive data may still remain in on the stack even after its primary storage location when it is passed as argument or spilled (in registers) onto the stack. Thus the scrubbing finder only reports dead stores of (2) and (3) where a constant is stored.Thus, when dead store belonging to one of the two categories described above is removed, Scrubbing Finder reports: (1) the Location of the removed scrub, including file and line number; (2) the Removed IR Instruction; and (3) Additional Info describing any instances where the removed scrub was inlined.