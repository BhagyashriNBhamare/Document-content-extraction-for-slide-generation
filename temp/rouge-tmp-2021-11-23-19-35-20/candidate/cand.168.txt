Encouraged by the rapid adoption of Single Sign-On (SSO) technology in web services, mainstream identity providers, such as Facebook and Google, have developed Software Development Kits (SDKs) to facilitate the implementation of SSO for 3rd-party application developers. As a conservative estimate in [49], 405 out of Top-1000 applications support SSO services, indicating that SSO login has already become a mainstream authentication method and still continues its strong adoption.Motivated by the prevalence of SSO services, mainstream Identity Providers (IdPs) like Google and Facebook, have provided their Software Development Kits (SDKs) to facilitate the implementation of third party services (e.g. IMBD and Uber), which are referred to as the Relying Parties (RP) under the SSO framework.To further enhance flexibility, some high-profile open source projects [3,21] have integrated SSO SDK modules from different IdPs so that an RP application can readily support multiple IdPs at the same time. The first type reasons about the specification of the standard SSO protocols [23,39] by different methods including model checking [5,7,15,19], cryptographic proof [11] and manual analyses [34]. We have thus developed new techniques including request order scheduling and multi-party coordination for this kind of multi-party applications.We have implemented a full-featured prototype of S3KVetter and applied it to check 10 popular SSO SDKs. We have designed and implemented S3KVetter to perform security analysis of SDK internals based on dynamic symbolic execution and a theorem prover. In an SSO ecosystem, there are three parties: a User, a Relying Party server (RP server) and an Identity Provider server (IdP server) 3 . While S3KVetter supports both protocols and both authorization flow types for the web and mobile platforms, we use the authorization code flow of OAuth2.0 under the web platform as the running example throughout this paper.2.1 Authorization Code Flow of OAuth2.0 the information of the user hosted by the IdP ; V. (Step 10-11) The user can then access his information hosted by the RP. While we will use Fig. 1 as an illustrative example throughout this paper, our work actually goes beyond Fig. 1. It is worth to note that S3KVetter can also be extended to study the security of other multi-party applications like payment services as discussed in Section 6.5. Here, the nonleaf nodes in the tree represent symbolic constraints enforced by the corresponding path, and the leaf nodes represent the final computation results (e.g., an access token or the identity of a logged-in user in the context of SSO). By contrast, S3KVetter, leveraging high-coverage symbolic execution, automatically explores different corner-case situations.Intuitively, the symbolic predicate tree has captured rich semantic information: The leftmost path in Fig. 4 corresponds to the case where the user skips Req0 (i.e.,Step 1 in Fig. 1) and directly sends Req1 (Step 5) to the SDK. Although existing symbolic execution studies [10,31,40] have proposed different techniques to support asynchronous event/ request orders, they require expert-level domain knowledge of the application under test to provide all the possible external events (e.g., atomic rule updates and flow independence reduction for OpenFlow application [10]). more thoroughly, S3KVetter should allow attackers to randomly, symbolically select execution orders such as making out-of-order requests, skipping/ replaying requests.We develop a general and simple scheduling algorithm, which does not require any application-specific heuristic from the analyst, to systematically explore execution paths by generating inputs and schedules (i.e., request orders) one by one. For example, a subset {Req0, Req1, Req2} can mean two possible execution orders: {Req0, Req1, Req2} and {Req1, Req0, Req2}. The intuition behind this scheme is that S3KVetter Req2 Req2 Req2 Req0 Req1 Input Schedule 1 Schedule 2 Schedule 3 Schedule 4 Time Sequence to bypass logic checks to break multi-step operation Figure 5: Scheduling for out-of-order requests attempts to skip any important logic check, break the multi-step operations or replay requests (as can be seen in Figure 5). Note that S3KVetter will not generate a complete set of request orderings since an attacker, in theory, can generate infinite number of request orderings, e.g., by repeating each request arbitrary number of times. However, since the IdP server typically imposes limit on API access rate, a large number of invocations of the external functions can easily hit the control threshold and lead to unexpected responses. As such, the first approach will get stuck in non-core error-processing paths.The second solution is to check the return type of the external function and then returns a random value of this type without executing the external functions (e.g., DART [22]). Once a nonce parameter is consumed, S3KVetter, unlike the real-world IdP server, will first generate a new nonce value internally. Therefore, S3KVetter can internally force its simulated remote IdP Code Example: Fig. 6 illustrates how S3KVetter can coordinate multiple parties with the code example. When exploring Path2 (where we skip Req0), S3KVetter finds that code satisfies the path constraint (code = None) and therefore provides the code for the SDK. An SSO system involves interactions among the user, the RP server and the IdP server, where any weak communication links (i.e., 11 steps in Fig. 1) can lead to logic flaws. It is therefore more intuitive to define the final security goal (i.e., authentication property) for the RP server, which is the focus of this paper.In particular, we have one key observation to secure the Single Sign-On service: An RP server should login a user if and only if the exact user has actually authorized this specific RP. A more elaborated example is Clause 6, which can be violated in two different cases: (1) it is possible that an attacker eavesdrops the victim's code and uses it to sign into the RP (i.e., RPsession.uid = victim and IdPsession.uid = attacker) ; (2) it can also be the result of a CSRF attack, in which the attacker makes the victim's browser to send the RP a crafted request with the attacker's code (i.e., RPsession.uid = attacker and IdPsession.uid = victim). By that, we mean that, when a conventional symbolic execution engine is unable to obtain correct/ meaningful results (e.g., code) from external parties (and thus gets stuck in error-processing paths), S3KVetter can either "generate" valid results, or schedule to other paths, to continue exploring meaningful paths beyond the error-processing paths. There is only one requirement for the exploitation of these vulnerabilities 8 : the attacker needs to setup a malicious RP (mRP) and lure a victim user to login to the mRP. Secondly, S3KVetter may not be able to explore all execution paths due to the following limitations: • The underlying SMT solver assumes a query does not have a feasible solution when it takes too long to solve. 9 While we assume an attacker can control all packets sent to the RP server, only part of these packets would be processed by the SDK.To apply S3KVetter on other multi-party systems, one additional manual step is to develop the required security properties (i.e., the counterpart of Listing 1) for the specific domain of applications. For example, the list of the required security properties for payment services can be developed by codifying the following statement: A merchant M should accept an order if and only if the user has paid to the cashier in the correct amount for that specific order associated with merchant M.Note that the developed scurity property is not necessarily an exhaustive list of all protocol states. While other researchers have managed to automatically extract the required security properties from the source code [5] or protocol specification [16], their results are complementary to ours and can be adopted to further extend the capabilities of S3KVetter. • While our earlier work on model-based security testing for OAuth2.0 (OAuthTester) [49] has the potential, at least in theory, to discover all the vulnerabilities listed in Table 2, our testing shows that OAuthTester can only detect two out of the seven types of vulnerabilities (TLS and state misuse) listed. Such belief is based on the fact that, under the authorization-code flow, the access token is exchanged over a secure TLS connection routed directly between the IdP and RP, without passing through the mobile (client) device which may be controlled/ tampered by the attacker. Therefore, these SDK developers attempt to pre-process the user input and stores it only after it has passed the security checkings.Despite these seemingly strict security checks, we will show that the so-called refresh token injection vulnerability is still possible. Below, we present one exploit which requires the least capability of the attacker (Eve): As long as Eve can obtain Alice's refresh token associated with a malicious RP (run by Eve), Eve can login as Alice to any RP which uses the vulnerable SDK (as shown in Fig. 8):1-4. In the worst case where the user data is for authentication, the attacker can log into the vulnerable RP as the victim user.Note that the above exploit only works for those IdPs (e.g., Fitbit) which do not require client secret in Step 6 of Fig. 8. This function generates an authorization URL (Line 5) which includes a random state parameter to prevent CSRF attacks: Upon receiving Req1, the "callback" function will be invoked to parse and verify auth response. This vulnerability can have high security implication, ranging from sniffing the victim's activity at the vulnerable RP via a "login CSRF" attack [8], to controlling the victim's RP account by account hijacking attack [26]. To protect the access token against leakage, more and more IdPs (e.g., Facebook, Sina, etc.) start to support the MAC token.The MAC token protocol is supposed to be more secure by signing the original bearer token. developer should design a separate function to store the corresponding variable/ parameter so that the SDK can easily decide whether a variable/ parameter can be accessed and/or altered by the user or not. As a result, even if the SDK developers attempt to filter out the userprovided variables, an intelligent attacker can still manipulate sensitive variables (e.g., access token, refresh token) that she should not be allowed to.Less is more. The reason is that, since the SSO specifications only serve as a high-level guideline, IdPs typically have various application-specific logic flows, unique APIs and security checks. Firstly, the protocol specification [23,39] has been verified by different formal methods including model checking [5,7,15,19,20,36], manual analyses [28,32] and cryptographic proof [11]. For example, al-though [19] discovers the so-called 307 Redirect attack that allows an attacker to learn the victim's password in IdP, real-world SSO systems actually use 302 redirection instead.Despite these theoretical works, the practical implementations of the protocols were often found to be incorrect due to the implicit assumptions enforced by the IdP SDKs [46] or the incorrect interpretation of ambiguous specification [13]. In addition to existing vulnerabilities, S3KVetter successfully discovers 4 new types of vulnerabilities, all of which can result in serious consequences including application account hijacking or user privacy leakage. sGiven the marked sample app, S3KVetter must identify which (ranges of) symbolic input fields (e.g., the entire request.url or just the code in Listing 6) determine a path and then extracts all the path constraints related to these fields.