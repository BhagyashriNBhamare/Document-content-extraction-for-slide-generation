In response, the security community continues to develop intrusion prevention techniques meant to stop malware from propagating to new machines and intrusion detection systems (IDS's) meant to detect malicious processes running on computer hosts [15,26,27,30,41]. Compared to these efforts, we seek to develop a lightweight, quick malware recovery technique which transparently preserves the state of trusted services running on an infected host without the overhead of log-based schemes.We present a malware recovery system which extends the Checkpoint/Restore In Userspace project (CRIU) [40] to quickly restore an infected Linux container (LXC) to a safe state while removing malware and preserving running services in the process. While not a VM-based technique, MalTRAK [39] uses the concept of "views" or system snapshots in a similar manner to undo the effects of a malware program.ExecRecorder [18] is a VM-based recovery method which also integrates logging to restore a system to a trusted snapshot before replaying log events for nonmalware processes to restore the system state. LXC is an open-source Linux project which aims to allow for the virtualization of a Linux system or process within privilege-constrained containers [6]. These con-tainers are meant to be lightweight alternatives to virtual machines, allowing for Linux virtualization without emulating system hardware and running a separate kernel. CRIU has been incorporated into the LXC project, allowing for an entire container and the processes running within it to be checkpointed or restored. Protobuf was selected based on its high performance serializing and deserializing data relative to other formats, such as XML or JSON [31], and also because it was already used extensively for the image files generated by CRIU checkpoints. The policy can be composed of a variety of user-defined or dynamically generated rules that are used to omit processes from being restored, including:• Executable Name Match: Whether the executable filename of a process matches a given string• File Match: Whether any opened file of a process matches a given string• TCP IP Match: Whether the IP address for any established TCP connection of a process matches a given IP address• Memory Match: Whether the process contains the specified ASCII or Hex encoded string• PID Match: Whether the PID of a process matches the given PID• Parent PID Match: Whether the parent PID of a process matches the given PPID• Parent Executable Name Match: Whether the parent executable filename matches the given stringIn choosing these rule types, we seek to provide a flexible policy language which can identify malware to omit during the restore process based upon alerts provided by various intrusion detection triggers, such as potentially malicious TCP connections, executables which match a virus signature, and flagged PIDs. Note that this architecture requires no integration on the part of third-party IDS/IPS vendors; all that is required to integrate an alert system with the recovery agent is a small parsing script for turning the system's alerts into JSON and forwarding these alerts to the CRIU-MR agent. The recovery agent also handles the filesystem restore, preparation, and cleanup operations needed to perform quick malware recovery, which will be covered in more detail below. At some point it begins executing and may modify the filesystem.Detection: As a result of the malware on the system, one or more "triggers" may send an alert to the recovery agent. This JSON file is used to build the policy used by CRIU for malicious process removal. The example code used to generate the JSON alerts and send them to the recovery agent are shown in Appendix A.Preparation: The recovery agent for CRIU-MR listens on a TCP port for a JSON message. Using these backups, the filesystem for the container is restored with a few simple shell commands: One benefit of this method is that the infected filesystem can be later inspected (with the assistance of the CRIU-MR log files) to collect malware samples and detect malicious filesystem changes.CRIU Restore: At this point, the CRIU restore of the checkpointed non-malware processes begins. The swap backup for the container is also restored from the "master" backup to allow for a quick filesystem restore in the event of another breach using the following command: The preparation, CRIU checkpoint, filesystem restore, CRIU restore, and cleanup steps are all automated via the CRIU-MR recovery agent program. To simulate a long-running malicious payload, we remotely execute commands which create a file each second on the filesystem, but any arbitrary C code can be executed.Each experiment consists of the following: first, an ssh session is started, and the malware is started as root in the background and using the unix command nohup to avoid termination when the ssh session ends. In fact, the removal of malware appears to match the time taken for a checkpoint and restore 4 For goahead_ldpreload we observe that the remote code execution occurs in a separate process /root/goahead/test/cgi-bin/cgitest handling CGI scripts, which is the executable name used in the policy for that exploit. We therefore conclude that our modifications for CRIU-MR do not impact CRIU's underlying TCP restore abilities.Beyond faster system restore, one benefit of the CRIU-MR method over methods which log every filesystem modification, such as Taser [20], is that there is no overhead for writing to logs during normal execution of the container. This is likely due to the fact that Linux containers rely mostly on partitioning resources using Linux namespaces and control groups instead of more complex solutions, such as hardware virtualization used by conventional VMs.Another concern is the security of the container in terms of isolation. For example, if botnet malware is detected via an IDS based on a TCP connection to a command and control server, the connection may end before the alert is processed and CRIU-MR begins the checkpoint process, meaning the malware will fail to be flagged for omission during restore. In such a case, if the malware runs from an executable placed on the system via a malicious channel, CRIU-MR will still successfully remove it from the container during the restore process since the botnet executable isn't located on the safe filesystem backup. However, Linux is a popular operating system for web servers, with approximately 66.8% of web servers from the Alexa top ten million sites using some flavor of it, according to a survey conducted by W3Tech in February 2018 [12]. It might also be possible to extend the main ideas of this method using container technology for other operating systems, such as Docker, by using or creating the appropriate checkpoint/restore methods.Finally, it is important to take appropriate actions even after malware removal. Research into this area may reveal more robust ways of ensuring that malware effects have been reverted even if it interfered with other processes.Because any maliciously uploaded files are archived in a separate filesystem, CRIU-MR could also be used as part of a framework which discovers and analyzes new malware. Listing 1 shows an example of using Logstash with the grok filter to parse Snort alerts and send them to the CRIU-MR agent. Finally the grok parsing code in the filter step simply becomes:%{GREEDYDATA: f i l e p a t h } :%{GREEDYDATA: malwarename } FOUND B NFQUEUE BufferListing 2 shows an example implementation of a buffer for packets intended for the interface lxcbr0, which is the default interface used for the Linux container networking. The Snort command used to generate the alerts is snort -c snort.conf -i lxcbr0 -A full -k none, where -A full denotes full alert syntax. The -k none parameter indicates no checksums should be calculated, which we anecdotally observe is required for obtaining alerts on both inbound and outbound traffic. Finally the grok parsing code in the filter step simply becomes:%{GREEDYDATA: f i l e p a t h } :%{GREEDYDATA: malwarename } FOUND Listing 2 shows an example implementation of a buffer for packets intended for the interface lxcbr0, which is the default interface used for the Linux container networking.