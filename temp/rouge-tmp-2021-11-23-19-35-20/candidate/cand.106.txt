To reduce the size of the trusted computing base (TCB) on commodity systems, software solutions (such as InkTag [40] and Virtual Ghost [26]) and hardware solutions (such as Intel SGX [42], ARM TrustZone [11], and Haven [12]) prevent the OS kernel from reading and corrupting application data.Despite these protections, attackers can steal application data using side-channel attacks that exploit shared hardware resources [38] or interactions between application code and the OS kernel [73]. Worse yet, a compromised OS kernel can exacerbate these side channels by manipulating software state, e.g., via CPU scheduling, and by configuring privileged hardware resources, e.g., the processor's interrupt timer and memory management unit (MMU) [38,73]. To thwart LLC side-channel attacks, we leverage Intel's Cache Allocation Technology (CAT) [4] in concert with techniques that prevent physical memory sharing.Since our solution must prevent physical memory sharing, control configuration of the Intel CAT feature, and prevent reading and writing of page table pages, we implement our solution by enhancing Virtual Ghost. Apparition is optimized relative to the original Virtual Ghost by using Intel Memory Protection Extensions (MPX) [4] to reduce software fault isolation (SFI) overheads and by eliminating serializing instructions (which reduce instruction-level parallelism) added by the original Virtual Ghost to control page table access.To summarize, our contributions are as follows:• We show that using MPX for SFI and eliminating serializing instructions when accessing page table pages improves performance by up to 2× relative to the original Virtual Ghost. Our defense combines Intel's CAT feature [4] (which cannot securely partition the cache by itself) with existing memory protections from Virtual Ghost [26] to prevent applications from sharing cache lines with other applications or the OS kernel. We assume that the application and the libraries that it uses are part of the TCB for that application's security policy; that the application author has taken measures to ensure that the application and its libraries are safe from direct attack, e.g., by using security hardening tools [33,56] or type-safe programming languages, and that the application and its libraries protect themselves from Iago attacks [17] by distrusting return values from the OS. Systems that protect applications from the OS kernel like Virtual Ghost [26], Overshadow [20], InkTag [40], and Haven [12] do not mitigate these side channels; the architectural states are still shared among processes, and the OS kernel has access to or even controls the page table on these systems. More specifically, the OS kernel can use the methods below to infer information about an application's memory access patterns via the virtual-to-physical address translation mechanism:Swapping If the OS kernel cannot directly modify the PTEs for pages containing private application data, it can indirectly mark the pages inaccessible if the shielding system provides the OS with a mechanism to swap pages out and back in. Systems such as InkTag [40] and Virtual Ghost [26] provide mechanisms for swapping that prevent direct data theft via encryption but do not mitigate swapping side channels.Reading PTEs If the OS kernel cannot modify PTEs and cannot swap out pages, it can still infer an application's memory access patterns by reading PTEs as the application executes. On multi-processor and multicore systems, the compromised OS can scan the page tables (which reside in memory) on one core while the application executes on another core.Inferring Caching of Translations A compromised OS can potentially infer a victim's memory access patterns using PRIME+PROBE [8-10, 38, 58, 66, 78] and FLUSH+RELOAD [13,76,79] cache side-channel attacks on caches holding virtual-to-physical address translations. If the shielding system neglects to hide an application's saved program counter when an interrupt, trap, or system call occurs, the OS could configure the processor timer to mimic single-step execution [38] and read the program counter as each instruction is executed. Virtual Ghost can add run-time checks while translating code from the V-ISA to the N-ISA; the SVA-OS instructions can help enforce security policies by restricting hardware configuration and state manipulation.Via compiler instrumentation and run-time checks, Virtual Ghost can provide applications with the functionality they need to protect themselves from a compromised OS kernel [26]. Pages containing native code are mapped as execute-only while all other Virtual Ghost VM memory regions are inaccessible to applications and the kernel.With these features, programmers can write ghosting applications for Virtual Ghost systems that actively protect themselves from the OS kernel: applications can store all their data and encryption keys inside ghost memory to prevent theft and tampering, and they can use encryption and digital signatures to maintain data confidentiality and integrity when sending data into or receiving data from the operating system's I/O systems [26]. Since Virtual Ghost must control how the processor's MMU is configured [26], it originally mapped page table pages in the OS kernel's direct map for read-only access, and when an SVA-OS instruction needed to update the page tables, it temporarily cleared the x86 CR0.WP bit to disable the MMU's enforcement of write protection, thereby allowing the Virtual Ghost VM to modify the page table.We have found that this method incurs significant overhead as flipping CR0.WP is a serializing operation that interferes with instruction-level parallelism [4]. This caused Virtual Ghost's page table updates to be much slower than those of a conventional OS kernel, decreasing the speed of process creation and termination, demand paging, and the execution of new programs.Apparition eliminates the need for modifying CR0.WP by placing a direct map of physical memory within the Virtual Ghost VM memory that provides write access to all physical frames, including page table pages. This prevents the OS from observing updates to PTEs caused by ghost memory allocation, deallocation, and swapping and from inferring information when the processor sets the accessed or dirty bits in PTEs for ghost memory.To enforce these restrictions, we exploit the hierarchical, tree-like structure of x86 page tables. To the best of our knowledge, no existing work exploits such memory allocation side Name Description void allocmem(int num, uintptr t frames[]) Allocate num physical memory frames and store the addresses to them in the specified array. In our design, the Apparition VM will request a random number of frames from the OS when it needs more physical memory; these frames will be stored within an internal cache of free frames that it can use to fulfill ghost memory requests.When the internal cache of free frames becomes sufficiently large, the Apparition VM will return frames to the OS so that they can be used for other purposes. When the OS loads an application in memory for execution, it loads the V-ISA code into either user-space or kernel-space memory and then asks Apparition to verify the integrity of the code and to create the native code for the application in Virtual Ghost VM memory. This not only prevents data theft by applications and compromised OS kernels, but, as we discuss next, allows our Apparition design to utilize Intel CAT [4] to defend against LLC side-channel attacks.Cache Partitioning Our defense against LLC sidechannel attacks combines Virtual Ghost's existing memory protection mechanisms [26] with static cache partitioning implemented using Intel's CAT processor feature [4]. However, software in one COS can read data from all cache lines in the LLC, allowing software running in different COSs to read the same cache lines if they are sharing physical memory e.g., read-only mapped shared library code.Our design requires one partition for kernel code and non-ghosting applications not using ghost memory, one for Apparition VM code, and one for each ghosting application. However, since Apparition ensures that there is no sharing of ghost memory or native code between a ghosting application and the OS kernel (or other applications), and since the MPX SFI protections prevent the OS kernel from accessing ghost memory and Apparition VM memory, such cross-COS reads will never occur. Hence, the memory protections in Virtual Ghost coupled with Intel CAT can defend against LLC side-channel attacks.Cache Partitioning Configuration The Apparition VM configures the cache partitions on boot and uses several mechanisms which, together, ensure that the OS kernel cannot reconfigure or disable the cache partitioning. Third, Virtual Ghost enforces CFI on kernel code, ensuring that the OS kernel can only execute its own code and cannot jump into the middle of variable-length x86 instructions within the kernel [26] that might reconfigure cache partitioning.On an interrupt, trap, or system call, the processor transfers control to the Apparition VM which switches the cache partition in use to the Apparition VM's partition. Similarly, the Apparition VM will need to flush the cache on context switches if the number of distrusting ghosting applications exceeds the number of COSs provided by the processor.If a process wants to create a cooperating thread with which to share its ghost memory or a child process which it trusts to use the same cache partition, the process can provide an option to the fork() system call indicating that the new process or thread should use the same cache partition as the parent process. To mitigate Meltdown [49] and Spectre [46] attacks that speculatively access outof-bounds memory, Apparition could use speculationresistant SFI instrumentation on both application and kernel code [34] to protect large memory regions; in particular, we show in [34] that SFI instrumentation using instruction sequences to stall speculative execution using a data dependence so that the SFI instructions must complete before the protected memory read instruction begins execution. The original Virtual Ghost prototype contained 5,344 source lines of code [26] in comparison.We implemented the MPX SFI optimization in Apparition by changing the existing LLVM IR-level SFI pass in Virtual Ghost [26] to insert inline assembly code utilizing MPX instructions instead of LLVM IR bitmasking instructions. While Virtual Ghost is designed to restrict Direct Memory Access (DMA) operations to memory with an I/O MMU [26], neither the original Virtual Ghost prototype nor our prototype implements this feature.To implement our paging protections in Sections 5.1 and 5.2, we modified the ghost memory allocator within the Apparition VM so that it requests all physical memory frames from the OS when the application uses the hypercall to request ghost memory. For our experiments, we used a Dell Precision T3620 workstation with an Intel R Core TM i7-6700 hyperthreading quad-core processor at 3.40 GHz with an 8 MB 16-way LLC, 16 GB of RAM, and an Intel E1000 network card. We use a high-resolution timer (reading rdtsc directly) to measure time, and we report the average (arithmetic mean of) execution time of multiple runs.Our evaluation needed benchmarks and applications that rely heavily on OS kernel services e.g., the file system and network stack. We transferred the files by having the ssh client run the cat command on the files on the server.Ghosting Bzip2: We compiled Bzip2 1.0.6, a data compression program [16], with a new C library that can, at run-time, be configured to allocate heap objects in either traditional user-space memory or in ghost memory. We measure the time for Bzip2 to compress the 32 MB file we used in the OpenSSH experiments.Ghosting GnuPG: We compiled GnuPG 2.0.18, a cryptography program [45], with our C library that can, at run-time, be configured to allocate heap objects in either traditional user-space memory or in ghost memory. The standard deviation is 0% for all file sizes tested.Applications: Table 5 lists the average CPU time spent for OpenSSH client file transfers on the native FreeBSD kernel over 20 rounds of execution. The third column of Ghosting OpenSSH Client: The Opt-VG-PGGhosting line in Figure 6 shows the overhead of our page table defenses on the unhalted CPU clock cycles (converted into time using the processor's clock frequency) of the ssh client transferring files. While we use static partitions, we could leverage dynamic cache partitioning techniques e.g., SecDCP [70], to improve performance.Ghosting RandomAccess: We use the RandomAccess microbenchmark in Section 8.1 to evaluate the impact of LLC partitioning when an application's working set is small enough to fit in the LLC but exceeds the capacity of the assigned partition. SP 3 [75], Overshadow [20], InkTag [40], CHAOS [18], and AppShield [21] build on commercial hypervisors and protect entire applications by providing an encrypted view of application memory to the OS and detect corruption of physical memory frames by the OS using digital signatures. It detects privileged side-channel attacks that trigger frequent traps and interrupts and aborts the application if an attack is detected.Cache side-channel attacks are a known problem [36- 38,43,52,58,76,79]. Still, we can leverage techniques such as dynamic partitioning in SecDCP [70] to improve the performance of our cache partitioning scheme but, unlike SecDCP, ensure that the OS does not reconfigure or disable the partitioning.Other mechanisms can mitigate cache side-channel attacks, but they also assume unprivileged attackers.