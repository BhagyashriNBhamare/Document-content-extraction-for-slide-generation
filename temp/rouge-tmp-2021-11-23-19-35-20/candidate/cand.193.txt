Our work examines the generation of this field in Windows (versions 8 and higher), Linux and Android, and shows that the IP ID field enables remote servers to assign a unique ID to each device and thus be able to identify subsequent transmissions sent from that device. [2] specifically lists motivations for web-based fingerprinting as "fraud detection, protection against account hijacking, anti-bot and anti-scraping services, enterprise security management, protection against DDOS attacks, real-time targeted marketing, campaign measurement, reaching customers across devices, and limiting number of access to services". The Linux/Android attack requires WebRTC which cannot be turned off for mobile Chrome and Firefox.VPN resistant: The device ID remains the same when the device uses an IP-layer VPN.Windows shutdown+startup vs. restart: The Fast Startup feature of Windows 8 and later, 2 which is enabled by default, saves the kernel to disk on shutdown, and reloads it from disk on system startup. Device tracking via IP ID: Using IP ID is proposed in [5] (2002) to detect multiple devices behind a NAT, assuming an IP ID implementation using a global counter. However, this technique does not scale beyond a few dozen devices, due to IP ID collisions (the IP ID field provides at most 2 16 values), and requires ongoing access to the traffic arriving at the DNS resolver. The analysis of this algorithm is based on two assumptions: (1) that the technique is applied shortly after restart, when the relevant memory buffer contains zeroes in a large part of its cells; and (2) that the attacker controls or monitors traffic to pairs of IP addresses which differ in single, specific bit position (including positions in the left half of the address). Properties of the Toeplitz hash Our attack uses the following properties of T , which follow from the linearity of this transformation:T (K, I||(0, 0, . . . , 0)) = T (K, I)(2)Therefore the trailing zeros in the input of T in the computation of v on line 3 of Algorithm 1, have no effect on the output. If these packets are sent in rapid succession (i.e. when no other packet is sent in-between with i = i g ), then β [i g ] g, j = β g + j mod 2 32 , and therefore the output in line 5 of the 2 32 4:i ← Num(K2 ⊕ T (K, (IP DST ) 0,..., |IP DST | 2 −1 ) ⊕ T (K, IP SRC )) mod M 3: v ← β [i] + Num(K1 ⊕ T (K, IP DST ||IP SRC ||0 32 )) modβ [i] ← (β [i] + 1) mod 2 32 5:return v mod 2 15 v mod 2 16 for Windows 10 RedStone 5 algorithm is calculated with β [i g ] g, j = β g + j mod 2 15 (for simplicity, in Windows 10 RedStone 5, we discard the most significant bit of the IP ID). • The value(K1 ⊕ T (K, 0 32 ||IP SRC )) 18,...,31 = T (K, IP 0 ) 18,...,31 ⊕ Vec(IPID 0 − β 0 mod 2 14 ) 18,...,31This value allows the tracker to calculate (assuming K 18 , . . . K 62 are known) the value of the counter β [i] mod 2 14 for any destination IP address whose IP ID is known (provided the source IP is IP SRC ). These issues include ways to emit the needed traffic from the browser, handling packet loss and out-of-order packet transmission, handling interfering packets, and limiting the false-positive and false-negative error probabilities.The run time of the key extraction attack is less than a second even on a very modest machine. A typical user needs to restart his/her Windows machine only for some Windows updates, i.e. with a frequency of less than once per month.The attack is scalable: with 41 bits, the probability of a device to have a unique ID is very high, even for a billion device population; false positives are also rare (2.1 × 10 −6 - Table 3), and false negatives can be made negligible (Appendix A.1.4). We list here some obvious ways of modifying Algorithm 1 and their impact:• Increasing M (the size of the table of counters) -surprisingly, this has very little effect on the basic tracking technique, since no assumptions were made on M in the first place. These six networks did not include any major ISP and seem to be used by relatively few users: they included an airport WiFi network, a government office, and a Windows machine connecting through one cellular hotspot (hotspots that we tested in other cellular networks did not change the IP ID). The tracking snippet forces the browser to rapidly emit UDP packets to each such IP (using WebRTC and specifically the STUN protocol, which enables sending bursts of packets closely spaced in time to controlled destination addresses). The modification is for step 2, which now reads:i ← h(IP DST , IP SRC , protocol ⊕ g(net), key) mod M where g(x)is a right-shift (by ρ bits) and a truncation function that returns 32 bits from x. We can safely ignore them because the tracker can detect a burst with a lot of missing packets, reject the sample and run the sampling logic again, or use a more sophisticated logic incorporating information from more than two bursts. The tracker should be able to monitor the traffic to these IP addresses with time synchronization resolution of about 10 milliseconds (or less) -e.g. by having all the IPs bound to a single host.With L different destination IP addresses and M buckets (M = 2048 in Algorithm 2), there are ( L 2 ) /M expected collisions, assuming no packet loss. In the second phase the tracking server runs an exhaustive search on the key space W where the key is 32 bits long for algorithms A 1 and A 2 , 41 bits long for algorithm A 3 (Linux) and 48 bits for A 3 (Android). At this point, the tracker (e.g. law enforcement body) extracts the key, possibly using a very expensive array of processors, and not necessarily in real time.Once the tracker has the target's key, it is easy to test any invocation of the tracking snippet against this particular key and determine whether the connecting device is the targeted device. The probability of |W | − 1 false keys to generate at least one false positive key is therefore:Prob(FP) ≈ 1 − ν−1 ∑ i=0 A i ( 1 M ) i (1 − 1 M ) A−i |W |−1Assuming |W | = 2 48 (worst case -Android), we enumerated over all ν values for each L in {200, 250, . . . , 500} to find the optimal ν (per L). False positives and false negatives Using a computer simulation with L = 400 destination IP addresses, a burst length of δ L = 0.6 seconds, and packet loss rate of 0.01, we calculated an approximation of for the false negative rate of 4.2 × 10 −8 for ν = 11, and an approximation for the false positive rate of 6.2 × 10 −10 . The expected number of collisions is ( L 2 ) /M, and therefore increasing M by a factor of c requires the attacker to increase L by only a factor of √ c. On the other hand, δ L also grows (probably linearly in L), and when f δ L ≥ 2 16 no information is practically revealed to the tracker. It is probably safe to assume that the tracker can handle an increase of L by a factor of ×10, which means that in order to stop the attacker the IP ID generation algorithm must increase M by more than ×100, making it too memory expensive to be practical. The tracking snippet used WebRTC to force UDP traffic to a list of L = 400 hosts, and this traffic passed through our laptop (as a gateway) and was recorded.We then ran the collision collection logic (Phase 1), and fed its output (IP pairs whose IP IDs collide) to the exhaustive key search logic (Phase 2). Table 3 demonstrates that with an optimal choice of 30 IP addresses, if the tracker keeps only 41 bits of the key tail, he/she will get multiple keys with probability 2.1 × 10 −6 , which is sufficiently small even for a large scale deployment.In the case where multiple keys are emitted by the algorithm (even after truncation, e.g. to 41 bits), two strategies can be applied: either (a) determining that this particular device cannot be assigned an ID (at the price of losing 2.1 × 10 −6 of the devices); or (b) assigning multiple IDs to the device (which makes tracking the device more complicated and more prone to ID collisions). Let us first define the Toeplitz hash, T (K, I), which is a bilinear transformation from a binary vector K in GF(2) 320 , and an input which is a binary string I (where |I| ≤ 289) to the output space GF(2) 32 . • RANDOM(x), x > 0 -a PRNG (a 96/128 bit Tausworthe Generator) which receives x as a parameter and provides a random integer in the range [0, x). The dwell time in this case drops to near-zero.6.7 The Effective Key Space in Attacking Algorithm A 3In Algorithm A 3 , 32 bits of the net namespace are extracted by a function we denote as g(), and are added to the calculation of the hash value. [6] describes a technique to predict the IP ID of a target, but requires the adversary to have a fully controlled device alongside it behind the same NAT. In the calculation, the leading term (in terms of run time) is computing T (K, I) 17,...,31 (where |I| = 32), which takes 14|I| bit operations, and is used twice. The browser then sends STUN "Binding Request" (UDP short datagram) to the destination host and port.To send STUN requests to multiple servers (in Javascript), create an array A of strings in the form stun:host:port, then invoke the constructor RTCPeerConnection({iceServers: A}, ...) in a regular WebRTC flow e.g. [13] (applying the fix from [8]). Increasing M Changing the algorithm to use a larger number M of counters, will reduce the likelihood of pairs of IP addresses using the same counter. Our work demonstrates that using non-cryptographic random number generation of attacker-observable values (even if the values themselves are not security sensitive), may be a security vulnerability in itself, due to an attacker's ability to extract the key/seed used by the algorithm, and use it as a fingerprint of the system. Moreover, after we reconstruct K, we can reconstruct the current counter values (in full or in part) by sending traffic to specially chosen IP addresses, obtaining their IP ID values and with the knowledge of K, work back the counter values that were used to generate them. Even for R = 128 · 10 6 , collisions affect only 0.00006 of the population.Dwell time In order to record B 5 , the snippet page needs to be loaded in the browser for 8-9 seconds. On restart, in contrast, the kernel is initialized from scratch, and a new value for K is generated, i.e. the old device ID is no longer in effect.Scalability: Our technique can support billions of devices (Windows, Linux, newer Androids), as the device ID is random, and thus ID collisions are only expected due to the birthday paradox. We then used WebSocket traffic to the additional pair of IP addresses (from a class B network that is different than those in the initial set of 15 IPs) to verify the correctness of the key bits extracted. Device ID collisions The expected number of pairs of devices with colliding IDs, due to the birthday paradox, and given R devices and a key space of size |W |, is ( R 2 ) /|W|. In order to track a Linux/Android device, the tracker needs to control several hundred IP addresses. These older Windows versions are out of scope for this paper.The source code of the algorithm that is used for generating IP ID values in Windows is not public. TCP: WebSocket [22] emits TCP traffic in a controlled fashion once a circuit is established, thus can be used by the snippet to fully control packet transmission. The standard deviation of the attack time for a given f is r · |W | · σ (P f ), which is σ (P f ) /E(P f ) in Table 1 times the average attack run time in Table 2. We need to set the number J of IP addresses from the same class B network to which the client is directed in the first set of measurements, and the number G of pairs of IP addresses, each pair in the same class B network, used in the second set of measurements.Our goal is to optimize for minimum false positives. Tracking machines based on the key that is used for generating the IP ID has multiple advantages:Browser Privacy Mode: Since our technique exploits the behavior of the IP packet generator, it is not affected if the browser runs in privacy mode.Cross-Browser: Since our technique exploits the behavior of the IP packet generator, it yields the same device ID regardless of the browser used. It works best when the WebRTC STUN [21] Sending Short UDP Datagrams to Arbitrary Destinations, or "Set Your Browsers to STUN" The technique requires sending UDP datagrams from the browser to multiple destinations. Otherwise, the algorithm needs to go through the remaining key space.Approximated P distribution f [Hz] E(P) σ (P) σ (P) /E(P)100Targeted tracking Even if the key space W is too large to make it economically efficient to run large scale device tracking, it is still possible to use it for targeted tracking. 12 In general, for tracking purposes, a lower value of f is better.Note that key and net are generated during the operating system initialization, which, unlike Windows, happens during restart and during (shutdown+)start. Controlling such a magnitude of Internet-routable IP addresses was logistically out of scope for this research. These are quite rare (in the STUN traffic measurement experiment we got 29 such cases out of 1014 -2.9%, though they are more common in Androids whose kernel is 4.x and have f = 100) and easily identified. That is, for j = 1, . . . , J − 1 and i = 17, . . . , 31, the equations are:31 m=16 (IP j ⊕ IP 0 ) m · K i+m = (Vec(IPID j − (β 0 + j) mod 2 15 ) ⊕ Vec(IPID 0 − (β 0 ) mod 2 15 )) i (4)Speeding up the computation using preprocessing The coefficients of K in eq. Lab verification We tested a machine in the lab with the above test setup to obtain 40 bits of K. Then, using WinDbg in local kernel mode, we obtained tcpip!TcpToeplitzHashKey, extracted the 40 bits from it and compared to the 40 bits calculated by the snippet -as expected, they came out identical. This is less ideal since the traffic is less bursty, its transmission order isn't deterministic, and there is an overhead in HTTPS requests and in gQUIC packets.Browser Distribution in Android We want to estimate the browser market share of "supportive" browsers (Chromelike and Firefox) in the Android OS. A 3 -Algorithm 2, adding net namespace to the calculation.Of interest to us are algorithms A 1 to A 3 . 3. Substituting the above into the definition of IPID yields:IPID g, j = β g + j + Num( T (K, IP 0 ) 17,...,31 ⊕ Vec(IPID 0 − β 0 mod 2 15 ) 17,...,31 ⊕ T (K, IP g, j ) 17,...,31 ) mod 2 15Using the linearity of T , this is simplified into: 14 . As described in Section 1, fingerprinting techniques typically cannot guarantee the uniqueness of the device ID, in particular with respect to corporate machines cloned from "golden images". The procedure picks an index to a counter as a function of the source and destination IP address, the protocol and the key. Since "Tor transports TCP streams, not IP packets", 10 this applies to all Tor-based products, such as the Tor browser and Brave's "Private Tabs with Tor" and therefore they are not covered by our technique.Windows Defender Application Guard (WDAG): This new technology in Windows 10 enables the user to launch the Edge browser in a virtual environment. Thus we use an upper bound of δ L = 0.6 seconds for a single burst duration.Chrome emits up to 9 bursts with increasing time delays, at the following times (in seconds, where t = 0 is the first burst): 0, 0.25, 0.75, 1.75, 3.75, 7.75, 15.75, 23.75, 31.75. Corporates, however, often install a single "golden image" (standard set of software packages) on many identical (hardware-wise) machines, and therefore it is hard to obtain fingerprints that distinguish among such machines.In this work we present a new tracking mechanism which is based on extracting data used by the IP ID generator (see Section 1.1). The tracker already knows these values except for K 18 , . . . , K 33 , and therefore only needs to enumerate over the 2 15 possible values of K 18 , . . . , K 32 and eliminate all values which do not agree with the equation. The tracker needs to contro