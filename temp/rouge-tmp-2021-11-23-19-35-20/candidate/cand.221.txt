This paper presents PeX, a static Permission check error detector for LinuX, which takes as input a kernel source code and reports any missing, inconsistent, and redundant permission checks. We evaluated PeX on the latest stable Linux kernel v4.18.5 for three types of permission checks: Discretionary Access Controls (DAC), Capabilities, and Linux Security Modules (LSM). In Linux, each user is assigned a user identifier (uid) and a group identifier (gid). Correspondingly, each file has properties including the owner, the group, the rwx (read, write, and execute) permission bits for the owner, the group, and all other users. We refer to those functions, that validate whether a process (a user or a group) has proper permission to do certain operations, as permission checks. On its call path, vfs_readlink (Line 7) is protected by the LSM hook security_inode_readlink (Line 4) so that a LSM-based MAC mechanism, such as SELinux or AppArmor, can be realized to allow or deny the vfs_readlink operation. For example, as shown in Figure 3a, VFS abstracts all file system operations in a ker-nel interface struct file_operations that contains a set of function pointers for different file operations. The second challenge lies in soundly enumerating a set of permission checks and inferring correct mappings between permission checks and privileged functions in Linux kernel.Though some commonly used permission checks for DAC, Capabilities, and LSM are known (Table 1), kernel developers often devise custom permission checks (wrappers) that internally use basic permission checks. However, it still blows up both the memory and the computation time due to the expensive insert, expand and merge operations.shows how hard it is for a permission check analysis tool to keep up with all permission checks.To make matters worse, Linux kernel has no explicit documentation that specifies which privileged function should be protected by which permission checks. Since the huge Linux kernel code base makes it practically impossible to review them all manually, reasoning about the mapping is considered to be a daunting challenge.In light of this, PeX presents a novel static analysis technique that takes as input a small set of known permission checks to identify their basic permission checks and leverages them as a basis for finding other permission check wrappers ( §6.2). KIRIN is inspired by two key observations: (1) almost all (95%) indirect calls in the Linux kernel are originated from kernel interfaces ( §4.1) and (2) the type of a kernel interface is preserved both at its initialization site (where a function pointer is defined) and at the indirect callsite (where a function pointer is used) in LLVM IR. Some interfaces may be dynamically allocated and initialized at run time for reconfiguration.For the former, KIRIN scans all Linux kernel code linearly to find all statically allocated and initialized struct objects with function pointer fields. KIRIN stores the result of the above first pass in a key-value map data structure in which the key is a pair of kernel interface type and an offset (a field), and the value is a set of call targets. This adds back the kernel interface type struct.usb_driver in the LLVM IR (Line 6), thereby enabling KIRIN to infer the correct type of driver and resolve the targets for unlocked_ioctl.Our experiment ( §7.2) shows that KIRIN resolves 92% of total indirect callsites for allyesconfig. It takes as input kernel source code (in the LLVM bitcode format) and common permission checks (Table 1), analyzes and reports all detected permission check errors, including missing, inconsistent, and redundant permission checks. PeX generates the call graph leveraging the result of KIRIN ( §5), and then partitions it into two groups.User Space Reachable Functions: Starting from functions with the common prefix SyS_ (indicating system call entry points), PeX traverses the call graph, marks all visited functions, and treats them as user space reachable functions. The partitioned call graph serves as a basis for building an interprocedural control flow graph (ICFG) [31] used in the inference of the mapping between permission checks and privileged functions ( §6.3). However, they are often the wrapper of basic permission checks, which actually perform the low-level access control, and even worse there could be other wrappers of the wrapper.PeX solves this by automating the process of identifying all permission checks including wrappers. Given a known permission check ns_capable (Lines 10-13), PeX first finds security_capable (Line 4) as a basic permission check, and then based on it, PeX detects another permission check wrapper has_ns_capability (Lines [14][15][16][17][18][19][20]. The rationale behind the dominator analysis is based on the following observation: since there is no single path that allows the dominated call instruction to be reached without visiting the dominator (i.e., the permission check), pc f uncs -all permission checking functions OUTPUT:pv f uncs -privileged functions 1: procedure PRIVILEGED FUNCTION DETECTION 2:for f ← pc f uncs do for u ← User( f ) do CallInst ← CallInstDominatedBy(u) Inter-procedural analysis, for full program path callee ← getCallee(CallInst) pv f uncs.insert(callee) end for 8: end for return pv f uncs 10: end procedure the callee is likely to be the one that should be protected by the check on all paths 2 . For a given mapping between a permission check and a privileged function, PeX performs a backward traversal of the ICFG, starting from the privileged functions with the corresponding permission check in mind. If the call to the privileged function (pvcall) is not preceded by the corresponding permission check func- end for for f ← kinit f uncs do if f uses any pc f uncs then report ( PeX was implemented using LLVM [27]/Clang-6.0. For comparison, we took K-Miner's implementation from the github [6] and added the logic to count the number of resolved indirect callsites and the average number of targets per callsite. Table 3 summaries evaluation results of KIRIN, comparing it to the type-based approach and K-Miner approach in terms of the percentage of indirect callsite (ICS) resolved, the average number of targets per ICS, and the total analysis time. After further inves-tigation, we noticed that SVF runs on each partition whose code base is smaller than the whole kernel, its analysis scope is significantly limited and unable to resolve function pointers in other partitions, leading to the poor resolution rate.Besides, we found out that K-Miner does not work for allyesconfig which contains a much larger code base than defconfig. As a result, the type-based approach incorrectly identifies both functions as possible call targets of the function pointer f_ops→write_iter. For example, PeX detects wrappers such as nfs_permission and may_open for DAC; sk_net_capable and netlink_capable for Capabilities; and key_task_permission and __ptrace_may_access for LSM. In the mean time, PeX+KM timed out on an earlier pointer analysis phase, thereby failing to report any bug.When defconfig is used for comparison, PeX+TYPE and PeX+KM were able to complete the analysis. Though PeX+TYPE can capture them all (as type-based analysis is sound yet imprecise), it generates up to 3x more warnings, placing a high burden on the users side for their manual review. We plan to release PeX and the list of potential privileged functions, hoping kernel developers will contribute to identify privileged functions and fix more true permission errors.Certain static paths reported by PeX may not be feasible dynamically during program execution, resulting in false positives. Specifically, a problematic path starts from evdev_write and reaches the privileged function credit_entropy_bits, which can control the entropy in the entropy pool, while bypassing the required CAP_SYS_ADMIN permission check.The LSM-21 missing check in xfs_file_ioctl led to another interesting discussion among kernel developers [9]. Nonetheless, we have one complaint to share.For the LSM-19 and LSM-20 cases, PeX found that the LSM hooks security_kernel_read_file and security_kernel_post_read_file were used to protect the privileged functions kernel_read_file and kernel_post_read_file in some program paths. For the same privileged function prctl_set_mm_exe_file, which is used to set an executable file, PeX discovered one case requiring CAP_SYS_RESOURCE in user namespace, and another case checking CAP_SYS_ADMIN in init namespace. AutoISES regards data structures, such as the structure fields and global variables, as privileged, applies static analysis to extract security check usage patterns, and validates the protections to these data structures. First, PeX is privileged function oriented while AutoISES is more like data structure oriented.Second, AutoISES is designed for LSM only, whose permission checks (hooks) are clearly defined, and therefore it is not applicable to DAC and Capabilities due to their various permission check wrappers. Note that to resolve indirect call targets, all these works leverage a type-based approach, which is not as accurate as KIRIN, thus suffering from false positives.MECA [54] is an annotation based static analysis framework, and it can detect security rule violations in Linux.APISan [55] aims at finding API misuse. RoleCast [42] leverages software engineering patterns to detect missing security checks in web applications.