For instance, since the majority of static analysis tools inspect the Dalvik bytecode [2], malware circumvent them by using various obfuscation techniques to raise the bar of code comprehension [61], implementing malicious activities in native libraries to evade the inspection [13,59,70,92], and leveraging packing techniques to hide malicious payloads [82,85,88]. However, existing systems are not effective in capturing the execution of all malicious payloads, because they are impaired by the inherent limitation of dynamic analysis (i.e., low code coverage) and the lack of efficient code path exploration technique.In this paper, we propose Malton, a novel on-device non-invasive analysis platform for the ART runtime. First, to trigger as many malicious payloads as possible, we propose a multi-path exploration engine based on the concolic execution [27] to generate concrete inputs for exploring different code paths. Second, to conduct efficient path exploration on mobile devices with limited computational resources, we propose an offloading mechanism to move heavy-weight tasks (e.g., solving constraints) to resourceful desktop computers, and an in-memory optimization mechanism that makes the execution flow return to the entry point of the interested code region immediately after exiting the code region. ART is the new runtime introduced in Android version 4.4, and becomes the default runtime from version 5.0. Hence, we can find the information of a Java class in the oatdata section and its compiled native code through the oatexec symbol.When an app is launched, the ART runtime parses the OAT file and loads the file into memory. Reading contact and parsing SMS are implemented in the JNI methods readContact() (Line 1) and parseMSG() (Line 2), respectively.Existing malware analysis tools could not construct a complete view of the malicious behaviors. Although existing tools (e.g., CopperDroid [73]) can find that the malware reads IMSI and leaks the information by system call sys sendto(), they cannot locate the method used to get IMSI and how the IMSI is leaked in detail, because sys sendto() can be called by many functions (e.g., JavaMail APIs, Java Socket methods and C/C++ Socket methods) from both the framework layer and the native layer. To address this challenge, we propose an efficient way to bridge the semantic gaps between the low level native instructions and upper layer Java methods.Java Method Tracker To track the Java method invocations, we need to identify the entry point and exit points of each Java method from the ARM instructions dynamically. If so, Malton inserts the helper function (i.e., callTrack()) at the beginning of the block to record the method invocation and parse arguments when it is executed.To identify the exit point of a Java method, Malton leverages the method calling convention of the ARM architecture 2 . If they are equal, an exit point of the method is found, and this return address is popped from the method call stack.Malton parses the arguments and the return value of the method after the entry point and the exits point of the method are identified, respectively.According to the method calling convention, the register r0 points to the ArtMethod object of current method, and registers r1 − r3 contain the first three arguments. For example, when the framework method sendMessageAtTime(Message msg, long uptimeMillis) of class android/os/Handler is invoked, r0 points to the ArtMethod instance of the method sendMessageAtTime(), r1 stores the this object and r2 represents the argument msg. While the invoked Java method could be tracked by the Java method tracker in the Android framework layer, Malton tracks the JNI reflection to provide a comprehensive view of malicious behaviors, such as, the context when privacy-concerned Java methods are invoked from the native code. Native code loading means that malicious code could be implemented in native code and loaded into memory, where Java code loading refers to loading the Dalvik bytecode. Since malware usually receives the control commands and sends private data through network, Malton inspects these behaviors by wrapping network related system calls, such as, sys connect(), sys sendto(), recvfrom(), etc.• File operations. As malware often needs to fork new process, or exits when the emulator or the debug environment is detected, Malton captures such behaviors by monitoring system calls relevant to the process operations, including sys execve(), sys exit(), etc.Moreover, Malton may need to modify the arguments and/or the return values of system calls to explore code paths. In this case, Malton replaces the results of the system call sys connect() to success, or replaces the address of C&C with a bogus one controlled by the analyst to trigger malicious payloads. To propagate taint tags across different layers, Malton works at the instruction layer because the codes of all upper layers become ARM instructions during execution. During the execution of the target app, Malton parses the IR statements and expressions in the helper functions, and propagates the taint tags according to the logic of the IR statements and expressions.Malton supports taint sources/sinks in different layers (i.e., the framework layer and the system layer). Instead, we detail the offloading mechanism and the in-memory optimization used in the concolic execution module, and explain how the direct execution engine works.Concolic Execution: Offloading Mechanism It is nontrivial to apply concolic execution in analyzing Android malware on real devices, because concolic execution requires considerable computational resources, resulting in unacceptable overhead on the mobile devices. Besides, Malton inserts a helper function before each memory store (i.e., Ist Store and Ist StoreG) statement to track the memory modifications, so that all the modified memory could be restored.Alternatively, the analyst can choose the target code region according to the method call graph, or first use static analysis tool to identify code paths and then select a portion of the path as the interested code region. To answer Q2, we evaluate Malton with sophisticated malware samples by constructing the complete flow of information leakage across different layers, detecting stealthy behaviors with Java/JNI reflection, dissecting the behaviors of packed Android malware, and identifying the malicious behaviors of hidden code. To retrieve the information of each contact, the malware first obtains the column index and the value of the field id in step 1 and step 2 in Figure 4 6 , respectively. Then, a new instance of the class CursorWrapper 6 The number in each ellipse denotes the step index.is created based on id and uri (com.android.contact), and this contact's phone number is acquired through this instance. The number in the ellipse and rectangle is the step index, and we use different colours (i.e., Figure 5: Malton can detect stealthy behaviors through the Java/JNI reflection of the photo3 malware. As an example, Fig- ure 6 shows partial log file of analyzing the packed malware sample 9 , and Figure 7 illustrates the identified malicious behaviors of this sample. Malton empowers us to observe that the ART runtime invokes the function FindClass() (Line 8) and the function LoadNativeLibrary() (Line 9) to locate the class com.netease.nis.wrapper.MyJni and load the library libnesec.so, respectively.After initialization, the malware calls the JNI method MyJni.load() to release and load the hidden Dalvik bytecode into memory. Note that ZjDroid [9] is a dynamic unpacking tool based on the Xposed framework and is started by the Intent com.zjdroid.invoke.By registering the Intent receiver, the malware can detect the existence of ZjDroid.Finally, the app loads and initializes the class v.v.v.MainActivity in Line 23 to 26, and the hidden malicious payloads are executed at Line 29. To evaluate the ef- Table 5: The commands and the related behaviors explored by Malton (The 3rd column lists the number of IR blocks to be executed for exploring the code paths with/without in-memory optimization). Detected behavior Number of executed blocks "cq" Read information SMS contents, contacts, device model and system version, then send to 292019159c@fcvh77f.com with password "aAaccvv11" through SMTP protocol. 15k/20443kficiency of the in-memory optimization, we record the number of IR blocks to be executed for exploring each code path with/without in-memory optimization, and list them in Table 5 (the last column). In future work, we will borrow some ideas from the X-Force [55] system to recover the execution from crashes automatically.Third, the code coverage is a concern for all dynamic analysis platforms, including ours. We leverage the monkey tool to generate events, and use the path exploration module to explore code paths. Moreover, as Malton only defines the default sensitive APIs, users can add more sensitive APIs to Malton.Last but not least, though Malton uses taint analysis to track sensitive information propagation, it cannot track implicit information flow and propagate taint tags over indirect flows.We will enhance it by leveraging the ideas in [45]. According to the implementation techniques, the existing (dynamic or hybrid) Android malware analysis tools can be roughly divided into five types: tailoring Android system [34,39,71,89], customizing Android emulator (e.g., Qemu) [73,83], modifying (repackaging) app implementation [37], employing system tracking tools [84], or leveraging an app sandbox [20,24]. Mobile-Sandbox [68] uses TaintDroid to monitor framework behaviors and employs ltrace [5] to capture native behaviors.To avoid modifying Android system (including the framework, native libraries, Linux kernel etc.), a number of studies [10,12,22,23,31,32,43,60,61,67,78,81,87] propose inserting the logics of monitoring behaviors or security policies into the Dalvik bytecode of the malware under inspection and then repacking it into a new APK. ANDRUBIS [50] and MARVIN [49] (which is built on top of ANDRUBIS) monitor the behaviors at the framework layer by instrumenting DVM and log system calls through VMI.TaintDroid [39] 񮽙 񮽙 × × × × × × Dynamic TaintART [71] 񮽙 × 񮽙 × × × × × Dynamic ARTist [21] 񮽙 × 񮽙 × × × × × Dynamic DroidBox [34] 񮽙 񮽙 × × × × × × Dynamic VetDroid [89] 񮽙 񮽙 × × × × × × Dynamic DroidScope [83] × 񮽙 × × × × × 񮽙 Dynamic CopperDroid [73] × 񮽙 񮽙 × × × × 񮽙 Dynamic Dagger [84] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic ARTDroid [30] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic Boxify [20] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic CRePE [29] 񮽙 񮽙 × × × × × × Dynamic DroidTrace [91] 񮽙 񮽙 񮽙 × × × × 񮽙 DynamicMonitoring system calls [17,35,46,48,54,68,75,76,84,91] is widely used in Android malware analysis because considerable APIs in upper layers eventually invoke systems calls. One common drawback of systemcall-based techniques is the semantic gap between system calls with the behaviors of upper layers, even though several studies [54,84,91] try to reconstruct high-level semantics from system calls. Since they behave as a proxy for all system calls and binder channels of the isolated apps, they support the analysis of native code and could reconstruct partial framework layer behaviors.ARTDroid [30] traces framework methods by hooking the virtual framework methods and supports ART. Since the boot image boot.art contains both the vtable and virtual methods arrays that store the pointers to virtual methods, ARTDroid hijacks vtable and virtual methods to monitor the APIs invoked by malware.HARVESTER and GroddDroid [10,61] support multipath analysis. Moreover, they do not support the analysis of native code.To make concolic execution applicable for testing embedded software, Chen et al. [28] and MAYHEM [26] adopt similar offloading method.