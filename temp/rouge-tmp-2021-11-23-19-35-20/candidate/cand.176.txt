In light of this, several regulatory bodies have called for a need to audit smart contracts for security and correctness guarantees. Erays takes in smart contract from the Ethereum blockchain, and produces high-level pseudocode suitable for manual analysis. Unfortunately, smart contracts are historically errorprone [14,24,52] and there is a potential high financial risk associated with interacting with smart contracts. As a result, smart contracts have attracted the attention of several regulatory bodies, including the FTC [18] and the SEC [43], which are intent on auditing these contracts to prevent unintended financial consequences. Many smart contracts do not have readily linkable public source code available, making them opaque to auditors.To better understand opaque smart contracts, we present Erays, a reverse engineering tool for Ethereum smart contracts. In light of this, we posit that smart contract developers may be expecting to achieve "security by obscurity" by withholding their high level code.We conclude with a discussion of the value of audits, reverse engineering, and where Erays can aid in solving the growing needs of the Ethereum community. Solidity syntax is heavily influenced by Javascript and C++, and supports a number of complex language features, such as inheritance, libraries, and user-defined types.Ethereum-based Tokens.In addition to the built-in Ether currency, the Ethereum blockchain is also widely used as a host for "tokens", which are separate currencylike instruments built on top of a smart contract. We scraped Etherscan for all verified contracts as of January 3rd, 2018, collecting a total of 10,387 Solidity files.We then compiled the Etherscan verified contracts to determine exact bytecode matches with blockchain contracts. At its core, recovering a CFG from basic blocks requires identifying the successor(s) of each basic block.To determine the successor(s) for a basic block b, we need to examine the last instruction in the block. In the last case, the successor depends on the target address of the branch instruction, which requires closer scrutiny.Indirect branches present a challenge when determining the target address [46]. The algorithm follows a conventional pattern for CFG recovery [46]: we analyze a basic block, identify its successors, add them to the CFG, then recursively analyze the successors.When analyzing a block, we model the stack effects of instructions. In this stage, we lift EVM's stack-based instructions into a register-based instructions. In order to eliminate redundant basic blocks, we replace these checks with ASSERT.NEQ, GEQ, LEQ, SL, SR: These instructions correspond to "not equal", "greater than or equal", "less than or equal", "shift left", and "shift right". The instructions SWAP (swap two stack items), DUP (duplicate a stack item) and PUSH (push a stack item) are all translated into MOVE instructions.To derive the registers on which the instructions operate, we map each stack word to a register, ranging from $s0 to $s1023 because the EVM stack is specified to have a maximum size of 1,024 words. The initial stack height is three, thus, ADD reads from $s1 and $s2, and writes back the result to $s1.Knowing the precise stack height is crucial to lifting. Given the stack heightPUSH1 0x1 MOVE $s3, 0x1 SLOAD SLOAD $s3, [$s3] DUP2 MOVE $s4, $s2 LT LT $s3, $s4, $s3 ISZERO ISZERO $s3, $s3 PUSH1 0x65 MOVE $s4, 0x65 JUMPI JUMPI $s4, $s3Code Block 3: Lifting A BLock -We show a block of stackbased instructions lifted to register-based instructions given initial stack height of three.SLOAD $s3, [0x1] GEQ $s3, $s2, $s3 JUMPI 0x65, $s3Code Block 4: Optimizing A Block -We show the optimized version of Code Block 3. Aggregation aims to further simplify the produced intermediate representation by replacing many instructionsSLOAD $s3, [0x1] $s3 = S[0x1] GEQ $s3, $s2, $s3 $s3 = $s2 ≥ $s3 JUMPI 0x65, $s3 if ($s3) goto 0x65Code Block 5: Three-Address Form -We show the Code Block 4 in three-address form.with their analog, compact versions that we term "aggregated expressions." We cease propagating a given definition when either $r is redefined or any part of RHS is redefined.Combined with dead code elimination, the aggregation process pushes the definitions down to their usages, producing a more compact output. Consider the example in Code Block 5, by aggregating the first expression into the second one, and then the second into the third, the block can be summarized into a single expression:if ($s2 ≥ S[0x1]) goto 0x65 We employ structural analysis [44] algorithms to recover high level control constructs (control flow structure recovery). Given specific contract inputs, we "execute" our representation andassert(0x0 == msg.value) $s2 = c[0x4] while (0x1) { if ($s2 >= s[0x0]) break if ($s2 <= 0xa) { $s2 = 0x2 + $s2 } $s2 = 0xc + $s2 } m[$m] = $s2 return($m, (0x20 + $m) -$m)Code Block 6: Structural Analysis -A simple example of the final output of Erays, where control flow structures are recovered from blocks of expressions. Each step is a snapshot of the EVM machine state, which includes the opcode executed, the program counter, the stack image, the memory image, and the storage image.We then "execute" our representation and confirm the result is consistent with the debug trace. Operations that are dependent on the blockchain world state also fall into this category. Such operations include storage updates, contract creation, log updates and message calls. By making sure that all these operations are executed with the right arguments (memory buffers are checked if applicable), we ensure that our representation is correct. As an example, when executing $s3 = $s2 + $s3, we would load the values from $s2 and $s3, sum them , modulo by 2 256 (word size) and put the result in $s3. If our machine encounters an exception during these operations, we mark it as a failure.We leverage historical transactions on the blockchain to construct a set of tests. There are several follow-up works on improving the recovery process, including iterative refinement [41] and pattern-independent structuring [51]. Most contracts are fairly small -the median number of blocks found in contracts is 100, and these blocks contain a median 15 instructions. To quantify this, we measure the cyclomatic complexity of each contract, which is a popular software metric introduced by Thomas McCabe [33]. We note that around this time, there was a sharp rise in ERC20 Tokens on the Ethereum blockchain, which tend to be larger contracts that contain an average of 226 blocks. However, they are not particularly complex, and have an average McCabe complexity of 51.6, which is smaller than many contracts in the ecosystem. Each block, however, may contain contract specific data that would render the comparison useless, such as specific return address information or constants compiled into a block. For example, the most popular function by implementation is the public getter function for the uint256 data type.We next turn to investigate popular external functions included in contracts, and the number of implementations of each of those functions. Some of these can be easily explained, for example, the decimals() function is simply a 'getter" method for getting the precision of a token. All of the top functions are related to ERC20 tokens [26], which are required to implement a specific interface.ness logic for a token that defines how token transfers happen, and are somewhat custom. Using Erays, we find that many of these are multisignature wallets that require multiple individuals to approve any transactiona standard cryptocurrency security measure. Through blockchain analysis using Etherscan, we observed that this contract was accessed every week from the same account, 0xd244..., which belongs to Gemini, a large cryptocurrency exchange. 4 This address accesses two other high value, opaque wallets in our dataset, with $381 M and $164 M USD in balance, respectively.We use Erays to reverse engineer these contracts, and uncover their access control policies. Any party can call the Table 3: Top Contracts by Balance -We show the top 10 contracts by balance, as well as their transaction volume, whether they matched exactly to verified code, and their opacity reduction after applying Erays if they did not match to source code. We note that in the past, cryptocurrency exchanges have failed to handle related hazards, resulting in significant losses [21]. We find that many of these contracts are associated with large exchanges that create one contract instance for each user account.Poloniex Exchange Wallets The largest cluster of identical opaque contracts appears a total of 349,612 times on the Ethereum blockchain. To begin, we built a list of 30 suspected arbitrage contracts by scanning transactions within blocks 3,900,000 to block 4,416,600, and selected contracts that both make internal calls to EtherDelta and generate two trade events in a single transaction. To prune our list, we ran our similarity metric (described in Section 5) over every pair of the 30 contracts and found three clusters of highly similar (> 50% similarity) contracts. As a final case study, we apply Erays to the Cryptokitties contract.With 3 hours of reverse engineering work using Erays, we were able to create a Solidity contract whose output exactly matches the output of the mixGenes function on the blockchain. Finally, a particular gene is mutated with 25% probability if the larger of the two parents' corresponding gene is less than 23 and with 12.5% probability otherwise.Concurrent to our work in reverse engineering, at least three other teams also attempted to reverse engineer the mixGenes function [22,27,48]. Much of the analysis on the Bitcoin blockchain has focused on clustering transactions by usage patterns (e.g., gambling or trading) [34] and measuring the performance of the underlying peer-to-peer network [19,20,36,37]. We envision that reverse engineering may be used by "white hate" security teams or regulatory bodies in order to carry out public audits of the Ethereum blockchain. Etherscan's verified source code is a step in the right direction, but more work must be done in order to improve transparency in the ecosystem.Why are so many contracts opaque, given the ease of publishing source code to Etherscan? In some cases, opacity may be a deliberate decision in order to achieve security through obscurity. Although Ethereum features a decentralized standard called "Swarm" that supports publishing a contract's Application Bytecode Interface (ABI), including the method signatures and argument types, this standard does not include the full source code. We identified that smart contract developers may be expecting obscurity for the correct functionality of their contracts, and may be expecting to achieve "security by obscurity" in withholding their high level code. For an INTCALL, they can be interpreted as the number of arguments and return values.We note that a sequence of bytecode instructions can be viewed as a single operation, thus the delta and alpha value of the sequence computed in the manner shown in 7. We observe that callee_exit would normally end with an indirect branch, where the branch address is produced by caller_begin.