A natural step to secure privacy-sensitive data is to use end-to-end encryption to protect it during transit.Existing protocols for end-to-end encryption, such as SSL/TLS and TextSecure [44], focus on one-to-one communication between two principals: for example, Alice sends a message to Bob over an insecure channel. Such IoT systems demand many-to-many communication among decoupled senders and receivers, and require decentralized delegation of access to enforce which devices can communicate with which others.We investigate existing IoT systems, which currently do not encrypt data end-to-end, to understand the requirements on an end-to-end encryption protocol like JEDI. A resource hierarchy matches the organization of IoT devices: for instance, smart cities contain buildings, which contain floors, which contain rooms, which contain sensors, which produce streams of readings. Generally, a principal with access to a set of resources can give another principal access to a subset of those resources.Vanadium [77] and bw2 [5] introduced decentralized delegation (SPKI/SDSI [31] and Macaroons [13]) in the smart buildings space. Only principals permitted to subscribe to a URI are given keys that can decrypt messages published to that URI.IoT systems that support decentralized delegation (Vanadium, bw2), as well as related non-IoT authorization systems (e.g., SPKI/SDSI [31] and Macaroons [13]) provide principals with tokens (e.g., certificate chains) that they can present to prove they have access to a certain resource. A number of IoT systems [70,74] use only simple cryptography like AES, SHA2, and ECDSA, but these primitives are not expressive enough to encode JEDI's rendezvous point, which must support hierarchically-structured resources, non-interactive expiry, and decentralized delegation.Existing systems [83][84][85] with similar expressivity to JEDI use Attribute-Based Encryption (ABE) [12,48]. Publishers encrypt their messages with JEDI before passing them to the underlying communication system (without knowledge of who the subscribers are), and subscribers decrypt them with JEDI after receiving them from the underlying communication system (without knowledge of who the publishers are). An adversary in JEDI who steals an authority's secret key can decrypt all messages for that hierarchy, but still does not learn who has access to which resource, and cannot access separate hierarchies to which the first authority has no access. In the campus IoT example above, if a building admin receives access to all sensors and all their different readings for a building, the admin must obtain a potentially very large number of keys, instead of one key for the entire building. For a pattern S, we define:fixed(S) = {(i, S(i)) | S(i) = ⊥} free(S) = {i | S(i) = ⊥}A key for pattern P 1 can decrypt a message encrypted with pattern P 2 if P 1 = P 2 . We use the first 1 slots to encode the URI, and the last 2 slots to encode the time.Given a URI of length d, such as a/b/c (d = 3 in this example), we split it up into individual components, and append a special terminator symbol $: ("a", "b", "c", $). To encrypt a message m in JEDI, one samples a symmetric key k, and encrypts k with JEDI to produce ciphertext c 1 . To sign a message m ∈ Z * p with a key for pattern S, one uses KeyDer to fill in a slot with m, and presents the decryption key as a signature. We can circumvent this by instead (1) choosing a symmetric key k every hour, (2) signing k at the start of each hour (using WKD-IBE for anonymity), and (3) using k in an authenticated broadcast protocol to authenticate messages sent during the hour. For any well-formed keys k 1 , k 2 corresponding to the same (URI, time) pair in the same resource hierarchy, and any message m ∈ Z * p , the distribution of signatures over m produced using k 1 is information-theoretically indistinguishable from (i.e., equal to) the distribution of signatures over m produced using k 2 . In this solution, all keys are time-limited, and delegations are periodically refreshed, according to a higher layer protocol, by granting a new key with a later expiry time. This means that we must either (1) rely on intermediate parties to modify ciphertexts so that revoked keys cannot decrypt them, or (2) require senders to be aware of the revocation, and encrypt messages in a different way so that revoked keys cannot decrypt them. For example, if Alice has leaves lf 3 to lf 4 in Fig. 5, she stores an unqualifiable key for node v 1 and a qualifiable key for node v 3 . The size of secret keys is O(log k + log n) after our modifications to the CS method, so JEDI keys grow by this factor, to a total of O((log k + log n) · log T ) WKD-IBE keys, where T is the length of the time range for expiry.The construction in this section works to revoke decryption keys, but cannot be used with anonymous signatures ( §4.2). In the smart buildings use case ( §1), for example, a key would need to be revoked if a principal unexpectedly transfers to another job.The SD method for tree-based broadcast encryption can also be extended to support delegation and incorporated into JEDI (described in the appendix of our extended paper [57]), The SD method has smaller ciphertexts but larger keys. We expect JEDI's key delegation to be computed on relatively powerful devices, like laptops, smartphones, or Raspberry Pis; less powerful devices (e.g., right half of Fig. 1) will primarily send and receive messages, rather than generate keys for delegation. Even on more powerful microarchitectures without this limitation (e.g., Intel Core i7), most CPU time (≥ 80%) is spent on multiply-intensive operations (e.g., BigInt multiplication and Montgomery reduction), so the lack of such an instruction was a performance bottleneck. Fig. 6 does not include the sensor platform; §7.3 thoroughly treats performance of JEDI on low-power sensors.In Figure 6a, we used a pattern of length 20 for all operations, which would correspond to, e.g., a URI of length 14 and an Expiry hierarchy of depth 6. In bw2, the two critical-path operations are publishing a message to a URI, and receiving a message as part of a subscrip- We measure the overhead of JEDI for these operations because they are core to bw2's functionality and would be used by any messaging application built on bw2. JEDI has a particularly small overhead for 1 MiB messages in Fig. 7b, perhaps because 1 MiB messages take several milliseconds to transmit over the network, allowing the client to decrypt a message while the router is sending the next message.We also consider creating DOTs and initiating subscriptions, which are not in the critical path of bw2. To calculate the impact on battery lifetime, we consider a "sense-and-send" application, in which the Hamilton device obtains readings from its sensors at regular intervals, and immediately sends the readings encrypted over the wireless network. Therefore, this section explores how to perform individual WKD-IBE encryptions more efficiently.Most of the work to encrypt under a pattern S is in computing the quantity Q S = g 3 · ∏ (i,a i )∈fixed(S) h a i i , where g 3 and the h i are part of the WKD-IBE public parameters. Table 4 contains quantitative comparisons to the cryptography used by these systems; for those schemes based on bilinear groups, we re-implemented them using our JEDI crypto library ( §6.1) for a fair comparison. JEDI differs from existing encryption protocols like SSL/TLS, requiring us to overcome a number of challenges: Figure 2: JEDI keys can be qualified and delegated, supporting decentralized, cryptographically-enforced access control via key delegation. To encrypt a message that is decryptable by a subset of users, one finds a collection of subtrees that include all leaves except those corresponding to revoked users and encrypts the message multiple times using the public keys corresponding to the root of each subtree. To combine a hierarchy of maximum depth 1 (e.g., the URI hierarchy) and a hierarchy of maximum depth 2 (e.g., the expiry hierarchy), one can Setup WKD-IBE with the number of slots equal to = 1 + 2 . A central question answered in this section is: How should publishers encrypt messages before passing them to the underlying system for delivery ( §3.4)? To send a message, a principal encrypts it ( §3), signs the ciphertext, and includes a certificate chain that proves that the signing keypair is authorized for that URI and time. For battery lifetime calculations, we assume that the platform is powered using a CR123A Lithium battery that provides 1400 mAh at 3.0 V (252 J of energy). Cortex-M3 and Cortex-M4, which are more commonly used than Cortex-M0+, have instructions for 32-bit multiply-accumulate which produce the entire 64-bit result; we expect JEDI to be more efficient on those processors.We also wrote assembly to optimize BLS12-381 for x86-64 and ARM64, representative of server/laptop and smartphone/Raspberry Pi, respectively (first two tiers in Fig. 1). To address this challenge, we adapt the WKD-IBE scheme that we use for end-to-end encryption to achieve an anonymous signature scheme that can encode the URI and expiry and support decentralized delegation. Since JEDI decouples senders from receivers, it has no requirements on what happens at any intermediaries (e.g., does not require messages to be forwarded from publishers to subscribers in any particular way). Because that principal owns all of the resources in the hierarchy, it is called the authority of that hierarchy.Due to the setting of decoupled senders and receivers, the sender can no longer encrypt messages with the receiver's public key, as in traditional end-to-end encryption. JEDI takes advantage of this by efficiently adjusting the precomputed value Q S to compute Q T as follows:Q T = Q S · ∏ (i,b i )∈fixed(T ) i∈free(S) h b i i · ∏ (i,a i )∈fixed(S) i∈free(T ) h −a i i · ∏ (i,a i )∈fixed(S) (i,b i )∈fixed(T ) a i =b i h b i −a i iThis requires one G 1 exponentiation per differing slot between S and T (i.e., the Hamming distance). Achieving end-to-end encryption for large-scale IoT systems, like smart buildings or smart cities, is challenging because multiple principals typically interact indirectly via intermediaries, meaning that the recipient of a message is not known in advance. This requires storage for only 15 hashes (< 4 KiB memory) and computation of only 105 hashes per hour, which is practical. Achieving this is nontrivial because we have to combine broadcast encryption with JEDI's semantics of hierarchical resources, expiry, and delegation. JEDI, however, uses WKD-IBE in a nonstandard way to simultaneously support multiple hierarchies, one for URIs and one for expiry (and later in §5, one for revocation), each in the vein of HIBE. Neither solution is ideal: (1) makes assumptions about how messages are delivered, which we have avoided thus far ( §2), and requires trust in an intermediary to modify ciphertexts, and (2) weakens the decoupling of senders and receivers ( §1.1). However, for the sense-and-send use case typical of smart buildings, sensors anyway publish messages on a fixed schedule (e.g., one sample every x seconds), allowing the key to depend only on the message index. It is common for these devices to rely on an application-layer gateway to send data to computers outside of the low-power network [91]. • Setup(1 κ , 1 ) → Params, MasterKey;• KeyDer(Params, Key Pattern A , Pattern B ) → Key Pattern B ,derives a key for Pattern B , where either Key Pattern A is the MasterKey, or Pattern A matches Pattern B ;• Encrypt(Params, Pattern, m) → Ciphertext Pattern,m ;• Decrypt(Key Pattern , Ciphertext Pattern,m ) → m.We use the WKD-IBE construction in §3.2 of [1], based on BBG HIBE [17]. We also evaluate JEDI for a commercially available sensor platform called "Hamilton" [49], and show that a Hamilton-based sensor sending one sensor reading every 30 seconds would see several years of battery lifetime when sending sensor readings encrypted with JEDI. Recipients subscribe to a resource by asking the router to send them messages addressed to that resource.Many systems for smart buildings/cities, like sMAP [35], SensorAct [7], bw2 [5], VOLTTRON [82], and BAS [56], organize resources as a hierarchy. It then qualifies those keys using KeyDer to restrict them to the specific URI prefix and time range ( §3.5), and sends the resulting keys to the recipient of the delegation. It transparently encrypts and decrypts messages using WKD-IBE, and includes WKD-IBE parameters and keys in DOTs and principals, as needed for JEDI. Since most of the platform's cost ($18) comes from the on-board transducers and assembly, rather than the SAMR21 SoC, using an even more resource-constrained SoC would not significantly decrease the platform's cost. Since then, decentralized delegation has become the state-of-the-art for access control in smart buildings, especially those geared toward large-scale commercial buildings or organizations [42,52]. WKD-IBE was originally designed to allow delegation in a single hierarchy. The subscriber can decrypt messages for a URI using this key, and contact the key server for a new key when the key expires. Furthermore, A may compromise principals in possession of private keys that can decrypt the challenge (URI, time) pair during Phases 1 and 2, as long as all leaves corresponding to those keys are in the revocation list submitted in the Initialization Phase. This not only makes the broadcast encryption more efficient (smaller r), but also causes the effective revocation list for a stream of data to change even more rarely, allowing JEDI to benefit more from hybrid encryption. Table 4 compares JEDI to other systems and cryptographic approaches, particularly those geared toward IoT, in regard to security, expressivity and performance. Low-power wireless embedded sensors, due to power constraints, often do not use network protocols like Wi-Fi, and instead use specialized low-power protocols such as Bluetooth or IEEE 802.15.4. Conceptually, KeyDer, which is used to produce signatures, can be understood as a two-step procedure: (1) produce a key of the correct form and structure (called NonDelegableKeyDer), and (2) re-randomize the key so that it can be safely delegated (called ResampleKey). Therefore, the subscriber can decrypt c 1 once for the first message to obtain k, and cache the mapping from c 1 to k to avoid expensive WKD-IBE decryptions for future messages sent during that hour.Thus, expensive WKD-IBE operations are only performed upon key rotation, which happens rarely-once an hour (or other granularity chosen for expiry) for each resource. Central to JEDI is the challenge of finding an analogous cryptographic rendezvous point that senders can use to encrypt messages without knowledge of receivers. The above solution reveals the sender's identity (via its public key) and the particular chain of delegations that gives the sender access. One may consider computing Q S once, and then reusing its value when computing future encryptions under the same pattern S. Unfortunately, this alone does not improve efficiency because the pattern S used in one WKD-IBE encryption is different from the pattern T used for the next encryption.JEDI, however, observes that S and T are similar; they match in the 1 slots corresponding to the URI, and the remaining 2 slots will correspond to adjacent leaves in the time tree. Because S and T usually differ in only the final slot of the time hierarchy, this will usually require one G 1 exponentiation total, substantially faster than computing Q T from scratch. In aggregate, the occupancy 