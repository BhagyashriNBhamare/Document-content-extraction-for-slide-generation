A prominent example are browsers, as they parse a multitude of highly-structured inputs, ranging from XML or CSS to JavaScript and SQL queries.Previous approaches to address this problem are typically based on manually provided grammars or seed corpora [2,14,45,52]. In a similar vein, there are often program paths which can only be accessed by inputs outside of the formal specifications, e. g., due to incomplete or imprecise implementations or error handling code.Instead of using a pre-processing step, our technique is directly integrated in the fuzzing process itself. In a first step, we select a diverse set of programs for a comparative evaluation: we evaluate GRIMOIRE against other fuzzers on four scripting language interpreters (mruby, PHP, Lua and JavaScriptCore), a compiler (TCC), an assembler (NASM), a database (SQLite), a parser (libxml) and an SMT solver (Boolector). Coverage-guided fuzzers employ lightweight program coverage measurements to trace how the execution path of the application changes based on the provided input (e. g., by tracking which basic blocks have been visited). Following the overwhelming success of AFL, various more efficient coverage-guided fuzzers such as ANGORA [12], QSYM [64], T-FUZZ [47] or REDQUEEN [3] were proposed.From a high-level point of view, all these AFL-style fuzzers can be broken down into three different components: (i) the input queue stores and schedules all inputs found so far, (ii) the mutation operations produce new variants of scheduled inputs and (iii) the global coverage map is used to determine whether a new variant produced novel coverage (and thus should be stored in the queue). Then, it runs in a continuous fuzzing loop, composed of the following steps: (1) Pick an input from the input queue, then (2) apply multiple mutation operations on it. To determine whether new coverage was triggered, AFL compares the results of the execution with the values in the global coverage map.This global coverage map is filled as follows: AFL shares a memory area of the same size as the global coverage map with the fuzzing target. Hence, the shared map is updated as shown in b , reflecting the fact that edges A → B and C → D were executed only once, while the edges B → C and C → B were encountered 10 (0b1010) times. Finally, AFL checks whether the values encountered in this run triggered unseen edges in d. To this end, we compare the shared map to the global coverage map and update it accordingly (see e ), setting bits set in the shared but not global coverage map. This means that the edge between C → D was previously unseen, thus the input used for this example triggered new coverage.While coverage-guided fuzzers significantly improve upon blind fuzzers, they can only learn from new coverage if they are able to guess an input that triggers the new path in the program. However, they lose the ability to explore behavior more globally.While hybrid fuzzers can solve constraints over individual values of the input, they are typically not efficient at solving constraints on the overall structure of the input. To summarize, current automated software testing approaches have the following disadvantages when used for fuzzing of programs that accept structured input languages:• Needs Human Assistance. Instead, we learn an ad-hoc specification based on the program semantics and use it for coverage-guided fuzzing.We first provide a high-level overview of GRIMOIRE, followed by a detailed description. Using these loose, grammar-like recombination methods in combination with feedback-driven fuzzing, we are able to automatically learn interesting structures. Data: input is the input to generalize, new_bytes are the new bytes of the input, splitting_rule defines how to split an input Result: A generalized version of input 1 start ← 0 2 while start < input.length() do Example 4. To guess different nesting levels in between these pairs of opening/closing characters, we extend Algorithm 1 as follows: If the current index start matches an opening character, we search the furthermost matching closing character, create a candidate by removing the substring in between and check if it triggers the same new coverage. On a high level, we can divide our mutations into three standalone operations: input extension, recursive replacement and string replacement.Given the current input from the fuzzing queue, we add these mutations to the so-called havoc phase [3] as described in Algorithm 2. Algorithm 2: High-level overview of the mutations introduced in GRIMOIRE.Data: input is the current input in the queue, generalized is the set of all previously generalized inputs, tokens and strings from the dictionary, strings is the provided dictionary obtained from the binary1 content ← input.content() 2 n ← havoc_amount(input.performance()) 3 for i ← 0 to n do 4 if input.is_generalized() then 5 input_extension(input, generalized) 6 recursive_replacement(input, generalized) 7 string_replacement(content, strings)Before we describe our mutations in detail, we explain two functions that all mutations have in commonrandom_generalized and send_to_fuzzer. Thus, mutations working on generalized inputs first replace all remaining by an empty string.Algorithm 3: Random selection of a generalized input, slice, token or string.Data: generalized is the set of all previously generalized inputs, tokens and strings from the dictionary Result: rand is a random generalized input, slice token or string 1 if random_coin() then The input extension mutation is inspired by the observation that-in highly structured input languages-often inputs are chains of syntactically well-formed statements. Afterwards, we randomly select n ∈ {2, 4, 8, 16, 32, 64} and perform the following operations n times: First, we randomly select another generalized input, input slice, token or string. We extend the slice to "if(x>1)" and obtain "if(x>1)pprintAlgorithm 5: Overview of the recursive replacement mutation.Data: input is the current generalized input, generalized is the set of all previously generalized inputs, tokens and strings from the dictionary 1 input ← pad_with_gaps(input) 2 for i ← 0 to random_power_of_two() do ''". While REDQUEEN is entirely focused on solving magic bytes and similar constructs which are local in nature (i. e., require only few bytes to change), GRIMOIRE assumes that this kind of constraints can be solved by the underlying fuzzer. Since our technique is merely based on common techniques implemented in coverage-guided fuzzers-for instance, access to the execution bitmap-it would be a feasible engineering task to adapt our approach to other current fuzzers, such as AFL.More precisely, GRIMOIRE is implemented as a set of patches to REDQUEEN. Overall, about 500 lines were written to implement the proposed algorithms.To support reproducibility of our approach, we open source the fuzzing logic, especially the implementation of GRIMOIRE as well as its interaction with REDQUEEN at https://github.com/RUB-SysSec/grimoire. We use four scripting language interpreters (mruby-1.4.1 [41], php-7.3.0 [57], lua-5.3.5 [36] and JavaScriptCore, commit "f1312" [1]) a compiler (tcc-0.9.27 [6]), an assembler (nasm-2.14.02 [56]), a database (sqlite-3.25 [31]), a parser (libxml-2.9.8 [59]) and an SMT solver (boolector-3.0.1 [44]). Therefore, we believe that ANGORA and REDQUEEN find strings that are not part of the dictionary and thus outperform AFL.A complete statistical description of the results is given in the appendix (Table 7). As expected, our completely automated method is defeated in most cases by NAUTILUS since it uses manually fine-tuned grammars.Surprisingly, in the case of mruby, we find that GRIMOIRE is able to outperform even NAUTILUS.To evaluate whether GRIMOIRE is still useful in scenarios where a grammar is available, we perform another experiment. Best AlternativeEffect Size (∆ = ¯ A − ¯ B)Effect Size Additionally, we intended to compare GRIMOIRE against CODEALCHEMIST and JSFUNFUZZ, two other state-of-the art grammar-based fuzzers which specialize on JavaScript engines. The horizontal bar displays the coverage produced by the seed corpus that GLADE used during training.them as GRIMOIRE only supports targets that can be traced with Intel-PT (since REDQUEEN heavily depends on it). We therefore conclude in response to RQ 4 that we significantly exceed comparative grammar inference approaches in the context of fuzzing.We designed another experiment to evaluate whether GLADE's automatically inferred grammar can be used for NAUTILUS and how it performs compared to hand written grammars. As we have shown, GRIMOIRE can also be used to support grammar-based fuzzers with well-tuned grammars but NASM OOB-write - NASM OOB-write - NASM OOB-write - NASM OOB-write - NASM OOB-write - gnuplot 2018-19490 BO - - - - - gnuplot 2018-19491 BO - - - - - gnuplot 2018-19492 BO - - - - -cannot outperform them on their own. Early on, fuzzers typically did not observe the inner workings of the target application, yet different approaches were proposed to improve various aspects of fuzzers: different mutation strategies were evaluated [14,29], the process of selecting and scheduling of seed inputs was analyzed [11,51,61] and, in some cases, even learned language models were used to improve the effectiveness of fuzzing [22,27]. Sometimes, instead of using these heavy-weight primitives, more lightweight techniques such as taint tracking [12,17,26,50], patches [3,13,47,60] or instrumentation [3,39] are used to overcome the same hurdles.While these improvements generally work very well for binary file formats, many modern target programs work with highly structured data. To obtain new inputs, fuzzers traditionally can build on two strategies: generation and mutation.Fuzzers employing the former approach have to acquire a specification, typically a grammar or model, of an application's expected input format. Bastani et al. [5] introduced GLADE, which uses a modified version of the target as a black-box oracle that tests if a given input is syntactically valid. This can be understood as a generalization, in which we reduce inputs to the fragments that trigger new coverage, while maintaining information about gaps or candidate positions (denoted by ). Finallyif not stated otherwise-we use the same uninformed seed that the authors of REDQUEEN used for their experiments: "ABC. . . XYZabc. . . xyz012. . . 789! Thus, the techniques introduced in AN-GORA, REDQUEEN and QSYM are less relevant given the seeds provided to the fuzzers. It is worth mentioning that GRIMOIRE outperforms REDQUEEN, the baseline on top of which our approach is implemented.To partially answer RQ 1, we showed that in terms of code coverage, GRIMOIRE outperforms other state-of-the-art bug finding tools (in most cases). Given a program as black-box oracle as well as a corpus of valid input samples, it learns a grammar in the first stage. In the first experiment, we include the time GLADE spent on training into the measurement while for the second measurement, GLADE is provided the advantage of concluding the training stage before measurement is started for the fuzzing process. From a technical point of view, this maps to AFL as follows: Initially, AFL fills the input queue with the seed inputs. Techniques based on formal reasoning such as symbolic/concolic execution as well as taint tracking require precise semantics of the underlying platform as well as semantics of all used Operating System (OS) features (e. g., syscalls). Best AlternativeEffect Size (∆ = ¯ A − ¯ B)Effect Size During the aforementioned experiments, we also collected various statistics on how effective different mutators are. In this paper, we present the design and implementation of GRIMOIRE, a fully automated coverage-guided fuzzer which works without any form of human interaction or pre-configuration; yet, it is still able to efficiently test programs that expect highly structured inputs. Particularly, the fuzzer is able to sensibly recombine inputs that trigger interesting features in a way that has a good chance of triggering more interesting behaviors.Grammar fuzzers suffer from two major drawbacks. The recursive replacement mutator has a (comparatively) high likelihood of producing new structurally interesting inputs compared to more small-scale mutations used by current coverage-guided fuzzers.Example 7. We select QSYM (commit "6f00c3d") and ANGORA (commit "6ff81c6"), two state-of-the-art hybrid fuzzers which employ different program analysis techniques, namely symbolic execution and taint tracking. Still, as a consequence of the precise search technique, they struggle to explore large code regions due to significant overhead.By combining fuzzing and reasoning-based techniques, one can benefit from the strength of each individual technique, while avoiding the drawbacks. • We show that even though GRIMOIRE is a binary-only fuzzer that needs no seeds or grammar as input, it still outperforms many fuzzers that make significantly stronger assumptions (e. g., access to seeds, grammar specifications and source code). For these incremental runs, we reduce GRIMOIRE's upper bound for input generalization to 2, 048 bytes; otherwise, our fuzzer would mainly spend time in the generalization phase since NAU-TILUS produces very large inputs. For example, starting with the input "if(x>1)then end", we can replace the second gap with the second input, obtaining "if(x>1)then x=y+end". Typically, most totally random inputs are rejected early by the target application and do not visit interesting parts of the state space. Based on the challenges i