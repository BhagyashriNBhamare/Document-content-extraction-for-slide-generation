Unlike previous attempts, which simply automate the execution of known attacks, we consider a more challenging problem: to programmatically derive a novel attack strategy, given only a machine-readable description of the plaintext verification function and the malleability characteristics of the encryption scheme. These attacks likely represent the "tip of the iceberg": many vulnerable systems may remain undetected, due to the difficulty of exploiting non-standard format oracles.From a constructive viewpoint, format oracle vulnerabilities seem easy to mitigate: simply mandate that protocols use authenticated encryption. This is particularly true for non-standard format oracles which require en- Figure 1: Output of a format oracle attack that our algorithms developed against a bitwise padding check oracle F bitpad (see §5.2 for a full description). As a concrete example, the authors of [36] report that Apple did not repair a complex gzip compression format oracle in the iMessage protocol when the lack of authentication was pointed out; but did mitigate the flaw when a concrete exploit was demonstrated. Moreover, the developed attack must be efficient: ideally it should not require substantially more work (as measured by number of oracle queries and wall-clock execution time) than the equivalent attack developed through manual human optimization.To our knowledge, this work represents the first attempt to automate the discovery of novel adaptive chosen ciphertext attacks against symmetric format oracles. The function Maul Π ciph (C, S) → C takes as input a valid ciphertext and some opaque malleation instruction string S (henceforth "malleation string"), and produces a new, mauled ciphertext C . Given the result of a concrete experiment, we can then update our constraint formula using the new information, and continue the attack procedure until no further candidates can be eliminated.In the section that follows, we use M 0 , M 1 to represent the partition of messages induced by a malleation string. This assumption is compatible with common encryption schemes such as stream ciphers, but will not be valid for other schemes where malleation can produce key-dependent effects following decryption.We now describe the basic steps of our first attack algorithm.Step 0: Initialization. When the oracle produces a concrete result r ∈ {0, 1}, we compute an updated constraint formula G i such that for each input M, it holds that:G i (M) ← (G i−1 (M) ∧ F(Maul plain (M, S)) = r)If possible, we can now ask the solver to simplify the formula G i by eliminating redundant constraints in the underlying representation. If this occurs, we conclude the attack by applying the solver to the final constraint formula G i−1 to extract a human-readable description of the remaining candidate space (e.g., the bits of M * we are able to uniquely recover). This is fundamental to the constraint system we construct: our approach forces the solver to ensure that each malleation string S implicitly partitions the candidate message set into a pair (M 0 , M 1 ), such that malleation of messages in either subset by S will produce distinct outputs from the format checking function F. As a consequence of this, for any possible result from the real-world decryption oracle, the updated Figure 2: Left: illustration of a plaintext candidate space defined by G i−1 , highlighting the two subsets M 0 , M 1 induced by a specific malleation string S. Right: the candidate space defined by G i , in which many candidates have been eliminated following an oracle response b = 1. Indeed, merely counting the number of satisfying assignments to a constraint formula is known to be asymptotically harder than SAT [69,70], and practical counting algorithms solutions [14,20] tend to perform poorly when the combinatorial space is large and the satisfying assignments are sparsely distributed throughout the space, a condition that is likely in our setting. Subsequently, researchers in the model counting community showed that with some refinement, these approximate counting strategies can be used to approximate Max#SAT [35], although with an efficiency that is substantially below what we require for an efficient attack.To apply this technique efficiently to our attack, we develop a custom count-optimization procedure, and apply it to the attack strategy given in the previous section. 4 For a sufficiently high value of s, this approach effectively eliminates many "unprofitable" malleation string candidates and thus significantly improves the efficiency of the attack.The main weakness of this approach stems from the probabilistic nature of the approximation algorithm. In our approach, this falsenegative will cause the algorithm to reduce the size of s, potentially resulting in the selection of a less-profitable experiment S. Following Gomes et al. [37], we are able to substantially improve our certainty by conducting t trials within each query, accepting iff at least ( 1 2 + δ)t trials are satisfied, where δ is an adjustable tolerance parameter.Putting it all together. We now provide definitions for these terms.Definition 1 (Symmetric encryption) A symmetric encryption scheme Π is a tuple of algorithms (KeyGen, Encrypt, Decrypt) where KeyGen(1 λ ) generates a key, the probabilistic algorithm Encrypt K (M) encrypts a plaintext M under key K to produce a ciphertext C, and the deterministic algorithm Decrypt K (C) decrypts C to produce a plaintext or the distinguished error symbol ⊥. In a streamlined form, the problem can defined as follows: given a boolean 5 In principle our attacks can be extended to other theories, with some additional work that we describe later in this section. Specifically, we define our main attack algorithm in terms of a generic Max#SAT oracle that has the following interface:Max#SAT(φ, X,Y ) → X Our attacks assume a decryption oracle that, on input a ciphertext C, computes and returns F(Decrypt K (C)). This final output is determined by a helper subroutine SolveForPlaintext that uses the solver to find a unique solution for M * given a constraint formula, or else to produce a human-readable description of the resulting model. 7 Theorem 3.1 Given an exact Max#SAT oracle, Algorithm 1 maximizes in expectation the number of candidate plaintext messages ruled out at each iteration.A proof of Theorem 3.1 appears in the full version of this paper [15]. It is hypothetically possible to modify the algorithm, allowing it to reason over multiple oracle queries simultaneously (in fact, Phan et al. discuss such a generalization in their side channel work [58]). The MaxCount algorithm is based on repeated application of approximate counting and sampling algorithms [23,24,25], which can in turn be realized using a general SAT solver.While MaxCount is approximate, it can be tuned to provide a high degree of accuracy that is likely to be effective for our attacks. Our algorithm can be viewed as being a subset of the full MaxCount algorithm of Fremont et al.The FastSample algorithm operates over a constraint system φ(S, M 0 M 1 ), and returns a concrete value S that (heuristically) maximizes the number of solutions for the bitvectors M 0 , M 1 . Our algorithms employ an abstract subroutine AdjustSize that is responsible for updating the conjectured set size s in our optimization loop:(b continue , s , Z ) ← AdjustSize(b success , n, s, Z)The input bit b success indicates whether or not a solution was found for a conjectured size s, while n provides a known upper-bound. If AdjustSize is called with s = ⊥, then s is set to an initial set size to test, b continue = TRUE, and Z = Z.Finally, the subroutine ParityConstraint(n, l) constructs l randomized parity constraints of weight k over a bitvector b = b 1 b 2 . . . b n where k ≤ n denotes the number of bit indices included in a parity constraint (i.e. the parity constraints come from a family of functions H(b) = n i=1 b i · a i where a ∈ {0, 1} n and the hamming weight of a is k). It is designed as a user-supplied module in recognition of the fact that this portion will need to be customized for specific target systems and communication channels.As part of our prototype implementation, we provide working examples for each of these modules, as well as a test harness to evaluate attacks locally. To properly capture truncation off either end of a message, the malleation bitvector is extended by 2 ˙ log 2 (n) so the lowest order log 2 (n) bits of the malleation bitvector specify how many bits should be truncated off the low order bits of the plaintext and the next log 2 (n) bits specify what should be truncated from high order bits of the message. Since the block C i is given directly to a block cipher, any implementation must account for the the fact that modification of the block C i creates an unpredictable effect on the output P i , effectively randomizing it via the block cipher.For a solver to reason over such an effect on the plaintext output, we would need to include constraint clauses corresponding to encryption and decryption, i.e. boolean operations implementing symmetric schemes like AES. This includes the attack orchestrator, example format check implementations, the test harness, and our generic solver Python API which allows for modular swapping of backing SMT solvers, with implementations for Z3 and STP provided. It is possible that circuit synthesis algorithms designed to decrease circuit size (used for applications such as FPGA synthesis) or other logic optimizers could reduce circuit complexity, but we leave exploring this to future work.We additionally provide a translation tool from the output format of CMBC-GC [34] to Python (entirely comprised of circuit operations) to enable use of the Python front-end to Delphinium. For each experimental run, we collected statistics including the total number of decryption oracle queries performed; the wall-clock time required to construct each query; the number of plaintext bits recovered following each query; and the value of s used to construct a given malleation string. The total number of queries required to complete an attack provides the clearest signal of attack progress, and we use that as the primary metric for evaluation. Our experiments begin by sampling a random message M * from the space of all possible PKCS #7 padded messages, and setting G 0 ← F PKCS7 . As points of comparison, attacks with t = 3 resulted in a similar number of queries (modulo expected variability over different randomly sampled messages) but took roughly 2 to 3 times as long to complete, and attacks with t = 1 reached over 5000 queries having only discovered half of the target plaintext message.Bitwise Padding. This contrived scheme encodes the bit length of the padding P into the rightmost log 2 (n) bits of the plaintext string, and then places up to P padding bits directly to the left of this length field, with each padding bit set to 1. 13 A key feature of this format is that a valid ciphertext C * should not be vulnerable to a format oracle attack using a simple exclusive-OR malleation against this format, for the simple reason that the attacker can predict the output of the decryption oracle for every possible malleation of the ciphertext (due to the linearity of CRC), and thus no information will be learned from executing a query. To evaluate how truncation affects the ability of Delphinium to find attacks, we conducted a second attack using the function F crc8 , this time using an implementation of AES-CTR supporting truncation. This initial result serves both as validation of Delphinium and as creation of an avenue for future work, including the development of a model for a more complex but widespread ISA such as 32-bit ARM [3], perhaps exploiting additional signals such as segmentation faults or side channels in order to capture the capabilities of a sophisticated adversary.S2N with Exclusive-OR and Truncation. 15 The CBC malleation function accepts a structured malleation string S, which can be parsed as (S , l, r) where l, r are integers indicating the number of blocks to truncate from the message.To test this capability, we used the PKCS7 format function with a blocksize of B = 16 bytes, and a two-block CBC plaintext. Where a human attacker would focus on recovering the entire contents of one block before truncating and attacking the next block of plaintext, Delphinium instead truncates more or less as it pleases: in some queries it truncates the message and modifies the Initialization vector to attack the first block. One line of work [26], [58] focuses on generating public input values that lead to maximum leakage of secret input in Java programs where leakage is defined in terms of channel capacity and shannon entropy.