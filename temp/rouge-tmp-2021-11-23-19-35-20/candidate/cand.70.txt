Specifically, we exhibit attacks against the two central event loops in Google's Chrome web browser: that of the I/O thread of the host process, which multiplexes all network events and user actions, and that of the main thread of the renderer processes, which handles rendering and Javascript tasks. For instance, the HTML5 standard [2] mandates that user agents be implemented using EDP, similarly, Node.js, memcached, and Nginx, also rely on EDP.In EDP, each program has an event loop which consists of a FIFO queue and a control process (or thread) that listens to events. A key feature of EDP is that high-latency (or blocking) operations, such as database or network requests, can be handled asynchronously: They appear in the queue only as events signaling start and completion, whereas the blocking operation itself is handled elsewhere. Figure 1 illustrates such a scenario for a loop that is shared between an attacker A and a victim V.Attacks based on observable contention of shared resources have a long history [25] and an active present [8,27,37]; however, attacks against shared event loops have so far only been considered from a theoretical point of view [22]. Specifically, we target shared event loops in the two central processes of Google's Chrome web browser: The host process, whose event loop is shared between all requests for common resources, such as network and user interface; and the renderer processes, whose loops can be shared between Javascript tasks of different tabs or iframes.We build infrastructure that enables us to spy on both loops from a malicious HTML page. We demonstrate that shared event loops can be used to transmit information between cross-origin pages.Specifically, we implement a covert channel with a bandwidth of 200 bit/s through the renderer's main thread event loop, and another one working crossprocesses of 5 bit/s. They work under the assumption that event loops behave as FIFO queues; in reality, however, Chrome's event loop has a more sophisticated structure, relying on multiple queues and a policy-based scheduler. The Same-Origin Policy (SOP) is a central concept in the web security model: The policy restricts scripts on a web page to access data from another page if their origins differ. The host process runs several threads; the most relevant ones are:• the CrBrowserMain thread, which handles, e.g., user interaction events, and • the IOThread, which handles, e.g., IPC, network stack, and file system.The renderer processes are sandboxed processes responsible for parsing, rendering and Javascript execution. Each renderer runs several threads; the most relevant ones are:• the MainThread where resource parsing, style calculation, layout, painting and non-worker Javascript runs, • the IOChildThread, which handles IPC communication with the host process, and• the CompositorThread, which improves responsiveness during the rendering phase by allowing the user to scroll and see animations while the main thread is busy, thanks to a snapshot of the page's state.Each of the threads in the host and renderer processes maintains at least one event loop that is largely a FIFO queue. A site instance is a collection of pages from the same site that can obtain references to each other (e.g., one page opened the other in a new window using Javascript). • When the number of renderer processes exceeds a certain threshold, Chrome starts to reuse existing renderers instead of creating new ones.On (64-bit) OSX and Linux, the threshold for reusing renderers is calculated by splitting half of the physical RAM among the renderers, under the assumption that each consumes 60MB. In fact, even filesystem pages (loaded with file://) can co-reside with an arbitrary HTTP site. The corresponding messages of all renderers pass through the event loop of the host process' I/O thread.We illustrate this communication using two different examples: how user actions flow from the host to the corresponding renderer process, and conversely, how network requests flow from a renderer to the host process. The host main thread communicates the user event to the corresponding renderer by message passing between their I/O event loops, and the render acknowledges the receipt of this message. In this section we describe how to violate the SOP by eavesdropping on the event loops of Chrome's host and renderer processes. This causes loop to recursively post tasks, while keeping the render responsive since other events are still being processed.In order to minimize the noise introduced by the measurement script itself, the function save in line 2 uses a pre-allocated typed array (Float64Array) to store all the timing measurements. The Chrome sandbox ensures that all of the renderer's network and user interaction events pass through the host process' I/O event loop, see Section 2.4. Web workers that are shared between multiple pages are usually implemented in a dedicated OS process; this means they communicate via IPC and, therefore, can be used to spy on the I/O thread of the host process. That is, each trace captures around 5 seconds (200.000·25 µs = 5 s) of the loading process of a page in the sample set.The event-delay traces for the host process consist of 100.000 data items each. Wait 5 seconds and go to 1 with next URL The harvesting procedure for the host process differs only in that we use the rel="noopener" attribute in order to spawn a new renderer.We conducted measurements on the following three machines: We measure the timing on a Chrome instance with two tabs, one for the spy process and the other for the target page. It appears to be suitable for classifying eventdelay traces obtained from event loops because, for example, static pages with few external resources are more likely to produce long events at the beginning and stabilize soon, whereas pages with Javascript resources and animations are likely to lead to more irregular patterns and produce a larger number of long delays. The goal of DTW is to find a matching of points in X with points in Y , such that (1) every point is matched, (2) the relative ordering of points in each sequence is preserved (monotonicity), (3) and the cummulative distance (i.e. the sum of the values of f ) over all matching points is minimized. We rely on two kinds of speed-up techniques, one at the level of the data and the other at the level of the algorithm:At the level of data, we reduce the dimension of our data by applying a basic sampling algorithm: We split the raw trace into groups of measurements corresponding to time intervals of duration P, and replace each of those groups by one representative. Figure 5 shows two plots with the raw data taken from a renderer's main thread loop, and its corresponding time series obtained after sampling.At the algorithmic level, we use two sets of techniques for pruning the search for the optimal warping path, namely windowing and step patterns [15]. In particular, we rely on three well-known step patterns available in R. Intuitively, the symmetric1 pattern favors progress close to the diagonal, the symmetric2 pattern allows for arbitrary compressions and expansions, and the asymmetric forces each point in the reference to be used only once. For each of the traces in the testing set, we compute the set of k closest matches in the training set according to the time warping distance.We measure performance in terms of the k-match rate, which is the percentage of pages in the testing set for which the true match is within the set of k closest matches. The renderer's loop, however, is in general more robust to noise caused by other tabs in the browser.On the other hand, our attacks do not make any use of the pages' source code or of details of Chrome's scheduling system with priority queues, the GC with periodic scavenges, or the frame rendering tasks. push ( trace [ i ]) 9 } 10 }Listing 4: Pseudo-Javascript code to detect keystrokes in a trace of timestamps gathered by the code in Listing 1. We conclude by discussing two open challenges for recognizing user events, namely the detection of user events beyond keystrokes and the detection of events in the browser's host process.Detecting User Events beyond Keystrokes A continuous mouse movement results in a sequence of events, each of which carrying information about the coordinates of the cursor's trajectory. These events are issued with an inter-event delay of 8 ms, and the (empty) event listener operation blocks the loop for approx 0.1 ms. The particular frequency and duration of these events makes mouse movements (or similar actions, like scrolling) easy to spot with LoopScan, as seen in Figure 10. For instance, most mouse clicks only appear between two sequences of mouse movement events.We are currently investigating techniques that enable the automatic identification of such patterns in eventdelay streams. • the receiver R monitors the event loop of the renderer's main thread using the techniques described in Section 3.1; it decodes a 0 if the length of the observed tasks is below a threshold (related tô t), and a 1 otherwise. It decodes a 0 if the number of observed events during time interval t b is below a threshold, and 1 otherwise.The optimal values of N and t b highly depend on the machine. However, there are good reasons to expect similar side channels in other browsers, as they all follow the same event-driven paradigm and rely on similar architectures.For instance, recent Firefox versions with multiprocess support 5 also rely on a privileged browser process and multiple content processes that, unlike renderers in Chrome, act as a pool of threads for each different origin (each with its own message queue). Despite this difference, tests with LoopScan on Firefox version 55 show that congestion on both event loops is observable across origins and tabs.Specifically, we applied the monitoring technique for the renderers described in Section 3.1.2 on a microbenchmark with a set of 30 pages with 15 traces each. A special case are cross-site search attacks [14], which circumvent the same-origin policy to extract sensitive information, by measuring the time it takes for the browser to receive responses to search queries.Other classes of browser-based timing attacks exploit timing differences in rendering operations [24,33,5], or simply use the browser as an entry point for Javascript that exploits timing channels of underlying hardware, for example caches [26,16], DRAM buffers [17], or CPU contention [9].