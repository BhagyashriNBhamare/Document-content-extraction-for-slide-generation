However, generating good seeds for OS fuzzing is a hard problem as the behavior of each system call depends heavily on the OS kernel state created by the previously executed system calls. We designed and implemented MoonShine as an extension to Syzkaller, a state-of-the-art evolutionary fuzzer for the Linux kernel. Ideally, the synthetic seed programs for OS fuzzers should each contain a small number of system calls that exercise diverse functionality in the OS kernel.However, the behavior of each system call heavily depends on the shared kernel state created by the previous system calls, and any system call invoked by the seed programs without the correct kernel state will only trigger the shallow error handling code without reaching the core logic. For example, a seed program using the read system call must ensure that the input file descriptor is already in an "opened" state with read permissions using the open system call.Existing OS fuzzers [11,37] rely on thousands of hand-coded rules to capture these dependencies and use them to generate synthetic seed programs. The system call traces must be distilled while maintaining the correct dependencies between the system calls as mentioned earlier to ensure that their achieved code coverage does not go down significantly after distillation. For example, we find that randomly selecting system calls from existing program traces do not result in any coverage improvement over hand-coded rules (see Section 5. We also demonstrate that our distilled seeds help Syzkaller, a state-of-the-art system call fuzzer, to improve its coverage achieved for the Linux kernel by 13% over using manual rules for generating seeds. Finally, MoonShine's approach led to the discovery of 17 new vulnerabilities in Linux kernel, none of which were found by Syzkaller while using its manual rule-based seeds.In summary, we make the following contributions:• We introduce the concept of seed distillation, i.e., distilling traces from real world programs while maintaining both the system call dependencies and achieved code coverage as a means of improving OS fuzzers. Therefore, in this paper, we focus on distilling a small number of system calls from the traces while maintaining their dependencies and preserving most of the coverage achieved by the complete traces.Existing test case minimization strategies like afltmin [12] try to dynamically remove parts of an input while ensuring that coverage does not decrease. A dynamic test minimization strategy similar to that of afl-tmin might take up to 256 iterations for finding the minimal distilled sequence of calls.To avoid the issues described above, we use lightweight static analysis to identify the potential dependencies between system calls and apply a greedy strategy to distill the system calls (along with their dependencies) that contribute significantly towards the coverage achieved by the undistilled trace. A system call c i is defined to be implicitly dependent on c j if the execution of c j affects the execution of c i through some shared data struc-1: 0 = mlockall(MCL_FUTURE) 2: 3 = open("tmpfile.txt, O_RDWR, 0600) 3: 0x7b43f2000 = mmap(NULL, PAGE_SIZE,...,3,0) 4: 0x7b43f3000 = mmap(NULL, PAGE_SIZE,...,3,0) 5: 0x7b43f4000 = mmap(NULL, 2*PAGE_SIZE,...,3,0) 6: -EBUSY = msync(0x7b43f2000,...,MS_INVALIDATE) 7: 5 = write(1, "hello", 5) 8. When msync is called with the flag MS_INVALIDATE on an mmap'd page to invalidate all changes, msync fails with an -EBUSY error because the pages were locked in memory. When MoonShine applies the same procedure to the write it finds that it does not have explicit dependencies.Next, MoonShine uses static analysis on the kernel source code to identify any upstream calls that may be implicit dependencies of msync, mmap, and write. It observes that msync checks the value of the struct vma_struct->vma_flags field and mlockall writes to the same field. Without the mlockall, the vm_flag field would not be set, and msync would not return -EBUSY, as highlighted on line 5. Starting from a list of system calls S gathered from the program traces, MoonShine sorts the system calls by their coverage from largest to smallest (line 8). This grouping of distilled calls is added to our collection of seeds S (line 16) for OS fuzzing.In Algorithm 1, we demonstrate that MoonShine constructs seeds from the calls that contribute the most new coverage and captures those calls' implicit and explicit dependencies. The result nodes store the following information: 1) value returned, 2) return type (pointer, int, or semantic) and 3) the call in the trace which produced the result. MoonShine iterates over all the result nodes stored in the map for the specific type and value and adds one edge from the argument node to each result node in the graph.Once the argument dependency graph is constructed, MoonShine identifies explicit dependencies for a given call by enumerating the call's list of arguments and for each argument MoonShine visits the corresponding argument node in the dependency graph. Similarly, a global variable v is a write dependency of a system call c if c ever writes to v. As such, a call c a is an implicit dependency of c b if the intersection of c a 's write dependencies and c b 's read dependencies is nonempty.MoonShine is able to identify the collection of read and write dependencies by performing control flow analysis on the target kernel. If MoonShine encounters an assignment expression or unary assignment expression containing a global variable, it marks that global variable as a write dependency.Note that for a given trace this approach may overestimate or underestimate the number of implicit dependencies for a given call. Linux allows privileged user level programs to recover the coverage they achieved through the debugfs file /sys/kernel/fs/debug/kcov. We implement our tracer by adapting and extending Strace [13], a popular system call tracer. Furthermore, Strace can track calls across fork and exec which is useful because many programs are executed by using scripts and if we are unable to capture traces across these calls then it limits our ability to scalably capture traces. If process A calls clone and the result is B > 0 then we know A is a parent of B. Each edge also stores the position of the last call in A's trace before B was created, and this is important because some resources produced by A can be accessed by B, e.g. file descriptors or memory mappings. If that value is not in the cache then it traverses up the process tree and checks each process argument graph. MoonShine handles this by specifically tracking memory allocations made by mmap or SYSTEM V calls. MoonShine's implicit dependency tracker is build on Smatch [16], a static analysis framework for C. Smatch allows users to register functions which are triggered on matching events while Smatch walks the program's AST. MoonShine tracks read dependencies by registering a condition hook that checks if the conditional expression, or any of its subexpressions, contains a struct dereference. In particular, we assessed MoonShine's impact on the performance of Syzkaller, a state-of-the-art OS fuzzer targeting the Linux kernel, by distilling seeds constructed from traces of thousands of real programs.Our evaluation aims at answering the following research questions. (Section 5.3)• RQ3: How effectively can MoonShine track dependencies? We constructed seeds from 3220 programs from the following sources 1) Linux Testing Project (LTP) [7] Kselftests is a testing suite contained within the Linux source tree that tests specific subsystems in the kernel. The test suite includes regression tests against previously discovered bugs, and tests which exercise components of the C Standard Library such as processing ELF files, io, and networking calls. We chose Syzkaller as it is a stateof-the-art system call fuzzer, having found a large number of vulnerabilities, and is actively maintained. The second is a random distillation algorithm, called RANDOM, which tracks no dependencies at all. The RANDOM algorithm works by first selecting all system calls in a trace that contributed the most coverage increase, and assigning each to its own synthetic program. Of the 17 new vulnerabilities we discovered, 10 of them were only discovered when using seeds generated by Moonshine(I+E) and the average age of each was over 9 months. We have reported all vulnerabilities to the appropriate maintainers and 9 have already been fixed.Result 1: MoonShine found 17 new vulnerabilities that default Syzkaller cannot find out of which 10 vulnerabilities can only be found using implicit dependency distillation. This shows Syzkaller's coverage improves noticeably when it starts with either of MoonShine's generated seeds; however, when seeded with programs that have been distilled with both explicit and implicit dependencies, Syzkaller achieves 13% coverage improvement compared to the 9% when using explicit dependencies alone.Breakdown By System Call. The height of each bar represents the union of all unique basic blocks hit by that system call across all fuzzer programs (both seed and generated) over 24 hours of fuzzing. Similarly, the calls which produced the most new coverage under our distilled seeds were also file or networking related, for example fsync and sockpair. To evaluate how effectively MoonShine can track dependencies, we first measured the coverage achieved by our seed programs during trace generation. To understand the impact of tracking dependencies, we repeated this experiment using seeds generated by RANDOM. This suggests that capturing dependencies is crucial to improving Syzkaller's performance and that MoonShine is able to do so effectively.Result 3: MoonShine distills 3220 traces consisting of 2.9 million calls into seeds totaling 16,442 calls that preserve 86% of trace coverage. Prior to benchmarking our components, we preloaded all seed programs on a custom Google Cloud image running linux-4.13-rc7 compiled with kcov. However, this is to be expected because after each system call we must capture the coverage recorded by kcov and write it to a file. The time required to build the dependency graph and track implicit dependencies was only 30 seconds. When using seeds whose average call length is 730, Syzkaller performed less than 100 mutations in one hour, which is prohibitively slow.We now assess the impact that MoonShine's seeds have on Syzkaller's overall performance. On a matching action, the kernel calls inotify_handle_event() to generate an event for the user, which has the following structure: After allocating memory, inotify_handle_event() calls strcpy() to copy the filename. When Thread 1 resumes, dentry->d_name.name is different so the subsequent strcpy will overflow the struct if the size of the name has increased.After 4.5 hours of fuzzing with seeds distilled using Moonshine(I+E), Syzkaller reported a KASAN: slab out of bounds in strcpy crash in inotify_handle_event(). In line 7, the file is renamed to the longer name "long_name." This is because its manual rules are weighted to select calls that share semantic types. In this case, the rename, close and inotify_add_watch did not share semantic types, but MoonShine's distillation algorithm could detect that each of these calls contributed new coverage as during their control paths each triggered an inotify event. Figure 10 shows the relevant excerpt where the test iteratively changes the pipe size starting from the default size of 4096; however, during fuzzing, Syzkaller changed the size to 0. Default Syzkaller was unable to detect the bug because it is unable to understand that the command F_SETPIPE_SZ is meant to take After Thread 1 computes alloc_len, Thread 2 increases the length of filename by copying a larger string to dentry->d_name.name, causing the overflow in strcpy. Developing a tracking mechanism for such inter-thread/inter-process dependencies will be an interesting future work.False Positives from Static Analysis. Note that these false positives do not affect the coverage achieved by the distilled corpus but might make the traces slightly larger than they need to be.In our experiments, we observed that imprecise pointer analysis is a major source of false positives. Although our current prototype implementation is based on Linux and Syzkaller, there are a several ways we can extend MoonShine to benefit other kernel fuzzers. MoonShine's static implicit dependency analysis can also be easily extended to other open source OS kernels such as FreeBSD.For closed-source operating systems like Microsoft Windows, MoonShine can potentially support trace distillation of by leveraging recent works [29,33] using virtualization-based approaches to capturing system call traces and kernel code coverage albeit with higher performance overhead. Exploring this tradeoff is an interesting area for future research.Fuzzing Device Drivers. Seed selection was first explored in the context of file-format fuzzing, i.e., fuzzers for application code that parse well-structured input (pdfs, jpeg, png, etc.). By contrast, OS fuzzer distillation must work at the finer granularity of individual system calls within program traces and maintain the implicit/-explicit dependencies of the system calls while minimizing the number of calls as the program traces tend to be, on average, multiple orders of magnitude larger than the seed files used for fuzzing.Seed Generation and Generational Fuzzers. Like Syzkaller, all of these OS fuzzers can potentially benefit from the coverage improvements offered by the MoonShine framework.Finally, the class of evolutionary fuzzers that target semantic bugs (e.g., SlowFuzz [35], NEZHA [30], Frankencerts [17], and Mucerts [41]) may also similarly benefit from domain-specific seed distillation techniques that maximize coverage or path diversity.Implicit Dependencies. The inotify buffer overflow vulnerability was assigned CVE-2017-7533 and the fix was applied to the 4.12 kernel and backported to all stable kernels versions after 3.14. Moreover, the seeds generated by Moonshine improved the coverage of Syzkaller by over 13%, and resulted in the discovery of 17 new vulnerabilities in the Linux kernel that the default Syzkaller could not find by itself.