In particular, control-flow integrity (CFI), code-pointer integrity (CPI), and fine-grained code randomization are effective mitigation techniques against code-reuse attacks. For example, CFI's shadow stack, CPI's safe-region, and the random-ization secret must be protected from adversaries able to perform arbitrary read-write accesses. We extend Clang/LLVM to include our new instruction, and enhance CPI by protecting CPI's safe region using IMIX. Prominent examples include: W⊕X [44,48] which prevents data from being executed, and hence, code-injection attacks; Control Flow Integrity (CFI) [1] and Code-Pointer Integrity (CPI) [38] which protect code pointers to prevent code-reuse attacks; and Data Flow Integrity (DFI) [2,10] mitigating data-only attacks by restricting data access. For instance, CFI requires run-time checks and a shadow stack [1,9,18], which is updated every time a function is invoked or returns. Hence, to pre-vent the adversary from accessing the data some form of in-process memory isolation is needed, i.e., a mechanism ensuring access only by the defense code while denying access by the potentially vulnerable application code. Instrumentation-based memory isolation inserts run-time checks before every memory access in the untrusted code in order to prevent accesses to the protected region. However, it imposes a substantial performance overhead, for instance, code instrumented using Software Fault Isolation (SFI) incurs an overhead up to 43% [51]. Memory protection based on hardware extensions is another approach to achieve in-process isolation. For instance, Intel has recently announced Control-flow Enforcement Technology [33] and Memory Protection Keys [34] (already available on other architectures, e.g. memory domains on ARM32 [4]). To summarize, our main contributions are:• Hardware primitive to isolate data memory. Therefore, IMIX introduces a new memoryaccess permission to protect the isolated pages, which prevents regular load and store instructions from accessing this memory. Finally, we demonstrate how defenses against memorycorruption attacks benefit from using IMIX by porting code-pointer integrity (CPI) [38] to leverage IMIX to isolate its safe-region. Further, we compare our solution to Intel's Memory Protection Keys and Intel's Memory Protection Extensions [34] overhead for CPI. In contrast, during a control-flow hijacking attack, the attacker overwrites code pointers, which are later used as a target address of an indirect branch, to change control flow to execute injected code [3] or to conduct a code-reuse attack [50,52,54]. There exist different approaches to mitigate these attacks, however, they all have in common that they are part of the same execution context as the vulnerable application, and often make a tradeoff between practicality and security. As we argue in Section 8, IMIX is most likely to be adapted for Intel-based x86 CPUs, hence, we focus in this section on memory protection features that are implemented or will be implemented for Intel-based x86 CPUs. Segmentation and paging build a layer of indirection for memory accesses that can be configured by the operating system, and the CPU enforces access control while resolving the indirection. The paging permission system enables the operating system to assign memory to either itself or to the user mode.To isolate different processes from each other, the operating system ensures that each process uses its own page table. Recently introduced or proposed features that enable memory isolation on x86 are Extended Page Tables (EPT), Memory Protection Extensions (MPX), Software Guard Extensions (SGX), Memory Protection Keys (MPK) and Control-flow Enforcement Technology (CET). SGX allows to create enclaves within a process that are completely isolated from the rest of the system at the cost of high overhead when switching the execution to the code within an enclave. Intel's hardware support for CFI, CET, provides similar memory isolation the shadow stack as IMIX for security critical data in general. However, this approach comes with a significant performance overhead due to the additional instructions.To summarize, none of the above listed memory protection features provides mitigation-agnostic security and performance benefits at the same time. Throughout our work, we use the following standard adversary model and assumptions, which are consistent with prior work in this field of research [21,38,53,54]. This is enforced by hardening the target application with the W⊕X memory policy [44,48]. Traditionally, defense developers enforce the integrity of the (static) code using W⊕X or execute-only memory, while the integrity of the data relies on some form in-process memory isolation. However, existing memory isolation techniques, namely instrumentation and data hiding, force the defense developers to choose between high performance overheads and compromised security. IMIX 3 provides an efficient, secure, hardware-enforced in-process memory isolation mechanism. The memory access logic is modified so that it will generate a fault if 1) an instruction other than smov is used to access a page protected by IMIX, or if 2) an smov instruction is used to access a normal page. If we allowed smov to access normal memory, attacks on metadata would be possible, e.g., the attacker could overwrite a pointer to CPI's metadata with an address pointing to an attacker-controlled buffer in normal memory. First, IMIX provides two high-level primitives: one for allocating protected memory and one for accessing it. For application developers, IMIX provides source code annotations: variables with our annotation will be allocated in protected memory, and all accesses will be through the smov instruction. Developers can build programs with IMIX, using our extended Clang compiler 1 , which supports annotations for variables that should be allocated in protected memory and new IR instructions to access the protected memory. The CPU already has a data structure to store information about every page, which is called a Page access regular pages, while smov can only access isolated pages. Thus, we used a hardware simulator to show the feasibility of our design.Next, we describe how we extend x86-64 with the help of Intel's SAE, and then discuss the necessary modification to real hardware.Simulated Hardware. SAE supports emulating an x86 system running a full operating system with its processes, while allowing various architectural instrumentations, including the CPU, the memory, and related hardware such as the memory management unit (MMU). If either a mov or smov instruction that accesses memory is found, we register an instruction replacement callback. To identify protected memory, we look up the related PTE by combining the virtual address and the base address of the page table hierarchy linked from the CR3 register. In the remaining cases, namely smov attempting to access regular memory, and regular instructions attempting to access isolated pages, we raise a fault.Real Hardware. Modern MMUs are divided into three major components: logic for memory protection and segmentation, the translation lookaside buffer (TLB) which caches virtual to physical address mappings, and page-walk logic in case of a cache miss [49]. Processes can request the kernel to mark a page as an isolated page by using the existing mprotect system call, which is already used to manage the existing memory access permissions: PROT_READ, PROT_WRITE, and PROT_EXEC. To provide C/C ++ support for IMIX, we modify the LLVM compiler framework [40]. Hence, we created two corresponding IMIX instructions: sload and sstore, which defense developers can use as a drop-in replacement for their regular counterparts.LLVM IR instructions are implemented as C ++ classes and therefore supports inheritance. We implemented our IR instructions to as subclasses of their regular counterparts in order to reuse the existing translation functionality from LLVM IR to machine code, called lowering in LLVM parlance.To allocate memory in the isolated pages, we implemented an LLVM function that can be called from an optimization pass, which allocates memory at page granularity using malloc and immediately sets the IMIX permission using mprotect. A reference to the allocated memory is returned so that IMIX IR instructions can access the protected memory.Attribute Support. To give developers an efficient way to protect sensitive data like cryptographic keys at source code level, we added a IMIX attribute which can be used to annotate C/C ++ variables which should be allocated in isolated pages. CPI uses a safe region in memory to guarantee integrity of code pointers and prevent code-reuse attacks.All code pointers, pointers to pointers, and so on, are moved to the safe region, so that memory corruption vulnerabilities cannot be exploited to overwrite them. Return addresses are protected using a shadow stack. In order to access the safe region, CPI provides accessors that use mov instructions with a %gs segment override, which access the safe region using %gs as the base address and an offset. Specifically, we changed the safe region functions to access memory directly via smov instructions instead of using register-offset addressing. The main objective of IMIX is to provide in-process memory isolation for data in order to make it accessible only by trusted code. As IMIX is a hardware extension, an attacker cannot directly bypass it, i.e., use a regular memory access instruction to access the isolated memory. In practice, however, sanitizing inputs correctly requires limited complexity, e.g., in the case of a shadow stack [18] or CPI's safe region [38]. There are two ways for an attacker to re-configure IMIX: 1) leveraging the interface of the operating system to change memory permissions, or 2) manipulating page table entries.For the first case, we assume that the attacker is able to manipulate the arguments of a benign system call to change memory permissions (mprotect() on Linux). To evaluate the performance of our approach, we ported the original implementation of CPI by Kuznetsov et al. [38] to leverage IMIX to isolate the safe region and applied it to the SPEC CPU2006 benchmark suite. We performed our evaluation using Ubuntu 14.04 LTS with Linux Kernel version 3.19.0 on an Intel Core i7-6700 CPU in 64-bit mode running at 3.40 GHz with dynamic voltage and frequency scaling disabled, and 32 GB RAM.Baseline. As hardware emulation turned out to be too slow for executing the SPEC CPU2006 benchmarking tests, we instead evaluated IMIX by replacing smov instructions with mov instructions that access memory directly. We argue that this reflects the actual costs for smov instructions, because the IMIX permission check is part of the paging permission check.During our performance evaluation we made the interesting observation that our IMIX instrumentation comes with a higher overhead than the baseline. Unsurprisingly, by adjusting our IMIX-based CPI instrumentation to use segment register-based addressing we achieve 0% overhead over CPI. We further compare IMIX to other memory protection approaches, namely Intel MPK and Intel MPX, in Section 9. However, we argue that this does not apply to IMIX for two reasons: 1) IMIX enables strong and efficient in-process isolation of data which is an inevitable requirement of many memory-corruption defenses. With IMIX we provide a strong and efficient hardware primitive to enforce the protection of this data which is mitigation-agnostic. Contrary to IMIX, CET's hardware extension is tailored to isolate the shadow stack of a CFI implementation [45]. As expected, generalizing CET's shadow stack to support arbitrary memory accesses still allows implementation of an isolated shadow stack [18]. The instruction prefix determines whether a memory-access instruction uses a 32-bit (default case) or 64-bit address. By ensuring that untrusted code can only use 32-bit addresses to access memory, protected data can be stored in memory that can only be addressed with 64-bit addresses. On the surface, re-enforcing legacy segmentation seems to be an attractive solution, however, IMIX is easier to implement from a hardware perspective: segmentation requires arithmetic operations, IMIX only one check. As segmentation registers are rarely used by regular applications any more, they are often used to store base addresses for memory hiding [6,38,41]. to IMIX as both come with disadvantages that render them impractical.The main goal of MPX [31] is to provide hardwareassisted bounds checking to avoid buffer overflows. MPX can be retrofitted to enforce memory isolation by defining one bound that divides the address space in two segments: a regular, and a protected region. Protecting CPI's safe region with MPX using the opensource implementation by Koning et al. [37] results in a total performance overhead of 36.86% with a maximum of 203.71% for mcf, which cannot be considered practical, especially since we were not able to execute the benchmarks that show the highest overheads across all techniques. Intel's MPK is a feature to be available in upcoming Intel x86-64 processors [27,34], already available on other architectures like IA-64 [30], and ARM32 (called memory domains) [4]. Reducing these to two possible domains allows IMIX to be leveraged by mitigations like CPI or CFI that rely on frequent domain switches. In contrast, MPK is useful if the application changes domains infrequently, i.e., for temporal memory isolation, or to isolate different threads. As a consequence, many mitigations rely on information hiding via segmentation, on expensive software-based isolation, or on retrofitting memory-isolation features that require compromises in the design of the mitigation.With IMIX we design a mitigation-agnostic in-process memory-isolation feature for data that targets the x86 architecture.