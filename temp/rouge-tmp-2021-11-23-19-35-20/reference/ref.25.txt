In this work, we show that previous literature might have left an overly pessimistic conclusion of ARM's security as we unveil AutoLock: an internal performance enhancement found in inclusive cache levels of ARM processors that adversely affects Evict+Time, Prime+Probe, and Evict+Reload attacks. Our findings highlight the intricacies of cache attacks on ARM and suggest that a fair and comprehensive vulnerability assessment requires an in-depth understanding of ARM's cache architectures and rigorous testing across a broad range of ARM based devices. The majority of attacks have been demonstrated on classic desktop and server hardware [25,30,42,51], and with Intel's market share for server processors being over 98% [31], their platforms have been targeted most frequently.With mobile usage skyrocketing, the feasibility of cache attacks on smartphone and IoT processors -which are predominantly ARM-based -has become a relevant issue. Attacks that rely on the existence of a cache flush instruction, i.e., Flush+Reload [51] and Flush+Flush [23], work efficiently across a broad range of x86 processors, but have limited applicability on ARM devices. This leaves a significant number of ARM processors without a cache flush instruction.For all processors with a disabled flush instruction or an earlier architecture version, e.g., ARMv7, only eviction based cache attacks can be deployed. Yet, our findings show that an internal performance enhancement in inclusive lastlevel caches, dubbed AutoLock, can still impede eviction based cache attacks. This inhibits cross-core LLC evictions, a key requirement for practical Evict+Time, Prime+Probe, and Evict+Reload attacks on multi-core systems, and further limits the number of ARM based attack targets in practice.In literature, Lipp et al. [37], Zhang et al. [54], and Zhang et al. [56] confirmed the general feasibility of flush and eviction based cache attacks from unprivileged code on ARM processors. Given the lack of flush instructions on a large selection of ARM devices and the deployment of non-inclusive LLCs or inclusive LLCs implementing AutoLock, the authors might have left an overly pessimistic conclusion of ARM's security against cache attacks. As AutoLock is likely implemented on a larger number of ARM processors, we discuss its general implications and how our results relate to previous literature.Despite its adverse effect on eviction based cache attacks, the impact of AutoLock can be reduced. We discuss generic circumvention strategies and execute the attack by Irazoqui et al. [29] in a practical cross-core Evict+Reload scenario on a Cortex-A15 implementing AutoLock. This is because in the context of cross-core LLC evictions, inclusive lastlevel caches with AutoLock behave identically to noninclusive ones. In summary, our main contributions are:• the disclosure and description of AutoLock, an undocumented and previously unknown cache implementation feature with adverse impact on practical eviction based cache attacks on ARM devices,• a comprehensive test suite to determine the existence of AutoLock on actual devices, as its presence is not documented publicly,• a discussion of AutoLock's implications and its relation to previous literature demonstrating cache attacks on ARM, and• a set of strategies to circumvent AutoLock together with a practical demonstration of a crosscore Evict+Reload attack on a multi-core SoC implementing AutoLock.The rest of this paper is organized as follows. The number of lines or ways per cache set is called the associativity of the cache level. If a cache level x is inclusive with respect to a higher level y, then all valid cache lines contained in y must also be contained in x. This is an implicit consequence of the inclusiveness property that has been successfully exploited in crosscore cache attacks that target inclusive LLCs [26,27,39]. In a patent publication by Williamson and ARM Ltd., the authors propose a mechanism that protects a given line in an inclusive cache level from eviction, if any higher cache level holds a copy of the line [50]. We refer to this transparent protection of cache lines in the LLC as Automatic Lockdown or AutoLock.The impact of AutoLock during eviction is illustrated in Figure 1. For simplicity, the illustration is based on a two-level cache hierarchy: core-private L1 caches and a shared inclusive last-level cache (L2) with one inclusion bit per cache line. This line is then evicted to allow the allocation of a new one.If the number of ways in the inclusive lower cache level, W l , is higher than the sum of ways in all higher cache levels, i.e., W h,sum = ∑ N i=1 W h,i , it can be guaranteed that at least one line is always selectable for eviction. In this case, the patent proposes to fall back to the previous behavior, i.e., evict all copies of a line from higher level caches. While not impossible per se, this case is not covered by the patent authors.If an inclusive LLC with AutoLock is targeted in a cache attack, the adversary is not able to evict a target's data or instructions from the LLC, as long as they are contained in the target's core-private cache. In both cases, AutoLock and non-inclusive LLC, the attacks do not work cross-core because the attacking core cannot influence the target core's private cache. AutoLock is neither mentioned in ARM's architecture reference manuals [7,10] nor in the technical reference manuals of the Cortex-A cores considered in this work [5,6,8,9]. The presence of AutoLock, however, is crucial to assess the risk of cache attacks, in particular those that rely on cross-core evictions in the LLC. If the cache line remains in the LLC and core-private cache after the cross-core eviction, the test concludes that AutoLock is implemented. We ensure a working eviction by verifying it in the same-core scenario before executing the AutoLock tests. If neither of those are available, cross-core evictions still allow to draw a conclusion, but only for a certain outcome. In order to evict a cache line from the LLC, we implement the method described by Gruss et al. [22] and Lipp et al. [37]. The strategy proposed by Gruss et al. [22] is shown in Algorithm 1. Input: C ... list of set-congruent addresses1 for i = 0..N-1 do /* # of windows */ 2 for j = 0..A-1 do /* # reps/window */ 3 for k = 0..D-1 do /* # addrs/window */ 4 access(C[i + k]); 5 end 6 end 7 endThe idea is to always access a subset of the addresses in C for a number of repetitions, then replace one address in the subset with a new one, and repeat. Lipp et al. [37] demonstrate that sliding window eviction can successfully be applied to ARM processors.The parameters N-A-D must be determined once for each processor. This is done by creating a list of setcongruent addresses C and exhaustively iterating over multiple choices of N, A, and D. By continuously checking the success of the eviction, the strategy with the least number of memory accesses that still provides reliable eviction can be determined. Alternatively, huge pages reveal sufficient bits of the physical address to derive the corresponding cache set [27]. If access to physical address information is entirely prohibited, timing measurements can still be used to find set-congruent addresses [41]. When determining N-A-D on devices that might implement AutoLock, all memory accesses to T and all evictions of it must be performed on a single core. In the dual-core setting, core 0 is accessing the target address T and core 1 is trying to evict it by using the eviction set C and the processor specific eviction parameters N-A-D. As currently nothing indicates that AutoLock can be en-or disabled from software, its presence on a processor has to be determined only once. Through this visual inspection, it is possible to determine with very high confidence whether or not T remains in the cache after the eviction strategy is run. The PMU of ARMv7-and ARMv8-compliant processors can be configured to count the number of accesses (hit or miss) to the last-level cache. This is done by reading the L2 access counter for a reload with no previous run of the eviction strategy, which guarantees a fetch from core-private cache. This test requires access to the PMU, which on ARM is typically limited to privileged code, unless otherwise configured. On Linux, for instance, the perf subsystem of the kernel provides this access via the perf_event_open system call [36]. Commonly used timing sources include hardware based timestamp counters (PMCCNTR for ARM), the perf subsystem of Linux [36], the POSIX clock_gettime() function [45], and a custom thread based timer. Further discussions about timing sources can be found in the work by Lipp et al. [37] and Zhang et al. [56]. The Samsung Exynos 5422 and the ARM Juno r0 SoCs feature two processors with multiple cores each. The LLCs on the Cortex-A7 and A53 are inclusive to the L1 instruction caches, while the LLCs on the Cortex-A15, A57, and the Krait 450 are inclusive to the L1 data caches. Public documentation of the Krait 450 is scarce and information about cache inclusiveness could only be obtained for earlier Krait generations [34]. For each processor, we verify that the eviction parameters listed in Table 1 can successfully evict cache lines in a same-core setting. We then test for AutoLock in the cross-core case with the experiments proposed in the previous section. A hardware limitation of the Cortex-A53 in the ARM Juno r0 SoC prevents the visual inspection of its L2 cache. All trials indicate each processor's inclusive cache implements AutoLock. We then execute a target instruction on core 0 and run a 25-2-6 eviction strategy on core 1. This is necessary because the ARM architecture allows memory accesses to be reordered to optimize performance.As a result, we observe that reloading the target in- struction after executing the eviction algorithm causes no additional L2 access. To determine the presence of AutoLock on the Cortex-A7 and the Krait 450, we execute the cache-timing experiment described in Algorithm 4. When the eviction step is skipped, the target address remains in the cache, and thus the access time is significantly lower, as pictured. For both the Krait 450 and the A57, we performed 50,000 measurements to ensure that clear trends can be seen.Corresponding experiments on the Cortex-A7 indicate that its instruction cache side implements AutoLock. All ARM Cortex-A processors on our test devices exhibit AutoLock in their inclusive last-level caches, whereas no evidence of AutoLock can be found on the Qualcomm Krait 450. Depending on the associativity of the core-private cache levels the LLC is inclusive to, a significant fraction of cache lines can be locked in an LLC set. The field of cache attacks finds its origins in the early anticipation of varying memory access times compromising the security of cryptographic software [32,35]. As the targeted implementations performed key-dependent memory accesses that resulted in key-dependent numbers of cache hits and misses, the execution time contained sufficient information to recover (parts of) the se- [3], and Bogdanov et al. [14]. Instead, attacks rely on background activity on the target system, limited sizes of cache levels, self-evictions, and the fact that unused data will typically be removed from cache after some time. While a large number of attack papers have been published, only a few basic attack strategies exist that can be categorized depending on how this removal is implemented.Flush-based Attacks. The Flush+Reload technique was concurrently used by Benger et al. [12] to recover ECC secret keys, by Zhang et al.[58] to launch cross-tenant attacks on PaaS clouds, and by Gruss et al. [24] to implement template attacks. We currently believe that none of the flush based attacks are affected by AutoLock, because cache maintenance operations such as cache flushing seem to override AutoLock.Eviction-based Attacks. As a cross-over to the flush based attacks, Gruss et al. [24] proposed the Evict+Reload attack, which removes cache contents through evictions but other than that remains identical to the Flush+Reload technique. Irazoqui et al. [28] demonstrated the applicability of cache attacks across CPUs through the cache coherency protocol, which allows the execution of Flush+Reload style attacks by forwarding cache flush and data request messages between two CPU clusters. Yarom et al. [52] showed that cache bank contentions introduce timing variations of accesses to different words on a single cache line. Gruss et al. [21] introduced prefetching instructions as a way to load memory into cache without explicitly accessing it. In literature, this strategy has for instance been applied by Kim et al. [33] and Zhou et al. [59]. As this is not a trivial task, several tools have been proposed that help to detect cache leaks and fix vulnerable code [4,18,53]. For these system-and application-level countermeasures, we do not expect any particular impact from AutoLock.Most of the previous cache attack literature is dedicated to the x86 architecture. Lipp et al. [37] were the first to demonstrate the feasibility of Prime+Probe, Flush+Reload, Evict+Reload, and Flush+Flush attacks on ARM devices. Yet, Lipp et al. successfully demonstrate a covert channel based on cross-core evictions on this chip. While Lipp et al. experiment on a Qualcomm Snapdragon 410, we perform our tests on an ARM built Juno SoC. Since their work was focused solely on Flush+Reload, one of the two cache attacks unaffected by AutoLock, we assume they never encountered it during their experiments. As a prerequisite for their final target device selection, the authors experimentally determined the inclusiveness property of the last-level caches on all devices. In other previous work, Zhang et al.[54] implemented a Prime+Probe attack in an unprivileged Android application on an ARM Cortex-A8. As AutoLock does not affect same-core attacks, the experiments of the authors would not have been affected, even if the Cortex-A8 implemented AutoLock. Given the nature of AutoLock, all same-core attacks remain possible, as the adversary can evict target memory from all core-private cache levels. In contrast to these attacks, all techniques that rely on evicting a cache line, namely Evict+Time, Prime+Probe, and Evict+Reload, are impaired by AutoLock in cross-core scenarios. Based on our experiments, we currently assume that AutoLock is primarily implemented on Cortex-A cores designed by ARM itself. While newer cores such as the Cortex-A72 and A73 might be affected as well, it remains unclear whether this also holds for the ARM-compliant cores, such as the Kryo (the successor of the Krait), the Mongoose (M1, M2), as well as the cores integrated into the Apple SoCs.If a device implements AutoLock, adversaries must find and employ circumvention strategies to leverage the full potential of eviction based cache attacks. In the upcoming section, we discuss circumvention strategies and demonstrate that the attack proposed by Irazoqui et al. [29] can still be mounted in a cross-core Evict+Reload scenario with an inclusive LLC implementing AutoLock. Despite the restrictions that Automatic Lockdown poses to eviction based cache attacks, its effects can be alleviated with the following strategies:• Pre-select Target SoCs: Our findings suggest that AutoLock is present on Cortex-A cores designed by ARM itself, while it is not implemented by ARM compliant cores, such as Qualcomm's Krait 450. • Trigger Self-evictions: When AutoLock is active, a cache line can only be evicted from the inclusive LLC if no higher cache level contains a copy of it. If the attack allows, an adversary can take advantage of the low associativity and simply prolong the waiting time between reloads such that the target line will automatically be evicted from core-private caches by other system activity scheduled on the respective core. The attack proposed by Irazoqui et al. [29] observes the first line per table to recover an entire AES key. In the upcoming section, we pick up this idea and demonstrate how the attack can be extended to exploit multiple cache lines to successfully circumvent AutoLock.Note that all of the presented strategies increase the chances of successful attacks not only on inclusive caches implementing AutoLock, but also on noninclusive caches. For 4-byte entries and a 64-byte cache line, t = 16. Given an AES-128 implementation that uses four 1 kiB T-tables and performs 160 lookups per encryption, which evenly spread over the four tables, n = 40. (2)Improvements The original attack targets one cache line per table. This can happen on a processor that implements AutoLock or noninclusive caches. Irazoqui et al. [29] state that the attack works equally well with all cache lines carrying lookup table entries. As discussed in the previous section, it is likely in practice that some of them are automatically evicted from core-private caches, hence re-enabling the attack despite AutoLock. After all scores have been added for all hypotheses, the recovery phase proceeds as proposed.We implement the original attack and all improvements using Evict+Reload on a multi-core ARM Cortex-A15 processor featuring a data-inclusive LLC with AutoLock. This illustrates the impact of AutoLock, which only affects cross-core attacks. Paired with a limited understanding of how ARM's cache architectures function internally, this makes assessing the practical threat of flush and eviction based cache attacks on ARM a challenging task. We therefore believe that a fair and comprehensive assessment of ARM's security against cache attacks requires a better understanding of the implemented cache architectures as well as rigorous testing across a broad range of ARM and thereto compliant processors.