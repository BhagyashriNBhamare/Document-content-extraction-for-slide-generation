Passwords and access control remain the popular choice for protecting sensitive data stored online, despite their well-known vulnerability to brute-force attacks. More importantly , both the crypto server and the service provider can rotate their secret keys, a proactive security mechanism mandated by the Payment Card Industry Data Security Standard (PCI DSS). Nevertheless, some information is required to be stored in an encrypted form, such as credit card information, as mandated by the payment card industry data security standard (PCI DSS) [19]. For example, an attacker who gets access to a password database can first launch an offline dictionary attack to obtain user passwords, then logs in as these users and "legitimately" requests the online service provider to perform decryption. Later, when this end user logs in with a candidate password, the server cooperates with the rate-limiter again to check if the candidate password is identical to the one encrypted in the corresponding record.Due to the cooperation requirement above, PH essentially performs a double encryption of the passwords. Second, the rate-limiter can track the number of unsuccessful login attempts of each end user, and rate-limit password validation requests, and hence online attacks, on a per-user basis. Lastly, if either the server or the rate-limiter is compromised, or if the secret keys are in use for quite some time, the parties can jointly execute a key-rotation mechanism to refresh their secret keys. Furthermore, the key-rotation is seamless to the end users and requires arguably minimal help from the rate-limiter. To solve this problem, we propose passwordhardened encryption (PHE) services, which is an extension of PH services that goes beyond authentication and uses the passwords to secure general data in addition to the passwords. When an end user registers, the server and the rate-limiter jointly create a record which not only encrypts the user password but also a secret message. This makes PHE an appealing approach, for example, to conform to PCI DSS which requires credit card information to be encrypted by a mechanism supporting key rotation.With per-user secret messages, each user can now enjoy the benefit of encrypting their respective data using an independent key. More importantly, if the server decides to rotate not only its own secret key but also some of the (data-)keys, the rotation is not as costly as re-encrypting the whole database.In a nutshell, PHE is a one-package data-security solution for online service providers who employ passwordbased authentication and store sensitive user data. Our extensive experimental evaluation demonstrated that our PHE scheme is highly efficient (∼ 10ms per request) and scales well to highthroughput scenarios. With this observation, we design an extremely simple PHE scheme (which also gives a much simpler PH scheme) as follows.To encrypt the message M under the password pw, the server and the rate-limiter sample random nonces n S and n R respectively, and jointly compute(H x R,0 H y S,0 , H x R,1 H y S,1 M y )where H R,b = H R (n R , b) and H S,b = H S (n S , pw, b) are (multiplicative) group elements output by hash functions H R and H S , b ∈ {0, 1}, and x and y are the secret keys of the rate-limiter and the server respectively.To decrypt with the password pw, the server computes H y S,0 to recover the hash value H x R,0 , and sends the latter to the rate-limiter. We observe that in the existing definition of PH [16], in the case where the rate-limiter rejects in the validation phase, it is indistinguishable to the server whether the rate-limiter refuses to entertain the validation request (even when the password is correct) or the password indeed does not match the record. To address this issue, we define the (strong) soundness property, which requires the rate-limiter to explain not only the reasons for acceptance, but also for rejections.In any real-world instantiation with strong soundness, compromised/cheating rate-limiters which (selectively) prevent legitimate logins (using correct passwords) can be detected. They also proposed a scheme PHOENIX which is secure under the new definition.PHE services extend the security of PH as defined by Lai et al. [16] to messages, such that encrypted messages can only be decrypted with the correct password and the help of the external rate-limiter. The main goal of password-protected secret sharing (PPSS) or password-authenticated key-exchange (PAKE) is also to protect a secret message (of an end user, with the help of possibly more than one server) in such a way that it can only be recovered using the correct password. While it seems that PHE can be constructed from PPSS by having the server hold one of the shares and the rate-limiter hold the other, the resulting scheme lacks important features of PHE.Per-user rate-limiting. While global rate-limiting is trivial, note that PHE schemes additionally allow (and require) the rate-limiter to count the number of unsuccessful login attempts of each user, and refuse to provide decryption services to the server for a certain user (indirectly) if the latter has attempted too many unsuccessful logins. HCR does not support key rotation either.Password-based key-derivation or encryption [14,15,17] encrypts messages directly using keys derived from passwords. We formalize password-hardened encryption, an extension of password-hardening, for encrypting messages which can only be decrypted by the user password, the secret keys of both the server and the rate-limiter. We denote the empty string by ε.A password-hardened encryption (PHE) scheme consists of the efficient algorithms and protocols (Setup, KGen S , KGen R , Encrypt, Decrypt, Rotate, Update), which we define as follows:Setup and Key Generation. When an end user registers for an account with password pw ∈ P and a secret message M ∈ M (e.g., an AES key, which can also be chosen by the server on behalf of the end user), the server engages in the (labeled) encryption protocol with the rate-limiter R to compute a record T with label :(( , T ), ε) ← Encrypt S(sk S , pw, M), R(sk R ). The first condition is an exception which only appears in the definition of forward-security, while the second holds in all other situations, including normal executions in realworld applications. When an end user logs in to the service provided by the server with a candidate password pw ∈ P, the server retrieves the corresponding encryption record T and label for the user, and engages in the (labeled) decryption protocol with the rate-limiter:(( f , M), ε) ← Decrypt S(sk S , pw, T ), R(sk R ). The flag f is either ⊥ to indicate failure (the rate-limiter aborts), 0 if the record or the password is invalid, or 1 for a successful login. The rate-limiter outputs nothing, i.e., the empty string ε.Key Rotation and Record Update. On input a label , an update token τ, and a record T (which encrypts some message M with label ), the update algorithm outputs a new record T (also encrypting M with label ). Moreover, if a record passes decryption with respect to some secret keys, then the updated record also passes decryption with respect to the rotated keys. In each round, the attacker can compromise either the rate-limiter or the server and use whatever he learned in the next roundHid b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk R , sk R ) ←$ KGen R (pp) 2 : O := {P·, R(sk R , . . .) :3 : P ∈ {Encrypt ε , Decrypt , Rotate : ∈ {0, 1} * }} 4 : / / All rate-limiter outputs are given to adversary, 5 : / / except for sk R from Rotate·, R(skR).6 : / / Rotate·, R(skR updates skR embedded in all oracles to sk R . Practically this implies using a TLS connection between rate-limiter and server, and updating long-term keys and certificates during key-rotation.7 : (sk * S , χ, M * 0 , M * 1 , st) ←$ A O 1 (pp, pk R ) 8 : pw * ←$ χ 9 : (( * , T * ), ε) ←$ Encrypt ε S(sk * S , pw * , M * b ), R(sk R ) 10 : b ←$ A O 2 (st, * , T * ) 11 : return bWe formalize the security properties of PHE, extending those from password-hardening [16]. Eventually, A 1 outputs a server secret key sk * S , a password distribution χ, two messages M * 0 and M * 1 , and a state st. The challenger picks a random password pw * from the distribution χ, and encapsulates M * b into a record T * with label * honestly using sk * S and pw * by locally emulating the encryption protocol. Note that the communication transcript of the emulation is not given to A. Intuitively this is justified because the server was honest while the record was created and we assume a secure channel.Finally, A 2 gets * and T * , and must guess whether M * 0 or M * 1 is encrypted by outputting a guess b , which is also output by the experiment.Definition 1 (Message Hiding) A PHE scheme PHE is message hiding if, for any PPT adversary A = (A 1 , A 2 ), there exists a negligible function negl (λ ) such thatPr Hid 0 PHE,A (1 λ ) = 1 − Pr Hid 1 PHE,A (1 λ ) = 1 ≤ 2 Q ∑ i=1 p i + negl (λ ) ,where the probability related to an experiment outcome is taken over the random coins of the experiment, p i is the probability of the i-th most probable event in the distribution χ specified by the adversary, and Q is the number of times that A 2 queries Decrypt ·, R(sk R ) with input label = (·, * R ) 4 . Obl b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk S , sk S ) ←$ KGen S (pp) 2 : O := {PS(sk S , . . .), · : 3 : P ∈ {Encrypt ε , Decrypt , Rotate : ∈ {0, 1} * }} 4 : (pw * 0 , M * 0 , pw * 1 , M * 1 , st) ←$ A O 1 (pp, pk S ) 5 : // All server outputs are given to A, except for sk S from RotateS(skS ), ·.6 : / / RotateS(skS ), · updates skS embedded in all oracles to sk S . Figure 3: Partial Obliviousness Experiment is called the "challenge password" and "challenge message" respectively.7 : (( * , T * ), st) ←$ Encrypt ε S(sk S , pw * b , M * b ), A 2 (st) 8 : / / The server output ( f , m) from Decrypt S(skS , . . . , ), · is withheld from A 9 : / / if (, pw) = (( * S , ·), pw * 0 ) or (( * S , ·), pw * 1 ). This property arguably suffices for practical applications.Soundness PHE,A (1 λ ) 1 : (pk R , sk S , pw, pw , M, st) ←$ A 1 (1 λ ) 2 : ((, T ), st) ←$ Encrypt ε S(sk S , pw, M), A 2 (st) 3 : (( f , M ), st) ←$ Decrypt S(sk S , pw , T ), A 3 (st) 4 : b 0 ← ( f = ⊥) 5 : b 1 ← (pw = pw ∧ ( f = 1 ∨ M = M )) 6 : b 2 ← (pw = pw ∧ f = 0) 7 : return b 0 ∧ (b 1 ∨ b 2 )Figure 4: Soundness ExperimentStrongSoundness PHE,A (1 λ ) 1 : (pk R , sk S , , , pw, pw , T, st) ←$ A (1 λ ) 2 : (( f , M), st) ←$ Decrypt S(sk S , T, pw), A 2 (st) 3 : (( f , M ), st) ←$ Decrypt S(sk S , T, pw ), A 3 (st) 4 : b 0 ← (⊥ / ∈ { f , f }) / / Rate-limiter does not abort. 5 : b 1 ← ((, pw) = ( , pw ) ∧ ( f , M) = ( f , M ))6 : / / Same labels and passwords, different behaviors7 : b 2 ← ((, pw) = ( , pw ) ∧ f = f = 1) 8 : / / Record is valid under different label-password pairs 9 : return b 0 ∧ (b 1 ∨ b 2 )Figure 5: Strong Soundness ExperimentTo make the rate-limiter even more accountable, the strong soundness property guarantees all properties of soundness, with some additional ones ( Figure 5). This property ensures that even for maliciously generated records and maliciously generated secret keys for both the server and the rate-limiter, the rotated keys and updated records are indistinguishable to freshly generated keys and records respectively, except for the information that is preserved for ensuring functionality, e.g., the encrypted messages and the labels.Unlike the original definition [16], our definition allows the adversary to generate multiple records. This definition seems not to be equivalent to the single-record variant, as an adversary against the single-record variant cannot simulate a challenger of the multi-record variant without knowing the update token chosen by the challenger of the single-record variant.Definition 4 (Forward Security) A PHE scheme PHE is forward secure if for any two-stage PPT adversary A = (A 1 , A 2 ) there exists a negligible function negl (λ ) withPr FwdSec 0 PHE,A (1 λ ) = 1 − Pr FwdSec 1 PHE,A (1 λ ) = 1 ≤ negl (λ ) ,where each probability is taken over the random coins of the experiments. Below, we discuss why these approachesFwdSec b PHE,A (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk S , sk R , {( i , pw i , T i )} n i=1 , st) ←$ A 1 (pp) 3 : / / for some n = poly (λ ) 4 : ∀i ∈ [n], (( f i , M i ), ε) ← Decrypt i S(sk S , pw i , T i ), R(sk R ) 5 : if b = 0 then 6 : ((pk S , sk S , τ), (pk R , sk R )) ←$ RotateS(sk S ), R(sk R ) 7 : ∀i ∈ [n], T i ←$ Update i (τ, T i ) 8 : else 9 : (pk S , sk S ) ←$ KGen S (pp), (pk R , sk R ) ←$ KGen R (pp) 10 : ∀i ∈ [n], (( i , T i ), ε) ←$ Encrypt i S(sk S , pw i , M i ), R(sk R ) 11 :/ / By the assumed convention,i = i ∀i ∈ [n]12 : endif 13 : b ←$ A 2 (st, sk S , sk R , T 1 , . . . , T n ) 14 : return ((∀i ∈ [n], f i = 1) ∧ b ) At first glance, a PHE scheme might be built on top of a PH scheme, by additionally encrypting the message in the enrollment protocol, in such a way that it can be decrypted if and only if a valid candidate password is provided. Similar to the construction of symmetric-key encryption from PRFs, where a ciphertext C which encrypts message M using key k is computed as C = (PRF(k, r) ⊕ M, r), one idea is to encrypt a message by the output of the PO-PRF as a one-time pad.When instantiated with PYTHIA, the only known construction of PO-PRF, a PRF value is a group element e(H 1 (un), H 2 (pw)) k in the target group of a cryptographic bilinear map e. Along with the simplification and the upgrade, we also let the rate-limiter generate a proof even if the pseudorandom value given by the server, or equivalently the given candidate password, is invalid (which was missing in PHOENIX). Let H S , H R : {0, 1} * → G be hash functions (to be modeled as random oracles in the security proof). These nonces serve asSetup (1 λ ) crs ←$ Π.Gen(1 λ ) G ←$ G return (crs, G) KGen S (pp) pk S ← ε sk S ← y ←$ Z q return (pk S , sk S ) KGen R (pp) x ←$ Z q X ← G x pk R ← X sk R ← x return (pk R , sk R )Figure 7: Setup and Key Generation of PHE session identifiers or pseudonyms of the registering enduser. It sends C 0 to the rate-limiter, who checks if C 0 is indeed equal to H x R,0 . The latter then verifies the proof, recovers M as (T 1 H −x R,1 H −y S,1 ) 1/y , and outputs the flag f = 1 and the message M. Otherwise, the rate-limiter proves that C 0 and H x R,0 are not equal. Full proofs are postponed to Appendix A.Theorem 1 (Partial Obliviousness) Assume that DDH is hard in G. Then, in the random oracle model, our construction achieves partial obliviousness.Proof 1 (Proof sketch) The proof is based on the observation that the adversary can only obtain (pseudorandom) hashes of(pw * b , M * b ) but not (pw * 1−b , M * 1−b ), since (essentially) the only way to obtain the latter is by querying the decryption oracle on (, pw) where = ( * S , ·) and pw = pw * 1−b , which is refused by the oracle.Theorem 2 (Message Hiding) If Π is zero-knowledge and DDH is hard in G, then our construction achieves message hiding in the random oracle model. else n S ← {0, 1} λ endif H S,0 ← H S (pw, n S , 0), H S,1 ← H S (pw, n S , 1) receive (n R ,C, π) from R H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" if Π.Vf(crs, stmt, π) = 0 then return ⊥ endif T ← (C 0 H y S,0 , C 1 H y S,1 M y ) ← (n R , n S ) return ( , T ) Encrypt ·, R(sk R ) parse sk R as x if = ε then parse as (n R , n S ) else n R ← {0, 1} λ endif H R,0 ← H R (n R , 0), H R,1 ← H R (n R , 1) C = (C 0 ,C 1 ) ← (H x R,0 , H x R,1 ) stmt ← "∃x s.t. (C 0 ,C 1 , X) = (H x R,0 , H x R,1 , G x )" wit ← x π ← Π.PoK(crs, stmt, wit) send (n R ,C, π) to R return εTheorem 3 (Strong Soundness) If Π is sound and has the proof of knowledge property, then our construction is strongly sound.Proof 3 (Proof sketch) The proof follows almost immediately from the soundness and the proof of knowledge property of Π: An adversary against (strong) soundness must convince an honest server to either draw an incorrect conclusion about the validity of a record or a candidate password, or recover a different message which is not encrypted in the record. As shown in Figure 11, the PHE crypto service perfectly scales to more cores and can handle more than 525 encryption and (successful) decryption (i.e., registration and login) requests per second (per core). On the other hand, since the server in PYTHIA does nothing but equality checks, its computation cost should be negligible.Considering current recommendations for best practice [21] on password hashing we note that algorithms like scrypt or Argon2 [3] are usually configured to limit login throughput to tens of requests per second which is significantly slower than the overhead introduced by PHE. To convert the system in a single batch conversion step, assuming the existing system stores passwords in the form of salted hashes (n S , H(n S , pw)), the server samples a random message M, further hashes each record to compute (n S , H y S,0 H y S,1 ) = (n S , H(H(n S , pw), 0) y , H(H(n S , pw), 1) y M y ) (modeling H as a random oracle and interpreting its output as a group element), and communicate with the rate-limiter to complete the PHE record.Either way, the random message M is used as a symmetric key (e.g., for AES) to encrypt the existing (plaintext) profile of the end user, and is discarded after encryption. We have proposed and constructed password-hardened encryption (PHE) services, an extension to passwordhardening (PH) services, which not only protects passwords but also user data stored by an online service provider, even if the latter is fully compromised. Finally, new constructions, perhaps based on other (e.g., lattice-based) complexity assumptions or without using the random oracle, and more efficient instantiations are always welcome.Message Hiding. Then, the proof is done since Exp 0,4 and Exp 1,4 are functionally identical.After the modification made in Exp b,3 , note that the challenger essentially acts as a conditional decryption oracle which, on input (n R ,C 0 ), checks if the ciphertext is well-formed, i.e., whether C 0 = H R (n R , 0) x (which is programmed to a random value), and if so outputs C 1 = H R (n R , 1) x with a simulated proof of correctness. If Π is sound and has the proof of knowledge property, then PHE is strongly sound.To prove such claim, we observe that if there exists an adversary A which causes either of the soundness experiments to output 1, then the challenger can extract two proofs for two contracting statements respectively, which breaks the soundness of Π. This means that the challenger has a proof of "∃x s.t. (C 1 , X) = (H x R,1 , G x )" for some C 1 = C 1 , another contradicting statement.For the second case, since pw = pw , the challenger sends C 0 which is not equal to C 0 except with negligible probability to A in the decryption protocol. The public keys and the records are uniquely determined by the secret keys.For any client and server secret keys x and y, there is a one-to-one correspondence between each fresh key pairs (x , y ) ∈ Z 2 q and each tuple of randomness (α, β ) ∈ Z 2 q chosen in the rotation protocol, given byx = αx + β y = αy ≡ α = y /y β = x − αx . This work is partially supported in parts by Germany/Hong Kong Joint Research Scheme (G-CUHK406/17) of the Germany Academic Exchange Service (DAAD) and the Research Grants Council (RGC), University Grant Committee of Hong Kong, and General Research Funds (CUHK 14201914) of RGC. In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 . In the experiment Exp b,2 , the only information about, since the decryption oracle refuses to decrypt ciphertexts with the labels = ( * S , ·) and passwords pw * 0 and pw * 1 .