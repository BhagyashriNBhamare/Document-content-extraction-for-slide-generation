We design KOOBE to assist the analysis of such vulnerabilities based on two observations: (1) Surprisingly often, different OOB vulnerability instances exhibit a wide range of capabilities. In our evaluation, we demonstrate the applicability of KOOBE by exhaustively analyzing 17 most recent Linux kernel OOB vulnerabilities (where only 5 of them have publicly available exploits), for which KOOBE successfully generated candidate exploit strategies for 11 of them (including 5 that do not even have any CVEs assigned). According to a recent report from Microsoft [38], around 70% of security bugs that were fixed between 2006 and 2018 are memory safety bugs. According to the Google's syzbot dashboard [25], which reports bugs from continuously fuzzing Linux kernels, in a single year (from Aug 2017 to Sep 2018), there were 1,216 Linux kernel bugs discovered by syzkaller [26] and fixed. These studies employ various program analysis techniques to search for a possible exploit path (that can achieve arbitrary code execution) given a Proof-of-Concept (PoC) test case.Exploits of OS kernel vulnerabilities have unique characteristics compared to those of user applications -any kernel exploit is multi-interaction by design, involving a sequence of attacker-chosen inputs (i.e., syscalls and their arguments) where one is dependent on another; this is in contrast with many user applications such as command line programs that take input in one-shot. For example, CVE-2016-6187 can overwrite only one single byte; CVE-2017-7184 can write more bytes but only the same fixed value. Even worse, we find that a PoC (e.g., generated by syzkaller [26]) sometimes fails to exercise the complete capability of a vulnerability, making it seemingly unexploitable.To this end, we develop KOOBE that automates the process of all key steps in evaluating a kernel OOB vulnerability, focusing on the key module of capability extraction, which feeds into subsequent exploitability evaluation. We release the source code of KOOBE to facilitate further research (https: //github.com/seclab-ucr/KOOBE).• We thoroughly evaluate KOOBE using known CVEs as well as crash reports from syzbot. As we will elaborate through a real-world kernel OOB vulnerability, this is because that (1) a PoC program may not fully explore the capability of an OOB vulnerability; (2) there is often a huge search space to locate an appropriate memory layout that can facilitate the exploit. Also, a typical heap OOB exploit involves two kinds of objects: we denote the object intended to be accessed as the vulnerable object (vul in line 12) and the overwritten one containing critical data (e.g., a function pointer) as the target object. However, the overflown content is in fact controllable by an adversary if sys_setsockopt is invoked before triggering the OOB access (its argument controls the value of gsock.option). In fact, at the time of writing, there was no publicly available exploit against this vulnerability, presumably because its capability is underestimated and requires a significant amount of manual work to (b) An exploit that leverages heap feng shui to manipulate the heap layout such that the target object is adjacent to the vulnerable object, exploits the vulnerability to alter the pointer of the target object, and then triggers the dereference of the pointer to divert the control flow. For instance, a PoC derived from random mutation-based fuzzing may overwrite a pointer in a target object with some random value resulting in non-exploitable page faults, or corrupt some system data that leads to crashes. We first summarize the capability of the vulnerability, based on which we can further select a target object with a critical field that can be overwritten if it is close to the vulnerable object. However, given that the heap allocator is deterministic and the fact that an attacker can always set up the heap layout ahead of time through a sequence of syscalls, it is almost always possible to arrange the memory to facilitate OOB write exploits (e.g., vulnerable and target objects adjacent to each other). Given the summarized capabilities and pre-arranged memory layout, we need to carefully select a target object whose critical fields can be overflown with desired payload. As shown in Fig. 1b, we select Type3 as the target object since it has the same size of the vulnerable object (easier to perform heap feng shui) and has a function pointer in the first 8 bytes. Type4 on the other hand is not suitable for exploitation as its critical field (i.e., the data pointer sk) is not at the beginning.In the cases where the capability of a specific OOB vulnerability is limited, it is imperative to collect a diverse set of objects containing critical fields. For instance, CVE-2016-6187 shown in Fig. 3a can only overflow one byte of zero, which is not sufficient to fabricate a pointer. This is because overwriting the least significant byte of a reference counter to zero is equivalent of decreasing its value, ultimately converting it to a UAF vulnerability. Thus, we design KOOBE to decouple the capability extraction from the rest of the pipeline.After capability extraction, we evaluate exploitability for each potential target object and generate an exploit by incorporating heap feng shui strategies. This modularity is an important distinction from prior work [44,55,57], where they either consider only the one-shot input exploits which inherently couple the capability and exploitability anal-ysis together (e.g., no additional interactions allowed to select target objects) [44,55], or implicitly consider capabilities by exploring different vulnerability points [57] in the context of kernel UAF vulnerabilities (perhaps due to the nature of this type of bugs). As shown in Fig. 4, it starts off by analyzing a PoC with symbolic tracing to summarize the PoC's (basic) capability, and then automatically determines whether it is sufficient for exploitation -using one or more appropriate target objects. If not, we trigger the additional step of capability exploration to discover new capabilities observed on different execution paths 3 . In the motivating example, if we assign a symbolic value to the vulnerable object returned from the function kmalloc() (line 9), we can get the following symbolic expression of the pointer at line 12: vul + offsetof(Type2, option) where vul is the symbolic value we assigned. By analyzing the symbolic expression of the pointer in Fig. 3b (which is vul + i/8 where both vul and i are symbolic values -i is passed from a syscall argument), we can assert that this must be an OOB vulnerability point, as the offset is potentially larger than the size of the vulnerable object as there is no constraint against i (even if the PoC was not using a large enough i). We denote the set of all paths as P, the set of all vulnerability points along the path p ∈ P is signified as N p , and the corresponding OOB write set is denoted as T p = {(off pi , len pi , val pi )|i ∈ N p ∧ off, len, val ∈ E}, where off and len denote the starting point of the OOB write relative to the address of the vulnerable object and how many bytes can be written, respectively, and val represents the overwritten values of an OOB write. The capability of p (a particular path) is denoted as C p = {size p , T p , f (p) | size p ∈ E}, where size stands for the size of the vulnerable object, and f (p) is the set of path constraints collected when executing p.We point out that each OOB access can be constrained due to the path constraints along the executed path. C orig = {sizeof(Type1), {(offsetof(Type2, option), 8, 0x08080000000000)}, / 0} (1)while the complete capability should be:C comp = {sizeof(Type1), {(offsetof(Type2, option), 8, val)}, {val! ∀e 1 , e 2 ∈ E, e 1 e 2 if e 1 is identical to e 2 or e 1 is a constant whose value can be taken in e 2 ∀p 1 , p 2 ∈ P, T p 1 i T p 2 i if off p 1 i off p 2 i ∧ len p 1 i len p 2 i ∧ val p 1 i val p 2 i ∀p 1 , p 2 ∈ P, C p 1 C p 2 if size p 1 size p 2 ∧ ∀i ∈ N p 1 T p 1 i T p 2 iWe observe that directly comparing symbolic expressions can be tricky as they have intrinsic relationships, especially when coupled with path constraints. For example, by means of symbolic tracing, the offset of the write can be extracted from the first argument (destination address) of memcpy(); the value of the write can be extracted from the second argument (source address); and the length of the write can be retrieved from the third argument. Therefore, as shown in Fig. 4, if our system fails to produce a solution (failing to locate a suitable target object) with discovered capabilities, it searches for new PoCs that either extend the existing capabilities or uncover new ones, and then repeats the process of capability summarization and exploitability evaluation until we succeed or a pre-set timeout is triggered. This is because maximizing branch coverage is only a very loose approximation of discovering more OOB capabilities -it often prioritizes the wrong test programs to drive the fuzzing session (simply the ones that achieve new coverage and may not even trigger the OOB) and is insensitive to the actual OOB capabilities discovered. Compared to an existing capability C p 1 , a newly-extracted capability C p 2 is perceived as a new one if C p 2 C p 1 is false.Specifically, whenever a new test program is executed, we collect the concrete values of the OOB write set at runtime as the capability feedback (e.g., how many bytes are written and what values are written). Note that as depicted in Fig. 4, vulnerability analysis (see §4.1) is always performed before capability summarization, avoiding missing any OOB sites that KASAN fails to detect.In our design, we keep a balance of the test programs in the corpus. We change the strategy for seed selection by maintaining two queues for those increasing coverage and extending capability, and pick a seed from both queues with equal probability. After it initializes the memory object M with the symbolic data/indexes/offsets provided by the capability, it could evaluate if a candidate is suitable by adding target constraints upon the memory object M and checking the satisfiability with respect to the path constraints retrieved from capability summarization. The second row and third row regarding the OOB offset and OOB length (which are both constants) are taken to update the memory object, as well as the fourth row representing the OOB value (which is an 8-byte symbolic value). In this case, the target object of Type3 expects the first field (a function pointer of 8 bytes from index 0 to 7) to be overwritten with a valid user or kernel space address, which can be indeed satisfied. On the other hand, the second field of the target object of Type4 can not be overflown due to the limited OOB offset and OOB length.Capability Composition. Thus, these distance functions of the corresponding target type hold the following two properties: 1) Returning zero iff it is satisfied: for instance, the distance function for data pointer type returns zero only when the value is within a valid range (i.e., [MIN_POINTER, MAX_POINTER]); otherwise, a positive distance is returned; 2) Differentiability: it allows our greedy algorithm to distinguish which capability helps us get closer to the desired payload. Table 1: Encoding target constriants to distance functions where M is a symbolic memory model, I is the inital concrete memory for M, and s and P represent the start index and desired payload of the target field to be overwritten, respectively. As aforementioned, since our goal is to achieve the IP hijacking primitive rather than an end-to-end solution achieving arbitrary code execution (which may involve ROP/JOP to bypass SMEP), we explicitly consider these modern defenses (e.g., KASLR, SMEP) out of scope. It consists of 7,510 LOC of C++ to the S2E for capability summarization and exploitability evaluation, 2,271 LOC of python based on Angr to analyze vulnerabilities, and 1,106 LOC of Go to explore diverging paths with fuzzing and synthesize exploits. In this section, we present some important technical details of this system.Dynamic Instrumentation to Support CapabilityGuided Fuzzing. In addition to using S2E for symbolic tracing and generating symbolic representations of capabilities, we also integrate S2E with Syzkaller using the QEMU provided by S2E, leveraging its powerful binary-level instrumentation support for capability-guided fuzzing (as described in §4.3). In the critical step of exploitability evaluation where we update the memory model with M[offset: offset+length-1] = value[0: length-1] (see §4.4), it is possible that the offset, length and value are all symbolic. Specifically, given a summarized OOB write (off, len, val) where all elements are symbolic and the concrete length is 10, our system updates the memory object M with each byte individually as follows:for i in [0, 10]: M[ite(i < len, i+off, offset dummy )] = val[i]where ite represents an if-then-else expression supported by KLEE and Z3 [10], and offset dummy represents the offset of a dummy byte which we introduce to nullify the memory update of a specific byte. Essentially, a solver can search for a viable solution with a length between 0 and 10, and update the memory model appropriately.As we see in this example, we only conservatively search backward from a concrete OOB length (0 to 10). This is because it is impossible to predict the values of bytes at larger indexes, whereas it is safer to predict at smaller indexes (if the length were to be smaller), since we have seen them getting assigned and we know when the path will not change (by obeying the path constraint of the OOB length if any). This is a similar problem encountered in a previous work [13] where they attempt to resolve such conflicts through what they call "path kneading" to identify a way to temporarily divert the path and merge it back to reach the same critical point. This analysis is heavyweight, taking 2.62 hours on average, which is difficult to be applied to Linux kernel given the size of its codebase (and we may need to evaluate hundreds of PoCs potentially for each vulnerability after capability exploration). Intuitively, the relationship between the loop guard (e.g., n) and execution times of the loop body is also modeled when extracting capability for loops, and thus discarding those constraints would not make us over-estimate the capability. In our solution, we hence simply remove such unnecessary constraints, which allows the solver to search through the valid ranges of symbolic index and loop bounds, creating a different PoC than the one used before (i.e., syscall arguments will be changed so that the OOB write and OOB length will adapt to overwrite the critical field target object). As race condition threads are typically written in a loop repeating the sequence of syscalls, we annotate the PoC at the beginning of each loop to inform our system when a thread is about to re-execute its syscall sequence. Besides the type of critical data, we also collect its offset and the size of the target object as they constitute the target constraints. Dataset and Setup We evaluate our system against 17 (7 + 10) Linux kernel heap OOB write PoCs collected exhaustively from CVE database and syzbot (a fuzzing platform based on Syzkaller) [8], which are the largest public datasets of Linux vulnerabilities. Out of all 28 distinct syzbot reports pertaining to heap OOB write, eight are not reproducible (i.e., no C code provided to test), eight are considered as one bug since they share the same patch, one is difficult to trigger since it requires fault injection to make the kernel fail to allocate the vulnerable object, one related to KVM already needs root privilege to trigger the vulnerability, one is in fact associated with a CVE (present in the other dataset and considered duplicate), and thus they are excluded from testing. In addition, the last column of Table 2 and 3 represents the number of potential exploits, meaning that our system found these target objects (and their target constraints) matching the description of the capability out of 2615 candidates we collected. #public EXP #generated EXP #potential EXP 813961de3ee6474dd5703e883471fd941d6c8f69 1 2 4 35f7d5225ffcbf1b759f641aec1735e3a89b1914 0 2 643 bbeb6e4323dad9b5e0ee9f60c223dd532e2403b1 0 2 136 eb73190f4fbeedf762394e92d6a4ec9ace684c88 0 1 3 4576cd469d980317c4edd9173f8b694aa71ea3a3 0 1 3 17cfe79a65f98abe535261856c5aef14f306dff70 0 0 9fa68f620041be04720d0cbfb1bd3ddfc6310b24 0 0 NA 3619dec5103dd999a777e3e4ea08c8f40a6ddc57 0 0 NA 70303420b5721c38998cf987e6b7d30cc62d4ff1 0 0 NA bb29648102335586e9a66289a1d98a0cb392b6e5 0 0 NA Overall 1 8 + :We use commit hash of patches to distinguish vulnerabilities. memcpy(vul+4+lenA+lenB, bufC, lenC); //OOB Figure 7: A vulnerability triggered by three memcpy() invocations the OOB length so that it does not corrupt other objects as opposed to the original PoC. Specifically, imagine if the target object requires the size of the vulnerable object to be equal to 64, effectively reducing the length of bufA, the constraint solver would fail to produce a solution if we update the memory object with a concretized length of 120. Similarly, vulnerability 35f7d5225ffcbf1b759f that overflows 4 bytes of arbitrary values cannot be exploited if we want to modify an entire 8-byte pointer, yet our system produced a solution in which we only overwrite the 4 least significant bytes of a data pointer, resulting in a pointer residing in physmap region where we could control its content.CVE-2018-5703. We further evaluate capability summarization, exploitability evaluation, and the capability-guided fuzzing solution. Note that we only perform fuzzing when necessary, meaning our system is unable to find a suitable target object given the capability in the original PoC. We also attempted to compare our solution with the vanilla Syzkaller, and it fails to produce a desirable PoC for all four cases even after the 12-hour Time opt nop index tracing solving fuzzing CVE-2016-6187 2 0 2 38s 1s NA CVE-2017-7184 3 2 2 27s 45s 23m CVE-2017-7308 2 1 2 48s 4s NA CVE-2017-7533 1 0 0 160s 164s NA CVE-2017-1000112 2 2 2 36s 132s NA CVE-2018-5703 1 1 1 85s 41s 194m 813961de3ee6474dd570 2 2 2 34s 5s NA 35f7d5225ffcbf1b759f 2 2 2 34s 18s 8m bbeb6e4323dad9b5e0ee 2 2 2 48s 26s 23m eb73190f4fbeedf76239 1 1 1 54s 104s NA 4576cd469d980317c4ed 1 1 1 57s 7s NA nops: No constraint relaxing. The recent work [56] proposes a novel solution to bypass SMEP and SMAP, given an IP hijacking primitive. Future work would be to explore different probability configuration and design approaches to dynamically adjust it during the fuzzing execution.Although we only consider defenses deployed in practice in this work, some fine-grained randomization based defenses [3,14,42] would break some of our assumptions in generating exploits (e.g., DieHard [14] and SLAB/SLUB freelist randomization [3] make heap feng shui much less predictable). Some state-of-the-art coverage-guided fuzzers adopt more advanced techniques to improve mutation strategies, such as static and dynamic analysis [43], a gradient-descent-based search strategy [19], neuro network [49], input-to-state inference [11], etc. In this paper, we distill key challenges in exploiting Linux kernel OOB vulnerabilities and emphasize the necessity to separate the capability summarization of a vulnerability from its exploitation. The Figure 11: An example of a configuration fed to capability extraction { "key": { // type: reference counter, data pointer, // function pointer, custom data "type": "reference counter", "offset": 0, // The offset to the target field "size": 192, // The value we want to overwrite with "payload": "\x00\x00\x00\x00", "original value": "\x01\x00\x00\x00" "allocate": // Allocate this object "s[0] = syscall(__NR_keyctl, 1, "keyring", 0, 0, 0); syscall(__NR_keyctl, 5, s[0], 0x3f3f3f3f, 0, 0);", // Trigger a dereference of the target pointer "dereference":"syscall(__NR_keyctl, 1, "keyring", 0, 0, 0); do_keyspray(); syscall(__NR_keyctl, 3, 0xfffffffffffffffd, 0, 0, 0);", // Number of objects allocated before the target object "#pre-object": 1 }} Figure 12: Database for target objects "layout" records the sizes of all the heap objects allocated during the execution of the syscall that allocates the vulnerable object, summarizing the side effect we have to cope with when performing heap feng shui. In this case where the syscall that allocates the vulnerable object and the one triggering OOB writes are the same, leaving no room for allocating the target object afterward, we thus proactively reserve three adjacent slots (line 27) for the vulnerable and target objects and one more competing for the memory as declared in the database (i.e., "#pre-object"). B IP-Hijacking primitive generation walkthroughTo provide a concrete example of the workflow we walk through the steps of generating an IP-hijacking primitive for Algorithm 1: Exploitability composition CVE-2016-6187 that only allows overflowing one byte of zero. To provide a concrete example of the workflow we walk through the steps of generating an IP-hijacking primitive for Algorithm 1: Exploitability composition CVE-2016-6187 that only allows overflowing one byte of zero. We basically need to locate the function that triggers the OOB access and its source line number (given in the backtrace of any KASAN report) and use static analysis (we use Angr) to locate the actual write instruction.Recall that KOOBE needs to recognize all the loops involving OOB writes and their guards (i.e., the comparison instruction determining whether a loop should exit), we thus implement some static analysis with Angr.