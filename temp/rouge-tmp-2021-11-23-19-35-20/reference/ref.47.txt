We suggest a novel modelling technique capable of producing high-quality instruction-level power (and/or EM) models without requiring a detailed hardware description of a processor nor information about the used process technology (access to both of which is typically restricted). For instance, much earlier efforts to model total energy consumption for the purposes of optimising code for constrained devices [27] showed clearly that the power consumed by a particular instruction varies according to the instructions previous in the sequence.Another important aspect of power model construction, as emphasised by recent contributions in the template building literature [5,11,20], is portability between different devices of the same design. As well as enhancing the accuracy and nuance of our predicted traces relative to previous work, our systematic method of selecting and testing potential explanatory variables provides valuable insights into the leakage features of the ARM Cortex devices examined, which are of independent interest.The second part of our contribution is a procedure to extract the data flows of arbitrary code sequences which can subsequently be mapped to trace predictions via our carefully refined models. In this section we aim to provide enough context for our paper to be reasonably self-contained for a reader not familiar with the tasks of leakage modelling and model evaluation (Sect. 2.1), the ARM Cortex-M processor family (Sect. 2.2), assembly code instructions (Sect. 2.3) and/or typical side-channel measurement setups (Sect. 2.4). Note that even these most exhaustive of strategies, which may be collectively classed as 'white box' modelling due to their reliance on comprehensive implementation details, fail to account for influences on the leakage outside the information provided by the netlist (for instance crosstalk) and therefore represent simplifications of varying imperfection. Previous instruction-level (and higher code-level) simulations for the purposes of sidechannel analysis have settled for Hamming weight or Hamming distance assumptions [26,28] or have estimated simple models constrained to be close to such approximations [7,6]. The F-test can also be used to test overall model significance, which is useful in our case where the exploitable (i.e. data dependent) variation may only represent a small fraction of the total variation in the traces (which includes noise and unrelated processes). Within the family there are six variants of processor: the M0, M0+, M1, M3, M4 and M7, where the M0 provides the lowest cost, size and power device, the M7 the highest performing device, and the M0+, M3 and M4 processors sit in-between. In this work we focus on profiling a select number (21) of Thumb instructions that are highly relevant for implementing symmetric cryptography, which run on both the Cortex-M0 and M4 processors: ldr, ldrb, ldrh, str, strb, strh, lsls, lsrs, rors, muls, eors, ands, adds, adds #imm, subs, subs #imm, orrs, cmp, cmp #imm, movs and movs #imm. How we model these operands based on the register selection of the instructions is described below.For the majority of non-memory instructions (i.e. those other than ldr, ldrb, ldrh, str, strb, strh), three different registers may be selected for use in the format "inst r d , r n , r m /#imm", where r d is the destination register for the output, r n the register holding the first operand and r m the register containing the second operand. These boards both feature an ST-Link to flash programs to the processor and provide on-chip debugging capabilities as well as on-board RC oscillator clock signals (8Mhz and 16Mhz for the STM32F0 and STM32F4 respectively). To measure the EM emissions on the Cortex-M4 processor we placed a small EM probe over the output of one of the capacitors leading to one of the power supply pins of the processor.We used a Lecroy Waverunner 700 Zi scope at a sampling rate of 500 MS/S for both the power and EM analyses. We fit models of the following form (written in matrix notation) to the measured leakage of different instructions via OLS estimation (see, e.g., Chapter 3 of [12]):y = δ + [ O 1 | O 2 | T 1 | T 2 ] β β β + ε ε ε(1)whereO i = [ x i [0] | x i [1] | . . . | x i [31] ]is the matrix of operand bits across bus i = 1, 2, [31] ] is the matrix of bit transitions across bus i = 1, 2 (i.e., [b] denotes the b th -bit, x i denotes the i th operand to a given instruction, z i denotes the i th operand to the previous instruction, and '|' denotes matrix concatenation). The test statistic is computed via the residual sums of squares (RSS) of each model, along with their respective numbers of parameters p A , p B and the sample size n as follows:F = RSS A −RSS B p B −p A RSS B n−p B(2)Under the null hypothesis that the terms have no effect, F has an F-distribution with (p B − p A , n − p B ) degrees of freedom. We are especially concerned with sources of variation that have a differential impact on the data-dependent contributions, as these will determine how well we are able to proportionally approximate the exploitable part of the leakage (whereas 'level' (average) effects will simply shift the model by an additive constant). • Bus transitions contribute to the instructions on immediate values, and also to cmp.Whilst we again advise against over-interpreting the Rsquareds (see Section 2.1), a comparison between the first rows of 3 and 4 indicates that, in the case of the ALU and shift instructions, model (1) accounts for substantially less of the variation in the M4 EM traces than it does of the variation in the M0 power traces. For instance, we might expect instructions invoking the same processor components (as visualised in Fig. 1) to leak similarly: ALU instructions as one group (i.e. adds, adds #imm, ands, eors, movs, movs #imm, orrs, subs, subs #imm, cmp, cmp #imm), shifts as another, albeit closely-related group (lsls, lsrs, rors), loads (ldr, ldrb, ldrh) and stores (str, strb, strh) that interact with the data in/out registers as two more groups, and the multiply instruction (muls) as a group on its own with a distinct profile due to its single cycle implementation. The silhouette value is a useful measure to gauge this, defined for the i th object as S i = b i −a i max(a i ,b i ) , where a i is the average distance from the i th object to the other objects in the same cluster, and b i is the minimum (over all clusters) average distance from the i th object to the objects in a different cluster [22]. The coefficients on the first operand are large for just six of the bits while the second operand coefficients are mediumsized across all bits of the first two bytes.In summary, our exploratory analysis of the datadependent form of the instruction leakages confirms many of our a priori intuitions about the architecture and supports our model building approach as sensible and meaningful. We then fit model (1) with the addition of a dummy for (level) board effects and we compare this against a model with the further addition of board/data interaction dummies, in order to test the joint significance of the latter.We find a remarkable degree of consistency in the data-dependent leakage of the different boards. For the purposes of future extensions to our methodology, we propose modelling high register movs as an additional distinct instruction.We test for variation between the eight low registers by collecting 5,000 traces for each source register (r n ) and destination register (r d ) (evenly distributed over the possible source/destination pairs, making 625 per pair) as movs are performed on random inputs. For the ldr instruction (which is two cycles long) the relevant point was one cycle ahead of that of the muls, lsls and eors; for str, the relevant point was three clock cycles ahead, implying that the data leaked during the subsequent instruction.Using these relevant points, we then built models for each target instruction in function of its operands, as in model (1), with the addition of dummy variables for previous and subsequent instructions. • DxI s = [ O 1 xI s | O 2 xI s | T 1 xI s | T 2 xI s ]:The Hamming weights of the two 32-bit operands and their Hamming distances from the previous two inputs, interacted with the 'subsequent instruction' dummies, as above.The extended model, in our matrix notation, is therefore:y = δ + [ I p | I s | D | DxI p | DxI s ] β β β + ε ε ε(3)For the purposes of building comprehensive instruction-level models we are especially interested in confirming (or otherwise) the presence of sequence-varying data-dependency, which we again achieve by performing F-tests for the contribution of the interaction terms. Previous analyses fitting linear regression models to target values [13,29] have allowed for these and for other higher-order interactions, increasing the possibility of accounting for even more exploitable variation in the leakage. There are a number of instruction-level emulators available for the ARM, Thumb and Thumb2 instruction sets due to the popularity of these processors.We choose an open source (programmed in C) emulator called Thumbulator 8 . Our data flow adaptation is built around a linked list data structure: in addition to the instruction type, the values of the two operands and the associated bit-flips from the preceding operands are stored in 32-element binary arrays.The operand values, and associated bit-flips from the preceding operations, are then used as input to the model equations (as derived in Sect. 5; see Eqn. Specific tests divide the traces into two subsets based on some known intermediate value such as an output bit of an S-box or the equality (or otherwise) of a round output byte to a particular value. The non-specific 'fixed-versusrandom' test acquires traces associated with a particular fixed data input and compares them against traces asso- ciated with random inputs. An experienced and side-channel aware implementer who has detailed leakage information about the M0 would now be able to spot a problem with this code: because the ror instruction also leaks a function of the Hamming distance to its predecessor, there could be problem if the prior instruction is protected by the same mask. Address Machine Assembly Code No.Code 1-2 0x08000206 0x684C ldr r4,[r1,#0x4] 3 0x08000208 0x41EC ror r4,r5 4-5 0x0800020A 0x604C str r4,[r1,#0x4] 6-7 0x0800020C 0x688C ldr r4,[r1,#0x8] 8 0x0800020E 0x41F4 ror r4,r6 9-10 0x08000210 0x608C str r4,[r1,#0x8] 11-12 0x08000212 0x68CC ldr r4,[r1,#0xC 13 0x08000214 0x41FC ror r4,r7 14-15 0x08000216 0x60CC str r4,[r1,#0xC] Table 1: Thumb assembly implementation of ShiftRows showing (colour-coded in red) leaky instructions as indicated by the model-simulated power consumption.