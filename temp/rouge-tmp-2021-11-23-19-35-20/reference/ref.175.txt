Through a study on 80,694 apps from Google Play, we find that 49.2% of manipulation cases are XPM, 4.8% of the apps have XPM behaviors, and more than 70% XPM behaviors aim at top Web sites. More alarmingly, we discover 21 apps with obvious malicious intents, such as stealing and abusing cookies, collecting user credentials and impersonating legitimate parties. For simplicity of presentation, we call them WebViews throughout the paper.Based on WebViews, mobile systems further provide app developers with Web resource manipulation APIs to customize browser behaviors and enrich Web app functionalities. For example, if a host app has a WebView which loads "www.facebook.com", then it can use evaluateJavascript API to run JavaScript in the Facebook Web pages and get user data from Facebook. Luo et al. [32,33] showed that malicious apps can attack WebView by injecting JavaScript code, sniffing and hijacking Web navigation events [32], and hijacking touch events at the Web pages [33]. Since Android apps are easy to be collected in a large volume and Android platform dominates the mobile market, our empirical study is based on Android platform.First, since not all manipulations cause security issues, we need a clear definition about the threat in Web resource manipulation. In our definition, only manipulating code from a different principal to the manipulated Web resource will be flagged as suspicious.Second, to allow measuring the Web resource manipulation problem on a large scale, we further design a tool to automatically recognize XPM behaviors in real-world apps. We find that 49.2% of manipulation points are cross-principal, 4.8% of apps have XPM behaviors, 63.6% of cross-principal manipulation points originate from libraries, and more than 70% of XPM points manipulate top popular Web services. We also find that most of XPM behaviors are necessary to improve the usability for mobile users, some XPM behaviors implement OAuth implicit flow in an unsafe way, and we confirm the Web resource manipulation behaviors with obvious malicious intents for the first time in real-world Android apps and iOS apps. We also perform several experiments to test the awareness of such risks to service providers, and find that most Web service providers are unaware of these risks and can not effectively prevent users from accessing sensitive pages in WebView. There are three Java classes (C1, C2 and C3) in the two apps which use WebViews to load www.facebook.com and use CookieManager.getCookie API to get cookies from www.facebook.com.For C1 which belongs to the official Facebook app and C2 which belongs to the official Facebook Login SDK, it is quite normal for them to access cookies from www.facebook.com. After a manual inspection on C3, we confirm that "Chatous" abuses Facebook cookies to collect user data in Facebook (more details are discussed in Section 4.3.3). We designate the security principal of the manipulating code as App Principal (AP), and the security principal of the manipulated Web resource as Web principal (WP). We consider the host app is not trusted, i.e. it may attack the Web resources by stealing sensitive data, breaking code/data integrity, etc. This paper focuses on measuring the security impact of Web resource manipulation APIs in real-world applications, while does not aim to study all kinds of threats in appweb interaction, which has been well-studied by existing work [32,33,17,23,36,48]. Certainly, host apps may use hybrid frameworks such as Cordova [1] or customized browsers such as customized Chromium [7], to integrate Web services. including quite sensitive resources, such as local storage and network traffic.To better understand the impact of the problem of cross-principal Web resource manipulation, we perform a thorough study of the WebView APIs provided by Android and iOS platform. To support a large-scale empirical study of Web resource manipulation behaviors in real-world apps, this paper designs an automatic tool, named XPMChecker to recognize this behavior in apps. Meanwhile, host apps often incorporate third-party libraries and SDKs, making it quite challenging to identify the principals for different app code. Web principal and app principal are extracted from different sources and use different naming conventions for their identity, thus two kinds of naming diversity are introduced: polymorphism and abbreviation. Obviously, it is a huge challenge to correctly determine whether the Web principal and app principal represent the same party.Main Ideas. Although there is no existing identifiers to represent app principal, we find some indicators extracted from the code can represent app principal.For example, we can use Java package name, app name, etc. Based on the above ideas, we design and implement XPMChecker which is capable of automatically recognizing XPM behaviors in real-world Android apps. • XPMClassifier gives a final decision about whether a Web resource manipulation point is crossprincipal or not by leveraging nature language processing techniques and search engines.Since our study mainly targets Android, XPMChecker is implemented for Android. The static analyzer first finds all the manipulation points for each input APK file, and extracts the manipulated Web URL and manipulating context for each manipulation point. We thoroughly study the official document of Android WebView APIs [9] and their usages in real-world apps. The URL is the parameter for such manipulation API, For example, the manipulated URL for CookieManager.getCookie(String url) is its first parameter, as showed in Listing 1. For example, in Listing 2, the manipulated URL of evaluateJavascript is the string "www.google.com" loaded by its base WebView instance. For shouldOverrideUrlLoading API, the "url" is a callback parameter and can only be determined at runtime. CookieManager cm = new CookieManager () ; 2 cm . We do a forward data flow analysis from the "url" parameter, and collect all branch statements having string operations with the "url" parameter as the inferred positions.It is more complicated to handle Type II APIs, where the manipulated URLs are actually loaded by the base WebView instances. Similar to Type III APIs, the dynamic URLs are inferred from the control flow structure of the code.String Analysis. Since we focus on integrated Web services, URLs with protocols other than HTTP/HTTPS are not considered and filtered out. • META, the meta-information of the app, including application package name and developer information;• DP, the declaring package name of the manipulating code;• SIG, the signature for the manipulating code;The META and DP information can be directly extracted from the APK file and app market. The SIG is a signature used to identify the provenance of the manipulating code, i.e. the host app or a third-party library. Specifically, it contains the class of the manipulation point, classes that are connected with the same WebView instance, and classes of the Java objects that have been injected into WebView through addJavaScriptInterface API.Manipulating Code Signature. Otherwise, we compare the Merkle trees for the two manipulating code signatures from top to bottom.In summary, the static analyzer module locates all manipulation points in each APK, extracts the manipulated URL and manipulating context for each point, and saves this information into a database. Since the protocol and port element defined in the Web origin are hard to compare with app principal, our solution uses the domain name at each manipulation point as the Web principal.Before extracting domains from Web resource URLs, we need to normalize the extracted URLs as there may be some abnormal URLs, such as short URL, IP address. Our insight is that Android developers usually include reverse domain name in the package name of their code.To distinguish library code and host app code, we use the signature for the code union (SIG). Otherwise, if it appears in more than one app from different developers, it originates from a library.Obfuscated Package Name Recovery. In this way, most of the obfuscated package names are recovered for libraries.Currently, for each manipulation point, we can extract its Web principal and app principal. For example, if the app principal is "fb" and the Web principal is "facebook", it is obvious to recognize them as same principal by manual inspection while there is no straightforward way to automatically give the same result.As it is difficult to strictly tell whether two principals are the same, we perform some relaxation on this problem. Note that in rare cases where search engine returns no results, we use literal edit distance between Web principal and app principal to calculate the similarity.1. Firstly, we remove noise words in < AP mp ,W P mp > such as suffixes [5] and stop words [6] (e.g. remove "com" and "get" from "get.appdog.com"), since they make little contribution to XPM classification. Fourthly, we calculate the similarity of the two principals as cosine similarity between the two vectors using the following equation.Sim(AP mp ,W P mp ) = n ∑ i=1 A i W i n ∑ i=1 A 2 i n ∑ i=1 W 2 i(3)5. These apps were selected with at least 5,000 installations across 48 categories, and 84,712 (out of 108,477) apps were successfully downloaded. We use XPMChecker to analyze these apps on a CentOS 7.4 64-bit server with 64 CPU cores (2GHz) and 188 GB memory. For the successfully analyzed apps, XPMChecker finds 13,599 apps with 29,448 manipulation points, and 3,858 of the apps contain 14,476 XPM points. For each Web resource manipulation point, Principal Identifier extracts the Web principal and app principal, then XPMClassifier judges whether this is XPM by leveraging search engine knowledge. To set θ , we select 1,000 labeled manipulation points from our ground truth and draw the receiver operating characteristic (ROC) curve by trying different thresholds (as shown in Figure 4). Therefore, the precision and recall of Principal Identifier and XPMClassifier are 98.9% and 97.9% respectively.We further manually inspect the false positives and false negatives. This section measures the prevalence of XPM behavior in real-world apps. As shown in Table 3, in all the successfully analyzed 80,964 apps, XPMChecker finds 13,599 apps that contain at least one manipulation points, that is 16.9% of all apps. Further more, XPMChecker finds 3,858 apps have XPM behaviors, which is 4.8% of all apps.Finding 3: 63.6% of cross-principal manipulation points originate from libraries. In all, we manually study all the 88 libraries in Table 5 which cover 63.6% of all XPM behaviors, and randomly select 100 apps from the 1,414 apps. We find that the most popular XPM behaviors we found are customizing Web services and invoking local apps. We also find a library called "Android-MuPDF" which injects JavaScript code into the Google cloud print page to help users reduce the steps in using cloud print. If the URLs are ads about apps, it will invoke the local "Google Play" app to display the advertised apps. Fig- ure 6(a) shows the standard and secure OAuth 2.0 implicit grant flow, where an external user-agent is used and third-party app can only access data in step 1 and step 7. For example, we find a library called "com.magzter" that uses onPageFinished API to intercept access token when doing OAuth on Twitter.According to previous research on OAuth security [41,16,43] and RFC OAuth 2.0 specification [4], it is unsafe to use internal user-agent. Then we select 200 apps for manual study, and finally we confirm 22 malicious XPM behaviors in 21 distinct apps (listed in Appendix A). Based on their malicious aims, we classify these apps into three categories: impersonating relying party in OAuth (A1, 2 apps), stealing user credentials (A2, 6 apps) and stealing cookies (A3, 14 apps). apps impersonate another relying party in OAuth by providing the client ID of the victim in step 1 (see Figure 6(b)) and intercepting access token of the victim in step 5. For example, Instaview is a visitor tracking app that tells users who has viewed their Instagram account. Apps in this category inject JavaScript code to sensitive Web pages, such as login page and OAuth authorization page to steal user credentials. The Instaview app described above also steals user credentials in step 2 of Figure 6(b) using similar methods.A3: Stealing and Abusing Cookies. We find that Chatous gets Facebook cookies using CookieManager.getCookie API and directly invokes Facebook APIs using these cookies to get the user friend list and send invitation messages to all the friends of the user. Both Melon and Kiwi have 10,000,000 to 50,000,000 installations, and Plaza has 1,000,000 to 5,000,000 installations.Finding 9: Malicious XPM behaviors exist on both Android and iOS. In our results, 18 out of 21 apps with malicious XPM behaviors attack OAuth, indicating that OAuth is the mostly targeted Web service.Finding 11: Malicious XPM behaviors have affected a large number of users. Thus, we draw the following conclusion.Finding 12: Most Web service providers are unaware of risks in Web resource manipulation, and can not effectively prevent users from accessing sensitive pages in WebView. Thus, though complete isolation improves security, it is hard to apply to existing apps.Finding 14: Fine-grained access control is a must for regulating Web resource manipulation APIs. Our work makes non-trivial efforts by leveraging static analysis, code similarity and search engines.Currently, our work has a few limitations. Several works point out that malicious JavaScript code from unauthorized Web origin can get sensitive data from the host apps through several ways, including abusing the JavaScript bridge (exported Java functions using addJavascriptInterface API) [32,17,36,23], accessing file system [17,23,45], abusing HTML5 geolocation API [23] or postMessage API [24]. When using WebView as the user-agent in OAuth, Shehab et al. [43] show that user credentials and authorization interface may be attacked, while Chen et al. [16] point out that access token sent in redirection URI may be leaked by the host app. With a study of 80,694 top Google Play apps, we find that 49.2% of manipulation points are XPM, 4.8% of apps contain XPM behaviors, and more than 70% XPM behaviors manipulate top popular Web sites. Yuan Zhang was supported in part by the Shanghai Sailing Program under Grant 16YF1400800 and a research gift from Ant Financial.