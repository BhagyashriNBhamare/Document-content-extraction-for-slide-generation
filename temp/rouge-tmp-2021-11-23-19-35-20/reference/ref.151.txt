We show that it is feasible to apply Charm to various device drivers, including camera, audio, GPU, and IMU sensor drivers, in different mobile systems, including LG Nexus 5X, Huawei Nexus 6P, and Samsung Galaxy S7. Therefore, one smartphone vendor might use a powerful camera so that its smartphone would stand out in this market, while another might be the first to incorporate a fingerprint scanner.Such diversity has an important implication for the operating system of mobile systems: a large number of highly diverse and customized device drivers are required to power the corresponding set of distinct I/O devices. That is, since the device driver executes within a virtual machine, it enables the analyst to use various dynamic analyses including manual interactive debugging, record-and-replay, and enhanced fuzzing.Executing a mobile system's device driver within a workstation virtual machine is normally impossible since the driver requires access to the exact hardware of the I/O device in the mobile system. It leverages the commonly available USB interface and hence makes our solution immediately available to security analysts.Second, in addition to interacting with the I/O device's hardware, a device driver interacts with several other modules in the operating system kernel including a bus driver, the power management module, and the clock management module. Therefore, different device drivers of different mobile systems can use the same RPC interface, reducing the engineering effort to apply Charm to new device drivers.We implement Charm's prototype using an Intel Xeonbased workstation and three smartphones: LG Nexus 5X, Huawei Nexus 6P, and Samsung Galaxy S7. Third, we show that Charm enables us to find 25 bugs in drivers including 14 previously unknown bugs (several of which we have already reported) and two bugs detected by a kernel sanitizer not available on the corresponding mobile system's kernel. Fourth, we show that we can record and replay the execution of the device driver, which, among others, can help easily recreate a bug without needing the mobile system's hardware. To demonstrate this point, we have used GDB to analyze 3 vulnerabilities in Nexus 5X camera driver (reported on Android Security Bulletins [2]). Therefore, anyone with access to a virtual machine can replay the device driver execution and analyze it.While any virtual machine record-and-replay can be used in Charm, we have implemented our own solution. However, by running the driver in a virtual machine in an x86 machine, Charm enables the use of kAFL.Another such fuzzing tool, which is capable of fuzzing kernel-based device drivers, is Syzkaller [7], recently released by Google. For example, we show that we can easily use KASAN in Charm by simply porting our drivers to a KASAN-enabled virtual machine kernel.Finally, Syzkaller can more effectively capture and analyze crash bugs when fuzzing a virtual machine compared to a mobile system. When such debugging hardware is not available, one can try to read the kernel messages through the Android Debug Bridge (ADB) interface, the main interface used over USB for communication to Android mobile systems. Unfotunately, doing so requires prohibitive engineering effort due to the diversity of I/O devices in mobile systems today.The second approach is to run the device driver in a virtual machine in the mobile system and use the direct device assignment technique [21,24,43,53,54] (also known as device passthrough) to enable the virtual machine to access the underlying I/O device. The device driver executes fully in the workstation and only the infrequent low-level I/O operations are forwarded and executed on the physical mobile system.In Charm, the latency of remoting the low-level I/O operations to the mobile system is of critical importance. Unfortunately, the overhead of instruction interpretation slowed the execution down to a point that our device drivers triggered various time-out errors.This made us realize that native execution is needed to meet the device driver's latency requirements, and hence we used a hardware-virtualized x86 virtual machine and reimplemented Charm in KVM.Note that it is possible to use an ARM workstation in order to have native ARM execution for the Charm's virtual machine. In this paper, we show that by leveraging native execution of an x86 processor and a customized low-latency USB channel, we can not only eliminate time-outs but also achieve performance on par with the execution of the analysis running directly on the mobile system.The second concern is that the disparity between the ARM Instruction Set Architecture (ISA) used in mobile systems vs. the x86 ISA used in the virtual machine may result in incorrect device driver behavior, which can affect the analysis, e.g., false positives in bugs detected by a fuzzer. We then intercept the low-level interactions of the driver with the hardware interface of the I/O device and route them to the actual mobile system through a USB channel. To achieve this, a stub module in the workstation's hypervisor communicates with a stub module in the mobile system to support the device driver's interactions with its hardware. Whenever the corresponding I/O device in the mobile system triggers an interrupt, the mobile stub forwards the interrupt to the stub in the workstation, which then injects it into the virtual machine for the device driver to handle. In an x86 virtual machine, the ACPI interface is emulated by the hypervisor.The first solution that we considered was to add a remote I/O device to the hypervisor's ACPI emulation layer so that the virtual machine kernel can detect it. In our initial prototypes of Charm, we experienced various time-out problems in the device driver and I/O device due to high latency of our initial channel implementation. Both in the mobile system and in the workstation, our stub modules read and write to these endpoints directly in the kernel (the host operating system kernel in the case of the workstation) hence avoiding costly user/kernel crossings. Instead, it uses the bus driver API.Second, if a module is needed on the mobile system, we keep the module in the mobile system and implement a Remote Procedure Call (RPC) interface for the driver in the virtual machine to communicate with it. These modules (which include power and clock management system, pin controller hardware, and GPIO) are in charge of hardware components that are needed to boot the mobile system and configure the USB interface. Moreover, we show, through our evaluation, that non-driver developers should also be able to perform the port as long as they have some knowledge about kernel programming, which we believe is a requirement for security analysts working on kernel vulnerabilities.Porting a device driver to run in Charm requires the following steps. To do this, the device tree entries corresponding to the I/O device hardware must be moved from the mobile system's device tree to that of the virtual machine (as discussed in ยง4.2). Second, the device drivers that are ported to the virtual machine must be disabled in the mobile system (since we cannot have two device drivers managing the same I/O device). We have ported 4 device drivers to Charm: the camera and audio device drivers of LG Nexus 5X, the GPU device driver of Huawei Nexus 6P, and the IMU sensor driver of Samsung Galaxy S7. Regardless, we show in ยง6.2 and ยง6.4 that we can still effectively fuzz the device driver and even find bugs.We use a workstation in our prototype consist-ing of two 18-core Xeon E5-2697 V4 processors (on a dual-socket SeaMicro MBD-X10DRG-Q-B motherboard) with 132 GB of memory and 4 TB of hard disk space. That is, the x86-based interrupt controllers supported in the virtual machine only supports up to 24 interrupt line numbers. This author ported these drivers to Charm after the implementation of Charm was almost complete, hence he could mainly focus on the port itself.The port of these two drivers was mainly performed by a different author from the author who ported the first two drivers (i.e., camera and audio drivers of Nexus 5X). Therefore, one might wonder if Charm impacts the performance of the device driver significantly.To evaluate the performance of the device driver, we perform two experiments. The first three setups (standing for Light-weight VM, Medium-weigh VM, and Heavy-weight VM) represent fuzzing the device driver in Charm while the last one represents fuzzing the device driver directly on the Nexus 5X smartphone. This result is important: it shows that Charm's remote device driver execution does not negatively impact the performance of the driver and hence the driver can be used for various analysis purposes. Our simple record-and-replay implementation does not support concurrent execution of threads within the driver.To demonstrate the effectiveness of Charm's recordand-replay, we record the execution of a PoC (related to bug #2 discussed in ยง6.4). One key question that we would like to answer is whether using an x86 virtual machine for a mobile I/O device driver would result in a large number of false positives, which can make the fuzzing more difficult for the analyst as s/he will have to filter out these false positives manually. Not only it facilitates fuzzing, it enables newer features of the fuzzer that is not currently supported in the kernel of the mobile system.Our analysis showed that these bugs belong to 7 categories: one unaligned access to I/O device registers, 19 NULL pointer dereferences, one invalid pointer dereference, one use-after-free, one out-of-bounds access, one divide-by-zero, and one explicit BUG() statement in the driver.Fuzzing with Charm uncovered 14 previously unknown bugs. We also studied a similar issue for bugs #23 and #24, which are also triggered in Charm (but not in the mobile system) for a similar reason.We believe that these results demonstrate that Charm can be used to effectively find correct bugs in device drivers through fuzzing. To demonstrate this, we have analyzed three publicly reported vulnerabilities in the Nexus 5X camera driver: CVE-2016-2501, CVE-2016-3903, and CVE-2016-2061. Since we compile the driver and kernel with debugging information, GDB can also display source lines, making the debugging much easier. In the end, we also set a watchpoint for step boundary and find that its value comes from a function argument passed from user space, which is untrusted.CVE-2016-2061. The first step is to check if the "vulnerable object" (struct vfe device, where the out-of-bounds write occurs) is a kernel heap or stack object. Such a large memory footprint can destroy the integrity of data stored nearby and cause a kernel crash.To address the first problem, we borrow the heap feng shui idea from the exploit of CVE-2017-7308 [5] to precisely co-locate the "vulnerable object" with one or more "target objects" (where one of their function pointer fields is the target for overwriting). This means that we can potentially spray a large number of target objects and try to arrange the target objects to be at a desired offset from the vulnerable object.To address the second problem, where a 480-byte overwrite may crash the kernel unintentionally, it is necessary to know the size of the target object and how likely they will align with the vulnerable object. The closest to our work are Avatar [77] and SURRO-GATES [50], solutions for dynamic analysis of binary firmware in embedded devices, such as a hard disk bootloader, a wireless sensor node, and a mobile phone baseband chip. For example, Charm can fuzz the device driver fully in a virtual machine.Other forms of remote I/O exists for mobile systems as well, such as Rio [22] and M+ [60]. Many of these analysis frameworks are built on top of the virtualization technology and can support fullsystem analysis, including the low-level code such as kernel and device drivers [33,34,59,75,76]. Aftersight [33] uses virtual machine replay to feed recorded logs from a production system to a testing system in real time where more expensive analysis is run. They can only support system software running within a virtual machine, e.g., device drivers for emulated and virtualized I/O devices (including direct device assignment for PCI-based I/O devices). Charm can benefit from Slowfuzz since it generally broadens the scope of the fuzzers' use cases.The diversity of device drivers and their direct interactions with physical I/O devices create challenges for dynamic analysis. Moreover, static analysis solutions often suffer from large false positive rates due to imprecision.Analysis of firmware running inside embedded devices faces similar challenges stemming from diversity as analysis of device drivers. However, we might need to insert explicit update operations in the driver for performance optimization and in the mobile system's kernel stub to notify the DSM system of the completion of DMA.Closed source (binary) drivers. Charm enables application of various existing dynamic analysis solutions, e.g., interactive debugging, record-and-replay, and enhanced fuzzing to these device drivers.