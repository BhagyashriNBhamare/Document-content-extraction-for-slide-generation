Our evaluation shows that QSYM does not just out-perform state-of-the-art fuzzers (i.e., found 14× more bugs than VUzzer in the LAVA-M dataset, and outper-formed Driller in 104 binaries out of 126), but also found 13 previously unknown security bugs in eight real-world programs like Dropbox Lepton, ffmpeg, and OpenJPEG, which have already been intensively tested by the state-of-the-art fuzzers, AFL and OSS-Fuzz. Fuzzing can quickly explore the input space at nearly native speed, but it is only good Figure 1: Newly found line coverage of popular open-source software by state-of-the-art concolic executors, Driller and S2E, and our system, QSYM, until they saturated. For example, Driller [8] demonstrates its effectiveness of the hybrid fuzzing in the DARPA Cyber Grand Challenge (CGC) binaries-generating six new crashing inputs out of 126 binaries that are not possible when running either fuzzing or concolic execution alone.Unfortunately, these hybrid fuzzers still suffer from scaling to find real bugs in non-trivial, real-world applications. We observed that the performance bottlenecks of their concolic executors are the main limiting factor that deters their adoption beyond the synthetic benchmarks.Unlike the promise made by concolic executors, they fail to scale to real-world applications: the symbolic emulation is too slow in formulating path constraints (e.g., libjpeg and libpng in Figure 1) or it is often not even possible to generate these constraints (e.g., libtiff and file in Figure 1) due to the incomplete and erroneous environment models (Table 4). Unlike our approach, current concolic executors employ coarse-grained, basic-block-level taint tracking and symbolic emulation, which incur non-negligible overheads to the concolic execution.Additionally, we alleviate the strict soundness requirements of conventional concolic executors to achieve better performance as well as to make it scalable to real-world programs. Moreover, this approach makes it possible to implement a few practical techniques to generate new test cases, i.e., by optimistically solving some parts of constraints ( §3.2), and to improve the performance, i.e., by pruning uninteresting basic blocks ( §3.3). Because of this, QSYM is free from snapshots incurring significant performance degradation and incomplete environment models resulting in incorrect symbolic execution due to its non-reusable nature. A QSYM-based hybrid fuzzer outperformed state-of-the-art automatic bug finding tools (e.g., Driller and VUzzer) in the DARPA CGC and LAVA test sets. Further, QSYM discovered 13 new bugs in eight real-world software. §5 evaluates QSYM with benchmarks, test sets, and real-world test cases. The following are the main reasons that block the adoption of hybrid fuzzers to the real world beyond a small-scale study. [12] to test angr because angr does not support the fadvise syscall, which is used in the coreutils applications.this significant overhead in symbolic emulation when we execute several programs without branching out to the other paths (no path explosion) or solving constraints on the path in widely-used symbolic executors, KLEE and angr. To model symbolic memory, the emulator needs to interpret how an instruction affects the symbolic memory status when supplied with symbolic operands. Consequently, the use of IR significantly reduces the implementation complexity because the emulator will have a much smaller number of interpretation handlers than when it directly works with machine instructions (e.g., 1,795 versus 62). For instance, based on our evaluation, the VEX IR [16], used by angr, increases the number of instructions by 4.69 times on average (versus machine instructions) in the CGC binaries, resulting in much symbolic emulation handling.Why not: IR blocks further optimization. According to our measurement with the real-world software (Figure 2), such as libjpeg, libpng, libtiff, and file, only 30% of instructions in symbolic basic blocks require symbolic execution. To avoid repetitive overhead, they transform and cache basic blocks into IRs, instead of individual instructions, to save space and time for cache management. Remove the IR translation layer and pay for the implementation complexity to reduce execution overhead and to further optimize towards the minimal use of symbolic emulation. The engine can explore the path without paying overhead for re-executing the program to the branch.On the contrary, the concolic execution engine in hybrid fuzzing fetches multiple test cases from the fuzzer with which they are associated different paths of the program (i.e., sharing no common branch). Therefore, snapshots taken from one test case path cannot be re-used in the other test case path such that they do not optimize the performance. Unfortunately, the snapshot mechanism breaks the assumption that the kernel holds: when a process diverges through fork()-like system calls, the kernel no longer maintains the states. Thus, concolic execution engines should maintain the states by itself.Existing tools try to solve this problem through either full system concolic execution or external environment modeling, but they result in significant performance slowdown and inaccurate testing, respectively. For example, Linux kernel 2.6 has 337 system calls, but angr only supports 22 system calls out of them. Optimize repetitive concolic testing, remove the snapshot mechanism that is inefficient in hybrid fuzzing, and use concrete execution to model external environments. The complete constraints can also over-constrain [5] a path that limits concolic execution to find future paths. However, if file_tryelf() does not depend on the true branch of looks_ascii(), this is the over-constraint problem because an input generated by concolic execution without caring about the path constraint, ch == 0x7f, will explore a path in file_tryelf(). Collect an incomplete set of constraints for efficiency and solve only a portion of constraints if a path is overly-constrained. Thanks to its efficient execution, QSYM can execute symbolic execution repeatedly instead of using snapshots that require external environment modeling. The existing concolic executors take such a coarse-grained approach because they suffer from high // If rdx (size) is symbolic __memset_sse2: movd xmm0,esi mov rax,rdi punpcklbw xmm0,xmm0 punpcklwd xmm0,xmm0 pshufd xmm0,xmm0,0x0 cmp rdx,0x40 ja __memset_sse2+80 def _op_generic_InterleaveLO(self, args):s = self. _vector_count left_vector = [args[0][(i+1)*s-1:i*s] for i in xrange(c/2)] right_vector = [args[1][(i+1)*s-1:i*s]for i in xrange(c/2)] return claripy.Concat(*itertools.chain.from_iterable( reversed(zip(left_vector, right_vector))))Figure 5: An example that shows the effect of instruction-level symbolic execution. Unlike a block-level approach, such as angr, that should symbolically execute all instructions, QSYM can generate symbolic constraints by executing only the last two instructions. Accordingly, many optimizations made by angr are to reduce such mode switching, e.g., striving to run one mode as long as possible.Solving only relevant constraints. QSYM solves constraints relevant to the target branch that it attempts to flip, and generates new test cases by applying the solved constraints to the original input. For example, Figure 6 shows an initial test case and new test cases generated by QSYM and Driller when exploring the same code paths: the red marker shows the differences between the original input and the generated test cases. However, focusing only on relevant constraints gives us a higher chance to solve the constraints and produce new test cases that potentially take different code paths. Moreover, due to its environment support ( §3.1) or various heuristics ( §3.2, §3.3), QSYM tends to generate more relaxed (i.e., incomplete) forms of constraints that can be easily solved. Since QSYM can achieve performance without introducing forkingbased symbolic execution [21], QSYM can utilize the old but complete technique to support external environments. In hybrid fuzzing, a symbolic solver's role is to assist a fuzzer to get over simple obstacles (e.g., narrow-ranged constraints like {ch == 0x7f} in Figure 3) and go deeper in the program's logic. Thus, as a hybrid fuzzer, it is well justified to formulate potentially new test inputs, regardless of reaching unexplored code via the current path or other paths.QSYM strives to generate interesting new test cases from the generated constraints by optimistically selecting and solving some portion of the constraints, if not solvable as a whole. As the emulation overheads dominate the overheads of constraint solving in complex programs, it economically makes sense to leverage this opportunity. To mitigate this problem, QSYM attempts to detect repetitive basic blocks and then prunes them for symbolic execution and generates only a subset of constraints. One exception is when a block contains constant instructions that do not introduce any new symbolic expressions, e.g., mov instructions in the x86 architecture and shifting or masking instructions with a constant.QSYM decides to use exponential back-off to prune basic blocks since it rapidly truncates overly frequent blocks. This helps not to lose constraints that are essential to discover a new path and also does not affect much on the symbolic execution because running such basic blocks a small number of times would not make the constraints too complex.Context-sensitivity acts as a tool for distinguishing running the same basic block in a different context for frequency counting. For example, when there are two strcmp() calls, say strcmp(buf, "GOOD") and strcmp(buf, "EVIL"), these two calls must be considered as a different basic block execution for frequency counting. QSYM relies on Intel Pin [24] for DBT, and its core components are implemented as Pin plugins written in C++: 12K LoC for the concolic execution core, 1.9K LoC for expression generation, and 1.5K LoC for handling system calls. The current implementation of QSYM supports part of Intel 64-bit instructions that are essential for vulnerability discovery such as arithmetic, bitwise, logical, and AVX instructions.QSYM will be open-sourced and support different types of instructions, including floating point instructions in the future. It is worth noting that Google's OSS-Fuzz generated 10 trillion test inputs a day [28] for a few months to fuzz these applications, but QSYM ran them for three hours using a single workstation. For testing purpose, we modified Driller to accept file input because these applications receive input from files, while the original Driller accepts only the standard input. To show how effectively our concolic executor can assist a fuzzer in discovering new code paths, we measured the achieved code coverage during the fuzzing process by using QSYM (a hybrid fuzzer) and AFL (a fuzzer) with a varying number of input seed files. For the 0% case, we provided a dummy ASCII file containing 256 'A's as a seeding input as both fuzzers required at least one input to begin with. On the contrary, QSYM not only formulated and solved the constraints for checking the PNG's magic header identifier but also explored more than 20% of code paths of libpng, which was 3% higher than the code coverage of fuzzing with valid images, i.e., the 20% AFL case. To show the performance benefits of QSYM's symbolic emulation, we used the DARPA CGC dataset [30] to compare QSYM with Driller, which placed third in the CGC competition [8]. To make our analysis simpler, we selected the first PoV (only one) as a seeding input for both fuzzers.To show the fuzzing result, we used the code coverage that we measured from all the test cases generated while fuzzing each CGC challenge. The AFL bitmap consists of 65,536 entries to represent code coverage, which is reasonable enough for our comparison purpose.Since the direct comparison of simple code coverage numbers might not properly indicate which fuzzer explored more and different code paths, we relatively compared their code coverage (see below). The darkest colors indicate that one fuzzer dominated the code coverage of another.QSYM outperforms Driller in terms of code coverage; QSYM explored more code paths in 104 challenges (82.5%) out of 126 challenges, whereas Driller did better only in 18 challenges (14.3%). It is worth noting that increasing the timeout for Driller (i.g., giving more time for constraints solving) does not help to improve the result of the code coverage. We could find several tendencies from further investigation of the results: 1) QSYM explores more paths than Driller in large programs and with long PoVs (i.e., in exploring deeper path). To read a message, an attacker should go through the following process: (1) create a new user (user1), (2) create another user (user2), (3) log in as user1, (4) send a message to user2, (5) logout, (6) log in as user2, and (7) read a message by sending a message id to read. This shows that QSYM's efficient symbolic emulation is effective in discovering sophisticated bugs hidden deeper in the program's path.2) With a limited time budget (5 to 30 minutes), Driller gets more coverage in applications with multiple nested branches within quickly reachable paths (i.e., shallow paths) because its snapshot mechanism is optimized for this case. Due to its slow emulation, Driller can search only the branches close to the start of a program in a limited time (5 to 30 minutes). LAVA is a test suite that injects hard-to-find bugs in Linux utilities to evaluate bug-finding techniques, so the test is adequate for demonstrating the fitness of the technique. Take an example in base64; the program decodes an input string using a table lookup (i.e., table[input [0]]) and further comparisons will be restricted by that concrete value. In such a case, concolic execution concretizes the entire symbolic constraints to the current input because the table lookup over-constrains input symbols to have only one solution that is identical to an initial test case. QSYM found 14× more bugs than VUzzer and any other prior techniques in the LAVA-M dataset.To evaluate our decision for optimistic solving that uses only the last constraint among constraints in an execution path, we measured the elapsed time and the number of bugs found in the LAVA-M dataset while changing the number of additional constraints. Figure 13 shows that basic block pruning not only reduced execution time (63.6 min versus 94.2 min) but also helped to find more code coverage (13.2% versus 11.8%) in the real-world software. Basic block pruning made QSYM concretely execute the function and focus on other interesting code, whereas running without it made the emulation stuck there for generating constraints.The other design decisions, context-sensitivity and grouping, are essential to increase code coverage. In contrast, QSYM successfully generated a new test case that can pass the complicated branch by modifying the seven bytes of a given input. However, in hybrid fuzzing like QSYM, because the fuzzer can efficiently validate whether the input drives the program to an expected state (i.e., finding a new code coverage) or not, we can quickly extract some useful results from the haystack. QSYM can complement the others by quickly reaching the branch with narrow-ranged, complex constraints and solving them to generate test cases for that point. Also, AFLFast [34] uses a Markov chain model to prioritize paths with low reachability, and CollAFL [36] provides accurate coverage information to mitigate path collisions.However, fuzzing has a fundamental limitation: it cannot traverse paths beyond narrow-ranged input constraints (e.g., a magic value). In contrast, QSYM uses (1) fuzzing to explore most paths to avoid the path explosion problem, (2) generic heuristics (e.g., basic block pruning) without assuming any specific bug type, and (3) instruction-level re-execution-based symbolic execution for better performance. More importantly, QSYM found 13 previously unknown bugs in the eight non-trivial programs, such as ffmpeg and OpenJPEG, which have heavily been tested by the state-of-the-art fuzzer, OSSFuzz, on Google's distributed fuzzing infrastructure. DARPA FA8650-15-C-7556), NRF-2017R1A6A3A03002506, ETRI IITP/KEIT [2014-0-00035], and gifts from Facebook, Mozilla, and Intel.