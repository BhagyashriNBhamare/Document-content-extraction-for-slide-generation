However, contexts based on the recent execution history are often inadequate in breaking down large ECs due to the limited number of incoming execution paths to an indirect control transfer instruction (ICT).1 In this paper, we propose a new context for CFI, origin sensitivity, that can effectively break down large ECs and reduce the average and largest EC size. Origin-sensitive CFI (OS-CFI) takes the origin of the code pointer called by an ICT as the context and constrains the targets of the ICT with this context. If the context consists of only one level of return address, it is denoted as 1-call-site sensitive. Similarly, 2-call-site sensitive CFI uses two levels of return addresses as the context.Execution history based context can substantially reduce the average EC size, but is much less capable in reducing the largest EC size. To address that, we need a more distributed context that is not concentrated on the ICT.In this paper, we propose a new type of context for CFI, origin sensitivity. It supports both C-style indirect calls and C++ virtual calls with slightly different definitions for them: the origin for the former is the code location where the called function pointer is most recently updated; that for the latter is the location where the receiving object (i.e., the object for which the virtual function is called) is created. Our evaluation with SPEC CPU2006, NGINX, and a few real-world exploits shows that the prototype can significantly reduce the average and largest EC sizes, and incurs only a small performance overhead: 7.6% on average for the SPEC CPU2006 and NGINX benchmarks.In summary, this paper makes the following contributions:• We propose the concept of origin sensitivity that can substantially reduce both the average and largest EC sizes to improve the security of CFI. • We have built a prototype of OS-CFI with the following design highlights: we re-purpose the bound table of MPX to securely store and retrieve origins, and use TSX to protect the integrity of reference monitors; we piggyback on the analysis of SUPA, a precise static points-to algorithm, to built the origin-sensitive CFGs. OS-CFI takes the origin of the code pointer called by an ICT as the context. If the ICT is a virtual call, the origin is defined as the code location where the receiving object is created, i.e., where its constructor is called; 2 The context of a C-style ICT is similarly defined. Line 1 -10 shows how simulated networks are initialized: it creates an ExecuteOnStartup object for each network to call the network's initialization code; The constructor of ExecuteOnStartup sets the private member code_to_exec (a function pointer) and adds itself to a linked list (Line 18 -23). Figure 1: Example to illustrate origin sensitivity sensitivity can distinguish individual calls to code_to_exec (because it records each iteration of the while loop); but it is difficult to decide which target is valid because that depends on the unspecified order in which the constructors are called. Because only one function address can be taken at each origin, only one target is possible at the ICT. The same security guarantee can be achieved for virtual calls because only one class of objects can be created at an origin (Section 2.2). However, we need to track origins as function addresses are propagated throughout the program in a way similar to how taint is propagated -the origin is the source of the taint, and the ICT is the sink. If an object is copied to another object, we essentially create a new object using its class' copy constructor or copy assignment operator. There is thus no need to propagate the origin for objects.To address the challenge, we propose a hybrid definition of origin sensitivity that combines the origin with call-site sensitivity. More specifically, we relax the definition of the origin as the code location where the related code pointer is most recently updated. As such, we keep using the object construction site alone as the origin for virtual calls. Table 1 demonstrates the hybrid origin sensitivity's capability in reducing the largest EC size as compared to call-site sensitivity [21]. Common CFI policies cannot handle such cases because there is not sufficient information in the control flow to separate these targets apart. A similar case is shown in Fig. 4 of Section 4 with the code snippet.3Bjarne Stroustrup's C++ Style and Technique FAQ: "To create an object you need complete information. Large ECs are the weakest link in a CFI system since they provide the most leeway in "bending" the control flow within the CFI policy• Security: context-sensitive CFI systems, including OS-CFI, have more complex reference monitors to collect and maintain the contextual information. As previously mentioned, any defense for C++ programs must protect both virtual calls and C-style ICTs.A CFI system consists of three major components: the CFI policy, the CFG generation, and the enforcement mechanism. OS-CFI enforces an adaptive CFI policy that applies either origin or call-site sensitivity for each ICT and adopts the shadow stack to protect returns. OS-CFI's CFG is generated with a precise context-, flow-, and field-sensitive static pointsto analysis [36]. Note that origin sensitivity itself uses 1-call-site on its origins for C-style ICTs (Section 2.2). We adopt this policy to improve the performance without sacrificing the security: origin sensitivity is a powerful context that can substantially break down large ECs, but it has to collect and maintain more metadata at the run-time. A CFG must be complete to ensure that the resulting CFI system has no false positives (valid control flows reported as invalid). We represent these CFGs as a set of tuples:• Call-site sensitive CFG: each tuple of this CFG has the following form: (CS 1/2/3 , I i , T last store to the related function pointer; while I i is where the function pointer is actually called. I o is the location where the receiving object of a virtual call is constructed.We use the C++ code in Fig. 2 to illustrate how the CFGs are generated (and later enforced). SVF constructs a whole-program sparse value-flow graph (SVFG) that conservatively captures the program's def-use chains. It is an on-demand context-, flow-, and field-sensitive points-to analysis based on the SVFG. It improves the precision by refining away imprecise value-flows in the SVFG with strong updates [34]. Next, we describe how OS-CFI generates the related tuples for the indirect calls in Fig. 2 since they are the more complex cases.In Fig. 2, Base has a protected member function pointer fmt, which is called by Base.print and Child.print. SUPA can create a def-use chain from Line 18 to the assignment of the fmt field at Line 12 because it is field-sensitive. Note that SUPA is precise enough to exclude targetB from the points-to set of fmt at Line 18. Specifically, we create a hash table for each CFG and instrument the program (at the LLVM IR level) to collect the run-time metadata at the origins. Io is the address of the origin (i.e., the instruction that last writes to the function pointer), and CS o is the most recent return address on the call stack. To store the metadata, we use the address of the function pointer as the key and the context, (CS o , I o ), as the value. Fig. 2 has been annotated with the calls to store metadata at Line 13 and 31 for Base.fmt function pointer.Virtual calls: the origin for virtual calls is the location where the object is created (I o ). In C++, every object with virtual functions has a hidden member named vPtr that points to its vTable. After an object is created, its vTable will not be changed.The reason we use vPtr's address as the key (instead of the base address of the object, even though they both can uniquely identify the object) will be clarified as we discuss the metadata storage. The instrumentation is added to each class' constructor so that we only need to insert the code once (instead of once at each location where the constructor is called). With the support of the compiler, run-time, and kernel, MPX can check the bounds of memory access to prevent memory errors, such as buffer overflows and over-reads. In fact, the MPX support will be removed from GCC in version 9.0, after it was just integrated in 5.0 [27]. The bound table is organized and operates like a two-level page table, as shown in Fig. 3: the bounds directory points to the second-level bounds tables; each bounds table contains a number of bound entries. To locate a bound entry, MPX first indexes into the bounds directory to retrieve the base of the related bounds table, and then uses the second index to locate the related bound entry. If the provided pointer content mismatches that in the table, MPX will return an error. Therefore, we can detect any manipulation of these pointers, after they have been stored, without the extra performance penalty.For virtual calls, OS-CFI uses the address of the receiving object's vPtr pointer, which points to the object's vTable, as the key. (CS o , I o )is the origin fetched from the metadata storage; I i represents the address of indirect call instruction; T is the target, i.e., the value of the function pointer. For call-site sensitivity, OS-CFI retrieves the return addresses from the shadow stack and uses a similar method to verify the target under this context. If a stronger protection of the MPX table is necessary, we can use MPX's bound check to protect it, with a small additional overhead [4,22]. Note that this use of the bound check does not conflict with OS-CFI's use of the MPX table since the bound check can be performed with just the bound registers.The hash tables for CFGs are protected as the read-only memory and thus cannot be changed by the attacker. Specifically, TSX keeps tracks of the memory accessed by a transaction and aborts the transaction if any of that memory is changed by others (e.g., attacks). Previous systems often use the debug information for this purpose, which works for function addresses but not as well for call sites because they are not in the symbol table. This approach works most of the time but may not be reliable when the compiler optimization is turned on. We then use the label-as-value extension of Clang to store the label addresses to an array and assign the array to a custom section. In this section, we evaluate how effectively OS-CFI can improve the security by reducing the largest and average EC sizes and what is the performance overhead for some standard benchmarks. Therefore, the quality of its CFGs are affected by SUPA.Advancements and issues of SUPA: SUPA is a scalable and precise context-, flow-, and field-sensitive points-to analysis. We found that, even with a generous budget on a relatively powerful machine (a 16-core Xeon server with 64GB of memory), SUPA can still run out of budgets for complex programs, such as gcc and perlbench. When that happens, SUPA may return wrong results in the points-to sets (e.g., functions with wrong signatures). However, these issues can put OS-CFI to a disadvantage currently -our CFGs are generated by piggybacking on the SUPA as it traverses the SVFG. Accordingly, we cannot generate call-site or origin sensitive edges for these failed ICTs. Because evalRoutines is initialized statically, SUPA will not generate any context for this ICT. Even µCFI can only provide the same precision as context-insensitive CFI in this case because the constraint data (piecet(i)) can potentially be compromised before being captured by µCFI using processor trace [17]. We expect OS-CFI to substantially break down most of these ECs once the problems in SUPA are resolved.Next, we present a few case studies to illustrate how OS-CFI can successfully break down largest ECs in some programs of SPEC CPU2006.6Table 3 and 4 cannot be compared directly because Table 4 includes the ICTs SUPA failed to resolve while Table 3 does not. omnetpp with the largest number of targets -35 targets in context-insensitive CFG. cArray has a clear function that calls discard on every contained object, which in turn calls the virtual destructor. As such, OS-CFI can uniquely identify the specific destructor to be called; i.e., it can enforce a perfect CFI policy at Line 5 since the EC size is 1. I o is the location of the instruction that last writes to the function pointer (Line 7), while CS o is the call sites of the store function (Line 18 Because HMMFileRead is called in the main function, callsite sensitivity is not useful for this case at all because there is just one call site. We experimented with two real-world exploits and one synthesized exploit to show how OS-CFI can block them. We experimented with two vulnerabilities, CVE-2015-8668 in libtiff and CVE-2014-1912 in python. CVE-2015-8668: This is a heap-based buffer overflow caused by an integer overflow. Although all twelve origins are possible for the ICT at Line 3, the run-time context allowed us to uniquely identify the only valid target. CVE-2014CVE- -1912 this buffer overflow in python-2.7.6 is caused by the missing check of buffer size ( Py_buffer has a member of the type PyTypeObject, which contains a function pointer tp_hash. Our system also successfully prevented this exploit.In both cases, OS-CFI not only blocked the exploits but also constrained the vulnerable ICTs to a single target at run-time. The buffer overflow in isEmployee can overwrite res to always return true.OS-CFI prevented both exploits. All the experiments were conducted on a server with the Xeon E3-1275 processor and 64 GB of memory, running the 64-bit Ubuntu 16.04.5 LTS Server system. Other return protection can be integrated with OS-CFI too, such as shadow stack [10] and Intel CET [19], with different security and performance impacts. The performance of OS-CFI is better than PathArmor (8.5%) [38] and PittyPat (12.7%) [14], even though OS-CFI is a whole program protection while PathArmor only protects a few selected syscalls and PittyPat uses separate threads to parse processor traces (this reduces the number of available CPU cores by half). Compared to the original SUPA, it took OS-CFI 5.3% longer on average to analyze these benchmarks, measured on the same machine as the performance evaluation. However, the addition of context imposes stringent demands on the system design, leading to more trade-offs and opportunities: first of all, a context-sensitive CFI system requires context-sensitive CFGs. However, scalable path-sensitive points-to analysis, needed by systems like PathArmor and PittyPat, is still unavailable; The second challenge is how to securely collect, store, and use contextual information with minimal performance overhead. OS-CFI uses the stock kernel, whose general MPX support is sufficient.OS-CFI derives its CFGs from a context-, flow-, and fieldsensitive static points-to analysis. This securely conveys the constraint data to the monitoring process. It can guarantee the integrity of all code pointers in the program by separating them and related critical data pointers in a protected safe memory region [23]. By considering the origins of function pointers and objects during the verification of control transfers, we can significantly improve the security of CFI by reducing the largest and average EC sizes. Our prototype is available as an open-source project at https: //github.com/mustakcsecuet/OS-CFI.