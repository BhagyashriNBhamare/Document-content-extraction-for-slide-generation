Intel has introduced a hardware-based trusted execution environment, Intel Software Guard Extensions (SGX), that provides a secure, isolated execution environment, or enclave, for a user program without trusting any underlying software (e.g., an operating system) or firmware. However, exploiting this channel in practice is challenging because 1) measuring branch execution time is too noisy for distinguishing fine-grained control-flow changes and 2) pausing an enclave right after it has executed the code block we target requires sophisticated control. When we want to run security-sensitive applications (e.g., processing financial or health data) in the public cloud, we need either to fully trust the operator, which is problematic [16], or encrypt all data before uploading them to the cloud and perform computations directly on the encrypted data. Unlike previous side channels, such as cache-timing channels, the page-fault side channel is deterministic; that is, it has no measurement noise.The controlled-channel attack has a limitation: It reveals only coarse-grained, page-level access patterns. To avoid such problems, Intel SGX hides all performance-related events (e.g., branch history and cache hit/miss) inside an enclave from hardware performance counters, including precise event-based sampling (PEBS), last branch record (LBR), and Intel Processor Trace (PT), which is known as anti side-channel interference (ASCI) [24]. The branch-prediction side-channel attack aims to recognize whether the history of a targeted branch instruction is stored in a CPU-internal branch-prediction buffer, that is, a branch target buffer (BTB). After that, the attacker can probe the shared BTB entry by executing the shadow branch instruction and determine whether the targeted branch instruction has been taken based on the execution time ( §3). In summary, an attacker should have 1) a permission to freely access or manipulate the virtual address space, 2) access to the BTB anytime before it is overwritten, and 3) a method that recognizes branch misprediction with negligible (or no) noise.In this paper, we present a new branch-prediction sidechannel attack, branch shadowing, that accurately infers the fine-grained control flows of an enclave without noise (to identify conditional and indirect branches) or with negligible noise (to identify unconditional branches). When attacking slidingwindow RSA-1024 decryption, we successfully inferred each bit of an RSA private key with 99.8% accuracy. Finally, we suggest hardware-and software-based countermeasures against branch shadowing that flush branch states during enclave mode switches and utilize indirect branches with multiple targets, respectively ( §5). We demonstrate that branch shadowing successfully identifies fine-grained control flow information inside an enclave in terms of basic blocks, unlike the state-of-the-art controlledchannel attack, which reveals only page-level accesses. We make branch shadowing very precise by 1) exploiting Intel PT and LBR to correctly identify branch history and 2) adjusting the local APIC timer to precisely control the execution inside an enclave. We explain Intel SGX and two other processor features, branch prediction and LBR, closely related to our attack. SGX provides a set of instructions to allow an application to instantiate an enclave that secures the code and data inside it against privileged software such as an OS or a hypervisor, hardware firmware, and even hardware units except for the CPU. However, we observe that SGX does not clear all cached system state such as branch history ( §3). Branch instructions can severely reduce instruction throughput since the processor cannot execute past the branch until the branch's target and outcome are determined. Branch target prediction is a procedure to predict and fetch the target instruction of a branch before executing it. For branch target prediction, modern processors have the BTB to store the computed target addresses of taken branch instructions and fetch them when the corresponding branch instructions are predicted as taken.BTB structure and partial tag hit. For example, in a 64-bit address space, if ADDR [11:0] is used for index, instead of using ADDR [63:12] for a tag, only a partial number of bits such as ADDR [31:12] is used as the tag. First, the processor predicts that a forward conditional branch-a conditional branch whose target address is higher than itself-will not be taken, which means the next instruction will be directly fetched (i.e., a fall-through path). In Skylake CPUs, the LBR stores the information of up to 32 recent branches, including the address of a branch instruction (from), the target address (to), whether the branch direction or branch target was mispredicted (it does not independently report these two mispredictions), and the elapsed core cycles between LBR entry updates (also known as the timed LBR). Also, the LBR can selectively record branches taken in user space, kernel space, or both.Since the LBR reveals detailed information of recently taken branches, an attacker may be able to know the finegrained control flows of an enclave process if the attacker can directly use the LBR against it, though he or she still needs mechanisms to handle not-taken branches and the limited capacity of the LBR. We explain our threat model, which is based on the original threat model of Intel SGX and the controlledchannel attack [60]: an attacker has compromised the operating system and exploits it to attack a target enclave program.First, the attacker knows the possible control flows of a target enclave program (i.e., a sequence of branch instructions and their targets) by statically or dynamically analyzing its source code or binary. Self-paging [22] and live re-randomization of address-space layout [15] inside an enclave are outside the scope of our attack.Second, the attacker infers which portion of code the target enclave runs via observable events, e.g., calling functions outside an enclave and page faults. Fourth, the attacker recognizes the shadow code's branch predictions and mispredictions by monitoring hardware performance counters (e.g., the LBR) or measuring branch misprediction penalty [3,12,13]. The branch shadowing attack aims to obtain the finegrained control flow of an enclave program by 1) knowing whether a branch instruction has been taken and 2) inferring the target address of the taken branch. Because of the size limitations of the BTB, BPU, and LBR, the branch shadowing attack has to synchronize the execution of the victim code and the shadow code in terms of execution time and memory address space. [1,[5][6][7][8][9][10], marked with ⋆ in (b)) of the shadowing instance depends on the branching result (i.e., taken or not at [1] in (a)) of the victim instance.nipulate the local APIC timer and the CPU cache ( §3.6) to frequently interrupt an enclave process execution for synchronization, adjust virtual address space ( §3.7), and run shadow code to find a function the enclave process is currently running or has just finished running ( §3.8). Without the branch history, this branch is always mispredicted because of the static branch prediction rule ( §2.2). To make a BTB entry collision [13], we align the lower 31 bits of the shadow code's address (both the branch instruction and its target address) with the address of the victim code.When the victim code has been executed before the shadow code is executed, the branch prediction or misprediction of the shadow code depends on the execution of the victim code. Therefore, we think that the RDTSC-based inference is difficult to use in practice and thus we aim to use the LBR to realize precise attacks, since it lets us know branch misprediction information, and its elapsed cycle feature has little noise (Table 1). To avoid this problem, we intentionally insert an indirect branch right after the target branch, making all branches properly record their elapsed time in separate CYC packets. Intel PT's timing information about branch misprediction has a much smaller variance than RDTSCP-based measurements (Table 1). 2 Enclave execution is interrupted and No Take (b) Case 2: The target conditional branch has not been taken (i.e., either not been executed or been executed but not taken). 5 Finally, by disabling and retrieving the LBR, we learn that the shadowed conditional branch has been correctly predicted-it has been taken as predicted. We think that this correct prediction is about branch prediction because the target addresses of the two branch instructions are different; that is, the target prediction might be failed. 5 Finally, by disabling and retrieving the LBR, we learn that the shadowed conditional branch has been mispredicted-it has been taken unlike the branch prediction.Initializing branch states. To solve this problem, after the final step of each attack iteration, we additionally run the shadow code multiple times while varying the condition (i.e., interleaving taken and not-taken branches) to initialize branch states. Second, an attacker can infer the result of the condition evaluation of an if-else statement because an if block's last instruction is an unconditional branch to skip the corresponding else block.Unlike a conditional branch, an unconditional branch is always taken; i.e., a branch prediction is not needed. Thus, we use the elapsed cycles of a branch that the LBR reports to identify the branch target misprediction penalty, which is less noisy than RDTSC (Table 1). 1 The enclave has not yet executed the unconditional branch in the victim code, so the BTB has no information about the branch.2 Enclave execution is interrupted, and the OS takes control. 4 The BPU correctly predicts the shadowed unconditional branch's target, because the target unconditional branch has never been executed. We found that the LBR always reports that every taken unconditional branch has been predicted irrespective of whether it mispredicted the target (undocumented behavior). We explain how we can infer whether a target indirect branch inside an enclave has been executed by shadowing its branch history. 5 Finally, by disabling and retrieving the LBR, we learn that the shadow ... Memory CPU (isolated) 0x004⋯532:Does not take n/a n/aTake? (b) Case 6: The target indirect branch has not been taken code's indirect branch has been incorrectly predicted-it has not been taken, unlike the branch prediction.Next, we explain the case in which an indirect branch has not been taken (Case 6). 3 The OS enables the LBR and then executes the shadow code. 5 Finally, by disabling and retrieving the LBR, we learn that the shadow code's indirect branch has been correctly predicted-it has not been taken, as predicted.Inferring branch targets. The branch shadowing attack needs to consider cases that change (or even remove) BTB entries because they make the attack miss some branch histories. We empirically identified that the Skylake's BTB has 4,096 entries, where the number of ways is four and the number of sets is 1,024 ( §5.1). If the branch shadowing attack could not check a BTB entry before it has been changed, it would lose the information.To solve this problem, we interrupt the enclave process as frequently as possible and check the branch history by manipulating the local APIC timer and the CPU cache. ADD takes only one cycle in the Skylake CPU [25] such that our frequent timer can interrupt a victim enclave per every ∼50 cycles. To interrupt an enclave process more frequently, we selectively disable the L1 and L2 cache of a CPU core running the victim enclave process by setting the cache disable (CD) bit of the CR0 control register. With the frequent timer interrupt and disabled cache, about 4.71 ADD instructions were executed between two timer interrupts on average (standard deviation: 1.96 with 10,000 iterations). Also, the attacker can use the page-fault side channel [60] to synchronize attacks in terms of pages. process runs in the core under the branch shadowing attack, its execution would affect the overall attack results. The branch shadowing attack's goal is not to overcome countermeasures against branch-prediction side-channel attacks, e.g., exponent blinding to hide an exponent value, not branch executions [34]. This function has two conditional branches (jne) marked with ⋆ whose executions depend on each bit (ei) of an exponent. Also, to differentiate each loop execution, we shadow unconditional branches that jump back to the loop's beginning.We evaluated the accuracy of branch shadowing by attacking RSA-1024 decryption with the default key pair provided by mbed TLS for testing. The sliding-window size was five.On average, the branch shadowing attack recovered approximately 66% of the bits of each of the two CRT exponents from a single run of the victim (averaged over 1,000 executions). This number of runs is small compared to existing cache-timing attacks, which demand several hundreds to several tens of thousands of runs to reliably recover keys [20,35,65]. Instead of using the LBR, we measured how long it takes to execute the shadow branches using RDTSCP while maintaining other techniques, including the modified local APIC timer and victim isolation. We found that mbedtls_mpi_exp_mod conditionally called mpi_montmul (marked with +) according to the value of ei and both functions were located on different code pages. However, as Figure 6 shows, because of the sliding-window technique, the controlledchannel attack cannot identify every bit unless it knows W[wbits]-i.e., this attack can only know the first bit of each window (always one) and skipped bits (always zero). Since the BTB and BPU benefit from local and global branch execution history, there would be a performance penalty if these states were flushed too frequently.We estimate the performance overhead of our countermeasure at different enclave context switching frequencies using a cycle-level out-of-order microarchitecture simulator, MacSim [30]. To simulate branch history flushing for every enclave context switch, we modified MacSim to flush BTB and BPU for every 100 to 10 million cycles; this resembles enclave context switching for every 100 to 10 million cycles. Figure 8 shows the BTB hit rate, whereas Figure 9 shows the BPU correct, incorrect (direction prediction is wrong), and misfetch (target prediction is wrong) percentages. The BTB and BPU statistics are also barely distinguishable beyond a flush frequency of 100k cycles.According to our measurements with a 4GHz CPU, about 250 and 1,000 timer interrupts are generated per second in Linux (version 4.4) and Windows 10, respectivelyi.e., a timer interrupt is generated for every 4M and 1M cycles, respectively. It obfuscates a set of branch instructions into a single indirect branch, as inferring the state of an indirect branch is more difficult than inferring those of conditional and unconditional branches ( §3.5). To emulate conditional execution, the CMOV instructions in Figure 10b update the target address in r15 only when a or b is zero. Zigzagger's approach has several benefits: 1) security: it provides the first line of protection on each branch block in an enclave program; 2) performance: its overhead is at most 2.19× (Table 5); 3) practicality: its transformation demands neither complex analysis of code semantics nor heavy code changes. Third, as with the controlled-channel attack, the branch shadowing attack needs repetitions to increase attack accuracy, which can be prohibited by a state continuity solution [55]. This attack would be necessary if a victim enclave process has self-modifying code or uses remote code loading, though this is outside the scope of our threat model ( §3.1). Also, Costan et al. [10] propose a new en-clave design to prevent both page-fault and cache-timing side-channel attacks. In this paper, we presented and evaluated the branch shadowing attack, which identifies fine-grained execution flows inside an SGX enclave. Figure 11 shows how we modified the lapic_next_deadline() function specifying the next TSC deadline and the local_apic_timer_interrupt() function called whenever a timer interrupt is fired.We made and exported two global variables and function pointers to manipulate the behaviors of lapic_next_deadline() and local_apic_timer_interrupt() with a kernel module: lapic_next_deadline_delta to change the delta; lapic_target_cpu to specify a virtual CPU running a victim enclave process (via a CPU affinity); and timer_interrupt_hook to specify a function to be called whenever a timer interrupt is generated. Specifically, we focus on examples in which the controlled-channel attack cannot extract any information, e.g., control flows within a single page. The branch shadowing was able to infer the format string by checking the switch-case statement in Lines 4-13 and the types of input arguments to this function according the switch-case statement in Lines 15-23.