We present Miranda, an efficient mix-net design, which mitigates active attacks by malicious mixes. Each active attack-including dropping packets-leads to reduced connectivity for corrupt mixes and reduces their ability to attack, and, eventually, to detection of corrupt mixes. For example, services like WhatsApp and Signal, which offer protection of messages through end-to-end encryption, gained popularity over the past years. However, as research has shown [47,40,42,41], Tor offers limited security guarantees against traffic analysis.The need for strong anonymity systems resulted in renewed interest in onion mixnets [12]. Onion mixnets are an established method for providing provable protection against meta-data leakage in the presence of a powerful eavesdropper, with low computational overhead. Early mixnets suffered from poor scalability, prohibitive latency and/or low reliability, making them unsuitable for many practical applications. Onion mixnets offer strong anonymity against passive adversaries: a single honest mix in a cascade is enough to ensure anonymity. However, known mixnet designs are not robust against active long-term traffic analysis attacks, involving dropping or delaying packets by malicious mixes. It is challenging to identify and penalize malicious mixes while retaining strong anonymity and high efficiency. We present security arguments that demonstrate the effectiveness of Miranda against active attacks. This allows Miranda to mitigate corrupt mixes, without requiring expensive computations.Miranda disconnects corrupt mixes by carefully gathering evidence of their misbehavior, resulting in the removal of links which are misused by the adversary. These include (1) a fixed set of mixes (no churn), (2) a majority of benign mixes (no Sybil), (3) reliable communication and efficient processing (even during DoS), and (4) synchronized clocks. Our paper makes the following contributions:• We present Miranda, an efficient, low-cost and scalable novel design that detects and mitigates active attacks. • We propose an encoding for secure loop messages, that may be used to securely test the network for dropping attacks -extending traditional mix packet formats for verifiability. • We analyze the security properties of Miranda against a wide range of attacks.Overview. In Sections 4 and 5, we detail the core protocols of Miranda, which detect and penalize active attacks. In Section 7, we evaluate the security properties of Miranda against active attacks. In this section, we outline the general model of the Miranda design, define the threat model, and motivate our work by quantifying how active attacks threaten anonymity in mix networks. See discussion in Section 9 of this and other practical challenges.Messages are end-to-end layer encrypted into a cryptographic packet format by the sender, and the recipient performs the last stage of decryption. At the end of the round, each mix forwards all packets to their next hops. Changing the binary pattern of packets by removing a single layer of encryption prevents bit-wise correlation between incoming and outgoing packets. The packet format should also allow senders to encode arbitrary routing information for mixes or recipients. We allow arbitrary number of malicious clients but assume that there are (also) many honest clients -enough to ensure that any first-mix in a cascade, will receive a 'sufficient' number of messages in most rounds -say, 2ω, where ω is sufficient to ensure reasonable anonymity, for one or few rounds.In addition, Miranda assumes reliable communication between any pair of honest participants, and ignores the time required for computations -hence, also any potential for Miranda-related DoS. In practice, communication failures will occur; see discussion in Section 9 of this and other practical challenges.We denote by n the total number of mixes in the network (|M| = n), n m of which are malicious and n h are honest (n = n m + n h ). Anonymity?Active attacks, like dropping messages, can result in a catastrophic advantage gained by the adversary in linking the communicating parties. More precisely, although the communication is over cascades that might contain malicious mixes, the Miranda design aims to provide protection which is indistinguishable from the protection provided by an 'ideal mix', i.e., a single mix node which is known to be honest.The key goals of Miranda relate to alleviating and discouraging active attacks on mix networks, as they have a significant impact on the anonymity through traffic analysis. Every active attack by a rogue mix results, with a non-negligible probability, in the removal of at least one link connected to the rogue mix -or even removal of the rogue mix itself. In Miranda, as in other synchronous mixnet designs, time is broken into rounds, and in each round, a mix 'handles' all messages received in the previous round. Epochs are used to manage Miranda; the beginning of each epoch includes announcement of the set of cascades to be used in this epoch, after a selection process that involves avoidance of mixes detected as corrupt -and of links between two mixes, where one or both of the mixes reported a problem.The process of selecting the set of cascades for each epoch, is called the inter-epoch process, and is performed by a set of d servers refered to as directory authorities, following [14], which maintain a list of available mixes and links between them. Namely, cascades exclude links that were reported, or mixes involved in too many reports, or detected via Miranda's communitybased attacker detection mechanisms, described in Section 6. However, we find it useful to maintain thresh as a separate value, to allow the use of larger value for thresh to account for a number of failures of honest mixes or links between honest mixes, when the Miranda design is adopted by a practical system.Significant, although not prohibitive, processing and communication is involved in the inter-epoch process; this motivates the use of longer epochs. As we explain in Subsection 2.2, a practical system deploying Miranda should use a lower-layer protocol to deal with (even severe) packet losses, and we developed such efficient protocol -see [5]. For each mix in the cascade, we include in the routing information the exact round number during which the mix should receive the packet and during which it should forward it. For example, if desired, answering the query for p k could be done in round i + 6 instead of limiting it to the same round.i i + 1 i + 2 i + 3 Client M 1 M 2 M 3 p K p K R 1 p K R 2 p K R 3 (a) Successfulstatement confirming that a packet p was received by mix M i . However, generating receipts for each packet individually incurs a high computational overhead due to costly public key signature and verification operations.To reduce this overhead, mixes gather all the packets they received during round r in Merkle trees [37] and sign the root of the tree once. Similarly, each mix, except the last one, receives a receipt in response to all the packets it forwarded 3 Although Sign and Verify use the relevant cryptographic keys, we abuse notations and for simplicity write them without the keys. If a mix does not receive an aggregated receipt or does not receive a signed confirmation on an aggregated receipt it sent within the expected time slot 4 , the mix disconnects from the misbehaving mix. Anonymity loves company. To prevent potential abuse of this mechanism by a corrupt first mix, which receives over ω messages yet responds with under-ω receipt, these receipts are shared with the directories, allowing them to detect such attacks. Similarly, nobody can reproduce an opening value that is valid for a non-loop packet created by an honest sender.If a loop message fails to complete the loop back, this means that one of the cascade's mixes misbehaved. This allows S to isolate the cascade's problematic link or misbehaving mix which caused the packet to be dropped. To achieve that, if Alice sends β messages in round r, then α·β 1−α additional loop messages are sent alongside the genuine messages.This may seem to only ensure α in the context of the messages that Alice sends but not against an attack on messages sent to Alice. However, notice that if a corrupt mix M i drops messages sent to Alice by an honest sender Bob, then M i faces the same risk of detection -by Bob.If Alice can sample and estimate an upper bound γ on the number of messages that she will receive in a particular round, then she can apply additional defense. To foil this threat, in Miranda, messages are always sent only during the round following their receipt from the application, and after being shuffled with all the other messages to be sent during this round. Therefore, if a loop message fails to complete the loop back to the sender as expected, the client initiates an isolation process, during which it detects and isolates the specific problematic node or link in the cascade. Then, the client chooses another cascade from the set of available cascades and sends future packets and loop messages using the new route. When a client asks an honest mix to prove that it received and correctly forwarded a packet, the mix presents the relevant receipt. To avoid the risk of its detection as a corrupt mix, which would happen if it was a loop message, the corrupt mix may disconnect from the subsequent mix -again losing a link. Therefore, a corrupt mix that drops a packet either loses a link, or risks being exposed (by loop message) and removed from the network.Delaying packets. Therefore, the delaying attack also causes the mix to either lose a link or to be expelled from the system.The combination of packet receipts, link disconnection notices, the isolation process and loop messages, forces malicious mixes to immediately lose links when they perform active attacks. Potentially, this could prevent clients from obtaining the necessary proofs about problematic links, thus preventing them from convincing directory authorities about problematic links. If all mixes cooperate with the directory authority, it is able to isolate and disconnect the problematic link. If a first mix does not send a receipt, the client could have simply chosen another cascade; however, this allows malicious mixes to divert traffic from cascades which are not fully malicious, without being penalized, increasing the probability that clients would select other fully malicious cascades instead. This prevents malicious mixes from excluding semi-honest cascades without losing a link. The inter-epoch process selects a new random set of cascades to be used in the coming epoch, avoiding the links reported by the mixes, as well as any mixes detected as corrupt.Until the inter-epoch terminates and the mixes move to the new epoch, the mixes continue with the intra-epoch process as before; the only difference is that newly detected failures, would be 'buffered' and handled only in the following run of the inter-epoch process, to avoid changing the inputs to the inter-epoch process after it has begun.The inter-epoch process consists of the following steps. Hence, any mix which has more than thresh links disconnected must be faulty (due to the assumption that thresh > n m ), and hence the directories exclude that mix completely and immediately. Namely, consider an undirected graph G = (V, E) where the vertices map to the mixes in the system (V = M), and an edge (M i , M j ) ∈ E means that the link between mixes M i and M j was not dropped by either mix. The filtering mechanism removes all mixes that lost thresh links or more, i.e., {M i | ∀M i ∈ G : Deg G (M i ) ≥ thresh}, where thresh = n m + 1. To allow clients to easily confirm that they use the correct set of cascades, the directory authorities collectively sign the setGraph G Graph G (thresh = n m + 1) Graph G M 1 M 2 Detected M 1 M 2 M 1 Detected Remove M 2 Deg(M 1 ) < thresh(= 3) Deg(M 2 ) ≥ thresh(= 3) Remove M 1 Deg(M 1 ) ≥ thresh(= 2)Figure 3: An illustration of the simple malicious mix filtering (without community detection). This is somewhat challenging, since sampling is normally a random process, which is unlikely to result in exactly the same results in all directory authorities. To achieve this, while preventing the faulty directory authorities from biasing the choice of the seed bits, we can use a cointossing protocol, e.g., [7], among the directory authorities 5 . Encouragingly, many other techniques can be employed; yet, we hope that the following algorithms will be also useful in other applications where applicable, e.g., where community detection is needed.We begin with the following observation.Observation 1. For every two mixes M i , M j that have an edge in (M i , M j ) ∈ E, at least one of them is a malicious mix.Observation 1 stems directly from our assumption that honest mixes never fail. Since the aggressive removal of both mixes connected by the failed link from G is not efficient, we adopt the idea of virtual removal of the conflicting pair. Next, the algorithm invokes the VIRTUALPAIRREMOVAL procedure on G to virtually remove a pair of mixes from G (line 14). We use the thresh variable to keep track of the virtually removed malicious mixes and the global thresh value is decreased only when a malicious mix was actually detected (line 4), and the rest only change the virtual threshold thresh . A removal sequence is legitimate if every removed node v j has at least one edge.Let us define the graph G i to be the resulting graph after removing from G the node M i together with all its neighbors, denoted as N(M i ). 1: procedure SIMPLEMALICIOUSFILTERING(G,thresh ) 2: for everyM i ∈ G s.t. Deg G (M i ) ≥ thresh do 3:M i is malicious (remove from G, G, M). By observing G 1 , we know that at least one of the mixes M 2 , M 3 are malicious (since they share an edge), therefore, µ i ≥ 1 since we successfully identified a malicious mix which is not in {M 1 ∪ N(M 1 )}. Alternatively, the same argument can be made regarding M 2 and M 4 instead of the pair M 2 and M 3 . Therefore, an execution of theM 2 M 3 M 4 M 5 M 6 M 7 M 8 M 9Detected Detected (e) If M 2 and M 3 were not detected as malicious as explained in (b), then after the removal of M 1 in (c) they will be detected, because the removal of M 1 causes n m = 4 → n m = 3. After the removal of M 1 , M 2 and M 3 , the algorithm cannot classify M 4 as malicious based on its neighbors, since M 4 only dropped one link. If desired, there is always the opportunity to execute the aggressive pair removal technique after the CommunityDetection algorithm to potentially remove more malicious mixes (with price of possible removal of an honest mix). Also, randomly picking a pair of mixes that share an edge in G might not always be the optimal strategy. As discussed in Section 4, a malicious mix that drops a packet sent from a preceding mix or destined to a subsequent mix, loses at least one link; in some cases, the malicious mix gets completely excluded. However, the adversary might try other approaches in order to link the communicating users or gain advantage in the network, as we now discuss.A malicious first mix can refuse clients' packets; however, such attack is imprudent, since clients can migrate to other cascades. If the malicious mix acknowledges the receipt, the malicious mix is exposed when the client performs the isolation process: the client can obtain a signed receipt proving that the malicious mix received the packet on time, and also the acknowledged receipt from the honest mix that dropped the delayed packet. For example, in the (n − 1) attack [45] applied to the full network, the adversary tracks a target packet from Alice by blocking other packets from arriving to an honest mix, and instead injecting their own packets. Another example is the intersection attack [8], where the adversary tries disconnecting target clients. A malicious entry mix may drop packets from clients, since losing a link to a client is not a serious 'penalty'; but in Miranda, clients then use a witness mix (see Section 4.4) -forcing the mix to either relay their packets, or -lose a link to a mix or risk discovery, as discussed above.Miranda enforces a minimum number of ω packets for mixing by the entry mix. This is designed to protect the rare cases where a client sends via an entry mix which is used only by few (or no) other clients, which could allow an eavesdropper attack; we now explain why this cannot be abused to facilitate an active attack (by the first mix). Attackers can try to maximize their chances by: (1) increasing the probability that fully malicious cascades are included in the set C produced by the directory authorities during the inter-epoch process, and/or (2) increasing the probability that clients pick a fully malicious cascade from C during an epoch. Interestingly, we found that such an attack only slightly increases the chance of selecting a fully malicious cascade -while significantly increasing the chance of selecting a fully honest cascade (see Claim 5). Figure 6 and Figure 7 present the probability of picking a fully malicious cascade depending on the number of mixes colluding with the adversary and the percentage of lost links.Once n c cascades are generated, the adversary could try to bias the probability of clients choosing a fully malicious cascade. We illustrate in Figure 8 the attack cost, expressed as the number of links the adversary must affect in order to achieve a certain probability of success in shifting clients to a fully malicious cascade. Furthermore, using just 1% of the possible cascades suffices to reduce success probability to about 10% or less.ets, it does not know the destination. Hence, even if the mix would know the identity of the sender, e.g., by being the first mix, the packet can still be a loop message with probability at least α.Note that a malicious non-last mix that drops a loop message, yet sends a receipt for it and remains connected to the next mix, would be proven malicious and excluded from the network. Therefore, these messages can be dropped without detection.However, dropping of messages by the last mix can also be done against the ideal mix (see Section 2.4), e.g., by a man-in-the-middle attacker. Therefore, mitigating this attack is beyond Miranda goals, and should be handled by the applications adopting Miranda 7 . The discussion in Section 6 presented several community detection techniques to leverage Miranda's reported links information into a detection tool that removes malicious mixes from the system. We now argue that the contribution of these mechanisms is both important and secure. Therefore, the only way for a strategic adversary to abuse these algorithms is to strategically drop links in a way that causes these algorithms to wrongfully remove honest mixes from the system, due to misclassification of honest mixes as malicious. We now argue that the T hresholdDetection and CommunityDetection algorithms are secured against such attack.Claim 7. According to the implementation of Community Detection, the algorithm only removes mix M i ∈ G that satisfies Deg(M i ) > n m − µ i , which according to Claim 1 never happens for honest mixes. Additionally, [12] uses the untraceable return addresses to provide end-to-end receipts for the sender.Receipts were also used in reputation-based proposals. In comparison, Miranda does not depend on the witnesses, and a single one is just used to enhance the design. Miranda rather than focusing on a single mix, looks at the link between the mixes.In the extended reputation system proposed in [22] the reputation score is quantified by decrementing the reputation of all nodes in the failed cascade and incrementing of all nodes in the successful one. Therefore, because a single mix's behavior affects the reputation of all mixes in the cascade, the malicious nodes can intentionally fail a cascade to incriminate honest mixes. If the last mix is not able to present the receipt, then the sender contacts a random node from the cascade, which then asks the last mix to pass the message and attempts to deliver the message.Trap messages and detecting active attacks. However, this idea is limited to detecting only aggressive (n-1) attacks, but mix nodes systematically dropping single packets can operate undetected. Moreover, the authors do not also specify any after-steps or how to penalize misbehaving mixes.The Atom [33] messaging system is an alternative design to a traditional mix networks and uses trap messages to detect misbehaving servers. Challenges for making Miranda practical. The Miranda design includes several significant simplifying assumptions, mainly: (1) fixed set of mixes, (2) majority of benign mixes, (3) reliable communication and processing, and (4) synchronized clocks. We believe that future work may deal with this significant challenge by both minimizing failures, by designing robust underlying mechanisms such as highly-resilient transport layer; and refined assumptions and analysis, e.g., considering incentives and game-theory analysis, to ensure that the system is robust to 'reasonable' levels of failures.These issues are significant challenges for future research, essential towards the implementation of Miranda in practical systems. Recent research in mix networks showed that continuous-time mixes, especially pool mixes, may allow anonymity for low latency communication [44]. Miranda achieves much better efficiency than previous designs, but at the same time quickly detects and mitigates active adversaries. The overall contribution of our work is an efficient and scalable detection and mitigation of active attacks.