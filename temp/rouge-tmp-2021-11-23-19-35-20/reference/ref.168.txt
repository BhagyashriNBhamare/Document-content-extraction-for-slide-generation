Encouraged by the rapid adoption of Single Sign-On (SSO) technology in web services, mainstream identity providers, such as Facebook and Google, have developed Software Development Kits (SDKs) to facilitate the implementation of SSO for 3rd-party application developers. As a conservative estimate in [49], 405 out of Top-1000 applications support SSO services, indicating that SSO login has already become a mainstream authentication method and still continues its strong adoption.Motivated by the prevalence of SSO services, mainstream Identity Providers (IdPs) like Google and Facebook, have provided their Software Development Kits (SDKs) to facilitate the implementation of third party services (e.g. IMBD and Uber), which are referred to as the Relying Parties (RP) under the SSO framework.To further enhance flexibility, some high-profile open source projects [3,21] have integrated SSO SDK modules from different IdPs so that an RP application can readily support multiple IdPs at the same time. Typically, an SSO SDK provider would release the source code of its SDK and provide documentations, together with simple usage examples. Note that if the internals of a SDK already contain vulnerabilities, then all RP applications using the vulnerable SDK become susceptible. The first type reasons about the specification of the standard SSO protocols [23,39] by different methods including model checking [5,7,15,19], cryptographic proof [11] and manual analyses [34]. The other type aims to discover vulnerabilities of real-world SSO implementations via network traffic analysis [43,44,47,48] and large-scale automated testing [18,33,49,51]. We have thus developed new techniques including request order scheduling and multi-party coordination for this kind of multi-party applications.We have implemented a full-featured prototype of S3KVetter and applied it to check 10 popular SSO SDKs. We have systematically conducted an in-depth security analysis on 10 commercially deployed SSO SDKs, the first of this kind. We have designed and implemented S3KVetter to perform security analysis of SDK internals based on dynamic symbolic execution and a theorem prover. In particular, we develop a set of new techniques, including symbolizing request orders and multi-party coordination, to improve symbolic execution for multi-party distributed systems with multiple-lock-step interactions. In an SSO ecosystem, there are three parties: a User, a Relying Party server (RP server) and an Identity Provider server (IdP server) 3 . While S3KVetter supports both protocols and both authorization flow types for the web and mobile platforms, we use the authorization code flow of OAuth2.0 under the web platform as the running example throughout this paper.2.1 Authorization Code Flow of OAuth2.0 the information of the user hosted by the IdP ; V. (Step 10-11) The user can then access his information hosted by the RP. (2) The attacker can setup an external machine and use his/her own account to freely communicate with the client, IdP and RP server. Fig. 2 presents the high-level system architecture of S3KVetter, which contains three components: an extended concolic (dynamic symbolic) execution engine, a predicate translator and a theorem prover. Finally, taking the translated predicate tree and our manually developed list of security properties as inputs, the theorem prover reasons about each program path for security property violation. 3 shows the setup of the overall system in which S3KVetter simulates the client device to communicate with the RP server (i.e., SDK) and IdP server. By contrast, S3KVetter, leveraging high-coverage symbolic execution, automatically explores different corner-case situations.Intuitively, the symbolic predicate tree has captured rich semantic information: The leftmost path in Fig. 4 corresponds to the case where the user skips Req0 (i.e.,Step 1 in Fig. 1) and directly sends Req1 (Step 5) to the SDK. Upon receiving Req1, the SSO SDK under test first checks whether the communication uses HTTPS, followed by verifying the existence of a code parameter in the URI. This corresponds to the vulnerability of use-before-assignment of the state variable, as to be detailed in Section 7.3. more thoroughly, S3KVetter should allow attackers to randomly, symbolically select execution orders such as making out-of-order requests, skipping/ replaying requests.We develop a general and simple scheduling algorithm, which does not require any application-specific heuristic from the analyst, to systematically explore execution paths by generating inputs and schedules (i.e., request orders) one by one. Recall that we are interested in the authentication property only, which is typically completed by the last request in the call-flow. We use Fig. 5, which contains three requests Req0, Req1 and Req2, to illustrate how to generate a new schedule as follows:1. The intuition behind this scheme is that S3KVetter Req2 Req2 Req2 Req0 Req1 Input Schedule 1 Schedule 2 Schedule 3 Schedule 4 Time Sequence to bypass logic checks to break multi-step operation Figure 5: Scheduling for out-of-order requests attempts to skip any important logic check, break the multi-step operations or replay requests (as can be seen in Figure 5). For example, the schedule of {Req1, Req2} guides S3KVetter to skip the first request, a key milestone of the SSO business process, which leads to the discovery of the vulnerability of use-before-assignment of the state variable (Section 7.3). However, since the IdP server typically imposes limit on API access rate, a large number of invocations of the external functions can easily hit the control threshold and lead to unexpected responses. If S3KVetter skips this request and directly sends Req1, to exchange for an access token in Step 6, S3KVetter has no choice but to either use an old value or locally generate a seemingly legitimate code. As such, the first approach will get stuck in non-core error-processing paths.The second solution is to check the return type of the external function and then returns a random value of this type without executing the external functions (e.g., DART [22]). Instead of strictly following the IdP's behaviors, S3KVetter modifies the response so that every party has the same synchronized view on the global system state. Once a nonce parameter is consumed, S3KVetter, unlike the real-world IdP server, will first generate a new nonce value internally. Therefore, S3KVetter can internally force its simulated remote IdP Code Example: Fig. 6 illustrates how S3KVetter can coordinate multiple parties with the code example. When exploring Path2 (where we skip Req0), S3KVetter finds that code satisfies the path constraint (code = None) and therefore provides the code for the SDK. The implementation requires to model the IdP server so that S3KVetter, in most cases, can rely on the SDK as the real IdP. On one hand, we follow existing work [5,46] to perform blackbox differential fuzzing analysis (i.e., under different input arguments and app settings) for a better understanding of the conditional checking enforced by real IdPs. Observe from Fig. 4 that the node which checks whether uri contains a code parameter can be represented as (str.contains uri code) in the language of SMT-Lib. The goal of S3KVetter is to detect flawed SDK implementations by checking the logic in the SDK internals. An SSO system involves interactions among the user, the RP server and the IdP server, where any weak communication links (i.e., 11 steps in Fig. 1) can lead to logic flaws. It is therefore more intuitive to define the final security goal (i.e., authentication property) for the RP server, which is the focus of this paper.In particular, we have one key observation to secure the Single Sign-On service: An RP server should login a user if and only if the exact user has actually authorized this specific RP. To be more specific, an RP server can accept a user's login request in Step 5 of Fig. 1 if and only if the exactly same user has authenticated and/or authorized this specific RP in Step 3. A more elaborated example is Clause 6, which can be violated in two different cases: (1) it is possible that an attacker eavesdrops the victim's code and uses it to sign into the RP (i.e., RPsession.uid = victim and IdPsession.uid = attacker) ; (2) it can also be the result of a CSRF attack, in which the attacker makes the victim's browser to send the RP a crafted request with the attacker's code (i.e., RPsession.uid = attacker and IdPsession.uid = victim). For Module 2 in Fig. 2, we choose SMT-Lib v2.0 which uses first-order logic with quantifier to represent the translated predicate tree. In particular, they have covered the two most popular protocols (i.e., OAuth2.0 and OpenID Connect) and both of the widely used authorization grant flows, namely, the implicit flow and the authorization code flow. The number of downloads for each SDK was retrieved on Oct 2017 from PyPI statistics [2] -a website which provides runtime statistics of PyPI published packages. If developers install a SDK directly from its source code (e.g., via official webpage or Git), the suggested way for many IdPs (e.g., Facebook, Weichat, Renren, Douban), then the installation will not be included in the statistics. â€¢ 1 : Facebook SDK supports OIDC, and the other SDKs support OAuth2.0 protocol. Therefore, as shown in Table 1, S3KVetter can achieve 2%-13% higher statement coverage and 2%-19% higher branch coverage for the SDKs under test. This is in line with our expectation for two reasons: Firstly, a SDK often contains functions beyond the scope of SSO (e.g., advertisement, notification, etc.). There is only one requirement for the exploitation of these vulnerabilities 8 : the attacker needs to setup a malicious RP (mRP) and lure a victim user to login to the mRP. Once this condition is satisfied, the attacker can remotely control the victim's account of any RP which uses the vulnerable SSO SDK. We have manually verified all the reported vulnerabilities and found no false positive. Secondly, S3KVetter may not be able to explore all execution paths due to the following limitations: â€¢ The underlying SMT solver assumes a query does not have a feasible solution when it takes too long to solve. Firstly, the analyst should build a sample app, based on the SDK under test, so that S3KVetter can actually execute/ explore the app and thus the target SDK. For instance, the Request-OAuthLib SDK authenticates a user only based on the variable of request.url. 9 While we assume an attacker can control all packets sent to the RP server, only part of these packets would be processed by the SDK.To apply S3KVetter on other multi-party systems, one additional manual step is to develop the required security properties (i.e., the counterpart of Listing 1) for the specific domain of applications. For example, the list of the required security properties for payment services can be developed by codifying the following statement: A merchant M should accept an order if and only if the user has paid to the cashier in the correct amount for that specific order associated with merchant M.Note that the developed scurity property is not necessarily an exhaustive list of all protocol states. â€¢ While our earlier work on model-based security testing for OAuth2.0 (OAuthTester) [49] has the potential, at least in theory, to discover all the vulnerabilities listed in Table 2, our testing shows that OAuthTester can only detect two out of the seven types of vulnerabilities (TLS and state misuse) listed. Such belief is based on the fact that, under the authorization-code flow, the access token is exchanged over a secure TLS connection routed directly between the IdP and RP, without passing through the mobile (client) device which may be controlled/ tampered by the attacker. For any RP using a SDK with the "access token injection" vulnerability, an attacker can remotely inject any access token of her choice to the vulnerable RP. As a result, as long as the attacker can obtain a valid (but different) access token of Alice (e.g., by luring Alice to login to a malicious RP controlled by the attacker), the attacker can log into the vulnerable RP as Alice. Firstly, Clause 4 is violated since the victim RP uses the access token issued to mRP. https://RP.com?state=xxx&code=fake code &access token=victim access token at mRP The exploit only requires the attacker to obtain Alice's access token, e.g., via a malicious RP. Since the code is invalid, the IdP returns error.Therefore, the previously stored access token will not be overwritten. To avoid this problem, it is common for an IdP to issue another long-term "refresh token" to the RP, together with the initial access token. Meanwhile, some SDK developers have enough security expertise and realize the risk of directly storing the value from the end-user (e.g., the access token injection vulnerability). Therefore, these SDK developers attempt to pre-process the user input and stores it only after it has passed the security checkings.Despite these seemingly strict security checks, we will show that the so-called refresh token injection vulnerability is still possible. Such attempts are presented in Listing 4 with much simplification for the ease of presentation.Specifically, this SDK first checks whether there is a refresh token either in the arguments provided by the API caller or in the oauth.token object delivered via a secure server-to-server communication. In the worst case where the user data is for authentication, the attacker can log into the vulnerable RP as the victim user.Note that the above exploit only works for those IdPs (e.g., Fitbit) which do not require client secret in Step 6 of Fig. 8. This may explain why 9 out of 10 SDKs (see Table 2) are vulnerable to different existing attacks related to the state parameter: These SDK developers often rely on the RP developers to implement the state parameter by themselves. However, a so-called "use-before-assignment" vulnerability of the state variable exists. This vulnerability can have high security implication, ranging from sniffing the victim's activity at the vulnerable RP via a "login CSRF" attack [8], to controlling the victim's RP account by account hijacking attack [26]. To protect the access token against leakage, more and more IdPs (e.g., Facebook, Sina, etc.) start to support the MAC token.The MAC token protocol is supposed to be more secure by signing the original bearer token. To support multiple IdPs, a SDK will need to develop an additional layer to provide a new, generalized interface to glue various IdP-specific implementations together.For example, the Request-OAuthLib SDK defines two objects (i.e., oauth. Firstly, the protocol specification [23,39] has been verified by different formal methods including model checking [5,7,15,19,20,36], manual analyses [28,32] and cryptographic proof [11]. For example, al-though [19] discovers the so-called 307 Redirect attack that allows an attacker to learn the victim's password in IdP, real-world SSO systems actually use 302 redirection instead.Despite these theoretical works, the practical implementations of the protocols were often found to be incorrect due to the implicit assumptions enforced by the IdP SDKs [46] or the incorrect interpretation of ambiguous specification [13]. In contrast, relatively few efforts have been devoted to the security analysis on the SDK internals.Asynchronous events studies. Researchers have also used symbolic execution to verify web applications (e.g., [12,42]), but they did not consider challenges arise from multi-lock-step operations or the multi-party coordination. In addition to existing vulnerabilities, S3KVetter successfully discovers 4 new types of vulnerabilities, all of which can result in serious consequences including application account hijacking or user privacy leakage. To reduce the overhead for the constraint solver 11 , we maintain each input field as an individual symbolic variable (e.g., code, state) once these fields are split or decoded.