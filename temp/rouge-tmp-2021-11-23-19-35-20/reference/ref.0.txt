USBFILTER is not only able to block or permit specific device interfaces; it can also restrict interfaces to a particular application (e.g., only Skype can access my webcam). The Universal Serial Bus (USB) provides an easy-to-use, hot-pluggable architecture for attaching external devices ranging from cameras to network interfaces to a single host computer. Attackers may also exfiltrate data from the host by leveraging raw I/O (e.g., using libusb [14]) to communicate with the USB device directly, or bypass the security mechanism employed by the USB device controller by sending specific USB packets to the device from the host USB controller [4]. Unfortunately, the USB Implementers Forum considers defending against malicious devices to be the responsibility of the user [44], who is unlikely to be able to independently verify the functionality and intent of every device simply by its external appearance, and may just plug in USB devices to take a look [43]. USBFILTER can pin devices (e.g., webcams) to approved programs (e.g., Skype, Hangouts) to prevent malicious software on a host from enabling or accessing protected devices.USBFILTER is different from previous works in this space because it enables the creation of rules that explicitly allow or deny functionality based on a wide range of features. SELinux [35] policies and PinUP [13] provide mechanisms for pinning processes to filesystem objects, but USBFILTER expands this by allowing individual USB packets to be associated with processes. The granularity and extensibility of USBFILTER allows it to perform the functions of existing filters [41] while permitting much stronger control over USB devices.The remainder of this paper is structured as follows: In Section 2, we provide background on the USB protocol and explain why it is not great anymore; in Section 3, we discuss the security goals, design and implementation of our system; in Section 4, we discuss how USBFILTER meets our required security guarantees; in Section 5, we evaluate USBFILTER and discuss individual use cases; in Section 6, we provide additional discussion; in Section 7, we explore related work; and in Section 8, we conclude. A USB device refers to a USB transceiver, USB hub, host controller, or peripheral device such as a human-interface USB Device Interface 0 Interface 1 Interface 2 In Out In In Out Out EP 0 EP 0 EP 1 EP1 EP 0 EP 0 EP 0 EP 0 EP 1 EP 1 EP 1 EP 1 EP 2 EP 2 EP 2 EP 2 EP n EP n Figure 1: A detailed view of a generic USB device. When a USB device is attached to a host machine, the host USB controller queries the device to obtain the configurations of the device, and activates a single configuration supported by the device. While the interface provides the basic information for the host operating system to load the driver, the endpoint is the communication unit when a driver talks with the USB device hardware. Per specification, the endpoint 0 (EP0) should be supported by default, enabling Control (packet) transfer from a host to a device to further probe the device, prepare for data transmission, and check for errors. All other endpoints can be optional though there is usually at least EP1, providing Isochronous, Interrupt, or Bulk (packet) transfers, which are used by audio/video, keyboard/mouse, and storage/networking devices respectively. The relative ease with which a USB peripheral can be installed on a host is simultaneously its greatest and most insecure property.The USB subsystem has been expanded in software as well, with Virtio [30] supporting I/O virtualization in KVM, enabling virtual USB devices in VMs, and passing through the physical devices into VMs. Wireless USB (WUSB) [19] and Media Agnostic USB (MAUSB) [16] promote the availability of USB devices by leveraging different wireless communication protocols, making the distinction among local USB devices, virtual ones, and remote ones vanish.Overall, the utility and complexity of USB has been steadily increasing in both hardware and software. Since operating systems implicitly trust any device attached, these hidden functions are enumerated, their drivers are loaded, and they are granted access to the host with no further impediment.Data exfiltration from host machines may be the main reason why USB storage is banned or restricted in enterprise and government environments. While access controls can be bypassed by raw I/O, which communicates to the device directly from userspace (e.g., using libusb [14]), network-based methods are vulnerable to network spoofing (e.g., ARP spoofing [32] and DNS spoofing [36]). The adversary may also launch network attacks in order Figure 2: USBFILTER implements a USB-layer reference monitor within the kernel, by filtering USB packets to different USB devices to control the communications between applications and devices based on rules configured.to enable or access authorized devices from unauthorized processes or devices. • Unauthorized Access: The adversary may attempt to enable or access authorized devices on a host (e.g., webcam, microphone, etc.) via unauthorized software to gain access to information or functionality that would otherwise inaccessible.We assume that as a kernel component, the integrity of USBFILTER depends on the integrity of the operating system and the host hardware (except USB devices). While these goals are not required for full functionality of USBFILTER, we chose to design for stronger security guarantees to ensure that processes attempting to access hardware USB devices directly would be unable to circumvent our system. These rules may not conflict with each other.While the above goals support the security guarantees that we want USBFILTER to provide, we expand upon these to provide additional functionality:G4 Granular. The core USBFILTER component is statically compiled and linked into the Linux kernel image, which hooks the flow of USB packets before they reach the USB host controller which serves the USB device drivers, as shown in Figure 3. To access external USB devices, user-space applications request I/O operations which are transformed into USB request blocks (URBs) by the operating system. Once a driver is bound with an interface, it is able to communicate with that interface using USB packets.Determining the driver responsible for receiving or sending a given USB packet is useful for precisely controlling device behaviors. To recover this important information from USB packets without changing each driver and extending the packet structure, we save the interface index into the kernel endpoint structure during USB enumeration. Furthermore, applications generally submit asynchronous I/O requests, causing the kernel to perform the communications task on a separate background thread.This problem also appears when inspecting USB network device packets, including both wireline (e.g., Ethernet) dongles and wireless (e.g., WiFi) adapters. In these cases, USB is an intermediate layer to encapsulate IP packets into USB packets for processing by the USB networking hardware.These cases are problematic for USBFILTER because a naïve traceback approach will often only identify the kernel thread as the origin of a USB packet. Once verified, new rules will be synchronized with the kernel and saved locally.If no user-defined rules are present, USBFILTER enforces default rules that are designed to prevent impact on normal kernel activities (e.g., USB hot-plugs). Attestation and MAC policy are necessary for providing complete mediation and tamperproof reference monitor guarantees, but not for the functionality of the system. Together with TPM, we also use Intel's Trusted Boot (tboot) 2 After booting into the USBFILTER kernel, the runtime integrity of the TCB (defined in Section 3.1) must also be assured. We also ensure that USBTABLES executes in a restricted environment and that the access to the rules database saved on the disk is protected by defining an SELinux Policy Module and compiling it into the SELinux Policy. Devices cannot initiate USB packet transmission without permission from the controller.We also instrument the virtual USB host controller (vhci) to cover virtual USB devices (e.g., USB/IP). To support other non-traditional USB host controllers such as Wireless USB [19] and Media Agnostic USB [16], USBFILTER support is easily added via a simple kernel API call and the inclusion of a header file.Tamperproof (G2). As such, we define the general conflict between two rules as follows:general_con f lict(R a , R b ) ← ∀C i 񮽙 C : (∃C a i 񮽙 R a ∧ ∃C b i 񮽙 R b ∧ value(C a i ) 񮽙 = value(C b i ))∨ (∃C a i 񮽙 R a ∧ ∧ ∃C b i 񮽙 R b )∨ (񮽙 ∃C a i 񮽙 R a ∧ ∧ ∃C b i 񮽙 R b ). We consider a general conflict to occur if the new rule and an existing rule would fire on the same packet.Based on the general conflict, we define weak conflict and strong conflict as follows:weak_con f lict(R a , R b ) ← general_con f lict(R a , R b ) ∧ action(R a ) = action(R b ). Future work will add general rules, which can be overwritten by new rules.-d|--debug enable debug mode -c|--config path to configuration file (TBD) -h|--help display this help message -p|--dump dump all the rules -a|--add add a new rule -r|--remove remove an existing rule -s|--sync synchronize rules with kernel -e|--enable enable usbfilter -q|--disable disable usbfilter -b|--behave change the default behavior -o| --proc process table rule -v|--dev device table rule -k|--pkt packet table rule -l|--lum LUM table rule -t|--act table rule action ---------------------------------proc: pid,ppid,pgid,uid,euid,gid,egid,comm dev: busnum,devnum,portnum,ifnum,devpath,product, manufacturer,serial pkt: types,direction,endpoint,address lum: name behavior/action: allow|drop Figure 4. The process table lists conditions specific to target applications; the device table contains details of USB devices in the system; the packet table includes important information about USB packets; and the LUM table determines the name of the LUM to be used if needed. The USBFILTER host machine is a Dell Optiplex 7010 with an Intel Quad-core 3.20 GHz CPU with 8 GB memory and is running Ubuntu Linux 14.04 LTS with kernel version 3.13. However, with USBFILTER, the system administrator can guarantee that the headset's microphone remains disabled and cannot be enabled or accessed by users.We use a Logitech H390 Headset to demonstrate how to achieve this guarantee on the USBFILTER host machine:usbtables -a logitech-headset -v ifnum=2,product= "Logitech USB Headset",manufacturer=Logitech -k direction=1 -t dropThis rule drops any incoming packets from the Logitech USB headset's microphone. We can write USBFILTER rules to completely shutdown the keyboard and mouse functionalities:usbtables -a teensy1 -v ifnum=2,manufacturer= Teensyduino,serial=1509380 -t drop usbtables -a teensy2 -v ifnum=3,manufacturer= Teensyduino,serial=1509380 -t dropIn these rules, we use condition "manufacturer" and "serial" (serial number) to limit the Teensy's functionality. Then we add following rules into the host machine:usbtables -a mymouse -v busnum=1,devnum=4,portnum=2, devpath=1.2,product="USB Optical Mouse", manufacturer=PixArt -k types=1 -t allow usbtables -a mykeyboard -v busnum=1,devnum=3, portnum=1,devpath=1.1, product="Dell USB Entry Keyboard", manufacturer=DELL -k types=1 -t allow usbtables -a noducky -k types=1 -t dropThe first two rules whitelist the existing keyboard and mouse on the host machine; the last rule drops any USB packets from other HID devices. In this case study, we show how to use USBFILTER to restrict the use of a Logitech Webcam C310 to specific users and applications.usbtables -a skype -o uid=1001,comm=skype -v serial=B4482A20 -t allow usbtables -a nowebcam -v serial=B4482A20 -t dropThe serial number of the Logitech webcam is specified in the rules to differentiate any others that may be attached to the system as well as to prevent other webcams from being attached. To prevent this attack, we use USBFILTER to prevent all USB packets from a Google Nexus 4 smartphone:usbtables -a n4-charger -v product="Nexus 4" -t drop This rule rule drops any USB packets to/from the phone, which enforces the phone as a pure charging device without any USB functionality. We then compare the results between the USBFILTER kernel with varying numbers of rules loaded and the stock Ubuntu kernel, where USBFILTER is fully disabled, Table 5: Latency (ms) of the fileserver workload with different mean file sizes.as shown in Table 3. The average cost per packet are 2.6 µs and 9.7 µs respectively, including the time to traverse all the 20/100 rules in the kernel, and the time used by the benchmark itself to get the timing and print the result. We choose the fileserver workload in filebench, with the following settings: the number of files in operation is 20; the number of working threads is 1; the run time for each test case is 2 minutes; the mean file size in operation ranges from 1 KB to 100 MB; all other settings are default provided by filebench. We use iperf to measure bandwidths of upstream TCP and UDP communications, where the host machine acts as a server, providing local network access via a Ralink RT5372 300 Mbps USB wireless adapter. To better understand the performance impact of USB-FILTER, we generate a series of real-world workloads to measure typical USB use cases. In this section, we showed how USBFILTER can help administrators prevent access to unauthorized (and unknown) device interfaces, restrict access to authorized devices using application pinning, and prevent data exfiltration. Future work will introduce a new USB networking driver framework to be shared by specific drivers, providing a unified interface for passing PID information into USB packets.Another issue of using process table in USBFILTER rules is TOCTTOU (time-of-check-to-time-of-use) attacks. When process information is crucial to the system, we recommending using USBTABLES to change the default behavior to "drop", make sure that no packet would get through without an explicit matching rule. For example, one can write a LUM to limit the capability of a HID device, such as allowing only three different key actions from a headset's volume control button, which is implemented by GoodUSB as a customized keyboard driver, or disabling sudo commands for unknown keyboards. While users can write some simple rules, we expect that developers will provide useful LUMs, which may require deep understanding of the USB protocol and domain specific knowledge (e.g., SCSI, and will share these LUMs with the community. Due to this, a wide range of attacks have been built on USB including malware and data exfiltration on removable storage [15,34,46], tampered device firmware [27,7], and unauthorized devices [1]. Since our system operates between the device drivers and the USB host controller and traces packets back to their source or destination application, USBFIL-TER can uniquely filter access to any USB interface.While USBFILTER working in the host operating system directly, other USB security solutions make use of virtualization. With a default deny policy for new devices, administrators can restrict connection of unknown devices using granular identifiers such as serial number.