Content Security Policy (CSP) is a W3C standard designed to prevent and mitigate the impact of content injection vulnerabilities on websites by means of browser-enforced security policies. Though CSP is gaining a lot of popularity in the wild, previous research questioned one of its key design choices, namely the use of static white-lists to define legitimate content inclusions. Content Security Policy (CSP) is a W3C standard introduced to prevent and mitigate the impact of content injection vulnerabilities on websites [11]. For instance, the following policy:script-src https://example.com; img-src *; default-src 'none' specifies these restrictions: scripts can only be loaded from https://example.com, images can be loaded from any web origin, and contents of different type, e.g., stylesheets, cannot be included. Moreover, CSP prevents by default the execution of inline scripts and bans a few dangerous JavaScript functions, like eval; these restrictions can be explicitly deactivated by policy writers to simplify deployment, although they are critical for the security of CSP.Simple as it looks, however, CSP is typically hard to deploy correctly on real websites [19,20,1,18] and there are several, diverse reasons for this:1. white-lists are hard to get right. This is an interesting approach to deal with the first problem we mentioned: by selectively enabling only a few known inline scripts, web developers can significantly improve the security of their websites against script injection, while avoiding a major overhaul of their code base by moving inline scripts to external files. However, the other two problems which hinder a wider and more effective deployment of CSP are still largely unsolved, since they both stem from the inherent complexity of accurately predicting the capabilities dynamically needed by real, content-rich web applications. The most important design goal of our proposal is to avoid both a major overhaul of the existing CSP specification and a dramatic change to the logic behind policy writing, so as to simplify its practical adoption by web developers who are already familiar with CSP.Our proposal builds on the pragmatic observation that static white-lists are inherently complex to write down for modern web applications and do not really fit the dynamic nature of common web interactions, so we devise Compositional CSP (CCSP), an extension of CSP based on runtime policy composition. we provide a precise specification of CCSP and we discuss two realistic use cases which may benefit from this extension of the CSP standard. Our experiments show that CCSP is easy to deploy and fully supports the intended functionality of the tested websites (Section 6). Consider a web page w including the following script tag in its HTML contents:<script src="https://a.com/stats.js"/>The stats.js script, in turn, is implemented as follows:This script includes another script from https://b.com and an image from https://c.com and all these contents must be allowed by the content security policy of w to let the web page work correctly. This means that the content security policy of w must not only whitelist https://a.com as a valid source for script inclusion to load stats.js, but it must also white-list all the dependencies of stats.js with their correct type. An appropriate content security policy for w would thus be:script-src https://a.com https://b.com; img-src https://c.comThis approach has two significant problems. Concretely, the example web page w must be changed to bind a randomly generated nonce to its script tag as follows:<script src="https://a.com/stats.js" nonce="ab3f5k"/> Correspondingly, its content security policy is adapted as follows:script-src 'nonce-ab3f5k' 'strict-dynamic'; img-src https://c.comUnder this policy, only those scripts whose tag includes the nonce ab3f5k are allowed to be loaded, irrespective of the web origin where they are hosted. In our example, the script dependency.js can be relocated from https://b.com to https://d.com without any need of updating the content security policy of w. Also, both stats.js and dependency.js can include new libraries without violating the policy of w, again thanks to the presence of 'strict-dynamic'. In our example, if the script stats.js is updated to load its image from https://d.com rather than from https://c.com, or if the script is left unchanged but the image is relocated to https://d.com by means of a HTTP redirect, the content security policy of w must also be updated to ensure a correct rendering of the website. The key observation justifying the design of 'strict-dynamic' is that, if a script loaded by a web page is malicious, it can already attack the page, without any need of abusing 'strict-dynamic' to load other malicious scripts from external domains.However, it is worth noticing that the design of 'strict-dynamic' does not support the principle of least privilege, since it gives all scripts with a valid nonce the ability of putting arbitrary relaxations on script inclusion, even though not every script requires this capability. (In fact, the use of nonces makes particularly troublesome to compare the permissiveness of two content security policies, which instead is a fundamental building block of the upcoming CSP Embedded Enforcement mechanism [17].) Moreover, its design is backward compatible to ensure a seamless integration with the existing CSP deployment.3 Compositional CSP (CCSP) In our view, web developers should be able to keep their content security policies as simple as possible by focusing only on the direct dependencies required by their web pages, largely ignoring other dependencies needed by the contents they include. Different scripts can be assigned different upper bounds on policy relaxation.CSP-When delivering stats.js, the script provider can attach it the following header:CSP-Union script-src https://b.com/dependency.js; img-src https://c.comThe CSP-Union header includes what stats.js needs to operate correctly. In this case, the policy supplied by the script provider is compliant with said upper bounds, hence the browser would update the content security policy of the page as follows:script-src https://a.com/stats.js https://b.com/dependency.js; img-src https://c.comThis policy is reminiscent of the policy we would write using CSP 1.0 or CSP Level 2, but it is assembled dynamically by interacting with the content providers. It is also worth noticing that, since the burden of policy specification is now split between page developers and content providers, CCSP makes it feasible in practice to white-list individual contents rather than entire domains, which makes the resulting policy stricter and more secure. We discussed how our proposal overcomes some important limitations of CSP, but we now observe that these improvements come with a cost on the content providers, which in our proposal become actively involved in the policy specification process. Developers at a.com may want to mitigate the impact of vulnerabilities in the b.com library, since the end user of the advertisement library may be unaware of the inclusion of external contents and just blame the developers of a.com for any security issue introduced by the advertisement system. The a.com developers can thus attach the following headers to their library: This way, the developers at a.com declare their need of including a script by b.com, but they only grant it enough capabilities to relax the content security policy of the embedding page to white-list more images from its own domain (using any protocol) and nothing more. We abstract from the details of the matching algorithm of CSP and we just write matches(u, se) if u matches any of the source expressions in the list se.We let P stand for the set of the content security policies and we let p range over it. We let stand for the binary relation between content security policies such that p 1 p 2 if and only if all the content inclusions allowed by p 1 are also allowed by p 2 . It includes a content security policy specifying the initial content restrictions to be applied to the protected resource;2. We call R a relaxation policy and we refer to the pair (p, R) as the protection state of the protected resource.In the protection state (p, R), a content inclusion is allowed if and only if it is allowed by the content security policy p, whose weakening is subject to the relaxation policy R. Initially, the protection state is set so that p is the policy delivered with the CSP-Compose header of the protected resource and R = {( se 1 , p 1 ), . . . , ( se n , p n )} is the CSP-Intersect header originally attached to it. Let (p, R) be the current protection state and assume that a content is loaded from the URL u. Assume also that the corresponding HTTP response attaches the following headers: a CSP-Union header including the content security policy p and a CSP-Intersect header defining the relaxation policy R . Since the users of the a.com library are not necessarily aware of the inclusion of contents from b.com, the developers at a.com are careful in limiting the capabilities granted to the imported library. In particular, they deploy the following CCSP policy declaring the need of importing a script from b.com, which in turn should only be allowed to load images from the same domain, using any protocol:Hence, even though b.com asked for the ability of loading arbitrary images from the web, the restrictions put in place by a.com actually ensured that the content security policy of the protected page was only relaxed to load images from b.com. Threat Model. Since CCSP ultimately relies on CSP to implement protection, the same limitations apply to it, though attackers who are not aware of the deployment of (C)CSP on the protected resource may see their attacks thwarted by the security policy.Policy Upper Bounds. If we stipulate that CCSP-compliant browsers should only enforce standard content security policies in absence of CCSP policies, which is a reasonable requirement being CCSP an extension of CSP, developers of protected resources can provide support for legacy browsers just by sending both a CCSP policy (enforced by CCSP-compliant browsers) and a standard content security policy (enforced by legacy browsers). This can be done automatically by a server-side proxy and it will produce a policy which is typically more liberal than necessary, yet permissive enough to make the protected resource work correctly (and not necessarily weaker than the policy the average web developer would realistically write using CSP). Notice, however, that this still takes into account the (worst case) expectations of the developers of the protected resource.Though both choices are sensible, we slightly prefer the first option as the default in CCSP, most notably because it is consistent with a similar design choice taken in the latest draft of CSP Embedded Enforcement [17], where the lack of an expected header on an embedded content triggers a security violation on the embedding resource. Assuming a reasonably large deployment of CCSP by content providers, developers who are willing to deploy a standard content security policy on their websites would have a much simpler life if they decided to run CCSP instead, because the policies written in the CSP-Compose headers are a subset of the policies which would need to be written using the standard CSP; moreover, the direct dependencies of the protected resource are much simpler to identify than the indirect ones. Developers of protected resources can write CSP-Intersect headers for CCSP-compliant providers and trust that they provide appropriate CSP-Union headers for their contents; at the same time, however, developers can also include the dependencies of legacy content providers directly in the CSP-Compose header. One may argue that it is difficult enough to get first parties to adopt CSP, let alone convince third parties to write CCSP policies. To evaluate the benefits offered by CCSP, we built and extensively analyzed a dataset of CSP violations collected in the wild, finding a number of cases which are difficult to accommodate in CSP (and, indeed, were not correctly supported by policy writers). In particular, we focused on two categories of violations which are difficult to fix robustly in CSP, but are simple to address with CCSP: (i) violations triggered by the recursive inclusion of contents by any of the scripts loaded on the website, and (ii) violations triggered by HTTP redirects towards URLs which are not white-listed in the content security policy of the website. Both these scenarios are common, but challenging for CSP, since they involve elements which are not under the direct control of the developers of the websites.To detect the violations in the first category, we relied on the structure of the collected violation reports, which includes both the URI of the website (named document-uri) and the URI of the element triggering the violation (named source-file); if there is a mismatch between the two, we put the violation into the first category. One can readily observe that scripts often need to recursively include other scripts as expected, but they also typically load a bunch of other contents of different nature, most notably fonts, frames and images. The use of 'strict-dynamic' can fix the 96 violations related to the script-src directive, which however represent only the 41.6% of the total number of violations in this category. It inspects all the incoming HTTP(S) responses looking for CCSP headers: if they are present, the extension parses 6 https://developer.chrome.com/extensions/ webRequest them following the syntax described in the present paper and then strips away standard CSP headers (if any) to avoid conflicts. com, loaded by a script from https://abs.twimg.com.Since twimg.com is controlled by Twitter, we decided to assume a high level of trust for all its sub-domains and we wrote the following CSP-Intersect header for the homepage of twitter.com: CSP-Intersect: scope *.twimg.com; script-src https://*; default-src 'none';This gives contents hosted on twimg.com the ability of relaxing the content security policy of Twitter to load arbitrary scripts over HTTPS. We fixed it by writing the following CSP-Intersect header for the homepage of www.orange.sk: CSP-Intersect: scope static.hotjar.com; frame-src *.hotjar.com; default-src 'none';We then attached the following CSP-Union header to the script from vars.hotjar.com: CSP-Union: frame-src https://vars.hotjar.com/rcj-b2 c1bce0a548059f409c021a46ea2224.htmlNotice that this time we were able to white-list exactly the required contents, since the whole URL is readily available in the script code. The web developers at www.orange.sk probably noticed these violations and tried to fix them by adding www.google.sk to the img-src directive, but since we were visiting the website from Italy, we got redirected to www.google.it and this domain was not included in the content security policy of www.orange.sk.We then fixed these issues by adding the following information to the headers sent by www.orange.sk: CSP-Intersect: scope www.google.com; img-src *; default-src 'none';and by including the following headers to the redirect sent from www.google.com:CSP-Union:img-src www.google.itNotice that the correct top-level domain is known to the server, because it is also issuing the redirect request.Other Websites. The effectiveness of these proposals is still unclear, since automatically generating content security policies which are at the same time accurate and secure turned out to be extremely challenging, requiring a combination of static analysis, runtime monitoring and code rewriting. It is also worth mentioning that CCSP is naturally effective at simplifying the policy specification process for web developers, assuming that content providers are willing to dedicate some efforts to foster the integration between their contents and the content security policies of the embedding resources.The idea of dynamically changing the enforced CSP policy advocated in CCSP is also present in the design of COWL, a confinement system for JavaScript code [12]. It is worth noticing that CSP Embedded Enforcement is a first step towards making the CSP enforcement depend upon an interaction between the protected resource and the content providers, though the problems it addresses are orthogonal to CCSP. Similarly to CSP, CSP Embedded Enforcement asks web developers to get a thorough understanding of the contents they include to write a content security policy for them.Other papers on CSP studied additional shortcomings of the standard, touching on a number of different issues: ineffectiveness against data exfiltration [13], difficult integration with browser extensions [5], unexpected bad interactions with the Same Origin Policy [10] and suboptimal protection against code injection [6]. Our experiments show that popular content providers can deploy CCSP with limited efforts, leading to significant benefits for the large majority of the web.As future work, we plan to implement CCSP directly in Chromium and carry out a large-scale analysis of its effectiveness, including a performance evaluation. Finally, we would like to investigate the problem of supporting robust debugging facilities for CCSP in web browsers. Rather, we uniformly represent them using the source expression inline(str), where str is a string which uniquely identifies the white-listed inline script or stylesheet;3. for simplicity, we do not model ports and paths in the syntax of source expressions.To simplify the formalization, we only consider wellformed policies, according to the following definition.Assumption 1 (Well-formed Policies). However, there is no loss of generality in focusing only on well-formed policies, since if both unsafe-inline and inline(str) occur in the same directive, only one of them is enforced: browsers supporting CSP 1.0 would ignore inline(str), while browsers implementing more recent versions of CSP would ignore unsafe-inline. The definition of the semantics of CoreCSP is based on three main entities: locations are uniquely identified sources of contents; subjects are HTTP(S) web pages enforcing a CSP policy; and objects are contents available for inclusion by subjects.Definition 3 (Locations). We also assume that, for all objectso = ((il, str ), str), we have o ∈ O script ∪ O style . Given a list of directives d and a content type t, we define d ↓ t as the value bound to the first t-src directive, if any; otherwise, the value bound to the first default-src directive, if any; and in absence of both, we let it be the wildcard { * }. t =      v if d = d 1 ,t-src v, d 2 ∧ ∀d ∈ { d 1 } : d = t-src v ⊥ otherwiseWe then define the lookup operator d ↓ t as follows:d ↓ t =          d.t if d.t = ⊥ v if d.t = ⊥ ∧ d = d 1 , default-src v, d 2 ∧ ∀d ∈ { d 1 } : d = default-src v { * } otherwiseThe judgement p s t O defines the semantics of policies. This makes reasoning on CSP policies quite complicated, hence we introduce a class of policies, called normal policies, whose semantics does not depend on a specific subject. (D-VAL) d ↓ t = v v s L d s t {o ∈ O t | π 1 (o) ∈ L} (D-CONJ) p 1 s t O 1 p 2 s t O 2 p 1 + p 2 s t O 1 ∩ O 2The syntax of normal policies is obtained by replacing the occurrences of h in Table 5 with h, where:h ::= sc | * | (sc, he). for all normal policies p, subjects s 1 , s 2 and content types t, we have that p s 1 t O 1 and p s 2 t O 2 imply O 1 = O 2 . We start by defining a binary relation src on normal source expressions. Given a normal policy p and a content type t, we define p ⇓ t as follows:p ⇓ t = d ↓ t if p = d (p 1 ⇓ t) (p 2 ⇓ t) if p = p 1 + p 2Lemma 3 (Correctness of Smart Lookup). Given two policies p 1 , p 2 and a subject s, we define the meet p 1 s p 2 as the least policy s.t. (p 1 s p 2 ). We thank Daniel Hausknecht, Artur Janc, Sebastian Lekies, Andrei Sabelfeld, Michele Spagnuolo and Lukas Weichselbaum for the lively discussions about the cur-