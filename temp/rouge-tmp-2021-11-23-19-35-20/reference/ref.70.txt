In this paper we demonstrate that shared event loops are vulnerable to side-channel attacks, where a spy process monitors the loop usage pattern of other processes by enqueueing events and measuring the time it takes for them to be dispatched. Specifically, we exhibit attacks against the two central event loops in Google's Chrome web browser: that of the I/O thread of the host process, which multiplexes all network events and user actions, and that of the main thread of the renderer processes, which handles rendering and Javascript tasks. Figure 1 illustrates such a scenario for a loop that is shared between an attacker A and a victim V.Attacks based on observable contention of shared resources have a long history [25] and an active present [8,27,37]; however, attacks against shared event loops have so far only been considered from a theoretical point of view [22]. Specifically, we target shared event loops in the two central processes of Google's Chrome web browser: The host process, whose event loop is shared between all requests for common resources, such as network and user interface; and the renderer processes, whose loops can be shared between Javascript tasks of different tabs or iframes.We build infrastructure that enables us to spy on both loops from a malicious HTML page. • For the event loop of the host process we rely on two different mechanisms: network requests to nonroutable IP addresses, which enter the loop and abort very quickly, providing a resolution of 500 µs; and SharedWorkers, whose messages pass through the event loop of the host process, providing a resolution of 100 µs.We use the information obtained using these techniques in three different attacks:1. Second, we show that page identification through the event loop requires only minimal training: we achieve recognition rates of up to 75% and 23% for the event loops of the renderer and host processes, respectively, for 500 main pages from Alexa's Top sites. We demonstrate that shared event loops can be used to transmit information between cross-origin pages.Specifically, we implement a covert channel with a bandwidth of 200 bit/s through the renderer's main thread event loop, and another one working crossprocesses of 5 bit/s. They work under the assumption that event loops behave as FIFO queues; in reality, however, Chrome's event loop has a more sophisticated structure, relying on multiple queues and a policy-based scheduler. The Chrome architecture is segmented into different operating system processes. Each renderer runs several threads; the most relevant ones are:• the MainThread where resource parsing, style calculation, layout, painting and non-worker Javascript runs, • the IOChildThread, which handles IPC communication with the host process, and• the CompositorThread, which improves responsiveness during the rendering phase by allowing the user to scroll and see animations while the main thread is busy, thanks to a snapshot of the page's state.Each of the threads in the host and renderer processes maintains at least one event loop that is largely a FIFO queue. Chrome supports different policies that govern how web applications are mapped to renderer processes, and that influence whether or not event loops are shared.The default policy is called process-per-siteinstance. For example, https://docs.google.com and https://mail.google.com:8080 are from the same sitebut not from the same origin, as they differ in subdomain and port. Even in the restrictive default process-per-siteinstance policy, there are some situations that force Chrome to host documents from different sites in the same renderer process, causing them to share the event loop:• Iframes are currently hosted in the same process as their parent. • When the number of renderer processes exceeds a certain threshold, Chrome starts to reuse existing renderers instead of creating new ones.On (64-bit) OSX and Linux, the threshold for reusing renderers is calculated by splitting half of the physical RAM among the renderers, under the assumption that each consumes 60MB. The corresponding messages of all renderers pass through the event loop of the host process' I/O thread.We illustrate this communication using two different examples: how user actions flow from the host to the corresponding renderer process, and conversely, how network requests flow from a renderer to the host process. • UI flow: User actions such as mouse movements or clicks enter the browser through the main thread of the host process. There are several scenarios in which an adversary site A can share the event loop of the renderer's main thread with a victim site V. Meanwhile, A's page monitors keystroke timings (see Section 4.2), which can be used for recovering user passwords [32]. The call to performance.now() in line 2 of the function loop returns a high-resolution timestamp that is saved as described below.The call to self.postmessage(0,'*') in line 3 posts message save ( performance . onmessage = loop 6 loop () Listing 1: Javascript code to monitor the main thread's event loop with the postMessage API. This causes loop to recursively post tasks, while keeping the render responsive since other events are still being processed.In order to minimize the noise introduced by the measurement script itself, the function save in line 2 uses a pre-allocated typed array (Float64Array) to store all the timing measurements. JIT can trigger code optimization or deoptimization, in the case of Chrome by the CrankShaft and Turbofan compilers, at points in time that are hard to predict. On some browsers, such as Microsoft's Internet Explorer, GC rounds can be triggered programmatically, which helps to eliminate noise from the measurements enabling more precise attacks [11]. The Chrome sandbox ensures that all of the renderer's network and user interaction events pass through the host process' I/O event loop, see Section 2.4. Pages of different origins running in different (disconnected) tabs can use the shared event loop to implement a covert channel, violating the browser's isolation mechanisms. A tab running a rogue page of A can identify which pages are being visited by the user in other tabs by spying on the shared event loop. In line 3 we request a non-routable IP address, and set the rejection callback of the promise to self, to recursively run when the request fails.1 function loop () { 2 save ( performance . 4 catch ( loop ) 5 } 6 loop ()Listing 2: Javascript code to monitor the host's I/O thread using network requests.Shared Workers. As a result, we measure the round-trip time from the page to the worker, which reflects the congestion in the I/O event loop. Note that one can further increase the measurement resolution by recording the time in each endpoint and merging the results. We implement the eavesdropping techniques described in Sections 3.1 and 3.2 in a tool called LoopScan, which enables us to explore the characteristics of the side channel caused by sharing event loops. LoopScan source is publicly available at https://github.com/cgvwzq/ loopscan. We describe how the event-delay trace obtained from spying on event loops can be used for identifying webpages loaded in other tabs. Here, duplicates are sites that share the subdomain but not the top-level domains (e.g., "google.br" and "google.com") and that are likely to have similar event-delay traces. Open a new tab via target = window.open(URL, '_blank'); 2 2. Wait 5 seconds and go to 1 with next URL The harvesting procedure for the host process differs only in that we use the rel="noopener" attribute in order to spawn a new renderer.We conducted measurements on the following three machines: We measure the timing on a Chrome instance with two tabs, one for the spy process and the other for the target page. Unfortunately, our experimental results were discouraging, with less than a 15% of recognition rate in small datasets.Dynamic Time Warping. Instead, we focus on the relative ordering of events as a more robust feature for page identification.This motivates the use of dynamic time warping (DTW) [7] as a similarity measure on event-delay traces. The goal of DTW is to find a matching of points in X with points in Y , such that (1) every point is matched, (2) the relative ordering of points in each sequence is preserved (monotonicity), (3) and the cummulative distance (i.e. the sum of the values of f ) over all matching points is minimized. We rely on two kinds of speed-up techniques, one at the level of the data and the other at the level of the algorithm:At the level of data, we reduce the dimension of our data by applying a basic sampling algorithm: We split the raw trace into groups of measurements corresponding to time intervals of duration P, and replace each of those groups by one representative. It speeds up DTW but will not find optimal warping paths that lie outside of the envelope. The possible configurations of the techniques presented in Section 4.1.4 create a large parameter space, see Ta- ble 1 We systematically identify the optimal parameter configuration for each event loop on each machine. We evaluate the performance of page identification through the shared event loops of host and renderer processes on each individual machine, as well as through the renderer process across two different machines.To this end, we select the top configuration for each corpus from the tuning phase and carry out a 10-fold cross-validation. For each of the traces in the testing set, we compute the set of k closest matches in the training set according to the time warping distance.We measure performance in terms of the k-match rate, which is the percentage of pages in the testing set for which the true match is within the set of k closest matches. However the homogeneity in hardware and software of Macbooks facilitate reuse of training data across machines, which may make remote page identification more feasible. A reason for this poor performance is that events on the OSX laptop often take 2x-5x more time than on the Linux desktop machine. Normalizing the measurements could improve cross-machine recognition.The code and datasets used for tuning and crossvalidation are available as an R library at https:// github.com/cgvwzq/rlang-loophole. The renderer's loop, however, is in general more robust to noise caused by other tabs in the browser.On the other hand, our attacks do not make any use of the pages' source code or of details of Chrome's scheduling system with priority queues, the GC with periodic scavenges, or the frame rendering tasks. OAuth allows users to login using their identity with trusted providers, such as Google, Facebook, Twitter, or Github. Because the window of the login form shares the event loop with the opener's renderer, a malicious A can eavesdrop on the keystroke events issued by the login form. 5 d2 = trace [ i +1] -trace [ i ] 6 7 if (L < d1 < U && L < d1 < U ) { 8 keys . To evaluate the effectiveness of this attack, we have implemented a malicious application A that extracts the inter-keystroke timing information from a user V logging-in via Google's OAuth. We conclude by discussing two open challenges for recognizing user events, namely the detection of user events beyond keystrokes and the detection of events in the browser's host process.Detecting User Events beyond Keystrokes A continuous mouse movement results in a sequence of events, each of which carrying information about the coordinates of the cursor's trajectory. These events are issued with an inter-event delay of 8 ms, and the (empty) event listener operation blocks the loop for approx 0.1 ms. The particular frequency and duration of these events makes mouse movements (or similar actions, like scrolling) easy to spot with LoopScan, as seen in Figure 10. A promising starting point for this are existing on-line variants of dynamic time-warping [31]. Unfortunately, our current methods are not precise enough for this task, since the host's I/O thread is more noisy than the renderer's main thread and the effect of a user action on the host process is limited to a short signaling message, whereas the renderer's main thread is affected by the execution of the corresponding Javascript event listener. • the receiver R monitors the event loop of the renderer's main thread using the techniques described in Section 3.1; it decodes a 0 if the length of the observed tasks is below a threshold (related tô t), and a 1 otherwise. Transmission starts with S sending a 1, which is used by the agents to synchronize their clocks and start counting time intervals. During each intervals we do the following:• the sender S idles for transmitting a 0; it posts N fetch requests into the I/O thread's queue for sending a 1. We have shown how sharing event loops leads to timing side-channels and presented different attacks on Chrome. Nevertheless, our results point to fundamental security issues in the event-driven architecture of browsers that eventually need to be addressed in a fundamental manner. The attacks presented in this paper rely on two capabilities of the adversary: (1) the ability to post tasks into the loop's queue with high frequency, and (2) the ability to accurately measure the corresponding time differences.Rate Limiting. This has already been applied by browser vendors for mitigating other kinds timing channels, but these efforts are unlikely to succeed, as shown in [23]: Modern browsers have a considerable number of methods to measure time without any explicit clock. The current resolution of performance.now is limited to 5 µs, which makes microarchitectural timing attacks difficult, but does not preclude the detection of Javascript events.Full Isolation. The "Site Isolation Project" is an ongoing effort to ensure a complete process-per-site-instance policy, that means: providing cross-process navigations, cross-process Javascript interactions and out-of-process iframes. Timing attacks on web browsers date back to Felten and Schneider [13], who use the browser cache to obtain information about a user's browsing history.More recently, so-called cross-site timing attacks [10,35] have exploited the fact that the browser attaches cookies to all requests, even when they are performed across origins. A special case are cross-site search attacks [14], which circumvent the same-origin policy to extract sensitive information, by measuring the time it takes for the browser to receive responses to search queries.Other classes of browser-based timing attacks exploit timing differences in rendering operations [24,33,5], or simply use the browser as an entry point for Javascript that exploits timing channels of underlying hardware, for example caches [26,16], DRAM buffers [17], or CPU contention [9]. We systematically study how this channel can be used for different purposes, such as web page identification, user behavior detection, and covert communication.