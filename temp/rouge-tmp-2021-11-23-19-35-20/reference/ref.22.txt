Database-backed applications rely on access control policies based on views to protect sensitive data from unauthorized parties. However, not all database tables contain sufficient information to map a user to rows in the table, as a result of database normal-ization, and thus, require the joining of multiple tables. SafeD uses a declarative language for defining security policies, while retaining the simplicity of database views. Unfortunately, securing web applications has remained a challenge, mainly for three reasons: (i) the incompatibility of modern web architecture and the security mechanisms of database systems, (ii) limitations of the automated techniques for enforcing a security policy, and (iii) failure to write secure, non-buggy code when implementing access contol logic within the application.1. Using an overprivileged account, the web application can simply maintain a pool of active database connections that can execute queries on behalf of any end user.To use a DBMS' mechnisms, (1) each application user must be assigned a unique database account, and (2) a separate database connection (using the assigned account) must be used for processing each user's requests. 1 Making such changes to web applications would prevent them from using a connection pool, and result in performance degradation [33,48]. Although current techniques can fully restrict database reads [43,45], they do not support database updates (i.e., INSERT, DELETE, and UPDATE queries) due to the view update problem [27]. Such a problem can occur when a view definition contains a join query.Consider OsCommerce, an open-source e-commerce web application, which allows customers to leave reviews on products. customer_ID = current_id ;The first three conditions in the WHERE clause obtain the set of products a customer has ordered, and the last condition ensures that the customer and the current user are the same. This is because there is no one-to-one mapping between the rows in the view and those in the base tables, e.g., a user can purchase a product multiple times across different orders.Previous work has largely ignored the view update problem by assuming that any table on which a security policy is defined contains the user id, thus joins are not required to map a user to rows in the table [36,39,43]. Unsecure or buggy code leave web applications vulnerable to numerous access control bypass attacks, such as SQL injection [8,25,28,34,35,38,42] and insecure direct object reference attacks [14,44]. For example, a vulnerability in Symantec's webbased management console allowed authenticated lowprivileged users to execute arbitrary SQL queries on the backend database, and change their account privileges to administrator level [25]. Generality: The access control policy can be enforced for all read (SELECT) and write (UPDATE, INSERT, and DELETE) queries on any table (whether it contains the user id as a column or not);C2.Correctness: The application user should only be able to access and modify authorized information as defined by the developer's policy;C3. Connection Sharing: For compatibility with existing web applications, the solution should allow for reusing a set of persistent and over-privileged database connections to serve requests of multiple end users.Our Approach -We introduce the phantom extraction technique for enforcing access control on write queries, while being robust to policies that involve joins. Since the access control is evaluated at the driver level, SafeD does not require a new database connection to establish a new user context, nor is it tied to a particular database backend. We surveyed 10 popular open-source web applications and show that complex row-level access control policies with joins queries are required for, on average, 21% of the tables to define per-user policies (Section 3).2. On MySQL (which lacks built-in support for row-level access control for read/write queries), a 6% increase in transaction latency is observed (Section 8.1). On Postgres, SafeD provides comparable performance to Postgres' access control for simple policies, but outperforms it by an order of magnitude for row-level access control policies with joins in terms of transaction latency and throughput (Section 8.2). While the authors remark that Diesel can be extended to user-based access control (e.g., by duplicating all the modules for each connected user), they also acknowledge that their solution would not scale [39] and suggest using database access control in conjunction. Defining these functions via procedural code offers flexibility, but is also more error-prone compared to simply writing declarative policy statements as in SafeD.More recently, Postgres 9.5 has added support for fine-grained access control, whereby administrators define two policy conditions for each table and each role. SafeD does not make this assumption, decoupling a user's read and write permissions.As mentioned in Section 1, the key advantage of SafeD over access control features of database systems is that the former is compatible with today's web application architecture. SafeD also provides databaseindependence, and offers a simple syntax for defining a security policy compared to database solutions. Thus, prior work has proposed alternatives that decouple access control logic from the application, but all existing work cannot handle write queries when a declarative policy definition requires a join. These types of policies, which we call join policies, occur when a database table does not contain a field corresponding to a user, such as user id, which enables a mapping of rows in the table to a user. order to define a policy for the page table, a join with page restriction is necessary to determine which pages a user can edit.5 (9%) Drupal [2] 60 12 (20%) myBB [5] 75 8 (11%) ZenCart [11] 96 18 (19%) Cyclos [1] 185 24 (13%) Average Percent 21%For each web application, we recorded the total number of tables in the database and the fraction of those tables that require a join query in a declarative policy definition to enforce a per-user policy.Our survey results, shown in table 2, indicate that an average of 21% of an application's database tables require a join query to define a per-user policy declaratively. SafeD extends an existing database driver (e.g., JDBC or ODBC) to add a security layer that ensures all queries issued by the application are compliant with the defined declarative security policy (see Figure 2). At run-time, SafeD automatically transforms each query into a read-safe or write-safe query (i.e., one that is compliant with the read and write policies). Our results show that SafeD can protect practical database-backed applications at a negligible cost (Section 8). In other words, the web application is assumed to reliably verify the enduser's identity and make it available to SafeD along with the issued query, but the query itself can be arbitrarily over-privileged, due to bugs or remote exploits. However, if the policy is incorrectly defined, SafeD cannot prevent the undesirable actions of authorized users. Appendix B provides several examples of how safety can be enforced based on the results and definitions presented in this section. In SafeD, a security policy is composed of two sets of access rules: the read policy and the write policy. 4 Read sets are defined similarly, except that the READSET keyword is used instead of WRITESET.DEFINE WRITESET FOR ROLE customer USER $i ONThe definition of the read and write sets for a Next, we define read and write sets formally. Since each element of a set is unique, we allow for duplicate entries by taking the Cartesian product of S with the natural numbers, N × S, and use that as our new tuple space. Furthermore, given any subset s ⊆ S, we denote its complement as s c = S \ s.Given a set of users U, we define a security policy as a pair of two functions (p r , p w ), where p r is the read policy and p w is the write policy, defined below.Definition 1 (Read/Write Policy). (Read/Write Set) Given a user u ∈ U and a table T ⊆ S,• The read set of T , V r (T, u) = T ∩ p r (u), represents the set of tuples in T that user u can read. A query R by a user u with read policy p r is read-safe if the query would return the same result when executed on the subset of tuples in the accessed tables that are readable to the user, namely p r (u). The above corollary implies the following: if in a query R, each table T i of the database accessed in the FROM clause is replaced by a table T i where T i = T ∩ p r (u), then the resulting query R will be readsafe. Intuitively, a write query by a user u that updates a table T is write-safe if 1) it does not modify anything outside table T 's write set, and 2) any nested SELECTs within it are also read-safe (so that it does not leak data via the writes). A write query W by a user u that modifies table T is read-safe if all of its nested queries (which must be SELECTs) are read-safe. Given a user u ∈ U, a tuple space S, a set of tuples s ⊆ S, a table T ⊆ S, a write operation W that is read-safe, the write policy p w , and the write set V w (T, u), the following conditions,(1) V w (W (T ), u) = W (V w (T, u)) (2) W (T ) = W (V w (T, u))are necessary and sufficient to ensure W is write-safe, i.e.,NV w (T, u) = NV w (W (T ), u). We defer the proof of Theorem 1 to the Appendix.We now can define the notion of a query being safe in terms of read-safety and write-safety for the four types of queries addressed in this paper. Given a policy (p r , p w ), we consider a SELECT query for a user u to be safe if it is read-safe. INSERT queries: If all created tuples by an INSERT query are within the write set of the user, then the query is write-safe. For write queries, SafeD uses a novel technique, called phantom extraction, to ensure only the portion of the table within the write set is updated (Section 6.1). We prototyped this strategy and tested it with the TPC-C benchmark and found it to thrash at low transaction rates. We say that a write query's phantom is a read-safe copy of the query, which only updates rows in the write set. First, transform the original query into a read-safe query using read policy intersection (Section 5.2). The transformation module automatically transforms a query Q into a safe query that is guaranteed to satisfy the two conditions in Theorem 1 for read-safety and writesafety, while providing the illusion that the query operates on the view of tables that are in the user's read set and write set. Read policy intersection automatically transforms a SELECT query in Q into one that is read-safe by appending additional tables and conditions to each query based on the read policy.Nested Queries (read-safety) -SELECT queries can be nested within other queries, including write queries. if (Q is a Select query) then 5: return Execute(rsQ) T ← GetWriteTable(rsQ) 7: writesetde f ← GetWriteSetDef(u, T) 8: return PhantomExtract(rsQ, T, writesetdef) SafeD uses one of two strategies for implementing the PhantomExtract function: V-Copy or No-Copy. Instead of modifying T directly, an empty temporary table with the same schema as T is created in the database and the corresponding reference (i.e. the table name), tempT, is returned. Finally, T is modified based on the state of addTup and rmTupAn alternate strategy, No-Copy (Algorithm 3), can sometimes reduce the amount of work performed by the database and evaluates the conditions of Theorem 1 locally when possible. This parsing can be always done for blind INSERT queries, which contain the new values for a tuple in the VALUE clause. For DELETE queries, due to the Corollary 3, No-Copy executes the DELETE query on the subset of T that is within its write set, ensuring that only writable tuples are deleted.Write set intersection is also used to transform rsQ into phantom if rsQ is an UPDATE. We have implemented a prototype of SafeD by extending the JDBC driver. What is SafeD's performance overhead for a database without built-in support for access control? How does SafeD's performance vary with the ratio of unsafe queries in the workload? Setup -In all experiments, we used two machines running Ubuntu 12.04 with 32GB of memory, configured as a client and a database server. For TPC-C, we used its standard mixture of transactions (43% payment, 4% order status, 4% delivery, 4% stock-level, and 4% new order) and a scale factor of 20. A customer's user context contains three attributes: the warehouse id (WID), the district id (DID), and the customer id (CID). When the target tables do not contain the necessary attributes to map the current user to tuples in the table, i.e, the New Order and Order Line tables, a join between the target table(s) and the OOrder table is necessary to obtain the set of order ids (O ID) that the current user can access. Customers execute the new order, order status, and payment transactions, while managers execute the delivery and stock-level transactions.Our second policy, Policy 2, tests the sensitivity of the performance results of SafeD and Postgres's rowlevel access control by adding restrictions to Policy 1. The results show that SafeD can enforce a fine-grained security policy at a negligible cost to latency compared to having no protection (6.1% for No-Copy and 5.9% for No-Copy strategy). However, note that these results represent best-case scenarios for Postgres's built-in mechanism, since the benchmark application had full access to every table.We conducted a second set of experiments using Policy 2 in order to artificially force both strategies (SafeD and built-in) to perform joins during their access control checks.The results are shown in Figure 4b. This considerably lowered the performance of V-Copy, due to its creation of temporary tables and copying of the write sets. These results indicate that when a user's write set contains joins, SafeD using No-Copy significantly outperforms Postgres's built-in access control.While SafeD outperforms the built-in access control, the performance of both strategies could be improved. Thus, to reduce the performance overhead, we repeated the experiment with a denormalized database, i.e, we added a new column, NO C ID, to the New Order table. To measure the impact of having unsafe queries on SafeD's performance, we modified the TPC-C workload by adding additional queries that are unsafe under Policy 1. As the number of unsafe queries increases, V-Copy's latency greatly increases, whereas No-Copy's latency overhead is relatively constant. Thus, overall, defining security policies in SafeD seems to be relatively straightforward.SafeD also simplifies developer effort when ensuring the application issues safe queries. Database-backed application developers often implement their access control policies procedurally in code because the access control mechnisms of database systems are not adequate for enforcing access control for multi-user applications. We also provide two possible design strategies, V-Copy and No-Copy, for performing query extraction. If we define A v = W (V w (T, u)) \ V w (T, u) and D v = V w (T, u) \ W (V w (T, u)), then from the definition of W (T ), we have W (V w (T, u)) = |A v | + |D v |However, we also see that from making use of condition (1) we haveV w (A, u) = V w (W (T ) \ T, u) def of A = V w (W (T )) \V w (T, u) Lemma 1 = W (V w (T, u)) \V w (T, u) condition (1) = A v def of A v . To better understand the transformation described in Section 6, we describe the steps of the No-Copy Strategy, which is comprised of Algorithms 1 and 3, using three example queries. Suppose a customer with current id=2 manages to (e.g., by exploiting a bug in the application) cause the web application to issue the following query:SELECT * FROM reviews WHERE products_id IN ( SELECT products_id FROM orders_products OP , orders O WHERE O . Suppose a customer with current id=2 causes the application to issue the following query: Listing 10: Original DELETE query issued by the application First, SafeD obtains the customer's read policy for tables used in any SELECT's in the query, but there are no SELECT queries. Given that the current write-safe query is a DELETE, SafeD performs write set intersection by appending additional conditions to the outer query's WHERE clause Since the write set includes a join (see Listing 5, an additional nested query is added to obtain a list of products purchased by the current customer. ( reviews_id , products_id , customers_id , customers_name , reviews_rating , date_added , last_modified , reviews_read ) VALUES ( -1 , 1 , 1 , 'John', 5 , 1 -1 -2016( -1 , 1 , 1 , 'John', 5 , 1 -1 - , 1 -1 -2016 Listing 12: Original INSERT query issued by the application Similar to the DELETE query example, the original INSERT query is read-safe by definition. Based on the query in Listing 12, we see that the original query adds a single row with customers id=1.