üSpark comprises two key ideas: (i) endowing low-level system software with abstractions found in higher-level languages (e.g., objects, interfaces, function-call semantics for implementations of interfaces, access control on interfaces , concurrency and serialization), enforced using a combination of commodity hardware mechanisms and lightweight static analysis; and (ii) interfacing with platform hardware by programming in Assembly using an idiomatic style (called CASM) that is verifiable via tools aimed at C, while retaining its performance and low-level access to hardware. Hypervisors not only enable the old-hat style of customization, such as modularity for device drivers, but are further extended with convenient functionality for security services such as attestation, debugging, tracing, application-level integrity and confidentiality, trustworthy resource accounting, on-demand I/O isolation, trusted path, and authorization [14], [18], [22], [49], [53], [57], [62], [64], [65], [71], [74], [75], [77], [80], [83]- [86]. As the size and complexity of these systems increase -not to mention the number of extensions, which may be active in arbitrary combinations -so has the incidence of security-related bugs. Solution -We address this challenge by developing überSpark (üSpark), an architecture for building extensible hypervisors that: (a) is compatible with commodity systems; (b) enables automated compositional verification of security properties; and (c) produces performant systems. We focus only on security invariants -memory separation, control-flow integrity, information flow -and other extension properties that can be formulated as invariants. This helps bring to commodity-compatible hypervisors those on-going approaches, which offer full functional correctness, but we also enable precise reasoning on untrusted and unverified system code. A third group of special üAPI üobjects allow access to shared resources enabling state-of-the-art tools for automatic verification of sequential C code to be soundly applied to verifying security properties, while still allowing multithreaded high-performance applications.In keeping with our first and second design goals, üSpark enforces verifiable-object abstractions using a combination of commodity hardware mechanisms (pagetables and de-privileging) and light-weight static analysis, leveraging off-the-shelf C99 source-code analysis and certified-compilation tools. We use standard and custom Frama-C plug-ins to perform static verification checks that include: per-üobject behavioral contracts (via a standard weakest-precondition plug-in); abstract variable assertions that enable behavioral asserts as well as üobject control-flow integrity (via a standard abstract-interpretation plug-in on stack frames and other variables); syntactic checks that ensure conformance with a restricted C99 syntax and logical de-privileging of üobjects (via a standard abstract syntax tree analysis plug-in); and, composition checks that enable client üobjects that share a common server üobject to compose soundly (via a custom composition-check plug-in). During üobject compilation, all C99 code is processed using the certified CompCert compiler [12] while each CASM instruction is replaced by the corresponding Assembly instruction by our custom Frama-C plugin. (c) We carry out a comprehensive evaluation showcasing verification metrics, development effort and performance, and report on our experience (1 person yr; üobject verification times from 1-23 minutes with a cumulative time ≈ 1hr; 2% average runtime overhead over native micro-hypervisor applications with guest performance unaffected; §8, §9). The hypervisor and extensions are written in C and Assembly.The hypervisor leverages CPU capabilities, such as memory-mapped I/O (MMIO) and legacy I/O, for system-to-device interaction; it initializes boot CPU (BSP) state; it sets up memory page tables, as well as device allocations and DMA protections (e.g., via an IOMMU); it initializes multi-CPU support via the Local Advanced Programmable Interrupt Controller (LAPIC) and activates other CPUs and sets up their memory page tables and appropriate protections. Consider now adding two new verified extensions to the hypervisor: hyperdep, which ensures that guest-VM data pages are non-executable; and (b) sysclog, which ensures that every system call issued by the guest is logged via a dedicated network card to an external trusted entity on the network. As with hyperdep and sysclog, core hypervisor properties, and the properties of other extensions should not be violated by running aprvexec, and the risk of running aprvexec should only be suffered by a guest that explicitly enables it and relies on its presumed properties. Goals -Our overarching goal is to enable development of performant extensible hypervisors offering proofs of wide-ranging properties on their code, including low-level memory safety, control-flow guarantees, and information flow, as well as higher-level properties such as trusted network logging (sysclog) and data execution prevention (hyperdep), going all the way up to security properties spanning both hardware and software states (IOMMU, LAPIC, network-card and CPU). Compositionality: When new components are added, or existing components changed, human reverification effort should be limited to the changed codebase, yet it should provide guarantees about the entire system under all possible configurations. Our development and verification approach must integrate into the existing hypervisor C and Assembly language programming ecosystem, and cover the entire source code base including commodity hardware and guest OS. This separates the concerns of showing how a complex low-level system achieves low-level formal properties from how those low-level properties refine a high-level abstract model; we focus on the former, since it is a hard and as yet open problem, whereas much on-going work tackles the latter [31], [42]. We assume that our hardware TCB is functionally correct, and we have load-time integrity, i.e., the verified hypervisor is the one securely loaded onto the hardware at boot time. Assembly language for a verified üob-ject is written using CASM, a dialect of C in which Assembly instructions are encoded within regular C functions (CASM functions) via C-like pseudofunction calls (CASM instructions 1 ). For example, for the x86 instruction movcr3 involving register eax there is a corresponding CASM pseudo-function called ci_movl_eax_cr3. Beyond defining its own functionality, a üobject is also accompanied by a behavior contract. This consists of a use manifest ( §4.3) and a formal behavior specification of its own public interface, which guarantee that if a certain assumption is satisfied in how a public method is invoked, then a property on the return values is guaranteed to hold upon return of that method, without mention of internal üobject state.Every üobject is held to a number of invariants, which together guarantee its adherence to the verifiableobject abstraction. These invariants include memory and (internal) control-flow integrity, so that the code can be reasoned about; and satisfaction of the formal contract, so that the contract alone may overapproximate the üob-ject, thereby enabling compositional verification; as well as correct initialization. This enables us to achieve the sweet spot with both high performance (there is no hardware de-privileging overhead; §8.3.1) and compositional verification (privileged üobjects can be verified seperately; §7.2). The verifiable-object abstraction requires üobject-to-üobject control-flow integrity (otherwise returns could land at arbitrary üobject program sites, access controls would be violated, etc.). For example, an extension can be split between a top half and a bottom half as with traditional device drivers (in our case study, sysclog could shed its networking code into a separate üobject, sysclognw, that only takes transmission requests from sysclog, and is the only authorized user of a separate NIC dedicated to logging), ensuring that only the top half may invoke the bottom half at runtime, while still keeping the two isolated from each other and independently verifiable. But if either is unverified, the sentinel must employ the appropriate control-transfer method for the isolation mechanism imposed on the unverified üobject (e.g., if using ring-based isolation, switch privilege levels and stacks, marshal arguments, etc.). üObject Resource Confinement -üSpark implements üobject resource confinement in which distinct system resources are: (a) managed by designated üob-jects, (b) protected from access by unauthorized üob-jects, and (c) regulated in their use by authorized client üobjects. It is held to the property that it can only use the resources declared in its manifest.For verified üobjects, üSpark employs a hardware model identifying CPU interfaces to system resources (e.g., I/O and designated memory instructions interface to system devices, instructions that can modify CPU model specific register states, etc.) and static analysis to ensure that access to those interfaces respects the üob-ject's manifest ( §7). For example, sysclog's manifest shows that it may access the dedicated NIC for its remote logging, and static analysis ensures that the code for sysclog may access only that NIC, nor can any other üobject access sysclog's NIC.In contrast, unverified üobjects are held to their use manifests via more direct enforcement mechanisms, such as hardware MMU and privilege protections (virtualization, de-privileging) and software manipulations (e.g., SFI). This, in turn, allows us to prove invariant properties of üobjects, and the hypervisor as a whole, via sequential source-code verification. This, allows us to prove invariant properties encompassing hardware states and keeps our hardware model simple by precluding modeling of concurrent hardware accesses ( §7.1.2). The invariants are divided into üSpark system invariants and üSpark general programming invariants (those that pertain specifically to üobject C and CASM functions). A üobject CASM program is a CC99 program such that: (i) all Assembly code appears only in CASM functions; and (ii) these CASM functions preserve the caller C functions' CPU register state.Given a üobject CASM program, we are interested in verifying two kinds of properties: (1) invariant properties: whether ϕ holds at every state (after every instruction), and (2) individual state assertions: whether ϕ holds at specific program points. We introduce a set of fresh C variables (denoted V hw ), one for each register; replace each Assembly instruction accessing R hw by one or more CC99 statements that operate in a semantically equivalent way over V hw ; replace each r ∈ V hw with v r in assertions used for specifying hardware state during verification. In particular, the abstract üSpark üBP consists of a set of abstract üobjects, where each abstract üobject 񮽙 s is obtained from the corresponding concrete üobject s by converting each function g ∈ p(s) to an abstract function 񮽙 g; more concretely: by replacing all CASM functions as described above, replacing accesses to data that other cores and devices can modify by nondeterministic values, replacing a call to an unverified üobject by a call to the intercept handler üobject with non-deterministic arguments. As a first step, we refactor XMHF into: (a) verified hypervisor (vh) üobjects for prime, sentinel, core, üAPIs, and verified hypapps; (b) unverified hypervisor (uh) üobjects for unverified hypapps; and (c) unverified guest (ug) üobjects for the OS (Figure 2); §8 quantifies this refactoring effort. Finally, for each CPU in the system, prime: (a) activates protected-mode with paging and hypervisor-mode via control registers CR0 and CR4 and the VMXON instruction; (b) sets up SYSENTER MSRs, interrupt descriptor table and VM control structure (VMCS) to transfer control to the sentinel; and (c) loads vh page tables in CR3 and transfers control to xcstrt core startup üobject. The sentinel handles exceptions by transferring control to the vh xcehub üobject. We use the following Frama-C plugins: Deductive verification via Frama-C's WeakestPrecondition (WP) plugin enables the verification of assume-guarantee behavior specifications on C functions. We built üSpark-specific plugins on top of Frama-C as follows: (a) übp -enforces üSpark blueprint; (b) ühwm -embeds hardware model during verification; (c) ücasm -substitutes Assembly mnemonics corresponding to CASM instructions after verification; (d) ücc -enforces general üSpark coding rules; (e) ümf -parses üobject manifest; and (f) ücvf -performs composition check ( §7.2.1). In keeping with our longer term goal of guaranteeing that the verified source code properties carry over to the binary, we employ the CompCert [11], [12], [46] certified C99 compiler to compile üobjects. üXMHF Verification -Verification of üXMHF consists of: (a) üobject composition check, and (b) verifying üSpark invariants ( §5) and üobject local properties. However, sysclog and aprvexec are not composable (Figure 3b) since aprvexec sets the execute bit while sysclog clears the execute bit in the protections for the provided memory-page (lines 9-10). We use deductive verification to verify the hyperdep üobject activate method to ensure that the guest page address that is passed is used as the parameter to the ugmpgtbl üobject setentry method with read, write and no-execute protections. POC Verification: For brevity, we choose a sampling of POCs from a few üSpark invariants (Inv 4 ü , Inv 6 ü , Inv 6 üprog , Inv 7 üprog , and Inv 10 ü ; see Appendix A and [73]) that showcase the importance of all the verification techniques described in §7.1.1. In summary, the requires-8 ... assigns-ensures clause triplet is sufficient to represent the function behavior, and the loop invariants and ghost variables within the function are used to prove the clause triplet. System size and Verification TCB -üXMHF is implemented in 7001 SLoC verified privileged code split into 11 üobjects with 5544 lines of ACSL annotations and 2079 lines of hardware model ( Figure 6). A fraction of the time was spent adding implementation support for multiple hypapps with a greater part spent on porting to the üSpark hypervisor architecture by creating required üobjects and adding verification related harnesses and annotations. As seen, segmentation and CR3-based page tables provide the lowest overheads (37x and 48x), but are still an order of magnitude larger than the verified-to-verified sentinel call overhead. üXMHF Microbenchmarks: For purposes of micro benchmarking we measure the üXMHF xcihub üobject, which handles several intercepts required for guest execution. The overhead is due to üAPI invariant checks (<10%) and the sentinel cost of deprivileging, shadow stack and parameter marshalling ( §8.3.1). Verification Theories -Automated verification results vary by theory, e.g., Alt-Ergo and Z3 failed to discharge a few verification conditions (VC) that CVC3 handled. Annotations -ACSL is versatile in its support for writing partial specifications (e.g., memory safety of SHA-1) and assertions as well as complete specifications (e.g., page-table setup). NOVA [67] deprivileges everything (including VMM modules), except for a small privileged micro kernel. mCertiKOS [31] follows a similar approach to seL4 but makes the abstract specification layered to reduce the interdependencies among the kernel and various extensions and makes the verification process more tractable for an admittedly stripped down version of the original CertiKOS kernel (single-core, non-preemptible custom guest OS, basic process and syscall handling). Lastly, both mCertiKOS and seL4 require the developer to write line-for-line specifications for C/ASM code in a different abstract language (Isabelle/HOL or Coq/Ocaml/Lasm) with a very steep learning curve. Verified System Stack -In Verve [81], a simplified OS and applications are verified for type and memory safety using a Hoare-style verification condition (VC) generator and automated theorem proving. CASM and Certified Compilation -Our highlevel proofs depend on Compcert's specification of the C memory and register semantics and CASM's adherence to those semantics (discharged as invariants on the source-code and our hardware model) to ensure that the C and Assembly code operate on disjoint state. Concurrency -We have shown that a practical multi-threaded system with interesting security properties can be built by dealing with a serialized execution model and sequential verification in lieu of complex concurrent verification. We incrementally developed and verified a commodity x86 micro-hypervisor using üS-park, and performed a comprehensive evaluation which shows automated compositional verification with modest development effort and minimal runtime overhead.Availability: ÜBERSPARK and ÜXMHF sources are available at: http://uberspark.org Inv 1 ü üSpark begins execution with the entry point of a distinguished initial "prime" üobject sI in singlecore mode with just core 1 activated Inv 2 ü A special "asynchronous" function startcores(s) activates all cores i > 1 and begins executing a designated üobject s immediately thereafter; all cores remain active thereafter for the system lifetime. We then verify the send function via abstract interpretation to ensure that it programs the network card hardware to read from the dmadata region, transmit the buffer, and wait for end of transmission signal.We use deductive verification to verify the hyperdep üobject activate method to ensure that the guest page address that is passed is used as the parameter to the ugmpgtbl üobject setentry method with read, write and no-execute protections.Note, aprvexec (unverified) üobject is not verified since its properties follow from the ugmpgtbl üAPI invariants ensured by our composition check as described in §7.2.1.