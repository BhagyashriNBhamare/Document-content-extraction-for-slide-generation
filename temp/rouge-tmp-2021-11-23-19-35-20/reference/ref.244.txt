We show that these inconsistencies can enable attackers to bypass email authentication to impersonate arbitrary senders, and forge DKIM-signed emails with a legitimate site's signature. Absent knowledge of our attacks, for many of them even a conscientious security professional using a state-of-the-art email provider service like Gmail cannot with confidence readily determine, when receiving an email, whether it is forged. Attackers can exploit such inconsistencies to bypass security policies and subvert the system's operation.In this paper, we provide a case study of such composition issues in the context of email (SMTP) sender authentication. To combat email spoofing, modern email servers employ several SMTP extensions-SPF, DKIM, and DMARCto authenticate the sender's purported identity, as the basis for displaying in email clients assurances of validity to users when they read messages. The second class ("UI-mismatch") exploits inconsistencies between mail servers and the mail clients used to read email, such that the server and the client authenticate/display different email addresses. Alice's email is first transmitted to her service provider via her mail user agent (MUA). SMTP's original specification lacked mechanisms to authenticate the sender's identity, enabling any Internet host to impersonate another's identity by sending spoofed emails. In addition, SMTP introduces multiple other sender identities, such as the HELO command, Sender and Resent-From headers. Sender Policy Framework (SPF) allows a domain owner to publish DNS records to specify which servers are allowed to send emails for the domain. When the destination server receives the email, it queries the domain in the d= field of the DKIM-Signature header to obtain the signer's public key, and verifies the DKIM signature's validity.DKIM -Signature: v =1; a=rsa -sha256 ; c= relaxed / relaxed ; d= example . SPF authenticates the HELO/MAIL FROM identifier and DKIM authenticates the d= field in DKIM-signature header: neither of them authenticates the From header displayed to the end-user, which means that even if an email passes SPF and DKIM validation, its From address can still be forged. Domain-based Message Authentication, Reporting & Conformance (DMARC) is designed to fix this final trust problem by building on SPF and DKIM. The receiving server performs an identifier alignment test to check whether the domain in the From header matches the domain name verified by SPF or DKIM. An email sent by a Sending Server goes through two phases before reaching the end-user recipient: authentication by the Receiving Server, and display by the mail user agent (MUA). We consider three types of spoofing attackers: forgery attackers, replay attackers, and attackers who have accounts on legitimate email services. These attackers can obtain such DKIM-signed emails from, for example, advertisement emails, registration emails, or public mailing lists.Malicious users of legitimate email providers exploit the failure of some email providers to perform sufficient validation of emails received from local MUAs. In such a deployment environment, an email authentication system should prevent spoofed email from ever passing the authentication tests, ensuring that end-users always see authenticated email sender addresses.Security requirement. To achieve this goal, an email system should provide the following basic security requirement: The end-user Bob who uses email client C to receive an email from receiving server R can determine that the message is indeed from user Alice of sending server S, if and only if: (1) The From header of the email that S sends matches the authenticated username (other users of S cannot spoof Alice's address); (2) SPF/DKIM/DMARC components in R can obtain S's DNS correct policy; (3) SPF/DKIM and DMARC components in R consistently authenticate the same identifier; (4) the identifier that R authenticates is consistent with the identifier that C shows to Bob.Challenges in preserving the requirement. To investigate how real-world systems handle these challenges, we conducted a security analysis of popular email providers and MUAs.Selecting email providers and clients. We chose to test email providers that 1) verify SPF/DKIM/DMARC for incoming email, 2) allow us to register accounts for testing, and 3) reflect SPF/DKIM/DMARC authentication results in the email headers. Finally, we manually analyzed the identified behaviors to verify the likelihood of success in practice.We define an email authentication mechanism as broken when the following both hold: 1) the email server erroneously verifies the test email's sender as not spoofed, for example, DMARC authentication produces a "pass" result; 2) the MUA erroneously indicates that the sender address is from a (legitimate) target domain rather than the attacker's sending domain.To extend our results to closed-source proprietary systems, we first examined popular open-source SMTP implementations, 3 to understand their possible interactions and find potential ambiguities. Guided by these results, we then probed the possible internal logic of black-box systems, testing any discovered ambiguities to assess whether they reflect similar vulnerabilities.Leveraging this approach, we found three categories of attacks leading to "broken" authentication results: intra-server, UI-mismatch, and ambiguous-replay attacks. Ambiguity b/w SPF&DMARCAmbiguity b/w DKIM&DNS Ambiguity b/w DKIM&DMARC Gmail.com (A 3 ) iCloud.com (A 5 ) (A 4 ) Outlook.com Yahoo.com Naver.com (A 4 ) Fastmail.com Zoho.com (A 5 ) (A 4 ) Tutanota.com (A 2 , A 5 ) (A 4 ) Protonmail.com (A 5 ) (A 4 ) Mail.ru"": vulnerable to specific attack(s) due to internal inconsistencies. SMTP employs two different identifiers-HELO and MAIL FROM-to represent the email sender who transmits a message. The SPF standard (RFC 7208) states that SPF verifiers should check both; checking MAIL FROM is mandatory, and HELO is recommended. When the SPF component cannot verify the MAIL FROM address, but can verify the HELO identifier, the DMARC component might still use the MAIL FROM identifier for its alignment test. Some SPF implementations treat "(any@legitimate.com" as an empty MAIL FROM address, and thus forward the results of checking HELO to the DMARC component, because the string in the parentheses can be parsed as a comment according to RFC 5322 [10]. An attacker can craft ambiguous domains to make the authentication component believe that it's verifying the legitimate domain, but the DNS component actually queries the attacker's domain to obtain policy records. They then sign the message with their own private DKIM key to generate the DKIM-Signature header, which specifies the "d=" tag as legitimate.com and the 's=' tag as "attacker.com. When the Gmail server receives the email, its DKIM component queries the domain s._domainkey.d, i.e., "attack.com.\x00.any._domainkey.legitimate.com", to obtain the public key. RFC 8601 defines the Authentication-Results header to provide a common framework for communicating these Here, "spf=pass" and "dkim=pass" indicate that the message passed both SPF and DKIM verification for the mail server for example.com. Although many applications require domain names to follow specific syntax rules-for example, domain name registrars only allow users to register domain names under the LDH rules (only letters, digits, hyphens)-the DNS protocol does not impose any restrictions on the characters in a domain label.In particular, an attacker can introduce malformed domains that include meta-characters, for example "a.com(. Per Figure 5d, attackers can generate DKIM-Signature headers using their own private keys, with "d=" values that embed a literal open parenthesis, such as "legitimate.com(. When receiving this message, the DKIM component queries "selector._domainkey.legitimate.com(. Here, the mail server takes the second "@" as the delimiter, and recognizes it as a valid email address, while the SPF component takes the first "@" as the delimiter, and thus queries "legitimate.com'@a.attack.com"-the attacker's domain-to verify the sending IP address. RFC 5322 states that an email message must have exactly one From header, which implies that email messages with multiple From headers are invalid and should be rejected by receiving services.We find that 19 out of 29 tested implementations (including 5 email providers and 14 MUAs) do not in fact follow the specification and reject such messages. iCloud.com (Web) and Mail (Windows) display the last From header; Mail (MacOS) shows both headers; and the other 11 MUAs display the first From header.Thus, attackers can mislead the presentation to the user of email sender validity by using a mail server that (1) accepts multiple From headers, (2) with a different preference than the user's email client. Protonmail.com (Server) rejects the first and second case, Yahoo.com (Server) rejects the third case. Mail.ru (Server)'s DMARC component recognizes the folding-space-succeeded From header and authenticates attack.com, but Outlook (Windows) takes it as an unknown header and presents admin@legitimate.com as the validated From header.Sometimes we can even fool the email servers and MUAs that use the same header parsing and processing, by leveraging special forwarding behaviors of the email servers. Gmail.com (Web) shows the Resent-From header value when the From header is missing; the other 6 display the Sender header value in the From field. As shown in Figure 6d, Naver.com (Server) recognizes a folding-spacesucceeded From header and verifies attack.com, but Outlook (Windows) doesn't recognize it and shows the (unverified) Sender header value in the From field.Attackers can also combine different techniques to chain multiple features to bypass strict security validation. Gmail.com (Server) has strict message validation: it rejects messages with multiple From header to be parsed as a "folded" line, i.e., a continuation of the Authentication-results header. Gmail.com (Web) ignores the empty From header, and displays the Resent-From header value as the message sender. The local part can be a string with or without quotes.Route portion is an obsolete feature originally defined in RFC 822 to indicate the delivery path that the message should follow. For example, RFC 5322 Appendix A.5 states that "From: Pete(A nice \) chap) <pete(his account) @silly. To permit the use of these characters as uninterpreted data, email senders can use '\' to escape them.Encoding coding and quoted-printable encoding. For example,"From: bob<b@b.com>" can be encoded as "From: =? Gmail.com (Server) and Mail.ru (Server) reject the messages; Tutanota.com (Web) displays the last address; Zoho.com (Server) and iCloud.com (Web) don't verify or display any address; 2 mail servers and 4 MUAs verify or display all of the addresses; all the others take the first address.Multiple email addresses enable two new kinds of ambiguities. In our experiments, Yahoo.com (Server), Outlook.com (Server), iCloud.com (Server), Fastmail (Server), Zoho.com (Server) and Tutanota.com (Server) don't recognize the encoded address, and use attack.com for DMARC testing; but Gmail.com (Web), Outlook.com (Web), Yahoo.com (Web), Naver.com (Web), Mail (MacOS), Mail (Windows) and Mail (iOS) support this encoding feature, and only display the first address.3) Route portion (A 11 ). Mail.ru (Server) and Zoho.com (Server) DMARC component believes that "<" has higher priority, and authenticate attack.com; but Outlook (Windows) and 8 other MUAs have a different preference, and only display legitimate.com.Differences in parsing display names and real addresses provide another source of ambiguity. As shown in Fig- ure 8f, Thunderbird (Linux), Mail.ru (Web), Gmail.com (Server) and Mail.ru (Server) mistakenly validate or display admin@legitimate.com as the real sender but Outlook.com (Server), iCloud.com (Server), Protonmail.com (Server) and 9 other implementations recognize it as attack.com.Broader issues. -": email providers that don't support third-party MUAs for our testing account.pass Outlook.com authentication by appending invisible characters to the target domain, for example, "From: admin@legitimate.com\u2000". header with Base64-encoded email address, e.g., "From: base64encode(admin@legitimate.com)", the DMARC module of Yahoo.com (Server) authenticates the encoded domain, but its web interface shows the decoded address.3) From alternative headers (B 3 ). An attacker can craft ambiguous emails by adding a new header (e.g., Subject) to the signed mail, if two parties in the email process chain parse and interpret the extra header differently; for example, if the DKIM component uses the original Subject header while the mail client uses the crafted Subject header.While RFC 6376 § 5.4.2 states DKIM components must use the last header if a message has duplicate headers, we find that DKIM components and email clients indeed sometimes lack consistency in processing multiple headers. For example, Google Groups usually appends unsubscribe information at the end of each forwarded email. When the Gmail web interface displays this message, it uses the MIME boundary defined by the attacker and only shows the attacker's content, because RFC 2046 § 5.1.1 specifies that any content before the boundary is treated as preamble and not displayed by email clients.We conducted a preliminary assessment of this problem by collecting emails from wikileaks.org, IETF mailing lists, and our personal emails. Gmail.com (Server), Zoho.com (Server), mail.ru (Server) accept From headers like "From:admin@a.com\,<user@a.com>" and only check the second one. An attacker with an account on an email service can also employ replay attacks to forge DKIM-signed emails even for email providers that perform strict From header validation, such as Outlook.com.The spoofing attack (A 18 ) proceeds in two steps. They stated they were assessing how to mitigate the issues we reported.iCloud.com, Tutanota.com and Thunderbird: thanked us for our report and stated they were actively fixing these issues.Microsoft: disregarded our report (which included our paper and a video 5 demoing the A 10 attack) because the threats rely on social engineering, which they view as outside the scope of security vulnerabilities.Yahoo.com: misunderstood our report (which included our paper and a video 6 demoing the attack in Figure 8b) as reflecting DNS misconfiguration issues, which we have clarified, but to date have received no further reply. While a strict specification can clarify and regulate protocol fields with confusing semantics, problems often arise when implementations lack a comprehensive understanding of the specifications.Second, text-based protocols with complex syntaxes can lead to a variety of parsing inconsistencies. For example, if a message lacks a Subject header, "h=subject" will prevent an attacker from adding one to the signed message.Combining these two features, a domain owner can prevent replay attacks by setting "h=from:from" for messages with one From field. We also caution that hardening a weak authentication system by composing it with additional security components, such as sanitizers or monitors, itself can introduce complex compositions that create new vulnerabilities, as we showed in Figures 6c and 6e. One possible mitigation solution 7 is for mail servers to provide authentication information to email clients directly, so that email clients can avoid re-parsing and re-verifying complex messages. While the specifics of the attacks reflect the particulars of various email protocols and mechanisms, in abstract terms the attacks leverage several classes of vulnerabilities likely present in other complex multi-component services.In general, it is difficult to make components built by different developers fully consistent: 1) specifications allow for latitude in interpreting details; 2) it is easy to overlook the possibility of deliberate ambiguities in attacker-provided inputs; 3) specifications themselves evolve over time, with some components keeping outdated functionality for compatibility; 4) components can differ in which subset of a suite of complex features they implement; 5) components can vary in how they tolerate non-compliant inputs; and 6) functional equivalencechecking between complex components is intractable.Many of the vulnerabilities we found arise not from programming mistakes but intended features. This attack is similar but not the same as our A 10 attack that uses encoding: his attacks encode control characters in From headers to exploit parsing errors in email clients, while our attacks encode spoofed email addresses to exploit inconsistencies between email servers and clients.Replay attacks are a known problem noted in the DKIM specification [4], which in § 8 warns DKIM users of attacks involving extra header fields and the "l=" tag. Fortunately, all of them validate MAIL FROM and DKIM-Signature domains strictly (by verifying domain ownership), which makes DMARC bypassing difficult. Our attacks confirm the general problem they sketched; for example, many UI-mismatch attacks we found have their roots in the complexity of the From header syntax.In addition to SMTP, inconsistency problems also exist in other computer systems, such as IP packet processing [9,[29][30][31][32][33], HTTP and web systems [34][35][36][37][38][39], file processing [40][41][42][43] and abuse of other operating system resources [44]. All 10 email providers and 19 MUAs in our experimental testing proved vulnerable to multiple of the 18 attacks that we developed.As our software systems become increasingly complex, the need for building them out of disparate independent components rises. This work was supported in part by the National Science Foundation via grant CNS-1237265, and by a gift from Google.