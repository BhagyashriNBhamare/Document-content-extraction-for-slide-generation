Information hiding (IH) is an important building block for many defenses against code reuse attacks, such as code-pointer integrity (CPI), control-flow integrity (CFI) and fine-grained code (re-)randomization, because of its effectiveness and performance. However, recent works have shown that IH is vulnerable to various attacks. Information hiding (IH) is a software-based security technique, which hides a memory block (called "safe area") by randomly placing it into a very large virtual address space, so that memory hijacking attacks relying on the data inside the safe area cannot be performed. Some of these attacks use special system features to avoid system crashes when scanning the memory space [19,35]; some propose new techniques to gauge the unmapped regions and infer the location of a safe area [43]; some exploit the thread-local implementation of safe areas, and propose to duplicate safe areas by using a thread spraying technique to increase the probability of successful probes [20]; others suggest that cache-based side-channel attacks can be used to infer the location of safe areas [22]. Prior IH techniques have failed because they solely rely on the program crashes to detect attacks, but recent attacks have devised novel methods to reduce entropy without crashing the programs.SafeHidden avoids these design pitfalls. It mediates all types of probes that may leak the locations of the safe areas, triggers a re-randomization of the safe areas upon detecting legal but suspicious probes, isolates the thread-local safe areas to maintain the high entropy, and raises security alarms when illegal probes are detected. To address this challenge, after re-randomizing the safe areas, SafeHidden utilizes hardware transactional memory (i.e., Intel TSX [2]) to determine which TLB entries were loaded before re-randomization and preload these entries to avoid future TLB misses.Detecting TLB misses is further complicated by a new kernel feature called kernel page table isolation (KPTI) [1]. Because KPTI separates kernel page tables from user-space page tables, TLB entries preloaded in the kernel cannot be used by the user-space code. • It develops a novel technique to integrate SafeHidden with KPTI, which may be of independent interest to system researchers. Information hiding (IH) technique is a simple and efficient isolation defense to protect the data stored in a safe area. It makes sure that no pointer pointing to the safe area exists in the regular memory space, hence, making it unlikely for attackers to find the locations of the safe areas through pointers. Instead, normal accesses to the safe area are all done through an offset from a dedicated register. Others use the stack pointer register on X86 64, %rsp, that originally points to the top of the stack. High No RERANZ [57] Real Return Address Table %gs The table that contains the return addresses pushed by call A safe area is usually designed to be very small. To locate a safe area, attackers may either improve the memory scanning technique to avoid crashes, or trigger the defense's legal access to the safe area and infer its virtual address using side-channels. But, it can be captured by an exception handler instead of crashing the system.Attackers could also use memory management APIs to infer the memory allocation information, and then locate the safe area. In a user's memory space, there are many unmapped areas that are separated by code and data areas. Because a safe area is mostly placed in an unmapped area, an attacker can probe its surrounding areas to find its location without causing exceptions or crashes.All probing attacks need to use such covert techniques to probe the memory many times without causing crashes because the size of a user's memory space is very large. To translate a virtual address to a physical address, the MMU initiates a page table (PT) walk that visits each level of the page table sequentially in the memory. As only certain virtual addresses map to a specific cache set, the virtual address of the safe area can be inferred using cache side-channel analysis.However, it is worth mentioning that to successfully determine the virtual address of one memory area, hundreds of such Prime+Probe or Evict+Time tests are needed. We assume the design of the defense is not flawed: That is, before launching code reuse attacks, the attacker must circumvent the defense by revealing the locations of the safe areas (e.g., using one of many available techniques discussed in Section 2.2). We assume the underlying operating system is trusted and secured.We assume the existence of some vulnerabilities in the application that allows the attacker to (a) read and write arbitrary memory locations; (b) allocate or free arbitrary memory areas (e.g., by interacting with the application's web interface or executing script directly); (c) create any number of threads (e.g., as a JavaScript program). Particularly, we consider the following attack vectors. • Vector-1: Gathering memory layout information to help to locate safe areas, by probing memory regions to infer if they are mapped (or allocated); • Vector-2: Creating opportunities to probe safe areas without crashing the system, e.g., by leveraging resumable exceptions; • Vector-3: Reducing the entropy of the randomized safe area locations to increase the success probability of probes, by decreasing the size of unmapped areas or increasing the size of safe areas; • Vector-4: Monitoring page-table access patterns using cache side-channels to infer the addresses of safe areas, while triggering legal accesses to safe areas. The design of trap areas mitigates the attacks from Vector-2, and significantly limits the attackers' ability to probe the memory persistently. To block Vector-3, SafeHidden prevents unlimited shrink of unmapped areas and unrestricted growth of safe areas: (1) Unmapped areas. maximum size of the mapped area allowed by SafeHidden is 64 TB, which is half of the entire virtual address space in the user space. When the thread-local safe area is protected using such a scheme, the entropy will not be reduced by thread spraying because any thread sprayed by an attacker can only access its own local safe area.To mitigate Vector-4, SafeHidden also monitors legal accesses to the safe area that may be triggered by the attacker. As the virtual address of the safe area is changed during re-randomization, the corresponding PTEs and their cache entries that are used by the attacker to make inferences no longer reflects the real virtual address of the safe area. In the following subsections, we will detail how SafeHidden recognizes and responds to the stealthy memory probes (see Section 4.1), how SafeHidden achieves the threadprivate memory (see Section 4.2) and how SafeHidden defeats cache-based side-channel analysis (see Section 4.3). The attackers could use them to reason about the memory layout of the parent process from a child process. As shown in Table 2, SafeHidden intercepts different types of memory accesses to these areas and applies different security policy accordingly:• If the event is an access to an unmapped area, SafeHidden will randomize the location of all safe areas. • If the event is an access to trap areas through memory access instructions, memory management system calls, or system calls with EFAULT return value, it will trigger a security alarm. For accesses to unmapped areas, an immediate alarm may cause false positives because the application may also issue memory management system calls, system calls with an EFAULT return value, or a memory access that touches unmapped memory areas. The modification of the kernel is too complex, which cannot be implemented as a loadable kernel module: For example, to be compatible with kswapd, the reference page table must be synchronized with the private page tables of each thread, which requires tracking of CPU accesses of each PTE (especially the setting of the accessed and dirty bits 2 by CPU). Currently, a memory access in a guest VM needs to go through two levels of address translation: a guest virtual address is first translated into a guest physical address through the guest page table (GPT), which is then translated to its host physical address through a hypervisor maintained table, e.g., the extended page table (EPT) [38] in Intel processors, or the nested page table (NPT) [56] in AMD processors. two threads of the same program, both the virtual CR3 registers point to the page table of the program, and both EPT pointers (EPTPs) of VCPUs are pointing to a shared EPT.To implement a thread-private memory, we can instead make each EPTP to point to a separate EPT to maintain its own thread-private memory. But when Thread0 tries to access P1, it will trigger an EPT violation exception when the hardware walking EPT0 and be captured by the hypervisor.In such a scheme, when a thread is scheduled on a VCPU, the hypervisor will set EPTP to point to its own EPT. SafeHidden mitigates such attacks by intercepting TLB misses when accessing safe areas.To only intercept the TLB miss occurred in safe areas, SafeHidden leverages a reserved bit in a PTE on X86 64 processors. Thus, when a TLB miss occurs, it is trapped into the page fault handler and triggers the following actions: (1) It performs one round of randomization for the safe area; (2) It clears the reserved bit in the PTE of the faulting page; (3) It loads the PTE (after re-randomization) of the faulting page into the TLB; (4) It then sets the reserved bit of the PTE again. Second, as the location of a safe area is changed after a randomization, it will cause many TLB misses when the safe area is accessed at the new location, which may trigger many false alarms and re-randomizations. To address this problem, SafeHidden reloads the safe area's PTEs that were already loaded in the TLB back to the TLB after re-randomization. Therefore, SafeHidden can quickly find out all loaded PTEs before the re-randomization and reload them for the new location in the TLB without triggering any page fault exception.Integrating SafeHidden with kernel page table isolation (KPTI) [1] introduces additional challenges. It separates the kernel page tables from user-space page tables, which renders the pre-loaded TLB entries of the safe areas in kernel unusable by the user-space application. Specifically, we consider a defense system with only one safe area hidden in the unmapped memory space. We abstract the attackers' behavior as a sequence of memory probes, each of which triggers one re-randomization of the safe area and creates a new trap area.P c ith =            (i · P t ) · i−1 ∏ j=1 (1 − P h − j · P t ) i f i ≤ M (M · P t ) · ( M ∏ j=1 (1 − P h − j · P t )) · (1 − P h − M · P t ) i−1−M i f i > M (1)The probability of detecting probes. When the size of the safe area is set to 8 MB, and the maximum size of all trap areas is set to 1 TB, as shown in Figure 3(a), P c n increases as the number of probes grows. When the number of probes reaches 15K, SafeHidden detects the attack with a probability of 99.9%; P c n approaches 100% as the number of probes reaches 20K. Obviously, in the real world situation, the attacker's success probability will be even lower, and the attack will be caught much sooner.P s ith =            P h · i−1 ∏ j=1 (1 − P h − j · P t ) i f i ≤ M P h · ( M ∏ j=1 (1 − P h − j · P t )) · (1 − P h − M · P t ) i−1−M i f i > M(2) SafeHidden is designed as a loadable kernel module. In the GuestKM, the Syscall Interceptor and the #PF Interceptor modules are used to intercept system calls and page fault exceptions. When these two types of events are intercepted, they will request the Checker module to determine if SafeHidden needs to raise a security alarm, or if it needs to notify the Randomizer module to perform randomization. It configures the EPT paging structures, enables virtualization mode, and places the execution of the non-virtualized OS into the virtualized guest mode (non-root VMX mode). Because the guest is a mirror of the current running system, the default EPT stores a one-to-one mapping that maps each guest physical address to the same host physical address.Task-2: installing hooks in guest kernel. When the guest starts to run, GuestKM will be triggered to install hooks to intercept three kinds of events: 1) To intercept the system calls, GuestKM modifies the system call table's entries and installs an alternative handler for each of them; 2) To intercept the page fault exception, GuestKM uses the ftrace framework in Linux kernel to hook the do page fault function; 3) To intercept context switches, GuestKM uses the standard preemption notifier in Linux, preempt notifier register, to install hooks. Once a safe area is recognized, its PTEs will be set invalid by setting the reserved bits.To determine whether a safe area is thread-local or not, GuestKM monitors the event of setting the dedicated register in child threads. As described in Section 4.1 and 4.3, when GuestKM needs to perform randomization, it invokes the customized implementation of do mremap() function in the kernel with a randomly generated address (by masking the output of the rdrand instruction with The 0x7ffffffff000) to change the locations of the safe areas. The user-mode page table used in the user mode contains all user-space address mappings and a minimal set of kernel-space mappings for serving system calls, handling interrupts and exceptions. To accelerate the page table switching, the roots of the page tables (i.e., PGD kernel and PGD user in Figure 5) are placed skillfully in the physical memory so that the kernel only needs to set or clear the bit 12 of CR3.Moreover, to avoid flushing TLB entries when switching page tables, the kernel leverages the Process Context Identifier (PCID) feature [2]. This is because SafeHidden only runs in the kernel mode-it uses the kernel-mode page table with kPCID, but the TLB entries of the safe areas must be loaded from the user-mode page table using uPCID.An intuitive solution is to map SafeHidden into the kernel space portion of the user-mode page tables. However, this method introduces more pages into the user-mode page tables and thus increases the attack surface of the Meltdown attack.We propose the following alternative solution: SafeHidden still runs in the kernel mode using the kernel-mode page table. Then without switching to the user-mode page table, it accesses the safe area pages to load the target PTEs into the TLB with uPCID.There is no need to switch to the user-mode page table for two reasons: (1) TLB entries are only tagged with PCIDs and virtual addresses; (2) the user-space addresses are also mapped in the kernel-mode page table. This is to avoid these TLB entries (tagged with uPCID) to be exploited by the Meltdown attack.Listing 1 illustrates the details of how to load user PTEs into the TLB from the kernel mode code under KPTI. Because line 12-21 code runs under the kernel-mode page table with uPCID, this code page mapping will be loaded into the TLB that can be accessed by user-mode code later. SafeHidden uses Intel TSX to test which PTEs of the safe areas are loaded in the TLB. If a thread has a thread-local safe area, GuestKM will issue a hypercall to notify the hypervisor to initialize an EPT for this thread. When initializing an EPT, SafeHidden will configure the entries based on other threads' local safe areas by walking the GPT to find all physical pages in the safe areas. When GuestKM knows a new thread is switched in through the sched in(), it will check whether the thread has a private EPT or not, and switches to its EPT in if it does.Monitoring illegal accesses. When SafeHidden is used to protect web servers, alarms can be integrated with application firewalls to block the intrusion attempts. We implemented SafeHidden on Ubuntu 18.04 (Kernel 4.20.3 with KPTI enabled by default) that runs on a 3.4GHZ Intel(R) Core(TM) i7-6700 CPU with 4 cores and 16GB RAM. For each instrumented instruction, OCFI obtains its jump target and checks if it is within the legal range.SS is our implementation of a shadow stack, which is an example of the thread-local safe areas (see Table 1). SS adopts a compact shadow stack scheme [41] (in contrast to a parallel shadow stack scheme). Each experiment evaluates its defense against one attack vector.In the first experiment, we emulated an attack that uses the allocation oracles [43] to probe Firefox browsers under OCFI's protection. In the second scenario, even though the attacks can gauge the exact size of an unmapped area, they always stumble into one of the trap areas when accessing the surroundings of the unmapped area, which triggers security alarms.In the second experiment, we launched 10,000 trials of CROP attacks [19] to probe a Firefox protected by OCFI. This experiment shows that SafeHidden can prevent the continuous probing attacks effectively.In the third experiment, we launched 10,000 trials of the CROP attack using thread spraying to probe Firefox protected by SS. We sprayed 2 14 (=16,384) threads with more than 16,384 thread-local safe areas, and then scanned the Firefox process with a CROP attack. For the experiment of CPU computation, we ran SPEC CPU2006 benchmarks with ref input and multi-threaded Parsec-2.1 benchmarks using native input with 8 threads; For the experiment of network I/O, We chose the Apache web server httpd-2.4.38 and Nginx-1.14.2 web server. Nginx was configured to work with 4 worker processes; For the experiment of disk I/O, we chose benchmark tool Bonnie++ (version 1.03e). This is due to two reasons: (1) All threads need to be blocked when randomizing the thread-shared safe areas or the thread-local safe areas (when not triggered by a TLB miss); (2) When protecting the thread-local safe areas, SafeHidden needs to synchronize the thread-private EPTs with the guest page table, which could introduce VM-Exit events. We can also see that SafeHidden incurs 12.18% and 12.07% on average when applied to SS and OCFI to protect Apache. But for each request to Apache, Apache will invoke the mmap() system call to map the requested file into the virtual memory space which could trigger the extra randomization of all safe areas compared with Nginx; (2) Apache is a multi-threaded program. When TLBleed is used against SafeHidden, by triggering only L1 DTLB misses without L2 TLB misses, TLBleed may reduce the entropy of the safe area location by 4 bits (in the case of a 16-set L1 DTLB), which leads to roughly 20 bits entropy remaining for 8 MB safe area. As the memory protection related exceptions are suppressed in the speculatively executed code, SafeHidden could not detect Spectre attacks.Resilience to attacks. To avoid this, the entry of the NMI handler could be instrumented (by rewriting the NMI entry in IDT) to switch back to the kPCID. For example, using Vector-2, persistent attacks could always succeed. These CFI mechanisms must protect their metadata either by memory isolation [8,53,42,41,37] or IH [40,60,61]. SafeHidden extends this method to detect side-channel attacks against the safe areas, which is the first time to our best knowledge such a feature is used in security.Trap areas as security defenses. The EPT has been used to isolate VMs [26], to protect processes from the malicious OS and/or other processes [18,50,24], and to protect sensitive code/-data within a process [34]. A new thread-private memory mechanism is proposed to isolate the thread-local safe areas and prevent the adversaries from reducing the randomization entropy via thread spraying. Yinqian Zhang is supported in part by gifts from Intel and DFINITY foundation.