We present detailed benchmarking of floating point performance for various operations based on operand values. We evaluate the vector-operation based defensive mechanism proposed at USENIX Security 2016 by Rane, Lin and Tiwari and find that it only reduces, not eliminates , the floating-point side channel signal. • Shift sensitive floating-point computations to the GPU or other hardware not known to be vulnerable.At USENIX Security 2016, Rane, Lin, and Tiwari [15] proposed additional mitigations:• Use program analysis to identify floating-point operations whose inputs cannot be subnormal; these operations will not experience subnormal slowdowns. • Run floating-point operations whose inputs might be subnormal on the the processor's SIMD unit, loading the a SIMD lane with a dummy operation chosen to induce consistent worst-case execution time.Rane, Lin, and Tiwari implemented their proposed mitigations in a research prototype Firefox browser. Andrysco et al.'s attack on Firefox, and the attacks on browsers we present, use SVG filter timing to break the Same-Origin Policy, an idea introduced by Stone [16] and Kotcher et al. [13]. For the purposes of this paper we will refer to floating point, floats, and doubles to mean the IEEE-754 floating point standard (see Figure 1) unless otherwise specified.The floating point unit (FPU) accessed via Intel's single scalar Streaming SIMD (Single Instruction, Multiple Data) Extensions (SSE) instructions adheres to this standard on all processors we discuss. If the exponent has any non 0 bits the value is normal, and the significand has an implicit leading 1 bit. If the exponent is all 0 bits (i.e., exponent − bias = −bias) then the value is subnormal, and there is no implicit leading 1 bit. As Andrysco et al. [2] observe, subnormal values do not frequently arise, and special hardware or microcode is used to handle them on most CPUs.Andrysco et al.'s attacks made use of the substantial timing differences between operations on subnormal (or denormal) floating point values and on normal floating point values. See Figure 8 for a list of non-normal IEEE-754 value types. However, since the rendering time of the SVG filter is visible to the attacker page, and the rendering time is dependent on the <iframe> content, the attacking page is able to violate this policy and learn pixel information. Unsurprisingly, double precision floating point numbers show more types of, and larger amounts of, variation than single precision floats.Figures 4, 5, 6, and 7 are crosstables showing average cycle counts for division and multiplication on double and single precision floats on the Intel i5-4460. Bold face indicates a computation that had a standard deviation of > 1 cycle (none of the tests on the Intel i5-4460 had standard deviations above 1 cycle). This apparatus measures the steadystate execution time of each computation.The entirety of our data across multiple generations of Intel and AMD CPUs, as well as tools and instructions for generating this data, are available at https://cs eweb.ucsd.edu/~dkohlbre/floats.It is important to note that the Andrysco et al. [2] focused on the performance difference between subnormal and normal operands, while we observe that there are additional classes of values worth examining. Many of these implementations no longer used floating point math, instead using their own fixed point arithmetic.As the feConvolveMatrix implementation now consists entirely of integer operations, we cannot use floating point timing side channels to exploit it. Single Precision Add/Sub - - - Mul S - - Div S - - Sqrt M Z - Double Precision Add/Sub - - - Mul S - - Div M Z Z Sqrt M Z Z The fixed point implementation used in Firefox SVG filters is a simple 32-bit format with no Not-a-Number, Infinity, or other special case handling. Our Firefox SVG timing attack makes use of the feSpecularLighting lighting model with an fePointLight.This particular filter in this configuration is not ported to fixed point, and performs a scaling operation over the input alpha channel.The surfaceScale property in feSpecularLighting controls this scaling operation and can be set to an arbitrary floating point value when creating the filter. This sets the alpha channel to 1 for a black pixel input, and 0 for a white pixel input.4.2. Firefox has patched the surfaceScale based attack on the feSpecularLighting filter in Firefox 52 and assigned the attack CVE-2017-5407. Since as we have seen these can a 0×subnormal can be 21× faster than a subnormal times a normal, we can easily detect the difference between executing over a black pixel or a white pixel.We have disclosed the attack to Apple, and discussed options for entirely disabling cross-origin SVG filtering. Specifically, Chrome enables the Flush-to-Zero (FTZ) and Denormals-are-Zero (DAZ) flags.These flags are two of the many FPU control flags that can be set. In the case of Chrome, FTZ and DAZ are enabled and disabled manually in the Skia rendering path. We have tested it on Windows 10 (Intel i7-6700k), Ubuntu Linux 16.10 (Intel i5-4460), OSX 10.11.6 (Intel i7-3667U Macbook Air), and a Chromebook Pixel LS ChromeOS 55.0.2883.105 (i7-5500U) on versions of Chrome from 54-56. Since the FTZ and DAZ flags are set only on entering the Skia rendering code, the parsing is not subject to these flags and we can always successfully generate subnormals at parse time.The largest obstacle we bypass is the use of the FTZ and DAZ control flags. Unfortunately none of the current SVG filter implementations we examined have tight division <div id="pixel" style="width:500px;height:500px;overflow:hidden"> <div id="scroll" style="width:1px; height:1px; overflow:hidden; transform:scale(600.0); margin:249px auto"> <iframe id="frame" position="absolute" frameborder="0" scrolling="no" src="TARGET_URL"/> </div> </div> Chrome enables the FTZ and DAZ control flags whenever a filter is set to run on the CPU, which disallows our Firefox or Safari attacks from applying directly to Chrome. This would normally only be useful for a GPU-based attack but we can force the feConvolveMatrix filter to abort from GPU acceleration at the last possible moment and fall back to the CPU implementation by having a kernel matrix over the maximum supported GPU size of 36 elements. Unlike on Firefox or Safari, adding a filter to a <div>'s style and then calling getAnimationFrame is insufficient to be sure that the time until the callback occurs will accurately represent the rendering time of the filter. Escort [15] proposes defenses against multiple types of timing side channels, notably a defense using SIMD vec- [2]. Second, they perform a number of basic block linearizations, array access changes, and branch removals to transform the control flow of the program to constant time and minimize side effects.We do not evaluate the efficacy of the higher level control flow transforms and instead evaluate only the elementary operations.Escort's tool is to construct a set of dummy operands (the escort) that are computed at the same time as the Default libdrag Single Precision Add/Sub - - Mul S - Div S Z Sqrt M Z Double Precision Add/Sub - - Mul S - Div M Z Sqrt M ZSingle Precision Add/Sub S S Mul S - Div S - Sqrt S - Double Precision Add/Sub S S Mul S - Div S - SqrtS - Escort will replace most floating point operations it encounters. libdrag can easily fix this, at serious performance cost, by enabling the floating point replacements for all floating point operations with no exceptions.To determine if Escort closes floating point timing side channel when enabled, we measured the timing behavior of Escort's libdrag floating point operations, as well as the end-to-end runtime of toy programs compiled under Escort. (See figure 9)An interesting outcome of this behavior is that subnormal values cause a speedup under libdrag rather than the slowdown observed under scalar operations.We speculate that this is the result of fast paths in the microcode handling for vector operations. By examining the cycle times for each operation in the default and libdrag case we found that the total cycle time for an escorted add or subtract is approximately equal to the sum of the cycle counts for a subnormal,subnormal operation and the test case. We did not test other SVG filters for vulnerability under the Escort/libdrag modifications.Given the observed timing variations in the AMD Phenom II X2 550 in section 7.2.2 we believe that multiple SVG filters would be timing side channel vulnerable under Escort on that CPU. We have made Rane, Lin and Tiwari aware of these findings.The 'escort' mechanism can only serve as an effective defense if vector operations are computed in parallel. Thus, extracting timing differences from the occational division they do perform is extremely difficult.If a filter were found to perform tight division loops, or a GPU that has timing variation on non-division operations were found, the same attacks as in previous sections could be ported to the GPU accelerated filters.We believe that even without a specific attack, the demonstration of timing variation based on operand values in GPUs should invalidate "move to the GPU" as a defensive strategy. Van Goethem, Joosen, and Nikiforakis [17] observed that callbacks introduced to support HTML5 features allow attackers to time individual stages in the browser's response-processing pipeline, thereby learning response size more reliably than with previous approaches.The interaction of new browser features -TypedArrays, which translate JavaScript variable references to memory accesses more predictably, and nanosecondresolution clocks -allow attackers to learn whether specific lines have been evicted from the processor's lastlevel cache. If this is true, a redesign of the vector processing unit would be required to make Escort effective at closing all floating-point timing channels.We have revisited browser implementations of SVG filters, and found (and responsibly disclosed) exploitable timing variations in the latest versions of Chrome, Firefox, and Safari.Finally, we have shown that modern GPUs exhibit slowdowns in processing subnormal values, meaning that the problem extends beyond x86 processors. Even with a origin policy that blocks the cross-origin pixel stealing, any timing side channel allows an attacking page to run a history sniffing attack. It is possible that floating point instructions are unusual not because they exhibit timing variation but because their operands have meaningful algebraic structure, allowing intelligent exploration of the search space for timing variations; even so, we identified timing variations that Andrysco et al. overlooked.