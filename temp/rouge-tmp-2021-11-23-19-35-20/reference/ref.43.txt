Traditional auditing techniques generate large and inaccurate causal graphs. The evaluation results show that our technique generates cleaner attack graphs with rich high-level semantics and has much lower space and time overheads, when compared with the event loop based partitioning techniques BEEP and ProTracer. Most existing techniques [38,46,49,50,59] entail hooking and recording important system level events (e.g. file operations), and then correlating these events during an offline investigation process. For instance, a Firefox process may visit numerous pages over its lifetime while only one page is related to a driveby-download attack.Researchers proposed to partition execution to units so that only the events within a unit are considered causally related [43,46]. Although existing execution partitioning based systems such as BEEP [43] and ProTracer [46] have demonstrated great potential, they partitioned execution based on event handling loops. (2) There are often inter-dependencies across units. (3) A high level task is often composed of many units (e.g., those denoting event loop iterations in multiple worker threads that serve the same high level task). Therefore, developers' input on what denotes a task/unit is necessary. Our proposal is hence to allow the developer/user to inform our system what task/unit structure they desire by annotating a small number of data structures (e.g., the tab data structure in Firefox). MPI is highly automated as the user only needs to annotate a few data structures and then the invocations to logging commands are automatically inserted through program analysis. In addition, MPI provides a data structure profiler, called the annotation miner, to recommend the potential data structures to annotate. We integrate it with three different provenance collection systems: the widely adopted Linux audit framework, and two state-of-the-art research projects, ProTracer [46] 2 and the LPM [23] enabled HiFi [55] system (LPM-HiFi) which features secure audit logging.In summary, we make the following contributions:• We propose the novel idea of partitioning execution based on data structures to support different granu-1 MPI is short for "Multiple Perspective attack Investigation" 2 ProTracer is based on BEEP, we replace the BEEP with MPI.larities and facilitate multi-perspective, applicationsemantics-aware attack investigation. In this section, we use an example to illustrate the differences between the classic provenance tracking systems [23,49,50,55], the existing event loop based execution partitioning approaches [43,46], and the proposed approach. This example simulates an important kind of real-world attacks, watering hole attack [18,19], Watering hole is a popular attack strategy targeting large enterprises such as Apple [11] and Google [12]. In our example case, a developer in an enterprise opens Firefox, and then uses Bing to look for a utility program for file copying. He also uses a p2p software Transmission to download the videos described by the torrents.Unfortunately, the forum website was compromised, targeting enterprises whose developers tend to use the forum for technical discussion and information sharing. These techniques collect system subjects (e.g. processes and threads) and objects (e.g. files, network sockets and pipes) information at run time with system call hooking or Linux Security Modules (LSM) [62], and construct dependency graph or causal graph for inspection. For the case mentioned in §2.1, the administrator identifies the Firefox process and all its data sources by backtracking, and then discloses the downloaded files and the operations on these files with forward tracking. In Figure 1, many network sockets point to the Firefox process, and the process points to a large number of files including the torrent files and others like fcopy, which reflect the browsing and downloading behaviors of Firefox.While we only show part of the original graph in Fig- ure 1 for readability, the original graph contains more than 500 nodes in total, with most files and network socket accesses being (undesirably) associated with the Firefox and Transmission nodes. It has dependencies with many torrent files and network sockets, obfuscating the true causalities (e.g., a torrent file and the corresponding downloaded file). Assume the administrator applies BEEP/ProTracer to the motivation case in §2.1. He acquires the download event in Firefox, which is associated with the web socket a.a.a.a. Then, he traces back to the forum website, and eventually the search engine. This is because all user interactions like scrolling the web pages, moving mouse pointer over a link and clicking links are processed by unique event loop iterations, each leading to a unit/node. As these events operate on DOM elements, they are connected in the dependency graph due to memory Figure 1: Simplified causal graph for the case in §2.1 generated by traditional solutions (Tool in [16]). dependencies, making the graph excessive.The root cause of the limitation lies in that BEEP exposes very low level semantics (i.e., event loop iterations) in partitioning. It requires intensive training to identify the event handling loops and memory accesses that disclose dependencies across units (e.g., one event loop inserts a task to the queue which is later loaded and processed by another event loop). Note that providing source code does not address this problem as identifying event handling loops and cross-unit dependencies requires in-depth understanding of low level program semantics, which is much easier through dynamic analysis by observing concrete states than static analysis, in which everything is abstract. Partitioning based on event handling loops works nicely for server programs, in which one event loop iteration handles an external request and hence corresponds to a high level task. For example, in GUI programs, units are generated to denote the large number of GUI events (e.g., key strokes), even though all these events may serve the same high level task.Consider the p2p program Transmission. In each iteration of the loop, it waits for 1 second (line 6), updates the torrent status and logs some information (line 7). The overarching idea of this paper is that high level tasks are reflected as data structures. It then leverages program analysis to instrument a set of places that indicate switches and inheritances of tasks to achieve execution partitioning. Hence, MPI allows annotating multiple data structures, each denoting an independent perspective. For instance, a tab may show pages from multiple domains whereas pages from the same domain may appear in multiple tabs. Figure 5 shows the causal graph for the attack example when we partition the execution of Firefox by its tabs and Transmission by the files being downloaded. Observe that the Bing tab leads to the wordpress tab, which also shows the forum main page. A number of forum pages are displayed on separate tabs, each of which leads to the download of a torrent file through a Transmission unit. The memory dependencies that are needed to chain the low level event loop units are no longer necessary because these low level units are automatically classified to a high level unit in MPI. But if we look at the execution from the tab perspective, these memory dependencies are no longer inter-unit dependencies that need to be explicitly cap-tured. However, such annotations are so low-level that (1) they require a lot of human efforts due to the large number of places that need to be annotated (e.g., the memory dependencies), and (2) they expose low-level and sometimes non-informative semantics such as mouse moves and timer events. The user first annotates the program source code to indicate unit related data structures under the help of the annotation miner, which is essentially a data structure profiler. The analysis component, implemented as a LLVM pass, takes the annotations and analyzes the program to determine the places to instrument (e.g., data structure accesses denoting unit boundaries). Specifically, 1 a task_struct with a unique pid identifies an individual process; 2 a variable current is used to indicate the current active process. In order to perform unit switching, we need to identify the unit data structure that is analogous to task_struct and used to store per-unit information, a field/expression that can be used to differentiate unit instances as the identifier, and a variable that stores the current active unit. Since an identifier must be paired up with the corresponding indicator, we allow providing an indicator id as part of the identifier annotation. A natural way to partition its execution is to partition according to the file it is working on, each represented by a file_buffer data structure. Vim uses the variable curbuf to represent the current active buffer. Consequently, we use curbuf as our indicator variable.Line 2 shows the indicator annotation. In this case, y_current→array can be considered as the IPC channel between the two different file_buffer instances. More specifically, the main thread divides a task into multiple subtasks that can proceed asynchronously and dispatches them to various (background) worker threads. A worker thread receives sub-tasks from the main thread and also other threads and processes them in the order of reception. It can also further break a sub-task to many smaller sub-tasks and dispatch them to other threads, including itself. Observe that at step 1 , the loading of tab1 first dispatches a Domain Name Server (DNS) query to a DNS thread, and then (step 3 ) posts a connection request to the socket thread to download the page. Edges denote memory dependencies across sub-tasks that need to be disclosed during training and instrumented at runtime in BEEP/ProTracer. This annotation is associated with a data structure to denote a sub-task (e.g., the HTTP connection request posted to the socket thread). Intuitively, it is a delegator of a top level task (e.g., the HTTP connection request delegates the unit of its owner tab). Hence, we provide multiple perspectives by annotating the nsPIDOMWindow data structure and using different expressions in the identifier annotations to distinguish the perspectives. The indicator id 1 is for tabs and 2 for windows. When the main thread tries to load a new URI (step 1), it posts an nsConnEvent to the SocketThread (step 2) by calling the PostEvent method (box C). Since nsConnEvent is a sub-class of nsRunnable (box B), the delegator class, the newly created nsConnEvent inherits the tab/window id. □ Annotation Miner. The user provides a pair of executions to denote an intended unit task, one execution containing one unit and the other containing two units. Next, we show how to mine the tab data structure in Firefox ( Figure 12). Each element of the vector denotes the current unit instance for each unit type (or each perspective). If the user has annotated n unit data structures (with n indicators and n identifiers), there are n elements in the vector. Since data structure nsRunnable (box A) is annotated as a delegator and the HTTP connection request nsConnEvent (box B) is a subclass of nsRunnable, MPI propagates the current unit id in the main thread to the worker thread, namely, the socket thread. Inside the socket thread that receives and processes the request (i.e., step 3), loading the request from the task queue causes the change of the queue size indicating a possible unit context switch. It takes a program with the four kinds of annotations mentioned in §3.2, and produces an instrumented version of the program that emits additional syscall events denoting unit context switches and channel operations.MPI needs to identify the following a few kinds of code locations: (1) all the updates (i.e., definitions) to indicator variables, including unit indicators and delegator indicators, to add instrumentation for unit context updates; (2) all the creation/initialization locations of delegator data structures to add instrumentation for the inheritance of unit context; (3) reads/writes of channel variables/fields to add instrumentation for channel event emission and redundancy detection; (4) all the system/library calls that may lead to system calls to add instrumentation for unit event emission and redundancy detection. Specifically, an indicator may be defined multiple times and there may not be any system calls (or library calls that can lead to system calls) in between. The function im_regexec_multi() in Figure 13 searches for a regular expression in Vim. In Figure 13, the definition at line 6 cannot reach any point beyond line 8. Appendix B discusses how to construct attack graphs from MPI logs.In this section, we present the evaluation results including the annotation efforts needed, the runtime and space overheads of the prototype, and a number of attack cases to show the advantages of MPI compared to the event loop based partitioning technique in BEEP [43] and ProTracer [46]. Since BEEP supports only one low-level perspective, we only annotate one perspective in MPI during comparison. These programs do not need to switch between different tasks frequently, which means they rarely trigger the instrumented code. For example in Apache, a remote HTTP request can lead to redirection, and the Apache server needs a few BEEP execution units to handle it. When multiple tabs are opened, Firefox processes them in the background with threads. During our experiments, we had to add test inputs to the training sets of BEEP to ensure the provenance was not broken for a number of applications (e.g., Firefox). We have ran MPI for 24 hours with a regular workload. For programs that do not have standard test benchmarks, but support batch mode (e.g., Vim), we translate a number of typical use cases to test scripts to drive the executions. We preclude highly interactive programs.For each application, we choose the same perspectives as the previous experiment, and the results are shown in Figure 14. In this experiment, we measure the effectiveness of the annotation miner and the number of annotations eventually added. We present the applications in the first column, and their sizes (measured by SLOCCount [13]) in the second column. In the last column, we show the instrumentation places automatically identified by our compiler pass. To evaluate the annotation miner, we use the 20 programs in Table 1. Figure 15 shows the reported data structures for Vim, Firefox and HTTPd. To evaluate MPI's effectiveness in attack investigation, we apply it on 13 realistic attack cases used in previous works [32,43,44,46]. For attacks involving GUI programs (e.g., Firefox), the number is 8%, and in an extreme attack case involving Transmission, it is less than 1%. The number of classified files is also large.In Figure 16, we show a number of possible investigation perspectives for the FTP server application. MPI provides choices that align better with the logical structures of the application, such as the session perspective (box 2), i.e., all the commands/requests from a session belong to a unit, the directory perspective (box 4), i.e., all the commands on a given directory are considered a unit, and the user perspective (box 5), i.e., all commands/requests from a user (not limited to an IP address) belong to a unit. The simplified graph by MPI with connection based partitioning is shown in Figure 18, and user based partitioning in Figure 19. Attacks that can bypass the security mechanisms of these systems may cause problems for MPI. Moreover, attacks that target the underlying audit system, such as audit log blurring and log filling, may inject noise to logs, making log inspection difficult. For example, operating systems like Ubuntu now leverages Ubuntu Software Center to deliver trustworthy software which can be used to protect the MPI binaries for benign software. It can be easily integrated with systems of various granularities.MPI requires program source code. Both GCC and LLVM provide advanced language features [4,6,7] that are triggered by annotations. Detailed comparison of MPI with existing audit systems [10,31,[43][44][45] can be found in §2. System wide record-and-replay techniques [30,[37][38][39] can also track provenance. MPI can be applied to such systems to overcome the dependency explosion problem and enable multiple perspective inspection.In [48], researchers propose to develop provenance aware applications. al. [49] provide a library with provenance tracking APIs so that programmers can develop provenance aware applications. Execution partitioning is important for addressing dependency explosion in audit logging. We implemented a prototype and evaluated it on three existing systems: Linux Audit, ProTracer and LPM-HiFi. Inter-unit communication through system resources such as files, sockets, and the system clipboard can be captured by the default underlying system event tracking module without the intervention of MPI.A naive solution is to emit a unit context switch event upon any indicator update and a channel event upon any channel read/write. However in practice, we observe that (1) an indicator update may not imply the change of the unit context and (2) even though the unit context changes, there may not be any system events that happen in between the two unit context switches. Input:L -the event log l -unit type (i.e., perspective) given in the @indicator annotation e s -symptom eventOutput: G l -the generated causal graph for perspective lVariable: ob js -system objects/subjects relevant to e s s e , pid e -the system object/pid of event e bUnit -if the current unit causally related with e s eventUnit[pid] -the events in the current unit of process pid 1: ob js ← { pid es , s es } 2: bUnit ← true 3: for each event e ∈ L in reverse order, starting from e s do 4:if e is not a unit context switch event then 5:eventUnit [pid]. add(e) 6:if e updates any object or subject in ob js then 7:bUnit ← true 8:if e is a unit context switch event then 9:if e does not switch to a l unit then 10: continue 11: else 12:if bUnit then 13:add events in eventUnit[pid e ] to G l 14:add accessed objects/subjects in eventUnit[pid e ] to ob js 15:eventUnit[pid e ] ← ∅ 16: bUnit ← f alse 17: return G lWe use an ob js set to represent the system objects, subjects, and channels between units that are directly or indirectly related to the symptom event. The algorithm checks the flag to see if the current unit is causally related to the symptom (lines 11-12). The temporary event list and the flag are then reset (lines 15-16). It traverses back and reaches line 7, which is a unit context switch (UCX) event whose indicator is 5 and the identifier value is 7. Note that the value of identifier indicates lines 1-3 and lines 7-8 belong to the same unit (instance), which means that the application is working on the same task. The investigator first conducted forward tracking from the design file but found that the file was neither sent outside by any email nor copied by any employee to their own devices. For Firefox, we choose three different ways to instrument: windows, i.e., a unit for a top level residence window for tabs (note that multiple windows may be driven by the same Firefox process internally); tabs and elements (inside a page). For both cases, a lower level suggests 2-3 times overhead increase.