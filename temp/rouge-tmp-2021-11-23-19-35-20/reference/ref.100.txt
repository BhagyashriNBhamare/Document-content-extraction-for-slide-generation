CORS (cross-origin resource sharing) is a more disciplined mechanism supported by all web browsers to handle cross-origin network access. We find that the design, implementation, and deployment of CORS are subject to a number of new security issues: 1) CORS relaxes the cross-origin "write" privilege in a number of subtle ways that are problematic in practice; 2) CORS brings new forms of risky trust dependencies into web interactions; 3) CORS is generally not well understood by developers, possibly due to its inexpressive policy and its complex and subtle interactions with other web mechanisms, leading to various misconfigurations. Our work aims to provide a comprehensive security analysis of CORS in its protocol design, implementation, and deployment process, and to identify new types of security issues about the deployments of CORS in real-world websites.The issues we found in this study can be classified into three categories: a) Overly permissive cross origin sending permissions. We found that by leveraging this relaxed sending permission, an attacker could exploit previously unexloitable CSRF vulnerabilities, remotely infer victim's accurate cookie size of any website, or use a victim's browser as a stepping-stone to attack binary protocol services inside victim's internal network. We found that an attacker can leverage this inherent risk to launch MITM attack against HTTPS sites or steal secrets on strongly secured target sites by exploiting vulnerabilities on weak websites. By conducting a large-scale measurement on Alexa top 50,000 websites including their 97, 199, 966 distinct sub-domains, we found insecure CORS misconfigurations in 132,476 sub-domains, accounting for 27.5% of all the CORS configured sub-domains across 13.2% of all CORS configured "base domains" (the first lower-level domains of public domain suffixes 1 , sometimes referred to as "public suffix plus one"). For example, remotely exploiting victim's internal binary-protocol services, remotely obtaining victim's accurate cookie size on any website. â€¢ We conducted a large-scale measurement of CORS configurations in popular websites, and found 27.5% of all the CORS configured sub-domains across 13.2% of base domains have insecure misconfigurations. Cross-origin resource access can be classified into two categories: cross-origin local resources access (e.g., for DOM, cookie) and cross-origin network resources access (e.g., for XMLHttpRequest). More specifically, we study the access control mechanisms for both sending cross-origin requests and reading cross-origin responses. In order to ensure that different web applications cannot interfere with each other, Netscape introduced the Same Origin Policy (SOP), the fundamental isolation strategy for client-side web application security. Although SOP prevents JavaScript from reading the response of a cross-origin request (except a few cases such as imported script), it does not prevent client-side JavaScript from sending crossorigin POST requests (e.g., using automatic form submission without user awareness). Combining the three factors, a malicious website can control a victim's browser to issue POST requests with the victim's identity to other websites. Below is an example showing how SMTP commands are encapsulated into a POST request:POST / HTTP/1.1 Host: 192.168.1.1 Content-type: multipart/form-data; boundary=--123 --123 Content-Disposition: form-data; name="foo" HELO example.com MAIL FROM:<somebody@example.com> RCPT TO:<recipient@example.org> --123--There are currently no effective protocol-level solution for these two types of attacks. Thus, browsers often block only a small subset of port numbers, leaving the majority of them exposed. Initially developers invented JSON-P (JSON with Padding) [19] to bypass SOP, by leveraging the exception that an imported cross-origin JavaScript using the <script> tag is accessible to the hosting page. Second, a JSON-P resource needs to have application-level access control to prevent unauthorized read, which complicate web application implementations.In order to provide a safer and more powerful solution for authorized cross-origin resource sharing, W3C designed Cross-Origin Resource Sharing (CORS) [38] protocol to replace JSON-P. Browser vendors such as Mozilla gave priority to the WHATWG's standard [6], resulting in the obsolescence of W3C CORS standard in August 2017 [7]. The resource server generates an access control policy in HTTP response headers (Access-ControlAllow-Origin) indicating the origins allowed to read its resources.3. A non-simple request is considered dangerous, thus requires a preflight request to obtain permission from the resource owner to send the actual crossorigin request.The preflight request is initiated with an OPTIONS method, and includes Origin, Access-Control-Request-Method, Access-ControlRequest-Headers headers. The resource server includes Access-Control-Allow-Origin, Access-ControlAllow-Method and Access-Control-Allow-Headers in its HTTP response to indicate the allowed origins, methods, and headers respectively. In this model, a requesting website script initiates a resource access request from a user's browser, which automatically adds an Origin header to indicate the requester's identity; then the third-party website returns the access control policy; Finally, the browser enforces the access control policy to determine whether the requester can access the requested network resources. In the course of doing so, we identified potential interactions between CORS features and known attacks (specific and general) and their implications.Furthermore, we measure CORS policies of realworld websites to evaluate CORS deployment in the wild. CORS allows "simple requests" to be sent freely by default, to keep consistent with previous policy (cross-origin GET and POST requests are allowed by default). However, these new interfaces (referred to as "CORS interfaces" subsequently) in fact implicitly further relax sending permissions, unintentionally allowing malicious customization of HTTP headers and bodies in CORS simple requests. CORS interfaces provide new capabilities that allow JavaScript to modify 9 CORS whitelisted headers (See Section 2.4). CORS works on the top of HTTP, so when implementing CORS interfaces, browsers should restrict at least those 4 whitelisted header values according to HTTP's BNF rules. In addition, although the five browsers follow CORS standards in limiting Content-Type to three specific values ("text/plain", "multipart/form-data","application/xform-url-encoded"), these restrictions can be bypassed. Thus, an attacker can still craft malicious content in Content-Type headers by appending an attack payload to a valid value.These implementation flaws open new attack surface in that a web attacker can manipulate a victim's browser to craft exploitation payloads using a CORS simple request, using the browser as stepping-stone to compromise vulnerable yet nominally internal-only services.Case study: In order to demonstrate the threat, we conducted an experiment to exploit an internal service by crafting a malicious Content-Type header. In our experiment, this attack enabled us to obtain a shell on the internal server.CORS imposes few limitations on header sizes. Chrome >16MB/>16MB Apache 8KB/<96KB Edge >16MB/>16MB IIS 16KB/16KB Firefox >16MB/>16MB Nginx 8KB/<30KB IE >16MB/>16MB Tomcat 8KB/8KB Safari >16MB/>16MB Squid 64KB/64KBCase Study: web attackers can exploit header size differences between browsers and web servers to launch side-channel attacks, remotely determining the presence of a victim's cookies on any website. To carry out this attack, an attacker first measures the header size limit of a target web server by directly issuing requests with increasing-size headers until receiving a 400 Bad Request response. In Chrome, the Performance.getEntries() API directly exposes whether or not a request is successful: if a response has status code 400, the API will return empty response time.Attackers can further infer more details about victim's cookies, such as the size of cookies with specific path attribute by comparing cookie size under different directories, or the size of cookies with the secure flag by comparing the cookie size in HTTP and HTTPS requests. For example, an attacker might remotely infer the victim's health conditions by looking for visits to particular disease or hospital websites; infer political preferences by visits to candidate websites; or infer financial considerations by whether the victim has an account on lending or investment websites. Such flexibility in composing request body can lead to new security problems.Case Study: We show that an attacker can exploit a file upload CSRF vulnerability which was previously unexploitable. We confirmed that, with CORS, an attacker can exploit this CSRF vulnerability to modify the victim's avatar.CORS has few limitations on body values. However, both CORS standards and CORS interfaces in browsers impose no limitations on the values of request body, which gives attacker greater flexibility.Case Study: We found that it is possible with the new flexibility to exploit binary-based protocol services. By taking advantage of the CORS interfaces, an attacker can craft a cross-origin request, making its header size a multiple of 16 bytes, which is ignored by the AFP server, and constructing its binary body in AFP protocol format for communication with the AFP Server. An attacker can first enter a weakly secured trusted domain, and then abuse this trust relationship to attack a strongly secured target site.We study two typical types of trust relationship and the risks they pose:1) HTTPS site trusting their own HTTP domain. We found that about 12.7% CORS-configured HTTPS websites (e.g., fedex.com) trust their own HTTP domain, and 17.5% CORS-configured websites (e.g., mail.ru) trusted all of its subdomains. However, if an HTTPS site is configured with CORS and trusts its own HTTP domain, then an MITM attacker can first hijack the trusted HTTP domain, and then send a crossorigin request from this domain to the HTTPS site, and indirectly read the protected content under the HTTPS domain.Case Study: Fedex.com (Alexa Rank 470), has fully deployed HTTPS and enabled the secure and httponly flag in its cookies to protect against MITM attacks. In total, we collected 97,199,966 different subdomains over 49,729 different base domains.For each subdomain, we repeatedly changed the Origin header value to different error-prone values in different testing requests, and inferred their CORS configurations according to response headers. We also found that 8 out of 11 popular CORS frameworks undermine CORS's security mechanisms and could generate insecure policies.While some mistakes were caused by negligence, others arose due to the complex details and pitfalls in CORS' design and implementation, which make CORS unfriendly to developers and prone to misconfigurations. The W3C CORS standard states that an Access-ControlAllow-Origin header value can be either an origin list, "null", or "*", whereas in the WHATWG's Fetch standard, it can only be a single origin, "null", or "*". We found a number of misconfigurations are rooted in this category.In general, we can classify the misconfigurations into two sub-categories: 1) blindly reflect requester's origin in response headers; 2) attempt to validate requester's origin but make mistakes.1). For example, www.example.com wants to allow any example.com subdomain, but it only checks whether the Origin header value ends with "example.com", leading to allow attackexample.com, which can registered by attackers. In browser implementations, null is sent from multiple different sources, including local file pages, iframe sandbox scripts.When developers want to share data with local file pages (e.g., hybrid applications), they configure "Access-Control-Allow-Origin: null" and "Access-Control-Allow-Credentials: true" on their websites. This means that "Access-Control-Allow-Origin: *" can only be used to share public resources.We found this security mechanism is not wellunderstood by either application developers or framework developers: 1) Many application developers were not aware of this additional requirement and still configured both "Access-Control-Allow-Origin: *" and "Access-Control-Allow-Credentials: true". If the resource is first accessed by a.com and is cached with header "Access-Control-Allow-Origin: http://a.com", b.com will not be able to access the resource since the cached content has a CORS policy that does not match with b.com.HTTP provides the Vary header for this situation. Although CORS made attempt to restrict the default sending permission such as restricting Content-Type to three white-list values, it unintentionally relaxed the permissions in subtle ways, leading to various new cross-origin attacks.Under web rapid iterative development model, new protocols aren't fully evaluated before deployed. Although the "always-preflight" solution may break websites, it provides an unified way to solve these problem fundamentally.Another mitigation is to limit the format and value of white-list headers and bodies in CORS simple requests, e.g. disallowing unsafe values in white-list headers and bodies, restricting header length, restricting access to unsafe ports. For example, originally, CORS limited Content-Type to three specific values excluding "application/json", so many web applications used this restriction as CSRF defenses against JSON APIs. They do not adopt the "always-preflight" solution which we prefer because it may break existing websites.More specifically, they chose to disallow some unsafe characters (e.g., '{') in CORS whitelisted headers, limit the size of CORS whitelisted headers, and restrict access to AFP ports. Safari: Apple informed us that their investigation revealed that comprehensive changes are required to address these issues, and they are testing those changes with a beta testing program.Edge/IE: Microsoft acknowledged and thanked our report, but provided no further comment to date.CORS frameworks: Tomcat, Yii and Go-CORS frameworks have modified their software to not reflect origin header when configured to '*'. Wilander opened an issue on Github [44], suggesting that Fetch standard should restrict Accept, Accept-Language, and Content-Language value according to RFC 7231, as an attacker may abuse these three headers to delivery malicious payloads. Johnson measured the reflecting origin misconfiguration in the Alexa top 1M sites [20], and Mller [26] measured different misconfigurations mentioned in Kettle's work. By conducting an large scale measurement on CORS deployment in real-world websites, we found that CORS was not well-understood by developers, 27.5% of all the CORS configured domains had insecure misconfigurations. To aid in identifying CORS misconfiguration issues, we also provide an open-source tool 6 , to help web developers and security-practitioners to automatically evaluate whether a website is vulnerable to the misconfiguration problems we found.The reality of CORS security is an unfortunate epitome of web security. The Fudan author is supported in part by the NSFC U1636204, the National Program on Key Basic Research (NO. 2015CB358800).