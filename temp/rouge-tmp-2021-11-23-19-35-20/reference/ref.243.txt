MUZZ owns three novel thread-aware instrumentations, namely coverage-oriented instrumentation, thread-context instrumentation, and schedule-intervention instrumentation. Further, by replaying the target programs against the generated seeds, MUZZ also reveals more concurrency-bugs (e.g., data-races, thread-leaks) than AFL. However, these approaches by themselves do not automatically generate new test inputs to exercise different paths in multithreaded programs.Meanwhile, grey-box fuzzing is effective in generating test inputs to expose vulnerabilities [34,36]. In particular, we observed that, theoretically, at most 4 CVE records could be detected by grey-box fuzzers that work on user-space programs.As a result, there are no practical fuzzing techniques to test input-dependent user-space multithreaded programs and detect bugs or vulnerabilities inside them. Then it enters the fuzzing loop: 1) Seed selection decides which seed to be selected next; 2) Seed scheduling decides how many mutations M will be applied on the selected seed t; 3) Seed mutation applies mutations on seed t to generate a new seed t ; 4) During repeated execution, for each new seed t , the fuzzer executes against it N c times to get its execution statistics; 5) Seed triaging evaluates t based on the statistics and the coverage feedback from instrumentation, to determine whether the seed leads to a vulnerability, or whether it is "effective" and should be preserved in the seed queue for subsequent fuzzing. Programs and Our Solution Figure 1 is an abstracted multithreaded program that accepts a certain input file and distributes computing jobs to threads. For example, based on the condition of statement 3 , which is purely dependent on the input content (i.e., different results of buf provided by seed files), it may or may not execute 4 . Then there are at least three interleavings: i) T1: 1 →T2: 1 →T2: 2 →T1: 2 g_var=4 ii) T1: 1 →T2: 1 →T1: 2 →T2: 2 g_var=4 iii) T1: 1 →T1: 2 →T2: 1 →T2: 2 g_var=2 After the second 2 is executed, the values of g_var may be different (4 and 2, respectively). As a result, subsequent mutations on this seed will miss important feedback regarding g_var, making it difficult to generate seeds that trigger the vulnerability.To summarize, the challenge of fuzzing multithreaded programs is, existing GBFs have difficulties in generating seeds that execute multithreading context and keep threadinterleaving execution states. This means that the multithreading-relevant seeds are implicitly prioritized. Thread-contextThe state-of-the-art GBFs, such as AFL, instrument the entry instruction of each basicblock evenly as the basicblock's deputy. For brevity, we use source code to illustrate the problem and use statements to represent instructions in assembly or LLVM IR [28]. AFL-Ins works perfectly on single-threaded programs: the kept transitions can reflect both branching conditions (e.g., 3 → 4 and 3 → 5 ) and function calls (e.g., 4 → 9 and 6 → 9 ). This will decrease the diversities of schedules, and consequently reduce the overall effectiveness. It contains four major components: A static thread-aware analysis guided instrumentations, B dynamic fuzzing, C vulnerability analysis, D concurrency-bug revealing. 2) Thread-context instrumentation ( §4.3) is a type of lightweight instrumentation that distinguishes different thread identities by tracking the context of threading functions for thread-forks, locks, unlocks, joins, etc. 3) Schedule-intervention instrumentation ( §4.4) is a type of lightweight instrumentation at the entry of a thread-fork routine that dynamically adjusts each thread's priority. For seed selection ( §5.1), in addition to the new coverage information provided by coverageoriented instrumentation, MUZZ also prioritizes those seeds that cover new thread-context based on the feedback provided by thread-context instrumentation. By taking into account the semantics of threading APIs (e.g., POSIX standard Pthread, the OpenMP library), we get an ICFG that is aware of the following multithreading information: 1) TFork is the set of program sites that call thread-fork functions. It includes the call sites of the pthread APIs such as pthread_join, pthread_exit, etc. 3) TLock is the set of sites that call thread-lock functions such as pthread_mutex_lock, omp_set_lock, etc. 4) TUnLock is the set of sites that call thread-unlock functions like pthread_mutex_unlock, omp_unset_lock, etc. 5) TShareVar is the set of variables shared among different threads. C1 The statements should be executed after one of TFork, while TJoin is not encountered yet. C2 The statements can only be executed before the invocation of TLock and after the invocation of TUnLock. C3 The statements should read or write at least one of the shared variables by different threads. This condition is determined by observing whether the investigated statement contains a variable data dependent on TShareVar (based on pointer analysis). Therefore the conditions are different from the constraints required by static models (e.g., may-happen-in-parallel [11,45]) or dynamic concurrency-bug detection algorithms (e.g., happens-before [12] or lockset [41]). For example, the pointer analysis is flow-and context-insensitive; extraction of thread-aware results such as F f ork (in C1) and TShareVar (in C3) are over-approximated in that the statically calculated sets may be larger than the actual sets; C2 may aggressively exclude several statements that involve interleavings. As 10 is considered to be the preferred upper bound of M c [35], we determine the base probability as:P e ( f ) = min E( f ) − N( f ) + 2 10 , 1.0 (1)We use P s as the probability to selectively instrument on the entry instruction of a basicblock that is entirely outside suspicious interleaving scope, i.e., none of the instructions inside the basicblock belong to L m . Otherwise, 1) for the entry instruction in b, MUZZ always instruments it (i.e., with probability 1.0); 2) for the other instructions, if they are inside L m , MUZZ instruments them with a probability of P m ( f , b). The context is collected at the call sites of F ctx = {TLock, TUnLock, TJoin}, each of which has the form TC = Loc, N ctx , where Loc is the labeling value of deputy instruction executed before this call site, and N ctx is obtained by getting the value of the key identified by current thread ID from the "thread ID map" collected by the instrumented function F S (to be explained in §4.4 is a context-signature that determines the overall thread-context of a specific execution. In order to intervene in the interleavings during the execution of the multithreading segments, we resort to the POSIX API pthread_setschedparam to adjust the thread priorities with an instrumented function named F S that will be invoked during fuzzing. This function does two tasks: a) During repeated execution ( §5.2), whenever the thread calls F S , it updates the scheduling policy to SCHED_RR, and assigns a ranged random value to its priority. This value is uniformly distributed random and diversifies the actual schedules across different threads. In addition to following AFL's strategy by using has_new_trace(Q S ) to check whether there exists a seed, s, in Q S that covers a new transition (i.e., cov_new_trace(s)==true), MUZZ also uses has_new_mt_ctx(Q S ) to check whether there exists a seed in Q S with a new thread-context (S ctx ). We augment this to fit for multithreading setting.N c (t) = N 0 + min N v , N 0 ·C m (t)(5)In both AFL and MUZZ, N 0 = 8, N v = 32. Compared to a seed that cannot even enter the thread-fork routines, it is usually much easier to generate a multithreading-relevant seed mutant from an existing multithreading-relevant seed. Therefore, from the mutation's perspective, we prefer multithreading-relevant seeds to be mutated.2) MUZZ can distinguish more multithreadingrelevant states. Owing to more multithreading-relevant seeds in the queue and property 1), we can expect that: a) concurrency-vulnerabilities are more likely to be detected with the new proof-of-crash files mutated from multithreading-relevant files from the seed queue. The vulnerability analysis and concurrency-bug replaying components rely on ClusterFuzz's crash analysis module. The archive includes initial seeds for fuzzing, the detected concurrencyvulnerabilities and concurrency-bugs, the implementation details, and other findings during evaluation.Our evaluation targets the following questions: RQ1 Can MUZZ generate more effective seeds that execute multithreading-relevant program states? RQ3 What is the effect of using MUZZ generated seeds to reveal concurrency-bugs (B m ) with bug detectors? Column T pp records the preprocessing time of static analysis (c.f. §4.1). Columns N b , N i , and N ii depict the number of basicblocks, the number of total instructions, and the number of deputy instructions for M-Ins (c.f. §4.2), respectively. Therefore, N mt tracks the different multithreading execution states during fuzzing -a larger value of this metric suggests the fuzzer can keep more effective thread-interleaving seeds. We sum up those seed files across all six fuzzing runs to form N all and N mt in in all the benchmarks. Answer to RQ1: MUZZ has advantages in increasing the number and percentages of multithreading-relevant seeds for multithreaded programs. The characteristics of these V m are that their crashing backtrace contains multithreading context (i.e., TFork is invoked), however, the crashing condition might also be occasionally triggered when only one thread is specified. Answer to RQ2: MUZZ demonstrates superiority in exercising more multithreading-relevant crashing states and detecting concurrency-vulnerabilities. Instead, we aim to reveal as many bugs as possible within a time budget, by replaying against fuzzergenerated seeds with the help of these techniques. N m e is the number of observed concurrencyviolation executions and N m B is the number of concurrencybugs (B m ) according to their root causes. Answer to RQ3: MUZZ outperforms competitors in detecting concurrency-bugs; the value N c calculated during fuzzing additionally contributes to revealing these bugs. Larger values of P s0 and P m0 increases the instrumentation ratio only if the thresholds are frequently reached. Two case studies can support this statement. First, it is unfair to track coverage over time when comparing MUZZ, MAFL with AFL or MOPT due to the different meanings of "coverage".