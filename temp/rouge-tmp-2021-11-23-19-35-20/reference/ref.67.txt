In this work, we present the CLKSCREW attack, a new class of fault attacks that exploit the security-obliviousness of energy management mechanisms to break security. A novel benefit for the attackers is that these fault attacks become more accessible since they can now be conducted without the need for physical access to the devices or fault injection equipment. In essence, a CLKSCREW attack exploits unfettered software access to energy management hardware to push the operating limits of processors to the point of inducing faulty computations. This is dangerous when these faults can be induced from lower privileged software across hardware-enforced boundaries, where security sensitive computations are hosted.We demonstrate that CLKSCREW can be conducted using no more than the software control of energy management hardware regulators in the target devices. CLKSCREW sidesteps all these risks of destroying the target devices permanently.To highlight the practical security impact of our attack, we implement the CLKSCREW attack on a commodity ARMv7 1 phone, Nexus 6. With only publicly available knowledge of the Nexus 6 device, we identify the operating limits of the frequency and voltage hardware mechanisms. We show how the CLKSCREW attack can subvert the hardware-enforced isolation in ARM Trustzone in two attack scenarios: (1) extracting secret AES keys embedded within Trustzone and (2) loading self-signed code into Trustzone. We note that the root cause for CLKSCREW is neither a hardware nor a software bug: CLKSCREW is achievable due to the fundamental design of energy management mechanisms.We have responsibly disclosed the vulnerabilities identified in this work to the relevant SoC and device vendors. We then detail key classes of supporting hardware regulators and their software-exposed interfaces. DVFS works by regulating two important runtime knobs that govern the amount of energy consumed in a system -frequency and voltage.To see how managing frequency and voltage can save energy, it is useful to understand how energy consumption is affected by these two knobs. 3 In a system with a fixed capacitative load, at any time t, the instantaneous dynamic power is proportional to both the voltage, V t and the frequency F t as follows: DVFS regulates frequency and voltage according to runtime task demands. The combined need for accurate layer-specific feedback and low voltage/frequency scaling latencies drives the prevalence of unfettered and software-level access to the frequency and voltage hardware regulators.P t ∝ V 2 t × F t . Voltage regulators supply power to various components on devices, by reducing the voltage from either the battery or external power supply to a range of smaller voltages for both the cores and the peripherals within the device. Privileged software like a kernel driver can use these memory-mapped control registers Figure 2: Separate clock sources for each Krait core.to direct voltage changes. A multiplexer (MUX) is used to select amongst the three clock sources, namely (1) a PLL supplying a fixed-rate 300-MHz clock signal, (2) a High-Frequency PLL (HFPLL) supplying a clock signal of variable frequency based on a N multiplier, and (3) the same HFPLL supplying half the clock signal via a frequency divider for finer-grained control over the output frequency.As shown in Figure 2, the variable output frequency of the HFPLL is derived from a base frequency of 19.2MHz and can be controlled by configuring the N multiplier. For instance, to achieve the highest core operating frequency of 2.65GHz advertised by the vendor, one needs to configure the N multiplier to 138 and the Source Selector to 1 to select the use of the full HFPLL. Similar to changing voltage, privileged software can initiate percore frequency changes by writing to software-exposed memory-mapped PLL registers, shown in Figure 2. Software support for DVFS comprises two key components, namely vendor-specific regulator drivers and OS-level power management services.Besides being responsible for controlling the hardware regulators, the vendor-provided PMIC drivers [5,6] also provide a convenient means for mechanisms in the upper layers of the stack, such as the Linux CPUfreq power governor [46] to dynamically direct the voltage and frequency scaling. Finally, we characterize the operating limits of regulators and detail the steps to achieving the first CLKSCREW fault on a real device. To appreciate why unfettered access to hardware regulators is dangerous, it is necessary to understand in general why over-extending frequency (a.k.a. overclocking) or under-supplying voltage (a.k.a. undervolting) can cause unintended behavior in digital circuits.Synchronous digital circuits are made up of memory elements called flip-flops (FF). For the overall circuit to propagate input D src → output Q dst , the minimum required clock cycle period 4 , T clk , is bounded by the following timing constraint (1) for some microarchitectural constant K:T clk ≥ T FF + T max_path + T setup + K (1)Violation of timing constraint. When the timing constraint is violated during two consecutive rising edges of the clock signal, the output from the source flip-flop FF src fails to latch properly in time as the input at the destination flip-flop FF dst . Since the attack code performing the fault injection and the victim code to be faulted both reside on the same device, the fault attack must be conducted in a manner that does not affect the execution of the attacking code. On a full-fledged OS with interrupts, we need to inject a fault into the target code without causing too much perturbation to nontargeted code. Using two attack scenarios that require vastly different degrees of timing precision in § 4 and § 5, we demonstrate how the timing of the fault can be fine-tuned using a range of execution profiling techniques.Fine-grained timing resolution. On this device, DVFS is configured to operate only in one of 15 possible discrete 5 Operating Performance Points (OPPs) at any one time, typically by a DVFS OS-level service. By enabling the debugfs feature for the regulators, we can get per-core voltage 6 and frequency 7 measurements. Using the softwareexposed controls described in § 2.2, while maintaining a low base frequency of 300MHz, we configure the voltage regulator to probe for the range during which the de-5 A limited number of discrete OPPs, instead of a range of continuous voltage/frequency values, is used so that the time taken to validate the configured OPPs at runtime is minimized.6 /d/regulator/kraitX/voltage 7 /d/clk/kraitX_clk/measurevice remains functional. This unfettered access to the regulators offers a powerful primitive to induce a software-based fault.ATTACK ENABLER (GENERAL) #1: There are no safeguard limits in the hardware regulators to restrict the range of frequencies and voltages that can be configured.Large degree of freedom for attacker. With the help of this frequency/voltage characteristic, she can then possibly reduce the operating voltage to the extent where the overclocking frequency required is within the physical limit of the regulator.ATTACK ENABLER (GENERAL) #2: Reducing the operating voltage lowers the minimum required frequency needed to induce faults.Secondly, from the defender's perspective, the large range of instability-inducing OPPs above the curve suggests that limits of both frequency and voltage, if any, must be enforced in tandem to be effective. The challenge is doing so without self-faulting the attack code and accidentally attacking other non-targeted code.We create a custom kernel driver to launch separate threads for the attack and victim code and to pin each of them to separate cores. These two measures ensure that our fault injection effects are contained within the core that the target victim code is running on.ATTACK ENABLER (GENERAL) #3: The deployment of cores in different voltage/frequency domains isolates the effects of cross-core fault attack. The goal of the CLKSCREW attack is to induce a fault in a subset of an entire victim thread execution. F θ |T anchor = {F volt , F pdelay , F freq_hi , F dur , F freq_lo } To support execution of trusted code isolated from untrusted one, two leading industry technologies, ARM Trustzone [11] and Intel SGX [9], are widely deployed.They share a common characteristic in that they can execute both trusted and untrusted code on the same physical core, while relying on architectural features such as specialized instructions to support isolated execution. In this section, we show how AES [43] keys stored within Trustzone (TZ) can be inferred by lowerprivileged code from outside Trustzone, based on the faulty ciphertexts derived from the erroneous AES encryption operations. The attacker can repeatedly invoke the Trustzone app from the non-secure environment to decrypt any given ciphertext, but is restricted from reading the AES keys directly from Trustzone memory due to hardware-enforced isolation. To load this app into Trustzone as our victim program, we use a publicly known Trustzone vulnerability [17] to overwrite an existing Trustzone syscall handler, tzbsp_es_is_activated, on our Nexus 6 device running an old firmware 8 . Having the victim app execute within Trustzone on a commodity device allows us to evaluate CLKSCREW across Trustzone-enforced security boundaries in a practical and realistic manner. With this feature, we can now measure how long it takes for our Trustzone app to decrypt a single ciphertext, even from the non-secure world.ATTACK ENABLER (TZ-SPECIFIC) #5: Execution timing of code running in Trustzone can be profiled with hardware counters that are accessible outside Trustzone.Using the hardware cycle counter, we track the duration of each AES decryption operation over about 13k invocations in total. This shows that the victim thread does not exhibit too much variability in terms of its execution time.Recall that we want to deliver a fault to specific region of the victim code execution and that the faulting parameter F pdelay allows us to fine-tune this timing. More than 60% of the faults are precise enough to affect exactly one AES round, as depicted in Figure 9 (left). Furthermore, out of these faults that induce corruption in one AES round, more than half are sufficiently transient to cause random corruptions of exactly one byte, shown in Figure 9 (right). Tunstall et al. present a differential fault attack (DFA) that infers AES keys based on pairs of correct and faulty ciphertext [56]. Assuming a fault can be injected during the seventh AES round to cause a single-byte random corruption to the intermediate state in that round, with a corrupted input to the eighth AES round, this DFA can reduce the number of AES-128 key hypotheses from the original 2 128 to 2 12 , in which case the key can be brute-forced in a trivial exhaustive search. Given the pair of this faulty plaintext and the expected one, it took Tunstall et al.'s DFA algorithm about 12 minutes on a 2.7GHz quadcore CPU to generate 3650 key hypotheses, one out of which is the AES key stored within Trustzone. ARMbased SoC processors use the ARM Trustzone to provide a secure and isolated environment to execute securitycritical applications like DRM widevine [28] trustlet 9 and Algorithm 1 Given public key modulus N and exponent e, decrypt a RSA signature S. Return plaintext hash, H. x ← MONTMULT(x, 1, N rev , r −1 ) H ← FLIPENDIANNESS(x) 22: return H 23: end procedure key management keymaster [27] trustlet. The code blob is then distributed together with the signature and a certificate containing the signing modulus N. Subsequently, the code blob C can be authenticated by verifying that the hash of the code blob matches the plaintext decrypted from the signature using the public modulus N: Sig e mod N == H(C). To load apps into Trustzone, the attackers can invoke the TEE to authenticate and load a given app into Trustzone using the QSEOS_APP_START_COMMAND [4] Secure Channel Manager 10 command. The overall goal of the attack is to deliver a fault during the execution of DECRYPTSIG such that the output of DECRYPTSIG results in the desired hash H(C A ) of our attack code C A . This operation can be described by Equation 2, where the attacker has to supply an attack signature S A , and fault the execution of DE-CRYPTSIG at runtime so that DECRYPTSIG outputs the intended hash H(C A ). For comparison, we also describe the typical decryption operation of the original signature S to the hash of the original code blob, C in Equation 3. Attack : DECRYPTSIG(S A , e, N) f ault − −− → H(C A ) (2) Original : DECRYPTSIG(S, e, N) − − → H(C)(3)For a successful attack, we need to address two questions: (a) At which portion of the runtime execution of DECRYPTSIG(S A , e, N) do we inject the fault? With this keypair {N A , d A , e}, the hash of the attack code C A can then be signed to obtain the signature of the attack code, S A ← (H(C A )) d A mod N A . Before we begin the cryptanalysis, we note that the attack signature S A (an input to DECRYPTSIG) is not the signed hash of the attack code, S A (private-key encryption of the H(C A )). Line 15 marks the beginning of the modular exponentiation of the input signature, and thus, we focus our analysis here.First, since we want DECRYPTSIG(S A , e, N) to result in H(C A ) as dictated by Equation 2, we begin by analyzing the invocation of DECRYPTSIG that will lead to H(C A ). x desired ← S A · (r 2 mod N A ) · r −1 A mod N A(4)Next, suppose our CLKSCREW fault is delivered in the operation DECRYPTSIG(S A , e, N) such that N is corrupted to N A at Line 4. The attack signature S A passed into DECRYPTSIG gets converted to the Montgomery representation at Line 15, where both moduli are used:x f ault ← MONTMULT(S A , r 2 mod N, N A , r −1 A ) We can then characterize the output, x f ault , of the operation at the same Line 15 of a faulted DECRYPTSIG(S A , e, N) as follows:x f ault ← S A · (r 2 mod N) · r −1 A mod N A(5)By equating x f ault = x desired (i.e. equating results from (4) and (5)), we can reduce the problem to finding S A for constants K = (r 2 mod N) · r −1 A and x desired , such that: S A · K mod N A ≡ x desired mod N A Finally, subject to the condition that x desired is divisible 13 by the greatest common divisor of K and N A , denoted as gcd (K, N A ), we use the Extended Euclidean Algorithm 14 to solve for the attack signature S A , since there exists a constant y such that S A · K + y · N A = x desired . We extract the target function FLIPENDIANNESS from the binary firmware image and execute it in the non-secure environment to measure its length of execution. Due to the degree of precision needed, it is thus crucial to find a way to determine a reliable time anchor (see Steps 2 / 3 in § 3.5) to guide the delivery of the fault.Cache profiling To determine approximately which region of code is being executed during the chain validation at any point in time, we leverage side-channelbased cache profiling attacks that operate across cores. By treating this series of eviction gap duration values, g, as a time-series stream, we can approximate the execution profile of the chain validation code running within Trustzone.We plot a snapshot of the cache profile characterizing the validation of the fourth and final certificate in Fig- ure 11. Based on this obser- vation, we change the profiling stage of the attack thread to track two hand-crafted timing features to characterize the instantaneous state of victim thread execution.Timing anchor. With this timing anchor, we perform a grid search for the faulting parameters, F freq_hi , F dur and F pdelay that can best induce faults in FLIPENDIANNESS. To evaluate the efficacy of the regression models, we collect all observed faults with the goal of injecting a fault at byte position 141. In particular, the entire industry is increasingly moving or has moved to fine-grained energy management designs that separate voltage/frequency domains for the cores. The ARMv8 devices adopt the ARM big.LITTLE design that uses non-symmetric cores (such as the "big" Cortex-A15 cores, and the "LITTLE" Cortex-A7 cores) in same system [36]. Imposing a onesize-fits-all range of limits is challenging because SoCspecific limits hinder the portability of these regulators across multiple SoC. To mitigate the effects of erroneous computations due to induced faults, researchers propose redesigning the application core chip with additional logic and timing redundancy [13], as well as recovery mechanisms [33]. However, we note that while this mitigates against attacks without a timing anchor (AES attack in § 4), it may have limited protection against attacks that use forms of runtime profiling for the timing guidance (RSA attack in § 5). We emphasize that while CLKSCREW shows how faults can break cryptographic schemes, it does so to highlight the dangers of hardware regulators exposing software-access interfaces, especially across security trust boundaries. Our CLKSCREW attack is able to subvert even hardware-enforced security isolation and does not require physical access, further increasing the risk and danger of this attack vector.While we offer proof of attackability in this paper, the attack can be improved, extended and combined with other attacks in a number of ways.