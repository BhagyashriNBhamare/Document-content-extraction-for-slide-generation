We present WAVE, an authorization framework offering decentralized trust: no central services can modify or see permissions and any participant can delegate a portion of their permissions autonomously. To achieve this goal, WAVE adopts an expressive authorization model, enforces it cryptographically, protects permissions via a novel encryption protocol while enabling discovery of permissions, and stores them in an un-trusted scalable storage solution. First, a centralized service is a central point of attack: a single attack can simultaneously compromise many user accounts and permissions. It aims to capture a wide range of authorization policies and to provide an alternative to traditional systems, such as OAuth [4] and Active Directory.Importantly, in providing decentralized transitive delegation, WAVE facilitates applications that span multiple trust domains. The property manager within each campus is the authority for the cyberphysical resources associated with the buildings in the campus, but they must delegate permission to the individual building managers who must further delegate permissions to the tenants, allowing them to control the portions of the buildings that they rent. The building manager and/or tenant will also grant ephemeral permissions on subsets of the building infrastructure to contractors (like HVAC commissioning teams) and, especially in our case, to Existing authorization systems fall short in two general areas: they do not meet our Security Goals or they do not provide the features required for IoT usage scenarios. The smart building scenario illustrates the necessity for transitive delegation and revocation where, for example, a tenant can further delegate their permissions to a control service or guest and have those permissions predicated on the tenant's permissions. If the tenant moves out, all of the permissions they granted should be automatically revoked, even if the building manager is unaware of the grants the tenant has made. Even though the property manager is the authority for all the buildings, they must not be able to see the permissions that the tenants grant (Security Goal #2). This is adequate in the centralized service case where the authority is the service provider, but it does not work in the IoT case where the root authority (the property manager) has nothing to do with the devices needing to verify an action is authorized (for example a thermostat). As a further example, when the building manager's key needed to be replaced (e.g. it expired or was compromised), they created a new key and the property manager had to grant replacement permissions to this new key. Furthermore, when we had such ordering constraints in our prior deployments we observed users choosing insecure long expiry times or broad permissions to avoid this re-issue. Nevertheless, we found that representing the authorization model as a graph, such as in SDSI/SPKI [49,24] where a proof of authorization is a path through a graph, is compatible with our requirements, even though the existing systems implementing it fall short. An edge indicates that an entity grants another entity access according to a policy, which is one or more permissions along with a description of the resources for which the permissions are granted, and the expiry of the grant. The graph construction allows permissions to be granted in any order, including delegation of permissions one does not yet possess but expects to receive in the future.While WAVE's authorization graph and proofs are structurally similar to SDSI/SPKI, WAVE differs in three important aspects: (1) while in SDSI/SPKI only a central authority (holding an ACL) can verify a proof, in WAVE anyone can independently (with no communication) verify a proof yielding an authorization policy. (2) WAVE provides a trustworthy, scalable storage solution for attestations that enables discoverability with offline participants and out of order grants, which is out of scope for SDSI/SPKI. We present a new type of transparency log, the Unequivocable Log Derived Map (ULDM). To meet the requirement of protected permissions and Security Goal #2 despite the public ULDM storage tier, there must be a mechanism to prevent the storage servers or the general public from seeing the permissions, while ensuring that parties forming and verifying proofs can see the necessary permissions. Importantly, RDE does not introduce additional constraints on the ordering of delegations or liveness of participants.Our implementation of WAVE is a real-world open-source artifact [7]. When accessing a service or controlling a device, clients request a proof from the WAVE service; the WAVE service will search for a path through the global authorization graph from the authority for the service or device in question to the client's entity, where each edge grants a superset of the required permissions. To ensure the privacy of permissions, the WAVE service uses our protocol, Reverse-Discoverable Encryption (described in §4) to encrypt the attestations. When the client instructs the WAVE service to create an entity or an attestation, the WAVE service will place the public keys (for entities) or RDE ciphertext (for attestations) into the scalable untrusted storage ( §5). The first element of a URI (e.g. company-entity) is called the namespace authority or just namespace, which specifies the entity who is the root of authorization for that resource (the entity who has permission on that policy without having received permission from someone else). An RTree policy consists of:• A set of permissions (strings such as "schema::read") • A URI pattern describing a set of resources • A time range describing when the grant is valid • An indirections field, which limits re-delegation For example, a building manager entity might grant hvac:: actuate on bldgnamespace/floor4/ * over a time range corresponding with the lease terms, allowing further delegation, to a tenant entity. Although the storage server is centralized for availability, it is not a point of central trust as its behavior is cryptographically enforced. Since a proof is represented by a path through the graph, if an entity higher up in the delegation tree is revoked, all entities beneath it will no longer be able to prove they have permissions, even though the party revoking the entity may have been unaware of the delegations lower in the tree. In our example, the property manager cannot decrypt attestations that the tenant makes, and the party running the storage servers cannot read any of the attestations. WAVE proofs can be verified by anyone, unlike in SDSI/SPKI [49] or Macaroons [12]. Given that existing systems like SDSI/SPKI [49] use a similar construction, we do not explore this further.To achieve the other two security goals, WAVE introduces two new techniques: Reverse-Discoverable Encryption ( §4) to satisfy Security Goal #2, and Unequivocable Log-Derived Maps ( §5) to satisfy Security Goal #3. Our technique, reverse-discoverable encryption (RDE), does not require out-of-band communication between entities and works even if attestations are created out of order.We present our solution incrementally: §4.1 formalizes the problem that RDE solves. §4.2 presents a simplified design of RDE, based on traditional public-key encryption, that provides a weak but useful security guarantee called "structural security." §4.4 presents our final protocol, which provides both efficient discovery of attestations and a significantly stronger guarantee than structural security.For all the security guarantees stated in this section, we assume that the attacker Adv is computationally-bounded, and that standard cryptographic assumptions hold. This keypair is governed by two rules: when an entity grants an attestation, it (1) attaches its private key to the attestation, and (2) encrypts the attestation, including the attached private key, using the public key of the attestation's subject (recipient). This works even though attestation #4 was issued after #3. While structural RDE uses traditional public-key encryption, it differs from systems like PGP in that entities include their long-lived private keys in the attestations they encrypt. With policy-aware RDE, we achieve a stronger notion of security that prevents D from decrypting #5 by making two high-level changes to structural RDE.First, whereas structural RDE encrypts each attestation A according to only A.subject, policy-aware RDE encrypts each attestation A according to both A.subject and A.policy. In RDE, however, our insight is to instantiate a WIBE system for every entity, so there is no central PKG.A WIBE system consists of a master secret and public key pair (WIBE.msk, WIBE.mpk). The secret key sk ID * can decrypt an encrypted message, WIBE.Enc(WIBE.mpk, ID; m), if ID * and ID match in all non-wildcard components.Every policy p has an associated WIBE ID called a partition. To define P, consider that an RTree policy consists of a resource prefix as defined in §2.4 (matching multiple resources) and a time range during which the permission is valid. To express the start and end of this range as a WIBE ID, we define a time-partitioning tree of depth k over the entire supported time range; now any time in the supported time range can be represented as a vector representing a path in the tree from root to leaf. ; ID * i )} ID * i ∈Q(AThe issuer must also include the policy-specific WIBE keys from their own system in the attestations, generated with ID * s Q(A.policy), so that upstream attestations with compatible policies can be discovered. We define Q for RTree as: let E be a set of subtrees, each represented as a prefix of a time vector (i.e., a vector where unused components are wildcards), that covers the time range from the earliest possible encryption start time to the end of the time range of the attestation's validity. This is infeasible if n is large, and becomes a vector for denial of service attacks.If Alice knows B's partition, then the problem is solvedAlice can locally index the private keys she has from Bob's system, and efficiently look up a key that can decrypt B.However, B cannot include its own partition in plaintext, because it may leak part of B.policy.We solve this by encrypting the partition and storing it in the attestation. For this outer layer of encryption we use a more standard identity-based encryption (denoted IBE) that does not permit extracting the identity from the ciphertext [46,42] because we do not need wildcards. So far, what gets stored in the attestation is:IBE.Enc(IBE.mpk A.subject , L(A.policy); P(A.policy)|| WIBE.Enc(WIBE.mpk A.subject , P(A.policy);W ||I))where W is defined as above, andI = IBE.KeyGen(IBE.msk Issuer ; L(A.policy))denotes the IBE secret key from the issuer's system. In summary, for each attestation A granting permission on a namespace: entities who have not been granted permissions in that namespace in a path from A.subject can only see the subject and revocation commitment. Thus, even though policy-aware RDE permits some entities to see more attestations than strictly needed to create a proof of authorization, it still provides a significant reduction in visibility when compared to structural security. Our storage layer does not provide any additional confidentiality, so compromised storage servers can see the time of each operation (e.g., when encrypted attestations are stored), which encrypted attestations are fetched, as well as networking information of the packets arriving at the storage servers (which could be protected via Tor [1], a proxy, or other anonymous/secure messaging methods [21]). Integrity. However, if a participant simply assembles a list of decrypted attestations into a proof and gives those attestations to a verifier, the verifier learns not only the attestations in that proof, but also the WIBE keys in those attestations, which it can use to decrypt other attestations not in the proof. Each user's WAVE client maintains a perspective subgraph with respect to the user's entity, which is the portion of the global authorization graph visible to it. The client adds WIBE and IBE keys delegated via A to its index, as keys in the systems of A.issuer. This can be marginally improved by including an additional set of WIBE keys in the attestations to allow for the full resource (not just the prefix) to be captured by P and Q but this increases the number of included keys by a factor of . Multiple servers are responsible for maintaining a blockchain, and, due to the underlying Merkle tree data structure, any one server can prove the integrity of its responses to state queries according to a specific Merkle tree root hash, meeting the requirements.Prior versions of WAVE used an Ethereum blockchain, but extended use and experimentation revealed this solution to be inadequate for three reasons: (1) A blockchain introduces significant latency when adding objects to storage (up to a minute for a confirmed addition in Ethereum). (3) The blockchain does not scale past a few tens of transactions per second [22], so it could not store attestations for a global authorization system permitting thousands of delegations per second.Although this problem appears solvable with existing transparency logs such as Certificate Transparency (CT) [41] or Key Transparency (KT) [32], neither of those is appropriate. The ULDM is our approach to filling in the missing pieces, such as an auditing scheme to prevent equivocation and secure batching to increase performance.A ULDM is constructed using three Merkle trees, each serving a different purpose, as shown in Fig. 4. The first tree is the Operation Log, which stores every Put and Enqueue operation and can prove the log is append-only. To insert a value, the ULDM server: (1) Inserts the value into the Operation Log. When inserting a value, a client receives a merge promise (called Signed Certificate Timestamp in CT) which states that the inserted value will be present by a certain point in time. To retrieve a value, the client sends the storage server the Map Root Log version that it received in a previous request, along with the object identifier it is retrieving (e.g., the hash of an attestation or revocation commitment). If the object has been merged or doesn't exist, the server responds with: (1) the object or nil, (2) a proof that the object existed or did not exist in the Object Map at the latest map root, (3) a proof that the latest map root exists in the Map Root Log at the current Map Root Log head, and (4) a consistency proof that the current Map Root Log head is an append-only extension of the version the client passed in its request. It then ensures the hash of the replica Object Map root matches the hash stored in the Map Root Log, proving that the map is correctly derived from the operation log (no objects were modified or removed). In the ULDM case, the client would report the Map Root Log head which covers all prior map versions, enabling the auditor to discover that the previous query was satisfied from an invalid map.Detecting dishonesty with a single infrequently-reported value has important scalability implications: as we expect there to be many clients, it is important that the load placed on auditors is much less than the query load generated by the clients, otherwise, only large companies could afford to be auditors. By honest client, we denote a client that is neither faulty nor compromised. When a user creates an attestation, it derives a random revocation secret s from a seed stored with the entity private keys and includes a cryptographic hash of s, hash(s), called the revocation commitment, in the attestation. An entity must have their private key to perform revocation; mechanisms such as [53] can be used to ensure this.When verifying a proof, the WAVE service ensures that no attestations in the proof have been revoked. These name declarations form a web-of-trust global graph, similar to that formed by attestations. Then, by verifying the identity of a single entity out of band (the company), an entity can resolve the names of all employees within the company's departments, such as Alice.Marketing.ACME, without having to manually establish the validity of individual employee entities.The functionality above, proposed by SDSI, does not provide a distribution mechanism for entities to discover the name declarations required to perform resolution, nor a mechanism to ensure the privacy of declarations so that only authorized parties may read them. In other words, the same attestations that are used to form a proof of authorization are also used to govern which entities can read name declarations, without relying on a central directory server. The storage abstraction permits multiple distinct storage providers operating in parallel. This is the portion of the global graph visible from the perspective of the proving entity. The proof builder, when asked to build a proof, begins at the namespace authority (the entity that created the RTree namespace) for the resource that permissions are being proved on, and then performs a shortest path discovery through the perspective graph terminating at the proving entity. These decryption operations take place only once-when an attestation is added to the perspective graph-so are a one-off cost of re-1 Create attestation uses multiple cores Authentication Authorization LDAP+MySQL 6.3ms 0.8ms OAuth2 JWT 0.3ms WAVE 1 attest.1.2ms WAVE 3 attest.3.6ms Table 2: Latency of LDAP+MySQL, OAuth2 vs. WAVE. We can see the cost of decryption combined with indexing by measuring the time taken to update a perspective graph, for different sizes of changes to the graph, as shown in Fig. 6a. For a WAVE proof mirroring the single-delegation structure present in the LDAP/OAuth2 case, the proof verifies in a sixth of the time taken by the traditional LDAP flow. In OAuth a compromised token issuing server can generate valid tokens without the user's knowledge.Note that although OAuth2 has added a form of delegation [36], it requires the OAuth2 server to issue a new token, so is identical to the single-delegation scenario tested here.This example shows that using WAVE as a replacement for common authorization flows will likely not reduce performance, despite providing transitive delegation and removing all central authorities. Note that in this evaluation, every operation concerns a unique object, so as to benchmark the underlying cost of forming proofs, rather than the cache. Real workloads would likely have more cache hits.Although our storage implementation is unoptimized and built using an off-the-shelf Merkle tree database, single nodes handle insert loads an order of magnitude higher than possible on a blockchain system [22]. We operated various versions of WAVE for roughly two years in over 20 buildings, controlling more than 800 devices (thermostats, control processes, motion sensors, and others with little to no existing authorization capabilities) comprising 363 entities, 27 namespaces and 529 attestations (both valid and expired). The global authorization graph in our deployment is visualized in Fig. 8. User feedback indicated that WAVE improved most aspects of management (especially administrators having autonomy to grant and revoke permissions). Some aspects of WAVE are harder to manage: no user can enumerate all delegations in the system, which reduces auditability. Trust Management (TM) literature over the past two decades has thoroughly researched techniques for transitively delegable authorization. For example Macaroons [12] provides a mechanism for ex- Figure 8: The permission graph for the multi-building deployment. In our deployments we use RTree, based on SPKI's pkpfs [24], but mechanisms like third-party caveats could be introduced with no changes to the underlying layers.Hidden credentials (row 2 in Table 4) [58,37,30,48] address a different privacy problem: allowing a prover and verifier to hide their credentials from each other. Centralized discovery mechanisms put all credentials in one place which makes discovery simple but, as constructed in work thus far, requires this central storage to be trusted. Both the centralized and decentralized credential discovery work thus far have overlooked the privacy of credentials at rest (in the centralized case) or during discovery (in the distributed case); in both cases, there are parties who can read credentials that do not grant them permissions even indirectly.A concurrent work, Droplet [52], presents a distributed authorization system, but it does not meet the requirements of a general purpose authorization system in §1: Droplet does not provide transitive delegation, it only handles authorization for time series data streams as opposed to the more general policies of WAVE, and it induces a blockchain transaction for every change to an ACL, which scales poorly.WAVEs attestations and RDE can be used as the key exchange protocol for an end-to-end encryption scheme such as JEDI [38]. In meeting these requirements, WAVE (1) has no reliance on central trust, (2) provides transitive fine-grained delegation and revocation, (3) protects permissions during discovery and at rest, (4) allows for any party to verify a proof of authorization, (5) allows delegations to occur in any order with no communication between granter and receiver, and finally (6) allows for granting permissions to offline participants. We show that if neither clients in C nor the auditor A detect an attack, then there exists a possible history H of requests consistent with L and all responses to requests in R. Concretely, we show that the Operation Log that the storage server tells the auditor A is such a valid history H. Because A did not detect an inconsistency, we know that, for each client c ∈ C, (1) its Map Root Log head, at some point after its last request in R, is consistent with H. Because c did not detect an inconsistency, we know that (2) c's sequence of Map Root Log heads is append-only, (3) for each request, the returned object did (or did not, if no object was returned) exist in the Object Map, and (4) for each request, the Map Root Log at the time of the request contains the object map used in (3). We write A B and say "A is partition-compatible with B" if a key corresponding to one of the ID * s in Q(A.policy) can decrypt a WIBE ciphertext with the ID P(B.policy). If there exists a partition-compatible path p = (A, P 1 , . . . , P n ) to an entity compromised by Adv, then we say that A is useful with respect to Adv.Otherwise, if there exists a partition-label-compatible path p = (A, P 1 , . . . , P n ) to an entity compromised by Adv, then we say that A is partition-known with respect to Adv.Otherwise, if there exists a partition-compatible path from A.subject to an entity compromised by Adv, then we say that A is interesting with respect to Adv.Otherwise, we say that A is unknown with respect to Adv. From D's perspective in Fig. 2, for example, #1, #4, and #3 are useful, #5 is partition-known, and #2 is unknown. If corresponding attestations are useful to Adv, or if either has a partition-compatible path from its subject to a partition-compatible cycle, then they must be identical. In the sequence of hybrids, the encrypted graph provided by the challenger if b = 0 is identical to the encrypted graph in the previous hybrid, except that either (1) one of the WIBE or IBE ciphertexts generated by Chl in the Challenge phase is replaced with an encryption of a different string of correct length, or (2) the ID used for IBE encryption is changed to a different ID. This is because a ciphertext cannot be replaced with an encryption of zero if a secret key to decrypt the ciphertext exists in the graph. At the end of this hybrid sequence, the challenger provides a graph containing encryptions of zero in non-useful attestations if b = 0, and a proper encryption of G 1 if b = 1. It sends to Adv the public keys (verification key and WIBE/IBE public parameters) corresponding to each entity. In the sequence of hybrids, the encrypted graph provided by the challenger if b = 0 is identical to the encrypted graph in the previous hybrid, except that either (1) one of the WIBE or IBE ciphertexts generated by Chl in the Challenge phase is replaced with an encryption of a different string of correct length, or (2) the ID used for IBE encryption is changed to a different ID. This is because a ciphertext cannot be replaced with an encryption of zero if a secret key to decrypt the ciphertext exists in the graph. At the end of this hybrid sequence, the challenger provides a graph containing encryptions of zero in non-useful attestations if b = 0, and a proper encryption of G 1 if b = 1.