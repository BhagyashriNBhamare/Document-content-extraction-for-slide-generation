We propose three FUZZIFICATION techniques: 1) SpeedBump, which amplifies the slowdown in normal executions by hundreds of times to the fuzzed execution, 2) BranchTrap, interfering with feedback logic by hiding paths and polluting coverage maps, and 3) AntiHybrid, hindering taint-analysis and symbolic execution. Our evaluation on popular fuzzers and real-world applications shows that FUZZIFICATION effectively reduces the number of discovered paths by 70.3% and decreases the number of identified crashes by 93.0% from real-world binaries, and decreases the number of detected bugs by 67.5% from LAVA-M dataset while under user-specified overheads for common workloads. In this paper, we propose a new direction of binary protection, called FUZZIFICATION, that hinders attackers from effectively finding bugs. Specifically, attackers may still be able to find bugs from the binary protected by FUZZIFICATION, but with significantly more effort (e.g., CPU, memory, and time). First, it should be effective for hindering existing fuzzing tools, finding fewer bugs within a fixed time; second, the protected program should still run efficiently in normal usage; third, the protection code should not be easily identified or removed from the protected binary by straightforward analysis techniques.No existing technique can achieve all three goals simultaneously. It can slow each fuzzed execution, as shown in Figure 1(b), but the path discovery per execution is almost identical to that of fuzzing the original binary, as shown in Figure 1(c). It injects delays to cold paths, which normal executions rarely reach but that fuzzed executions frequently visit. The AntiHybrid technique aims to thwart hybrid fuzzing approaches that incorporate traditional fuzzing methods with dynamic taint analysis and symbolic execution.We develop defensive mechanisms to hinder attackers identifying or removing our techniques from protected binaries. We also perform an analysis to show that data-flow and control-flow analysis techniques cannot easily disarm our techniques.In this paper, we make the following contributions:• We first shed light on the new research direction of antifuzzing schemes, so-called, FUZZIFICATION. We will release the source code of our work at https: //github.com/sslab-gatech/fuzzification. For a given program, a fuzzer first creates a large number of inputs, either by random mutation or by format-based generation. Current research highlights several fast execution techniques, including (1) customized system and hardware to accelerate fuzzed execution and (2) parallel fuzzing to amortize the absolute execution time in large-scale. This fuzzing strategy is based on two empirical observations: (1) a higher path coverage indicates a higher chance of exposing bugs; and (2) mutating inputs that ever trigger new paths is likely to trigger another new path. Most popular fuzzers take code coverage as guidance, like AFL, HonggFuzz, and LibFuzzer, but with different methods for coverage representation and coverage collection. First, fuzzers do not distinguish input bytes with different types (e.g., magic number, length specifier) and thus may waste time mutating less important bytes Developers create a protected binary with FUZZIFICATION techniques and release it to public. Attackers cannot find many bugs from the protected binary through fuzzing, while trusted parties can effectively find significantly more bugs and developers can patch them in time.that cannot affect any control flow. One is compiled with FUZZIFICATION techniques to generate a protected binary, and the other is compiled normally to generate a normal binary. Then, developers distribute the protected binary to the public, including normal users and malicious attackers. Pack & obfuscation ✔ ✔ ✗ ✔ Bug injection ✔ ✔ ✗ ✗ Fuzzer identification ✔ ✗ ✔ ✗ Emulator bugs ✔ ✗ ✔ ✔ FUZZIFICATION ✔ ✔ ✔ ✔ We consider motivated attackers who attempt to find software vulnerabilities through state-of-the-art fuzzing techniques, but with limited resources like computing power (at most similar resources as trusted parties). A FUZZIFICATION technique should achieve the following four goals simultaneously:• Effective: It should effectively reduce the number of bugs found in the protected binary, compared to that found in the original binary. However, they usually introduce higher performance overhead to program executions, which not only hinders fuzzing, but also affects the use of normal users. Injecting arbitrary code snippets that trigger non-exploitable crashes can cause additional bookkeeping overhead and affect end users in unexpected ways [31]. First, SpeedBump injects finegrained delay primitives into cold paths that fuzzed executions frequently touch but normal executions rarely use ( §3). Second, BranchTrap fabricates a number of input-sensitive branches to induce the coverage-based fuzzers to waste their efforts on fruitless paths ( §4). Third, AntiHybrid transforms explicit data-flows into implicit ones to prevent data-flow tracking through taint analysis, and inserts a large number of spurious symbols to trigger path explosion during the symbolic execution ( §5). 1 We compile the program to generate a normal binary and run it with the given normal test cases to collect basic block frequencies. Our observation is that the fuzzed execution frequently falls into paths such as error-handling (e.g., wrong MAGIC bytes) that the normal executions rarely visit. Our tool automatically determines the number of code paths to inject delays and the length of each delay so that the protected binary has overhead under the user-defined budget during normal executions. First, we instrument the target programs to count visited basic blocks during the execution and generate a binary for profiling. We perform the following two steps repeatedly to determine the set of code blocks to inject delays and the length of each delay:• We start by injecting a 30ms delay to 3% of the leastexecuted basic blocks in the test executions. If it does not exceed the user-defined overhead budget, we go to the previous step to inject more delay into more basic blocks. Our SpeedBump technique is especially useful for developers who generally have a good understanding of their applications, as well as the requirements for FUZZIFICATION. INCLUDE_NON_EXEC and NON_EXEC_RATIO specify whether to inject delays into how ever many basic blocks are never executed during test execution. For a 120ms delay, we cannot inject any blocks for 1% overhead and can inject only 2% of the cold paths for 3% overhead. Specifically, we pass a variable from the original code to the generated code as an argument, make a reference from the generated code to the original one, and use the return value to modify a global variable of the original code. In this way, we introduce data-flow dependency between the original code and the injected code (line 6, 9 and 12), and change the program state without affecting the original program. We repeatedly run the modified CSmith to find appropriate code snippets that take a specific time (e.g., 10ms) for delay injection.1 //Predefined global variables 2 int32_t GLOBAL_VAR1 = 1, GLOBAL_VAR2 = 2; 3 //Randomly generated code 4 int32_t * func(int32_t p6) { 5 int32_t *l0[1000]; 6 GLOBAL_VAR1 = 0x4507L; // affect global var. For example, CSmith conducts pointer analysis to detect any access to an out-of-scope stack variable or null pointer dereference, uses explicit initialization to prevent uninitialized usage, applies math wrapper to prevent unexpected integer overflow, and analyzes qualifiers to avoid any mismatch. Recent fuzzing proposals, like VUzzer [52] and T-Fuzz [48], identify errorhandling basic blocks through profiling and exclude them from the code coverage calculation to avoid repetitive executions. Fortunately, the cold paths from SpeedBump include not only error-handling basic blocks, but also rarely executed functional blocks. Once a fuzzed execution triggers the fabricated branch, the fuzzer will set a higher priority to mutate that input, resulting in the detection of more fake paths. Finally, BranchTrap cannot be easily identified or removed by adversaries.A trivial implementation of BranchTrap is to inject a jump table and use some input bytes as the index to access the table (i.e., different input values result in different jump targets). To harden BranchTrap, we diversify the return addresses of each injected branch according to the user input. Our idea is inspired by ROP, which reuses existing code for malicious at- = arg1^arg2 index jmp table [index] ... tacks by chaining various small code snippets. 4 Finally, the execution returns to the original return address.The ROP-based BranchTrap has three benefits:• Effective: Control-flow is constantly and sensitively changed together with the user input mutation; thus FUZZIFICATION can introduce a sufficient number of unproductive paths and make coverage feedback less effective. • Low overhead: BranchTrap introduces low overhead to normal user operations (e.g., less than 1% overhead) due to its lightweight operations (Store argument; XOR; Resolve jump address; Jump to gadget). The second method of BranchTrap is to saturate the fuzzing state, which blocks the fuzzers from learning the progress in the code coverage. In this way, most of the newly discovered paths in the following executions will be treated as visited, and thus the fuzzer will discard the input that in fact explores interesting paths. If the initial bitmap is highly filled, such as 80% saturation, AFL detects only 700 paths with the same fuzzing effort. In our threat model, attackers cannot obtain the program source code or the original binarythey only have a copy of the protected binary, which makes it significantly more challenging to apply similar ID-assignment algorithms. We provide developers an interface to configure ROP-based BranchTrap and coverage saturation for optimal protection. First, the number of generated fake paths of ROP-based BranchTrap is configurable. To avoid high code size overhead, we inject a huge number of branches into only one or two of the most rarely executed basic blocks. VUzzer [52] utilized dynamic taint analysis to identify path-critical input bytes for effective input mutation. For example, to cover data dependency through a control channel, the DTA engine has to aggressively propagate the taint attribute to any variable after a conditional branch, making the analysis more expensive and the result less accurate.Introducing implicit data-flow dependencies. We transform the explicit data-flows in the original program into implicit data-flows to hinder taint analysis. For example, recent work, RedQueen [2], infers the potential relationship between input and branch conditions through pattern matching, and thus can bypass the implicit data-flow transformation. To hinder hybrid fuzzers using symbolic execution, FUZZIFICATION injects multiple code chunks to intentionally trigger path explosions. Once injected codes are run by the fuzzer multiple times, QSym identifies the repetitive basic blocks (i.e., injected hash function) and performs basic block pruning, which decides not to generate a further constraint from it to assign resources into a new constraint. We LLVM pass and use it to inject delays into cold blocks during the compilation. For the AntiHybrid technique, we use an LLVM pass to introduce the path explosion and utilize a python script to automatically inject implicit data-flows. We evaluate FUZZIFICATION against four state-of-the-art fuzzers that work on binaries, specifically, AFL in QEMU mode, HonggFuzz in Intel-PT mode, VUzzer 32 1 , and QSym with AFL-QEMU. The nine real-world programs include four applications from the Google fuzzer test-suite [24], four programs from the binutils [20] (shown in Table 2), and the PDF reader MuPDF. Second, we use three fuzzers to fuzz four binutils programs and all four fuzzers to fuzz LAVA-M programs to evaluate the impact of FUZZIFICATION on unique bug finding. We use two metrics to measure the effectiveness of FUZZIFICATION: code coverage in terms of discovered real paths, and unique crashes. We measure the impact of FUZZIFICATION on reducing the number of real paths against AFL-QEMU and HonggFuzzIntel-PT. We fuzz these programs for three days, using QSym as the symbolic execution engine and AFL-QEMU as the native fuzzer.67% to HonggFuzz, on average. Interestingly, although AntiHybrid is developed to hinder hybrid approaches, it also helps reduce the discovered paths in normal fuzzers. In summary, FUZZIFICATION satisfies the user-specified overhead budget, but shows relatively high space overhead. Further, BranchTrap is configurable, and developers may inject a smaller number of fake branches to small programs to avoid large-size overhead.Analysis on less effective results. We analyzedSpeedBump BranchTrap AntiHybrid All AFL-QEMU -66% -23% -18% -74% HonggFuzz (PT) -44% -14% -7% -61% QSym (AFL-QEMU) -59% -58% -67% -80%Average -56% -31% -30% -71% Table 5: Reduction of discovered paths by FUZZIFICATION techniques. Specifically, these two techniques only inject nine basic blocks within the user-specified overhead budget (2% for SpeedBump and 2% for BranchTrap), which is less than 0.1% of all basic blocks. The result of libjpeg shows an interesting pattern: QSym finds a large number of real paths from the original binary in the last 8 hours, but it did not get the same result from any protected binary. Table 5 shows that AntiHybrid achieves the best effect (67% path reduction) against hybrid fuzzers, followed by SpeedBump (59%) and BranchTrap (58%). Overall, FUZZIFICATION reduces the number of discovered crashes by 93%, specifically, by 88% to AFL, by 98% to HonggFuzz, and by 94% to QSym. Specifically, we used tiny delay primitives (i.e., 10 µs to 100 µs), tuned the ratio of basic block instrumentation from 1% to 0.1%, reduced the number of applied AntiHybrid components, and injected smaller deterministic branches to reduce the code size overhead. To understand the practicality of FUZZIFICATION on large and realistic applications, we choose six programs that have a graphical user interface (GUI) and depend on tens of libraries.As fuzzing large and GUI programs is a well-known challenging problem, our evaluation here focuses on measuring the overhead of FUZZIFICATION techniques and the functionality of protected programs. When applying the SpeedBump technique, we have to skip the basic block profiling step due to the lack of command-line interface (CLI) support (e.g., readelf parses ELF file and displays results in command line); thus, we only insert slow down primitives into error-handling routines. As shown in Table 7, on average, FUZZIFICATION introduces 5.4% code size overhead and 0.73% runtime overhead. Note that the code size overhead is much smaller than that of previous programs (i.e., 62.1% for eight relatively small programs Table 2 and over 100% size overhead for simple LAVA-M programs Table 6). Control Data Manual matching analysis analysis analysis SpeedBump ✔ ✔ ✔ - BranchTrap ✔ ✔ ✔ - AntiHybrid - ✔ ✔ - We evaluate the robustness of FUZZIFICATION techniques against off-the-shelf program analysis techniques that adversaries may use to reverse our protections. We confirm that no specific patterns can be found in SpeedBump and BranchTrap because we leverage CSmith [66] to randomly generate a new code snippet for each FUZZIFICATION process.Second, control-flow analysis can identify unused code in a given binary automatically and thus automatically remove it (i.e., dead code elimination). Instead, it introduces an expensive cost on the attackers' side when they try to fuzz the program to find bugs, and thus developers are able to detect bugs first and fix them in a timely manner. Existing mitigation efforts either aim to avoid program bugs (e.g., through type-safe language [32,44]) or aim to prevent successful exploits, assuming attackers will find bugs anyway (e.g., through control-flow integrity [1,16,30]). Delay primitive on different H/W environments.We adopt CSmith-generated code as our delay primitives using measured delay on one machine (i.e., developer's machine). Recently, researchers have been using fuzzing as a general way to explore program paths with specialties, such as maximizing CPU usage [49], reaching a particular code location [5], and verifying the deep learning result empiri-cally [47]. We build effective methods to hinder attackers on bug finding using FUZZIFICATION, which can provide developers and trusted researchers time to defeat the adversarial fuzzing effort.Anti-fuzzing techniques. However, our methods, at most, introduce slow down to the execution, while improper chaff bugs lead to crashes, thus harming the usability.Anti-analysis techniques. We develop three principled ways to hinder fuzzing: injecting delays to slow fuzzed executions; inserting fabricated branches to confuse coverage feedback; transforming data-flows to prevent taint analysis and utilizing complicated constraints to cripple symbolic execution. This research was supported, in part, by the NSF award CNS-1563848, CNS-1704701, CRI-1629851 and CNS-1749711 ONR under grant N00014-18-1-2662, N00014-15-1-2162, N00014-17-1-2895, DARPA TC (No.