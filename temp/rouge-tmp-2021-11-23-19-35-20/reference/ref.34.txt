In this paper, we reverse engineer the microcode semantics and inner workings of its update mechanism of conventional COTS CPUs on the example of AMD's K8 and K10 microarchitectures. From a high-level perspective, microcode is an interpreter between the user-visible Complex Instruction Set Computer (CISC) Instruction Set Architecture (ISA) and internal hardware based on Reduced Instruction Set Computer (RISC) paradigms [54]. In this paper, we focus on microcode in x86 CPUs and our goal is to answer the following research questions:1. We demonstrate how a microprogram can be utilized to instrument a binary executable on the CPU layer and we also introduce different kinds of backdoors that are enabled via microcode updates.Our analysis focuses on the AMD K8/K10 microarchitecture since these CPUs do not use cryptographic signatures to verify the integrity and authenticity of microcode updates. We introduce the first semiautomatic reverse engineering technique to disclose microcode encoding of general-purpose CPUs. Even though these works reported the workings of the microcode update mechanism, the purpose of fields within the microcode update header, and the presence of other metadata, none of the works was able to reverse engineer the essential microcode encoding. Hence, they were not able to build microcode updates on their own.We want to note that Arrigo Triulzi presented at TROOPERS'15 and '16 that he had been able to patch the microcode of an AMD K8 microarchitecture [59,60]. In this section, we provide a general overview of the mechanisms behind microcode and also cover details about the microcode structure and update mechanism. Based on the status signals, the control unit may alter program execution, i.e., a conditional jump is taken if the zero flag is set.The IDU plays a central role within the control unit and generates control signals based on the contents of the instruction register. Hence, hardwired decode units are suited for simple ISAs such as RISC processors like SPARC and MIPS.Microcoded Decode Unit. The microcode sequencer operates the whole decoding process, successively selecting microinstructions until the decode complete indicator comes up. The historical IBM System/360 M50 processor with horizontally-encoded microcode used 85-bit control words [53]. The well-known fdiv bug [62], which affected Intel Pentium processors in 1994, raised awareness that similarly to software, complex hardware is error-prone, too. Furthermore, we present our analysis setup and framework that includes prototype implementations of our concepts and supported our reverse engineering effort in a semi-automated way.Our analysis primarily covers AMD K8 and K10 processors because-to the best of our knowledge-they are the only commercially available, modern x86 microarchitectures lacking strong cryptographic protection of microcode patches. The former mainly represent the frequently used, performance critical macroinstructions (e.g., arithmetic and logical operations) that are decoded by hardware into up to three microinstructions. The sequence word may contain the address of the next triad or indicate that decoding is complete. They hold a microcode ROM address, intercept the triad stored at that location, and redirect control to the triad in patch RAM at the offset match register index Â· 2. The shared address space enables microcode in the patch RAM to jump back to microcode ROM, e.g., to reuse existing triads. Hence, we require a low-noise environment where we have full control of all code to realize accurate observation of the CPU state and behavior.Microcode ROM Heat Maps. Hence, we developed a novel technique to reverse engineer proprietary microcode encoding in a semi-automatic way.Since we did not have a large microcode update base on which we could perform fine-grained tests, we merely had a black box model of the CPU. After reverse engineering the microcode encoding, we can arbitrarily change CPU behavior for any microcoded macroinstruction and intercept control for any microcode ROM address. Combined with the fact that microcode updates potentially reset or halt the entire machine, it became apparent that another controller computer was needed. The error state includes the faulting program counter and stack pointer as well as the x86 general-purpose registers. A custom message protocol exposes the following operating system features via serial connection: (1) stream x86 machine code, (2) send and apply microcode update, and (3) report back the final or intermediate CPU state. Another test case that attempts to infer conditional behavior of microcode may alter streamed x86 machine code in order to induce different x86 eflags register values and at the same time permute the bit vector of an unknown field within a microinstruction. They indicate microcode ROM locations to intercept macroinstructions and help infer logic from triads. Unless stated otherwise, all information given afterwards was obtained through reverse engineering.We found four operation classes, namely RegOp, LdOp, StOp, and SpecOp, that are used for arithmetic and logic operations, memory reads, memory writes, and special operations such as write program counter, respectively. In case the conditional branch is not taken, the sequence word determines further execution. The special pcd register is read-only and contains the address of the next macroinstruction to decode. The sequence word, see Table 3, contains an action field at bit locations 14 to 16 that may indicate a branch to the triad at the given address, a branch to the following triad, or stop decoding of the current macroinstruction. (2) After execution of the added logic we implement the semantics of the macroinstruction in microcode ourselves and indicate sequence complete in the last triad. We developed a microcode register transfer language based on the syntax of Intel x86 assembly language, because for the implementation of microprograms it is impractical to manually assemble bit vectors. The conditional microcode branch encodes the condition in the first operand and the branch target in the second operand, i.e. jcc nZF, 0xfe5. In contrast to traditional microcontrollers, general-purpose x86 CPUs feature a much larger die size and are stacked up to 12 layers, which increases hardware reverse engineering effort.We expected the targeted non-volatile microcode ROM to be stored in a cell array architecture. In NOR ROM with active layer programming, the logic state is encoded by the presence or absence of a transistor [52]. We chose to represent the individual cells as set to logical '1' if the left via was set and '0' if the right one was set. In this section, we demonstrate the effectiveness of our reverse engineering effort by presenting microprograms that successfully augment existing x86 instructions and add foreign logic. See Listing 1 for a highlevel representation of the instrumentation logic; we refer the interested reader to Listing 7 in Appendix A.3 for a detailed RTL implementation.if ( esi == magic ) { temp = dword [ edi ] temp += 1 dword [ edi ] = temp }Listing 1: High-level description of the instrumentation logic implemented in microcode that counts the div instructions during execution. Hence, legitimate machine instructions as shown in Listing 3 may be misused to hide and execute arbitrary code.B8 0 A000000 mov eax , 0 xA BB 0 B000000 mov ebx , 0 xB F7F3 div ebx 05 909090 CC add eax , 0 xCC909090Listing 3: x86 machine code to trigger the div Trojan in Listing 2. More precisely, we present how microcode Trojans enable both (1) a bug attack (representative for Fault Injection (FI) [13]) and (2) a timing attack for Side-Channel Analysis (SCA) [34]. Since Curve25519 employs reduced-degree reduced-coefficient polynomials for arithmetic and the implementation uses 64-bit data types, the following C code is compiled to assembly in Listing 6:carry = (h + (i64) (1L << 25)) >> 26; mov eax , dword [ esp +0 xd0 ] add eax , 0 x2000000 mov ebx , dword [ esp +0 xd4 ] adc ebx , 0 x0 shrd eax , ebx , 0 x1aListing 6: x86 machine code implementing 64-bit right shift using the shrd instruction.This line of code processes internal (key-dependent) data as well as adversary-controlled (public-key dependent) data. We emphasize that the necessary primitives for bug attacks and timing side channel attacks can be created via microcode Trojans. From a hardware Trojan's perspective [58], microcode Trojans provide post-manufacturing versatility, which is indispensable for the heterogeneity in operating systems and applications running on general-purpose CPUs.Even though AMD emphasizes that their chips are secure [25], the microcode update scheme of K8 and K10 shows once more that security by obscurity is not reliable and proper encryption, authentication, and integrity have to deployed. For example, reverse engineering of an ARM1 processor [33] disclosed the presence of a decode Programmable Logic Array (PLA) storing microinstructions. For example, an open-source CPU variant for the security community can lead to instrumentation frameworks and system defenses based on performant microprograms. sw_branch 0 x7e6Listing 7: Microprogram that instruments the x86 instruction div and counts the occurrences. Part of this work was supported by the European Research Council (ERC) under the European Unions Horizon 2020 research and innovation programme (ERC Starting Grant No. 640110 (BASTION) and ERC Advanced Grant No. 695022 (EPoCH)). We listed the microcode registers with mnemonics and encoding in rdi 000111 t1l t1w t1d t1q 001000 t2l t2w t2d t2q 001001 t3l t3w t3d t3q 001010 t4l t4w t4d t4q 001011 t1h t5w t5d t5q 001100 t2h t6w t6d t6q 001101 t3h t7w t7d t7q 001110 t4h t8w t8d t8q 001111 regmb regmw regmd regmq 101000 regb regw regd regq 101100 pcb pcw pcd pcq 111000 zerob zerow zerod zeroq 111111 Table 6: General-purpose and microcode register encodings.As explained in Section 7.3, we exploit the x86 shrd instruction to implement both the bug attack and the timing attack. vector instruction 0x900 -0x913 -0x900 -0x913 -0x914 -0x917 rep cmps mem8 0x918 -0x95f -0x960 mul mem16 0x961 idiv 0x962 mul reg16 0x963 - 0x964 imul mem16 0x965 bound 0x966 imul reg16 0x967 - 0x968 bts imm 0x969 -0x971 -0x972 -0x973 div 0x974 -0x975 -0x976 -0x977 idiv 0x978 -0x979 -0x97a idiv 0x97b -0x9a7 -0x9a8btr imm 0x9a9 -0x9ad -0x9ae mfence 0x9af -09ff - In Section 5.2 we presented the microcode instruction set structure, which is one major result of our reverse engineering effort. We listed the microcode registers with mnemonics and encoding in rdi 000111 t1l t1w t1d t1q 001000 t2l t2w t2d t2q 001001 t3l t3w t3d t3q 001010 t4l t4w t4d t4q 001011 t1h t5w t5d t5q 001100 t2h t6w t6d t6q 001101 t3h t7w t7d t7q 001110 t4h t8w t8d t8q 001111 regmb regmw regmd regmq 101000 regb regw regd regq 101100 pcb pcw pcd pcq 111000 zerob zerow zerod zeroq 111111 Table 6: General-purpose and microcode register encodings.As explained in Section 7.3, we exploit the x86 shrd instruction to implement both the bug attack and the timing attack.