Current state-of-the-art deobfuscation approaches operate on instruction traces and use a mixed approach of symbolic execution and taint analysis; two techniques that require precise analysis of the underlying code. On the other hand, obfuscated malware stays under the radar for a longer time, until concrete analysis results can be used to effectively defend against it.To deal with this problem, prior research has explored many different approaches to enable deobfuscation of obfuscated code. Instead of manually analyzing the instruction handlers used in virtualization-based (VM) obfuscation schemes in a complex and tedious manner [44] or learning merely the bytecode decoding (not the semantics) of these instruction handlers [53], we aim at learning the semantics of VM-based instruction handlers in an automated way. Then, an SMT solver returns a permutation of the components that forms a well-encoded program following the previously specified intent [22,24], if it is satisfiable, i. e., such a permutation does exist.Instead of relying on a logical specification of program intent, oracle-guided program synthesis uses an inputoutput (I/O) oracle. Finally, to show applicability to areas more focused on security aspects, we further automatically learn the semantics of ROP gadgets.Contributions In summary, we make the following contributions in this paper:• We introduce a generic approach for trace simplification based on program synthesis to obtain the semantics of different kinds of obfuscated code. Based on I/O samples from assembly code as input, Syntia can apply MCTS-based program synthesis to compute a simplified expression that represents a deobfuscated version of the input. It is initialized by sequence called VM entry, which handles the context switch from native code to bytecode.After initialization, the VM dispatcher fetches and decodes the next instruction and invokes the corresponding handler function by looking it up in a global handler table (depicted in Figure 1). To exemplify, consider the following Intel x86 code: [ eax ] This might get translated into VM-ISA as follows: It favors many small, simple handlers over fewer more complicated ones.1 mov eax , dword ptr [0 x401000 + ebx * 4] 2 pop dword ptr1 vm_mov T0 , vm_contextBytecode Blinding. An alternative is proposed by Bell with Threaded Code (TC) [4]: He suggests inlining the dispatcher routine into the individual handler functions such that handlers execute in a chained manner, instead of returning to a central dispatcher. As an example, consider the gadget pop eax; ret: It takes the value on top of the stack, places it in eax and, using the ret instruction, dispatches the next gadget in the chain. In particular, the chained invocation of gadgets is reminiscent of handlers in VM-based obfuscation schemes following the threaded code principle.In addition to its application to exploitation, ROP has seen other fields of applications such as rootkit development [59], software watermarking [34], steganography [33], and code integrity verification [1], which reinforces the importance of automatic ROP chain analysis. This allows them to reduce the trace to those instructions relevant to the previously mentioned value flow.Graziano et al. [19] mainly apply standard compiler transformations such as dead code elimination or arithmetic simplifications to reduce the trace.Yadegari et al. [62] use bit-level taint analysis to identify instructions relevant to the computation of outputs. The core algorithm iteratively builds the decision tree in four main steps that are also illustrated in Figure 2: (1) The selection step starts at the root node and successively selects the mostpromising child node, until an expandable leaf (i. e., a non-terminal node that has unvisited children) is reached. It is obtained byX j +C ln n n j ,(1)where X j represents the average reward of the child node j, n the current node's number of visits, n j the visits of the child node and C the exploration constant. Given an instruction trace, we dissect the instruction trace into trace windows (i. e., subtraces) and aim at learning their high-level semantics which can be used later on for further analysis. Most notably, it affects synthesis results: if a trace window ends at an intermediary computation step, the synthesized formula is not necessarily succinct or meaningful at all, as it includes spurious semantics. For inputs, we apply a read-before-write principle: inputs are only registers/memory locations that are read before they have been written; for outputs, we consider the last writes of a register/memory location as output.Following this principle, the code above has three inputs and two outputs: The inputs are the memory read M 0 in line 1, rcx (line 2) and rdx (line 4). These synthesis instances are mutually independent and can be completely parallelized.To exemplify, for the I/O pairs above, we search an expression that transforms (2, 5, 7) to 7 and (1, 7, 10) to 8 for o 0 ; for o 1 , the expression has to map (2, 5, 7) to 14 and (1, 7, 10) to 18. Working with bit-vectors of size 3 (i. e., modulo 2 3 ), we observe for an expression with two inputs and one output the I/O relations: (2, 2) → 4 and (4, 5) → 1. As described in Section 2.3, the UCT (cf. Equation 1) provides a good balance between exploitation and exploration for many MCTS applications.However, we observed that it does not work for our use case: if we set the exploration constant C to a higher value (focus on exploration), it does not find deeper expressions; if we set C to a lower value, MCTS gets lost in deep expressions. For every data type that can be computed we introduce one non-terminal symbol (in our running example, we only use a single non-terminal value U that represents an unsigned integer). If we, in-+ U3 * U2 U1 Figure 6: The left-most U in U 3 U 2 U 1 * + is the topmost-right-most non-terminal in the abstract syntax tree. The expression (U + (U * U)) is represented as U U U * +. To measure the similarity of two outputs, we compare values with different metrics: arithmetic distance, Hamming distance, count leading zeros, count trailing zeros, count leading ones and count trailing ones. Limiting to the metrics of Hamming distance and count leading zeros (clz), we obtain hamming(4, 0) = hamming(4, 6) = 0.67, clz(4, 0) = 0 and clz(4, 6) = 1.0. Contrary, there exist four parameters that can be configured by a user to improve the effectiveness and speed: the initial SA-UCT value, the number of I/O samples, the maximum number of MCTS iterations and the maximum playout depth.The SA-UCT parameter T configures the trade-off between exploration and exploitation and depends on the maximum number of MCTS iterations; if the maximum number of MCTS iterations is low, the algorithm focuses on exploiting promising candidates within a small period of time. On the other hands, deeper playouts have an impact on the execution time.Since random playouts are performed for every node and for every I/O pair, the number of I/O samples has a significant impact on the execution time. Then, the user has the opportunity to define its own rules for trace dissection; otherwise, Syntia dissects the trace at indirect control In the following, we evaluate our approach in three areas of application. As a result, Simulated Annealing optimizes towards a high success rate for synthesis tasks and a minimal average time. With n a positive integer and B = {0, 1}, the algebraic system (B n , ∧, ∨, ⊕, ¬, ≤, ≥, >, <, ≤ s , ≥ s , > s , < s , =, =, s , , , +, −, ·), where , denote left and right shifts, · (or juxtaposition) denotes multiply, and signed compares and arithmetic right shift are indicated by s , is a Boolean-arithmetic algebra (BA-algebra), BA [n]. The arithmetic encoding is applied to highlight that our approach is invariant to the code's increased symbolic complexity and is only concerned with semantical complexity.Based on a concrete execution trace it can be observed that the 500 functions use, on average, 5 memory inputs (as parameters are passed on the stack) and one register output (the register containing the return value). Overall, the 500 synthesis tasks were finished in about 34 minutes, i. e., in 4.0 seconds per expression. Sharif et al. successfully mounted such an attack to recover the CFG of the virtualized function [53], but do not take semantics other than virtual instruction pointer updates into account.We recognize the latter approach as promising and note how Syntia allows us to automatically extract the highlevel semantics of arithmetical and logical instruction handlers. We evaluated Syntia to learn the semantics of arithmetic and logical VM instruction handlers in recent versions of VMProtect [58] (v3.0.9) and Themida [38] (v2.4.5.0). For example, the 449 instruction handlers contain 12 instances performing 8-bit addition, 11 instances for each of addition (for each flavor of 16-, 32-, 64-bit), nor (8-, 64-bit), left and right shift (32-, 64-bit); amongst multiple others. Equivalent reasoning applies to 16-bit nor operations in our trace (3.6% of the full trace, 18.8% of all arithmetic and logical trace windows). As the analysis is probabilistic in nature, we scheduled five more runs which yielded 4 new handlers. Even though the central handler table lists 1, 111 handlers, we identified 106 unique trace windows along the concrete execution trace.Themida implements a register-based architecture and stores intermediate computations in one of many register available in the VM context. Due to the small numbers of inputs and synthesis tasks, we chose the configuration vector (1.5, 100000, 50, 0) that sets a very strong focus on exploration while accepting a higher running time. Our synthesis results include 58 assignments, 17 binary additions, 5 ternary additions, 4 unary minus, 4 binary subtractions, 4 register increments/decrements, 2 binary multiplications and 1 bitwise and. We stress how VM-based obfuscation schemes do this to the extreme: a relatively small number of unique trace windows are used over the whole trace.In general, the synthesis results may not be precise semantics since we approximate them based on I/O samples. We still try to improve exploration strategies, for instance with Nested Monte Carlo Tree Search [35] and Monte Carlo Beam Search [7]. We now review related work for program synthesis, Monte Carlo Tree Search and deobfuscation. Furthermore, we can encode arbitrary complex function symbols in our grammar (e. g., complex encoding schemes or hash functions); a characteristic that is not easily reproduced by SMT-based approaches.In the context of non-academic work, Rolles applied some of the above mentioned SMT-based approaches to reverse engineering and deobfuscation [45]. Lim and Yoo [32] describe an early exploration on how MCTS can be used for program synthesis and note that it shows comparable performance to genetic programming. This approach is closest to our work as we are, in turn, mostly concerned with arithmetic and logical semantics of a handler.More recent results include work by Coogan et al.[13] as well as Yadegari et al. [62]. A second technique preserves program behavior of the obfuscated program for specific input invariants only, effectively increasing the input domains and thus the search space for symbolic executors.Guinet et al. present arybo, a framework to simplify MBA expressions [20].