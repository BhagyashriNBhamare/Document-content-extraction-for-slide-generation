However, more recent mal-ware has turned to employing obfuscation that subverts the integrity of the Android runtime (ART or Dalvik), a technique we call runtime-based obfuscation. In this work, we propose TIRO, a deobfuscation framework for Android using an approach of Target-Instrument-Run-Observe. We also evaluate TIRO on a corpus of 2000 malware samples from VirusTotal and find that runtime-based obfuscation techniques are present in 80% of the samples, demonstrating that runtime-based obfuscation is a significant tool employed by Android malware authors today. While dynamic analyses [10,27,28,34] can be used to detect and analyze malware, anti-malware tools often use static analysis as well for efficiency and greater code coverage [1,2,12]. In contrast, malware authors may eschew Java and execute entirely in native code, obfuscating with techniques seen in x86 malware [3,8,17,20,24]. We call this technique full-native code obfuscation.In this paper, we identify a third option-obfuscation techniques that subvert ART, the Android RunTime, which we call runtime-based obfuscation techniques. Compared to full-native code obfuscation, runtime-based obfuscation allows a malware developer to still use the convenient Java-based API libraries provided by the framework. Our study of obfuscated malware suggests that authors almost universally employ language-and runtime-based methods to hide their use of Android APIs in Java.To study both language-and runtime-based obfuscation in Android malware, we propose TIRO, a tool that can handle both types of obfuscation techniques within a single deobfuscation framework. TIRO is an acronym for the automated approach taken to defeat obfuscation -Target-Instrument-Run-Observe. We identify and describe a family of runtime-based obfuscation techniques in ART, including DEX file hooking, class modification, ArtMethod hooking, method entry-point hooking and instruction hooking/overwriting.2. We also run TIRO on 2000 obfuscated malware samples downloaded from VirusTotal to measure the prevalence of various runtimebased obfuscation techniques in the wild and find that 80% use a form of runtime-based obfuscation.We begin by providing background on the Android runtime and classical language-based obfuscation techniques in Section 2. ART, a separate runtime introduced in Android 4.4 and set as the default in Android 5.0, adds ahead-of-time (AOT) compilation (using the dex2oat tool) to a DEX interpreter. Starting in Android 7.0, ART also includes profile-based smart compilation that uses a mixture of interpretation, JIT, and AOT compilation to boost application performance.We briefly discuss traditional language-based obfuscation and full-native code obfuscation techniques:Reflection. Java provides the ability to dynamically instantiate and invoke methods using reflection. Because the target of reflected method invocations is only known at run-time, this frustrates static analysis and can make the targets of these calls unresolvable (e.g. by using an encrypted string), thus hiding call edges and data accesses.Value encryption. In some cases, the invocation to the dynamic loading API may be obfuscated by performing the invocation reflectively or in native code, using multiple layers of obfuscation to increase the difficulty of analysis.Native methods. Java applications may use the Java Native Interface (JNI) to invoke native methods in the application. As a result, applications that use native code obfuscation still need obfuscation for Java code if they want to be able to make Android API calls reliably. Finally, C shows how virtual methods are dynamically resolved via a virtual method table (vtable) and execution is directed to the target method code. lang.DexFile object is returned to the application if it uses the DexFile.loadDex() API; in normal cases, this object is passed to a class loader so that ART can later load classes from the new DEX bytecode.The class loading process, Stage B , is triggered when a class is first requested (e.g. when it is first instantiated). The class linker within ART searches the loaded DEX files (in the order of loading) until it finds a class definition entry (class_def_item) matching the requested class name. A set of entry-points are stored with the ArtMethod to handle each case (see 5 ); each is essentially a function pointer/trampoline that performs any necessary set-up, obtains and executes the method's DEX or OAT code, and performs clean-up. We describe these techniques in more detail below:1 2 DEX file hooking.When loading a DEX file, the dalvik.system.DexFile class is used in Java code to identify the loaded file; however, the bulk of the actual loading is performed by native code in the runtime, using a complementary native art::DexFile class. In most cases, the malicious DEX file is loaded using non-API methods and classes within native code, or is dynamically generated in memory, further hiding its existence.Similarly, instead of modifying the mCookie field, the obfuscation code can also modify the begin_ field within the art::DexFile native class and redirect it to another DEX file. 3 Both the class data pointer (class_data_item), which determines where information for a class is stored, and method data pointer (method_data_item), which determines where information is stored for a method, are prime targets for such modification. Class objects, reflection via the JNI can be used to obtain the Java Method object and through this, the obfuscation code can determine the location of the corresponding ArtMethod object, which is a wrapper/abstraction around the method. By modifying and hooking the values of these entry-points, it can change the code that is executed when the method is invoked.Although the new entry-point code can be arbitrary native code, there exists a number of method hooking libraries [18,19,35] that allow an application developer to specify pairs of hooked and target methods in Java. This look-up method determines the registered target method for a hooked method invocation and executes it.6 Instruction hooking and overwriting. The final stage in the method invocation process is to retrieve the DEX or OAT code pointers for a method and execute the instructions; this is performed by the method's entrypoints. The output is a set of deobfuscated information (such as statically unresolvable run-time values, dynamically loaded code, etc.) that can be passed into existing security analysis tools to increase their coverage, or used by a human analyst to better understand the behaviors of an Android application.The main design of TIRO is an iterative loop that incrementally deobfuscates applications in four steps:T arget: We use static analysis to target locations where obfuscation is likely to occur. This instrumentation reports the dynamic information necessary for deobfuscation.R un: We execute the obfuscated code dynamically and trigger the application to deobfuscate/unpack and execute the code.O bserve: We observe and collect the deobfuscated information reported by the instrumentation during dynamic analysis. An associated dynamic client solves these constraints at run-time, assembles the input object from the solved values, and injects the input objects to trigger the paths. For runtime-based obfuscation, while the obfuscated code is executed in the runtime (i.e. in Java/DEX bytecode), the actual obfuscation is done in native code as described in Section 3.3. As a result, we instead target all Java entry-points into application-provided native code, such as invocations to native methods and to native code loading APIs (e.g. System.load(), which calls the JNI_ OnLoad function in the loaded native library). To deobfuscate dynamic loading, part of the instrumentation will store the loaded code in a TIRO-specific device location and report this location in the log. Since the result of this modification is the execution of unexpected code on a method invocation, one approach might be to record the code that was loaded into the runtime for a given method and check whether this code has been modified at the time of invocation. As a result, to detect runtime-based obfuscation, TIRO instruments transitions between native to Java and Java to native code to detect whether runtime state has been modified while the application was executing native code.The runtime state monitored is specific to the objects used to load and execute code, as described in Section 3.3. To reduce this cost we: (1) only monitor runtime state used in the code loading and execution process, and that are retrievable via the dynamic loading or reflection APIs (i.e. state stored within DexFile, Class, and Method objects); (2) only monitor the objects for methods and classes used by the application, as determined by reachability analysis during TIRO's static phase. TIRO substitutes the original application with its instrumented code and uses IntelliDroid's targeting capabilities to compute and inject the appropriate inputs to run the instrumented obfuscation locations. For obfuscation that executes dynamically loaded code (e.g. dynamic loading, DEX file hooking, etc.), TIRO's instrumentation extracts the code that is actually executed into an extraction file, and a process monitoring TIRO's instrumentation log pulls this file from the device. An example of how TIRO iteratively deobfuscates code from the dexprotector packer is given in Appendix A.We implemented the static and dynamic portions of TIRO on top of IntelliDroid [31] and added the ART instrumentation that deobfuscates runtime-based obfuscation. The deobfuscated information extracted by TIRO is incorporated into the static analysis prior to the call graph generation phase and the code instrumentation is performed after the extraction of targeted paths and constraints. For example, there were several instances of unparseable, invalid instructions in methods that appear to be dead code. In cases where a class definition or method implementation is malformed (which often occurs for applications performing DEX bytecode modification), we skip these classes/methods and do not produce an instrumented version. The dynamic portion was executed on a Nexus 5 device running TIRO's instrumented versions of Android 4.4, Android 5.1, and Android 6.0. For obfuscation tools where there was more than one sample, the table shows the results for the sample with the most sensitive behaviors detected. First, all of the malware samples employed basic language-based obfuscation such as reflection and native code usage, while roughly 53% (18/34) of the samples also employed the more advanced runtime-based obfuscation techniques. The new sensitive behaviors detected after TIRO's iterative deobfuscation included well-known malware behaviors such as premium SMS abuse and access to sensitive data, including location information and device identifiers. We now describe in detail some of the interesting behaviors and obfuscation techniques TIRO uncovered:aliprotect: During TIRO's first iteration, we found that the APK file contained only one class (StubApplication) that set up and unpacked the application's code. From the run-time information gathered, TIRO reported that a number of class objects were requested via reflection, but only one was instantiated via a reflected call to the constructor method.In the second iteration, TIRO found that only the class that was instantiated was actually present in the dynamically loaded code. Further analysis showed that the application performed a trial-and-error form of class loading, where it looped through class names app.plg_v#. These methods did not appear to be invoked but attempting to load them without patching Soot resulted in crashes stemming from parsing errors.baiduprotect / naga / naga_pha: These samples used DEX file hooking to load code dynamically but they would also modify the hooked DEX file multiple times in their execution. Further iterations deobfuscated the reflected and native method invocations that formed most of the application's call graph.ijiamipacker: When first installing this APK, the dex2oat tool reported a number of verification errors in most of the classes. Fortunately, this sample did not suppress error logs, so TIRO was modified to write to the error log as well. A more robust approach would be to implement a custom deobfuscation log that only TIRO can access and control.qihoopacker: In addition to the DEX file hooking obfuscation that this sample employed, we found that it also invoked art::RegisterNativeMethods() to redefine the native method DexFile.getClassNameList(). While this dataset is larger, we speculate that these differences and the broader use of runtime-based techniques likely owe more to the fact that the malware in this dataset are more recent than those in the previous labeled dataset.The most frequent form of runtime-based obfuscation found was DEX file hooking, which is likely due to the ease of implementing the state modification (i.e. the DexFile::mCookie field) required for the obfuscation. Techniques that require overwriting larger regions of memory or more precise determination of a location to modify (e.g. modifying a vtable entry for ArtMethod hooking) were much less common. However, we do see instances of these techniques in recent malware, and the overall frequency of runtime-based obfuscation techniques in our dataset is likely in response to advances in analyses that can deal with the simpler and more well-known language-based techniques. Since the majority of obfuscation occurs in the application launch phase (i.e. when the application unpacks its main activity and other components), we compare the launch time of the application when running in TIRO against the launch time in an unmodified version of AOSP. Unlike language-based obfuscation where the application abuses Java language features, runtime-based obfuscation requires modifying runtime data, which must be done using native code. Whether this is useful to the malware developer is dependent on the type of malicious activity they wish to execute on a victim's device and how they want to implement it. Reusing the existing runtime on Android makes it easier for commercial obfuscation tools to reliably support all forms of Android applications.In addition, system services are normally accessed through their RPC interface, which would require a transition back into the runtime and would be detected by TIRO's monitoring of native-to-Java transitions. If direct OAT or ODEX modification were to exist, it would be straightforward to enhance TIRO to detect these modifications by monitoring art::OatFile objects in the same manner as art::DexFile objects.While we have identified a number of forms of runtime-based obfuscation in Section 3.3, there may be others that TIRO currently does not monitor, providing avenues for newer malware to avoid detection and deobfuscation. In addition, IntelliDroid may not be able to extract all targeted paths and constraints due to static imprecision and complex path constraints in the code; TIRO naturally inherits these limitations. A variety of security and privacy analyzers have been developed for Android, including static [2,12] and dynamic tools [10,27,28,34]. Harvester [22] uses static code slicing to execute paths leading to specific code locations, such as reflection invocations, and can log deobfuscated values. Some Android unpackers, such as DexHunter [36] and Android-unpacker [26], handle certain cases of DEX file and DEX bytecode manipulation, but use special packer-specific values to identify the code that must be extracted. TamiFlex [5] deobfuscates reflection by instrumenting the reflection classes loaded by the Java runtime, but does not handle other forms of obfuscation. Polyunpack [24] checks whether dynamic instruction sequences match those in its static model of the application and returns new unpacked instruction sequences. We propose TIRO, a unified deobfuscation framework for Android applications that can deobfuscate runtime-based obfuscation as well as traditional techniques such as reflection or native method invocation. Through an iterative process of static instrumentation and dynamic information gathering that uses Target, Instrument, Run and Observe, we show that TIRO is able to deobfuscate malware that have been packed using state-of-the-art Android obfuscators. The research in this paper was supported by an NSERC CGS-D scholarship, a Tier 2 Canada Research Chair, and a Google Faculty Research Award. Deobfuscation in these cases requires multiple iterations to resolve the reflection target and, if the target is used for another form of obfuscation, to resolve the reflected obfuscation API.As an example, Figure 2 shows how TIRO iteratively applies the T-I-R-O loop to deobfuscate the combination of techniques used by the dexprotector packer and to extract a complete application call graph. TIRO finds locations of reflected method invocations and instruments them to determine the reflection targets. Deobfuscation in these cases requires multiple iterations to resolve the reflection target and, if the target is used for another form of obfuscation, to resolve the reflected obfuscation API.As an example, Figure 2 shows how TIRO iteratively applies the T-I-R-O loop to deobfuscate the combination of techniques used by the dexprotector packer and to extract a complete application call graph. It also finds two dynamically loaded DEX files.Iteration 2: The static analysis scope is expanded to include code from these two DEX files.