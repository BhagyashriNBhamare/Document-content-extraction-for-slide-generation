In this paper, we consider the problem of automatic vulnerability identification and exploit generation for smart contracts. We develop a generic definition of vulnerable contracts and use this to build TEETHER, a tool that allows creating an exploit for a contract given only its binary bytecode. As such, smart contracts can for example be used to implement fundraising schemes that automatically refund contributions unless a certain amount is raised in a given time, or shared wallets that require transactions to be approved of by multiple owners before execution. In Ethereum, smart contracts are defined in a high-level, JavaScript-like language called Solidity [2] and is then compiled into a bytecode representation suitable for consumption by the Ethereum Virtual Machine (EVM). In fact, since the inception of Ethereum in 2015, several cases of smart contract vulnerabilities have been observed [3,4], causing a loss of tens of millions USD. In particular, we identify four critical, low-level EVM instructions that are necessarily involved in a value transfer: One used to create regular transactions (CALL), one for contract termination (SELFDESTRUCT), and two that can allow for code injection (CALLCODE, DELEGATECALL). Our approach is as follows: We search for certain critical paths in a contract's control flow graph. TEETHER finds exploits for 815 (2.10%) of those-completely automated, without the need for human intervention or manual validation, and not requiring source code of contracts. To this end, we tackle several EVM-specific challenges, such as novel methodologies to handle hash values symbolically (Section 4). Ethereum is often described as a second-generation blockchain, due to its support of so-called smart contracts-accounts controlled only by code which can handle transactions fully autonomously. Users can submit transactions to the network in order to transfer Ether to other users or to invoke smart contracts. Additionally, smart contracts also have a (private) storagea key-value store with 256-bit keys and 256-bit values. The EVM is a stack-based virtual machine with a wordsize of 256 bit. Besides arithmetic and control-flow instructions, the EVM also offers special instructions to access fields of the current transaction, modify the contract's private storage, query the current blockchain state, and even create further transactions 1 . While some attempts have been made to create "updatable" contracts that only act as a front-end and delegate actual execution to another, updatable contract address, in most cases creating a new contract with updated code and transferring funds is the only option-given that funds can still be reclaimed from the old contract 2 . In Solidity, a function with the same name as the contract is considered a constructor (Wallet). For instance, the example contract defines a modifier onlyOwner, which checks if the sender of the current transaction is equal to the stored owner of the wallet. Only if the check suc- 1 The original Ethereum paper [25] distinguishes between transactions, which are signed by regular accounts, and messages, which are not. A simple function call on a smart contract on the other hand is a transaction with a value of 0 and data the input data to the contract. E.g., to call the withdraw function, data would consist of the bytes 2e1a7d4d, followed by the amount to be withdrawn in Wei as a 256-bit word. The transaction field gas therefore specifies the maximum amount of gas that may be consumed in processing the transaction. An attacker needs only be able to (i) obtain a contract's bytecode (in order to generate an exploit) and (ii) to submit transactions to the Ethereum network (to execute the exploit). Furthermore, especially the fully automated creation of exploits allows to easily validate whether the found vulnerabilities are actually real-an important step to show the effectiveness and accuracy of any bug finding mechanism.A fundamental downside of largely anonymous blockchain networks like Ethereum, however, is that we cannot reach out to owners of vulnerable contracts. We discussed several approaches to tackle this problem, including but not limited to (i) public disclosure of all vulnerable accounts such that they can remedy the problem (yet revealing exactly to the public which contracts are vulnerable); (ii) temporarily transfer ("steal") money from vulnerable contracts into secure contracts until the owner has fixed the problem (yet rendering the old contract unavailable, causing money loss due to transaction fees, and being illegal). Our idea is to statically analyze a contract's code to reveal critical code parts that might be abused to steal Ether stored in a contract. Two of the EVM instructions described in Ethereum's formal specification [25] allow the transfer of value to a given address: CALL and SELFDESTRUCT. 3 The CALL instruction performs a regular transaction, with the following stack arguments:1. in offset, in size, out offset, out sizememory location and length of call data respectively returned data.Thus, if an attacker can control the second stack argument (to) when a CALL instruction is executed with a non-zero third stack argument, they can cause the contract to transfer value to an address under their control. DELEGATECALL does 1 PUSH20 <attacker−controlled address> 2 SELFDESTRUCT Figure 2: EVM "shellcode" the same, but persists the original values of sender and value, i.e., instead of creating a new internal transaction, it modifies the current transaction and "delegates" handling to another contract's code. Consequently, value is omitted from the arguments of DELEGATECALL.If an attacker controls the second stack element (to) of either CALLCODE or DELEGATECALL, they can "inject" arbitrary code into a contract. leads to the execution of either a CALLCODE or DELEGATECALL instruction where the second stack argument can be externally controlled.Definition 2 (Vulnerable State). A contract is in a vulnerable state, if a transaction can lead to the execution of a critical path.We will call a transaction that exploits a contract in vulnerable state by one of the critical instructions as a critical transaction. A contract is vulnerable if there exists a (possibly empty) sequence of state changing transactions that lead to a vulnerable state.From this it immediately follows that a successful exploit always consists of a sequence of state changing transactions followed by a critical transaction. Finally, the exploit generation module solves the combined constraints of critical paths and state changing paths to produce an exploit. Here, the JUMP instruction is used similar to x86's ret instruction, to resume execution at a "return address" that the caller pushed on the stack before the function call.To address this, TEETHER uses backward slicing to iteratively reconstruct the CFG. This process is repeated until no new edges are found and all jump instructions marked as resolved.In the example in Figure 5, two backward slices can be found for the JUMP instruction at address 19, (PUSH1 0b) and (PUSH1 15), which allows to introduce two out-edges for basic block 17, 17 → b and 17 → 15. The resulting CFG is then scanned for CALL, CALLCODE, DELEGATECALL, and SELFDESTRUCT instructions. As we require that this argument is potentially attacker controlled, slices are then filtered for those containing instructions whose results can be directly (ORIGIN, CALLER, CALLVALUE, CALLDATALOAD, CALLDATASIZE, CALLDATACOPY) or indirectly (SLOAD, MLOAD) controlled by an attacker.Each of the remaining slices defines an instruction subsequence of a critical path. As a state change can be useful for an attacker even without controlling the address or value written (e.g., Figure 3), no backward slices need to be computed in this case. Fixed-size elements, such as the call value or the caller's address are modelled using fixed-size bitvector expressions, variable-length elements, such as the call data, the memory, and the storage are modeled using Z3's array expressions.Whenever a conditional branch (JUMPI) is encountered whose condition µ s [1] is a symbolic expression, both the jump target and the fall through target are compared to the next address defined by the given path, and a new constraint of the form µ s [1] = 0 respectively µ s [1] = 0 is added accordingly. However, when executing this1 int x = 0; 2 if(msg.value > 0){ 3 x = 1; 4 } 5 if(x! sender.transfer(this.balance); 7 } Figure 6: Infeasible Paths Example path, the value of x at line 5 will always be a concrete value and, since the path skipped the assignment in line 3, will have value 0. Since such mappings are a common data structure in Ethereum contracts, TEETHER needs to be able to reason about such storage accesses, which requires a symbolic modeling of the SHA3 instruction.To this end, whenever we want to symbolically execute a SHA3 instruction, we introduce a new symbolic 256-bit variable to model the result of the Keccak-256 computation. We will later show in Section 4.5.1 how this mapping can be used to solve path constraints which include hash-dependent constraints. For example, the SHA3 instruction can compute hashes over variable length data. Similarly to mapping of Keccak-256 results to their respective input data, we also keep a mapping from symbolic read objects to their address, their length, and the memory-state when the read occurs. The final output of the constraint generation module for a given path p is a tuple R p = (µ, S, I,C, H, M), where µ is the symbolic machine state after execution S is the symbolic storage of the contract after execution I is the symbolic environment in which path p is executed C is a set of constraints that must be fulfilled to execute path p H is a mapping of Keccak-256 result variables to their respective input data M is a mapping of symbolic read objects to their address, length, and memory state We assume that both µ and S also capture the entire history of the respective states after every instruction. Let µ 0 and S 0 denote the initial state of a path, then R v = ( µ, S, I,C, H, M), whereµ = µ p 0 , . . . , µ p n S = S p 0 , . . . , S p n I = I p 0 , . . . , I p n C = n i=0 C p i ∪ n−1 i=0 {S p i+1 0 = S p i } ∪ {S p 0 0 = ˆ S} H = n i=0 H p i M = n i=0 M p iNote the introduction of additional constraints S p i+1 0 = S p i and S p 0 0 = ˆ S, which encode that the state changes performed by path p i , are still present at the beginning of path p i+1 . Otherwise, the next path sequence is requested and tested.Before checking satisfiability of a combined result, we first encode the attacker's goals using additional constraints. As value is specified by the third stack argument to CALL, formally this givesµ * s [2] > n ∑ i=0 I p i v Having assembled the combined path constraints of a path sequence, including their state inter-dependencies and the attacker's goals, the next step is to find a satisfying assignment, which will give us concrete values to build the transactions required for successful exploitation. This process is repeated until all variables are resolved.Q ← H ∪ M A ← / 0 while Q > 0 do D ← {c ∈ C|Vars(c) ∩ Q = / 0} A ← Sat(D) for all x ∈ Q do if x ∈ H then e ← H[x] if e ∩ Q = / 0 then v e ← A(e) v x ← Keccak-256(v e ) C ← C ∪ {e = v e , x = v x } Q ← Q \ {x} end if else if x ∈ M then a, l, µ m ← M[x] if (Vars(a) ∪ Vars(l)) ∩ Q = / 0 then v a ← A(a) v l ← A(l) v x ← A(µ m [v a : v a + v l ]) C ← C ∪ {a = v a , l = v l , x = v x } Q ← Q \ {x}The key insight here is that, since the mappings H and M define dependencies between the elements of H and M and the variables involved in their corresponding expressions, they also implicitly define a topological ordering on H and M. Furthermore, as these mappings can never define a cycle, this ordering is well-defined. Consider, for example, the Solidity statement sha3(sha3(msg.sender)) which takes the address of the message sender and hashes it twice. Using a snapshot from Nov 30 2017, we found a total of 784,344 contracts. Removing duplicates left us with a total number of 38,757 unique contracts. To avoid the situation that our code analysis gets stuck too long in a single contract, we allowed up to 30 minutes for CFG reconstruction plus 30 minutes for finding each a CALL, CALLCODE, DELEGATECALL, and SELFDESTRUCT-based exploit. While some of these can be false negatives due to TEETHER's limitations, like the restricting the transaction sequences to maximum three, or limitations of the underlying constraint solver, we believe the majority of these cases are actually true negatives, as our definition of critical paths is broad. 134 (24.50%) of the 547 CALL-based exploits and 57 (19.13%) of the 298 SELFDESTRUCT-based exploits are dependent, leaving 413 respectively 241 independent exploits. We thus modeled an attack on the actual blockchain as close as possible.Since every contract account has its own storage that can influence the execution, we validate every exploit against every affected account individually, leading to a total of 1,769 (exploit, account) combinations. The network is then run using the unmodified official Ethereum Go client [5], whose scripting interface will also be used to submit the exploit transactions.To reduce computation time by allowing tests on several non-unique contracts at once, we computed the exploit assuming that the contract's storage was set to zero. Unfortunately, creating an updated exploit fails for 84 (5.71%) of the CALLbased and 28 (9.69%) of the SELFDESTRUCT-based exploits, which means that the generated exploit was a false positive. Overall, a large fraction (88.41%) of the generated exploits works as expected: Once all exploit transactions have been processed, the attacker has successfully stolen Ether and increased their own balance.Overall, 205 exploits (11.59%) failed for mainly two reasons. As mentioned earlier, 112 (6.33%) of all exploits failed in the update stage due to the mismatch in storage between the initial exploit generation and the exploit re-computation on the actual storage contents. For example, one of the 44 contracts implements a betting functionality with a dedicated function to handle a draw. However, as Solidity does not provide a special keyword to mark the constructor, functions that were meant to be constructors can become regular functions due to ignoring case-sensitivity, spelling mistakes, or oversight during refactoring operations such as renaming. For example, these contracts seemingly confuse the contract's total balance (this.balance) with the value held by the current transaction (msg.value). Contrary to the intended behaviour, this allows all marked functions to be called by anyone but the owner.Interestingly, the first three of these categories can be almost exclusively attributed to Solidity. The inclusion of SLOAD and MLOAD into the potentially attacker-controlled instructions makes this criterion apply to many paths, even though the corresponding storage or memory locations may never be writable by an attacker. For example, the bug in Parity's multi-signature wallet [6] that allowed an attacker to take over multiple wallets, splits core functionality between two contracts. As described in Section 5, our evaluation initializes the contract's storage to an empty state when we start searching for exploits. This allows us to combine the analysis of contracts that share the same code, reducing the number of tool runs from 784,344 to only 38,757 and has reduced the overall runtime by roughly factor 20. In a similar vein to the work present herein, Luu et al. [20] presented OYENTE, a tool to detect certain vulnerabilities like transactionordering dependence or reentrancy. Validation is then often as easy as executing the exploit transactions and checking the final balance.Atzei et al. [7] provide a survey on attacks against Ethereum smart contracts, giving a taxonomy and discussing attacks and flaws that have been observed in the wild. For example, the multiplayer games attack described in their paper can also be identified and be exploited by our tool-fully automated.In an effort to support further vulnerability analyses, Matt Suiche has proposed a decompiler [24]. Also, Zhou et al. [26] developed Erays, a tool for reverse engineering smart contracts able to produce high-level pseudocode from compiled EVM code. Huang et al. [17] extends the considered attack surface by including the operating system and libraries a compiled binary uses at runtime, and work by Hu et al. [16] considers non-control-flow hijacking exploits by modelling data-oriented exploits.While all of these share the general idea of symbolic execution, constraint generation, and resolution to generate an exploit-as does the work presented hereinthere are major differences. In a large-scale analysis encompassing 38,757 contracts from the Ethereum blockchain, TEETHER identified 815 as vulnerable. Furthermore, this project has received funding from the European Union's Horizon 2020 research and innovation programme under grant agreement No 700176 ("SISSDEN").