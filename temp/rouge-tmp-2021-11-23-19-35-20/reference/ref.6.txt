To do so with high fidelity, we develop novel techniques to determine the physical address mapping in DRAM modules at runtime (to improve the effectiveness of double-sided row hammer attacks), methods to exhaustively hammer a large fraction of physical memory from a guest VM (to collect exploitable vulnerable bits), and innovative approaches to break Xen paravirtualized memory isolation (to access arbitrary physical memory of the shared machine). Our study also suggests that the demonstrated row hammer attacks are applicable in modern public clouds where Xen par-avirtualization technology is adopted. In particular, [23] has demonstrated that malicious programs may issue specially crafted memory access patterns, e.g., repeated and rapid activation of the same DRAM rows, to increase the chances of causing a disturbance error in neighboring rows.Row hammer vulnerabilities have been exploited in security attacks shortly after its discovery [4,10,16,20]. Other studies [10,16,20] aim to conduct row hammer attacks from high-level programming languages, e.g., JavaScript, so that an adversary can induce memory errors and escalate privileges remotely, by injecting malicious JavaScript code into the target's web traffic (e.g., by hosting malicious websites, cross-site scripting, man-in-the-middle attacks, etc.). Conducting such attacks, however, requires knowledge of the physical memory mapping in DRAMs (i.e., bits in physical addresses that determine memory channels, DIMMs, ranks, banks, and rows). Therefore, by alternately accessing two rows in the same bank, we expect a higher memory access latency due to row buffer conflicts. Building on the timing-channel primitive, we developed a novel graph-based algorithm which models each bit in a physical address as a node in a graph and establishes relationships between nodes using memory access latency. Unlike prior work, which sprays large numbers of page tables and conducts random row hammer attacks hoping that bit flips will occur in a page table entry (PTE) [4], in our approach (Section 5), we use hypercalls to map page directories in the OS kernel of our own VM to physical pages containing memory cells that are vulnerable to row hammer attacks. In the context of this paper, we call such attack techniques page table replacement attacks to indicate that the original page table has been replaced with a forged one. • A novel page table replacement technique that allows a malicious guest VM to have read and write accesses to arbitrary physical pages on the shared machine. We will then describe a novel graph-based algorithm for detecting physical address mapping in DRAMs (Section 3). We then present a few technical details in our row hammer attack implementation (Section 4) and a page table replacement attack that enables arbitrary cross-VM memory accesses (Section 5). Each bank has a row buffer to store the last accessed row in that bank. In addition to the cells dedicated for data storage, DRAM chips often include additional storage for ECC (error-correction codes) or parity bits, to enable detection and/or correction of errors in the data array.DRAM Refresh. DRAM chips maintain a row counter to keep track of the last row that was refreshed -this row counter is used to determine the rows that must be refreshed next.DRAM address mapping. Concurrently to our work, Pessl et al. [29] proposed methods to reverse-engineer physical address mapping in DRAM on both Intel and ARM platforms. Unlike our work, brute-force approaches were taken to (1) collect sets of memory addresses that are mapped to the same banks by randomly selecting addresses from a large memory pool and conducting the timing-based tests to cluster them, and (2) to determine the XOR-schemes (see Section 3) that are used by memory controllers, by testing all possible combinations of XOR-schemes against all sets of addresses.The advantage of their approach over ours is that it exhaustively searches XOR-schemes without the need to reason about the complex logic behind them, as is done in our paper. Independent of Intel's effort, Kim et al. [23] also reported that random bit flips can be observed by specially crafted memory access patterns induced by software programs.The first practical row hammer exploit was published by Seaborn from Google [4], who demonstrated privilege escalation attacks exploiting row hammer vulnerabilities to break the sandbox of Google's NaCl, and to obtain kernel memory accesses from userspace programs running on Linux operating systems. Particularly, Kim et al. [22] proposes Counter-Based Row Activation (CRA) and Probabilistic Row Activation (PRA) to address row hammer vulnerabilities. Prior work [4] has indicated that double-sided row hammer attacks are much more effective than single-sided ones. More precisely, we hope to determine which bits in a physical address specify its mapping to DRAM banks, rows and columns.This information, however, is not available in the system configuration or in the memory controller or DRAM datasheets. When two memory addresses mapped to the same DRAM bank in different rows are alternatively accessed in rapid succession, the accesses will be delayed due to conflicts in the row buffer (and subsequent eviction and reload of the row buffer). LATENCY() randomly selects 100 pairs 1 of memory addresses from a large memory buffer, so that each pair of addresses differs only in the bit positions that are specified by the input, I: in each pair, one address has '1's at all these bit The algorithm enumerates each pair of addresses by measuring the average access latency to read each address once from memory. The algorithm returns 1 (high) or 0 (low) to indicate the latency of memory accesses. In the following discussion, we use b i to refer to an address bit position and a node interchangeably.Our bit detection algorithms works under the assumption that Intel's DRAM address mapping algorithms may use XOR-schemes to combine multiple bits in physical addresses to determine one of the bank bits. It means that when accessing two addresses that differ only in a bit in C and a bit in R, we experience high latency in the LATENCY() test-indicating that the two addresses are in the same bank but different rows. The bits in C are in fact column bits that determine which column in a row the address is mapped to.Detecting bank bits in a single XOR-scheme. Particularly in Figure 2c, i = 18, j = 20, k = 15, l = 16 i , b j }) = 1. If none of the three edges exist in graph G 1 -the graph we constructed in the single-XOR-scheme-bit detection-it means these three nodes are involved in two XOR-schemes b i ⊕ b j and b i ⊕ b m : if two addresses differ in only two bits (out of the three), at least one of these two XOR-schemes will specify a different bank index; however, if two addresses differ in all three bits, the outcome of both XOR-schemes are the same for the two addresses, so they are in the same bank. If a bit is involved in more than two XOR-schemes, we can extend the method for detecting two XOR-schemes to detect it. Particularly, on the subset of nodes V − R − C, we enumerate all combination of four bits and look for LATENCY({b i , b j , b k , b l }) = 1, which, following the reasoning steps in the prior paragraph, suggests that one of the bits is involved in three XOR-schemes. As will be discussed in Section 5, only bit flips at certain positions within a 64-bit memory block can be exploited; also, only a fraction of them are repeatable in row hammer attacks (we will empirically evaluate the fraction of vulnerable bits that are both exploitable and repeatable in Section 6.2.3). To enumerate as many DRAM rows as possible to look for vulnerable bits, we developed the following data structure and algorithm to conduct double-sided row hammer attacks on every row in every bank: Especially, as will be shown later in Table 1, some of the 12 least significant address bits are bank bits, which means the same 4KB memory page are not always mapped to the same row. For example, on a Sandy Bridge processor with 2 memory channels, 1 DIMM per channel, 1 rank per DIMM, and 8 banks per rank (totally 4GB memory), there are 2 4 = 16 elements (i.e., 2 × 8 banks) in the first dimension, 2 16 = 65536 elements (i.e., number of rows per bank) in the second dimension, 2 7 = 128 elements (i.e., number of memory units per row) in the third dimension.Another observation we had for conducting efficient row hammer attacks is to avoid hammering on rows in sequential order. Even in public clouds, we found that rebooting the guest VMs will relaunch the VM on the same host, and possibly assigned to different (but largely overlapping) physical memory. To safely conduct row hammer attacks without crashing the co-located VMs and the host machine, we optionally conduct the row hammer attacks in a safe mode: In Figure 5, only when we control all memory units in row n, n + 2 and n − 2 do we conduct the doublesided row hammer attacks on row n + 1 and n − 1. To be compatible with native OS kernels, a paravirtualized OS kernel (e.g., already a part of mainstream Linux kernel) maintains a contiguous pseudo-physical memory address space; the mapping between pseudo-physical memory addresses and virtual addresses are maintained at page-granularity, following the same semantic as its non-virtualized counterparts. The mapping between each VM's pseudo-physical memory pages to machine memory pages is also kept in the hypervisor, but guest VMs are allowed to query the mapping information by issuing hypercalls (e.g., HYPERVISOR memory op()). To enable security isolation, the Xen hypervisor keeps track of the type of each memory page: page tables, segment descriptor page and writable pages. Instead of relying on an unreliable trial-anderror approach used in prior studies [4,20], in which a large number of page tables are sprayed to increase the chances of bit flips taking place in PTEs, we propose a novel approach that, given a set of DRAM bit flips that an attacker could repeatedly induce, deterministically exploits the repeatable bit flips and gains access to physical memory pages of other VMs or even the hypervisor.To access the entire machine address space with both read and write permissions, the attacker VM could do so by modifying a page table entry within its own VM so that the corresponding virtual address could be translated to a machine address belonging to other VMs or the hypervisor. We propose a novel attack that achieves this goal by replacing the entire page tables in a guest VM without issuing hypercalls, which we call the page table replacement attacks.For the convenience of discussion, we first define the following primitives:• Addr(v) returns the machine address of a vulnerable bit. • Virt(p) returns the virtual address of the beginning of a page p.• Differ(P 1 , P 2 ) returns a set of indices of bits in which the machine addresses of two memory pages P 1 and P 2 differ.Specially, when the vulnerable bit v satisfies Position(v) ∈ [12, M], where M is the highest bit of the physical addresses on the target machine, the attacker could exploit the flippable bit to replace an existing page table with a carefully-crafted page table containing entries pointing to physical pages external to the guest VM via the following steps (Figure 8): • Step 1: In the attacker's VM, allocate and map one virtual memory page (denoted p), so that the vulnerable bit v has the same page offset as one of the PFN bits in p's corresponding PDE. • Step 2: In guest kernel space, select two physical pages, P 1 and P 2 , where Differ(P 1 , P 2 ) = {Position(v)} and Position(v) of P 1 is the original state of the vulnerable bit (e.g., 0 if Direction(v) = 0 → 1). The attacker can also modify the PTEs in P 2 without issuing hypercalls as he has the write privilege on this forged page table.Theoretically, (52 − 12)/64 = 62.5% vulnerable bits can be exploited in page table replacement attacks, regardless of flippable directions. For instance, on a machine equipped with an Intel Westmere processor, Xeon E5620, and one DRAM chip (with 2 memory channels, 1 DIMM, 2 ranks, 8 banks, and 2 15 rows per bank), we ran our algorithm and found the bits that determine bank indices are b 6 ⊕ b 16 , b 13 , b 14 , b 20 , b 21 , and the bits that determine row indices are bits b 16 to b 19 , and bits b 22 to b 32 (totally 15 bits). Results for five local machines (Intel Sandy Bridge Core i3-2120 with 4GB memory, Intel Broadwell Core i5-5300U with 8GB memory, Intel Westmere Xeon E5620 with 4GB memory, Intel Haswell Xeon E5-2640 v3 with 32GB memory, and Intel Haswell Xeon E5-1607 v3 with 16GB memory) and three cloud machines (one machine in Cloudlab, Emulab d820, with 128GB memory, and two machines on Amazon EC2, one c1.medium instance and one c3.large instance, total memory size unknown) are shown in Figure 9. Second, we conducted double-sided row hammer attacks on some of the local machines we have in our lab: Machine Particularly on each of these machines, we indexed each row of the same bank from 1 to 2 k , where k is the number of detected row bits; the index of a row is given by the value presented by all row bits in the same order as they are in the physical address. The second machine is another desktop with a 3.7GHz Intel Core i5-2500 processor and 4GB of memory. To show that our double-sided row hammer attacks are more effective than single-sided versions, we empirically test how fast each method can induce memory bit flips.In addition, we also tested with row hammer code both with and without mfence to empirically evaluate the effectiveness of the two types of attack techniques Particularly, we implemented four types of row hammer attack tools: double-sided row hammer without mfence instruction, double-sided row hammer with mfence, single-sided row hammer without mfence, and single-sided row hammer with mfence. In Figure 12, we show the number of bit flips induced per hour by one of these approaches on four machines: Machine A, Sandy Bridge i3-2120, Machine B, Sandy Bridge Table 2). The results are shown in Figure 13a: 36.5%, 31.9%, 32.8%, 40.0% of these bits are in the PFN range of a page table entry, thus are usable in page table replacement attacks.Prior studies [23] have shown that many of the bit flips are repeatable. Particularly, we found 95904 single-bit errors, 4013 two-bit errors, 112 three-bit errors and 2 four-bit errors in the same 64-bit block. Particularly, we demonstrated the power of the cross-VM row hammer attacks in two examples: In the first example, we demonstrated a confidentiality attack where the adversary exploited the techniques to steal TLS private keys from an Apache web server; in the second example, we showed an integrity attack, in which the attacker altered the program code of an OpenSSH server to bypass the user authentication and logged in the server without knowledge of credentials.Arbitrary memory accesses. The attacker VM conducted the cross-VM row hammer attacks described above to obtain read access to the physical memory owned by the victim VM. If the adversary is lucky enough to successfully guess the machine address of the target memory page in the first trial, the average time to complete the attack was 0.32s (including the time to manipulate page tables, conduct row hammer attacks to induce the desired bit flip, read the memory page and check the validity of the private key, and write the extracted key to files). The signature can be extracted from offline binary disassembling as we assume the binary code of the OpenSSH server is also available to the adversary.Once the signature was found, the adversary immediately replaced a five-byte instruction "0xe8 0x1b 0x74 0xfd 0xff" (binary code for "callq pam authenticate") with another five-byte instruction "0xb8 0x00 0x00 0x00 0x00" (binary code for "mov $0 %eax"). If the target physical page is the first to be examined by the adversary, the average time to complete the attack was 0.322s, which included the time to manipulate page tables, conduct row hammer attacks to induce the desired bit flip, search the target page for specific patterns, and inject code in the target memory. cloud instance types Amazon EC2 [7] t1, m1, m2, m3, c1, c3, hi1, hs1Rackspace [28] General purpose, Standard Single/Multi-tenant Virtual Server Cloudlab d430, d810, d820, C220M4, C220M4, c8220(x), r320, dl360 In this section, we discuss the existing software and hardware countermeasures against the demonstrated cross-VM row hammer attacks.Row hammer resistance with hardware-assisted virtualization. Particularly, VT-x employs Extended Page Tables and AMD-V introduces Nested Page Tables [1] to accelerate the processor's accesses to two layers of page tables, one controlled by the guest VM and the other controlled by the hypervisor. Particularly, if the true physical address of an extremely vulnerable rows is known to the adversary, hammering around this specific row will greatly increase the adver- In conclusion, we explored in this paper row hammer attacks in the cross-VM settings, and successfully demonstrated software attacks that exploit row hammer vulnerabilities to break memory isolation in virtualization. The high-level takeaway message from this paper can be summarized as: (1) Row hammer attacks can be constructed to effectively induce bit flips in vulnerable memory chips, and (2) cross-VM exploitation of row hammer vulnerabilities enables a wide range of security attacks.