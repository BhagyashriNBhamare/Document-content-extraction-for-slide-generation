Unlike previous efforts, we demonstrate that AuthentiCall can be used to provide strong authentica-tion before calls are answered, allowing users to ignore calls claiming a particular Caller ID that are unable or unwilling to provide proof of that assertion. Unlike the web, where mechanisms such as TLS protect data integrity and allow experts to reason about the identity of a website, the modern telephony infrastructure simply provides no means for anyone to reason about either of these properties.In this paper, we present AuthentiCall, a system designed to provide end-to-end guarantees of authentication and call content integrity over modern phone systems (e.g., landline, cellular, or VoIP). Most critically, AuthentiCall provides these guarantees for standard telephone calls without requiring changes to any core network.Our work makes the following contributions: • Designs Channel Binding and Authentication Protocols: We design protocols that bind identities to phone numbers, mutually authenticate both parties of a phone call, and protect call content in transit. The remainder of this paper is organized as follows: Section 2 provides background information about the challenges underlying authentication in telephony networks; Section 3 describes our assumptions about adversaries and our security model in detail; Section 4 gives a formal specification of the AuthentiCall system; Section 5 discusses how analog speech digests can be used to achieve call content integrity; Section 6 provides details of the implementation of our system; Section 7 shows the results of our experiments; Section 8 offers additional discussion; Section 9 analyzes related work; and Section 10 provides concluding remarks. VoIP phones naturally have a secondary data channel, the majority of mobile phones allow users to both talk and use data networks simultaneously, and even some circuitswitched connections (e.g., ISDN) provide phones with a data connection. Given that the bitwise encoding of audio is unlikely to be the same at each endpoint, end-to-end encryption is not a viable means of protecting call content or integrity across the heterogeneous telephony landscape. Moreover, while we argue that the majority of phones have access to at least a low-bandwidth data connection, solutions that demand high-speed data access at all times (i.e., pure VoIP calls) do not offer solutions for the vast majority of calls (i.e., cellular calls). These are the Enrollment, Handshake, and Call Integrity protocols.These protocols make use of certificates issued to each client that indicate that a particular client controls a specific phone number. This PKI would issue an authoritative certificate that a phone number is owned by a particular entity, and AuthentiCall could enforce that calls take place between the entities specified in those certificates. (1)Data Channel Audio Channel N N et , ID(C), PhNum(C), ID(S CA ), PhNum(S CA ), T S ID(C), PhNum(C), ID(SCA), K + C NAudio NAudio, NNet, ID(C), PhNum(C)ID(SCA), TS, Sign k 񮽙 C Cert(ID(C), PhNum(C), K + C , Sign K 񮽙 S CA ) (2) (3) (4)(5)Figure 3: Our enrollment protocol confirms phone number ownership and issues a certificate. In message 2, the server sends a nonce N Net , the identities of C and S CA and the phone numbers of C and S CA with a timestamp to ensure freshness, liveness, and to provide a "token" for this particular authentication session.In message 3, the server begins to confirm that C controls the phone number it claims. While the protocol is secure in the presence of passive adversaries on both the data and voice networks, if an adversary can actively intercept a call addressed to a victim phone number (and also supply any out-of-band identity confirmation), they may be able to obtain a certificate for a number they illicitly control. The caller places a voice call over the telephone network while simultaneously using a data connection to conduct the handshake protocol.The handshake protocol consists of two phases. (1) Call PhNum(E) E 2 AuthentiCall Users Incoming call from R ID(E), PhNum(E), ID(R), PhNum(R) Cert(E), TS2, NE, DHE, Sign K 񮽙 E HMACK ER1 (msg 4a , msg 4b , "Caller") HMACK ER2 (msg 4a , msg 4b , "Callee") Server (S) Caller (R) Callee (E) (2) (3) (4a) (4b) (5a) (5b)TLS to Server Voice Call Message via Server TLS ID(R), PhNum(R), ID(E), PhNum(E) Cert(R), TS1, NR, DHR, Sign K 񮽙 R Figure 4: Our handshake protocol mutually authenticates both parties.connected to S via TLS, meaning S has properly authenticated itself to C. They can be computed independently and sent in parallel, reducing round trip latencies.Message 4 contains all information necessary for a Diffie-Hellman key establishment authenticated with a signature key defined in the certificate of R or E. Each side also provides a Diffie-Hellman share, and the entire message is signed with the public key in the certificate issued by AuthentiCall.After message 4, both sides combine their DiffieHellman secret with the share they received to generate the derived secret. 4 These messages areServer (S) Caller (R) Callee (E) (0a) (0b) (1a)(1b)Voice Call Message via Server TLS "Call Ended", TS3, ID(R), ID(E)HMACK ER (ID(R), ID(E), TS3, "Call Ended") (Na) (Nb) "Call Ended", TS4, ID(E), ID(R) HMACK ER (ID(E), ID(R), TS4, "Call Ended"). . . . . ."Call Connected", TS1, ID(R), ID(E) HMACK ER (ID(R), ID(E), TS1, "Call Connected") "Call Connected", TS2, ID(E), ID(R) HMACK ER (ID(E), ID(R), TS2, "Call Connected") EncK ER (Index, Audio Digest 1 , AuD2...AuD5),HMACER(EncK ER (P receding))EncK ER (Index, Audio Digest 1 , AuD2...AuD5),HMACER(EncK ER (P receding))Figure 5: Our call integrity protocol protects all speech content.designed to prevent attacks where a call is redirected to another phone. In order to prevent redirection attacks, the messages are bound to the identities of the communicating parties by including the IDs in the HMACs and by using keys for the HMACs that are unique to the call.When the voice call ends, each side sends a "call concluded" message containing the client IDs, a timestamp, and their HMAC. Unlike cryptographic hashes, which change drastically with small changes in input, robust hashes give very similar outputs for similar inputs. This means that common data digest approaches like cryptographic hashes will fail.While the original phone system used analog transmission of voice, it is now common in every telephone network (landline, VoIP, cellular, etc.) for speech to be digitized and compressed using an audio codec. The following subsections provide a description of the speech digests we use in AuthentiCall and a thorough analysis of the performance of these digests for telephone calls. Finally, to our knowledge we are the first to use any robust speech digest for an authentication and integrity scheme.For space reasons, and because we do not claim the design of the RSH digest as a research contribution, we provide a detailed description of the actual computation of an RSH digest in Appendix A. However, the remainder of this subsection will provide details necessary for the rest of this paper. We also describe how we use digests to detect tampered audio.We implement RSH using Matlab, and we deploy it in our AuthentiCall prototype by using the Matlab Coder toolbox to generate C code that is compiled as an Android native code library. To test robustness, we generate modified audio from the TIMIT corpus and compare the BER of digests of standard TIMIT audio to digests of degraded audio. We see higher error rates caused by the use of audio codecs like GSM-FR and AMR-NB; these codecs significantly alter the frequency content of the audio. The expected bit error for two random bit strings is 50%, and the mean seen for RSH bit error is close to the optimal, best possible distance between two adversarial digests.Because the TIMIT corpus contains speakers speaking several identical sentences, we can investigate the resilience of the digest to more specific adversarial scenarios in two important ways. The tradeoff is best depicted in a ROC curve in tive tradeoff measured on the adversarial audio and two legitimate modifications -GSM encoding and a combination of GSM, AMR-NB, 5% frame loss, 10ms delay, and 30dB of white noise. This corresponds to an individual adversary audio true positive detection rate of 0.90, while presenting a 0.0058 false positive rate against our "worst-case" audio and a 0.00089 false positive rate against clean GSM-FR encoded audio. The average British mobile phone user only places 176 minutes per month of outbound calls [65]; assuming inbound and outbound talk time are roughly equal, the average user only places 70.4 hours of calls per year. Also, since our digests depend on the semantic call content, changes to the structure of a sentence (and not necessary audible voice) would alert the user. Google Cloud Messaging (GCM) is used to generate a push notification to inform clients of incoming calls.Client: Our prototype AuthentiCall client consists of an Android app, though we anticipate that in the future AuthentiCall will be available for all telephony platforms, including smartphones, VoIP phones, PBXs, and even landlines (with additional hardware similar in concept to legacy Caller ID devices that uses a wireless or wired LAN data connection). This consists of a user's claimed identity, phone number, validity, public key and signature of the CA.Audio Nonces: As described in Section 4, the AuthentiCall enrollment protocol sends a nonce through the voice channel to ensure that an client can receive a voice call. The enrollment and handshake experiments were carried out 20 times over both WiFi and 3G, and digest exchange 5 Dual-Tone Multi-Frequency tones are the sounds made by dialing digits on a touch-tone phone. As shown in Figure 10, AuthentiCall only adds 1.07 seconds for WiFi or 1.41 seconds on 3G data to the total call establishment time (error bars indicate standard error). In these 10 calls, we play 10 sentences from 10 randomly selected speakers in the TIMIT corpus through the call, and our AuthentiCall implementation computed the sent and received digests. Using our 3-out-of-5 standard, we saw no five-second frames that were marked as tampered.While our individual hash performance false positive rate of 4.5% was low, we were surprised that the performance differed from our earlier evaluation on simulated degradations. One option would be to digest audio after compression for transmission (our prototype uses the raw audio from the microphone); such a scheme would reduce false positives partially caused by known-good transformation of audio. AuthentiCall offers a strong method to authenticate users over the phone, increasing security while reducing the authentication time and effort.Another valuable use case is emergency services, which have faced "swatting" calls that endanger the lives of first responders [73] as well as denial of service attacks that have made it impossible for legitimate callers to receive help [8]. In particular, the average time to send one SMS message is 6.4 seconds [53], meaning that AuthentiCall using SMS would require a minimum of 38.4 seconds -effectively increasing call setup time by a factor of 5. In the case of the former, researchers have explored a wide range of solutions: blacklists of phone numbers [6,44,52], call-back verification [47], channel characterization [57], call data analysis [35,45,48,58], carrier level ID extraction [68], timing [47], call provenance [17], name registries [22] and biometrics [14,19,27,37]. This protocol is not end-to-end (so the protocol is vulnerable to malicious network endpoints like IMSI-catchers [23,24]), requires both endpoints to call from an SS7-speaking network, and most importantly would also require modifying core network entities throughout every network.The solution closest to our own is Authloop [56]. In this appendix, we describe the construction of the RSH digest used by AuthentiCall for channel binding and content integrity.There are a number of constructions of speech digests, and they all use the following basic process. The construction also selects audio probabilistically; we show in Appendix B that the digest indeed protects all of the semantic content in the input audio. In RSH, the input audio is grouped into 30ms frames with 25ms audio overlap between frames, and 10 line spectral frequencies are computed for each frame to create a matrix L. Set eight digest bits by whether the corresponding coefficients of the first block (B 1 ) are greater than the coefficients of the second block (B 2 ). We note that sections of audio are selected probabilistically; we show in Appendix B that the probability that a section of audio is not used in a digest is negligible.An important consideration is to note that the digest is keyed. This is less than an individual phoneme, could not change semantic meaning of the audio, and losses of 25 milliseconds or more are common in audio transmission and typically go unnoticed by users. We begin by computing the probability that in any particular trial, the r-th row is not covered by at least one of the two blocks B 1 , B 2 used in the robust hashing algorithm. To build some intuition for these probabilities, take N = 200 and w = 51 (the average value if w were selected uniformly from its range), Pr X (i) 1 = 0 ≤ 0.98, i.e., the first row is almost certainly not covered in any particular trial.