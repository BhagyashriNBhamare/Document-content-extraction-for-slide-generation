To mitigate remote timing and cache-timing attacks, many ubiquitous cryptography software libraries feature constant-time implementations of cryptographic primitives. As far as we are aware, this is the first timing attack against OpenSSL EC-DSA that does not target scalar multiplication, the first side-channel attack on cryptosystems leveraging P-256 constant-time scalar multiplication and furthermore, we extend our attack to TLS and SSH protocols, both linked to OpenSSL for P-256 ECDSA signing. Our spy program probes relevant memory addresses to create a timing signal trace, then the signal is processed and converted into a sequence of right-shift and subtraction (LS) operations corresponding to the BEEA execution state from which we extract bits of information to create a lattice problem. This new approach allows us to accurately find the best candidate memory addresses to slow the modular inversion by an average factor of 18, giving a high resolution trace and allowing us to extract the needed bits of information from all of the traces.Unlike previous works targeting the wNAF scalar multiplication code path (for curves such as BitCoin's secp256k1) or performing theoretical side-channel analysis of the BEEA, we are the first to demonstrate a practical cache-timing attack against the BEEA modular inversion, and furthermore OpenSSL's ECDSA signing implementation with constant-time P-256 scalar multiplication.Our contributions in this work include the following:• We identify a bug in OpenSSL that allows a cache-timing attack on ECDSA signatures, despite constant-time P-256 scalar multiplication. (Section 4.3) • We describe how to combine the FLUSH+RELOAD technique with the improved performance degradation attack to recover side-channel traces and algorithm state from the BEEA execution. Elliptic Curve Cryptography (ECC) became popular mainly for two important reasons: no sub-exponential time algorithm to solve the elliptic curve discrete logarithm problem is known for well-chosen parameters and it operates in the group of points on an elliptic curve, compared to the classic multiplicative group of a finite field, thus allowing the use of smaller parameters to achieve the same security levels-consequently smaller keys and signatures.Although there are more general forms of elliptic curves, for the purposes of this paper we restrict to short Weierstrass curves over prime fields. Parameters: A generator G ∈ E of an elliptic curve group of prime order n and an approved hash function h (e.g. SHA-1, SHA-256, SHA-512). Using her private-public key pair (α A , D A ), Alice performs the following steps:1. Alice sends (m, r, s) to Bob.Verifying: Bob wants to be sure the message he received comes from Alice-a valid ECDSA signature gives strong evidence of authenticity. Thanks to the adoption of ECC and the increasing use of digital signatures, ECDSA has become a popular algorithm choice for digital signatures. They use the EVICT+RELOAD strategy and an L1 data cache-timing attack to recover the LSBs of ECDSA nonces from the library's wNAF (a popular lowweight signed-digit representation) scalar multiplication implementation in OpenSSL 0.9.8k. After collecting 2,600 signatures (8K with noise) from the dgst command line tool and using the Howgrave-Graham and Smart [15] lattice attack, the authors recover a 160-bit ECDSA private key from standardized curve secp160r1.Brumley and Tuveri [7] attack ECDSA with binary curves in OpenSSL 0.9.8o. Mounting a remote timing attack, the authors show the library's Montgomery Ladder scalar multiplication implementation leaks timing information on the MSBs of the nonce used and after collecting that information over 8,000 TLS handshakes a 162-bit NIST B-163 private key can be recovered with lattice methods.Benger et al. [4] target OpenSSL's wNAF implementation and 256-bit private keys for the standardized GLV curve [11] secp256k1 used in the BitCoin protocol. Leveraging the structure of the modulus n, the authors use more information leaked in consecutive sequences of bits anywhere in the top half of the nonces, allowing them to recover the secret key after observing as few as 25 ECDSA signatures.Allan et al.[2] improve on previous results by using a performance-degradation attack to amplify the sidechannel. Fan et al. [10] increase the information extracted from each signature by analyzing the wNAF implementation in OpenSSL. The latency measured in the last step tells whether or not the memory line was accessed by the victim during the second step of the attack, i.e. identifies cache-hits and cache-misses. A well known algorithm used for modular inversion is the Euclidean Extended Algorithm and in practice is often substituted by a variant called the Binary Extended Euclidean Algorithm (BEEA) [18, Chap. Additionally, in the very first iteration only the u while-loop can be executed since v is a copy of p which is a large prime integer n for ECDSA.Output: k −1 mod p. v ← p, u ← k, X ← 1, Y ← 0 while u = 0 do while even(u) do u ← u/2 /* u loop */ if odd(X) then X ← X + p X ← X/2 while even(v) do v ← v/2 /* v loop */ if odd(Y ) then Y ← Y + p Y ← Y /2 if u ≥ v then u ← u − v X ← X −Y else v ← v − u Y ← Y − X return Y mod pIn 2007, independent research done by Aciiçmez et al. [1], Aravamuthan and Thumparthy [3] demonstrated side-channel attacks against the BEEA. As a response, Cabrera Aldaya et al. [8] demonstrated a Simple Power Analysis (SPA) attack against a custom implementation of the BEEA. To understand the nature of this vulnerability and facilitate root cause analysis, in this section we give a brief overview of side-channel defenses in the OpenSSL library, along with some context and insight into what prompted these code changes. Tracking callers to BN mod inverse, the commit 1 enables the BN FLG CONSTTIME across several cryptosystems where the modular inversion inputs were deemed security critical, notably the published attack targeting RSA. Although BN mod exp mont consttime was introduced in the 0.9.7 branch, here we are referring to its use for modular inversion via FLT.OpenSSL version 0.9.6 0.9.7 0.9.8 1.0.01.0.1 1.0.2 BN mod inverse BN FLG CONSTTIME - BN mod inverse no branch - - ec nistp 64 gcc 128 - - - - BN mod exp mont consttime - - - - - EC GFp nistz256 method - - - - -mentation uses fixed-window combing combined with secure table lookups via software multiplexing (masking), and is enabled with the ec nistp 64 gcc 128 option at build time. While speed motivated the contribution, Möller observes 4 : "It seems that the BN MONT CTX-related code (used in crypto/ecdsa for constant-time signing) is entirely independent of the remainder of the patch, and should be considered separately." cache, or branch predictor timings. If the flag is not set, i.e. inputs are not secret, the control flow continues to the stock BEEA implementation.Paired with this code change, the next task was to identify callers to BN mod inverse within the library, and enable the BN FLG CONSTTIME flag for BIGNUMs in cryptosystem implementations that are security-sensitive. Our analysis suggests this was done by searching the code base for uses of the BN FLG EXP -CONSTTIME flag that was replaced with BN FLG CONST-TIME as part of the changeset, given the evolution of constant-time as concept within OpenSSL and no longer limited to modular exponentiation. As a result, the code changes permeated RSA, DSA, and Diffie-Hellman implementations, but not ECC-based cryptosystems such as ECDH and ECDSA.This leaves a gap for 1.0.1 with respect to EC-DSA. Following HeartBleed, OpenBSD forked OpenSSL to LibreSSL in July 2014, and Google forked OpenSSL to BoringSSL in June 2014. That is, as of this writing (fixed during disclosure) the current LibreSSL master branch can feature constant-time P-256 scalar multiplication with either EC GFp nistz256 method or EC GFp nistp256 -method callees depending on compile-time options and minor code changes, but inverts all ECDSA nonces with the BN mod inverse callee that fails the same security critical branch as OpenSSL, due to the caller ecdsasign setup not setting the BN FLG CONSTTIME flag for ECDSA signing nonces. Exploiting the vulnerability and performing our cachetiming attack is a long and complex process, therefore the analysis details are decomposed in several subsections. Our attack setup consists of an Intel Core i5-2400 Sandy Bridge 3.10GHz (32 nm) with 8GB of memory running 64-bit Ubuntu 16.04 LTS "Xenial". It does not feature HyperThreading.We built OpenSSL 1.0.1u with debugging symbols on the executable. The length of the equivalent noncê k is fixed to one bit more than that of the group's prime order n, thus the equivalent nonce satisfiesˆksatisfiesˆ satisfiesˆk = k + γ · n where γ ∈ {1, 2}. To compute the inversion, it calls BN mod inverse, where the BN FLG CONSTTIME flag is checked but due to the vulnerability discussed in Section 3 the condition fails, therefore proceeding to compute k −1 using the classical BEEA.Note that before executing the BEEA, the equivalent noncê k is unpadded through a modular reduction operation, resulting in the original nonce k and voiding the fixed bit-length countermeasure applied shortly before by ecdsa sign setup.The goal of our attack is to accurately trace and re-cover side-channel information leaked from the BEEA execution, allowing us to construct the sequence of rightshift and subtraction operations. The BN rshift routine receives the number of bit positions to shift right as an argument, used on u and v at the end of their respective loops. It is challenging to get good resolution and enough granularity with the FLUSH+RELOAD technique due to the speed of the technique itself, therefore, we apply a variation of the performance degradation attack to slow down the modular inversion operation by a factor of ~18. Combining the FLUSH+RELOAD technique with a performance degradation attack allows us to determine the number of right-shift operations executed between subtraction calls by the BEEA. Figure 5 contains sample raw traces captured in our test environment.Our spy process accurately captures all the subtraction operations but duplicates some right-shift operations, therefore we focus on the first part of the sequence to recover a variable amount of bits of information from every trace. Performance degradation attacks amplify side-channel signals, improving the quality and the amount of information leaked. The instrumentation skews the performance of the program, therefore this approach is suboptimal since it requires building the target code twice, one with instrumentation to identify code lines and other only with debugging symbols to measure the real performance.Once the "hot" memory addresses are identified, the next step is to evict them from the cache in a tight loop, thus increasing the execution time of the process accessing those addresses. We compare cache-misses between a regular modular inversion and a degraded modular inversion execution, resulting in a list of the "hottest" memory lines, building the code only once with debugging symbols and using hardware register counters.The perf command in Linux offers access to performance counters-CPU hardware registers counting hardware events (e.g. CPU cycles, instructions executed, cache-misses and branch mispredictions). Next, we degrade-by flushing in a loop from the cache-one memory line at a time from the caller BN mod inverse and callees BN rshift1, BNrshift, BN uadd, bn add words, BN usub.The perf command output gives us the real count of cache-misses during the regular execution of BNmod inverse, then under degradation of each candidate memory line. Some of the routines iterate over internal loops several times (e.g. BN rshift1) whereas in some other routines, iteration over internal loops happens few times (e.g. BN usub) or none at all. Overall "hottest" addresses in Table 2 shows the result of choosing the best strategy for our use case, where the addresses degraded in every routine varies from multiple addresses per routine to no addresses at all.For our use case, we observe the best results with 6 degrading addresses across two degrading processes executing in different CPU cores. The disadvantage of that approach is that it fixes the number of known LSBs (denoted ) per equation [8, In this section, we improve with respect to both points-extracting a varying number of bits from every nonce, subsequently allowing our lattice problem to utilize every signature queried, resulting in a significantly reduced number of required signatures. But at the same time, in reality for practical side-channels longer sequences are more likely to contain trace errors (i.e. incorrectly inferred LS sequences), ultimately leading to nonsensical lattice problems for key recovery. From the lattice perspective, ≥ 3 is a practical requirement [21, Sec. 4.2] so in that respect sequences of length 5 is the minimum to guarantee that every signature can be used as an equation for the lattice problem.To summarize, the data used to produce Figure 6 allows us to essentially build a dictionary that maps LS sequences of a given length to an ( i , a i ) pair, which we now define and utilize. n − 1} and |x| n to the interval {−(n − 1)/2 . Define the following (attacker-known) values.t i = r i /(2 i s i ) n ˆ u i = (a i − h i /s i )/2 i nIt now follows that 0 ≤ αt i − ˆ u i n < n/2 i . To extend the search space, we use the randomization technique inspired by Gama et al. [12, Sec. 5], shuffling the order of t i and u i and multiplying by a random sparse unimodular matrix between lattice reductions.Empirical results. Our lattice implementation uses Sage software with BKZ [25] reduction, block size 30. The protocol messages contain relevant information for the attack. OpenSSH is a set of tools implementing the SSH network protocol and it is typically linked against OpenSSL to perform several cryptographic operations, including digital signatures (excluding ed25519 signatures) and key exchange.For our experiments, we used OpenSSH 7.4p1 compiled from stock source and linked against OpenSSL 1.0.1u. We close with a few data points for our end-to-end attack, here focusing on TLS. In this context, end-to-end means all steps from the attacker perspective-i.e. launching the degrade processes, launching the spy process, and launching our custom TLS client. Consulting Table 3, we took 400 random subsets of size 55 from this set and ran lattice attack instances on a computing cluster. Our contributions traverse both practice and theory, recovering keys with as few as 50 signatures and corresponding traces.Stepping back from the concrete side-channel attack we realized here, our improved nonce bit recovery approach coupled with tuned lattice parameters demonstrates that even small leaks of BEEA execution can have disastrous consequences. Moreover, our work highlights the fact that constant-time considerations are ultimately about the software stack, and not necessarily a single component in isolation.The rapid development of cache-timing attacks paired with the need for fast solutions and mitigations led to the inclusion of the BN FLG CONSTTIME flag in Open-SSL. Despite OpenSSL's 1.0.1 branch being a standard package shipped with popular Linux distributions such as Ubuntu (12.04 LTS and 14.04 LTS), Debian (7.0 and 8.0), and SUSE, it reached EOL in January 2017. We thank Tampere Center for Scientific Computing (TCSC) for generously granting us access to computing cluster resources.Supported in part by Academy of Finland grant 303814.