A challenging part of the task is to connect an identified exploitable state (exploit primitive) to triggering execution of code-reuse (e.g., ROP) payload. However, due to the challenges of widely deployed exploit mitigations, pitfalls along an exploit path, and ill-suited primitives, it is difficult to even manually craft an exploit with a control-flow hijacking primitive for an off-the-shelf modern Linux kernel. Despite the undecidability of the general exploitability problem, sometimes a carefully crafted exploit could serve as a constructive proof of exploitability. In the second step, after pinpointing an exploit primitive, they add exploit constraints and perform constraint solving to generate a concrete input to exercise a predefined exploit technique (e.g., ret2libc attack). However, in order to generate working exploit for a controlflow hijacking primitive, there remains to be the following three challenges in the process of exploit primitive evaluation which limits the capability of automatic exploit generation techniques to target a complex real-world system such as the Linux kernel.Challenge 1, exploit mitigation. Lack of stack pivoting gadget [54] which is a vital step to perform ROP attack and insufficient control over general registers can make an exploit primitive ill-suited. Starting from a possibly ill-suited control-flow hijacking primitive (CFHP), KEPLER overcomes the lack of stack pivoting gadget and manages to build a "single-shot" exploitation chain to bootstrap existing Turing complete exploit techniques such as return oriented programming (ROP) [56], with the ability to bypass mainstream kernel mitigations as well as detouring exploit path pitfalls.To achieve this, KEPLER leverages a carefully designed code-reuse template for control-flow hijacking primitives to bypass widely-deployed mitigations in Linux kernel. KEPLER leverages blooming gadget to enhance control over necessary registers for a control-flow hijacking primitive. To highlight the effectiveness of KEPLER, we compare KEPLER with existing exploit hardening/generation tools (e.g., Q [60], fuze [75]) and KEPLER outperforms all of them in terms of generating effective kernel exploits under modern mitigation settings in Linux kernel.This research work makes the following contribution:â€¢ Kernel single-shot exploitation. Starting from a usersupplied control flow hijack primitive, KEPLER analyzes the Linux kernel binary, tracks down useful kernel gadgets, and automatically generates many gadget chains for launching "single-shot" exploitation and bypassing kernel mitigations. A control-flow hijacking primitive (CFHP) is a machine state that potentially deviates from the legal control-flow graph. Sometimes the primitive does not allow an attacker to modify/leak data at arbitray kernel address (e.g., a stack info leak which only dump several bytes on kernel stack [68]), they are referred as restricted memory write/leak primitive. To assist the process of finding a useful exploit primitive (e.g., control-flow hijacking primitive and memory write/leak primitive), there is a rich collection of research works. To efficiently explore state space for exploit primitives in Linux kernel, Wu et al. propose an automatic technique that utilizes undercontext fuzzing along with partial symbolic execution to explore CFHP and memory write primitive for UAF bugs [75]. In the primitive evaluation phase, a security analyst or an automatic exploit generation system tries suitable exploit techniques for the seemingly exploitable states identified before.Initially, without considering Data Execution Prevention, such systems use straightforward techniques such as ret2stack-shellcode and ret2libc with a CFHP [3] [9] [62]. Our work addresses the problem of ROP bootstrapping without stack pivoting gadget and is orthogonal to automatic ROP chaining techniques [33] [60] [66] [24] [57] because we do not tackle the problem of ROP payload construction.With the facilitation of forward and backward taint analysis, Mothe et al. devise a technical approach to craft working exploits for simple vulnerabilities in user-mode applications [48]. First, without assuming a perfect ex-ploit primitive (e.g., unlimited number of invocations of an arbitrary memory write primitive), we can faciliate exploit primitive evaluation for those usually ignored exploit primitive (e.g., ill-suited primitives and primitive that can only be triggered once). Initially, a CFHP in the kernel can directly execute shellcode in user-space because there is no isolation between user and kernel space (e.g., ret2usr). With adoption of Supervisor Mode Access Prevention (SMAP [11]), an attacker can no longer rely on a fake stack in userspace because userspace memory access is forbidden except during I/O channel functions. However, with a kernel patch applied, these physmap pages are no longer executable.To enforce CFI policy for the kernel, several kernel CFI solutions [16] [70] [26] have been proposed, however, these mitigations are not broadly adopted by major Linux release version such as CentOS, Ubuntu and Debian.Data-only kernel exploit techniques directly use a memory write primitive to modify sensitive kernel data objects such as process credentials, page tables and virtual dynamic shared object (vdso) [36]. (Kernel) Code diversification/randomization [14] [15] [27] [74] [42] [53] could significantly raise the bar of code-reuse exploitation by thwarting an attacker from locating useful gadget. A kernel has enabled stack canary to protect return address over stack for all functions containing local variable [22]. A kernel has been protected by virtualization-based hypervisor which prevents unauthorized modification of cr4 regsiter [49]. The option routes all call_usermodehelper() calls through a guard binary that can properly filter the requested userland programs to be run by the kernel [43]. Under the threat model, the content in arbitrary memory address such as the stack canary value of arbitrary kernel thread usually remains secret because the coarse kernel memory layout information does not reveal the stack canary value of a kernel stack. Its first member next_rcu is unmanageable because the PoC uses a heap spray technique which does not allow us to control first QWORD of struct ip_mc_socklist. We illustrate the challenges in evaluating a CFHP on x86-64 with CVE-2017-8890 [50], a recent vulnerability in the Linux kernel.1 void ip_mc_drop_socket(struct sock *sk){ 2 struct inet_sock *inet = inet_sk(sk); 3 struct ip_mc_socklist *iml; 4 // inet->mc_list is a dangling pointer 5 while ((iml = inet->mc_list) ! = NULL) { 6 // iml The root cause of the bug is an Use-After-Free over an object ip_mc_socklist defined in Table 1a. At the time of the control-flow hijacking, register rdi (head) points to a controllable memory region. With the write-protection over sensitive data such as process credential and page table , it is not possible to direct overwrite these data to escalate priviledge by converting the CFHP into a memory write primitive.A security analyst may think of the "cr4-flipping" attack which usually requires two CFHPs: one for flipping the cr4 register and the other to launch ret2user/pivot2usr. As is shown in Figure 1, after using the CFHP in rcu_reclaim to disable SMAP protection by invoking the function native_write_cr4() to zero the corresponding bits in cr4 register, an attacker encounters an unexpected termination: in previous execution, the loop from line 5 to line 10 in Table 1b queues another rcu callback denoted by head' (iml->next_rcu ->rcu) which is not under our control and causes a kernel panic.This kernel panic attributes to an invalid memory access. To get multiple CFHPs for a UAF vulnerability, an attacker may need to do multiple rounds of heap spraying and trigger a vulnerability multiple times, which could dramastically decrease the success ratio of the entire exploitation.Even if two control-flow hijack primitive is available to the attacker, it could still be very difficult for him to bypass the mitigation combination of SMAP as well as virtualizationbased hypervisor, because the attempt to modify cr4 register (in order to turn off SMAP and pivot kernel stack to userspace) could be easily prevented. Considering register rdi points to controllable area with this primitive, it would be great to have a gadget to overwrite rsp with a controllable memory address, such as gadget with form xchg r**,rsp; ret, mov rsp,[r**]; jmp rxx and mov rsp,r**; ret for consecutive payload [39]. Unfortunately, similar traditional stack-pivoting gadget does not exist or contains unavoidable exploit path pitfall (e.g., gadget xchg rsp, r14 ; jmp rsp could successfully pivot the stack pointer but inevitably panics the kernel) in our investigation across various modern linux kernel images. On the other hand, the exploit generation phase should be easily automated -it should be a well-defined search problem over a search space of reasonable size. 2 The term "magic gadget" means given a CFHP, one can instantly succeed in exploitation (e.g., getting a shell) by diverting control-flow to such gadget, thus boost exploit development and gain advantages in a game. Given a kernel state snapshot representing the CFHP, KEPLER enhances its power to construct a kernel stack-overflow by symbolically stitching several types of candidate gadget identified by static analysis on the kernel binary image.As is mentioned before, our basic idea is to bootstrap a traditional ROP attack with a CFHP in Linux kernel. Although there is not any gadget in Linux kernel which allows an attacker to directly escalate priviledge, The proposed "single-shot" exploitation is similar to "magic gadget" mentioned above in a sense that it only requires a single CFHP and could reliably achieve the goal of arbitrary code execution in kernel context. Our "single-shot" exploitation technique builds on two key ideas of breaking isolation with I/O functions and improving exploit success ratio with a single CFHP.First, we can break isolation between kernel-space and user-space by abusing kernel I/O functions. Fig- ure 4 illustates a practice of reusing I/O functions to construct kernel stack overflow by first leaking kernel stack canary with copy_to_user and then smashing kernel stack with copy_from_user.Second, "single-shot" exploitation can be achieved through stitching various kernel function gadgets. As is named after, copy_from_user(void* dst, void* src, unsigned long length) 3 is a heavily used I/O kernel function which migrates data from the user to kernel space. Once the copy is finished, instruction CLAC is executed to re-enable SMAP.As is specified in Linux kernel implementation, the function copy_from_user() takes as input three arguments -dst, src and length -which indicate the destination, source and length of the data that need to be copied from the user to kernel space.From the perspective of an attacker, a kernel stack overflow could be caused if he lets the CFHP jump to the site right before the invocation of copy_from_user (line 2 in Table 2b) and the machine state satisfies the following three requirements: Â‚ parameter dst (e.g., rdi) points to current kernel stack, Âƒ parameter src (e.g., rsi) points to any user-space address so that its content is controllable by an attacker, Â„ parameter length (e.g., rdx) is greater than the size of current stack frame to cause a kernel stack overflow.An interesting observation is that most (91% in Linux 4.15) invocations of this function set destination dst to address of a variable on kernel stack and thus will copy user data into a kernel stack. Among all these invocation sites, more than 99% contain the fault handling implementation.The insight of prioritizing short return path after stack smash is to prevent un-expected kernel panic as well as avoid the complexity of resolving extra data dependency in an errorprone and long normal return path of the function containing tens of basic blocks.To take a short return path, copy_from_user must return a non-zero value as is shown in Table 2a. To force copy_from_user returning a non-zero value as well as successfully copying the ROP payload from user-space to kernel stack, we trigger page fault after copying enough payload according to the last condition described above.We illustrate a representative example in Figure 5. More specifically, we set rsi and rdx to p1 + PAGE_SIZE âˆ’ n and n + 1 respectively, with n representing the length of payload actual copied. Since this naturally establish a channel to migrate data from kernel stack to user-space, we could exploit the characteristic of this kernel function to disclose the canary on kernel stack. To successfully return from a stackdisclosure gadget and continue exploitation, we use auxiliary function to create a similar stack frame as the stack-disclosure gadget and transfer the control-flow to stack-disclosure gadget with an indirect call after the function prologue.Auxiliary function should have stack canary protection and contain a controllable indirect call after its own function prologue which establishes a stack frame. Then content of current stack frame is copied to user-space by copy_to_user, a page fault is triggered to force non-zero return value of copy_to_user, as result short return path is taken in y. Before the function returns, stack canary sanity check is performed z, because the auxiliary function put a valid stack canary in current stack frame, the canary check is successfully passed and return to the caller of auxiliary function. "Single-shot" exploitation uses a blooming gadget to amplify control over other registers and a bridging gadget to combine the two actions sequentially. Assume we have a CFHP with 1 void regcache_mark_dirty(struct regmap *map) { 2 map->lock(map->lock_arg); // the 1st control-flow hijack 3 map->cache_dirty = true; 4 map->no_sync_defaults = true; 5 map->unlock(map->lock_arg); // the 2nd control-flow hijack 6 } Figure 7: Memory layout after using physmap spray [39] to allocate physmap pages with data under our control.control over rdi, we can get an augmented CFHP which controls rdi, rsi, and rdx at the same time at line 3 in Table 3. We use bridging gadget -a family of kernel functions with multiple controllable indirect calls -to spawns two CFHPs and combine canary leak and stack smash into a single shot.For example, function regcache_mark_dirty shown in Table 4 is such a bridging gadget which contains two indirect calls, map->lock in line 2 and map->unlock in line 5. To determine whether a gadget chain is useful for exploitation, our tool checks the memory access and deems a gadget chain useless if that exploitation chain attempts to access the user space or an unmapped kernel memory region. With the check right before symbolically executing the two gadgets, we can quickly determine the usefulness of the gadget chain in exploitation, terminate unnecessary symbolic execution and thus save the computation resources.In the process of the assessment of the exploitation chain, KEPLER symbolically executes each exploitation gadget. In this way, KEPLER could terminate the memory-intensive process every time the constraint solving is completed and thus free the memory for consecutive computation.As is described in Section 6.1, the payload smashed to the stack contains the stack canary disclosed as well as a sequence of addresses indicating an ROP chain that performs actual exploitation. On the other hand, this is because some components in Linux kernel experience significant overhaul since 2016 and we have difficulty of re-enabling the corresponding vulnerabilities in a new kernel image.In order to run and evaluate KEPLER, we also assembled and configured a testbed which has a 32-core Intel(R) Xeon(R) Platinum 8124M CPU and 256GB of memory. G1, G2, G3 and G4 represent the blooming gadget, bridging gadget, auxiliary and disclosure gadget pair, and stack-smash gadget. This is because the public exploits circumvent mitigations by manipulating control registers with two CFHPs, 4 The result related to Q in our evaluation is based on inference of its design instead of running its tool because we were not able to get the source code of Q.as is discussed in Section 2.3, this practice can be easily restricted by virtualization extension. As we can observe, KEPLER could quickly output an useful exploitation chain in less than about 50 wall-clock minutes (and the corresponding CPU-core time is roughly 1400 minutes given the prototype system uses 28 concurrent workers). Last but not least, Table 5 also shows the total number kernel gadgets in different categories. In addition, randomizing stack canary per-function call [73] could idealy prevent our exploit technique because it discourage the effort to fake stack frame and leak stack canary with copy_to_user. We propose KE-PLER, a framework to facilitate evaluation of control-flow hijacking primitives which leverages a novel "single-shot" exploitation to convert a control-flow hijacking primitive into a classic stack overflow and thus bootstrap traditional codereuse attack against modern Linux kernel. Table 7: The kernel ROP payload that copies an ROP payload to the current stack frame and then subtracts the stack pointer to execute the ROP payload.we demonstrate the exploitability of a kernel vulnerability. After that, we redirect the control flow of the Linux kernel to a universal ROP payload.