In 1998 Bleichenbacher presented an adaptive chosen-ciphertext attack on the RSA PKCS #1 v1.5 padding scheme. These implementations provide novel side-channels for constructing Bleichenbacher oracles: TCP resets, TCP timeouts, or duplicated alert messages. Finally, we discuss countermeasures against Bleichen-bacher attacks in TLS and recommend to deprecate the RSA encryption key exchange in TLS and the RSA PKCS #1 v1.5 standard. In 1998 Daniel Bleichenbacher published an adaptive chosen-ciphertext attack on RSA PKCS #1 v1.5 encryption as used in SSL [11]. This allows the attacker to decrypt arbitrary ciphertext without access to the private key by using Bleichenbacher's algorithm for exploiting the PKCS #1 v1.5 format.Instead of upgrading to RSA-OAEP [29], TLS designers decided to use RSA PKCS #1 v1.5 in further TLS versions and apply specific countermeasures [2,17,34]. While Bleichenbacher attacks have been found on multiple occasions and in many variations, we are not aware of any recent research trying to identify vulnerable TLS implementations in the wild. Many of the findings are interesting from the research perspective since they uncover different server behaviors or show new side-channels which were specifically triggered by changing TLS protocol flows or observing TCP connection state. These behaviors are of particular importance for the analyses of different vulnerabilities relying on server responses, for example, padding oracle [37] or invalid curve attacks [24]. The Bleichenbacher vulnerability check was afterwards included in SSL Labs and testssl.sh.As a result of a successful attack, the attacker is able to obtain the decrypted RSA ciphertext or sign an arbitrary message with server's private key. This key exchange is used in all cipher suites having names starting with TLS RSA (e.g. TLS RSA WITH AES 128 CBC SHA). If the server shares cipher and protocol support with the client, it responds with a ServerHello message indicating the selected cipher suite and other connection parameters. The client then sends a ClientKeyExchange message containing a premaster secret that was RSA encrypted using the key included in the server's certificate. || denotes byte concatenation.3.1 RSA PKCS #1 v1.5 RSA PKCS #1 v1.5 describes how to generate a randomized padding string PS for a message k before encrypting it with RSA [25]:1. The decryptor uses its private key to perform RSA decryption, checks the PKCS #1 v1.5 padding, and extracts message k. Bleichenbacher's attack allows an attacker to recover the encrypted plaintext m from the ciphertext c. For the attack execution, the attacker uses an oracle that decrypts c and responds with 1 if the plaintext starts with 0x0002 or 0 otherwise:O(c) = 1 if m = c d mod N starts with 0x0002 0 otherwise.Such an oracle can be constructed from a server decrypting RSA PKCS #1 v1.5 ciphertexts.Bleichenbacher's algorithm is based on the malleability of the RSA encryption scheme. Therefore, the client Finished message is always responded with an alert message and the attacker cannot determine PKCS #1 v1.5 validity. This can happen, for example, if the implementation strictly checks the PKCS #1 v1.5 format which prescribes that the first 8 bytes following 0x0002 are non-zero, or if the implementation strictly checks the length of the unpadded key. For example, the improved Bleichenbacher attack algorithm needs about 10,000 queries on average when using the "strongest" oracle. The weak oracle results in an attack with several millions of queries and can be provided by an implementation which checks whether the 0x00 byte is located on the correct position. Since this step requires many oracle requests, creating a signature is much more time consuming and is only practical if a strong oracle is available. The challenge of our research was to perform an effective scan using as few requests as possible, but allowing us to trigger all known vulnerabilities and potentially find new ones. This manual analysis allowed us to find new issues and extend further TLS scans which we applied to the Alexa Top 1 Million list.In the following sections we give an overview of our final scanning methodology. denotes byte concatenation, version represents two TLS version bytes, rnd[x] denotes a non-zero random string of length x, and pad() denotes a function which generates a non-zero padding string whose inclusion fills the message to achieve the RSA key length.Given the performance prerequisites for our scan, we carefully selected five PKCS #1 v1.5 vectors based on the previous research on Bleichenbacher attacks [11,7,28,36]. This message starts with incorrect PKCS #1 v1.5 padding bytes:M2 = 0x4117 pad()The invalid first byte in the PKCS #1 v1.5 padding should trigger an invalid server behavior as described, for example, in the original paper [11].3. Otherwise, if the server allows the attacker to identify messages with, for example, message M3 or M4, the server provides a strong oracle and the attack can be practically exploited. More specifically, we observed differences on some servers when processing a ClientKeyExchange message sent by itself versus when it was sent in conjunction with ChangeCipherSpec and Finished. We will refer to sending ClientKeyExchange alone as "shortened message flow" in the rest of the paper.The primary example of this is F5 BIG-IP. Otherwise, when processing properly formatted ClientKeyExchange, the device waited for subsequent ChangeCipherSpec and Finished messages.Our scans also confirmed that it is insufficient to consider only TLS alert numbers or timing as a suitable sidechannel. Some however returned an extra TLS alert when processing an invalid ClientKeyExchange.In a server scan it is therefore important to not only monitor the last received TLS alert but also the content and count of received messages and socket behavior. The oracle detection of our scanner works by first downloading a target server's certificate and using it to encrypt five ClientKeyExchange messages (M1,...M5). If the responses are identical, the server is retested using the same ClientKeyExchange but with an abbreviated message flow that omits ChangeCipherSpec and Finished. For each vulnerable implementation the table provides information about different server responses triggered by valid and invalid ClientKeyExchange messages, the TLS protocol flow (full / shortened), the oracle type (strong / weak), and a CVE ID. During our first scans, we discovered that the main Facebook host -www.facebook.com -was vulnerable. TLS alerts are referenced by their numbers: 10 (unexpected message) 20 (bad record mac), 40 (handshake failure), 47 (illegal parameter), 51 (decrypt error), and 80 (internal error). We created a proof of concept signature using this oracle and sent it to Facebook along with an explanation of the problem. Based on Facebook's encouraging responses to the first reports, we continued scanning their infrastructure and found yet another vulnerable behavior. Most commonly, F5 products would respond to malformed ClientKeyExchange with a TLS alert 40 (handshake failure) but allow connections to timeout if the decryption was successful. By contacting web page owners we learned that many of the implementations we identified as vulnerable were run by Citrix Netscaler devices. The Netscaler vulnerability is behaving slightly different depending on whether the connection uses a CBC or a GCM cipher suite.For this vulnerability the signal for a malformed decryption block is a timeout. We found that Cisco ACE load balancers were vulnerable.Different error types were answered with either TLS alert 20 (bad record mac) or 47 (illegal parameter). Based on our scans we assume that despite being out of support for several years ACE devices are still in widespread use.We also observed that the host cisco.com and several of its subdomains are vulnerable to Bleichenbacher attacks in the exact same way as the vulnerable ACE devices. Their tests found that versions 19 and 20 answered with TLS alert 10/51 while version 18 answered with TLS alert 20/51 as observed on the WhatsApp domain.The Erlang developers released fixes in the versions 18.3.4.7 [3], 19.3.6.4 [4] and 20.1.7 [5]. Sending a ClientKeyExchange where the zero terminator of the padding was not at the right position led to a TLS alert 80 (internal error). Other errors made the server send a ChangeCipherSpec message.The vulnerability only appears if Bouncy Castle is using the JCE API in Java for cryptographic operations.Bouncy Castle offers an old API (org.bouncycastle.crypto.tls) and a new API (org.bouncycastle.tls). The old API does not support the JCE API.Bouncy Castle plans to fix this vulnerability in version 1.59. We have identified a weak oracle in IBM Lotus Domino, distinguishable by TLS alerts 20 (bad record mac) and 47 (illegal parameter). A fix for PAN-OS is available in versions 7.1.5 and 8.0.7 [30]. Attempts to ask the operators usually remain unanswered and many products do not expose product or version information via the appropriate HTTP headers. 2 We performed several scans over the Alexa Top 1 Million list for vulnerable hosts. While our scan tool attempts to minimize inaccuracies by validating vulnerable responses, we have observed that certain non-deterministic behavior can still be falsely identified as vulnerable.According to these scans 22,854 hosts (2.3 %) were vulnerable among the www hosts. We assume that the reason for this low number of vulnerabilities overall is the correct mitigation implementation in OpenSSL, the most widely used TLS library.Among the top 100 domains according to Alexa 27 (thus 27 %) were vulnerable if we combine our best scan result with previous scans of hosts that were already fixed at that point. If we combine these two scans 21,194 hosts were vulnerable to one of the F5 variants we have seen. Our proof of concept is based on Tibor Jager's implementation of the Bleichenbacher algorithm.The implementation uses the simple algorithm as described by Bleichenbacher's original work [11]. This has consequences for the impact of the attack.TLS supports different kinds of key exchanges with RSA: Static RSA key exchanges where a secret value is encrypted by the client and forward-secrecy enabled key exchanges using Diffie Hellman or elliptic curve Diffie Hellman where RSA is only used for signing. An attacker can passively record traffic and later decrypt it with the Bleichenbacher oracle. We observed devices and configurations where this is the case, notably the Cisco ACE load balancers and the host paypal.com.In this section we describe general applications of Bleichenbacher attacks to servers that do not support static RSA key exchange. To attack a key exchange where RSA is only used for signatures, the attacker faces a problem: He could impersonate a server to a client, but in order to do this he has to be able to perform an RSA signature operation during the handshake. In response to the DROWN attack Google has first disabled QUIC for non-Google hosts and later changed the QUIC handshake to prevent this attack [12]. These servers provided very good performance, thus we believe a parallelized attack would have allowed impersonation of www.whatsapp.com.Similar attack scenarios can be imagined if different services share a certificate, a key, or have certificates that are also valid for other services. Apart from attacks against TLS an attack may be possible if the private key of a TLS server is also used in different contexts.An example for this is the ACME protocol [8] for certificate issuance that is used by Let's Encrypt. It allows revoking certificates if one is able to sign a special revocation message with the private key belonging to a certificate.While this does not impact the security of TLS connections, it allows causing problems for web page operators that may see unexpected certificate validation errors. The first algorithm proposes that servers fix ClientHello version errors in the premaster secret and calculate the Finished message with it. The second algorithm proposes to always treat a wrong version number in the premaster secret as an error.The TLS standards mention that the OAEP protocol provides better security against Bleichenbacher attacks. It was always decided however to keep the old PKCS #1 v1.5 standard for compatibility reasons.To summarize, it can be seen that the designers of the TLS protocol decided to counter Bleichenbacher attacks by introducing increasingly complicated countermeasures. Instead of removing these problematic modes or redesigning them to be resilient against padding oracle attacks the TLS designers decided to propose countermeasures. Given the complexity of the countermeasures in the TLS standard it is very likely that yet unknown timing variants of Bleichenbacher vulnerabilities exist in many TLS stacks.We learned from Adam Langley that various TLS implementations may be vulnerable to timing attacks due to the use of variable-size bignum implementations. If an attacker is able to measure that timing signal he may be able to use this as an oracle and perform an attack very similar to a Bleichenbacher attack. The workarounds are not implemented correctly on a large number of hosts.For the upcoming TLS 1.3 version the RSA encryption key exchange has been deprecated early in the design process [33]. There is no added risks if clients still support RSA encryption based key exchanges. Therefore server operators can disable RSA encryption based key exchanges and support Elliptic Curve Diffie Hellman exchanges for modern clients and finite field Diffie Hellman for old clients. Therefore in order to reduce the need to support the RSA encryption based key exchange users can switch to alternative apps that support more modern cryptographic algorithms.Despite these challenges we believe that the risk of incorrectly implemented countermeasures to Bleichenbacher attacks is so high that RSA encryption based key exchanges should be deprecated. It is standardized in the newer PKCS #1 standards, the latest being version 2.2 [29]. RSA signature implementations do not suffer from Bleichenbacher's attack from 1998, but the PKCS #1 v1.5 padding has another problem. Jager et al. [22] have shown Bleichenbacher vulnerabilities in XML encryption, Detering et al. have shown vulnerabilities in JSON / JOSE [16] and Nestlerode has discovered vulnerabilities in the Cryptographic Message Syntax (CMS) code of OpenSSL [31]. Jager et al. have warned about the risk of Bleichenbacher attacks for TLS 1.3 [23], and were awarded with the best paper award at the "TLS 1.3 Ready Or Not" (TRON) workshop [9]. Many existing TLS vulnerability testing tools did not have tests for Bleichenbacher vulnerabilities in the past. A strict interpretation of the TLS standard demands that all RSA decryption failures are answered with a TLS alert 20 (bad record mac) after the Finished message.Tripwire IP360 added detection 6 for vulnerable F5 devices in ASPL-753 which was released in coordination with F5's public advisory. We extended this evaluation with shortened protocol flows with missing ChangeCipherSpec and Finished messages, and implemented an oracle detection based on TCP timeouts and duplicated TLS alerts. We encourage developers of other TLS or security test tools to include tests for Bleichenbacher attacks and for other old vulnerabilities. 8 This allows developers 10 Summary and conclusionWe were able to identify nine vendors and open source projects and a significant number of hosts that were vulnerable to minor variations of Bleichenbacher's adaptivechosen ciphertext attack from 1998. The authors thank Tibor Jager for providing a Python implementation of the Bleichenbacher attack, Adam Langley for feedback on QUIC and timing problems in Go TLS, Eric Mill from GSA for helping us to identify vulnerable platforms, Nick Sullivan for sharing usage numbers of RSA key exchanges from Cloudflare, Dirk Wetter and David Cooper for implementing a ROBOT check in testssl.sh and for finding bugs in our test code, Hubert Kario for finding bugs in our test code, Graham Steel, Vladislav Mladenov, Christopher Meyer, Robert Merget, Ernst-Günter Giessmann, and Tanja Lange for feedback on this paper, Ange Albertini for drawing a great logo, Garret Wasserman from CERT/CC for helping with vendor contacts, and Facebook for generous bug bounties. kWe provide a signature that signs the following text:We hacked Facebook with a Bleichenbacher Oracle (JS/HB). We could alternatively get it directly from Facebook's servers via TLS, but that would stop working once the certificate expires and Facebook changes it.This signature is using the format of OpenSSL's rsautl command.