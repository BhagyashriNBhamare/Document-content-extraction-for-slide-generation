To address these challenges, we propose a novel stream-based query system that takes as input, a real-time event feed aggregated from multiple hosts in an enterprise, and provides an anomaly query engine that queries the event feed to identify abnormal behaviors based on the specified anomalies. Our evaluations on a broad set of attack behaviors and micro-benchmarks show that our system has a low detection latency (<2s) and a high system through-put (110,000 events/s; supporting ∼4000 hosts), and is more efficient in memory utilization than the existing stream-based complex event processing systems. These attacks consist of a sequence of steps across many hosts that exploit different types of vulnerabilities to compromise security [25,2,1]. System monitoring observes system calls at the kernel level to collect information about system activities. Third, system monitoring produces huge amount of daily logs (∼50GB for 100 hosts per day) [69,88]. To express such behavior, SAQL uses event patterns to express each activity in the format of {subject-operationobject} (e.g., proc p1 write file f1), where system entities are represented as subjects (proc p1) and objects (file f1), and interactions are represented as operations initiated by subjects and targeted on objects.Stateful computation in sliding windows over a data stream enables the specification of stateful behavior models for detecting abnormal system behaviors such as time-series anomalies, which lack support from existing stream query systems that focus on general data streams [91,59,30,42]. Figure 1 shows an invariant-based anomaly, where a process (apache.exe) starts an abnormal process (java.exe) that is unseen during the training period. SAQL provides constructs to define and learn the invariants of system behaviors in each state computed from a window, which allow users to combine both states of windows and invariants learned under normal operations to detect more types of abnormal system behaviors.Outlier-based anomalies allow users to identify abnormal system behavior through peer comparison, e.g., finding outlier processes by comparing the abnormal processes with other peer processes. One major challenge faced by this design is the scalability in handling multiple concurrent anomaly queries over the large-scale system monitoring data. Based on the analysis results, our system puts the compatible queries into groups, where in each group, a master query will directly access the stream data and the other dependent queries will leverage the intermediate execution results of the master query. Deployment and Evaluation: We built the whole SAQL system (around 50,000 lines of Java code) based on the existing system-level monitoring tools (i.e., auditd [15] and ETW [13]) and the existing stream management system (i.e., Siddhi [20]). We performed a broad set of attack behaviors in the deployed environment, and evaluated the system using 1.1TB of real system monitoring data (containing 3.3 billion events): (1) our case study on four major types of attack behaviors (17 SAQL queries) shows that our SAQL system has a low alert detection latency (<2s); (2) our pressure test shows that our SAQL system has a high system throughput (110000 events/s) for a single representative rulebased query that monitors file accesses, and can scale to ∼4000 hosts on the deployed server; (3) our performance evaluation using 64 micro-benchmark queries shows that our SAQL system is able to efficiently handle concurrent query execution and achieves more efficient memory utilization compared to Siddhi, achieving 30% average saving. The attributes of an event include event origins (i.e., agent ID and start time/end time), operations (e.g., file read/write), and other security-related properties (e.g., failure code). We next present how to use SAQL as a unified interface to specify various types of abnormal system behaviors.Rule-based Anomaly: Advanced cyber attacks typically include a series of steps that exploit vulnerabilities across multiple systems for stealing sensitive information [2,1]. Query 1 shows a SAQL query for describing an attack step that reads external network (evt1), downloads a database cracking tool gsecdump.exe (evt2 ), and executes (evt3) it to obtain database credentials.It also specifies these events should occur in ascending temporal order (Line 4). It specifies a 10-minute sliding window (Line 1), collects the amount of data sent through network within each window (Lines 2-4), and computes the moving average to detect spikes of network data transfers (Line 5). Query 3 shows a SAQL query that specifies a 10-second sliding window (Line 1), maintains a set of child processes spawned by the Apache process (Lines 2-4), uses the first ten time windows for training the model (Lines 5-8), and starts to detect abnormal child processes spawned by the Apache process (Line 10). Note that the invariant definition allows multiple aggregates to be defined. Query 4 shows a SAQL query that (1) specifies a 10-minute sliding window (Line 2), (2) computes the amount of data sent through network by the sqlservr.exe process for each outgoing IP address (Lines 3-5), and (3) identifies the outliers using DBSCAN clustering (Lines 6-8) to detect the suspicious IP that triggers the database dump. System monitoring data for Windows, Linux, and Mac OS are collected via ETW event tracing [13], Linux Audit Framework [15], and DTrace [8]. The system consists of two components: (1) the language parser, implemented using ANTLR 4 [3], performs syntactic and semantic analysis of the input queries and generates an anomaly model context for each query. An anomaly model context is an object abstraction of the input query that contains all the required information for the query execution and anomaly detection; (2) the execution engine, built upon Siddhi [20], monitors the data stream and reports the detected alerts based on the execution of the anomaly model contexts.The execution engine has four sub-modules: (1) the multievent matcher matches the events in the stream against the event patterns specified in the query; (2) the state maintainer maintains the states of each sliding window computed from the matched events; (3) the concurrent query scheduler divides the concurrent queries into groups based on the master-dependent-query scheme (Section 5.2) to minimize the need for data copies; (4) the error reporter reports errors during the execution.Threat Model: SAQL is a stream-based query system over system monitoring data, and thus we follow the threat model of previous works on system monitoring data [63,64,69,68,32,50]. Besides, the syntax directly supports the specification of event temporal relationships and attribute relationships, which facilitates the specification of complex system behavioral rules.Global Constraint: The global cstr rule specifies the constraints for all event patterns (e.g., agentid = 1 in Query 4 specifies that all event patterns occur on the same host). The entity rule consists of the entity type (file, process, network connection), the optional entity ID, and the optional attribute constraints expression (attr exp). =, >, >=, <, <=), the arithmetic operators (+, −, * , /), the aggregation functions, and the stateful computation-related operators (e.g., proc p[pid = 1 && name = "%chrome.exe"]). Event Attribute Relationship: Event attribute relationships can be included in the alert rule (alert) to specify the attribute dependency of event patterns (e.g., alert evt1.agentid = evt2.agentid && evt1.dst_id = evt2.src_id for two event patterns evt1 and evt2 indicates that the two events occur at the same host and | attr exp ('&&' | '||') attr exp | '! {' inv init+ inv update+ '}' inv init ::= id ':=' (num|empty set) inv update ::= id '=' attr exp state cluster ::= 'cluster' '(' point def ',' distance def ',' method def ')' point def ::= 'points' '=' peer ref '(' attr (',' attr)* ')' distance def ::= 'distance' '=' dist metric method def ::= 'method' '=' cluster method '(' num (',' num)* ')'Context-Aware Syntax Shortcuts:• Attribute inferences: (1) default attribute names will be inferred if only attribute values are specified in an event pattern, or only entity IDs are specified in event return. We select the most commonly used attributes in security analysis as default attributes: name for files, exe_name for processes, and dst_ip for network connections. Based on the constructs of sliding windows, SAQL provides constructs for stateful computation, which consists of two major parts: defining states based on sliding windows and accessing states of current and past windows to specify time-series anomalies, invariant-based anomalies, and outlier-based anomalies.State Block: The state def rule specifies a state block by specifying the state count, block ID, and multiple state fields. This enables SAQL to specify a broad set of detection logics for time-series anomalies (e.g., Line 5 in Query 2), invariant-based anomalies (e.g., Line 9 in Query 3), and outlier-based anomalies (e.g., Line 7 in Query 4). To make the system more scalable in supporting multiple concurrent queries, the engine employs a masterdependent-query scheme that groups semantically compatible queries to share a single copy of the stream data for query execution. Algorithm 1 shows the scheduling algorithm:Algorithm 1: Master-dependent-query schemeInput: User submitted new SAQL query: newQ Map of concurrent master-dependent queries: M = {masQ i → {depQ i j }} Output: Execution results of newQ if M.isEmpty then return execAsMas(newQ, M); else for masQ i in M.keys do covQ = constructSemanticCover(masQ i , newQ); if covQ = null then if covQ = masQ i then replMas(masQ i , covQ, M); addDep(covQ, newQ); return execDep(newQ, covQ); return execAsMas(newQ, M);Function constructSemanticCover(masQ,newQ)if Both masQ and newQ define a single event pattern then if masQ and newQ share the same event type, operation type, and sliding window type then Construct the event pattern cover evtPattCovQ by taking the union of their attributes and agent IDs and the GCD of their window lengths; if Both masQ and depQ define states then if masQ and depQ have the same sliding window length and masQ defines a super set of state fields of depQ then Construct the state cover stateCovQ by taking the union of their state fields; return covQ by concatenating evtPattCovQ, stateCovQ, and the rest parts of masQ; return null; Function execAsMas(newQ, M)Make newQ as a new master and execute it; Function addDep(masQ, depQ, M)Add depQ to the dependencies of masQ; Function replMas(oldMasQ, newMasQ, M)Replace the old master oldMasQ with the new master newMasQ and update dependencies; Function execDep(depQ, masQ) if depQ == masQ then return execution results of masQ; else if Both masQ and depQ define states then if masQ and depQ have the same sliding window length and masQ defines a super set of state fields of depQ then Fetch the state aggregation results of masQ, enforce additional filters, and feed into the execution pipeline of depQ; elseFetch the matched events of masQ, enforce additional filters, and feed into the execution pipeline of depQ;1. The scheme first checks if M is empty (i.e., no concurrent running queries). We deployed the SAQL system in NEC Labs America comprising 150 hosts (10 servers, 140 employee stations; generating around 3750 events/s). We performed four major types of attack behaviors in the deployed environment based on known exploits: (1) APT attack [2,1], (2) SQL injection attack [43,78], (3) Bash shellshock command injection attack [7], and (4) suspicious system behaviors. c3 Privilege Escalation: The attacker enters the victim's machine through the backdoor, scans the network ports to discover the IP address of the database, and runs the database cracking tool (gsecdump.exe) to steal the credentials of the database. We construct an outlier-based anomaly query (Query 15) to detect abnormally large data transfers to external IP addresses.Bash Shellshock Command Injection Attack: We conduct a command injection attack against a system that installs an outdated Bash package susceptible to the Shellshock vulnerability [7]. • Unauthorized login logs accesses (Query 20): finding the unauthorized processes that access the log files of login activities. Thus, the state computation is often maintained in a manageable level.N/A N/A N/A 8% 1.2GB command-history ≤1ms N/A N/A N/A 10% 2.2GB password ≤1ms N/A N/A N/A 9% 1.6GB login-log ≤1ms N/A N/A N/A 10% 2.2GB sshkey ≤1ms N/A N/A N/A 10% 2.1GB usb ≤1ms N/A N/A N/A 9% 2.1GB ipfreq ≤1ms N/A N/A N/A 10% 2.1GB We conduct a pressure test of our system by replicating the data stream, while restricting the CPU utilization to certain levels [5]. We select Siddhi [20], one of the most popular stream processing and complex event processing engines, for baseline comparison.Micro-Benchmark Construction: We construct our micro-benchmark queries by extracting critical attributes • Browsers access files: finding files accessed by the processes chrome, firefox, iexplore, and microsoftedge. • Processes spawn: finding processes spawn by the processes /bin/bash, /usr/bin/ssh, cmd.exe, and java.We also specify the following four evaluation categories for query variations, which correspond to the four optimization dimensions in Section 5.2:• Event attributes: we vary from 1 attribute to 4 attributes. Note that unlike SAQL which provides explicit constructs for stateful computation, Siddhi as well as other stream-based query systems [20,12,51,4], do not provide the native support for these concepts, making these tools unable to specify advanced anomaly models (i.e., time-series anomalies, invariant-based anomalies, outlier-based anomalies). Thus, the memory measured in Figures 5 to 7 is larger than the memory measured in the case study (Table 3), where we use the real-time data streams. Again, we would like to point out that the major focus of our work is to provide a useful interface for investigators to query a broad set of abnormal behaviors from system audit logs, which is orthogonal to the computing paradigms of the underlying stream processing systems.System Entities and Data Reduction: Our current data model focuses on files, processes, and network connections. Gao et al. [50] proposed AIQL which enables efficient attack investigation by querying historical system audit logs stored in databases. Unlike these techniques, which focus on finding effective features and building specific models under different scenarios, SAQL provides a unified interface to express anomalies based on domain knowledge of experts. However, they do not support stateful anomaly models as our SAQL system does, which are far more complex than data aggregation.Other System Analysis Languages: Splunk [21] and Elasticsearch [10] are platforms that automatically parse general application logs, and provide a keyword-based search language to filter entries of logs. https://sites.google.com/site/saqlsystem/. https://www.paessler.com/press/pressreleases/top 5 causesof sudden spikes in traffic. Appendix A SAQL Queries in Attack Cases StudyWe present the 17 SAQL queries that we construct in the case study, which are used detect the four major types of attack behaviors (Section 6.2.1). starttime, evt3.starttime 8 return p1, i1, p2, f1, p3, f2, p4, i2, evt1.starttime , evt2.starttime, evt3.starttime, evt4.starttime, evt5.starttime Query 10: apt-c4 evt1 // attacker executes osql.exe on the sql server 3 proc p3["%sqlservr.exe"] write file f1["%backup1.dmp" ] as evt2 // attacker dumps the DB content 4 proc p4["%sbblv.exe"] read file f1 as evt3 // malware reads the dump 5 proc p4 read || write ip i1[dstip="XXX"] as evt4 // malware transfers the dump to the attacker 6 with evt1 -> evt2 -> evt3 -> evt4 7 return p1, p2, p3, f1, p4, i1, evt1.starttime, evt2. starttime, evt3.starttime 8 return p1, i1, p2, f1, p3, f2, p4, i2, evt1.starttime , evt2.starttime, evt3.starttime, evt4.starttime, evt5.starttime Query 10: apt-c4 evt1 // attacker executes osql.exe on the sql server 3 proc p3["%sqlservr.exe"] write file f1["%backup1.dmp" ] as evt2 // attacker dumps the DB content 4 proc p4["%sbblv.exe"] read file f1 as evt3 // malware reads the dump 5 proc p4 read || write ip i1[dstip="XXX"] as evt4 // malware transfers the dump to the attacker 6 with evt1 -> evt2 -> evt3 -> evt4 7 return p1, p2, p3, f1, p4, i1, evt1.starttime, evt2.