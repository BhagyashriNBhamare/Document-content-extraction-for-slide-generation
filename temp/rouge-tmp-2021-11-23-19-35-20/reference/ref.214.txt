The key idea is to combine protection keys (MPKs), a feature recently added to x86 that allows protection domain switches in userspace, with binary inspection to prevent circumven-tion. For instance, isolating cryptographic keys in a network-facing service can thwart vulnerabilities like the OpenSSL Heartbleed bug [37]; isolating a managed language's runtime can protect its security invariants from bugs and vulnerabilities in co-linked native libraries; and, isolating jump tables can prevent attacks on an application's control flow.Isolation prevents an untrusted component from directly accessing the private memory of other components. Bounds checks impose overhead on the execution of all untrusted components; additional overhead is required to prevent control-flow hijacks [30], which could circumvent the bounds checks. Recent work such as Wedge, Shreds, SeCage, SMVs, and light-weight contexts (lwCs) [10,13,24,33,34] have reduced the overhead of such switching, but the cost is still substantial. Switching domain permissions requires writing the PKRU register in userspace, which takes only 11-260 cycles on current Intel CPUs, corresponding to an overhead of 0.07% to 1.0% per 100,000 switches/s on a 2.6 GHz CPU. This amounts to an overhead of at most 4.8% on the throughput of NGINX when isolating all session keys, which is up to 6.3x, 13.5x and 3x lower than the overhead of similar protection using SFI (with Intel MPX), lwCs and Intel VT-x, respectively.However, MPK by itself does not provide strong security because a compromised or malicious component can sim- ply write to the PKRU register and grant itself permission to access any component. This rewriting procedure can be integrated with a compiler or our binary inspection.ERIM is the first technique that enables efficient isolation in applications that require very high domain switching rates (~10 5 /s or more) and also spend significant time executing inside untrusted components. We evaluate our ERIM prototype on three such applications: 1) Isolating the frequently accessed session keys in a web server (NGINX), 2) isolating a managed language runtime from native libraries written in unsafe languages, and 3) efficiently isolating the safe region in code-pointer integrity [31]. Encapsulation itself requires isolating sensitive data so it cannot be accessed by untrusted code, and facilitating switches to trusted code that has access to the isolated state. We survey techniques for isolation and switching provided by operating systems, hypervisors, compilers, language runtimes, and binary rewriting, as well as other work that uses MPK for memory isolation.OS-based techniques Isolation can be easily achieved by placing application components in separate OS processes. Settings that require more frequent switches like isolating session keys or the safe region in CPI [31], however, remain beyond the reach of OS-based techniques.Mimosa [20] relies on the Intel TSX hardware transactional memory support to protect private cryptographic keys from software vulnerabilities and cold-boot attacks. Unlike ERIM, which is a general-purpose isolation technique, Mimosa specifically targets cryptographic keys, and is constrained by hardware capacity limits of TSX.Virtualization-based techniques In-process data encapsulation can be provided by a hypervisor. Control of the MMU is restricted to the monitor; compartments are de-privileged by scanning and removing exploitable MMUmodifying instructions. However, such isolation is languagespecific, relies on the compiler and runtime, and can be undermined by co-linked libraries written in unsafe languages.Software fault isolation (SFI) [47] provides memory isolation in unsafe languages using runtime memory access checks inserted by the compiler or by rewriting binaries. A compiler can use up to four bounds registers, and each register can store a pair of 64-bit starting and ending addresses. JITGuard [17], for instance, uses SGX to protect the internal data structures of a just-in-time compiler from untrusted code, thus preventing code-injection attacks. ERIM, on the other hand, provides strong isolation without relying on CFI and has lower overhead.ASLR Address space layout randomization (ASLR) is widely used to mitigate code-reuse exploits such as those based on buffer overflow attacks [43,23]. For example, as one of the isolation techniques used in CPI [31,46], a region of sensitive data is allocated at a random address within the 48-bit x86-64 address space and its base address is stored in a segment descriptor. Therefore, unlike MPK, ARM's memory domains do not support low-cost user-mode switching.MPK-based techniques Koning et al. [30] present MemSentry, a general framework for data encapsulation, implemented as a pass in the LLVM compiler toolchain. However, MemSentry's MPK instance is secure only with a separate defense against controlflow hijack/code-reuse attacks to prevent adversarial misuse of PKRU-updating instructions in the binary. Their use of MPK could be a specific use-case for ERIM, which is a more general framework for memory isolation. Unlike prior work, ERIM supports such isolation with low overhead even at high switching rates between components without requiring control-flow integrity.In the following, we focus on the case of two components that are isolated from each other within a single-threaded process. Access checks against the PKRU are implemented in hardware and impose no overhead on program execution.Changing access privileges requires writing new permissions to the PKRU register with a user-mode instruction, WRPKRU. This instruction is relatively fast (11-260 cycles on current Intel CPUs), does not require a syscall, changes to page tables, a TLB flush, or inter-core synchronization.The PKRU register can also be modified by the XRSTOR instruction by setting a specific bit in the eax register prior to the instruction (XRSTOR is used to restore the CPU's previously-saved extended state during a context switch). To this end, ERIM combines MPK with binary inspection to ensure that all executable occurrences of WRPKRU or XRSTOR are safe, i.e., they cannot be exploited to improperly elevate privilege.Background: Linux support for MPK As of version 4.6, the mainstream Linux kernel supports MPK. Page-table entries are tagged with MPK domains, there are additional syscall options to associate pages with specific domains, and the PKRU register is saved and restored during context switches. Preventing exploitation A key difficulty in ERIM's design is preventing the untrusted U from exploiting occurrences of the WRPKRU or XRSTOR instruction sequence on executable pages to elevate its privileges. To prevent such exploits, ERIM relies on binary inspection to enforce the invariant that only safe WRPKRU and XRSTOR occurrences appear on executable pages.A WRPKRU occurrence is safe if it is immediately followed by one of the following: (A) a pre-designated entry point of T, or (B) a specific sequence of instructions that checks that the permissions set by WRPKRU do not include access to M T and terminates the program otherwise. To eliminate such inadvertent occurrences, we describe a binary rewriting mechanism that rewrites any sequence of instructions containing a WRPKRU or XRSTOR to a functionally equivalent sequence without any WRPKRUs and XRSTORs. U may behave arbitrarily and may contain memory corruption and control-flow hijack vulnerabilities that may be exploited during its execution.However, ERIM assumes that the trusted component T's binary does not have such vulnerabilities and does not compromise sensitive data through explicit information leaks, by calling back into U while access to M T is enabled, or by mapping executable pages with unsafe/exploitable occurrences of the WRPKRU or XRSTOR instruction.The hardware, the OS kernel, and a small library added by ERIM to each process that uses ERIM are trusted to be secure. The OS's dynamic program loader/linker is trusted to invoke ERIM's initialization function before any other code in a new process.Side-channel and rowhammer attacks, and microachitectural leaks, although important, are beyond the scope of this work. A call gate transfers control from U to T by enabling access to M T and executing from a designated entry point of T, and later returns control to U after disabling access to M T . T's code may be invoked either by a direct call, or it may be inlined.After T has finished, the call gate sets PKRU to disable access to M T (lines 8-11). Next, the call gate checks that the PKRU was actually loaded with PKRU_DISALLOW_TRUSTED (line 12). If, as part of an attack, the execution jumped directly to line 11 with any value other than PKRU_DISALLOW_TRUSTED in eax, the program would be terminated on line 14. Efficiency A call gate's overhead on a roundtrip from U to T is two WRPKRUs, a few very fast, standard register operations and one conditional branch instruction. The inspection prevents U from mapping any executable pages with unsafe WRPKRU and XRSTOR occurrences and consists of two parts: (i) an inspection function that verifies that a sequence of pages does not contain unsafe occurrences; and, (ii) an interception mechanism that prevents U from mapping executable pages without inspection.Inspection function The inspection function scans a sequence of pages for instances of WRPKRU and XRSTOR. It also inspects any adjacent executable pages in the address space for instances that cross a page boundary.For every WRPKRU, it checks that the WRPKRU is safe, i.e., either condition (A) or (B) from Section 3.1 holds. In all cases, ERIM can identify designated entry points by looking at the symbol table and make them available to the inspection function.Condition (B) is checked easily by verifying that the WRPKRU is immediately followed by exactly the instructions on lines 12-15 of Listing 1. These instructions ensure that the WRPKRU cannot be used to enable access to M T and continue execution.For every XRSTOR, the inspection function checks that the XRSTOR is followed immediately by the following instructions, which check that the eax bit that causes XRSTOR to load PKRU (bit 9) is not set: bt eax, 0x9; jnc . Since the bpf filtering language currently has no provisions for reading the PKRU register, we rely on seccomp-bpf's SECCOMP_RET_TRACE option to notify a ptrace()-based tracer process. While ptrace() interception is expensive, note that it is required only when a program maps pages as executable, which is normally an infrequent operation.If programs map executable pages frequently, a more efficient interception can be implemented with a simple Linux Security Module (LSM) [50], which allows mmap, mprotect and pkey_mprotect system calls only from T. (Whether such a call is made by U or T is easily determined by examining the PKRU register value at the time of the syscall.) It is also fully transparent to U's code if all WRPKRUs and XRSTORs in the binary are already safe.Security We briefly summarize how ERIM attains security. The binary inspection mechanism prevents U from mapping any executable page with an unsafe WRPKRU or XRSTOR. Safe WRPKRUs and XRSTORs preserve ERIM's two security invariants (1) and (2) by design. As part of a process's initialization, before control is transferred to main(), ERIM creates a second MPK memory domain for M T in addition to the process's default MPK domain, which is used for M U . We describe here three methods of developing applications or modifying existing applications to use ERIM.The binary-only approach requires that either U or T consist of a set of functions in a dynamic link library. An additional ERIM dynamic wrapper library is added using LD_PRELOAD, which wraps the entry points with stub functions that implement the call gates and have names that indicate to the ERIM runtime the 1 typedef struct secret { 2 int number; } secret; 3 secret * initSecret() { 4 ERIM_SWITCH_T; 5 secret * s = malloc(sizeof(secret)); 6 s->number = random();7 ERIM_SWITCH_U; 8 return s; 9 } 10 int compute(secret * s, int m) { 11 int ret = 0; 12 ERIM_SWITCH_T; 13 ret = f(s->number, m); 14 ERIM_SWITCH_U; 15 return ret; 16 } Listing 2: C component isolated with ERIM valid entry points. Listing 2 demonstrates an example C program that isolates a data structure called secret (lines 1-2). Two functions, initSecret and compute, access secrets and bracket their respective accesses with call gates using the macros ERIM_SWITCH_T and ERIM_SWITCH_U. ERIM isolates secret such that only code that appears between ERIM_SWITCH_T and ERIM_SWITCH_U, i.e., code in T, may access secret. Components can have arbitrary pairwise trust relations with each other, as long as the trust relations are transitive. Each component can also (in its own code) allocate a per-thread stack, to protect stack-allocated sensitive data when calling into other untrusted domains. Stacks can be mandatorily switched by ERIM's call gates.ERIM for integrity only Some applications care only about the integrity of protected data, but not its confidentiality. When a newly compiled page is executed for the first time, ERIM handles the page execute permission fault, scans the new page for unsafe WRPKRUs/XRSTORs and enables the execute permission if no unsafe occurrences exist. ERIM-aware jit compilers can emit WRPKRU-and XRSTOR-free binary code by relying on the rewrite strategy described in Section 4, and inserting call gates when necessary.OS privilege separation The design described so far provides memory isolation. For instance, an application might need to restrict the filesystem name space accessible to U or restrict the system calls available to U.ERIM can be easily extended to support privilege separation with respect to OS resources, using one of the techniques described in Section 3.4 for intercepting systems calls that map executable pages. In the following we describe the strategy, briefly argue why it is complete, and summarize an empirical evaluation of its effectiveness.Rewrite strategy WRPKRU is a 3 byte instruction, 0x0F01EF. An x86 instruction contains: (i) an opcode field possibly with prefix, (ii) a MOD R/M field that determines the addressing mode and includes a register operand, (iii) an optional SIB field that specifies registers for indirect memory addressing, and (iv) optional displacement and/or immediate fields that specify constant offsets for memory operations and other constant operands.The strategy for rewriting an instruction depends on the fields with which the WRPKRU or XRSTOR subsequence overlaps. Whenever codegen outputs an inadvertent WRPKRU or XRSTOR, the surrounding instructions in the IR can be replaced with equivalent instructions as described above, and codegen can be run again.Runtime binary rewriting For binaries that cannot be recompiled, binary rewriting can be integrated with the interception and inspection mechanism (Section 3.4). Later, if there is a jump into the executable page, a trap occurs and the trap handler discovers an entry point into the page.The rewriter then disassembles the reserved page from that entry point on, rewriting any discovered WRPKRU or XRSTOR occurrences, and copies the rewritten instruction sequences back to the executable page. Isolating cryptographic keys in web servers Isolating long-term SSL keys to protect from web server vulnerabilities such as the Heartbleed bug [37] is well-studied [33,34]. To verify this, we partitioned OpenSSL's low-level crypto library (libcrypto) to isolate the session keys and basic crypto routines, which run as T, from the rest of the web server, which runs as U.Native libraries in managed runtimes Managed runtimes such as a Java or JavaScript VM often rely on third-party native libraries written in unsafe languages for performance. Since the evaluated applications use these operations infrequently, the impact on their overall performance is negligible.Our implementation also includes the ERIM runtime library, which provides a memory allocator over M T , call gates, the ERIM initialization code, and binary inspection. Unless otherwise mentioned, we perform our experiments on Dell PowerEdge R640 machines with 16-core MPK-enabled Intel Xeon Gold 6142 2.6GHz CPUs (with the latest firmware; Turbo Boost and SpeedStep were disabled), 384GB memory, 10Gbps Ethernet links, running Debian 8, Linux kernel v4.9.60. For reference, the table also includes the cost of a simple syscall (getpid), the cost of a switch on lwCs, a recent isolation mechanism based on kernel page table protections [33], and the cost of a VMFUNC (Intel VT-x)-based extended page table switch.In our microbenchmark, calls with an ERIM switch are be- Table 2: Cycle counts for basic call and return tween 55 and 80 cycles more expensive than their no-switch counterparts. We modified OpenSSL's libcrypto to isolate all session keys and the functions for AES key allocation and encryption/decryption into ERIM's T, and use ERIM call gates to invoke these functions.To measure ERIM's overhead on the peak throughput, we configure a single NGINX worker pinned to a CPU core, and connect to it remotely over HTTPS with keep-alive from 4 concurrent ApacheBench (ab) [3] instances each simulating 75 concurrent clients. The free CPU cycles absorb ERIM's CPU overhead, so ERIM's throughput matches that of the baseline.Note that this is an extreme test case, as the web server does almost nothing and serves the same cached file repeatedly. This corresponds to a total overhead of 2.7%, or about 0.43% for 100,000 switches a second.Scaling with multiple workers To verify that ERIM scales with core parallelism, we re-ran the first experiment above with 3, 5 and 10 NGINX workers pinned to separate cores, and sufficient numbers of concurrent clients to saturate all the workers. The numbers are consistent with an average overhead between 0.07% and 0.41% for 100,000 switches/s. In all, we modified 300 LoC in LLVM's CPI/CPS pass.Like the original CPI/CPS paper [31], we compare the overhead of the original and our ERIM-protected CPI/CPS system on the SPEC CPU 2006 CINT/FLOAT benchmarks, relative to a baseline compiled with Clang without any protection. Table 6: Domain switch rates of selected SPEC CPU benchmarks and overheads for ERIM-CPI without binary inspection, relative to the original CPI with ASLR.CPI: The geometric means of the overheads (relative to no protection) of the original CPI and ERIM-CPI across all benchmarks are 4.7% and 5.3%, respectively. From the table, we see that the high overheads on gcc, omnetpp and xalancbmk are due to extremely high switching rates on these three benchmarks (between 1.6 × 10 7 and 8.9 × 10 7 per second). In this section, we compare ERIM to isolation using SFI (with Intel MPX), extended page tables (with Intel VTx/VMFUNC), kernel page tables (with lwCs), and instrumentation of untrusted code for full memory safety (with WebAssembly). We place OpenSSL (trusted) in a designated memory region, and use MemSentry [30] to compile all of NGINX (untrusted) with MPX-based memory-bounds checks that prevent it from accessing the OpenSSL region directly. While this is theoretically true, in this experiment, we already observe extremely high switch rates of 1.2M/s (for file size 0kb) and, even then, MPX's overhead is 8.4x that of ERIM's overhead.Further, as explained earlier, for strong security, SFI must be supported by control-flow integrity, which would induce additional overheads that are not included here.Extended page tables (VMFUNC) Next, we compare ERIM to isolation based on extended page tables (EPTs) using Intel VT-x and VMFUNC. Figure 3b shows the throughput of NGINX protected with VMFUNC and emulated ERIM, relative to a baseline with no protection for different file sizes (we use Linux kernel v3.16). Across different file sizes, this varies from 1.4%-1.87% for 100,000 switches/s. Actual ERIM's switch overhead during the similar experiment of Section 6.2 is no more than 0.44% across all file sizes, which is two orders of magnitude lower than that of lwCs.Memory safety (WebAssembly) Finally, we compare ERIM's overheads to those of full memory safety on untrusted code. Specifically, we execute a loop five times, with xor eax,ecx; xor ecx,eax; xor eax,ecx, followed by a single RDTSCP after the loop.To validate the emulation we re-ran the SPEC CPU 2006 benchmark with CPI/CPS (Section 6.4) after swapping actual WRPKRU instructions with the emulation sequence shown above and compared the resulting overheads. ERIM's overall overhead is lower than that of isolation based on memory-bounds checks (with Intel MPX), even at switch rates of the order of 10 6 /s. Additionally, such techniques require control-flow integrity to provide strong security, which has its own overhead.