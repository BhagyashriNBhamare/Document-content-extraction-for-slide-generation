The software development community is adopting the Event-Driven Architecture (EDA) to provide scal-able web services, most prominently through Node.js. Our Node.cure prototype defends Node.js applications against all known EHP attacks with overheads between 0% and 24% on real applications. Over the past decade, this goal has led the software community to consider shifting from the One Thread Per Client Architecture (OTPCA) used in Apache to the Event-Driven Architecture (EDA) championed by Node.js.Perhaps inspired by Welsh et al.'s Scalable EventDriven Architecture (SEDA) concept [97], server-side EDA frameworks such as Twisted [24] have been in use since at least the early 2000s. While the OTPCA gives every client its own thread at the cost of contextswitching overheads, the EDA multiplexes many clients onto a small number of Event Handlers (threads) to reduce per-client overheads. Just as OutOfBoundsErrors allow applications to detect and react to buffer overflow attacks, so TimeoutErrors allow EDA-based applications to detect and react to EHP attacks.Our Node.cure prototype ( §5) implements first-class timeouts in the Node.js framework. We have developed a guide for practitioners on building EHP-proof systems, updated the Node.js documentation to warn developers about the perils of several APIs, and improved the safety of the fs.readFile API.In summary, here are our contributions:1. We define Event Handler Poisoning (EHP), a DoS attack against EDA-based applications ( §3). We implement and evaluate Node.cure, a prototype of first-class timeouts for Node.js ( §5). The Event-Driven Architecture (EDA) tries the opposite approach and reverses these tradeoffs, with many clients sharing execution resources: client connections are multiplexed onto a single-threaded Event Loop, with a small Worker Pool for expensive operations. The Event Loop may offload expensive tasks such as file I/O to the queue of a small Worker Pool, whose workers execute tasks and generate "task done" events for the Event Loop when they finish [60]. We refer to the Event Loop and the Workers as Event Handlers.Because the Event Handlers are shared by all clients, the EDA requires a particular development paradigm. For example, with reference to Figure 1, a callback might perform some string operations in CB A1 , then offload a file I/O to the Worker Pool in Task A1 so that another client's request can be handled on the Event Loop. These frameworks have been used to build a wide variety of industry and open-source services (e.g. [7,82,67,78,29,28,8,4]). An application's JavaScript code is executed using Google's V8 JavaScript engine [64], the event-driven architecture is implemented using libuv [10], and Node.js has core JavaScript libraries with C++ bindings for system calls. In an AC attack, a malicious client crafts input that shifts the performance of the victim service's data structures and algorithms from average-case to worst-case, reducing throughput to cause denial of service. In this section we provide our threat model ( §3.1) and define Event Handler Poisoning (EHP) attacks ( §3.2). The attacker knows how to exploit this vulnerability: they know the victim feeds user input to a vulnerable API, and they know evil input that will cause the vulnerable API to block the Event Handler executing it.Not all DoS attacks are EHP attacks. This blocking could be due to computation or I/O, provided it takes the Event Handler a long time to handle. Consequently, we define a lifeline's total time and synchronous time analogously.If there is a difference between a lifeline's average and worst-case synchronous complexity (time), then we call this a vulnerable lifeline 2 . The attacker identifies a vulnerable lifeline (server API) and poisons the Event Handler that executes the corresponding large-complexity callback or task with evil input. Based on typical Worker Pool sizes, we assume the Worker Pool is small enough that poisoning it will not attract the attention of network-level defenses.Since the EDA relies on cooperative multitasking, a lifeline's synchronous complexity (time) provide theoretical and practical bounds on how vulnerable it is. Note that a lifeline with large total complexity (time) is not vulnerable so long as each vertex (callback/task) has small synchronous complexity (time). In the OTPCA, a blocked client affects only its own thread, and frameworks such as Apache support thousands of "Event Handlers" (client threads) [61]. In the EDA, all clients share one Event Loop and a limited Worker Pool; for example, in Node.js the Worker Pool can contain at most 128 Workers [17]. Figure 3 shows the impact of EHP attacks on baseline Node.js, as well as the effectiveness of our Node.cure prototype. On baseline Node.js these attacks result in complete DoS, with zero throughput. When attacked, Node.cure's throughput dips until a TimeoutError aborts the malicious request(s), after which its throughput temporarily rises as it bursts through the built-up queue of pending events or tasks.only remedy would be to restart the server, dropping all existing client connections. With Node.cure the server can return to its steady-state performance.The architecture-level behavior of the ReDoS attack is illustrated in Figure 1. We examined the vulnerabilities in npm modules reported in the database of Snyk.io [22], a security company that monitors open-source library ecosystems for vulnerabilities. Some of the reported security vulnerabilities could be used to launch EHP attacks: Directory Traversal vulnerabilities that permit arbitrary file reads, Denial of Service vulnerabilities (those that are CPU-bound, e.g. ReDoS), and Arbitrary File Write vulnerabilities. Figure 4 shows the distribution of vulnerability types, absorbing categories with fewer than 20 vulnerabilities into the aforementioned "Other" category. A high-level CWE number is given next to each class.The dark bars in Figure 4 show the 403 vulnerabilities (35%) that can be employed in an EHP attack under our threat model ( §3.1). For example, a developer could partition every API into a sequence of Constant Worst-Case Execution Time stages. Instead of statically bounding an API's synchronous complexity through program refactoring, using timeouts we can dynamically bound its synchronous time. In this approach, the runtime detects and aborts long-running callbacks and tasks by emitting a TimeoutError, thrown from synchronous code (callbacks) and returned from asynchronous code (tasks). The other class of timeouts is on a per-process or per-thread basis. Because of this, timeouts must be a first-class member of an EDA framework, non-destructively guaranteeing that no Event Handler can block. The difficulty with timeouts is choosing a threshold [85], since a too-generous threshold still permits an attacker to disrupt legitimate requests. As the composition of safe APIs may be vulnerable 5 , application 5 For example, consider while(1){}, which makes an infinite sequence of constant-time language "API calls". The partitioning approach is by definition case-by-case, so future development and maintenance would need to preserve the bounds required by the service.For timeouts, we perceive a lower refactoring cost. Just as modern languages offer null pointer exceptions and buffer overflow exceptions to protect against common security vulnerabilities, so too should modern EDA frameworks offer timeout exceptions to protect against EHP attacks.In the remainder of the paper we describe our design, implementation, and evaluation of first-class timeouts in Node.js. For practicality, monitoring for timeouts must be lightweight, lest they cost more than they are worth.Here is the desired behavior of first-class timeouts. The long-running task is returned to the Event Loop with a TimeoutError for processing, while the new Worker resumes handling tasks. The libuv library exposes a task submission API uv queue work, which we extended as shown in Table 2. This is also the typical behavior of our timeout-aware Workers. If the submitter does not request an extension, the Manager creates a replacement Worker so that it can continue to process subsequent tasks, creates a Hangman thread for the poisoned Worker, and notifies the Event Loop that the task timed timeout-aware Worker Pool, including the roles of Event Loop, executors (both worker pool and priority), and Hangman. Concurrently, once the Hangman successfully kills the Worker thread, it invokes the task's killed callback for resource cleanup, and returns. We used synchronization primitives to prevent races when a task completes just after it is declared timed out. We addressed the dangling worker problem in Node.js's Worker Pool customers using a mix of killed-waiting, message passing, and blacklisting.Affected APIs. Handling encryption and compression was straightforward, while the DNS and file system APIs were more complex.Node.js's asynchronous encryption and compression APIs are implemented in Node.js C++ bindings by invoking APIs from openssl and zlib, respectively. We time out JavaScript instructions using V8's interrupt mechanism ( §5.3.1), and we modify Node.js's C++ bindings to ensure that callbacks that enter these bindings will also be timed out ( §5.3.2). The watchdog then starts another timer, ensuring that recursive timeouts while handling the previous TimeoutError are also detected.While an infinite sequence of TimeoutErrors is possible with this approach, this concern seems more academic than practical 6 . Timeouts require the use of a high priority interrupt because they must be able to interrupt long-running individual JavaScript instructions such as str.match(regexp) (possible ReDoS). To support a TimeoutError, we modified V8 as follows: (1) We added the definition of a TimeoutError into the Error class hierarchy; (2) We added a TimeoutInterrupt into the list of high-priority interrupts; and (3) We added a V8 API to raise a TimeoutInterrupt. A separate effort is required here because a pending TimeoutError triggered by the TimeoutWatchdog will not be delivered until control returns from a C++ binding to JavaScript.Node.js has asynchronous and synchronous C++ bindings. We opted to combine these approaches by offloading the work in vulnerable synchronous framework APIs to a dedicated Worker, which can be safely killed and whose queue never has more than one item.In our implementation, we extended the Worker Pool paradigm with a Priority Executor whose queue is exposed via a new API: uv queue work prio (Fig- ure 5). As described above, Node.cure makes tasks ( §5.2) and callbacks ( §5.3) timeout-aware to defeat EHP attacks against language and framework APIs. These bindings would need to be made timeout-aware, following the example we set while making Node.js's vulnerable C++ bindings timeout-aware (file system, DNS, encryption, and compression). In contrast, the evil inputs that trigger I/O-bound EHP attacks such as ReadDoS must name a particularly slow resource, presenting an opportunity to short-circuit requests on this slow resource.In Node.cure we implemented a slow resource management policy for libuv's file system APIs, targeting those that reference a single resource (e.g. open, read, write). We took the simple approach of permanently blacklisting these aliases by aborting subsequent accesses 8 , with the happy side effect of solving the dangling worker problem for write. This policy is appropriate for the file system, where access times are not likely to change 9 . Our prototype is for Linux, and we added 4,000 lines of C, C++, and JavaScript code across 50 files spanning V8, libuv, the Node.js C++ bindings, and the Node.js JavaScript libraries.Node.cure passes the core Node.js test suite, with a handful of failures due to bad interactions with experimental or deprecated features. Node.cure guarantees EHP-safety to all Node.js applications that do not define their own C++ bindings.All measurements provided in this section were obtained on an otherwise-idle desktop running Ubuntu 16.04.1 (Linux 4.8.0-56-generic), 16GB RAM, Intel i7 @3.60GHz, 4 physical cores with 2 threads per core. Our suite could be used to evaluate alternative defenses against EHP attacks.To evaluate any difficulties in porting real-world Node.js software to Node.cure, we ported the node-oniguruma [12] npm module.This module offloads worst-case exponential regular expression queries from the Event Loop to the Worker Pool using a C++ add-on. Every time V8 checks for interrupts, it now tests for a pending timeout as well. Both the precise and lazy versions of the TimeoutWatchdog require instrumenting every asynchronous callback using async-hooks, with relative overhead dependent on the complexity of the callback. Our micro- Overheads LokiJS [11] Server, Key-value store 1.00, 1.00 Node Acme-Air [3] Server, Airline simulation 1.03, 1.02 webtorrent [26] Server, P2P torrenting 1.02, 1.02 ws [27] Utility, websockets 1.00, 1.00* Three.js [23] Utility, graphics library Table 3: Results of our macro-benchmark evaluation of Node.cure's overhead. Applications that make little use of the Worker Pool will pay the overhead of the additional V8 interrupt check (minimal) and the TimeoutWatchdog's async hooks, whose cost is strongly dependent on the number of instructions executed in the callbacks. To add additional complete servers, we also included LokiJS [11], a popular key-value store, and IBM's AcmeAir airline simulation [3], which is used in the Node.js benchmark suite. Matching our micro-benchmark assessment of the TimeoutWatchdog's overhead, the overhead from Node.cure increased as the complexity of the callbacks used in the macrobenchmarks decreased -the middleware benchmarks sometimes used empty callbacks to handle client requests. As only 0.7% of npm modules define C++ bindings, we conclude that C++ bindings are not widely used and that they thus do not represent a serious limitation of our approach. First, we published a guide on safe service architecture for Node.js on nodejs.org. They do not advise developers on the design of Node.js applications, which as we have discussed must fit the EDA paradigm and avoid EHP vulnerabilities.We prepared a guide to building EHP-safe EDAbased applications, including discussions about appropriate work patterns and the risks of high-complexity operations.The pull request with the guide was merged after discussion with the community. First, we proposed documentation patches warning developers against submitting large requests to these APIs, e.g. "The asynchronous version of crypto.randomBytes() is carried out in a single threadpool request. First-class timeouts will protect against this class of attacks as it does ReadDoS.Programming with first-class timeouts. First, developers must choose a timeout threshold. Timeouts in other contexts have been shown to be selected without much apparent consideration [85], but for first-class timeouts we suggest that a good choice is relatively easy. If a tight timeout can be assigned, then a malicious request trying to trigger EHP will get about the same amount of server time as a legitimate request will, before the malicious request is detected and aborted with a TimeoutError. Appropriate coarse or fine-grained timeout thresholds could also be suggested automatically or tuned over the process lifetime of the server.If a tight timeout cannot be assigned, perhaps because there is significant natural variation in the cost of handling legitimate requests, then we recommend that the TimeoutError exception handling logic incorporate a blacklist. Promise chains permit catch-all handling of exceptions thrown from any link in the chain, so existing catch-all handlers can be extended to handle a TimeoutError.Detecting EHP attacks without first-class timeouts. In contrast, first-class timeouts will produce a TimeoutError at some point during the handling of the malicious request, permitting exception handling logic to easily respond by dropping the client and, perhaps, adding them to a blacklist.Other avenues toward EHP-safety. However, each of these is a variation on the same theme: dedicating isolated execution resources to each client, a road that leads to the One Thread Per Client Architecture. Their analysis included ReDoS and other expensive computation as a means of blocking the event loop, though they overlooked the risks of I/O and the fact that the small Worker Pool makes its poisoning possible. Our preliminary work [52] sketched EHP attacks and advocated Constant Worst-Case Execution Time partitioning as a solution. In addition, moving modules to separate processes in order to handle EHP attacks incurs significant performance overheads at start-up and larger performance overheads than Node.cure at run-time, and places more responsibility on developers to understand implementation details in their dependencies.Static analysis can be used to identify a number of vulnerabilities in JavaScript and Node.js applications. Guarnieri and Livshits demonstrated static analyses to eliminate the use of vulnerable language features or program behaviors in the client-side context [65]. Our first-class timeouts approach is instead a dynamic detect-and-respond defense against EHP attacks.More broadly, other research on the EDA has studied client-side JavaScript/Web [71,69,54,76] and Java/Android [59,58,43,68,72] applications. Wandschneider suggests worst-case linear-time partitioning on the Event Loop [96], while Casciaro advises developers to partition any computation on the Event Loop, and to offload computationally expensive tasks to the Worker Pool [47]. Everything needed to reproduce our results is available at https://github.com/VTLeeLab/node-cure -scripts for our analysis of the Snyk.io vulnerability database, links to our contributions to the Node.js community, and the source code for the Node.cure prototype. J.D. Greef of Ronomon suggested the EHP attacks listed in the discussion.