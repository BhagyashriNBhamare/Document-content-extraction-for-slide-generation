In response to these challenges, recent research [11,41,48] and industry efforts [1,2,35,43] developed Trusted Execution Environments (TEEs) that feature an alternative, non-hierarchical protection model for isolated application compartments called enclaves. Besides strong memory isolation, TEEs typically offer an attestation primitive that allows local or remote stakeholders to cryptographically verify at runtime that a specific enclave has been loaded on a genuine (and hence presumed to be secure) TEE processor.With the announcement of Intel's Software Guard eXtensions (SGX) [2,27,43] in 2013, hardware-enforced TEE isolation and attestation guarantees are now available on off-the-shelf x86 processors. At its core, Foreshadow abuses the same processor vulnerability as the recently announced Meltdown [40] attack, i.e., a delicate race condition in the CPU's access control logic that allows an attacker to use the results of unauthorized memory accesses in transient out-of-order instructions before they are rolled back. • We extract full cryptographic keys from Intel's architectural enclaves, and demonstrate how to (i) bypass enclave launch control; and (ii) forge local and remote attestations to completely break confidentiality plus integrity guarantees for remote computations.Current Status. This separation of responsibilities ensures that enclave-private memory can never be accessed from outside, while untrusted system software remains in charge of enclave memory management (i.e., allocation, eviction, and mapping of pages). Any attempt to directly access private pages from outside the enclave, on the other hand, results in abort page semantics: reads return the value -1 and writes are ignored.SGX furthermore protects enclaves against motivated adversaries that exploit Rowhammer DRAM bugs, or resort to physical cold boot attacks. A secure, mutually authenticated cryptographic channel can be established by means of an application-level protocol that leverages the above local attestation hardware primitives.Likewise, enclaves can invoke egetkey to generate "sealing keys" based on either the calling enclave's content-based or developer-based identity. Specifically, Intel provides (i) a launch enclave that gets to decide which other enclaves can be run on the platform, (ii) a provisioning enclave to initially supply the long-term platform attestation key, and (iii) a quoting enclave that uses the asymmetric platform attestation key to sign local attestation reports for a remote stakeholder.To regulate enclave development, Intel SGX distinguishes debug and production enclaves at creation time. When combined with a state-of-the-art enclave execution control framework, such as SGX-Step [57], our root attack can essentially dump the entire memory and register contents of a victim enclave at any point in its execution.Breaking SGX Sealing and Attestation. In case of Intel SGX, this may lead to an increased CPU security version number.Micro-operations furthermore enable superscalar processor optimization techniques stemming from a reduced instruction set philosophy. Second, hardware exceptions and interrupts are guaranteed to be "always taken in the 'inorder' instruction stream" [27], which implies that all transient µop results originating from out-of-order instructions following the faulting instruction should be rolled-back as well.CPU Cache Organization. In multi-way, set-associative caches, a cache line is located by first using the lower bits of the (physical) memory address to locate the corresponding cache set, and thereafter using a tag to uniquely identify the desired cache line within that set.Since CPU caches introduce a measurable timing difference for DRAM memory accesses, they have been studied extensively in side-channel analysis research [16]. The example uses a reliable FLUSH+RELOAD [61] covert channel, where the transient instruction sequence loads a predetermined "oracle" memory location into the cache, dependent on the least significant bit of the kernel data just read. However, as explained below and further explored in Appendix A, targeting enclaved execution also presents substantial challenges, for SGX's modified memory access and non-terminating fault semantics reflect extensive microarchitectural changes that affect transient execution.We first present our basic approach for reading cached enclave secrets from the unprivileged host process, and thereafter elaborate on various optimization techniques to increase the bandwidth and success rate of our attack for unprivileged as well as root adversaries. We suspect that SGX's modified memory access semantics bring about fundamental differences at the microarchitectural level, such that the CPU's access control logic does not pass the results of unauthorized enclave memory loads unless they can be served from the L1 cache. As such, in the absence of an exception, the race condition does not apply and any (transient) instructions following the rogue data fetch will never see the actual enclave secret, but rather the abort page value.Foreshadow overcomes this challenge by taking advantage of previous research results on page table-based enclaved execution attacks [58,60]. In our running example, we proceed by revoking 3 all access permissions to the enclave page we wish to read: 1 mprotect( secret_ptr &~0xfff, 0x1000, PROT_NONE );We verified that the above mprotect system call simply clears the "present" bit in the corresponding page table entry, such that any access to this page now (eventually) leads to a fault. We experimentally verified that such faults can be successfully exploited by an attacker enclave that transiently dereferences a victim enclave's pages via a malicious memory mapping. That is, an adversary executing Phases II and III of the basic Foreshadow attack should avoid inadvertently evicting enclave secrets that were originally brought into the L1 CPU cache during the enclaved execution in Phase I. When untrusted code accesses enclave memory, abort page semantics apply and secrets do not reach the transient execution. While the transaction's write set is discarded, we did not notice any difference in the read set.That is, accessed oracle slots remain in the L1 cache.Note that, while readily available on many processors, TSX is by no means the only fault suppression mechanism that attackers could leverage. That is, by transiently accessing the enclave secret each time before we reload an oracle slot, we ensure the cache line holding the secret data remains "warm" and is less likely to be evicted by the CPU's least recently used cache replacement policy. Likewise, since L1 and L2 caches are shared among logical processors, cache activity on one core might unintentionally evict enclave secrets on its sibling core.In order to limit such effects, root adversaries can pin the victim enclave process to a specific core, and offload interrupts as much as possible to another physical core.Dealing with Zero Bias. To counteract this zero bias, Foreshadow retries the transient execution Phase II multiple times when receiving 0x00 in Phase III, before decisively concluding the secret byte was indeed zero.Since Foreshadow's transient execution phase critically relies on the enclave data being in the L1 cache, we consistently receive 0x00 bytes from the moment a secret cache line was evicted from the L1 cache. This property has recently been abused to mount stealthy SGX PRIME+PROBE L1 cache side-channel attacks entirely from a co-resident logical processor, without interrupting the victim enclave [6,17,51]. Specifically, we found that the bandwidth for concurrently extracting secrets is severely restricted, since each Foreshadow round needs 256 time-consuming FLUSH+RELOAD measurements in order to transfer one byte from the microarchitectural state (Phase II) to the architectural state (Phase III). For this, untrusted operating systems can make use of the privileged ewb and eldu SGX instructions that respectively copy encrypted and integrityprotected 4 KiB enclave pages out of, and back into EPC.We observed that, when decrypting and verifying an encrypted enclave page, the eldu instruction loads the entire page as plaintext into the CPU's L1 cache. As further discussed in Section 6, this attacker capability effectively rules out software-only mitigation strategies that force data to be directly stored in memory while deliberately evading the CPU cache hierarchy. Some attack optimizations, such as page aliasing or isolating workloads, can therefore not be applied.We assess the effectiveness of Foreshadow by attacking a specially crafted benchmark enclave containing a 4 KiB memory page filled with randomized data. We attribute this effect to unintended L1 cache line evictions from (i) the remaining enclaved execution after loading the secret into the cache (e.g., eexit); and (ii) our own attack measurement code (e.g., probing of the oracle buffer in Phase III). For example, even though private memory should never leak from enclaves, sensitive data gets overwritten as soon as possible.To the best of our knowledge, we are the first to present full key extraction attacks against Intel's vetted architectural enclaves. This shows that Foreshadow is substantially more powerful than previous enclaved execution attacks that rely on either side-channels or memory safety bugs.Note that, for maximum reliability, both our attacks against Intel's architectural launch and quoting enclaves assume the root adversary model, and apply all of the optimization techniques described in Section 3.2. For this, the trusted in-enclave runtime allocates a temporary buffer, before calling 2 a small do_egetkey assembly stub that executes the egetkey instruction to derive 3 the actual launch key. We observed a 100% success rate in practice; that is, our final (online) exploit extracts the full 128-bit key without noise, from a single LE run with only 13 page faults in total -without resorting to the single-stepping or eldu prefetching techniques of Sections 3.3 and 3.5. The rogue launch token provider transparently creates tagged EINITTOKENs using a previously extracted key, and includes the corresponding (non-secret) KEYID, such that einit derives an identical launch key from the platform master secret. The Intel SGX design therefore includes a trusted Quoting Enclave (QE) [2,10] to validate local attestation reports, and sign them with an asymmetric private key. In an initial platform configuration phase A , Intel deploys a dedicated Provisioning Enclave (PE) to request an EPID private key, from here on referred to as the platform attestation key, from the remote Intel Provisioning Service. That is, our exploit reliably extracts the full 128-bit report and provisioning seal keys from a single QE run suffering 14 page faults in total.We validated the correctness of the extracted keys by fabricating bogus local attestation reports, using a previously extracted QE report key, and successfully ordering the genuine Intel QE to sign them. Using our rogue quoting service, a networklevel adversary (e.g., the untrusted host application) can trivially establish a man-in-the-middle position to read plus modify all traffic between a victim enclave and a remote party. Indeed, page table isolation mitigations are ruled out, for SGX explicitly distrusts the operating system kernel, and enclaves live within the address space of an untrusted host process.We want to emphasize that Foreshadow exploits a microarchitectural implementation bug, and does not in any way undermine the architectural design of Intel SGX and TEEs in general. Finally, we showed how to abuse SGX's eldu instruction to extract enclaved memory secrets without even executing the victim enclave, effectively rendering any software-only defense strategy inherently insufficient.Only Intel is placed in a unique position to patch hardware-level CPU vulnerabilities. Importantly, in contrast to Foreshadow, all known attacks explicitly fall out-of-scope of Intel SGX's threat model [28,33], and can be effectively avoided by rewriting the victim enclave's code to exclude such vulnerabilities.Conventional microarchitectural side-channels [16] are, however, considerably amplified in the context of SGX's strengthened attacker model. We contributed practical attacks against Intel's trusted architectural enclaves, essentially dismantling SGX's local and remote attestation guarantees as well.While, in the absence of a microcode patch, current SGX versions cannot maintain their hardware-level security guarantees, Foreshadow does assuredly not undermine the non-hierarchical protection model pursued by trusted execution environments, such as Intel SGX.1 void load_in_L2( uint64_t * secret ) { 2 asm volatile ( "mfence\n" ); enclave secrets to secondary cache levels or even to main memory. As edbgrd may inadvertently move enclave data to caches closer to the processor, we only perform this additional verification step after the actual Foreshadow attack attempt.We carefully benchmarked the access times for enclave secrets residing in L1, L2, and main memory. Out of the 98,610 remaining attack attempts, none succeeded in speculatively loading a secret-dependent oracle buffer slot in the transient execution phase.To rule out the possibility that the transient instructions may need more attempts to elevate the enclave secret from the L2 to the L1 cache, we ran the same benchmark with 1,000 repeated transient executions before actually reloading the oracle buffer. When applying Foreshadow against kernel data, we could indeed trivially extract kernel secrets from the L2 cache without noticing a significant success rate drop.We conclude that both Meltdown and Foreshadow exploit a similar race condition vulnerability in the CPU's out-of-order pipeline behavior, but Intel SGX's abort page semantics apparently have a profound microarchitectural impact. Unfortunately returning execution control from the enclave (eexit), may inadvertently evict In this appendix, we provide experimental evidence that Foreshadow requires enclaved data to be present in the L1 CPU cache. Future references to these addresses only hit the L2 cache, which still holds their original value.Listing 3 displays how we leverage this mechanism to ensure that the secret is only present in the L2 and L3 caches.