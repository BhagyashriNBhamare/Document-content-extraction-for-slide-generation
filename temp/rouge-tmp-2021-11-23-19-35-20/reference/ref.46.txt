Security architectures such as Intel SGX need protection against rollback attacks, where the adversary violates the integrity of a protected application state by replaying old persistently stored data or by starting multiple application instances. Intel Software Guard Extensions (SGX) enables execution of security-critical application code, called enclaves, in isolation from the untrusted system software [1]. To protect enclave data across executions, SGX provides a security mechanism called sealing that allows each enclave to encrypt and authenticate data for persistent storage. Through these security mechanisms (isolation, sealing, attestation) SGX enables development of various applications and online services with hardened security.The architecture has also its limitations. If the adversary manages to revert the enclave to its previous state, the maintained account balance or the queried transaction history does not match the executed transactions.To address rollback attacks, two basic approaches are known. Similar limitations also apply to rollback protection techniques that leverage Trusted Platform Modules (TPMs) [2,4,3]. Server replication using standard Byzantine consensus protocols [9] avoids a single point of failure, but requires high communication overhead and multiple replicas for each faulty node.In this paper we propose a new approach to protect SGX enclaves from rollback attacks. Later, when the enclave needs to recover its state, it obtains counter values from assisting enclaves to verify that the recovered state data is of the latest version.We consider a powerful adversary that controls the OS on the target platform and on any of the assisting platforms. Moreover, the adversary can also create multiple instances of the same enclave on all assisting platforms and route counter writes and reads to separate instances.We design and implement a rollback protection system called ROTE (Rollback Protection for Trusted Execution). We also design a session key update mechanism to address attacks based on multiple enclave instances.Our solution achieves a strong security property that we call all-or-nothing rollback. If desired, similar to [4,2], our approach can also provide crash resilience, assuming deterministic enclaves and a slightly weaker notion of rollback prevention (the latest input can be executed twice). We implemented ROTE on SGX and evaluated its performance on four SGX machines. We introduce a new security model for reasoning about the integrity and freshness of SGX applications. Our main idea is to realize rollback protection by storing enclave-specific counters in a distributed system of collaborative enclaves on distinct nodes. We propose and implement a system called ROTE that effectively protects against rollback attacks. ROTE ensures integrity and freshness of application data in a powerful adversarial model. After that, we explain rollback attacks, limitations of known solutions, and our requirements. Our model captures the main SGX functionalities that are available on all SGX platforms.Scheduling operations. The system software can start a created enclave using its enclave identifier e. The OS can suspend the execution of an enclave. The OS can terminate the enclave execution. At termination, the enclave runtime memory is erased by the SGX architecture and the enclave instance i is rendered unusable.Storage operations. Every enclave instance i can unseal data previously sealed by an instance of the same enclave identity e.Communication operations. The read message m e identifies the enclave identity e that wrote the data.Note that remote attestation identifies the enclave identity, but not the platform identity, because the attestation protocol is either anonymous or returns clientspecific pseudonyms (see Appendix A for details). We consider information leakage from side-channel attacks a realistic threat [17,18,19], but an orthogonal problem to rollback attacks, and thus outside of our model. Based on the SGX model, the adversary can schedule enclaves and start multiple instances of the same enclave, offer the latest and previous versions of sealed data, and block, delay, read and modify all messages sent by the enclaves.The adversary cannot read or modify the enclave runtime memory or learn any information about the secrets held in enclave data. After an enclave has sealed at least two data elements s 1 ← Seal(d 1 ) and s 2 ← Seal(d 2 ), the adversary performs Terminate() and Start() to erase the runtime memory of the enclave. When the sealed data captures the state of the enclave at the time of sealing, we say that the rollback attack reverts the enclave back to its previous state.Another approach is a forking attack, where the adversary leverages two concurrently running enclave instances. Intel has recently added support for monotonic counters [5] as an optional SGX feature that an enclave developer may use for rollback attack protection, when available. We performed a detailed analysis of SGX counters and report our findings in Appendix B.To summarize, we found out that counter updates take 80-250 ms and reads 60-140 ms. The non-volatile memory used to implement the counter wears out after approximately one million writes, making the counter functionality unusable after a couple of days of continuous use. 1 Writing to NVRAM takes approximately 1 The TPM 2.0 specifications introduce high-endurance non-volatile 100 ms and the memory becomes unusable after 300K to 1.4M writes (few days of continuous use) [2]. Another approach is to leverage a trusted server to maintain state for protected applications [6,7,8]. The goal of our work is to design a rollback protection mechanism that overcomes the performance and security limitations of SGX counters and other known solutions.In particular, our solution should support unlimited and fast state updates, considering a strong adversary model without a single point of failure. The intuition behind our approach is that a single SGX platform cannot efficiently prevent rollback attacks, but the owner or the owners of SGX platforms can enroll multiple processors to assist each other. The operation returns the last written value or an empty value if no counter was previously written.When an enclave performs a security-critical state update operation (e.g., modifies an account balance or extends a transaction history), it distributes a monotonically increasing counter value over the network to a set of enclaves running on assisting processors (WriteCounter), stores the counter value to its runtime memory and seals its state together with the counter value for local persistent storage. We assume n SGX platforms that assist the target platform in rollback protection The platforms can belong to a single administrative domain or they could be owned by private individuals who all benefit from collaborative rollback protection. We model each platform using the SGX model described in Section 2.1. On the compromised SGX nodes the adversary can freely modify the runtime memory (code and data) of any enclave, and read all enclave secrets and the SGX processor keys.This adversarial model combines a standard DolevYao network adversary [10] with adversarial behaviour (Byzantine faults) on a subset of participating platforms [11,12]. However, if one of the platforms is unreachable at the time of unsealing (e.g., due to network error, maintenance or reboot), the operation would fail. In such a system, some of the assisting enclaves may have outdated counter values, and the system must ensure that only the latest counter value is ever recovered, assuming an adversary that can block messages, and partition the network by choosing which nodes are reachable at any given time.Coordinated enclave restarts. Such a recovery mechanism opens up a new attack vector. In this section we describe ROTE (Rollback Protection for Trusted Execution), a distributed system for state integrity and rollback protection on SGX. This approach provides a strong security property (no rollback to any previous state), but if the enclave crashes between the increment and store operations, the system cannot recover from the crash.The second technique is store-then-inc, where the enclave first saves its state on the disk together with the latest input value, after that increments the trusted counter, and finally performs the state update [4,2]. Consider a financial enclave that receives a request message from an external party and for each request it should create only one signed response that is randomized or includes a timestamp (sgx get trusted time [24]). A rollback protection system could even support both counter increment techniques and allow developers to choose the protection style based on their application. The ROTE system consists of a system service that we call the Rollback Enclave (RE) and a ROTE library that ASEs can use for rollback protection.When an ASE needs to update its state, it calls a counter increment function from the ROTE library. Having a separate RE increases the TCB of our system slightly, but we consider easier application development more important.The ROTE system has three configurable parameters: • n is the number of assisting platforms, • f is the number of compromised processors, and • u is the maximum number of assisting platforms that can be unreachable or non-responsive at time of state update or read for the system to proceed. As an example, a system administrator can select the desired level of security f and robustness u which together determine the required number of assisting platforms n. Alternatively, given n assisting platforms, the administrator can pick f and u. Recall that standard Byzantine consensus protocols require always at least 3 f + 1 replicas.To avoid shared-fate scenarios due to power outages or communication blockades, the participating platforms would ideally have independent or redundant power supply, battery backup, networking and OS maintenance. To establish a protection group, the group owner selects n platforms.In this section, we assume that the operating systems on these platforms are trusted at the time of system initialization (e.g., freshly installed OS). If the application scenario allows that the protection group can be established among any SGX platforms, then system initialization is possible without initially trusted operating systems using remote attestation. The purpose of this secret key for initialization is to indicate a legitimate group establishment operation and to prevent a later, parallel group creation by compromised operating systems on the same certified platforms (see Section 5). Finally, the RE creates a monotonic counter (MC), sets it to zero, and seals its state.When an ASE wants to use the ROTE system for the first time, it performs local attestation on the RE. When an ASE is ready to update its state (e.g., a financial application has received a new transaction and is ready to process it and update the maintained account balances), it starts the state update protocol shown in Fig- ure 4. (2) The RE increments a counter for the ASE, increases its own MC, and signs the MC using SK RE . (7) Upon receiving back the echo, each RE finds the self-sent echo in its memory and checks if the MC value from it matches the one in the group counter table and the one received from the target RE. (8) After receiving q final ACKs, the RE seals its own state together with the MC value to the disk. The protocol proceeds as follows:(1) Session key establishment with other nodes and update of the group configuration OfferSeal(ASEA1,seal) checkLocalASECounterTable() Figure 6: The ASE start/read protocol. This is needed to verify the freshness of unsealed state after an ASE restart or when an ASE replies to a client request asking its current state (e.g., account balance). The protocol proceeds as follows:(1) The ASE queries the OS for the sealed data. (4) To verify the freshness of its runtime state, the RE performs the steps 4-6 from the RE Restart protocol, to obtain the latest MC from the network. The group owner should be able to update the previously established group (i.e., exclude or add new nodes) without interrupting the system operation.During system initialization, the RE verifies the signed list of group member keys and seals the group configuration. Since group updates are typically infrequent, they can be protected using SGX or TPM counters.At system initialization, the RE creates a monotonic counter using SGX counter service or on a local TPM. If the application scenario allows group establishment among any SGX platforms, similar trust assumption is not needed. The group owner can attest n + 1 group members using the attestation mode that returns a pseudonym for each attested platform, establish secure channels to all group members, and distribute keys that group members use to authenticate each other. The only way to violate enclave data integrity is to reset all nodes which brings the entire group to its initial state. In many application scenarios such integrity violation is easy to detect, and we do not consider it an attack on ROTE.In the event of crashes, restarts or node unavailability, the system may fail to proceed temporarily or permanently. In Figure 7 we illustrate a state transition diagram that represents RE states during sealing, unsealing and memory reading using the secure storage functionality. If the ReadCounter() operation fails, the RE halts (Halt-1). From State 7 the execution moves to State 2 for verifying freshness if a Read() request is received, while the Write() request moves execution to State 8. OS confirmation moves the enclave to normal operation in State 7. Unsealing is successful, but counter values do not match and the RE halts (Halt-1 or Halt-2). 5 Finally, the adversary can offer any other data (OfferSeal(arbitrary)) which moves the RE to State 5 where unsealing fails and RE halts (Halt-1 or Halt-2). The RE reads the MC from the secure counter storage (if this fails, Halt-1) and compares the value to the one residing in its memory. After an RE restart, the execution proceeds to State 2. When obtaining a counter from the distributed protection group (ReadCounter), RE receives the latest value that was sent to the protection group (WriteCounter). The required quorum for responses at the time of counter writing and reading is q = f + u + 1 = n+ f +1 2 . If the counter is successfully written to q = f +u+1 nodes, there always exists at least u + 1 honest platforms in the group that have the latest counter value in the memory. If the quorum cannot be satisfied in either the state update protocol or any counter retrieval, the system enters Halt-1 and can try to perform the same operation again.Platform restarts. The number of remaining platforms is insufficient for RE recovery and the distributed system no longer provides successful MC access, but no rollback is possible (Halt-X, since there is no guarantee that the non-restarted nodes have the latest counter, thereby risking a rollback. Third, all n + 1 nodes are restarted at the same time, in which case a new system configuration has to be deployed again by the group owner to re-initialize the system (Halt-X). After that, the attacker restarts the RE on that node, which initiates the recovery procedure from the rest of the protection group. No combination of RE restarts during the state update protocol allows the target RE to complete it, unless the counter was written to q nodes. The adversary can also restart assisting REs after they have sent the final ACK which will result in successful state update, and successful state recovery of the restarted REs since a sufficient number of the assisting nodes already have the updated counter value. We conclude that the successful completion of the two-phase state update protocol guarantees that at least q nodes received and at least u + 1 honest nodes have (i.e., correctly stored) the correct MC.Forking attacks. After every RE start, keys have to be established with all nodes from the protection group to prevent the attacker from instantiating new REs on different platforms in a one-by-one manner while keeping some of the nodes disconnected. Also, by forcing state retrieval and freshness verification after each instantiation and for all ASE requests, the running instance on each platform will always have the latest state and highest MC, thus preventing rollback.Our system also ensures that the adversary cannot establish a parallel protection group on the same platforms and re-direct ASEs to the rogue system causing a rollback. If the target RE is not able to recover the latest MC, the system end ups in either Halt-1, Halt-2 or Halt-X. The total TCB accounts for 1100 LoC.The enclaves use asymmetric cryptography for signing (ECDSA) and encryption (256-bit ECC). The delays depends on the network characteristics and the size of the protection group (n + 1). The first figure shows ROTE performance for protection groups that are connected over a local network, the second figure shows the simulated performance for a larger group also over a local network, while the third figure is for geographically distributed protection groups.Experimental setup. Our first experimental setup consisted of four SGX laptops and our second experimental setup consisted of 20 identical desktop computers, both connected via local network (1Gbps, ping ≤ 1ms). The required processing time of the state update protocol is less than 0.6 ms, where the creation of the first protocol message takes 0.51 ms (signing). Figure 9a shows that the state update delay was approximately 2 ms, while the state read delay was approximately 1.3 ms for group sizes from two to four nodes using the ROTE implementation. Table 1: Example application throughput without rollback protection, using ROTE and using SGX counters. Second, if the nodes are connected over a lowdelay network, ROTE supports applications requiring very fast state updates (1-2 ms). We tested the enclave using (a) no rollback protection, (b) the ROTE implementation, and (c) SGX counter based rollback protection. In all three cases the ROTE system provides significantly better state update performance than using SGX counters (e.g., 190 over 6 tx/s for 1KB) while suffering a 20-25% performance drop in comparison to systems which have no rollback protection (e.g., 260 over 190 tx/s for 1KB). Although sealing binds encrypted enclave data to a specific processor, our solution enables data migration within the protection group. Migration is especially useful before planned hardware replacements and group updates (e.g., node removal). Also the reboot of the target platform causes an observable network pattern. This pre-computation may be done at times when the expected load is low or at system initialization depending on the specific scenario.For communication between the enclaves we use symmetric keys derived from the key agreement protocol for performance reasons, since it is computationally much less expensive. However, depending on the application scenario we could use asymmetric keys which would enable, for example, post-incident forensics. The drawback of this approach is the increase of the system security perimeter outside of the processor.Periodic check-pointing. SGX counters are also likely vulnerable to bus tapping and flash mirroring attacks [22], while in our solution the trust perimeter is the processor package.Memoir [4] also leverages TPM NVRAM for rollback protection, and therefore has similar performance limitations. Secure audit log systems [27,28,29,30] provide accountability and in particular prevent manipulation of previous log entries after the target platform becomes compromised. In our case, the adversary cannot read secrets from trusted enclaves, but it can extract keys from f compromised nodes, and additionally schedule enclaves' execution on all nodes.Several recently proposed SGX systems [40,41,42,13,43,44,45,46] consider an adversary model with an untrusted OS. The SGX security architecture guarantees that enclaves are isolated from all software running outside of the enclave, including the OS, other enclaves, and peripherals. While the evicted EPC pages are stored in the untrusted memory, SGX assures their confidentiality, integrity and freshness via cryptographic protections. Additionally, the MEE is used to protect SGX's Enclave Page Cache against physical attacks and is connected to the Memory Controller [48,1]. Once an enclave has been attested, the verifier can establish a secure channel to it using an authenticated key exchange mechanism.Sealing. In this Appendix we outline all executed experiments and evaluate the SGX counter and trusted time service.SGX counter service. We tested SGX counters on five different platforms: Dell Inspiron 13-7359, Dell Latitude This work was partly supported by the TREDISEC project (G.A. no 644412), funded by the European Union (EU) under the Information and Communication Technologies (ICT) theme of the Horizon 2020 (H2020) research and innovation programme.