We developed a browser-based analysis framework, OBSERVER, to collect and analyze click related behaviors. Using OBSERVER, we identified three different techniques to intercept user clicks on the Alexa top 250K websites, and detected 437 third-party scripts that intercepted user clicks on 613 websites, which in total receive around 43 million visits on a daily basis. We click custom user interface components (e.g., the video or audio player controls) to command various web applications.Since clicks are important in modern web applications, attackers have launched UI redressing attacks, namely Clickjacking [26], to hijack user clicks. To defend against Clickjacking, a rich collection of works has been proposed, which has shown great performance [1,3,10,15,29,30]. To increase revenue that can be made through ad clicks, malicious websites have used bots to automatically and massively send fake click traffic to the ad networks, which is known as ad click fraud [5,22,27]. Consequently, traditional bot-based ad click fraud has then become less effective.Instead of relying on click bots, attackers recently started to intercept and redirect clicks or page visits from real users to fabricate realistic ad clicks. Nevertheless, Chrome still cannot detect and prevent other possible ways to intercept user clicks, including but not limited to links modified by third-party scripts, third-party contents disguised as first-party contents, and transparent overlays.A systematic study on click interceptions is necessary to deeply understand this emerging threat to web users. First, JavaScript code can be dynamically loaded. To pinpoint the scripts truly accountable for the interception, we need to re-engineer a browser to differentiate the actions of different scripts in runtime. Monitoring hyperlink creation and modification is insufficient to catch all the click interception practices. Second, we monitor the creation and execution of JavaScript objects so that we can track down the provenance of dynamic inline JavaScript code. With this design, we can develop an automated approach to monitor the event handlers accordingly, and determine if an event handler might be used to hijack user clicks. It also helps us understand the reason why a particular user click is of the interest of a script.In this work, we developed OBSERVER, a prototype of the aforementioned analysis framework by customizing and extending the Chromium browser. In particular, we observed that some scripts tricked users into clicking their carefully crafted contents, which were usually disguised as first-party contents, or intentionally implemented as barely visible elements covering first-party elements. This facilitates our capability in automatically detecting a wide range of click interception cases on various websites. It is one type of inter-page click interception in which a malicious first-party website tricks a victim into clicking components in another website loaded in an iframe. Framebusting [29][30][31] is a well-known defense to prevent clickjacking by disallowing untrusted websites to load specified pages via an iframe. Akhawe et al. [1], however, identified that such mechanisms are not comprehensive or suffer from an unacceptable usability cost.Our research complements these studies by investigating new practices of intra-page click interception by third-party scripts, which intercept a victim's clicks on components (including iframes) within the same page/frame. Our research demonstrates a new form of link hijacking that modifies all first-party hyperlinks before the user even clicks them, and shows our system can automatically detect them.Visual Deception. Rafique et al. [28] discovered overlay ads and invisible banners in free live-streaming services. Moreover, OBSERVER is able to distinguish deceptive contents created by different scripts because of its provenance tracking capability, allowing us to detect the real culprits.Click Fraud and Click Spam. For example, Pearce et al. [27] estimated that the ZeroAccess click-fraud botnet incurred advertising losses on the order of $100,000 per day. Click spams could even lead victim users to malicious ads [16,37,39]. Lauinger et al. [14] and Retire.js [25] studied the semantics of JavaScript libraries, by considering whether hosted JavaScript libraries are outdated or have known vulnerabilities. Systems like EvilSeed [11] and Revolver [13] focus on detecting malicious web pages using content or code similarities. These studies, however, rely on the origin of a JavaScript script to determine whether it is a first-party or third-party script. Furthermore, unlike ScriptInspector, OBSERVER can track the dynamic creation of JavaScript objects and DOM elements such that it can accurately attribute hyperlink modifications and event listener registrations. OBSERVER focuses on three fundamental actions that JavaScript code might rely on to intercept clicks: 1) modifying an existing hyperlink in a page; 2) creating a new hyperlink in a page; and 3) registering an event handler to an HTML element to hook a user click. Further, OBSERVER logs the reaction (i.e., navigation) of a page after it intentionally clicks a hyperlink or an element associated with an event handler in the page, to know the URLs to which a click interceptor aims to lead a user.In the following, we first demonstrate our threat model ( §3.1). First, a script can directly assign a new value to the attribute as in a.href = url ;, or in a.attributes["href"] = url;. Second, it may also call the setAttribute() API as in a.setAttribute ("href" , url) to perform a similar operation. Note that developers may leverage APIs defined in some third-party JavaScript libraries, e.g., jQuery, to change the attribute. OBSERVER can cover all these wrapper libraries because they would still need to call the above APIs defined in the DOM standard, which is implemented by all browsers to ensure cross-browser compatibility.OBSERVER hooks all these DOM APIs to monitor modifications to the href attribute of <a> tags in the DOM. To attribute the API access to a specific script, we need to obtain the identity of the accessing JavaScript code. This kind of inline scripts that are not wrapped within a <script> tag are also compiled into separate JavaScript objects, which are identified by the unique scriptIDs.OBSERVER associates the scriptID of a script with its sourceURL, which is the URL the browser uses to load the remote JavaScript code. In short, OBSERVER considers direct and indirect approaches that a script can exploit to achieve this goal: 1) creating a hyperlink and 2) creating a script that creates a hyperlink. Specifically, JavaScript can insert a new <a> tag into the DOM tree of a web page through APIs such as document.write("<a>...</ a>") and document.createElement("a"). A script can even replace the entire element with a new element by changing the outerHTML attribute of it, e.g., a.outerHTML = '<a href="' + url + '">...</a>'. OBSERVER assigns a special initiator value-0, which represents the owner of a document-to all static elements that are built by the browser parser. Specifically, as one class of HTML elements, new <script> elements can be dynamically created by JavaScript using the same APIs for creating elements. Some strings can also be dynamically parsed as inline JavaScript code if they are defined as inline event handlers or passed in the call of APIs like window.eval("..."). To distinguish the dynamically generated script, or the child script (either an inline script or an external script), from the generating script, or the parent script (the one that generates the script), OBSERVER records the scriptID of the parent script as the parentScriptID attribute of the child script. The parentScriptID of all scripts that are initially statically embedded by the document owner is set to 0. In particular, a script may open an arbitrary URL in a new browser window/tab, or send an HTTP request in the background, when a user clicks any element it listens for. Therefore, OBSERVER aims to monitor all event listeners registered by JavaScript code in a page to identify whether they will navigate a user to a different URL according to a user click.OBSERVER first monitors event listener registration by hooking the addEventListener() API and monitoring accesses to the on-event listeners, to identify the scripts that are interested in user interactions. OBSERVER detects the bottom frame in the JavaScript call stack and further constructs and logs the navigation URL in these APIs in the shadow data store of the target element.One challenge we met in our design is that one event handler can be activated multiple times. We implement a prototype of OBSERVER in the Chromium browser (version 64.0.3282.186). The values of these attributes are kept in the hidden attribute members of the modified C++ classes. They are updated in the DOM tree only when the attributes are first accessed by JavaScript.We hook the above DOM APIs by inserting custom monitoring code in the C++ implementation of the V8 binding layer between the V8 JavaScript engine and the DOM implementation in WebKit. We describe our data collection method in §4.1, how we determine the owner and privilege of JavaScript code as well as HTML elements in §4.2, and finally how we detect three classes of click interception in §4.3. To this end, we run our analysis framework on a 64 core CPU Linux server and collect data from the Alexa top 250K websites.We collect data in two phases for each web page: 1) collecting default data right after page rendering; and 2) collecting reaction data by interacting with a rendered page. In addition, we log for each element several display properties (e.g., width, height, position, opacity, etc.) to study additional tricks that may be used to intercept user clicks (e.g., some third-party contents overlap with or appear similar to first-party contents). We disable the navigation flag in OBSERVER to deactivate real navigations that may be caused by event handlers or hyperlinks. For example, the main page of https://www.google.com/ includes scripts from its subdomain apis.google.com and its CDN domain gstatic.com. For example, a script loaded from https://static-global-s-msn-com.akamaized.net/ on https:// www.msn.com/ are inferred as a first-party script because the proper subdomain name static-global-s-msn-com contains the main domain name msn. For instance, both gstatic.com and google.com use NSs nsX.google.com, where X is a numeric value. We classify dynamic elements into two groups based on which parties their initiating scripts belong to. As discussed earlier, we do not consider click interceptions exhibited by first-party scripts as malicious.Based on how a user click could be manipulated, we categorize click interception into three classes-interception by hyperlinks, interception by event handlers, and interception by visual deception. In particular, a script can intercept user click by 1) using an existing hyperlink or creating a new hyperlink; 2) registering a click event handler with an element; and 3) manipulating the UI to deceive a user into clicking elements controlled by the script.In the following, we explain the methods to detect the three classes of click interception. Therefore, we search in the href attribute log of an anchor element the last script that modifies its value. Note that although a first-party script may modify a third-party hyperlink, we think this is legitimate because the first party as the owner of the web page is entitled to include or remove any third-party contents. However, a script listening for user click may not necessarily navigate the user to another URL. We leverage the navigation-related APIs to solve this problem.To start a new navigation, a developer needs to either call the window.open() API or change the location of the current frame. We use the same 75% relative size threshold to detect suspicious huge elements that are registered with a third-party navigation event handler and can be used to intercept user clicks. Nevertheless, we still classify such practices as click interception (but not necessarily malicious) because the users can be deceived through the visual tricks.We have identified two possible visual deceptionsmimicry, and transparent overlay. Next, we calculate a similarity score between the two groups of elements using: 1) the CSS class names of the two root nodes, which are primarily used to describe the representations of HTML elements; 2) the numbers of each kind of media tags, which indicate how media contents are implemented; and 3) the relative sizes of media contents in two groups and the sizes of the largest container nodes, which represent the visual layout of an element group.We set a threshold learned from our training phase to keep only third-party element groups that are very similar to some first-party element groups. Transparent Overlay. Further, a script can make some of its elements barely visible by setting a small value to their opacity style property. We consider it as a limitation and plan to leverage knowledge in computer vision to develop a better automated testing method in our future work.Next, we detect third-party transparent overlay element groups by comparing the opacity value collected in the display properties with a small threshold (e.g., 0.1). In this section, we first present our analysis on data collected in our web crawl ( §5.1), then characterize click interception by demonstrating how different techniques ( §5.2) are employed by which scripts ( §5.3) to intercept user clicks, and finally explain why they do it and its consequences ( §5.4). Excluding those that timed out or crashed in our data collection process, we were able to gather valid data of 228,614 (91.45%) websites. On average, a web page contains 9.04 third-party navigation URLs, pointing to 1.87 domains.We visited each of the 2M navigation URLs and recorded both the intermediate redirect URLs and the landing URL. In total, we observe that 4,178 hyperlinks on 221 websites were intercepted, which can lead a user to 2,695 distinct third-party URLs. For instance, the ad URL shortening script https://cdn.adf.ly/js/link-converter.js modified the href 6 We get the statistics using the SimilarWeb API. For example, on the website http://torrents73.ru/, the third-party script http://gynax.com/js/MjgxMw==.js created a large anchor, which encloses a huge background image. We observe that 189 first-party elements of 161 websites were added at least one third-party navigation event handler. Another example is detected on the page http://azasianow.com/, where the thirdparty script http://fullspeeddownload.com/rq/4297 registered an event handler on the <body> element. In particular, the websites http://www.force-download.net/ and http: //www.force-download.es/ both registered a navigation event handler to the <html> node to intercept user clicks, just as the above-mentioned third-party scripts. Figure 1(a) shows an example of such a mimicry trick that we detect on the website https://www.bintang.com. The contents enclosed within the yellow rectangle were inserted by the third-party script https://securepubads.g.doubleclick.net/gpt/ pubads_impl_207. However, such trust would be abused in this case because those contents were generated solely by a third-party script the user does not know. We detect 146 transparent overlay third-party element groups on 144 websites. Figure 1(b) demonstrates an example of such a visual trick that we identify on the website http://jgsdf.ucoz.com. The script that created these third-party contents is http://pl14318198.puserving.com/a2/49/ 14/a2491467a19ffc3f9fe0dbe66e54bae0. We leave it for our future work to examine how effective the visual deceptions are on real users. We discuss next such a detection evasion example.The script https://pndelfast.com/riYfAyTH5nYD/4869-included by the website https://torrentcounter.to/-selectively intercepted the user clicks on the background of the website. Lines 8, 13, and 16 define the functions "setCookie", "removeCookie", and "getCookie", respectively. It sets the cookie in Line 28, if the return value of the function init defined in Line 20 is not true. Listing 1: A simplified click interception script from https: //pndelfast.com. We detect 86 unique third-party scripts that injected huge <a> tags into their embedding pages. The noticeable scripts are those loaded from http://gynax.com. The top script https://cdn.adf.ly/js/link-converter.js itself, or indirectly included by another third-party script.We categorize how a remote third-party script can be included into three classes. In particular, the short URL monetization script https://cdn.adf.ly/js/link-converter.js was found to be statically included by those 18 websites. The script https://wchat.freshchat.com/js/widget.js was statically included by 17 websites. However, in practice it is difficult and even infeasible to use CSP because many websites need to allow dynamic inclusion of advertising scripts that may be loaded from arbitrary sources due to ad syndication. As we have demonstrated in §5.3.1, many third-party scripts offer monetization services by converting first-party hyperlinks into third-party ad links. Similarly, we find many other cases where a click was intercepted by a third-party script to visit an advertiser's landing page.Identifying Advertising URLs. To understand if monetization via advertising is really a common reason for click interception, we compare the navigation URLs in the click interception cases with all the other navigation URLs in our dataset. In online display advertising, the publishers and the ad networks are paid by an advertiser when a user clicks the advertiser's ad under the pay-per-click billing mode. To boost ad revenue, the straightforward and effective approach is to leverage real user clicks, as modern ad networks can accurately detect bot-based click frauds [2,6,9,38]. The Google search results of the domain 1bcde.com also suggest it is a malicious redirect website.We also find that the script http://cdn.adf.ly/js/link-converter.js converted one link of the website http://magazinweb.net/ into http://ay.gy/2155800/..., which is an advertising link. It once took our browser to a drive-by download page, as shown in Figure 2. For instance, the SOA email address of https://www.instagram.com/ is awsdns-hostmaster@amazon.com, whereas that of https: //www.facebook.net/ is dns@facebook.com. Although our approach to determining the relationship between two hosts is not complete, it is good enough for achieving our goal and provides better results compared with a similar approach using only whois records [4]. OBSERVER applies an artificial way to interact with websites, i.e., using a script to click all the elements on a page, in order to automate the analysis. It would be an interesting research topic to study if developers would write code to distinguish authentic clicks from automatically generated ones 9 . According to our experiment, OBSERVER introduces negligible performance overhead on navigation. For example, an integrity policy can specify that all first-party hyperlinks shall not be modifiable by third-party JavaScript code. However, it might also 9 The clicks in our experiment were generated through Selenium and are different from those generated using JavaScript, which can be easily detected. Our research sheds light on an emerging client side threat, and highlights the need to restrict the privilege of third-party JavaScript code.