DR. CHECKER is a fully-automated static analysis tool capable of performing general bug finding using both pointer and taint analyses that are flow-sensitive, context-sensitive, and field-sensitive on kernel drivers. To demonstrate the scala-bility and efficacy of DR. CHECKER, we analyzed the drivers of nine production Linux kernels (3.1 million LOC), where it correctly identified 158 critical zero-day bugs with an overall precision of 78%. Thus, static source code analysis has long prevailed as the most promising technique for kernel code verification and bug-finding, since it only requires access to the source code, which is typically available.Unfortunately, kernel code is a worst-case scenario for static analysis because of the liberal use of pointers (i.e., both function and arguments are frequently passed as pointers). These tools range from precise, unsound, tools capable of detecting very specific classes of bugs (e.g., data leakages [32], proper fprintf usage [22], user pointer deferences [16]) to sound, im-precise, techniques that detect large classes of bugs (e.g., finding all usages of strcpy [55]). These staggering numbers were attributed to lower overall code quality in drivers and improper implementations of the complex interactions with the kernel core by the third party supplying the driver.In 2011, Palix et al. [39] analyzed the Linux kernel again and showed that while drivers still accounted for the greatest number of bugs, which is likely because drivers make up 57% of the total code, the fault rates for drivers where no longer the highest. Yet, we are unaware of any large-scale analysis of these drivers.In this work, we present DR. CHECKER, a fullyautomated static-analysis tool capable of identifying numerous classes of bugs in Linux kernel drivers. DR. CHECKER, is the first (self-proclaimed) soundy static-analysis-based bug-finding tool, and, similarly, the first static analysis tool capable of large-scale analysis of general classes of bugs in driver code. We evaluated DR. CHECKER by analyzing nine popular mobile device kernels, 3.1 million lines of code (LOC), where it correctly reported 3,973 flaws and resulted the discovery of 158 [6][7][8][9][10] previously unknown bugs. These tools evolved to reduce user interaction (i.e., removing the need for manual annotation of source code) by using machine learning and complex data structures to automatically identify potential dangerous portions of code [41,[59][60][61][62][63]. Before delving into the details of DR. CHECKER, we first present a motivating example in the form of a bug that was discovered by DR. CHECKER.In this bug, which is presented in Listing 1, a tainted structure is copied in from userspace using copy from user. This overflow would not be particularly problematic if it wasn't for the fact that the originally tainted length (i.e., the very large number) is later used to determine how much data will be copied in Listing 1: An integer overflow in Huawei's Bastet driver that was discovered by DR. CHECKER 1 s t r u c t b s t t r a f f i c f l o w p k g { 2 u i n t 3 2 t c n t ; the buffer (adjust traffic flow by pkg(buf, flow p.cnt)), resulting in memory corruption.There are many notable quirks in this bug that make it prohibitively difficult for na¨ıvena¨ıve static analysis techniques. Finally, the memory corruption in a different function (i.e., adjust traffic flow by pkg), which means that that the analysis must be able to handle inter-procedural calls in a context-sensitive way to precisely report the origin of the tainted data. Once the analysis clients have run and updated the global state of the analysis, we then employ numerous vulnerability detectors, which identify specific properties of known bugs and raise warnings (e.g., a tainted pointer was used as input to a dangerous function). The general architecture of DR. CHECKER is depicted in Figure 1, and the details of our analysis and vulnerability detectors are outlined in the following sections.Below we briefly outline a few of our core assumptions that contribute to our soundy analysis design: Assumption 1. An entry function, ε, is a function that is called with at least one of its arguments containing tainted data (e.g., an ioctl call). τ :v → {I 1 , I 2 , I 3 , ...} if TAINTED v → / 0 otherwise Definition 3.7. These maps allow us to differentiate between different fields of a structure to provide field-sensitivity in our analysis.The following types of locations are traced by our analysis:1. Our points-to map, φ , is the map between a value and all of the possible locations that it can point to, represented as a set of tuples containing alias objects and offsets into those objects.φ : v → {(n 1 , ˆ a 1 ), (n 1 , ˆ a 2 ), (n 2 , ˆ a 3 ), ...}For example, consider the instruction val1 = &info->dirmap, where info represents a structure on the stack and member dirmap is at offset 8. While most of the existing static analysis techniques [13,28] run their abstract analysis until it reaches a fixedpoint before performing bug detection, this can be problematic when running multiple analyses, as the different analyses may not have the same precision. To avoid this, and ensure the highest precision for all of our analysis modules, we perform a flow-sensitive and context-sensitive traversal of the driver starting from an entry point. For example, a pointsto analysis might need more traversals through a loop to reach a fixed point than a taint analysis. However, in the worst case, points-to analysis could potentially grow unconstrained,Algorithm 1: Soundy driver traversal analysis function SDTraversal((S, ∆, F)) sccs ← topo sort(CFG(F)) forall the scc ∈ sccs do if is loop(scc) then HANDLELOOP(S, ∆, scc) else VISITSCC(S, ∆, scc) end end function VisitSCC((S, ∆, scc)) forall the bb ∈ scc do forall the I ∈ bb do if is call(I) then HANDLECALL(S, ∆, I) else if is ret(I) then S ← S ∪ {φ ∆ (ret val), τ ∆ (ret val)} else DISPATCHCLIENTS(S, ∆, I) end end end end function HandleLoop((S, ∆, scc)) num runs ← LongestUseDe fChain(scc) while num runs = 0 do VISITSCC(S, ∆, scc) num runs ← num runs − 1 end function HandleCall((S, ∆, I)) if ¬is visited(S, ∆, I) then targets ← resolve call(I) forall the f ∈ targets do ∆ new ← ∆||I φ new ← (∆ new → (φ c (∆)(args), φ c (∆)(globals))) τ new ← (∆ new → (τ c (∆)(args), τ c (∆)(globals))) S new ← {φ new , τ new } SDTRAVERSAL(S new , ∆ new , f ) end mark visited(S, ∆, I) endresulting in everything pointing to everything. If a function call is a direct invocation and the target function is within the code that we are analyzing (i.e., it is part of the driver), it will be traversed with a new context (∆ new ), and the state will be both updated with a new points-to map (ρ new ) and a new taint trace map (τ new ), which contains information about both the function arguments and the global variables. For indirect function calls (i.e., functions that are invoked via a pointer), we use type-based target resolution. Every SCC is traversed at the basic-block level, where every instruction in the basic block is provided to all of the possible clients (i.e., taint and pointsto), along with the context and global state. The client analyses can collect and maintain any required information in the global state, making the information immediately available to each other.To analyze a driver entry point ε, we first create an initial state: S start = {φ start , / 0}, where φ start contains the points-to map for all of the global variables. The analysis clients interact with our soundy driver traversal (SDT) analysis by implementing visitors, or transfer functions, for specific LLVM IR instructions, which enables them to both use and update the information in the global state of the analysis. Since SDT is contextsensitive, the instruction location is a combination of the current context and the instruction offset within the function bitcode.Algorithm 2: Points-to analysis transfer functionsfunction updatePtoAlloca (φ c , τ c , δ , I, v, loc x ) map pt ← φ c (δ ) loc x ← (x, / 0, / 0) map pt (v) ← (0, loc x ) function updatePtoBinOp (φ c , τ c , δ , I, v, op 1 , op 2 ) map pt ← φ c (δ ) pto 1 ← map pt (op 1 ) pto 2 ← map pt (op 2 ) set 1 ← {(0, ob) | ∀( , ob) ∈ pto 1 } set 2 ← {(0, ob) | ∀( , ob) ∈ pto 2 } map pt (v) ← map pt (v) ∪ set 1 ∪ set 2 function updatePtoLoad (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) set 1 ← {ob(n) | ∀(n, ob) ∈ pto op } set 2 ← {(0, ob) | ∀ob ∈ set 1 } map pt (v) ← map pt (v) ∪ set 2 function updatePtoStore (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) pto v ← map pt (v) set v ← {ob | ∀( , ob) ∈ pto v } ∀(n, ob) ∈ pto op do ob(n) ← ob(n) ∪ set v function updatePtoGEP (φ c , τ c , δ , I, v, op, o f f ) map pt ← φ c (δ ) pto op ← map pt (op) set op ← {ob(n) | ∀(n, ob) ∈ pto op } set v ← {(o f f , ob) | ∀ob ∈ set op } map pt (v) ← map pt (v) ∪ set v The result of our points-to analysis is a list of values and the set of all of the possible objects, and offsets, that they can point to. function updateTaintAlloca (φ c , τ c , δ , I, v, loc x )Nothing to dofunction updateTaintBinOp (φ c , τ c , δ , I, v, op 1 , op 2 ) map t ← τ c (δ ) set v ← map t (op 1 ) ∪ map t (op 2 ) map t (v) ← set v ||I function updateTaintLoad (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) set op ← {ob t (n)||I | ∀(n, ob) ∈ pto op } map t ← τ c (δ ) map t (v) ← map t (v) ∪ set op function updateTaintStore (φ c , τ c , δ , I, v, op) map pt ← φ c (δ ) pto op ← map pt (op) map t ← τ c (δ ) tr v ← map t (v) ∀(n, ob) ∈ pto op do ob t (n) ← ob t (n) ∪ (tr v ||I) function updateTaintGEP (φ c , τ c , δ , I, v, op, o f f ) UPDATETAINTBINOP(φ c , τ c , δ , I, v, op, o f f )Internal kernel functions. While, we may miss some points-to information because of this, again sacrificing soundness, this assumption allows us to be more precise within the driver and scale our analysis.The update points-to transfer functions (updatePto*) for the various instructions are as shown in Algorithm 2. We also consider special kernel functions that copy data from user space (e.g., copy from user, simple write to buffer) as taint sources and taint all of the fields in the alias locations of the points-to map for Listing 2: A buffer overflow bug detected in Mediatek's Accdet driver by ITDUD where buf is assumed to be a single character but the use of "%s" will continue reading the buffer until a null-byte is found. 2 . . . 3 s t a t i c s s i z e t 4 a c c d e t s t o r e c a l l s t a t e 5 ( s t r u c t d e v i c e d r i v e r * d d r i , 6 c o n s t c h a r * b u f , s i z e t c o u n t ) 7 { 8 / / * * I m p r o p e r u s e o f t a i n t e d d a t a * * 9/ / b u f can c o n t a i n more t h a n one c h a r ! In fact, in the process of analyzing our results for this paper, we were able to create the Global Variable Race Detector (GVRD) detector and deploy it in less than 30 minutes.Almost all of the detectors use taint analysis results to verify a vulnerable condition and produce a taint trace with all of their emitted warnings. The various bug detectors used by DR. CHECKER in our analysis are explained below:Improper Tainted-Data Use Detector (ITDUD) checks for tainted data that is used in risky functions (i.e., strc*, strt*, sscanf, kstrto, and simple strto Listing 3: A zero-day vulnerability discovered by DR. CHECKER in Mediatek's mlog driver using our TAD and TLBD analysis. The example in Listing 3 shows this in a real-world bug, which also triggered on TAD.Listing 4: An information leak bug via padded fields detected by our ULD in Mediatek's FM driver where a struct's memory is not sanitized before being copied back to user space leaking kernel stack data. These types of bugs can result in information leaks or buffer overflows since the tainted size is used to control the number of copied bytes.Uninit Leak Detector (ULD) keeps tracks of which objects are initialized, and will raise a warning if any src pointer for a userspace copy function (e.g., copy to user) can point to any uninitialized objects. Luckily, each vendor has a code-name that is used in all of their options and most of their files (e.g., Qualcomm configuration options contain the string MSM, Mediatek is MTK, and Huawei is either HISI or HUAWEI), which helps us identify the various vendor options and file names. Linux kernel drivers have various ways to interact with the userspace programs, categorized by 3 operations: file [20], attribute [35], and socket [37]. For example, struct file operations on Mediatek's mt8163 kernel has its ioctl function at field 11, whereas on Huawei, it appears at field 9 in the structure.To handle these eccentricities in an automated way, we used c2xml [11] to parse the header files of each kernel and find the offsets for possible entry function fields (e.g., read or write) in these structures. An entry point argument can contain either directly tainted data (i.e., the argument is passed directly by userspace and never checked) or indirectly tainted data (i.e., the argument points to a kernel location, which contains the tainted data). • Improper API usage: DR. CHECKER assumes that all the kernel API functions are safe and correctly used (Assumption 1 in Section 3). - - - √ Inter-procedural - - - - √ Handles pointers - - - - √ Kernel Specific - - - √ √ No Manual Annotations √ √ √ - √ Requires compilable sources √ - - √ √ Sound - - - - - Traceable Warnings - - - √ √Ultimately, the tools seemed reasonable for basic code review passes, and perhaps for less-security minded programs, as they do offer informational warning messages:Flawfinder: Statically-sized arrays can be improperly restricted, leading to potential overflows or other issues (CWE-119:CWE-120). Perform bounds checking, use functions that limit length, or ensure that the size is larger than the maximum possible length.RATs: Check buffer boundaries if calling this function in a loop and make sure you are not in danger of writing past the allocated space Sparse Sparse was developed by Linus Torvalds and is specifically targeted to analyze kernel code. Despite this functionality, it still failed to detect any of the complex bugs that DR. CHECKER was able to help us discover.To summarize our experience, we provide a sideby-side feature comparison of the evaluated tools and DR. CHECKER in Table 3. In fact, 7 of the 158 identified zero-days have already been issued Common Vulnerabilities and Exposures (CVE) identifiers [6][7][8][9][10]. For example, if a function with a vulnerable condition is called multiple times from different contexts, DR. CHECKER will raise one warning for each context.GlobalVariableRaceDetector suffered from numerous false positives because of granularity of the LLVM instructions. The same overapproximation of points-to affected InvalidCastDetector, with 2 entry points (picolcd debug flash read and picolcd debug flash write) resulting in 66 (80%) false positives in Huawei and a single entry point (touchkey fw update.419) accounting for a majority of the false positives in Samsung. This analysis was done by randomly selecting 25 entry points from each of our codebases (i.e., Huawei, Qualcomm, Mediatek, and Samsung), resulting 100 randomly selected driver entry points. Moreover, these 18 entry points produced 63 warnings and took a total of 52 minutes to evaluate, compared to 9 warnings and less than 1 minute of evaluation time using our soundy analysis.Fixed-point Loop Analysis Since we were unable to truly evaluate a sound analysis, we also evaluated our second assumption (i.e., using a reach-def loop analysis instead of a fixed-point analysis) in isolation to examine its impact on DR. CHECKER. Specifically, as shown in Section 7.1, ignoring external API functions (i.e., kernel functions) is the major contributor to the feasibility of DR. CHECKER on the kernel drivers. Johnson et al. [28] proposed a sound CQUAL-based [24] tool, which is context-sensitive, field-sensitive, and precise taint-based analysis; however, this tool also requires user annotations of the source code, which DR. CHECKER does not.KINT [56] uses taint analysis to find integer errors in the kernel. We have presented DR. CHECKER, a fully-automated static analysis bug-finding tool for Linux kernels that is capable of general context-, path-, and flow-sensitive points-to and taint analysis. This material is based on research sponsored by the Office of Naval Research under grant number N00014-15-1-2948 and by DARPA under agreement number FA8750-15-2-0084.