In this paper, we propose a practical debloating framework, RAZOR, that performs code reduction for deployed binaries. Instead of only supporting given test cases, RAZOR takes several control-flow heuristics to infer complementary code that is necessary to support user-expected functionalities. RAZOR is thus a practical framework for debloating real-world programs. * The two lead authors contributed equally to this work.Unfortunately, most initial works on software debloating rely on the availability of program source code [40,15,44], which is problematic in real-world use. Therefore, to obtain the most benefits, the debloating process should take place after software deployment and should be tailored for each individual user.Making such a post-deployment approach beneficial and usable to end-users creates two challenges: 1) how to allow end-users, who have little knowledge of software internals, to express which features are needed and which should be removed and 2) how to modify the software binary to remove the unnecessary features while keeping the needed ones.To address the first challenge, we can ask end-users to provide a set of sample inputs to demonstrate how they will use the software, as in the CHISEL work [15]. Unfortunately, programs debloated by this approach only support given inputs, presenting a rather unusable notion of debloating: if the debloated software only needs to support an apriori, fixed set of inputs, the debloating process is as simple as synthesizing a map from the input to the observed output. Note that techniques like dead code elimination [23,22] and delta debugging [49,42] do not apply to this problem because they only focus on either removing static dead code or preserving the program's behavior on a few specific inputs.We design four heuristics that infer related-code based on the assumption that code paths with more significant divergence represent less related functionalities. Specifically, given one executed path p, we aim to find a different path q such that 1) q has no different instructions, or 2) q does not invoke new functions, or 3) q does not require extra library functions, or 4) q does not rely on library functions with different functionalities. Thanks to the nature of program debloating, our platform does not face the symbolization problem from general binary-rewriting tools [51,53,52,5]. In the RAZOR framework, we implemented three tracers (two based on dynamic binary instrumentation and one based on a hardware tracing feature), four path finding heuristics, and one binary generator.To understand the efficacy of RAZOR on post-deployment debloating, we evaluated it on three sets of benchmarks: all SPEC CPU2006 benchmarks, 10 coreutils programs used in previous work, and two real-world large programs, the web browser Firefox and the closed-sourced PDF parser FoxitReader. At the same time, it introduces only 1.7% overhead to the new binary. We also analyzed the related-code identified by our path finder and found that different heuristics effectively improve the program robustness.In summary, we make the following contributions:• New approach.We proposed a practical postdeployment debloating framework that works on program binaries. We implemented our system on an x86-64 Linux system and will open source RAZOR at https://github.com/ cxreet/razor. Based on the userprovided options (line 4 and 6), the program invokes function parsePNG to parse PNG images (line 5) or invokes function parseJPEG to handle JPEG images (line 7). In this case, the code is bloated with the unnecessary JPEG parser, which may contain security bugs [18]. Given a program P that has a set of functionalities F = {F 0 , F 1 , F 2 , ...} and a user specification of necessary functionalities F u = {F i , F j , F k , ...}, our goal is to generate a new program P ′ that only retains functionalities in F u and gracefully refuses requests of other functionalities in F − F u . From the simple code we can easily tell that code in the yellow background (i.e., line 6, 7 and 15) is not necessary, so we remove such code in a safe manner: function parseJPEG will be simply removed; for line 6 and 7, we should replace the code with fault-handling code to prompt warnings and exit gracefully.In this paper, we focus on reducing functionalities from software binaries. From the previous example, we can find the gap between the user specification and the code removed: users specify that the functionality of parsing PNG files is necessary (i.e., others are unnecessary), while we finally remove line 6, line 7, and function parseJPEG. Our problem can be rephrased as follows: given the program binary P b and a set of test cases T = {t i ,t j ,t k , ...}, where each test case t i triggers some functionalities of P b , we will create a minimal program P ′ b that supports and only supports functionalities triggered by the test cases in T . How to find more related-code from limited test cases.To address challenge C3, we propose control-flow-based heuristics to infer more related-code that is necessary to support the required functionalities but was missed during our inspection. The evaluation in §5.3 shows that our heuristic is effective in finding related-code paths and introduces only a small increase in code size. In the end, with the expanded CFG, Generator rewrites the original binary to produce a minimal version that only supports required functionalities ( §3.3). Tracer executes the bloated program with given test cases and records the control-flow information in three categories:(1) executed instructions, including their memory addresses and raw bytes; (2) the taken or non-taken of conditional branches, like je that jumps if equal; (3) concrete targets of indirect jumps and calls, like jmpq *%rax that jumps to the address indicated by register %rax. During the execution, it detects any dynamic code behavior, like both writable and executable memory region (e.g., just-in-time compilation [13]), or overlapped basic blocks (e.g., legitimate code reuse [26]), and switches to the instruction-level recording to avoid missing instructions. The trace also contains three conditional branch instructions: the one at 0x4004e3 only takes the true target; the one at 0x4004ee only takes the false target; the one at 0x400614 takes both targets. For example, Dynamorio always expands the file name to its absolute path, leading to different executed code in some programs (e.g., vim). With the collected execution traces, RAZOR disassembles the bloated binary and constructs the partial control-flow graph (CFG) in a reliable way. Next, we present these heuristics one by one, from the conservative one (including less code) to the aggressive one (including more code):(1) Zero-code heuristic (zCode). This heuristic adds new edges (i.e., jumps between basic blocks) into the CFG. The original execution path is L1→L2→L3→L5→L7→L9. With the zCode heuristic, PathFinder adds branch L1→L3 into the new CFG, as L3 is the non-taken branch of the conditional jump jge L3 in L1 and it is already reached from L2 in the current CFG. When applying the zCall heuristic on the example in Figure 4, PathFinder further includes block L4, and path L3→L4→L5, as this new path merges with the original one at L5 and does not contain any call instruction. In Figure 4, with this heuristic, PathFinder adds block L6 and path L5→L6→L7 to the CFG, as that path does not have any call to non-executed external functions. With this heuristic, PathFinder includes block L8 and path L7→L8→L9, as sqrt has a functionality similar to the executed function log.Algorithm 1 shows the steps that PathFinder uses to find related-code that completes functionalities. If the non-taken branch is reachable in the current CFG (line 4), zCode enables the new branch in the output CFG (line 5). First, it disassembles the original binary following the expanded CFG and generates a pseudo-assembly file that contains all necessary instructions. These modifications symbolize basic blocks, concretize indirect calls/jumps, and insert fault han- Figure 5: Synthesize debloated assembly file. Fourth, Generator copies the machine code from the object file into a new code section of the original binary. We leave the original code section inside the debloated program to support the potential read from it (e.g., jump tables in code section for implementing switch [11]). Similarly, instruction call 0x40 in block 0x06 is replaced with call L_0x40. Therefore, instead of replacing 0x6 with symbol L_0x6, we redirect the execution to the fault handling code cond_fail (will discuss in §3.3.3). For the sake of simplicity, we use the term indirect call to cover both indirect calls and indirect jumps.With the execution traces, Generator is able to handle indirect calls in two ways. For local targets, we define a concrete policy for each indirect call instruction. Different from previous work that creates a translation table for all potential targets in the module [53], our translation table contains only targets that are ever invoked by other modules. Figure 5 gives an example of indirect call concretization. Thus, any indirect call instruction can reach all possible targets, making the protection vulnerable to existing bypasses [12,43,9]. For example, one indirect call instruction in perlbench benchmark of SPEC CPU2006 has at least 132 targets, and each target is invoked millions of times. We redirect any such attempt to a fault handler that exits the execution and dumps the call stack. We implement a prototype of RAZOR with 1,085 lines of C code, 514 lines of C++ code, and 4,034 lines of python code, as shown in Table 1. In our evaluation, we use software-based instrumentation to collect complete traces for simple programs, and use a hardware-based method to efficiently get trace from large programs.Tracing with software instrumentation. We use the dynamic instrumentation tools Dynamorio [7] and Pin [25] to monitor the execution of the bloated program. At runtime, we remove the basic block instruction immediately after its first execution to avoid unnecessary overhead. Considering the overhead of software instrumentation, we provide an efficient Tracer built on Intel Processor Trace (Intel PT) [20]. Recall that the given test cases only trigger part of the functionalities, and the non-executed functions will not be included in the debloated binary. gcc_except_table sections to get more space for our update of landingpad values. We set up three sets of benchmarks to evaluate RAZOR: 29 SPEC CPU2006 benchmarks, including 12 C programs, seven C++ programs, and 10 Fortran programs; 10 coreutils programs used in the CHISEL paper 1 [15]; the web browser Firefox and the close-source PDF reader FoxitReader. We ran all the experiments on a 64-bit Ubuntu 16.04 system equipped with Intel Core i7-6700K CPU (with eight 4.0GHz cores) and 32 GB RAM. Figure 6b shows the code reduction of CHISEL benchmarks, debloated by CHISEL and RAZOR.On average, RAZOR achieves 68.19% code reduction for SPEC benchmarks and 78.8% code reduction for CHISEL benchmarks. datasets already trigger most of the code.Meanwhile, CHISEL achieves 83.4% code reduction on CHISEL benchmarks. Although CHISEL performs slightly better than RAZOR on code reduction, we find that the debloated binaries from CHISEL suffer from robustness issues ( §5.2) and security issues ( §5.4). On average, RAZOR removes 53.1% of basic blocks and 63.3% of instructions from the original programs, while CHISEL reduces 66.0% of basic blocks and 88.5% of instructions from the same set of programs. sort, and uniq) and trigger some unexpected behaviors for the other seven programs. We suspect that CHISEL only uses one test case of decompression to debloat the program and thus removes the code that parses command line options.Infinite loop. bzip2 crashes three test cases for the same reason.Missed output. In this subsection, we focus on the first experiment and leave the N-fold cross validation in §5.6.1. We tested RAZOR on CHISEL benchmarks as follows: (1) design training inputs and testing inputs that cover the same set of functionalities; (2) trace programs with the training inputs and debloat them with none, zCode, zCall, zLib, and zFunc heuristics; (3) run debloated binaries on testing inputs and record the failed cases. grep fails on all 38 testing inputs, while chown and rm fail more than half of all tests.The zCode heuristic helps mitigate the crash problem, like making grep work on 19 test cases. With the zLib heuristic, only two programs (i.e., chown and rm) still have a small number of failures. The number is reduced by −0, 4%, 3.8%, 8.8%, and 12.6% when applying zCode, zCall, zLib, and zFunc heuristics, respectively. The training inputs always trigger the true branch of the condition at line 2 and jump to line 3, which in turn reach line 4. tic adds lines 5 and 8 and related branches to the debloated program, which effectively avoids this crash.The zLib heuristic allows extra calls to native functions or library functions if they have been used in traces. Fig- ure 12 shows the related code, which crashes because of the missing code from line 6 to line 9. Since mkdir does not allow changing the file mode of an existing directory, the code first invokes function gettext to get the error message and then calls library function error to report the error. Since the training inputs never call strcmp, the debloated binary fails even with the zLib heuristic. Three bugs only exist in older versions (i.e., CVE-2010-0405, CVE-2009-2624, and CVE-2010. Specifically, CHISEL removes the vulnerable code of CVE-2014-9471 from date and the code of CVE-2016-6321 from tar. Meanwhile, it removes the patches of CVE-2008-1372and CVE-2005-1260 in bzip2, and CVE-2012-5667 in grep, rendering the debloated binaries vulnerable to these already-fixed bugs.Compared to CHISEL, RAZOR removes the bloated code in a conservative way. As shadow stack technique are getting deployed in compilers [24] and even hardware [19], our technique of indirect call/jump concretization ( §3.3.2) complements existing practical return-protections to achieve complete control-flow integrity. On average, RAZOR introduces 1.70% overhead to debloated programs, indicating its efficiency for real-world deployment. With the indirect call concretization, one indirect call instruction is replaced by several comparison and direct calls. For Firefox, we ran RAZOR to load the top 50 Alexa websites [28]. Without heuristics, Firefox fails on 13 out of 25 websites and FoxitReader fails on 39 out of 40 PDF files.The zCode heuristic helps reduce FoxitReader crashes to 10 PDF files and increases the code reduction by avoiding faulthandling instrumentation. We ran the debloated Firefox (with zLib) on several benchmarks and found that RAZOR introduces −2.1%, 1.6%, 0%, and 2.1% overhead to Octane [33], SunSpider [34], Dromaeo-JS [30], and Dromaeo-DOM [29] benchmarks. For example, the bank can provide its clients a minimal browser that only supports functionalities required by its website while exposing the least attack surface.To measure the benefit of the per-site browser, we applied RA-ZOR on three sets of popular and security-sensitive websites: banking websites, websites for electronic commerce, and social media websites. Surprisingly, social media websites can benefit by up to 8.5% extra code reduction and at least 4.2% when supporting all three websites. Second, we randomly split the 50 website into 10 groups, and select five groups (25 websites) as the training set, and others (25 websites) as the test set for 10 times. We understand that such a heuristic cannot guarantee the completeness or soundness of the path inference, and the debloated binary may miss necessary code (i.e., code for handling different environment variables) or include unnecessary ones (like some initialization code). For example, if function A is designed to be a legitimate target of an indirect call i, CFI will allow the transfer from i to A. However, if the user does not need the functionality in A, software debloating will disable the transfer and completely remove the function code. It also simplifies the analysis required by some CFI works [50,37] because of a smaller code base. For example, function strncmp implements 16 different subroutines to process strings with different alignments. For example, for each memory allocation, malloc searches a set of cached chunks and picks up the first available one. To further reduce the program size and memory usage, we can completely remove the original code section as follows: 1) during the execution tracing, we set the original code section to execute-only [11] so that any read from the code section will trigger the exception and can be logged by Tracer; 2) we perform backward data-flow analysis to identify the source of the data pointer used for each logged memory access; 3) during the binary synthesization, we relocate the data from the original code section to a new data section and update the new code to visit the new location. In this way, we are able to handle the challenging problem of data relocation during binary rewriting. We plan to extend the platform to support binaries in more formats and architectures, including shared libraries, 32-bit binaries, Windows PE programs, MacOS March-O programs, and ARM binaries. Similarly, Quach et al.[40] present library debloating through piece-wise compilation and loading. First, previous work performs the binary rewriting at the beginning of each process, leading to performance overhead for each execution, while RAZOR generates the debloated binary through static binary rewriting, which is only performed once and used forever. For example, Regehr et al. [42] propose C-Reduce to generate a smaller test cases efficiently. Bu et al. [8] propose a bloat-ware design paradigm that analyzes Java source code to optimize object allocations to avoid memory usage bloating at runtime. For example, Intel PT supports tracing operating systems.Hardware Debloating. This research was supported in part by the DARPA Transparent Computing program under contract DARPA-15-15-TC-FP006, by the ONR under grants N00014-17-1-2895, N00014-15-1-2162 and N00014-18-1-2662.