To offer a fast and service-preserving malware removal technique , we present CRIU-MR: a mechanism for restoring an infected server running within a Linux container to an uninfected state using Checkpoint/Restore in Userspace (CRIU). Compared to these efforts, we seek to develop a lightweight, quick malware recovery technique which transparently preserves the state of trusted services running on an infected host without the overhead of log-based schemes.We present a malware recovery system which extends the Checkpoint/Restore In Userspace project (CRIU) [40] to quickly restore an infected Linux container (LXC) to a safe state while removing malware and preserving running services in the process. The Taser [20] recovery system records all file, network, and process operations performed on the system and attempts to use such logs to undo the effects of a malware program once it is flagged by an IDS. While not a VM-based technique, MalTRAK [39] uses the concept of "views" or system snapshots in a similar manner to undo the effects of a malware program.ExecRecorder [18] is a VM-based recovery method which also integrates logging to restore a system to a trusted snapshot before replaying log events for nonmalware processes to restore the system state. Given their own recommendation for unprivileged container use, the LXC maintainers do not consider privileged container escape exploits a serious concern, stating "as privileged containers are considered unsafe, we typically will not consider new container escape exploits to be security issues worthy of a CVE and quick fix" [8]. One attractive feature of CRIU is that it is able to restore TCP connections by using the TCP_REPAIR socket option [3]. This assumption allows for rapid restoration of the filesystem, as the backup can be quickly swapped back into the container root filesystem location in case of an infection without file loss. The policy can be composed of a variety of user-defined or dynamically generated rules that are used to omit processes from being restored, including:• Executable Name Match: Whether the executable filename of a process matches a given string• File Match: Whether any opened file of a process matches a given string• TCP IP Match: Whether the IP address for any established TCP connection of a process matches a given IP address• Memory Match: Whether the process contains the specified ASCII or Hex encoded string• PID Match: Whether the PID of a process matches the given PID• Parent PID Match: Whether the parent PID of a process matches the given PPID• Parent Executable Name Match: Whether the parent executable filename matches the given stringIn choosing these rule types, we seek to provide a flexible policy language which can identify malware to omit during the restore process based upon alerts provided by various intrusion detection triggers, such as potentially malicious TCP connections, executables which match a virus signature, and flagged PIDs. Essentially, we check if there are any matching policy elements for each of these resources, and if there are, the PIDs of relevant processes are written to an additional protobuf formatted file named omit.img. The core modifications for the CRIU restore process ensure that malicious processes flagged by the checkpoint process in omit.img are not restored. These changes ensure that as the container is restored on the backup filesystem, processes referencing potentially malicious files that are no longer present will be gracefully omitted during the restore, even if these processes were not directly flagged via a policy rule. The example code used to generate the JSON alerts and send them to the recovery agent are shown in Appendix A.Preparation: The recovery agent for CRIU-MR listens on a TCP port for a JSON message. Using these backups, the filesystem for the container is restored with a few simple shell commands: One benefit of this method is that the infected filesystem can be later inspected (with the assistance of the CRIU-MR log files) to collect malware samples and detect malicious filesystem changes.CRIU Restore: At this point, the CRIU restore of the checkpointed non-malware processes begins. The swap backup for the container is also restored from the "master" backup to allow for a quick filesystem restore in the event of another breach using the following command: The preparation, CRIU checkpoint, filesystem restore, CRIU restore, and cleanup steps are all automated via the CRIU-MR recovery agent program. We observe the impact of the checkpoint/restore process on the active connections and find that no connections fail while the maximum response time increases by only a few seconds. • Linux.Agent: This malware, first discovered by Tim Strazzere [29] attempts to exfiltrate either the /etc/shadow file with encrypted passwords (if root access is available) or the /etc/passwd file (otherwise). In fact, the removal of malware appears to match the time taken for a checkpoint and restore 4 For goahead_ldpreload we observe that the remote code execution occurs in a separate process /root/goahead/test/cgi-bin/cgitest handling CGI scripts, which is the executable name used in the policy for that exploit. We execute one instance of ab for each file size in parallel and vary the number of concurrent requests per process at 1, 5, 10, and 20 for a total concurrency across all processes of 7 to 140. We observe that relative to the median request completion time, the "Max Request Time" for each file tends to increase by an amount of time comparable to the time it takes for CRIU-MR to execute as measured in Experiment I. For example, if botnet malware is detected via an IDS based on a TCP connection to a command and control server, the connection may end before the alert is processed and CRIU-MR begins the checkpoint process, meaning the malware will fail to be flagged for omission during restore. Alternatively, assertions about the memory spaces of benign processes could be checked during the restore process to verify their integrity, an idea we consider future work ( §7). Adding this feature will ensure that forged alerts that might cause CRIU-MR to flag important applications as malware or otherwise interrupt services cannot be sent to the recovery agent.Another avenue for future work is in the verification of the integrity of processes. Rather than using logging or VMbased methods for removing malware, CRIU-MR uses Linux containers and CRIU to quickly restore a system to a safe state in the event of an infection. Our test of the duration of the malware recovery process finds that malware recovery does not take significantly more time than a CRIU checkpoint/restore with no policy. Finally the grok parsing code in the filter step simply becomes:%{GREEDYDATA: f i l e p a t h } :%{GREEDYDATA: malwarename } FOUND B NFQUEUE BufferListing 2 shows an example implementation of a buffer for packets intended for the interface lxcbr0, which is the default interface used for the Linux container networking. Listing 1 shows an example of using Logstash with the grok filter to parse Snort alerts and send them to the CRIU-MR agent.