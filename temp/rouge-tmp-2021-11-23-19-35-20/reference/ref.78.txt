We found four of the eleven projects using flawed scrubbing techniques that may fail to scrub sensitive data and an additional four projects not using their scrubbing function consistently. We also synthesized existing techniques to develop a best-of-breed scrubbing function and are making it available to developers. A typical case might look like the following: char * password = malloc(PASSWORD_SIZE); // ... read and check password memset(password, 0, PASSWORD_SIZE); free(password);The memset is intended to clear the sensitive password buffer after its last use so that a memory disclosure vulnerability could not reveal the password. Security-conscious developers have been left to devise their own means to keep the compiler from optimizing away their scrubbing functions, and this has led to a proliferation of "secure memset" implementations of varying quality.The aim of this paper is to understand the current state of the dead store elimination problem and developers' attempts to circumvent it. Next, using a specially instrumented version of the Clang compiler, we analyzed eleven high-profile security projects to determine whether their implementation of a scrubbing function is effective and whether it is used consistently within the project. While not a perfect solution, we believe ours combines the best techniques available today and offers developers a readyto-use solution for their own projects.We also developed a scrubbing aware C compiler based on Clang. O We develop a scrubbing-safe dead store elimination optimization pass that protects memory writes intended to scrub sensitive data from being eliminated. Section 3 surveys the existing techniques that are used to implement reliable scrubbing functions and then Section 4 evaluates their performance. They developed a static checker called STACK that identifies such code in C/C++ programs and they used it to uncover 160 new bugs in commonly deployed systems.Our work examines how developers handle the correctness-security gap introduced by aggressive dead store elimination. While the soundness and security of dead store elimination has been studied formally [28,31,29], the aim of our work is to study the phenomenon empirically.Bug reports are littered with reports of DSE negatively affecting program security, as far back as 2002 from Bug 8537 in GCC titled "Optimizer Removes Code Necessary for Security" [3], to January 2016 when OpenSSH patched CVE-2016-0777, which allowed a malicious server to read private SSH keys by combining a memory disclosure vulnerability with errant memset and bzero memory scrubs [10]; or February 2016 when OpenSSL changed its memory scrubbing technique after discussion in Issue 445 [22]; or Bug 751 in OpenVPN from October 2016 about secret data scrubs being optimized away [26]. The CERT C Secure Coding Standard [37] recommends SecureZeroMemory as a Windows solution, memset_s as a C11 solution, and the volatile data pointer technique as a C99 solution. Furthermore, another common technique, using a volatile function pointer, is not guaranteed to work according to the standard because although the standard requires compilers to access the function pointer, it does not require them to make a call via that pointer [35]. Works with all compilation options and on all the compilers we tested (GCC, Clang, and MSVC), but is not guaranteed in principle. Fails in at least one configuration.In Section 4 we also compare the performance of a subset of the surveyed techniques.The scrubbing techniques we found can be divided into four groups based on how they attempt to force memory to be cleared:Rely on the platform. These deus ex machina techniques rely on a platform-provided function that guarantees the desired behavior and lift the burden of fighting the optimizer from the developers' shoulders. Used in: Kerberos's zap, Libsodium's sodium_mem-zero, Tor's memwipe. Under the hood, explicit_bzero simply calls bzero, however, because explicit_bzero is defined in the C standard library shipped with the operating system and not in the compilation unit of the program using it, the compiler is not aware of this and does not eliminate the call to explicit_bzero. As discussed in Section 3.3.1, this way of keeping the compiler in the dark only works if definition and use remain separate through compilation and linking. Annex K of the C standard (ISO/IEC 9899-2011) introduced the memset_s function, declared as errno_t memset_s(void* s, rsize_t smax, int c, rsize_t n);Similar to memset, the memset_s function sets a number of the bytes starting at address s to the byte value c. It is part of the optional Appendix K. C11 treats all the function in the Annex K as a unit. That is, if a C library wants to implement the Annex K in a standard-conforming fashion, it has to implement all of the functions defined in this annex. Since the dead store elimination problem is caused by compiler optimization, it is possible to prevent scrubbing stores from being eliminated by disabling compiler optimization. Also, specifying the whole list of optimization passes instead of a simple optimization level like O2 is cumbersome.Many compilers, including Microsoft Visual C, GCC and Clang, provide built-in versions of some C library functions, including memset. In particular, starting with glibc 2.3.4 on Linux, defining _FORTIFY_SOURCE to be an integer greater than 0 enables additional compile-time bounds checks in common functions like memset. When this scrubbing function is called in a different compilation unit than the defining one, the compiler cannot remove any calls to the scrubbing function because the compiler does not know that it is equivalent to memset. Unfortunately, this technique is not reliable when link-time optimization (LTO) is enabled, which can merge all the compilation units into one, giving the compiler a global view of the whole program. Another popular technique for hiding a scrubbing operation from the compiler is to call the memory scrubbing function via a volatile function pointer. OPENSSL_cleanse of OpenSSL 1.0.2, shown below, is one implementation that uses this technique: typedef void *(*memset_t)(void *,int,size_t); static volatile memset_t memset_func = &memset; void OPENSSL_cleanse(void *ptr, size_t len) { memset_func(ptr, 0, len); } The C11 standard defines an object of volatile-qualified type as follows:An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Furthermore, at every sequence point the value last stored in the object shall agree with that prescribed by the abstract machine, except as modified by the unknown factors mentioned previously. Therefore, a compiler would be in compliance if it inlined each call to OPENSSL_cleanse as: memset_t tmp_fptr = memset_func; if (tmp_fptr == &memset) memset(ptr, 0, len); else tmp_fptr(ptr, 0, len);If the memory pointed to by ptr is not read again, then the direct call to memset, the semantics of which are known, could be eliminated, removing the scrubbing operation. So long as the compiler does not perform assembly-level link-time optimization, this technique is effective at ensuring scrubbing stores are preserved.Used in: OpenSSL's OPENSSL_cleanse (also used by Tor and Bitcoin); Crypto++'s SecureWipeBuffer. The fourth set of techniques we found attempts to force the compiler to include the store operation without hiding its nature. OpenSSL gave up this technique in favor of the volatile function pointer technique (Section 3.3.3) starting with version 1.0.2. __crypt_blowfish compares the result of the second run with the hardcoded hash value in the function. Since the two calls to BF_crypt are in the same scope and the stack pointer points to the same position of the stack before the two calls, the sensitive data left on the stack by the first run should be cleared by the second run. The advantage of this solution is that it clears sensitive data not only on the stack but also in registers.While the complicated computation technique appears effective in practice, there is no guarantee that a compiler will not someday see through the deception. This means that, while accessing an object declared volatile is clearly an "access to an object that has volatile-qualified type" (as in the case of the function pointer that is a volatile object), accessing a non-volatile object via pointer-to-volatile may or may not be considered such an access. Used in: sodium_memzero from Libsodium, insecure_memzero from Tarsnap, wipememory from Libgcrypt, SecureWipeBuffer from the Crypto++ library, burn from Cryptography Coding Standard [9], David Wheeler's guaranteed_memset [39], ForceZero from wolfSSL [27], sudo_memset_s from sudo [23], and CERT's C99-compliant solution [37]. GCC's documentation indicates that the following inline assembly should work as a memory barrier [1]: __asm__ __volatile__("":::"memory")Our testing shows the above barrier works with GCC, and since Clang also supports the same syntax, one would expect that the barrier above would also work with Clang. Unfortunately, this means that creating a scrubbing function requires relying on platform-specific functions rather than a standard C library or POSIX function.Of the remaining techniques, we found that the volatile data pointer, volatile function pointer, and compiler memory barrier techniques are effective in practice with the compilers we tested. The performance of the C library implementation represents the expected performance of non-inlined platform-provided solutions (Section 3.1) and the separate compilation (Section 3.3.1) and weak linkage (Section 3.3.2) techniques without link-time optimization. The performance of GCC and Clang intrinsics represents the expected performance of inlined platform-provided solutions (Section 3.1) as well as the memory barrier technique (Section 3.4.3), assuming the scrubbing function is inlined. The benchmarking code calls a generic scrub function, which then calls the specific scrubbing routine to be tested; this code is allowed to be optimized, so as a result the scrubbing routine is typically inlined within the generic scrub function. Program executions were tied to the same CPU core to ensure that consistent hardware was used across tests.The tests were done on an Intel Xeon E5-2430 v2 processor with x86_64 architecture and a 32KB L1d cache, 32KB L1i cache, and 256K L2 cache running Ubuntu 14.04 with Linux kernel 3.13.0-100-generic. The left plot (Figure 1a) shows the result of compiling each technique using Clang 3.9, the right plot (Figure 1b) shows the result of compiling each technique using GCC 6.2. The fine solid black line is performance of plain memset when compiled with the -fno-builtin-memset option, which instructs the compiler not to use its own builtin intrinsic memset instead of calling the C standard library implementation. Its poor performance reflects the numerous developers reports complaining about its slow speed, for example Tor Ticket #7419 titled "Choose a faster memwipe implementation" [2]. "custom assembly" improves from 2 3 to 2 4 byte block sizes because above that threshold it qword-aligns its pointer in order to perform movq instructions.Furthermore, at some point (≥ 2 9 bytes for Clang; ≥ 2 14 bytes for GCC) the built-in memset defers to using libc's memset, hence it is identical to "volatile function pointer" given large block sizes. Upon first examining our results, we were surprised to find that the GCC-compiled "plain memset" with -fno-builtin-memset did as well as "plain memset" with the built-in intrinsic memset. As a result, we found that string.h (where memset is declared) changes its be-havior based on the value of the _FORTIFY_SOURCE macro, as described in Section 3.2. For each project, we set out to determine whether a memory scrubbing function is available, effective, and used consistently by the projects' developers. All eleven projects used one or more of the techniques described in Section 3 to clear sensitive data, and seven of them relied on a combination of at least two techniques.If a project relied on more than one technique, it automatically chose and used the first technique available on the platform in order of preference specified by the developer. is a custom assembly implementation, Barrier is the memory barrier technique, VDP is the volatile data pointer technique, VFP is the volatile function pointer technique, Comp. The most popular of the do-it-yourself approaches are the volatile data pointer (VDP) and volatile function pointer (VFP) techniques, with the latter being more popular with projects that attempt to use a platform-provided function first.Effectiveness. To determine whether a function was used consistently, we instrumented the Clang 3.9 compiler to report instances of dead store elimination where a write is eliminated because the memory location is not used afterwards. We did not report writes that were eliminated because they were followed by another write to the same memory location, because in this case, the data would be cleared by the second write. We then examined each case to determine whether the memory contained sensitive data, and whether dead store elimination took place because a project's own scrubbing function was not used or because the function was ineffective. - - - - - - - - - 1 OpenVPN 8 8 2 6 0 - - - - - - - - - 1 Kerberos 10 2 9 0 1 1 - - - 2* - - - - 3 Libsodium 0 0 0 0 0 1 3 2 - - 5 - - 4 - Tarsnap 11 10 10 1 0 - - - - - 1 - - - - Libgcrypt 2 2 0 2 0 - - - - - 1 - - - - Crypto++ 1 1 0 1 0 - - - 1 - 2 - - - - Tor 4 0 4 0 0 1 2 3 4 - - 5 6 - - Bitcoin 0 0 0 0 0 - - - 1 - - 2 3 - - OpenSSH 0 0 0 0 0 - 1 2 - - - 3 - - - OpenSSL 0 0 0 0 0 - - - 1 - - 2 3 - -Removed ops. The Heap, Stack, and H/S columns indicate whether or not the cleared memory was allocated on the heap, on the stack stack, or potentially on either heap or stack.Of the eleven projects examined, four had an effective scrubbing function but did not use it consistently, resulting in a score of inconsistent, denoted in Table 1. As the results in Table 1 show, only three of the eleven projects had a scrubbing function that was effective and used consistently.We notified the developers of each project that we scored flawed or inconsistent. OpenVPN 2.3.12 does not have a reliable memory scrubbing implementation since it uses a CLEAR macro which expands to memset. Otherwise it uses a memory barrier that may not prevent the scrubbing operation from being removed when the code is compiled with Clang (see Section 3.4.3). Furthermore, even though zap is available (and reliable on Windows), plain memset is still used throughout the code to perform scrubbing. Tor defines memwipe, which reliably scrubs memory: it uses Windows' SecureZeroMemory if available, then RtlSecureZeroMemory if available, then BSD's explicit_bzero, then memset_s, and then OPENSSL_cleanse, which is described below. We found no removed scrubbing operations in version 1.1.0b. Network Security Services (NSS) is an TLS/SSL implementation that traces its origins to the original Netscape implementation of SSL [18]. Then if weak symbols are supported, it uses a technique based on weak linkage, otherwise it uses the volatile data pointer technique. All memory scrubbing operations used sodium_memzero, and since Libsodium is not compiled with link-time optimization, no scrubbing operations using sodium_memzero were removed. Libgcrypt defines wipememory, which is a reliable way of scrubbing because it uses the volatile data pointer technique. Crypto++ defines SecureWipeBuffer, which reliably scrubs memory by using custom assembly if the buffer contains values of type byte, word16, word32, or word64; otherwise it uses the volatile data pointer technique. OpenSSH defines its own explicit_bzero, which is a reliable way of scrubbing memory: it uses BSD's explicit_bzero if available, then memset_s if available. To remedy this state of affairs, we developed a single memory scrubbing technique that combines the best techniques into a single function, described in Section 6. We consider a store, either a store IR instruction, or a call to LLVM's memset intrinsic, to be a potential scrubbing operation if O The stored value is a constant, O The number of bytes stored is a constant, and O The store is subject to elimination because the variable is going be out of scope without being read.The first two conditions are based on our observation how scrubbing operations are performed in the real code. It is worth considering an alternative approach to ensuring that sensitive data is scrubbed: The developer could explicitly annotate certain variables as secret, and have the compiler ensure that these variables are zeroed before going out of scope. We compiled and ran the SPEC 2006 benchmark under four compiler configurations: -O2 only, -O2 and -fno-builtin-memset, -O2 with DSE disabled, and -O2 with our scrubbing-safe DSE. As a result, any implementation of a secure memset based on the volatile qualifier is not guaranteed to work with every standardcompliant compiler.Second, it's very tricky in practice to make sure that a secure scrubbing function works well. We released it into the public domain so that developers can use it freely and collaborate to adapt it to future changes to the C standard, platforms or compilers.Third, even if a well-implemented secure scrubbing function is available, developers may forget to use it, instead using the standard memset which is removed by the compiler. To solve the problem, we implemented the secure DSE, a compiler-based solution that keeps scrubbing operations while remove dead stores that have no security implications, and secure_memzero, a C implementation that have been tested on various platforms and with different compilers. Our case studies in Section 5 were performed with this tool.Since scrubbing operations are removed in a compiler's dead store elimination optimization pass, we instrumented the DSE pass in LLVM/Clang 3.9.0 to report these instances.