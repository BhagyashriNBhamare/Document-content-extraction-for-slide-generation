IPsec enables cryptographic protection of IP packets. We found Bleichenbacher oracles in the IKEv1 implementations of Cisco (CVE-2018-0131), Huawei (CVE-2017-17305), Clavister (CVE-2018-8753), and ZyXEL (CVE-2018-9129). Examples for large industrial VPNs are the ANX (Automotive Network Exchange), ENX (European Network Exchange), and JNX (Japanese Network Exchange) associations, which connect vehicle manufacturers with their suppliers [1][2][3] Figure 1: The relationship between IKEv1 Phase 1, Phase 2, and IPsec ESP. In contrast to other widespread cryptographic protocols like TLS (Transport Layer Security) or SSH (Secure Shell), which operate at the application layer, IPsec allows to protect every IP based communication. When transmitting payload data, IPsec uses two different data formats to protect IP packets: AH (Authentication Header) for integrityonly setups and ESP (Encapsulating Security Payload) for confidentiality with optional integrity.IKE. There are two different versions of IKE named IKEv1 (1998) and IKEv2 (2005 . The numbers at the curly brackets to the left denote the number of messages to be exchanged in the protocol.previous version, both are still available in all implementations and both can be configured for actual use in all major operating systems and network devices. In IKEv1, four authentication methods are available for Phase 1 (cf. subsection 2.2): Two RSA encryption based methods, one signature based method, and a PSK (Pre-Shared Key) based method. In this paper, we make the following contributions:• We identify and describe Bleichenbacher oracles in the IKEv1 implementations of four large network equipment manufacturers, Cisco, Huawei, Clavister, and ZyXEL. • We show that the strength of these oracles is sufficient to break all handshake variants in IKEv1 and IKEv2 (except those based on PSKs) when given access to powerful network equipment. IKE is standardized in two major versions: Version 1, described in RFC 2409 [16] and accompanying documents, was published in 1998. It has been declared obsolete by the IETF (Internet Engineering Task Force), but it is nevertheless included in all implementations and still widely used. A main mode handshake consists of exactly six messages; an aggressive mode handshake compresses the protocol flow into only three messages. IKE uses random values called cookies (and denoted by c I and c R ) for this purpose; these cookies are present in each IKE header.The first two messages (m 1 and m 2 ) are used to negotiate on a proposal -a combination of different cryp- tographic algorithms, comparable to TLS ciphersuites. In messages m 3 and m 4 a DHKE is performed, together with the exchange of additional parameters called ancillary data (anc), depending on the chosen authentication method. Signature PKE & RPKE PSK k PRF n I ,n R (g xy ) PRF h(n I ,n R ) (c I , c R ) PRF PSK (n I , n R ) k d PRF k (g xy , c I , c R , 0) k a PRF k (k d , g xy , c I , c R , 1) k e PRF k (k a , g xy , c I , c R , 2) In Phase 1 of IKEv1, four different modes of authentication are available: (a) Digital signatures, (b) PKE (Public Key Encryption), (c) RPKE (Revised Public Key Encryption), and (d) PSKs (Pre-Shared Keys). This authentication mode assumes that each party owns an asymmetric key pair with valid certificates. The PKE based mode of authentication requires both parties to perform two public-and two private-key operations. For our analysis it is only important that IKEv2 (cf. Figure 6) shares two authentication methods with IKEv1, and that we can directly apply our attacks to impersonate an IPsec device in Phase 1 of IKEv2. Bleichenbacher's original paper [9] describes this process in further detail.Signature Forgery Using Bleichenbacher's Attack.It is well known that in the case of RSA, performing a decryption and creating a signature is mathematically the same operation. The ROBOT study [10] used this attack to forge a signature from Facebook's web servers as proof of exploitability.Optimized Bleichenbacher Attack In 2012, Bardou et al. [7] presented an optimization of the standard Bleichenbacher attack by trimming the initial space for m 0 . They divide a ciphertext by an integer t by multiplying it with t −e mod N with e being the public exponent of the oracle.In case the original plaintext was divisible by t, then the multiplication c 0 · u e · t −e is equal to m 0 t under the assumption that m 0 and m 0 · ut −1 are PKCS #1 v1.5 conforming. In Clavister's cOS and ZyXEL's ZyWALL USGs (Unified Security Gateways), PKE is not officially avail-Initiator (IDI , skI , pkI ) Responder (IDR, skR, pkR) m1 := (proposals) − cI , 0, m1 −−−−−−−−−− − → m2 := (proposal) ← − cI , cR, m2 −−−−−−−−−− − cn I := Encpk R (nI ) cid I := Encpk R (IDI ) m3 := (g x , cid I , cn I ) − cI , cR, m3 −−−−−−−−−− − → cn R := Encpk I (nR) cid R := Encpk I (IDR) m4 := (g y , cid R , cn R ) ← − cI , cR, m4 −−−−−−−−−− − k := PRF h(nI ,nR) (cI , cR)Derive kd, ka, ke from kk := PRF h(nI ,nR) (cI , cR) Derive kd, ka, ke from k Compute MACI using k m5 := Enck e (MACI ) − cI , cR, m5 −−−−−−−−−− − → Compute MACR using k m6 := Enck e (MACR) ← − cI , cR, m6 −−−−−−−−−− − Compute MACR andcompare to m6Compute MACI and compare to m5 able. We were able to confirm the existence of Bleichenbacher oracles in all these implementations (CVE-2018-0131, CVE-2017-17305, CVE- 2018-8753, and CVE-2018, which are explained in depth in sections 5 -7. The attackers initiate an IKEv1 PKE based key exchange with Responder A and adhere to the protocol until receiving message m 4 . For Cisco and ZyXEL, we know that t timeout ≥ 60s, for Clavister and Huawei t timeout ≥ 30s. For that, the connection is interrupted by the attackers and on the following attempt to restart the IKEv1 session with a handshake, the attackers execute a Bleichenbacher decryption attack against each party. Each theoretical description of some public key primitive starts with something like (pk, sk)$ ← KeyGen(1 κ )to indicate that freshly generated keys should be used if the security proof should remain valid. As a result, cross-ciphersuite [26] and cross-version [20] attacks have been shown, despite security proofs for single ciphersuite families.For IKE, there is a similar situation: Maintaining individual key pairs for all "ciphersuite families" and versions of IKE is practically impossible and oftentimes not supported. The actual security of the protocol family in this case crucially depends on its cross-ciphersuite and cross-version security. From these keys they need k pI to compute) (kd, kaI , kaR, keI , keR, kpI , kpR) ← PRFs(nI , nR, cI , cR) IKE AUTH Messages Encrypted-then-MACed with (keI , kaI ), (keR, kaR)MACI ← PRFk pI (IDI ) σI ← Sign skI (cI , 0, m1, nR, MACi) m3 := (IDI , σI , proposalR) − cI , cR, m3 −−−−−−−−−− − → MACR ← PRFk pR (IDR) σR ← Sign skR (cI , cR, m2, nI , MACR) m4 := (IDR, σR, proposalR) ← − cI , cR, m4 −−−−−−−−−− − (k eI , k aI , k eR , k aR ) ← PRFk d (nI , nR)MAC I = PRF k pI (ID B ), which is part of the data to be signed with the private key of Responder B. 2. For Cisco IOS, we know that t timeout ≥ 240s. The attackers initiate several parallel PKE based key exchanges with Responder B.• In each of these exchanges, they send and receive the first two messages according to Fig- ure 4. Cisco includes the PKE authentication mode in IOS, which is the operating system on the majority of Cisco routers and current Cisco switches. For our tests, we used a Cisco ASR 1001-X router running IOS XE in version 03.16.02. With it, we can create any IKE message and fully control all fields like cookies, proposals, nonces, ciphertexts, etc.Ciphertext c n I in Figure 4 is the target of our attack. For testing PKCS #1 v1.5 compliance, after decrypting c n I , the responder should check if the first two bytes of the plaintext are indeed 0x00 0x02, if the following eight bytes are non-zero, and then search for the first zero byte. Furthermore, IOS ignores c ID I and determines the public key to use for its response based on the IP address of the initiator. From our observations, we assume that all cryptographic calculations for IKE are done by the device's CPU despite it having a hardware accelerator for cryptography. With 1024-bit RSA keys, our test device is capable of handling only 850 Bleichenbacher requests per second on average. We also saw significant CPU load after around 64,000 Bleichenbacher oracle requests, possibly caused by a memory limitation of our test device. After a fifth retransmission of any Phase 1 packet, IOS waits one last time for ten seconds before canceling the handshake. This translates to a maximum of 60 seconds between two messages sent from the peer.For an attack, the attackers require the victim's DHKE share that is sent with message m 3 or m 4 , depending on the role the attackers play. For PKE authentication, both implementations use the key pair that is configured for IKEv1 authentication with signatures. When sending an invalid ciphertext c n I with message m 3 , we receive an error message containing only 16 seemingly random bytes. For our tests, we used a Huawei Secospace USG2205 BSR firewall running firmware version V300R001C10SPC700.The steps for setting up an IPsec configuration are very similar to Cisco. Similar to Cisco, we configured a proposal, a policy, and a policy-template so that only IKEv1 with RPKE authentication is allowed.Again, ciphertext c n I (cf. Figure 8) is the target of our attack. Thus, Huawei's Bleichenbacher oracle has an additional false negative rate of 56.64 %, which is explained in more detail in the next section. It only cancels processing if the value of the padding length byte is larger than the decrypted ciphertext or if the padding length byte is zero.In contrast to Cisco, we observed that the Huawei device as responder thoroughly checks the identity payload c ID I sent by the initiator. If the plaintext identity ID I after removing the padding is 121 or less bytes in length, the device however ignores the identity value and continues the handshake using the initiator's configured public key based on its IP address. The longer the length of c ID I , the higher the possibility that the value of the padding length byte is below the plaintext length so that no padding error occurs.Regardless of the length of c ID I , the padding length byte can only decrypt to one of 256 possible values. Taking into account that the length of c ID I has to be a multiple of 16 (the block length of AES), the attackers have to choose between a c ID I with a length of 128 bytes and one with 112 bytes. In order to keep the required time for an attack below the limits, we built a highly parallelized Bleichenbacher attacker using Java (cf. Figure 10). the SA was not recently used for a request and message m 2 was a retransmission after ten seconds.When preparing a Bleichenbacher request, an SA is taken from the unused SA pool and put into the used SA pool to ensure that SAs are not mixed up. We implemented two distribution mechanism (multiple and single interval) in order to address the different steps in Bleichenbacher's attack.The consumers do the expensive computations for the Bleichenbacher attack. If the public key of our ASR 1001-X router is 1024 bits long, we measured an average of 850 responses to Bleichenbacher requests per second. Therefore, an attack must succeed with at most 51,000 Bleichenbacher requests.Based on this result, we used our Cisco oracle simulator to measure the percentage of attacks that would succeed before the time runs out. However, in 78 simulations, we needed less than 51,000 request to decrypt the nonce and thus could have impersonated the router.Optimized Bleichenbacher. The main obstacle is the SA management: Once the attackers negotiate several thousand SAs with the router, its SA handling becomes very slow.We managed to perform a successful decryption attack against our ASR 1001-X router with approximately Cisco Bleichenbacher attack statistic Figure 11: Statistics of 990 standard decryption, 439 optimized decryption, and 542 signature-forgery attacks against our Cisco Bleichenbacher oracle simulator.19,000 Bleichenbacher requests. Note that a too slow Bleichenbacher attack does not permanently lock out attackers. If the victim has deployed multiple responders sharing one key pair (e. g. for load balancing), this could also be leveraged to speed up an attack. Note that due to the increased time limit, attacking IKEv2 with a forged signature has a higher success rate than the same attack on IKEv1. Other applications include interconnecting devices like with Bluetooth, Wi-Fi, or IKE. If victim and responder already have an active connection, the attackers bacher vulnerabilities in OpenSSL, JSSE (Java Secure Socket Extension), and a TLS hardware accelerator chip [27]. Another famous cross protocol attack is DROWN [6], which exploits the broken SSL 2.0 to break the current TLS 1.2. In this paper, we have shown that all versions and variants of the IPsec's Internet Key Exchange (IKE) protocol can be broken, given two entry points.The first entry point is weak PSKs. Offline dictionary attacks are possible against all three different variants, with two different adversaries: IKEv1 PSK in aggressive mode can be broken by a passive adversary, and both IKEv1 PSK in main mode and IKEv2 PSK can be broken by an active adversary who acts as a responder.The second entry point is Bleichenbacher oracles in the IKEv1 PKE and RPKE variants. In their documentation [12], Cisco states the following:If you plan to have both types of RSA authentication methods in your IKE policies, you may prefer to generate special-usage keys. We have not evaluated whether special usage keys are a working countermeasure against our key reuse attack. The current standard RFC 5996 [23] mentions that it is generally not smart to rely only on a user chosen password and recommends to use IKEv2 together with EAP (Extensible Authentication Protocol) protocols. However, in practice IKEv2 is usually used without EAP.Instead of using IKEv2 together with some EAP-TLS variant (like EAP-TTLS with EAP-MD5), one could also switch to OpenVPN and thus reduce the overhead from tunneling TLS in IKEv2. These flaws can be resolved by integrity protection. Though the vulnerability is not protocol-related, the majority of vulnerabilities have been found in TLS implementations. Supplementary to the description of the IKEv2 variant (cf. Figure 6), here we present the IKEv1 signature authentication mode in detail. Figure 13 shows the message flow for this mode.First, the initiator creates a set of proposals consisting of algorithms, key lengths, and additional parameters and sends it with his initiator cookie to the responder. C Key Types of Cisco IOSOur key reuse attack assumes that the same RSA key pairs are used for encryption and signatures. When generating RSA key pairs, Cisco IOS gives the administrator a choice: The default is to create general-keys, which generates a single key pair for all authentication methods that is vulnerable to our attacks. Ultimately, our research indicates that implementations only support IKEv2 with EAP for remote access of a user to a network. IPsec and IKE For some time, real-world cryptographic research in the area of IPsec concentrated on the encryption layer. Even though the seminal work by Bleichenbacher dates back to 1998 [9], Bleichenbacher vulnerabilities are discovered regularly. Figure 13 shows the message flow for this mode.First, the initiator creates a set of proposals consisting of algorithms, key lengths, and additional parameters and sends it with his initiator cookie to the responder. In order to confirm the keys and authenticate against each other, a MAC is computed by each party using key k from the key derivation. After both peers exchanged their signatures and optionally the corresponding certificates, they validate the signatures and continue with Phase 2 only if the signatures are valid. When generating RSA key pairs, Cisco IOS gives the administrator a choice: The default is to create general-keys, which generates a single key pair for all authentication methods that is vulnerable to our attacks.