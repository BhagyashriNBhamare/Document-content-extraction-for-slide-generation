As a dynamic analysis tool, Malton runs on real mobile devices and provides a comprehensive view of malware's behaviors by conducting multi-layer monitoring and information flow tracking, as well as efficient path exploration. For instance, since the majority of static analysis tools inspect the Dalvik bytecode [2], malware circumvent them by using various obfuscation techniques to raise the bar of code comprehension [61], implementing malicious activities in native libraries to evade the inspection [13,59,70,92], and leveraging packing techniques to hide malicious payloads [82,85,88]. For example, the percentage of packed * The corresponding author.Android malware has increased from 10% to 25% [36], and 37.0% of the Android apps execute native code [11]. Most of the existing tools either rely on emulators (e.g., DroidScope [83]) or modify the old Android runtime (i.e., Dalvik Virtual Machine, or DVM for short) to monitor malware behaviors (e.g., TaintDroid [38]). However, existing systems are not effective in capturing the execution of all malicious payloads, because they are impaired by the inherent limitation of dynamic analysis (i.e., low code coverage) and the lack of efficient code path exploration technique.In this paper, we propose Malton, a novel on-device non-invasive analysis platform for the ART runtime. It records the invocations of Java methods, including sensitive framework APIs and the concerned methods of the malware, in the framework layer, and captures stealthy behaviors, such as dynamic code loading and JNI reflection, in the runtime layer. Second, to conduct efficient path exploration on mobile devices with limited computational resources, we propose an offloading mechanism to move heavy-weight tasks (e.g., solving constraints) to resourceful desktop computers, and an in-memory optimization mechanism that makes the execution flow return to the entry point of the interested code region immediately after exiting the code region. • We implement the system named Malton by solving several technical challenges (e.g., cross-layer taint propagation, on-device Java method tracking, execution path exploration, etc.). ART is the new runtime introduced in Android version 4.4, and becomes the default runtime from version 5.0. When an app is being installed, its Dalvik bytecode in the Dex file is compiled to native code 1 by the dex2oat tool, and a new file in the OAT format is generated including both the Dalvik bytecode and native code. The OAT format is a special ELF format with some extensions.The OAT file has an oatdata section, which contains the information of each class that has been compiled into native code. Hence, we can find the information of a Java class in the oatdata section and its compiled native code through the oatexec symbol.When an app is launched, the ART runtime parses the OAT file and loads the file into memory. Although existing tools (e.g., CopperDroid [73]) can find that the malware reads IMSI and leaks the information by system call sys sendto(), they cannot locate the method used to get IMSI and how the IMSI is leaked in detail, because sys sendto() can be called by many functions (e.g., JavaMail APIs, Java Socket methods and C/C++ Socket methods) from both the framework layer and the native layer. Malton can solve this problem because it performs multi-layer monitoring.When cmd equals 5, the content of SMS, which is obtained from the framework layer (Line 37), will be parsed in the JNI method parseMSG() (Line 2) by native code. Although taint analysis could identify this information flow, existing static instrumentation based tools (e.g., TaintART [71] and ARTist [21]) cannot track the information flow in the native code. Malton can tackle this issue since it offers cross-layer taint analysis.Moreover, as shown in the method procCMD() (Line 11), the malware performs different activities according to the parameter cmd. Malton runs in real Android devices and conducts multi-layer monitoring, information flow tracking, and path exploring. After running a malware sample, Malton generates logs containing the information of method invocations and taint propagations at different layers and the result of concolic executions. For example, the taint propagation module in the instruction layer needs the information about the Java methods that are parsed and processed in the framework layer.Malton is built upon Valgrind [53] (V3.11.0) with around 25k lines of C/C++ codes calculated by CLOC [1]. To address this challenge, we propose an efficient way to bridge the semantic gaps between the low level native instructions and upper layer Java methods.Java Method Tracker To track the Java method invocations, we need to identify the entry point and exit points of each Java method from the ARM instructions dynamically. Specifically, the OAT file contains the information of each compiled Java method (ArtMethod), including the method name, offset of the ARM instructions, access flags, etc. If so, Malton inserts the helper function (i.e., callTrack()) at the beginning of the block to record the method invocation and parse arguments when it is executed.To identify the exit point of a Java method, Malton leverages the method calling convention of the ARM architecture 2 . Hence, in callTrack(), Malton pushes Figure 3: The example of parsing the Java object of the result of TelephonyManager.getDeviceId() the value of lr into the method call stack since lr could be changed during the execution of the method. If they are equal, an exit point of the method is found, and this return address is popped from the method call stack.Malton parses the arguments and the return value of the method after the entry point and the exits point of the method are identified, respectively.According to the method calling convention, the register r0 points to the ArtMethod object of current method, and registers r1 − r3 contain the first three arguments. According to its method shorty, we know that the return value of this API is a Java object represented by an Object instance, of which the memory address is stored in the register r0. To capture stealthy behaviors that cannot be monitored by the Java method tracker in the Android framework layer, Malton further instruments the ART runtime (i.e., libart.so). While the invoked Java method could be tracked by the Java method tracker in the Android framework layer, Malton tracks the JNI reflection to provide a comprehensive view of malicious behaviors, such as, the context when privacy-concerned Java methods are invoked from the native code. Native code loading means that malicious code could be implemented in native code and loaded into memory, where Java code loading refers to loading the Dalvik bytecode. Since malware usually receives the control commands and sends private data through network, Malton inspects these behaviors by wrapping network related system calls, such as, sys connect(), sys sendto(), recvfrom(), etc.• File operations. As malware often accesses sensitive information in files and/or dynamically loads malicious payloads from the file system, Malton records file operations to identify such behaviors. Since packed malware usually dynamically modifies its own codes through memory operations, like sys mmap(), sys protect(), etc., Malton monitors such memory operations. As malware often needs to fork new process, or exits when the emulator or the debug environment is detected, Malton captures such behaviors by monitoring system calls relevant to the process operations, including sys execve(), sys exit(), etc.Moreover, Malton may need to modify the arguments and/or the return values of system calls to explore code paths. Call a C function.information in the upper layers, such as the method invocations for identifying the information flow, etc. To propagate taint tags across different layers, Malton works at the instruction layer because the codes of all upper layers become ARM instructions during execution. Load the value stored in memory. A call to a pure (no side-effects) helper C function.For Malton, there are 9 types IR statements related to the taint propagation, which are listed in Table 2. During the execution of the target app, Malton parses the IR statements and expressions in the helper functions, and propagates the taint tags according to the logic of the IR statements and expressions.Malton supports taint sources/sinks in different layers (i.e., the framework layer and the system layer). By default, at the framework layer, 11 types of information are specified as taint sources, including device information (i.e., IMSI, IMEI, SN and phone number), location information (i.e., GPS location, network location and last seen location) and personal information (i.e., SMS, MMS, contacts and call logs). Specifically, taint analysis helps the analyst identify the code paths depending on the inputs, such as network commands, and the concolic execution module can generate the required inputs to explore the interested code paths. Instead, we detail the offloading mechanism and the in-memory optimization used in the concolic execution module, and explain how the direct execution engine works.Concolic Execution: Offloading Mechanism It is nontrivial to apply concolic execution in analyzing Android malware on real devices, because concolic execution requires considerable computational resources, resulting in unacceptable overhead on the mobile devices. Moreover, the analyst can select the IR statement that lets the input have concrete values as the entry point of the code region, and choose the exit statement (i.e., Ist Exit) or the next statement (i.e., Ist Next) of the subroutine as the exit point of the code region.Malton runs the malware sample until the exit point of the interested code region for collecting constraints and generating new inputs for different code paths through an SMT solver. For example, to change the source telephone number of a received SMS to explore certain code path (Line 41 in Listing 1), Malton can wrap the framework API SmsMessage.getOriginatingAddress() and modify its return value to a desired number at the exit points.To set the guard value of the Ist Exit statement, we insert a helper function before each Ist Exit statement and specify the guard value to the result of the helper function. The first column shows the type of sensitive behaviors, and the following columns list the numbers and percentages of malware samples that have been detected by each system due to the corresponding sensitive behaviors . To answer Q2, we evaluate Malton with sophisticated malware samples by constructing the complete flow of information leakage across different layers, detecting stealthy behaviors with Java/JNI reflection, dissecting the behaviors of packed Android malware, and identifying the malicious behaviors of hidden code. Then, a new instance of the class CursorWrapper 6 The number in each ellipse denotes the step index.is created based on id and uri (com.android.contact), and this contact's phone number is acquired through this instance. The number in the ellipse and rectangle is the step index, and we use different colours (i.e., Figure 5: Malton can detect stealthy behaviors through the Java/JNI reflection of the photo3 malware. In step 3, a memory area is allocated by the system call sys mmap(), and the thread method run() is invoked by the runtime through the JNI reflection function InvokeVirualOrInterfaceWithJValues() in step 4. Malton empowers us to observe that the ART runtime invokes the function FindClass() (Line 8) and the function LoadNativeLibrary() (Line 9) to locate the class com.netease.nis.wrapper.MyJni and load the library libnesec.so, respectively.After initialization, the malware calls the JNI method MyJni.load() to release and load the hidden Dalvik bytecode into memory. Note that ZjDroid [9] is a dynamic unpacking tool based on the Xposed framework and is started by the Intent com.zjdroid.invoke.By registering the Intent receiver, the malware can detect the existence of ZjDroid.Finally, the app loads and initializes the class v.v.v.MainActivity in Line 23 to 26, and the hidden malicious payloads are executed at Line 29. Detected behavior Number of executed blocks "cq" Read information SMS contents, contacts, device model and system version, then send to 292019159c@fcvh77f.com with password "aAaccvv11" through SMTP protocol. For example, when exploring the paths decided by the command "df", Malton only needs to execute 5k IR blocks with in-memory optimization.Otherwise, it has to execute 22,970k IR blocks. The concolic execution engine generates the satisfying inputs to execute certain code paths, and the direct execution engine forcibly executes selected code paths when the constraint resolver fails. Nevertheless, it's an arm race between the analysis tool and anti-analysis techniques.Second, though the in-memory optimization significantly reduces the code required to be executed, it is semi-automated because the analysts have to specify the entry point and the exit point of the interested code region. Moreover, as Malton only defines the default sensitive APIs, users can add more sensitive APIs to Malton.Last but not least, though Malton uses taint analysis to track sensitive information propagation, it cannot track implicit information flow and propagate taint tags over indirect flows.We will enhance it by leveraging the ideas in [45]. According to the implementation techniques, the existing (dynamic or hybrid) Android malware analysis tools can be roughly divided into five types: tailoring Android system [34,39,71,89], customizing Android emulator (e.g., Qemu) [73,83], modifying (repackaging) app implementation [37], employing system tracking tools [84], or leveraging an app sandbox [20,24]. Mobile-Sandbox [68] uses TaintDroid to monitor framework behaviors and employs ltrace [5] to capture native behaviors.To avoid modifying Android system (including the framework, native libraries, Linux kernel etc.), a number of studies [10,12,22,23,31,32,43,60,61,67,78,81,87] propose inserting the logics of monitoring behaviors or security policies into the Dalvik bytecode of the malware under inspection and then repacking it into a new APK. ANDRUBIS [50] and MARVIN [49] (which is built on top of ANDRUBIS) monitor the behaviors at the framework layer by instrumenting DVM and log system calls through VMI.TaintDroid [39] 񮽙 񮽙 × × × × × × Dynamic TaintART [71] 񮽙 × 񮽙 × × × × × Dynamic ARTist [21] 񮽙 × 񮽙 × × × × × Dynamic DroidBox [34] 񮽙 񮽙 × × × × × × Dynamic VetDroid [89] 񮽙 񮽙 × × × × × × Dynamic DroidScope [83] × 񮽙 × × × × × 񮽙 Dynamic CopperDroid [73] × 񮽙 񮽙 × × × × 񮽙 Dynamic Dagger [84] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic ARTDroid [30] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic Boxify [20] 񮽙 񮽙 񮽙 × × × × 񮽙 Dynamic CRePE [29] 񮽙 񮽙 × × × × × × Dynamic DroidTrace [91] 񮽙 񮽙 񮽙 × × × × 񮽙 DynamicMonitoring system calls [17,35,46,48,54,68,75,76,84,91] is widely used in Android malware analysis because considerable APIs in upper layers eventually invoke systems calls. CRePE [29] and DroidTrack [64] track apps' behaviors at the framework layer by modifying Android framework.Boxify [20] and NJAS [24] are app sandboxes that encapsulate untrusted apps in a restricted execution environment within the context of another trusted sandbox app. Moreover, they do not support the analysis of native code.To make concolic execution applicable for testing embedded software, Chen et al. [28] and MAYHEM [26] adopt similar offloading method. Malton provides a comprehensive view of the Android malware behaviors, by conducting multilayer monitoring and information flow tracking and efficient path exploration without the need of modifying the malware.