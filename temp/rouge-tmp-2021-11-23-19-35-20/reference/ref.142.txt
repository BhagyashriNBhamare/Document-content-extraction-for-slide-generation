Our study shows that only 5% of libc is used on average across the Ubuntu Desktop environment (2016 programs); the heaviest user, vlc media player, only needed 18%. In this paper: (1) We present a debloating framework built on a compiler toolchain that can successfully de-bloat programs (shared/static libraries and executables). For example, the standard C library (libc) is intended to be widely useful, and usable across a broad spectrum of applications although not all features are used by all applications. As a typical example, shared libraries are designed to contain the union of all functionality required by its users.Static dead-code-elimination -a static analysis technique used to identify unused code paths and remove them from the final binary -employed during compilation is an effective means to reduce bloat. Alternatively, programs can be statically linked (to apply dead-code elimination), but there are two main hurdles: patches to libraries require recompilation of all programs, which is not feasible, and licenses such as (L)GPL can complicate redistribution. Dynamic linking is key to practical and backwards-compatible solutions.To exemplify the security impact of bloating, consider libc, a Swiss Army knife in the arsenal of an attacker [34]. As a direct impact, our solution significantly increases the effectiveness of current software defense by drastically reducing the amount of code they must analyze and protect.We identify and remove unused code by introducing a piece-wise compiler that not only compiles code modules (executables, shared and static objects), but also generates a dependency graph that retains all compiler knowledge on which function depends on what other function(s). Here, and in the rest of this paper, we use the generalized term "code module" to signify a shared library, static library or an executable and "loader" to signify both loader and dynamic linker.CFI vs Piece-wise. In essence, libc protected by both piece-wise and CFI exposes significantly less attack space than libc protected by only CFI. We perform a comprehensive study of how glibc and other shared libraries are used in a set of over 2016 diverse programs across different domains (e.g., http server, database, MPEG players, document editors) in Ubuntu Desktop 16.04. We also introduce a backward compatible piece-wise loader that eliminates bloat.3. We demonstrate that several real world vulnerabilities in unused code can be successfully eliminated using our piece-wise compiler and loader.The rest of this paper is organized as follows. For each program, we 1) identified all libraries the program depends on using ldd; 2) identified all functions imported by the program and which library the symbol can be found in as well as their intra-modular dependencies; and 3) for each dependent library, identified the exported functions that were never imported by the program. In essence, we recursively traversed through all dependent code modules of a program and gathered all the function-level dependencies.On average, only 10.22% of functions in the top 15 most used shared libraries are used by programs (full results in Appendix A). For example, libc provides subroutines for memory management (e.g., malloc, calloc, free), file I/O (e.g., fopen, fclose, printf, scanf), string manipulation (e.g., strcpy, toupper, tolower), etc. If available, the dynamic linker will bind the symbol names to the strong definitions, rendering the weak definitions redundant; the unused weak implementation remains in memory and contributes to bloating.For example, glibc 2.19 hosts 610 (29%) functions that are marked as weak symbols including popular memory management functions like calloc. Debloating requires precise identification of programwide intra-and inter-modular dependencies, which introduces several challenges:1. Dependencies within hand-written assembly code: Generating inter-dependencies for assembly code in a module at compile time is challenging because assembly code is not analyzed by the compiler, and function boundaries in optimized code are sometime slurred.5. This is because while existing compile-and linktime optimizations can eliminate unused code within a compilation unit, bloat arising due to dynamically loaded modules persists due to the vast amounts of disjoint functionalities in shared libraries.At first glance, dynamically linked libraries are designed for code reuse (e.g., one copy of a library is resident in memory for multiple processes) and fine-grained function-level fragmentation of libraries in which each function and its dependencies are encapsulated within a single shared library may be an appealing solution. At a high-level, our approach bridges the traditional information gap between early (compilation) and late (loading) stages of a program. Specifically, (1) we develop a piece-wise compiler that maintains intra-modular (piece-wise) dependencies between each individual functionality (i.e., entry point) and all dependent functions that are necessary to satisfy execution, and (2) we develop a piece-wise loader that examines the dependencies of an executable and generates an inter-modular fullprogram dependency graph. Optional sections are ignored by unmodified loader, meaning our ELF files are backwards compatible with older loaders. This way, any COTS software can take advantage of our piece-wise technique by simply replacing the shared libraries in a system with piece-wise compiled shared libraries and replacing the loader with our piece-wise loader.Correctness. For a given code module, the piece-wise compiler has two main tasks: generate a function-level dependency graph with zero false negatives (we do not want to miss any legitimate dependency), and write this dependency graph to the binary. Thus, a dependency graph is effectively an annotated inter-procedural control flow graph. Below, we detail the treatment of such cases to ensure complete dependency recovery.Two factors can have a significant effect on the accuracy of a call graph: code pointers and jump tables, and hand-written assembly (this includes pure-assembly functions and inlined assembly). The piece-wise compiler uses the call graph analysis pass of LLVM to extract dependencies arising due to direct calls between functions. Pointers that target external function (still associated with symbols) can be reconciled at load time when all of the external modules are loaded along with the symbol information. Variable f is a global IO structure that contains a pointer to the write function. For example, in libc, a 'FILE' struct with a set of function pointers is created for every IO operation.In order to obtain a complete set of code pointer references within a module, we perform code-pointer anal-ysis (function pointer analysis + jump table recovery) to recover all potential code references either to functions or to code snippets (e.g., targets in switch statement). In this approach, our compiler statically generates a global set of functions as global dependency for the entire module. While this approach may not result in optimal code reduction, it is fast and is guaranteed to include all possible targets of indirect branches.Localized Code Pointer Scan. This is unlike the full-module scan where comp is marked as required for the entire module.1 ... 2 int comp ( int a , int b ) {...} 3 int foo () { ... /* foo is a global symbol */ 4 sort ( arr , len , & comp ) ; } 5 ... First, use-def chains are constructed for all IR instructions. When compared to the full-module scan, by leveraging symbol binding information available, this approach improves dependency graph's correctness and debloats more aggressively, but at the cost of analysis performance.Pointer Analysis. When an assignment a = b is encountered, locations pointed to by b are assumed to be a subset of locations pointed to by Our implementation is based on the algorithm recently proposed by Sui et al. [37]. For each function within the dependency graph, we examine the code to identify all the types of C++ objects that are instantiated within the function and gather the corresponding VTables. Function GetFunctionDeps recursively traverses call graph to provide a complete list of dependencies for a given function. for each DepFunc ∈ GetFunctionDeps(Function) do Deps ← Deps ∪ GetDependencies(DepFunc) return Deps 13: end procedure each type of object, we include all of the virtual functions in the VTable for the corresponding class as a dependency for the function that instantiates the object. Compilers do not optimize hand-written and inline assembly code and, as such, interdependencies involving assembly code are handled separately.Dependencies in assembly code: We perform a single pass through assembly code to identify all function calls and update the callgraph accordingly. Our compiler inserts two types of information to assist the loader with identifying dead code: dependency relationships between functions (i.e. the dependency graph) that comprises of functions and a list of dependencies, and function-specific data that includes location and size in bytes for all the functions in the dependency graph. While the piece-wise compiler only embeds function dependency information in binary, it can retains more information to assist precise late-stage security enforcement such as CFI. To address this, our loader pre-loads all shared libraries.First, the piece-wise loader recursively traverses all shared objects and their dependencies (by looking at DT NEEDED entries of the dynamic section of the ELF file of the program executable) to construct the list of shared objects that the main program needs. Thus, as a result of late-stage piece-wise debloating, such functions are removed and unavailable in cases where dynamically loaded libraries require them. At load time, the piece-wise loader will interpret it, pre-load those libraries, and retain only the functions that dlsym invokes.We found that only 64/2226 (2.9%) programs in our study dynamically compute module names. As a result, the behavior is also runtime dependent.Since we pre-load libraries in the order they appear in an ELF file, symbol resolution is also performed in the same order. Therefore, all dependencies for a program are known before it begins execution.To determine which functions are not required at runtime, i.e., the ones that must be removed, we rely on symbol resolution and the dependency graph embedded in the . During symbol resolution, the loader binds an undefined symbol to the first available definition for the symbol in the load order which allows our loader to identify which library functions the program imports.At the end of symbol resolution, all symbols in the global symbol table are fully resolved and reflect the runtime necessities of the program. For example, if foo.exe depends on function myFoo, which is defined in both shared libraries a.so and b.so, the symbol is resolved to whichever library is loaded first. Both piece-wise-compiled modules and the piece-wise loader are backward compatible for two reasons. Second, when the piece-wise loader loads a code module without the . While we did not engineer the support for dynamically rewriting the binary to reduce memory overhead, we refer interested readers to artificial diversity research for an algorithm [21]. We implemented two different versions of piece-wise loaders: (1) the GNU loader (v2.23) distributed with Ubuntu Desktop 16.04, and (2) the loader packaged within musl-libc (v1.1.15). First, we added an LLVM module pass to handle code pointers, process points-to information (if applicable), parse function calls from assembly code and generate a dependency graph. To demonstrate that our toolchain correctly debloats code modules, we used the piece-wise compiler to build 400 shared libraries distributed with Ubuntu Desktop 16.04 and installed them using dpkg. We piece-wise compiled musl-libc, and computed the footprint for each category. In the best case, 86% attack space reduction was achieved with localized scan and pointer analysis, and in the worst case, 60% code reduction was achieved for full-module pointer scan.While on average, pointer analysis and localized code pointer scan yield the same attack space reduction results, for some cases in the SPEC CPU 2006 benchmarks, we observe that one outperformed the other. On the one hand, the localized scan approach provides better debloating results when it allows removing functions that will not have address taken at runtime because all referring functions Table 4: Gadget reduction in coreutils 8.2 and SPEC CPU 2006 benchmarks for 6 different types of security sensitive gadgets: syscall, stack pointer update (SPU), call-oriented programming (COP), call-site/call preceded gadgets(CS), jump-oriented programming (JOP), and entry-point (EP). First, we piecewise compiled a set of shared libraries (minus glibc). Next, we manually tested a variety of unmodified executables -FireFox, curl, git, ssh and LibreOffice programs that used the piece-wise compiled libraries. • Risks transferring bugs in a shared library to the binary.Since piece-wise aims to bring dead code elimination benefits from static linking to dynamic linking, in table 8, we compare whole-program code reduction achieved by static linking with late-stage debloating using piece-wise toolchain. Compile-time overhead.We measured execution time added by our LLVM pass for each of the three approaches (full-module scan, localized scan and inclusion-based points-to analysis) by inserting timing code at the beginning and end of pass' main logic. On average, the code piece-wise loader that performs debloating added 20 milliseconds to the each process load time across all coreutils programs.Second, because piece-wise loader writes to code pages that contain the copies of shared libraries, copyon-write is triggered, which results in additional load time overhead. CVE-2014-3707 [3] is an out-of-bound read vulnerability in function curl easy duphandle affecting libcurl versions 7.17.1 to 7.38.0 that can be exploited for memory disclosure and denial-of-service attacks. To make matters worse, after duplication, it fails to update the pointer to point to the new buffer which can trigger illegal use of freed memory if original object has been freed.Our evaluation shows that debloating libcurl when it is used with programs like curl or cmake completely removes the affected functions and therefore the bug can no longer be exploited to perform a memory disclosure or a denial-of-service attack as part of an exploit payload such as through a return-to-libc attack. Piece-wise compilation and loading is independent of, yet complements CFIbased approaches.Feature-based Software Customization.Unlike C/C++, managed programing languages whose execution is monitored by Runtime Virtual Machine suffers from significant runtime overhead or bloating due to the extra logic added to manage an execution environment. We implemented a prototype system that performs piece-wise compilation and loading. We evaluated the system and showed that libc can be debloated to eliminate significant code fragments from memory thereby reducing the attack space.