Unfortunately, in embedded systems , high-level source code (C/C++) is often mixed with handwritten assembly, which cannot be directly handled by current source-based tools. Inception Symbolic Virtual Machine, based on KLEE, performs symbolic execution, using several strategies to handle different levels of memory abstractions, interaction with peripherals, and interrupts. Finally, the Inception Debugger is a high-performance JTAG debug-ger which performs redirection of memory accesses to the real hardware. We first validate our implementation using 53000 tests comparing Inception's execution to concrete execution on an Arm Cortex-M3 chip. For example, the boot Read Only Memory (ROM) vulnerability used to jailbreak some iPhones cannot be patched in software, because the bootloader is hard-coded in the ROM [12]. Binary-only testing is frequently performed by third parties (pen-testing, vulnerability discovery, audit), whereas source code-based testing is more commonly done by the software developers or when the project is open-source. First, although memory becomes cheaper and compiler efficiency improves, it is still often necessary to manually optimize the code (e.g., to fit in the cache, to avoid timing side-channels) and microcontrollers' memory size is still very constrained. Assembly is also necessary to directly interact with some low-level processor features (e.g., system-control or co-processor registers, supervisor calls). From left to right: logical (e.g., arithmetic, logic), memory (load, store, barrier), hardware (supervisor call, co- Figure 1: Presence of assembly instructions in realworld embedded software.processor registers access), control-flow (branch and conditional). Other places where assembler instructions or binary code is present is in Board Support Packages (BSP) provided by chip manufacturers or in library code directly present in ROM memory. On the other hand, FIE [10] tests embedded software using the source code, essentially adapting the KLEE virtual machine to support specific features of the MSP430 architecture. We focus on the ability to perform security testing on complete systems made of real-world embedded software that contain a mix of high-level source code, hand-written assembly code, and, possibly, binary code (e.g., libraries). In summary, in this paper we present the following contributions:• A new methodology to automatically merge lowlevel LLVM bitcode, poor in semantic information and relying on the features of a target architecture, with high-level LLVM bitcode, rich in semantic information useful to detect vulnerabilities during symbolic execution • A modified symbolic virtual machine, able to run the resulting bitcode code and to handle peripherals' memory and interrupts using different analysis strategies • A fast debugger to connect the peripherals on the real device with the virtual machine, preserving event synchronization • A thorough validation of the system to guarantee meaningful and reproducible results, and an evaluation of the approach on both synthetic and realworld cases • A tool based on affordable off-the-shelf hardware components and source code that will be fully published as open-sourcePaper organization. The main goal of Inception is to leverage the semantic information of high-level source code to detect vulnerabilities during symbolic execution, while also supporting low-level assembly code and frequent interactions with the hardware peripherals. Alternatively, architecture-dependent binary code can be lifted to an intermediate representation that can be at least partially executed into a symbolic virtual machine, but that has lost the source code semantic information. It provides high-speed access to the peripherals and could be easily extended for multiple targets.In the following we give an overview of our lift-andmerge approach, of how KLEE performs security checks, and on how we extended it to support interrupts and peripheral devices.2.2 Lift-and-merge process Figure 2 shows the main stages of our bitcode merging approach and how source code with inline assembly 1 is transformed into a consistent bitcode 3 that can be executed by Inception VM. Indeed, the original purpose of LLVM-IR bitcode is to enable advanced optimizations before code lowering to the target architecture, whereas assembly is already at a low semantic level that cannot be represented or optimized by the LLVM compiler.To solve this problem, we introduce a novel liftand-merge approach, which we implement in InceptionTranslator. We call the resulting bitcode a Mixed Semantic Level bitcode (mixed-IR), shown in 3 , which contains:High Semantic Level IR (high-IR) obtained from C/C++ source code. When the ISR returns, the context is automatically restored, so that the code which was suspended by the interrupt can resume.The Glue IR that acts as a glue to enable switching between the high-level semantics and the low-level semantics domains. Indeed, communication and switching between layers mainly happens at the interface between functions, that is, when a highlevel function calls a low-level one or the opposite. When a violation is detected, the constraint solver generates a test case that can be replayed.The Memory Manager leverages the ELF binary and the mixed-IR to build a unified memory layout where both semantic domains can access memory. Specific data regions are allocated in order to run low-IR code, such as pointers contained in the code section, and some memory sections (stack, heap, BSS). Similarly to the other redirected locations, DMA buffers cannot hold symbolic values.The Interrupt Manager gives KLEE the ability to handle interrupt events, by interrupting the execution and calling the corresponding interrupt handlers. We further extended KLEE to execute handlers that switch the context between threads in multithreaded applications.Memory Monitor and security checks. In order to be able to glue assembly and binaries with source code into a unified LLVM-IR representation (mixed-IR), we apply two distinct processes.The lifting process takes machine code (compiled assembly or binaries) and produces an equivalent intermediate representation (low-IR). This representation uses only low-level features of the LLVM-IR language and it mimics the original architecture (ARMv7-M), which contains some hardware semantics of the Cortex-M3 processor, such as the behavior of instructions with side effects. In the next section we will describe some interesting aspects of the lifter.The merging process takes the (almost) selfcontained low-IR and the high-IR compiled from C/C++, to glue them together (with some glue-IR). The first step is, therefore, to create a unified memory layout between the two IR-levels in the KLEE virtual machine. This memory layout is central for the low-IR and high-IR to coexist and communicate.Processor registers are represented by global variables for different reasons. However, it decreases the precision of corruption detection, because the heap memory is a container for indistinguishable contiguous variables, making it difficult to detect even simple outof-bounds accesses. KLEE allocator was specifically designed to detect memory safety violations. Another advantage of KLEE allocation is that it can detect memory management errors such as invalid free of local or global variables.The normal KLEE stack is used when high-IR code is running. Indeed, when the high-IR allocates data, the resulting memory object is typed and allocated at the same address as indicated by the symbol table, to keep the compatibility with assembly code. Therefore, whenever the Static Binary Translator finds a call or return that crosses the IR levels, it invokes the ABI adapter to generate some glue-IR that adapts parameters and return values.When a high-IR function calls a low-IR function, the high-IR arguments (typed objects) must be lowered to the architecture-dependent memory (stack/CPU registers). Knowing the size and address of the destination, the adapter generates the glue-IR that copies CPU registers and stack words from the low-IR to the high-IR destination. There are four possible connections between low-IR and high-IR (code examples available in the appendix):1. A glue-IR epilogue takes the return value (stored in r0 by the low-IR callee) and promotes it to a typed object in KLEE stack (used by the high-IR caller).3. Before calling the high-IR function, some glue-IR takes the input arguments from the CPU registers or the low-IR stack (where the low-IR caller stored them) and promotes them to typed objects on the KLEE stack (used by the high-IR callee).4. The main challenge when dealing with control flow consists in finding a good mapping between high-level control flow operators present in LLVM-IR (e.g., call, if/else) and low-level ARMv7-M instructions, which are at a lower abstraction layer (they directly modify the program counter, and sometimes rely on implicit hardware features). We translate to an LLVM call instruction any Arm instruction that saves the program counter before changing its value (i.e., direct and indirect branch-and-link instructions) to an LLVM call instruction. Interrupts are used very frequently in embedded programs to synchronize the peripherals with the embedded software in an event-driven fashion, or to implement multithreading.Inception VM can receive interrupts from the real device (when real peripherals are used and generate interrupts) or generated by the user using helper functions (e.g., to stress specific functions in a deterministic way). If the vector is fixed, a slight speedup in execution can be obtained by storing the vector in a configuration file, loaded by KLEE at startup.Before giving control to an interrupt handler, and when returning from it, a Cortex-M3 processor performs several seamless operations (e.g., stacking and unstacking the context, managing two stack modes). In Inception, a special glue-IR helper function generated by our lift-and-merge process performs these steps.To implement multithreading, operating systems such as FreeRTOS use the interrupt and stack management features offered by the Cortex-M3. The main challenge of this architecture is to keep the virtual machine and the device synchronized, without inconsistencies and race conditions, even in presence of multiple priorities. On the left, we can observe the switch between threads enabled by the seamless context stacking and unstacking.In summary, Inception Debugger fully handles interrupt synchronization with the host virtual machine, while previous work had only limited interrupt support [34]. In order to read and write the device memory, we directly connect to the system bus through the AHB-AP, which can be accessed with the JTAG protocol. Inspired by SURROGATES [17], we designed a custom device based on a Xilinx ZedBoard FPGA [11], to efficiently translate high-level read/write commands into low-level JTAG signals. Our debugger is able to communicate with the stub running on the device and handle interrupts using a dedicated asynchronous line and shared memory locations.In summary, we provide a clean slate design for an efficient, cheap , and open-source solution, which can be used to experiment and replicate research that requires customizable debuggers (e.g., [25]). For example, we compared single instructions against the real Cortex-M3 processor, assembly functions against the C code from which they originate or alternative implementations, and complete applications against their behavior on the native hardware. We stress symbolic execution on known control flow cases, and bug detection on known vulnerabilities.Arm Cortex-M3 lifter. While some of the examples we use below are proprietary, we also built a large set of validation and evaluation examples, sometimes based on existing open-source code. Our analysis samples are based on the Klocwork Test Suite for C/C++ 9 , which includes out-of-bound, overflow, and wrong dynamic memory management errors. The same mechanism is applied to local (static) allocation and global allocation.Second, when using KLEE dynamic allocation functions, all vulnerabilities can be detected in both high-IR and low-IR, whereas if we use some implementation in the code of the application, the detection rate drops to almost zero for both high-IR and low-IR. However, in this case we can test the code itself of the allocation functions, either in high-IR or low-IR depending on the case.In summary, in 40 synthetic tests, 70% of the inserted vulnerabilities were found and no false vulnerabilities were reported.Comparison with binary-only approaches. When testing embedded binary code, it is hard to catch memory corruptions because of the lack of semantic information, code hardening, and operating system protections. One of the advantages of our source-based approach is that we 10 DHRYSTONE is a synthetic computing benchmark program, available at http://www.netlib.org/benchmark/dhry-c.11 Value reported by the manufacturer for a STM32 with Cortex-M3. Indeed, the GNU/Linux userspace library (libusb-0.1-4) performs system calls and DMA requests for each I/O operation, introducing a significant latency. These two samples cover the different scenarios in which Inception can be applied.FreeRTOS is a market-leading real-time operating system supporting 33 different architectures. 14 We selected tests related to divide by zero, null pointer dereference, free memory not on heap, use after free, integer overflow, heap-based buffer overflow. The detection rate is 100% for divisions by zero, null pointer dereference, use after free, free of non-heap allocated memory, and heap buffer overflow vulnerabilities. It is very similar for Inception Translator to lift and merge a function in a statically linked library or from a function that contains inline assembly. To show the potential of Inception in these conditions, we analyzed a bootloader under development, and we found a problem that would have been difficult to detect on FPGA-based prototypes.Our target is a secure bootloader with several options, stored in a One Time Programmable (OTP) memory. Early detection is useful to avoid expensive fixes later.Commercial payment terminal To show the potential of Inception when hardware is available, we tested a payment terminal under development, using the FPGA prototype to redirect most peripherals and their interrupts. The key to using symbolic execution in realistic settings is to limit the expensive symbolic exploration to a small critical code region, treating the (software/hardware) environment separately. Previous work [26] reduces the frequency of timer-based interrupts by executing them only when the firmware goes in low-power interrupt-enabled mode. However, the detection level for the bitcode generated from low-IR could be improved, for example, reconstructing typed objects from assembly, using DWARF debug information, and adding extra detection heuristics (e.g., from [23]). In this section we cover related work on embedded software testing and binary lifting.Testing embedded software in an emulator and forwarding the interaction with the real hardware has been previously performed with several different approaches [32,34,22,17]. FIE [10] can perform symbolic execution of (MSP430 16-bit) source code, but it does not support assembly code and interaction with real hardware, thus requiring us to modify the application. For this purpose we compile plain C functions with LLVM toolchain into LLVM-IR and functions which include assembler into native code, which we then directly lift to LLVM-IR. Low-IR to high-IR parameter passing.void @high_fu nction (){ ... // High IR code % R0_2 = load i32 * @R0 % R1_1 = load i32 * @R1 % R2_1 = load i32 * @R2 % R3_2 = load i32 * @R3 % SP15 = load i32 * @SP % SP16 = inttoptr i32 % SP15 to i32 * % SP17 = load i32 * % SP16 %0 = call i32 @low_function ( i32 % R0_2 , i32 % R1_1 , i32 % R2_1 , i32 % R3_2 , i32 % SP17 ) store i32 %0 , i32 * @R0... // High IR code } define i32 @foo ( i32 %a , i32 %b , i32 %c , i32 %d , i32 % e ) #0 { ... // low -IR } 1.