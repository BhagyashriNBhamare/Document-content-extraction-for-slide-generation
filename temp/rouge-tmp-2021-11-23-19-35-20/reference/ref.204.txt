Millions of users rely on mobile health (mHealth) apps to manage their wellness and medical conditions. Many third parties are interested in such information: Our survey of 2917 popular apps in the Google Play Store shows that around 57% of these apps explicitly query for the list of installed apps. Therefore, we designed and implemented HideMyApp (HMA), an effective and practical solution for hiding the presence of sensitive apps from other apps. Mobile health (mHealth), the use of technologies such as smartphones and wearable sensors for wellness and medical purposes, promises to improve the quality of and reduce the costs of medical care and research. In this area, a serious and often overlooked threat is that an adversary can infer sensitive information simply from the presence of an app on a user's phone. When inquired about this threat, 87% of the participants in our user-study expressed concern about it (Section 10.6). Due to Android's open design, a zero-permission app can easily infer the presence of specific apps, or even collect the full list of installed apps on the phone [55]. As users have on average 80 apps installed on their phones, 4 most of them being free, there is a high chance of untrusted third-parties obtaining the list of installed apps.Since 2015, Android has classified as potentially harmful apps (PHA) 5 the apps that collect information about other apps without user consent [1]. Users employ a client app called HMA Manager to anonymously (un)install, use, and to update the apps selected from the HMA app store; an the HMA App Store does not learn about the set of apps that a user has installed from the store. HMA transparently works on stock Android devices, it does not require root access, and it preserves the app-isolation security model of the Android operating system (OS). Moreover, we are the first to identify the security and functional limitations of using app virtualization for the purpose of hiding apps.Our evaluation of HMA on a diverse set of both free and paid mHealth apps on the Google Play Store shows that HMA is practical, and that it introduces reasonable operational delays to the users. For example, in 90% of the cases, the delay introduced by HMA to the cold start of an mHealth app by a non-optimized proof-of-concept implementation of HMA is less than one second. 8 Also, through our static and dynamic analysis on apps from the Google Play Store, we gain understanding about the prevalence of the problem of apps fingerprinting other installed apps. HMA's source code is available at https://github.com/lca1/HideMyApp. A significant research effort has been devoted to fingerprinting Android apps based on their (encrypted) network traffic patterns [28,51,54]. These techniques are used to sandbox untrusted target apps (e.g., [24,25]) or to compartmentalize third-party libs from the host apps (e.g., [34]). As they were designed for a different problem, however, they do not directly help hide the presence of a sensitive target app: They either require the target app to be first installed, thus exposing them to nosy apps through public APIs, or they run multiple target apps inside the same container app, thus violating the Android's app-isolation security model. Thus, apps are isolated, or sandboxed, both at the process and file levels.Apps interact with the underlying system via methods defined by the Java API framework and the shell commands defined by the Linux-layer interface. Any app can execute shell commands; however, depending on its privilege, i.e., default app privilege, debugging (adb) 10 or root, the outputs of the same shell commands are different.Android Apps and APK Files. Here, we demonstrate that an app, depending on its capabilities (its granted permissions and/or privileges), can retrieve information about other installed apps. This includes static information (i.e., information available after apps are installed and that typically does not change during apps' lifetimes), and runtime information (i.e., information generated or updated by apps at runtime). This can be done by invoking two methods getInstalledApplications() and getInstalledPackages() (hereafter abbreviated as getIA() and getIP(), respectively); they return the entire list of installed apps. It can also use various methods of the PackageManager class (e.g., getResourcesForApplication()) as an oracle to check for the presence of a specific app. These methods take a package name as a parameter and return null if the package name does not exist on the phone.If Android restricts access to package names of installed apps (e.g., by requiring permissions), an app can still retrieve other static information about installed apps for fingerprinting attacks. The notations +, and indicate the resources that our system (HMA, see Section 8) can protect by default, by collaborating with app developers or by randomizing runtime information of the container apps, respectively. Resources marked with the − sign cannot be protected by HMA.the PackageManager class, e.g., getPackageInfo(). With Permissions.An app granted with the READ_EXTERNAL_STORAGE permission, a frequently requested dangerous-permission, can inspect for unique folders and files in a phone's external storage (a.k.a. SD card). In addition, accessibility services 11 (with the BIND_ACCESSIBILITY_SERVICE permission) can have access to the layouts and the layouts' contents of other apps.With Default App-Privilege. An app can retrieve the list of package names (command pm list packages) and learn the path to the APK file of a specific app (command pm path [package name]). As a result, the obfuscation of apps' package names has to be done per user, i.e., for each user, the same app needs to be uploaded to the Google Play Store with a different package name. To mitigate app-fingerprinting attacks, Android could follow an approach similar to iOS, i.e., to remove or restrict API methods and OS resources that leak identifying information of apps. For example, in iOS, the canOpenURL() method can be used to check if a particular app is on the phone. Since iOS 9.0, in order to have an arbitrarily high number of calls to this method, an app has to declare beforehand the set of apps that it wants to check. More importantly, even with 50 queries, a nosy app can still check if a specific app or small set of apps are installed on the phone.A possibly better approach is for Android to include a new "sensitive" flag that enables users to hide sensitive apps from other apps in the same phone, i.e., other apps will not be able to use Android API methods to infer the existence of apps flagged as sensitive. After eliminating duplicate entries, default Android apps, and brand-specific apps, we were left with 2917 apps.Privacy-Policy Dataset. For our static analysis, by using Apktool, 13 we decompiled the APKs to obtain their smali code, a human-readable representation of the app's bytecode. Of the 2917 apps evaluated, 1663 apps (57.0%) include at least one invocation of these two methods in the code from third-party libs and the apps. Next, we launched all the runnable activities declared by the app for 10 minutes.Although this approach has limitations, as it only has a short period of time per app and it cannot emulate all the activities a user could do, it is sufficient to estimate a lower-bound on the number of apps that query for LIAs at runtime, as shown in our results.Our results, shown in Table 2, show that 190 apps (6.54%) called getIA(), 436 apps (15.0%) called getIP(), and 19.2% of the apps called at least one of these two methods. An example of a common violation, shown in these guidelines, is "An app that doesn't treat a user's inventory of installed apps as personal or sensitive user data". 18 Next, we explain what developers understand about the guidelines.As mentioned in Section 5.1, out of 2917 apps in our dataset, we found 2499 privacy policies. This might be because developers copy the privacy policies from other apps, or because the apps will make these calls in the future.Besides the generic declared purposes of the collections of LIAs by apps, e.g., for improving the service (e.g., [14,21]), some apps explicitly state that they collect LIAs for targeted ads (e.g., [3,12]), and targeted ads by third-party ad networks (e.g., [15]). Unexpectedly, we found that of the 162 policies that mention the collections of LIAs, 76 categorize LIAs as non-personal, whereas Google defines this as personal information. Therefore, a solution that hides sensitive apps and that still supports inter-app communications is more desirable.Multiple user accounts could also introduce new security and privacy issues [45]. Another important problem is that some popular phone manufacturers (e.g., Samsung, LG, Huawei, Asus) disable multiple users in some of their devices, 20 thus affecting the availability of this solution to many users.We have also found experimentally that the implementation of multiple users in the latest (Android 9) and earlier versions of Android does not effectively prevent nosy apps from learning what other apps are installed in different user accounts. To bypass this protection, a nosy app could do any of the following:• On Android 7 or earlier, including an additional parameter flag (MATCH_UNINSTALLED_PACKAGES) in methods getIA() and getIP() will reveal the apps installed in secondary user accounts. Such an approach could be used to hide sensitive apps, however, it only supports a limited subset of permissions, and it does not support features that are crucial for mHealth apps such as storing users' data or connecting to Bluetooth-enabled devices. Apps that do not follow this requirement are classified as Potentially Harmful Apps (PHAs) or Mobile Unwanted Softwares (MuWS) [1,2]. Furthermore, these mechanisms might fail to detect targeted attacks, e.g., a nosy app might want to check if a small subset of sensitive apps exists on the phone. Unfortunately, we were not able to evaluate the robustness of the protection offered by Knox w.r.t. hiding apps, because Samsung discontinued its support for work and personal spaces for private users; only enterprise users can use such a feature. Along the line of user-level virtualization techniques, on the Google Play Store, we found apps that use these techniques to enable users to run in parallel multiple instances of an app on their phones and to partially hide the app, (e.g., [11,17,18]). We propose HideMyApp (HMA), a system for hiding the presence of sensitive apps w.r.t. to a nosy app on the same phone. A hospital or a hospital consortium (hereafter called hospitals) sets up an app store, called HMA App Store, where app developers working for the hospitals publish their mHealth apps. Note that such organizations and their own app stores already exist, e.g., the VA App Store set up by the U.S. Department of Veterans Affairs.To enable the users to manage the apps provided by the HMA App Store, the HMA App Store provides the users with a client app called HMA Manager. We discuss mechanisms to relax the trust assumptions on the HMA App Store and HMA Manager app in Section 9.2. In Section 9, we discuss mechanisms for preventing more advanced fingerprinting attacks by malicious apps; a malicious app has more capabilities than a nosy app, i.e., it can have special permissions (e.g., PACKAGE_USAGE_STATS or BIND_ACCESSIBILITY_SERVICE) and the debugging privilege (adb), thus it can perform more advanced attacks, such as fingerprinting apps using their runtime information.We assume that apps belonging to hospitals are nosy, i.e., these apps are also curious about what other apps are installed on the user's device. Each container app has a generic package name and obfuscated app components. That is, the sensitive app is not registered in the OS. Thus, if users open their default Android app launcher, they will only see container apps with generic icons and random names. To provide unlinkability between users and their sensitive apps w.r.t. the HMA App Store, the HMA Manager app never sends any identifying information of the users to the HMA App Store, and all the communications between the HMA App Store and the HMA Manager are anonymous. To reduce the delays introduced to the appinstallation and app-update requests, the HMA App Store defines a set of P generic package names for container apps, e.g., app-1, . . . , app-P. • The HMA App Store creates an empty app with a generic app icon, a random package name and label, and it imports into the app the lib and the code for the user-level virtualization, i.e., to launch the APK from the container app. List of installed apps: -Nosy App 1 -Nosy-App 2 -Play Store -HMA Manager -App-1 -App-2 -App-3Figure 1: Overview of the HMA architecture. Using the information stored in its database about the mappings between container apps and sensitive apps (Section 8.3), the HMA Manager displays to the user the container apps with the original labels and icons of the corresponding sensitive apps. If the version of the Android OS is at least 6.0, permissions requested by the sensitive app will be prompted by its container app at runtime. This step is needed, because the configuration file of the container app needs to be updated w.r.t. the updates introduced by the sensitive app. To prevent fingerprinting attacks based on the number of components declared in the container app, the HMA App Store adds dummy random components during the generation of the container app such that all the container apps declare the same number of components.A nosy app might try to fingerprint sensitive apps by using the sets of permissions declared by their container apps. This will affect the look and feel of the sensitive apps, but it is a trade-off between usability and privacy. To prevent an app with VPN capabilities from fingerprinting sensitive apps based on the IP addresses in the header of the IP packages, the sensitive apps can relay their traffic through the HMA App Store servers; this protection is provided at the cost of additional communication delays for the apps and it requires collaboration with app developers.A malicious app cannot fingerprint a sensitive app by using the list of running processes, because the sensitive app runs inside the child process of its container app with a random name. 29 Users should grant this permission only to apps they trust. Apps with adb privilege can take screenshots of the phone and infer apps' names from the screenshots. To relax the trust assumptions on the HMA App Store and HMA Manager, the HMA App Store can provide an API so that anyone can implement her own HMA Manager app, or the HMA Manager app can be opensource, i.e., anyone can audit the app and check if it follows the protocols as prescribed. We looked into three evaluation criteria: (1) overhead experienced by mHealth apps, (2) HMA runtime robustness and its compatibility with mHealth apps, and (3) HMA usability. Also, these apps support features that are crucial for mHealth apps, e.g., a Bluetooth connection with external medical devices (e.g., Beurer HealthManager app [4]) and an internet connection (e.g., Cancer.Net app [5]). To measure the operational delay introduced by HMA, we implemented a proof-of-concept HMA App Store on a computer (Intel Core i7, 3GHz, 16 GB RAM) with MacOS Sierra. Our HMA App Store dynamically generated container apps from APKs and relied on an open-source lib called DroidPlugin [8] for user-level virtualization. Our prototype container apps dynamically loaded the apps' classes and resources from the mHealth APKs and supported the interception and proxy of API calls commonly used by mHealth apps, e.g., APIs related to Bluetooth connections and SQLite databases. On Android, apps can be launched from two different states: cold starts where apps are launched for the first time since the phone was booted or since the system killed the apps, and warm starts where the apps' activities might still reside in memory, and the system only needs to bring them to the foreground, hence faster than cold starts.Experiment Set-Up. For a baseline, we measured the delays when the mHealth apps were executed without HMA.To measure warm-start delays, due to the lack of Android supports for profiling warm starts, we have to instrument the source code of the sensitive apps to log the time that the app enters different stages in its lifecycle. We measured the warm-start delays experienced by the app in both settings (w/ and w/o HMA), 50 measurements per setting.Results. Our experiments show that the median of this process takes 6.5 ± 0.16 s (as compared to 0.74 ± 0.07 s if the mHealth apps were launched w/o HMA). For 90% of the cases, the average delay with HMA is less than 2.0 ± 0.3 s. Note that our prototype is a proof-of-concept hence not optimized. We cannot simulate this case, because Android does not provide methods to control the garbage collector. To determine the cause of this error, we ran an example app 33 that uses the official Android API for database access (i.e., Android.database.sqlite) to insert and retrieve records from an SQLite database, and the example app ran successfully. /db-name) instead of its full path.Compatibility. Note that, with the recent release of Android 9, Google has restricted the use of Java reflection 34 -the programming interface that all user-level virtualization techniques rely on. Still, Android 9 has only less than 1% market share [7], which means HMA will be compatible with most Android devices in the coming years. Permissions defined by apps to control access to their components can be used to fingerprint them (e.g., they typically include the app name), as any app can list the permissions of other apps. Hence, to be compatible with HMA, these apps could evaluate alternative (official) approaches to support Firebase services or rely on other services for user authentication.Services and Explicit Intents. We began the study with an entry survey about demographic information, privacy postures, users' awareness and concerns about the problem of LIA collections. Then, we provided each participant with a fresh phone and asked them to install and use two apps: a popular public-transportation app for our city and an mHealth app called Cancer.Net. 67% of the participants had used the transportation app before, whereas only 7% of them had used the Cancer.Net app or an mHealth app. The transcript of survey questions and the instructions can be found at 38 . Our study shows that the participants are concerned about the privacy of health-related data: 90% of the participants would be at least concerned if their health-related information were collected by apps installed on their phones and shared with third parties, and 87% of participants would be at least concerned if third parties learned that they had used health-related apps. We have proposed HMA, the first solution that addresses this problem. The work was carried out while Anh Pham was a PhD student at EPFL.