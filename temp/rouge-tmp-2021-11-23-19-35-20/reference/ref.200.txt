However, the verification of blockchain payments requires the user to download and process the entire chain which can be infeasible for resource-constrained devices like mobile phones. Our main idea is to leverage the trusted execution capabilities of commonly available SGX enclaves. We design and implement a system called BITE where enclaves on full nodes serve privacy-preserving requests from light clients. This process imposes heavy requirements on bandwidth, computing, and storage resources of blockchain nodes that need to fetch all transactions and blocks issued in the blockchain, locally index them, and verify their correctness against all prior transactions. Therefore, users operating resource-constrained clients like mobile devices cannot afford to run their own full node.Lightweight clients and privacy. As a matter of fact, according to [24], in 73 − 85% of 5.8 − 11.5 million active Bitcoin wallets users control keys. For example, Bitcoin provides the BitcoinJ [2], PicoCoin [8] and Electrum [3] clients implementing the Simple Payment Verification (SPV) mode [44], where the clients connect to a full node that has access to the complete chain and assists the client in transaction confirmation. As the full node has to learn all transactions issued and received by the requesting client to confirm them, such payment verification obviously violates user privacy.To improve user privacy, several clients support filters (e.g., Bitcoin's BIP37 [31] and Ethereum's LES [6]). Our goal is to improve the privacy of Bitcoin lightweight clients without compromising the performance of the assisting full nodes. We propose BITE (for BItcoin lightweight client privacy using Trusted Execution), a solution in which a potentially untrusted entity runs a full node with an SGX enclave that serves transaction confirmation requests from clients. Since SGX provides code integrity and data confidentiality for enclaves, such a solution can preserve privacy (confidentiality) and completeness (integrity) of client requests.Unfortunately, simple usage of trusted computing is not sufficient to solve our problem. Thus, the simple usage of SGX would still leak the client's addresses to malicious full node.Given such limitations of SGX, the primary research problem and contribution of this paper is how to design and implement a solution that enables private processing of light client request in the presence of enclave leakage without compromising the system's overall performance. The basic building block for our control-flow hiding is the cmov instruction [7] that enables building oblivious execution of branches. The side-channel protections in the Oblivious Database variant also make the enclave's memory accesses (both code and data) independent of the address, thus preventing leakage caused by known SGX side-channels [20,43,27,50,58,36]. The full node can be easily made responsive for incoming client request during block updates by using two enclave instances in parallel. The processing cost is also comparable when full side-channel protection is not used.We argue that BITE emerges as the first practical solution that provides strong privacy protection for lightweight Bitcoin clients. We propose leveraging commonly available trusted execution capabilities of SGX enclaves for improved lightweight Bitcoin client privacy. We argue that BITE is the first practical way to provide strong privacy for lightweight Bitcoin clients.The remainder of this paper is organized as follows. A user that knows the corresponding private key is able to spend the Bitcoin contained in the transaction output.When a user wants to perform a payment, she creates a transaction that contains inputs, outputs, and the signatures that allow her to spend the inputs. Subsequently, the transaction is propagated to all nodes using a peer-to-peer network created by the system's participants. In this technique, light clients store only block headers, check their PoW puzzles and then request their own transactions and the Merkle paths that are needed to verify their presence in the blocks from a full node that stores the entire chain.Improvement proposal BIP 37 [31] introduced Bloom filters [18] that allow a light client to request a subset of all transactions to preserve some privacy without needing to download all transactions for each block. The false positive rate can be set by the creator of the filter.In Bitcoin light clients, Bloom filters are used to encode transactions or addresses, and allow a full node to determine which transactions to send to a lightweight client without letting the full node know the exact addresses. The use of Bloom filters to receive Bitcoin transactions from an assisting full node inherently creates a trade off between performance and privacy. In the extreme cases, the filter matches everything, i.e., the client downloads the full blocks, or the filter only matches the client's addresses, i.e., she has no privacy at all.Gervais et al. [25] have shown that using Bloom filters in Bitcoin light clients leaks more information than was previously thought. This problem can be solved by requesting transactions from multiple nodes, which again imposes more network load on the client.Another solution would be to run the SPV protocol with Bloom filters over a network anonymity mechanism such as Tor. The high-level goal of this paper is to develop a solution that provides better privacy for lightweight clients without compromising the system performance. The main idea behind our approach is to leverage commonly available Trusted Execution Environments (TEEs) such as Intel's SGX enclaves [33,23] running within full nodes to provide a privacy-preserving verification service to light clients. In short, SGX provides a set of security enhancements in the processor that allow creation of small applications, called enclaves, whose data confidentiality and code integrity is protected from any malicious software running on the same platform, including the privileged OS.A simple way to leverage SGX would be a solution where the light client sends its wallet private key to an enclave on the assisting full node. Such approach might give the owners of full nodes an undesirable economic incentive to break their own SGX processors, e.g., using physical attacks.To avoid such incentives, we choose a different approach. Figure 1 shows our system model that consists of full nodes FN 1 ...FN m and lightweight clients LC 1 ...LC n . Although swapping memory pages is supported (swapping requires expensive encryption and integrity verification [17]), the complete blockchain (BC) and the database of unspent transaction outputs (UTXO) are significantly larger (as of Jan 2019, 200GB [12] and 2.8GB [13] or more, respectively) than the enclave's memory limits . That is, the adversary cannot access processor-specific keys (e.g., attestation or sealing key) and she cannot access enclave runtime memory that is encrypted and integrity-protected by the CPU. Secure and practical realization of our approach under the defined attacker model involves several technical challenges.Leakage through external accesses. In a simple implementation of our approach, the adversary could infer the client's addresses by observing which entries the enclave reads from a (sealed) UTXO database when processing a client request.Similarly, enclaves rely on the OS to perform communication operations which allows it to infer information about the enclave's communication patterns. For example, by monitoring CPU caches the OS can infer secret-dependent data and code accesses inside the enclave's memory [20,43,27,50]. Based on the client request, an enclave on the full node scans the blockchain and replies with a set of Merkle paths that the client can use to verify its transactions using downloaded block headers. In this variant, the enclave on the full node maintains a specially-crafted version of the unspent transaction outputs (UTXO) database and when a client sends a verification request, it checks for the presence of client's outputs in this database using oblivious database access (ORAM [52]) and responds accordingly. The enclave reads the locally stored blockchain database using a custom scanning technique that normalizes the relationship between response sizes and actually accessed data to hide the data/block access patterns and ensure client privacy. When the client is started for the first time, it downloads all newer block headers from the peer-to-peer network and verifies that (i) they all have correct Proof of Work and (ii) the hash chain of the downloaded headers leads to the checkpoint. (2) If the attestation was successful, the Lightweight Client LC i establishes a secure communication channel to the Enclave E j using TLS. (5) In preparation of the response, the Enclave E j does the following: for blocks containing client addresses it adds the full transaction information and the corresponding Merkle tree path to the response, while for blocks without client addresses it only adds the block header. (6) The Lightweight Client LC i verifies that (i) the received block headers match its internal state and (ii) the received transactions and Merkle Tree paths match to the block headers. The threshold indicates the maximum response size per block such that if we are to scan n − x blocks, the maximum response size for the client can be r = (n − x) * t. However, if the adversary is able to mount high-granularity digital side-channel attacks (e.g., one that allows her to observe execution paths with instructionlevel granularity), she will be able to determine the transactions that were accessed, and thus infer the client's addresses.To make our system more robust against such attacks, we optionally add side-channel protections at the expense of performance (cf. Section 6). To protect against timing leakage we compute the Merkle path for all transactions in each of the scanned block in contrast to only computing the path for The data is copied in an oblivious fashion from the block to a temporary array, i.e., every transaction is conditionally moved using cmov to every possible destination. Specifically, we apply the following modifications, as per Figure 4: (i) Instead of continuing to scan the chain if the size of the response exceeds the threshold, we stop scanning after the specified number of blocks. While the block is parsed, each transaction is moved to the temporary array in an oblivious fashion, i.e., we use the cmov instruction to conditionally move each word of each transaction to every entry in the array. In our second variant, we focus on reducing the load of lightweight clients in terms of computation and network while offering even better privacy preservation (namely, the block number that specifies how deep the chain should be searched does not leak). The main idea behind this variant is to allow lightweight clients to send requests containing addresses of their interest and directly receive information regarding unspent outputs, without the need to verify block headers and Merkle tree paths.In order to achieve such verification, a new indexed database of unspent transactions (denoted as enclave UTXO) is created and searched for every client request using an Oblivious RAM algorithm. In particular, this UTXO set is encrypted on the disk as sealed storage, indexed for easy and fast access depending on the client request, and accessed using ORAM to prevent information leakage through disk accesses. (c) As in the Scanning Window variant, the client obtains the latest block headers from the peer-to-peer network.Client request handling. E j uses ORAM and the previously created index to access the enclave UTXO in an oblivious fashion. The enclave additionally includes the block hash of the last known block from the local blockchain (longest chain). Responses are always of constant size, i.e., shorter responses are padded and if a response is too large, the client is informed of missing outputs, such that she can later retrieve the rest of the outputs (e.g., from a different node). (6) The Lightweight Client LC i can summarize the unspent transaction outputs received from the Enclave E j . To ensure that the enclave always uses the latest version of the sealed UTXO database, SGX counters or rollback-protection systems such as ROTE [39] can be used.Database Update. Observation of the control flow and memory access does not leak whether the operation performed by the enclave was a read or a write, and since there is a single control flow without creating multiple branches depending on the condition, we effectively hide the execution and thus protect this variant from internal leakage in full. First, we analyze our solution with respect to our adversary model where SGX security enforcements cannot be broken. The constant ratio of response size to scanned blocks prevents information leakage from the response size. Most known side-channel attacks on SGX provide imperfect data-access or control-flow traces and require many repetitions to filter out noise [20,43,27,50]. To analyze our solution against future adversaries that may be able to mount more precise attacks, below we consider the worst case scenario, i.e., side-channel attacks that obtain perfect data access and control flow traces from enclave's execution.Scanning Window. Second, to hide the execution paths, we remove all branching in the code that accesses these data structures and replace them with cmov assembly instructions (see Section 4.2). Our solution uses the same techniques, and thus directly inherits the security guarantees that successfully protect against the same type of attacks, i.e., those based on digital side-channel leakage. Since the client can retrieve block headers from the P2P network and the enclave returns all transactions from its view of the chain, the client can ensure completeness of the response by checking that she received data from the longest chain. Since the client still performs SPV, the security is otherwise not affected and our system provides the same guarantees as current light clients, i.e., a node may omit transactions, but cannot steal funds or make a client falsely accept a payment.In the Oblivious Database variant, a compromised enclave could make the client accept false payments by sending invalid UTXOs. We conclude that BITE can provide as much security and privacy as traditional lightweight clients even given a full break of SGX. Our main ideas could most likely be applied to other TEEs as well, such as the open-source Keystone TEE [1], thus reducing the reliance on SGX (and thereby Intel) even further. The centerpiece of our system is an original blockchain parser. This results in an approximate upper bound of 2.2kB for N = 4000, the current limit in Bitcoin. At the time of writing, the UTXO size (indexed by Bitcoin address) is around 3GB while our ORAM overhead accounts for 2 times the original size, totaling around 6GB.We use Path ORAM to store the UTXO set and have evaluated various chunk sizes for the implementation. In the worst case the maximum index size involves the lower and upper limits for addresses (20B) and transaction hashes (32B) for every ORAM block resulting in a maximum of (8GB/32kB) · (32B * 2 + 20B * 2) ≈ 19.5MB.To set the response size, we analyzed the typical unspent outputs per active address in the Bitcoin network. In this section, we evaluate both variants of BITE and compare them to the current SPV performance using pythonbitcoinlib [53]. Figure 6a shows the processing cost to filter blocks for BITE and current SPV protocols. If the side-channel protection is added to Scanning Window, the oblivious execution and memory access adds a significant overhead. Higher t m allows to cope with high variance of relevant activity within the requested blocks. A request that fetches the information regarding 10 client addresses accounts only for 0.5s and is completely independent on the number of requested blocks, thus making it even faster than the standard SPV mode used without any privacy protections.Contrary to the Scanning Window, in the Oblivious Database variant, the enclave needs to update its UTXO set after each new block arrives in the ORAM database which takes 78.5s. To reach permanent availability we propose to use 2 systems in parallel which update with an offset between each other. The SPV with no privacy protections performs slight less effective than the Oblivious Database of BITE as it was the case when the processing performance was compared. Table 3: Performance comparison and requirements on the full node for supporting light clients. This database accounts to 6GB, a 100% overhead compared to the regular UTXO set, due to the ORAM algorithm requirements. The original Scanning Window offers a slightly worse performance than the standard SPV but offers increased privacy, protecting against external leakage, and requires significantly less bandwidth. Finally, we compare the performance and security of BITE to previous SGX side-channel protection systems. By applying Raccoon to the target enclave code, the performance overhead of the enclave's execution can range up to 1000x depending on the complexity of the original code that is made oblivious. Lightweight clients can use BITE in different ways and the chosen usage model can have implications on the clients' long-term privacy. However, we stress that such correlation would require long-term tracking of verification requests from the adversary and that the same limitation applies to any light client payment verification scheme.In recommended usage of BITE, the client (i) uses different full nodes for payment verification, (ii) regularly uses fresh Bitcoin addresses (e.g., using an HD wallet [57]), and (iii) introduces unpredictability to the timing pattern of payment verification requests like a small number of extra requests at random time points. However, our mechanism still allows these types of request with the distinctive factor that the client would have to request them in batches. For example, if a client in the Scanning Window variant requests transactions for 10 of his addresses from the last 300 blocks using the full-side-channel protection, there might be more transaction data then the 300 * t kB message size. On the other hand, a malicious node can easily block all enclave messages or interrupt enclave execution, thereby preventing the enclave to access the blockchain, update its UTXO or serve client requests. However, if future versions of Intel SGX would allow more enclave memory (i.e., currently the limit is 128MB without the expensive page swapping) ranging up to the RAM limit on the residing platform, one could keep the UTXO database and all other security critical data in the memory and not on the disk, similar to recently proposed SGX-based in-memory database systems like EnclaveDB [46]. The idea of light clients for Bitcoin was already included in the Bitcoin paper by Satoshi Nakamoto [44] in the form of Simple Payment Verification (SPV). Osuntokun et al. recently proposed modifications to Bitcoin nodes and lightweight clients that move the application of the filter to the client [45]. Since the client always either requests the full block or nothing at all, she will download almost every block if a large fraction of blocks contain at least one transaction that is of interest.Other research on Bitcoin privacy shows that using different heuristics, large parts of the Bitcoin transaction graph can be deanonymized [16,41]. These techniques are orthogonal to the problem of light client privacy and out of our scope.Lastly, there exist alternative solutions that tackle limited computation abilities of light clients, such as VerSum [55]. The main difference between Raccoon and our solution is that by tailoring our implementation, we avoid the need for taint analysis and extra decoy paths enabling a more efficient solution.Other related systems include Cloak [28] that prevents cache leakage using hardware-based transactional memory features in processors; ZeroTrace [49] and Obliviate [14] that provide a library for data structures protected using ORAM; DR.SGX [19] that randomizes and periodically rerandomizes all data locations in enclave's memory with cache-line granularity; and, T-SGX [51] and Deja Vu [22] that detect and prevent side-channel attacks based on repeated interrupts. Improved user privacy is one of the main goals of decentralized currencies like Bitcoin. In this paper, we have proposed a new approach to improve the privacy of lightweight clients using trusted execution. We argue that BITE is the first practical solution to ensure privacy for light clients, such as mobile devices, in Bitcoin. A typical ORAM model is one where a trusted client wants to store sensitive information on an untrusted server. However, one should note that ORAM techniques cannot hide access timing.In this work, we use a popular and simple algorithm called Path ORAM [52] that provides a good trade-off between client side storage and bandwidth. (4) return requested chunk The research work leading to these results has been supported by Zurich Information Security and Privacy Center (ZISC). This isolation protects the integrity and confidentiality of the enclave's execution from any malicious software running on the same system, including BIOS, OS and hypervisor, or even malicious peripherals such as compromised network cards [56,34,29]. To protect the integrity of the execution, the CPU securely records all initialization actions to create a measurement that records the code and initial state of the enclave. The SGX architecture enables protected applications, called enclaves that are isolated from software running outside of the enclave. This isolation protects the integrity and confidentiality of the enclave's execution from any malicious software running on the same system, including BIOS, OS and hypervisor, or even malicious peripherals such as compromised network cards [56,34,29]. This can be used to establish a secure communication channel to an enclave.In addition, SGX enables enclaves to store data for persistent storage in an encrypted form through a process called sealing.