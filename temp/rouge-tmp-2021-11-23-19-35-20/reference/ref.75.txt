In this attack, even a weak adversary without controlling/compromising any SDN controller/switch/app/protocol but only having malware-infected regular hosts can generate external network events to crash the SDN controllers, disrupt core services, or steal privacy information. Software-Defined Networking (SDN) is rapidly changing the networking industry through a new paradigm of network programming, in which a logically centralized, programmable control plane, i.e., the brain, manages a collection of physical devices (i.e., the data plane). However, referencing network states is under the risk of introducing concurrency vulnerabilities because external network events can concurrently update the internal network states.In this paper, we present a new attack, namely state manipulation attack, in the SDN control plane that is rooted in the asynchronism of SDN. The asynchronism leads to many harmful race conditions on the shared network states, which can be exploited by the attackers to cause denial of services (e.g., controller crash, core service disruption) and privacy leakage, etc. If the operation at line 4 is executed before that at line 8, it will trigger a Null-Pointer Exception (NPE) when the null switch object is dereferenced at line 9, which leads to the crash of the thread and eventually causes Denial-ofService (DoS) attacks on the controller.The root cause of this vulnerability is a logic flaw in the implementation of Floodlight that permits a harmful race condition. The key insight of State Manipulation Attack is that we can leverage the existence of such harmful race conditions in SDN controllers to trigger inconsistent network states. Our key observation is that harmful race conditions are commonly rooted by two conflicting operations upon shared network states that are not commutative, i.e., mutating the scheduling order of them leads to a different state though the two operations can be well-synchronized (e.g., by using locks). As the adversary typically has no control of the machine or operating system running the SDN controllers, even if a harmful race condition is known, it is difficult for an adversary to create the input and schedule combination to trigger the harmful race condition.Nevertheless, we show that an adversary can remotely exploit many harmful race conditions with a high success ratio by injecting the "right" external events into the SDN network. An adversary can then generate many sequences of these network events repeatedly to increase the chance of hitting a right schedule to trigger the harmful race condition.We have designed and implemented a framework called CONGUARD for exploiting concurrency vulnerabilities in the SDN control plane, and we have evaluated it on three mainstream open-source SDN controllersFloodlight, ONOS, and OpenDaylight, with 34 applications in total. CONGUARD has uncovered 15 previously unknown vulnerabilities that can result in both security and reliability issues. By the time of writing, we have already assisted the developers to patch 12 of them.The rest of the paper is organized as follows: Section 2 introduces background. In this section, we introduce the necessary background of SDN in order to understand the harmful race conditions in this domain.The heart of SDN is a logically centralized control plane (i.e., SDN controllers) that is separated from the data plane (i.e., SDN switches). For example, an access control application can install access control rules to all activated switches by querying the switch state from a switch manager application in the SDN controller. It will update its managed network states when it receives corresponding network events.Also, some applications, namely service applications, in the SDN control plane paraphrase external network events (i.e., OpenFlow messages) to its own internal network events and dispatch them to other applications' event handlers. For example, when a switch manager application recognizes that a new OpenFlow-enabled switch 2 has joined the network, it issues a SWITCH_JOIN event to all corresponding handlers for policy enforcement. We present a comprehensive model of such causal relationships in Section 4.1.1. In a non-adversarial case, a harmful race condition in the SDN control plane can happen rarely under normal network operation by asynchronous events as listed in Table 1. That is, we consider operating systems of SDN controllers and switches are well protected from the adversary, and the control channels between SDN controllers and SDN switches, as well as administrative management channels between administrators and SDN controllers, e.g., REST APIs, can be properly protected by SSL/TLS, which is particularly important when the SDN network is configured to use in-band control messages. Switch port events (i.e., PORT_UP and PORT_DOWN) can also be indirectly generated by network interface manipulation (up and down) from a connected compromised host by using interface configuration tools, e.g., ifconfig.In addition, an attacker can generate switch-dedicated events (i.e., SWITCH_JOIN and SWITCH_LEAVE) atop an in-band deployment of SDN networks. If that happens, no source IP address conversion rule (from 10.10.10.10 to 10.0.0.4) will be installed in switch 1. CONGUARD contains two main phases: (i) locating harmful race conditions in the controller source code by utilizing dynamic analysis and adversarial state racing, (ii) triggering harmful race conditions in the running SDN controller by remotely injecting right external network events with the proper timing. More specifically, given a target SDN controller, we first analyze its dynamic behavior (by generating network events as inputs to it and then tracing the execution) to detect race conditions consisting of two race operations on a shared network state. In addition, the runtime context of the two state operations must be consistent, e.g., the value of dpid at lines 4 and 10 must be equal.To address the first challenge, we develop an execution model of the SDN control plane that formulates happensbefore semantics in the SDN domain, which can help us greatly reduce false positives. Different from general multi-thread programs, there are a number of distinct types of operations and domain-specific causality rules in the SDN control plane.Execution Trace: First, we model an execution of the SDN control plane as a sequence of operations as listed following:• read(T,V): reads variable V in thread T.• write(T,V): writes variable V in thread T.• init(A): initializes the functions of application A in the SDN control plane. • dispatch(E): issues event E.• receive(H,E): receives event E by event handler H.• schedule(TA): instantiates a singleton task TA. • end(TA): terminates a singleton task TA.Happens-Before Causality: In this paper, we utilize happens-before relations [28] to model the concurrency semantics of the SDN controller. app id = A.app id α ≺ β α.app id = A.app id β ∈ terminate(A) α ≺ β Event Dispatching α ∈ dispatch(E) β ∈ receive(H, E) α ≺ β Sequential Event Handling α = receive(H 1 , E) β = receive(H 2 , E) α < τ β α ≺ β Switch Event Dispatching α = receive(H, E 1 ) β = dispatch(E 2 ) E 1 . switch id α ≺ β Port Event Dispatching α = (H, E 1 ) β = dispatch(E 2 ) E 1 . reason = OFPPR_ADD α ≺ β α = (H, E 1 ) β = dispatch(E 2 ) E 1 . reason = OFPPR_DELETE α ≺ β Explicit Link Down and Host Leave α = (H, E 1 ) β = dispatch(E 2 ) E 1 . port id α ≺ β α = (H, E 1 ) β = dispatch(E 2 ) E 1 . The SDN control plane monitors OFP_PORT_STATUS OpenFlow messages to detect the addition and deletion of switch ports in the data plane. Given an observed execution trace τ of an SDN controller, we construct happens-before relations between each pair of operations listed in the execution model in Section 4.1.1. For each pair of memory access operations, i.e., (α, β ), on the same state variable, we report (α, β ) as a race state operation, if it meets two conditions: 1) either α or β updates the state variable; 2) α β and β α.Taking the raw execution trace as input, we first conduct an effective preprocessing step to filter out redundant operations in the trace. We can then pinpoint race operations by checking if there is a path between each pair of conflicting nodes in the DAG. An intuitive approach is to instrument control logic to force an erroneous execution order, e.g., the state update executes before the state reference. Taking a potentially harmful race condition as input, our active scheduling technique reexecutes the program to force two operations (like operations in line 4 and line 10 in Figure 1) to follow a specific erroneous order, as shown in Figure 7. In addition to utilizing the waypoint to ensure execution context, we also add four atomic control points (P1, P2, P3, and P4) and one flag (F1) to enforce the deterministic scheduling between the state reference operation and the state update operation with consistent runtime information. To launch the attack, an adversary, who has no control of the SDN controller except sending external network events, first needs to figure out what external events to trigger a harmful race condition. Then, for each operation in a potentially harmful race condition, we backtrack the control flow graph from the operation to correlate the operation with the external event. Hence, there are two resulting scenarios: 1) if the update event can update the network state before the reference happens, the exploitation succeeds; 2) if the update event falls behind the reference operation, a harmful race condition will not be triggered. Moreover, an attacker can tactically increase the probability of success by selecting a larger vulnerable window [51] for a specific exploitation. For some vulnerabilities, we found that their vulnerable windows are subject to network conditions, e.g., the size of network topology or network round-trip latency. We have implemented CONGUARD and tested it on three mainstream SDN controllers, including Floodlight [1], ONOS [3] and OpenDaylight [4]. In addition, to improve performance, we only instrument those network state variables with reference data types and exclude primitive types (e.g., int, bool) because typically only reference types are involved in harmful race conditions.We log memory accesses (e.g., putfield and getfield) upon objects and class fields as well as their values as metadata. Failing to resolve those storage methods (e.g., remove() and get()) would lead to missing of potential vulnerabilities. For all the three controllers, the offline analysis was able to finish in less than two minutes.To evaluate the effectiveness of the SDN domainspecific happens-before rules, we compared the following two configurations on running race detection of CONGUARD with Floodlight version 1.1: (1) enforces only thread-based happens-before rules; (2) enforces both thread-based and SDN-specific rules. To evaluate the effectiveness of our approach for identifying harmful race conditions, we also compared CONGUARD with an SDN-specific race detector, SDNRacer [18], and a state-of-the-art general dynamic race detector, RV-Predict (version 1.7) [22]. RV-Predict is the state-of-the-art general-purpose data race detector that achieves maximal detection capability based on a program trace but does not consider harmful race conditions, and does not have SDN-specific causality rules. We evaluated RV-Predict as a Java agent for Floodlight v1.1 with our implemented network event generator and REST test scripts. By utilizing adversarial testing, we identified 15 concurrency bugs/vulnerabilities caused by harmful race conditions including 10, 2, 3 in Floodlight, ONOS and OpenDaylight, respectively. Furthermore, we conduct an impact analysis for those vulnerabilities, as shown in Table 4. The connection disruption is a serious issue in SDN domain since: (1) by default, the victim switch may downgrade to traditional Non-OpenFlow enabled switch and then traffic can go through it without controller's inspection; (2) an SDN controller may send instructions to clear the flow table of the victim switch when the controller recognizes a connection attempt from the switch 5 . We also found several bugs that could interrupt the enforcement of services inside the SDN control plane, which may lead to serious logic bugs that hazard the whole SDN network.In Floodlight, we found 3 bugs (Bug-1, Bug-2, and Bug-3) in the LinkDiscoveryManager application that can violate the operation of link discovery procedure. Bug-5 and Bug-6 could cause a logic flaw that leaks the physical IP address of the public server's replica. In Floodlight, we found 5 such bugs (Bug-5, Bug-6, Bug-7, Bug-8 and Bug-9) in the LoadBalancer application that <REST_REQUEST, SWITCH_LEAVE> * exploitable if the network is configured with in-band control, or if the adversary has access to the out-of-band network † exploitable if the adversary can send authenticated administrative events (REST APIs) to the controller could break the service chain for OFP_PACKET_IN event handlers. Moreover, the attacker can remotely exploit 6 more harmful race conditions (i.e., Bug-1, Bug-2, Bug-3, Bug-4, Bug-5 and Bug-6) by utilizing SWITCH_JOIN and SWITCH_LEAVE events when the SDN network utilizes in-band control messages. For the rest 6 harmful race conditions (i.e., Bug-7, Bug-8, Bug-9, Bug-10, Bug-13, and Bug-15), we found that they correlate with REST API requests which are administrative events and might be protected by TLS/SSL. In particular, we utilize Mininet to inject ordered attack event sequences with a proper timing and test how many trials an external attacker needs to trigger a harmful race condition. More importantly, the indicative information is useful for the attacker to tune their exploitations such as to minimize the timing interval between trigger event and update event.In addition to injecting ordered attack events and tuning the timing between attack events, we also found that, the vulnerable windows of 7 harmful race conditions (i.e., Bug-1, Bug-2, Bug-3, Bug-4, Bug-5, Bug-6, and Bug-12) can be enlarged in some conditions. In particular, we updated the source IP address of a host and sent out ICMP echo requests (with the destination IP address of the public service 10.10.10.10) into the network to trigger the OFP_PACKET_IN messages. As a result, the harmful race condition is triggered by injecting an attack event sequence, which actually disrupts the packet processing service (as shown in Figure 12) to dispatch the incoming packets to OFP_PACKET_IN event handlers of SDN controller/applications. Another defense solution is to guarantee the deterministic execution of state operations in the SDN control plane at runtime. As a common drawback of dynamic analysis techniques [10], the race detection part of CONGUARD cannot cover all execution paths. In order to adapt our approach to other systems, one needs to feed CONGUARD with precise domain-specific models (like happens-before rules discussed in Section 4.1.1) and proper design of Active Scheduling.Misuses of SDN Control Plane Northbound Interfaces (NBIs). However, these existing detectors do not work well for harmful race conditions discussed in this paper because (1) harmful race condition vulnerabilities are not necessary data races as discussed earlier (in many cases they are not), (2) these detectors lack SDN concurrency semantics.In the SDN domain, SDNRacer [32,18] proposes to detect concurrency violations in the data plane of SDN networks while treating the SDN control plane as a blackbox. NICE [15] complements model checking with symbolic execution to locate operation bugs inside SDN controller applications. TopoGuard [20] pinpoints two new attack vectors against SDN control plane that can poison network visibility and mislead further network operation, as well as proposes mitigation approaches to fortify SDN control plane. We develop a dynamic framework including a set of novel techniques for detecting and exploiting harmful race conditions.