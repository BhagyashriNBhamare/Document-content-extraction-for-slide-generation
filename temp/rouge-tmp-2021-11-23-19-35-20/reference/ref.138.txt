SSL/TLS libraries are notoriously hard for developers to use, leaving system administrators at the mercy of buggy and vulnerable applications. We explore the use of the standard POSIX socket API as a vehicle for a simplified TLS API, while also giving administrators the ability to control applications and tailor TLS configuration to their needs. For example, Georgiev et al. find that the "terrible design of [security library] APIs" is the root cause of authentication vulnerabilities [11]. A common conclusion of these works is that TLS libraries need to be redesigned to be simpler for developers to use securely.In this work we present the Secure Socket API (SSA), a TLS API for applications designed to work within the confines of the existing standard POSIX socket API already familiar to network programmers. We demonstrate our prototype SSA implementation across a variety of use cases and also show how it can be trivially integrated into existing programming languages.Our contributions are as follows:• An analysis of contemporary use of TLS by 410 Linux packages and a qualitative breakdown of OpenSSL's 504 API endpoints for TLS functionality. We also provide a discussion of benefits and features of this implementation, and demonstrate the ease of adding SSA support to other languages. • A description of and source code for a tool that dynamically ports existing OpenSSL-using applications to use the SSA without requiring modification.Previous findings have motivated the work for simpler TLS APIs and better administrator controls. We outline the benefits and drawbacks of our chosen implementation, and do the same for some suggested alternative implementations. The libssl component of the OpenSSL 1.0 library alone exports 504 functions and macros for use by TLS-implementing applications. This and other TLS APIs have been criticized for their complexity [11,12] and, anecdotally, our own explorations find many functions within libssl that have non-intuitive semantics, confusing names, or little-to-no use in applications. For example, an administrator cannot currently dictate what version of TLS is used by applications she installs, what cipher suites and key sizes are used, or even whether applications use TLS at all. Through custom changes in OpenSSL and GNUTLS, this configuration file allows developers to defer some security settings to administrators.The synthesis of these two problem spaces is that developers lack a common, usable security API and administrators lack control over secure connections. However, most operating systems already offer critical services to applications to reduce code redundancy and to ensure that the services are run in a manner that does not threaten system stability or security. For example, application developers on Linux and Windows are not expected to write their own TCP implementation for networking applications or to implement their own file system functionality when writing to a file. Since C/C++ developers on Linux and other Unix-like systems already use the POSIX socket API to create applications that access the network, this API represents a compelling path for simplification of TLS APIs. If TLS usage can be mapped to existing POSIX API syntax and semantics, then that mapping represents the most simple TLS API possible, in the sense that other approaches would either need to wrap or redefine the standard networking API.Under the POSIX socket API, developers specify their desired protocol using the last two parameters of the socket function, which specify the type of protocol (e.g., SOCK DGRAM, SOCK STREAM), and optionally the protocol itself (e.g., IPPROTO TCP), respectively. Enable developers to use TLS through the existing set of functions provided by the POSIX socket API, without adding any new functions or changing of function signatures. This enables us to provide an API that is already well-known to network programmers and implemented by many existing programming languages, which simplifies both automatic and manual porting to the SSA. A full listing of our methods and results for our analysis of libssl is located at owntrust.org.We collected the source code for all standard Ubuntu repository software packages that directly depend on libssl. Our selection of packages made a total of 24,124 calls to the libssl API.The resulting categories are of two types: those that are used for specifying behavior of the TLS protocol itself (e.g., symbols that indicate which TLS version to use, or how to validate a certificate), and those that relate specifically to OpenSSL's implementation (e.g., symbols used to allocate and free OpenSSL structures, options to turn on bug workarounds). The OpenSSL documentation indicates that these functions are preferred [10]. Of the 388 (68%) calls that indicate a singular TLS version to use, only 60 (15%) use the latest version of TLS (1.2), and 83 (21%) specify the use of the vulnerable SSL 3.0. Of note are the uses of eNULL (5), NULL (10), COMPLEMENTOFALL (3), RC4 (2), and MD5 (1), all of which enable vulnerable ciphers or enable the null cipher, which offers no encryption at all. We manually analyzed an additional sample of packages and found that many adopt default settings or retrieve their cipher suite lists dynamically from environment variables and configuration files.Our analysis indicates that, like with version selection, developers want to let the system select cipher suites for them, and that those who choose to hardcode behaviors often make mistakes. Only two extensions are used somewhat regularlyServer Name Indication (SNI), in 77 (19%) applications, and Next Protocol Negotiation (NPN) and its successor Application-Layer Protocol Negotiation (ALPN), in 60 (15%) applications. In addition, there are relatively few cases where developers need to supply configuration for an extension, such as a hostname with SNI or a list of protocols with ALPN. Of the 73 API functions used for managing keys and certificates, 39 (54%) are unused. However, one is used to verify that a given private key corresponds to a particular certificate, and two are used to provide decryption passphrases to unlock private keys.Given that most functions in this category are unused, and that all but three of those that are used are for specifying the locations of certificates and private keys, we recommend the SSA have simplified options for supplying private key and certificate data. A total of 7 packages use SSL get verify result, but neglect to ensure SSL get peer certificate returns a valid certificate. This includes the employ of strengthening technologies such as OSCP [22], CRLs [6], etc. We make this recommendation with one caveat: if an application would like to validate a certificate based on a hard-coded set or its own root store, then it can supply a set of trusted certificates to the SSA. Most of the analyzed packages, 299 (73%), do not make any changes to the default session caching mechanisms of OpenSSL. Manual inspection of these packages found this was used for logging and to pass session data to other processes, presumably to support load balancing for servers.We recommend that session caching be implemented by the SSA, relieving developers of this burden, with options for developers to disable caching and customize session TTLs. Of these, 138 (41%) set a flag that makes I/O operations on a socket block if the handshake has not yet completed, 189 (56%) set flags that modify the SSL write function to behave more like write, and 47 (14%) use a flag that reduces the memory footprint of idle TLS connections. The allocation category contains functions such as SSL library init and SSL free, whose existence is obviated by the existence of the SSA because all relevant memory allocation and freeing is performed as part of calls such as socket and close. All of these have direct counterparts within the POSIX socket API, or have combinations of symbols that emulate the behavior, such as SSL connect (connect), and SSL Peek (recv with MSG PEEK flag). The instrumentation and miscellaneous categories contain functionality that monitors raw TLS messages, extracts information from internal data structures, is scheduled for deprecation, etc. Data is sent and received through the socket using standard functions such as send and recv, which will be encrypted and decrypted using TLS, just as network programmers expect their data to be placed inside and removed from TCP segments under IPPROTO TCP. The response received is also decrypted by the SSA before placing it into the buffer provided to recv.In the server case, the application calls bind to give itself a source address of 0.0.0.0 (INADDR ANY) on port 443. Before it calls listen, it uses two calls to setsockopt to provide the location of its private key and certificate chain file to be used for authenticating itself to clients during the TLS handshake. General Behavior Behavior under IPPROTO TLS Create an endpoint for communication utilizing the given protocol family, type, and optionally a specific protocol.Create an endpoint for TLS communication, which utilizes TCP for its transport protocol if the type parameter is SOCK STREAM and uses DTLS over UDP if type is SOCK DGRAM. Connect the socket to the address specified by the addr parameter for stream protocols, or indicate a destination address for subsequent transmissions for datagram protocols.Perform a connection for the underlying transport protocol if applicable (e.g., TCP handshake), and perform the TLS handshake (client-side) with the specified remote address. Mark a connection-based socket (e.g., SOCK STREAM) as a passive socket to be used for accepting incoming connections.No TLS-specific behavior. The SSA enforces global TLS policy for any application, unless a configuration profile for that specific application is present, in which case it enforces the settings from the application-specific profile.We do this in a fashion similar to the application-specific profiles of AppArmor [24], the mandatory access control module used by Ubuntu and other Linux distributions. This option will cause the SSA to use the Server Name Indication in the TLS Client Hello message, and also use the specified hostname to verify the certificate in the TLS handshake. Servers can use this option to multiplex incoming connections from clients requesting different hostnames (e.g., hosting multiple HTTPS sites on one port). The value of this option can either be a path to a key file or an array of bytes, in PEM format. Used to indicate one or more certificates to be a trust store for validating certificates sent by the remote peer. Used to indicate a list of IANA-registered protocols for Application-Layer Protocol Negotiation (e.g., HTTP/2), in descending order of preference. Additional validation mechanisms not listed can also be used, such as notary-based validation, through the TrustBase plugin API. Arbitrary data can be transferred to and from the API implementation using setsockopt and getsockopt, because they take a generic pointer and a data length (in bytes) as parameters, along with an optname constant identifier. Adding a new option can be done by merely defining a new optname constant to represent it, and adding appropriate handling code to the implementation of setsockopt and getsockopt.In accordance with this standard, the SSA adds a few options for IPPROTO TLS. To streamline this process, we add a new sockaddr type, AF HOSTNAME, which can be supplied to connect. If the developer wishes to bind to a particular hostname, then they may use setsockopt with the TLS HOSTNAME option on their listening socket.The options listed in Table 3 are useful primarily in special cases, such as for client certificate pinning, or specifying a particular certificate and private key to use in the TLS handshake. These changes involved using IPPROTO TLS in the socket call when the URL scheme was secure (e.g., HTTPS, FTPS) and then assigning the appropriate hostname to the socket, using setsockopt with the TLS REMOTE HOSTNAME option. This modification was made in five hours by a programmer with no prior experience with wget's source code or OpenSSL, but who had a working knowledge of C and POSIX sockets.We also modified lighttpd, a light-weight eventdriven TLS webserver, to use the SSA instead of OpenSSL. In porting this and wget, most of the time spent was used to become familiar with the source code and remove OpenSSL calls.We also modified two applications that did not previously use TLS, an in-house webserver and the netcat utility. One of the benefits of using the POSIX socket API as the basis for the SSA is that it is easy to provide SSA support to a variety of languages, which is in line with our fourth design goal. Any language that uses the network must interface with network system calls, either directly through machine instructions or indirectly by wrapping another language's implementation. Adding SSA support to Python required modification of socketmodule.c, which was done by merely adding SSA constants (i.e., IPPROTO TLS and option values for setsockopt/getsockopt.) Adding SSA support to Go merely required adding a new constant, "tls", and an associated numerical value, to the net package of the language. Go also provides functions to interface with the setsockopt and getsockopt system calls (e.g., SetsockoptInt), which allow light-weight wrappers of options (e.g., setNoDelay) to be made. TFO is supported by clients via the sendto (or sendmsg) function with the MSG FASTOPEN flag. We have developed a loadable Linux kernel module that implements the Secure Socket API. The application links to the security library, such as OpenSSL or GnuTLS, and then uses the POSIX Socket API to communicate with the network subsystem in the kernel, typically using a TCP socket.A corresponding diagram, shown in Figure 3, illustrates how our implementation of the SSA compares to this normal usage. The kernel component offloads the tasks of encryption and decryption to an encryption daemon, which uses OpenSSL and obeys administrator preferences.Note that our prototype implementation moves the use of a security library to the encryption daemon. The supplied functions are then invoked when a user application invokes a corresponding POSIX socket call on a TLS socket, through the system call interface.When an SSA-using application invokes an I/O operation on a TLS socket, the kernel component transfers the plaintext application data to the user space daemon for encryption, and the encrypted data are then transmitted to the intended remote endpoint. The user space encryption daemon is a multi-process, event-driven service that interacts with the OpenSSL library to perform TLS operations. • Socket options Throughout a TLS socket's lifetime, an application may wish to use setsockopt or getsockopt to assign and retrieve information about various socket behaviors. For example, if the daemon fails to connect to a specified remote host, the corresponding error code is sent back to the application, and the kernel does not connect the internal socket to the the daemon, maintaining both sockets in an unconnected state and informing the application of real errors.When the daemon receives a certificate from a remote peer, it validates that certificate based on administrator preferences. In addition to, or replacement of these methods, administrators can defer validation to TrustBase [18], which offers multiple coexisting certificate validation strategies.Creating an internal socket between applications and the daemon provides natural support for existing socket I/O and polling operations. We created multiple simultaneous instances of these applications and recorded the time required for all of them to receive a remote file over HTTPS, repeating this for increasing numbers of concurrent processes. We find no statistically significant difference for local connections (p = 0.08) but do find a difference for remote ones (p = 0.0001). Bates et al. [3] found that 94% of popular TLS-using Ubuntu packages are dynamically linked with their security libraries, indicating that handling the dynamic linking case would be a significant benefit.We supply replacement OpenSSL functions through a shared library for dynamically linked applications to override normal behavior (usable via LD PRELOAD, dropin library replacement, etc.). By hooking functions that operate on file descriptors, we isolate an application's socket behavior from the OpenSSL library, allowing the SSA to control network interaction exclusively.OpenSSL uses an SSL structure to maintain all TLS configuration for a given connection, including the certificates, keys, TLS method (server or client), etc., that the application has chosen to associate with the given TLS connection (which is done through other function calls). For example, the SSL get peer certificate function was overridden to use getsockopt with a special TLS PEER CERTIFICATE CHAIN option to provide applications with X509 certificates to enable custom validation (many applications use this function to validate the hostname of certificates). This enables applications to use STARTTLS when they find that a remote endpoint supports opportunistic TLS.In our experimentation with this tool, we successfully forced wget, irssi, curl, and lighttpd to use the SSA for TLS dynamically, bringing the TLS behavior of these applications under admin control. All other networking calls (e.g. bind, connect, send, recv) remain the same, allowing developers to work with a familiar API. For example, administrators can set preferences for or veto specific TLS versions, cipher suites, and extensions, or automatically upgrade applications to TLS 1.3 without developer patches. Other languages can be easily modified to use the SSA, as demonstrated with our efforts to add support to Go, Python, and PHP.Adding TLS to the Linux kernel as an Internet protocol allows the SSA to leverage the existing separation of the system call boundary. The Linux Security Module framework, for example, was created to provide a shared kernel API to access control modules, which allowed administrators to pick the best solution for their needs (e.g., SELinux, AppArmor, Tomoyo Linux, etc.). The SSA enables administrators and power users to custom-tailor TLS to their local security policies. Accordingly, our presentation of the SSA with its extensions to the existing POSIX socket standard and related options is separate from the presented implementation. We outline two of these:• Userspace only: The SSA could be implemented as a userspace library that is either statically or dynamically linked with an application, wrapping the native socket API. While such a system sacrifices the inherent privilege separation of the system call boundary and language portability, it would not require that the OS kernel explicitly support the API. We also note that given the popularity of OpenSSL, it can also behave as a single point of failure, as with the Heartbleed vulnerability.Another benefit of centralization is that it vastly simplifies the landscape of security problems we face today. The usage of GnuTLS and other libraries may differ in ways that could affect our design recommendations.Because the SSA targets the POSIX socket API, we believe implementations very similar to ours can be deployed on operating systems that closely adhere to this standard, such as Android and MacOS. Collectively, prior work also largely ignores the suitability of their APIs to languages other than C/C++, which limits their utility to a large amount of developers.Administrator control over TLS: Fahl et al. [9], MITHYS [5] and two other solutions, TrustBase [18] and CertShim [3], provide administrator and operating system control over TLS certificate validation. In contrast, the SSA provides administrator control of numerous other aspects of TLS (version, ciphers, extensions, sessions, etc.) as well as certificate validation (which can use TrustBase behind the scenes). These findings informed the design of our API, and we find that TLS usage fits well within the confines of the existing POSIX socket API, requiring only the addition of constant values to three functions (socket, getsockopt, setsockopt) to support TLS functionality.