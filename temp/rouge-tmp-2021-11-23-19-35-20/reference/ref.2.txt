We discovered several issues and illustrate their importance by decrypting all group (and unicast) traffic of a typical Wi-Fi network. First we argue that the 802.11 random number generator is flawed by design, and provides an insufficient amount of entropy. The per-message RC4 key is the concatenation of a public 16-byte initialization vector with a secret 16-byte key, and the first 256 key-stream bytes are dropped. Finally, we propose and study a new random number generator tailored for 802.11 platforms. As a result, securing Wi-Fi traffic has received considerable attention from the research community. For example, they showed that WEP is utterly broken [11,42,4], demonstrated attacks against WPA-TKIP [43,45,47,41], performed security analysis of AES-CCMP [24,39,13], studied the security of the 4-way handshake [17,18,34], and so on.However, most research only focuses on the security of pairwise keys and unicast traffic. Surprisingly, we find that it is flawed by design. This reveals that an attacker can abuse biases to recover an 128-bit group key by capturing 2 30 to 2 32 encryptions of the group key, where the precise number depends on the configuration of the network.Group keys should only be used to protect broadcast or multicast frames. We demonstrate that this allows an attacker to use the group key to inject, and in turn decrypt, any traffic sent in a Wi-Fi network.Finally, we propose and study a novel random number generation tailored for 802.11 platforms. It extracts randomness from the wireless channel by collecting finegrained Received Signal Strength Indicator (RSSI) measurements. We show our algorithm can generate more than 3000 bits per second, and even when an adversary can predict individual RSSI measurements with high probability, the output of the generator still remains close to uniformly random.To summarize, our main contributions are:• We show that the 802.11 random number generator is flawed, and break several implementations by predicting its output, and hence also the group key. This headers contains the necessary MAC addresses to route the frame: addr1 = Receiver MAC address addr2 = Sender MAC address addr3 = Destination MAC address The Access Point (AP) forwards received frames to their destination, which is either a node on the wired network, or a Wi-Fi client. If a client wishes to transmit a broadcast or multicast frame, i.e., a group addressed frame, he first sends it as a unicast frame to the AP. This assures all clients within the range of the AP will receive the frame, even if certain stations are not within range of each other.The Frame Control (FC) field contains, among other things, the ToDS and FromDS flags. The ToDS flag is set if the frame is sent from a client to an AP, and the FromDS flag is set if the frame is sent in the reverse direction. To prevent downgrade attacks, the client and AP will verify the received and selected IEs in the 4-way handshake. In this handshake, the client and AP also authenticate each other, and negotiate a Pairwise Temporal Key (PTK). The PTK is then derived from a shared secret or passphrase, the ANonce and SNonce, and the MAC addresses of the client and AP.In the first message of the 4-way handshake, the AP sends the ANonce to the client (see Figure 2). The AP then checks whether the included IE matches the IE that was received in the initial association request. Otherwise the AP replies with the Group Temporal Key (GTK), and its supported ciphers as a list of IEs. Otherwise the client finishes the handshake by sending Msg4 to the AP.Messages in the 4-way handshake are defined using EAPOL-Key frames, whose most important fields are shown in Figure 3. Finally, the Key IV Key Scheduling (KSA) L = len(key) j, S = 0, range(256) for i in range(256):j += S[i] + key[i % L] swap(S[i], S[j]) return S Keystream Output (PRGA) S, i, j = KSA(key), 0, 0 while True: i += 1 j += S[i] swap(S[i], S[j]) yield S[S[i] + S[j]]Figure 4: Implementation of RC4 in Python-like pseudocode. The KSA takes as input a variable-length key, and generates a permutation S of the set {0,. This gradually changing permutation, combined with a public counter i and a private index j, form the internal state of the PRGA. Multiple biases have been found in the first few keystream bytes of RC4. Arguably the most well known was found by Mantin and Shamir [30]. In contrast, there are also biases that keep occurring throughout the whole keystream. Letting g denote the length of the gap, the bias can be written as follows:Pr[Z r , Z r+1 = Z r+g+2 , Z r+g+3 ] = 2 −16 񮽙 1 + e (−4−8g)/256 256 񮽙Hence the longer the gap, the weaker the bias.Listing 1: Random number generator as proposed by the 802.11 standard in Python-like pseudocode [21, §M.5].1 def PRF-256(key, label, data):2 R = HMAC-SHA1(key, label + "\x00" + data + "\x00") 3 R += HMAC-SHA1(key, label + "\x00" + data + "\x01") The security enhancements amendment to 802.11, called 802.11i, includes a software-based RNG [22, §H.5.2]. It extracts randomness from clock jitter and frame arrival times. While the standard states the proposed algorithm is only expository, and real implementations should extend it with other sources of entropy, we found that several platforms directly implement it and even simplify it. However, there is no discussion on how this impacts the RNG, e.g., whether additional iterations of the outer for-loop should be executed. Additionally, the standard does not mandate a minimum resolution for the timestamps that are used. If it checks whether there was Ethernet traffic in the last x seconds, repeated calls will probably operate on the same Ethernet packet, and the function will return the same data. In any case, either calling NetworkJitter implies waiting a significant amount of time until there is new traffic, or repeated calls return the same value.When the second clause of the if statement on line 10 is taken, the arrival times of frames transmitted during the 4-way handshake are used. We also remark that if the AP were to constantly abort the handshake after receiving message 2 (see line 13), most clients will blacklist the AP for a certain period. Hence it becomes infeasible to initiate and abort 256 4-way handshakes, which is something the random number generator is supposed to do. When done properly, this protects against permanent compromise of the RNG, iterative guessing attacks, backtracking attacks, and so on [25,3,9]. The 802.11 standard defines, but does not mandate, a key hierarchy for the generation of group keys [21, §11.6.1]. The on startup function is executed at boot time, and generates a random auxiliary key called the Group Master Key (GMK). Actual group keys, called Group Temporal Keys (GTKs), are derived from the GMK and key counter using a Pseudo-Random Function (PRF) in new gtk. The latest standard also states [21, §11.6 "The GMK is an auxiliary key that may be used to derive a GTK at a time interval configured into the AP to reduce the exposure of data if the GMK is compromised. Instead, older versions stated that the GMK may be reinitialized to reduce the exposure of data in case the current value of the GMK is ever leaked.Most implementations renew the GTK every hour by calling a function similar to new gtk. One major disadvantage of the proposed key hierarchy, is that fresh entropy is never introduced when generating a new group key in new gtk. Hence, once the value of GMK has been leaked, or recovered by an attacker, all subsequent groups keys can be trivially predicted.Since the standard assumes that GenRandom provides cryptographic-quality random numbers, there appears to be no advantage in using this key hierarchy. Nowadays implementations are allowed to directly generate a random value for the GTK [21, §11.6.1.4], though many platforms still implement the proposed group key hierarchy (see Section 3.4). We now study the RNG of real 802.11 platforms. We were able to recognize specific brands based on vendor-specific information elements in beacons. These drivers directly manage the 4-way handshake and key generation. Instead of initializing gnonce to key counter in line 7 of Listing 2, it generates a new value using GenRandom, and assigns the result to gnonce.We show that this RNG is flawed by predicting the group key generated by an Asus RT-AC51U. Since it is trivial to determine whether AES or TKIP is used, and less than 10 possible initial values are used in both cases, we end up with at most 32 · 10 possible values for the GMK.The second step is to estimate the jiffies count when the GTK, i.e., group key, was generated. Hence, if we know the uptime of the router, we can determine when the current group key was generated. Therefore, even after an uptime of year, our prediction of the jiffies value will only be off by roughly 50 000. It tests candidate keys by decrypting the first 8 bytes of a packet, and checking if they match the predictable LLC/SNAP header. We conclude the group key generated by a MediaTek driver can be brute-forced using commodity hardware in negligible time. However, it does not implement the RNG as proposed in the 802.11 standard. Instead, the RNG it uses depends on the kernel used by the device.When running on a VxWorks or eCos kernel, random numbers are generated by taking the MD5 checksum of the current time in microsecond accuracy. Assuming we can estimate time at which the group key was generated with an accuracy of one second, and that the timestamp in the next call to the RNG differs by at most 10 ms, we have to test 1 000 000 · 10 000 ≈ 2 33 keys. And since entropy for the group keys is only collected at boot (see Section 3.3), this again means all groups keys may be predictable. However, when generating a new group key using a function similar to new gtk, it also samples and incorporates new entropy. In case insufficient entropy is available, it will re-sample from /dev/random when the first client is attempting to connect. In case there still is not enough entropy available, the client is not allowed to connect All combined, this means the keys used by Hostapd should be secure. Since at this stage no operating system is loaded, we consider it an ideal candidate to investigate how vendors implement RNGs in a constrained (embedded) environment.Currently, the Wi-Fi module of Open Firmware only provides client functionality. All this information can be predicted or brute-forced by an adversary.We attribute this weak construction to a careless implementation, and treat it as an indication that a better design is to let the Wi-Fi chip generate random numbers itself. We present two attacks against the usage of RC4 in the handshake, and show how it allows an attacker to recover the group key. When inspecting the 4-way handshake in Figure 2, we can see that the AP sends the group key (GTK) to the client before the client verifies the IEs of the AP. This is problematic because, if multiple ciphers can be used to protect the handshake, an adversary can try to perform a downgrade attack to induce the AP into encrypting and transmitting the group key using a weak cipher.Interestingly, the 4-way handshake can indeed be protected by several cipher suites [21, §11.6.2], meaning a downgrade attack is possible. Ciphers Used Fast Transition (FT) AES-CMAC, AES key wrap CCMP without FT HMAC-SHA1, AES key wrap TKIP without FT HMAC-MD5, RC4 particular, when support for fast network transitions is requested, AES-CMAC and and NIST AES key wrap are used to protect messages in the 4-way handshake. Hence victims wanting to connect to the AP will use TKIP, and in turn the group key transmitted in the 4-way handshake will be encrypted using RC4. This works because the client will only detect the downgrade attack after receiving message 3. Essentially, the attacker clones the AP on a different channel, and forwards packets to, and from, the real AP. In particular, it will use this position to modify the beacons and probe responses so it seems the AP only supports (WPA-)TKIP. Hence the client will be forced to select TKIP, causing the AP use to RC4 for encrypting the group key.We tested this downgrade-style attack against a network that advertised both support for TKIP and CCMP. Since the rogue AP only advertised support for TKIP, the victim indeed selected TKIP. Interestingly, using a longer IV likely weakens this per-message key construction [28,36], while dropping the initial keystream bytes should strengthen it [33,28]. Fortunately, this is possible by relying on the predictable IEs that are located at the start of the EAPOL Key Data field, meaning we can derive the keystream at these initial positions.We now determine how much effort it takes to collect the required number of applicable IVs. Assuming a random initial IV is used, this will not happen with a probability of The 802.11 standard states that a station must generate an initial random IV at startup, and increment this IV after it is used in a message [21, §11.6.5]. We now turn our attention to plaintext recovery attacks, where an adversary targets information that is repeatedly encrypted under different RC4 keys. They showed that for WPA-TKIP, the public 3-byte prefix of the per-message RC4 key induces large, prefix-dependent, biases into the RC4 keystream [37,15]. By comparing these biases with the keystream distribution of 16-byte random RC4 keys in Figure 6c, we can conclude that the biases represented by the light and red background, are not caused by the specific IV values. In particular, we implemented the binning algorithm proposed by Paterson et al. [37], and the single-byte candidate generation algorithm proposed by Vanhoef and Piessens [47]. For the candidate generation algorithm, which returns a list of plaintext candidates for a sequence of bytes, we first need to determine at which position the group key is stored in the EAPOL Key Data field.The location of the group key depends on which cipher suites are supported. In contrast, if both TKIP and AES are supported, and if the older WPA informa- tion elements are included in addition to the RSN IEs 3 , the group key starts at position 62. Finally, in principle it is also possible to attack group key update messages, since the 802.11 standard does not mandate that these messages should be encrypted using the pairwise cipher [21, §11.6.7]. Even when an adversary creates a rogue AP advertising TKIP, the real AP will reject any request for TKIP, and hence will never use RC4 in the 4-way handshake. The receiver always uses pairwise keys to decrypt unicast frames, and ignores the KeyID value (recall Section 2.1). Since an AP does not operate at the IP layer, but on the MAC layer, it does not perform this check. For the three address fields in the frame we use the following values: Although in a normal network the AP never processes group addressed frames, we found that APs can be forced to process our injected broadcast packet by setting the ToDS bit in the Frame Control (FC) field. It will notice that the destination address (addr3) does not equal its own MAC address, and hence will forward the frame to the actual destination. This is done by performing an ARP poisoning attack. After the ARP poisoning attack, all IP packets sent by the client and router are encrypted using the group key. At this point we were able to successfully decrypt these broadcast packets using the group key, and read out the unicast IP packets sent by both the victim and router. If DGAF is disabled, no group keys are configured, meaning the stations and AP ignore all group addressed Wi-Fi frames. The sweep time of one sample, i.e., spectral scan, is 4µs, and these scans can be made even when there is no background traffic. Subtle or small biases may still be present, and have to be filtered out. Assuming that each bit b i is equal to one with probability p, combining n bits in this manner has the following characteristics [10]:Pr[bit = 1] = 0.5 − 2 n−1 · (p − 0.5) n (2) Pr[bit = 0] = 0.5 + 2 n−1 · (p − 0.5) n(3)We can now see that as n goes to infinity, both probabilities approach 0.5, meaning any possible biases will be suppressed. The new results of the Dieharder tests show this improves the quality of the random numbers (see Table 2). In practice, implementations can then query the Wi-Fi chip for random samples, and properly and securely manage this collected randomness using a model such as the one proposed by Barak and Halevi [3], or one of its improvements [9]. In [6] Bricout et al. analyze the structure and exploitation of Mantin's ABSAB bias.Security of group keys, and the isolation between unicast and group traffic, is briefly mentioned in the Hole 196 vulnerability [1]. Furthermore, it does not discuss how to inject unicast traffic using the group key, nor does it show how all internet traffic can be decrypted using the group key.Several previous works use the RSSI measurements of 802.11 frames, as returned by commodity Wi-Fi radios, to create secret key agreement protocols [32,23,38]. This is especially problematic for Wi-Fi stacks in embedded devices, as they generally do not have other (standardized) sources of randomness.