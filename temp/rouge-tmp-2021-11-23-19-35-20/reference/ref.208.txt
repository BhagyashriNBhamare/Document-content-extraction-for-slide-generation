In this paper we show how unauthorized co-located Android applications can access pairing-protected BLE data, without the user's knowledge. We discuss mitigation strategies in terms of the various stakeholders involved in this ecosystem, and argue that at present, the only possible option for securing BLE data is for BLE developers to implement remedial measures in the form of application-layer security between the BLE device and the Android application. Bluetooth is a well-known technology standard for wireless data transfer, currently deployed in billions of devices worldwide [37]. A more recent addition to the Bluetooth standard is Bluetooth Low Energy (BLE), which differs from Classic Bluetooth in that it incorporates a simplified version of the Bluetooth stack and targets low-energy, low-cost devices.Its focus on resource-constrained devices has made BLE highly suited for IoT applications [18], including personal health/fitness monitoring [22], asset tracking [8], vehicular management [13], and home automation [27]. To ensure privacy and security/safety, measures should be taken to protect such data from being accessed by unauthorized entities.The Bluetooth specification provides means for restricting access to BLE data via pairing and bonding, which are mechanisms for establishing an authenticated transport between two communicating devices. We also show that these unauthorized applications may be able to do so while requesting minimal permissions, thereby making them appear less invasive than even an authorized application.We discuss various strategies, in terms of the different stakeholders involved, that can be used to secure BLE data against such unauthorized access. This information, Figure 1: GATT communications between a mobile phone and a BLE-enabled glucometer.when combined with the download counts for each application, allows us to estimate a lower bound for the number of BLE devices that may be vulnerable to unauthorized data access.The rest of this paper is structured as follows: Section 2 provides an overview of key BLE concepts, particularly with regard to data access mechanisms and restrictions. Attributes are stored and accessed according to rules specified by the Attribute Protocol (ATT) and the Generic Attribute Profile (GATT), both of which are defined in the Bluetooth standard. (3) Authorization permissions specify whether end-user authorization is required for access.When a GATT client sends a read or write request for an attribute to a GATT server, the server will check the request against the permissions for that attribute, to determine whether the requested access mechanism is allowed and whether the client is authenticated and/or authorized, if required. In the case of authentication permissions, if the attribute requires an authenticated or encrypted link before it can be accessed (referred to as a "pairing-protecte" attribute in this paper), and if such a link is not present when the access request is made, then the server responds with an Insufficient Authentication/Encryption message. Authorization requirements, on the other hand, are implementation-specific and largely left up to developers.Once two devices complete the pairing process, they typically go through an additional bonding process, during which long-term keys are established. Upon re-connection, the link encryption process will be initiated using the stored keys. This attack demonstrates that the BLE credentials that are stored on an Android device are implicitly available to all applications on the device, rather than just the application that originally triggered the pairing.When the OfficialApp connects to the BLE device and attempts to access a pairing-protected characteristic, the resulting exchange will trigger the Android OS into initiating the pairing and bonding process (as depicted in the upper block in Figure 2). This enables the AttackApp to have the same level of access to the pairing-protected data on the device as the OfficialApp, but without the need for initiating pairing.A key point to note here is that, not only is the unauthorized AttackApp able to access potentially sensitive information from the BLE device, but also the user is likely to be unaware of the fact that this data access is taking place, as there is no indication during link re-encryption and subsequent attribute access. able to directly connect to the GATT server and read and write to the characteristics on it (including those that are pairingprotected), without the need for creating a new connection to the peripheral. In this attack scenario, because the OfficialApp scans for the BLE device before it connects to it, it also needs to request the BLUETOOTH_ADMIN permission. For example, a malicious application that masquerades as a gaming application, and which does not request any dangerous permissions, may be more likely to be downloaded by end users as opposed to one that requests location permissions. The simplest form of attack would then be for a malicious application to perform unauthorized reads of personal user data (as an example) and relay this to a remote server.We verified the practicability of this attack by testing a BLE-enabled fitness tracker that implemented the Bluetooth Heart Rate Service. We notified the device developer of this issue on 01 Nov 2018, but have not yet received a response.It should be noted that the above attack could be used by a malicious application to target other sensitive health information such as ECG, glucose or blood pressure measurements from vulnerable BLE devices, to build up a profile on a user's health. Therefore, a malicious application would either require some side-channel information in order to determine the correct moment for data access, or would need to interfere with the existing connection, thereby potentially alerting the user [31]. The main limitation for the AttackApp in the case of the first attack is that it requires the BLUETOOTH and BLUETOOTH_ADMIN permissions in its manifest, and also needs to explicitly request LOCATION permissions at first runtime in order to be able to invoke the BLE scanner. This enables the AttackApp to connect to the BLE device regardless of whether or not another application is also connected, but increases the risk of raising a user's suspicions.In the second attack scenario, the obvious limitation for the AttackApp that requests only the BLUETOOTH permission is that the application will only be able to access data from the BLE peripheral when the peripheral is already in a connection with (another application on) the Android device. The Bluetooth SIG is the group that is responsible for defining and maintaining the Bluetooth standard, which provides details on pairing, bonding and BLE attribute permissions. Despite this, we believe that developers accessing Bluetooth documentation should at least be made aware of the risks involved, and have therefore notified the SIG via their Support Request Form (17 Dec 2018). In this scenario, providing all applications with access to a common BLE transport opens up possibilities for attack, as we have demonstrated.One option to eliminate the problem is to modify how Android handles BLE communication channels. Otherwise, it is fairly likely that this measure will result in a fragmented ecosystem, with some devices running the modified operating system with protection mechanisms, and others running older versions of the OS with no protection.Regardless of whether or not the above measure is implemented, we believe that developers should be made aware of the possibility of unauthorized applications accessing their BLE device data. The issue was reviewed by the security team and rated as Moderate severity (16 May 2019), based on Android's severity assessment matrix [5]. At any rate, this is the only mechanism available at present for protecting data against access by co-located applications.That is, rather than relying solely on the pairing provided by the underlying operating system, developers can implement end-to-end security from their Android application to the BLE peripheral firmware. Due to the lack of clear guidelines regarding attribute security in both the Android Developer Guide and the Bluetooth specification, it is also possible that developers implement no security at all, due to an assumption that protection will be handled by pairing. As discussed in Section 3.3, the only strategy available at present is for developers to implement application-layer security, typically in the form of cryptographic protection, between the Android application and the BLE peripheral.In this section, we identify the proportion of applications that do not implement such security mechanisms, to demonstrate a possible lack of awareness surrounding the issue, and to be able to estimate the number of devices that are potentially vulnerable to the types of attack shown in Section 3.1. Android APKs, on the other hand, are easier to obtain, and a number of decompilers exist that allow for conversion of APKs to a human-readable format.We therefore target Android applications for our analysis and perform the following: (1) obtain a substantial dataset of BLE-enabled Android APKs, (2) determine the BLE method calls and the cryptography libraries of interest, and (3) define a mechanism to determine whether BLE reads and writes make use of cryptographically processed data. We performed our analysis over the entire dataset, rather than focusing on only those APKs that are currently available on Google Play. Applications are categorized in Google Play according to their primary function, such as "Productivity" or "Entertainment", and it may be possible to gauge the sensitivity of the BLE data handled by an application based on the category it falls under. When considering BLE methods, we focus on those methods that involve data writes and b "% of Total Methods" refers to the percentage of occurrences of a particular method for a particular data access type (i.e., read or write), with respect to all methods that enable the same type of data access.reads. However, we do not include these in our analysis as they are now obsolete.For cryptography, Android builds on the Java Cryptography Architecture [33] and provides a number of APIs, contained within the java.security and javax.crypto packages, for integrating security into applications. We also found through manual analysis that many instances of cryptographically-processed data were not identified by Amandroid, especially when the BLE functions were called from third-party libraries. Direct trace -Attempt to identify link between BLE and cryptography functions via direct register value transfers and as immediate results of method invocations. Associated entity trace -If the direct trace does not identify a link between source and sink, analyze abstract/instance methods and other registers used in previously analyzed function calls. For this reason, BLECryptracer assigns "confidence levels" of High, Medium and Low to its output, which correspond to the three trace methods above, to indicate how certain it is of the result. Note that BLECryptracer only looks for application-layer security in benign applications, and these confidence levels apply only when deliberate manipulations (i.e., malicious obfuscation techniques) are not employed to hide the data flow between source and sink.Appendix A describes the tracing mechanism in greater detail, and also outlines how BLECryptracer combats the effects of obfuscation in benign applications. In total, we created 184 APKs: 92 for reads and 92 for writes.We executed BLECryptracer against our benchmarking test set, analyzed the results and obtained performance metrics in terms of the three different confidence levels. For example, when considering the analysis of BLE reads, while the entire dataset of 92 APKs is relevant for confidence level High, only the 30 APKs that do not result in a TRUE outcome at level High will be analyzed for confidence level Medium. In terms of the True Positive Rate, BLECryptracer performs better than Amandroid for reads at 75% vs. 57%, and slightly worse for writes at 60% vs. 64%. These results show that, overall, BLECryptracer performs better than Amandroid for analyzing the use of cryptography with BLE data.It should be noted that three of the four False Positives obtained by BLECryptracer at the High confidence level were due to the order in which variables are assigned values (i.e., lifecycle events), which is not tested for by BLECryptracer.Other data transfer mechanisms not tested for are Looper and Messenger functions, which generate False Negatives. For this, we ran the two tools against a random subset of 2,000 APKs and compared time-to-completion in both cases. We imposed a maximum run-time of 30 minutes per APK for both tools, and only compared execution times for those cases where Amandroid did not time out (approximately 40% of the tested APKs timed out when analyzed by Amandroid. However, even with the longer analysis time, 44 and 76 APKs timed out for reads and writes, respectively, and had to be excluded from further analysis. While this is a large proportion of APKs, the results also indicate that a much smaller percentage of APKs use cryptographically processed data with BLE reads and writes (approximately 25% for both, identified with High confidence). Within the APKs that used both applicationspecific methods and libraries, around 34% used an external library to provide Device Firmware Update (DFU) capabilities, thereby enabling the BLE peripheral to be updated via the mobile application. This proportion was lower at 48% for applications that relied on libraries.In the case of the APKs that called getValue variants, 37% used only application-specific methods, 58% used only libraries, and 5% used both. In fact, a single such library (Estimote) made up more than 90% of all instances of cryptographically-processed BLE writes and 85% of cryptographically-processed BLE reads (identified with High confidence). An analysis of this library suggested that cryptography is being used to authenticate requests when modifying settings on the beacon.Apart from beacon libraries, we identified five libraries that function as wrappers for the Android BLE API. This library allows third-party developers to integrate their services into the Flic ecosystem, to allow them to automate certain tasks.Finally, Nordicsemi is a library provided by a BLE chipset manufacturer to enable DFU over the BLE interface. BLECryptracer identified 3,228 unique packages with cryptographically protected BLE data (with either reads or writes), with High confidence. 24 APKs were found to have issues within or associated with the methods that cryptographically processed BLE data (as identified by BLECryptracer) and often, a single APK exhibited multiple issues. Note that because this analysis was performed over unique packages, the number of APKs that misuse crypto-libraries will be higher.We manually analyzed the 24 APKs that were flagged by CogniCrypt as having BLE-relevant issues, and examined the identified instances of bad cipher modes and hardcoded keys/Initialization Vectors (IVs). This analysis shows that several real-world applications contain basic mistakes in their use of crypto-libraries and handling of sensitive data, which means that the BLE data will not be secure despite the use of cryptography. While it would be reasonable to expect that most "Medical" applications would implement some level of application-layer security, the results show that fewer than 30% of applications under this category actually have such protection mechanisms. In fact, of the APKs categorized under "Medical" and with no cryptographic protection for either reads or writes, we found that three of the top ten (in terms of installations) contained identifiers for the standard Bluetooth Glucose Service.Perhaps surprisingly, APKs that are categorized under "Business", "Shopping" and "Travel & Local" appear to be the most likely to incorporate application-layer security, with around 50% of all such applications being identified as having Graph depicts APKs that perform BLE reads or writes, and have no cryptographic protection for either. The tracker is a low-cost model that, based on the install count on Google Play (1,000,000+), appears to be widely used. To exploit this, we developed an APK that, in accordance with the attacks described in Section 3.1, connects to the device, sends commands to place it in DFU mode, and then writes a new modified firmware to the device without user intervention. As mentioned in Section 4.4, BLECryptracer does not analyze data that is written out to file (including shared preferences), or communicated out to a different application, because it is not straightforward (and many times, not possible) to determine how data will be handled once it has been transferred out of the application under analysis. When backtracing a register, BLECryptracer stops when it encounters a constant value assignment. Some of the research has focused on the threats to privacy based on user location tracking [15,19], while others explored the possibility of obtaining personal user data from fitness applications or devices [14,28]. In this paper, we analyze the risks posed to data on Bluetooth Low Energy devices from co-located Android applications. We show the conditions under which an unauthorized Android application would be able to access potentially sensitive, pairing-protected data from a BLE peripheral, once a co-located authorized application has paired and bonded with a BLE peripheral, without the user being aware of the access. Our results suggest that over 45% of all applications, and about 70% of "Medical" applications, do not implement cryptography-based applicationlayer security for BLE data. The code for our BLECryptracer tool is available at https://github.com/projectbtle/BLECryptracer This repository also contains the SHA256 hashes of the APKs in our dataset, and the source/sink files used for the Amandroid analysis. Finally, in the event that no cryptography use is identified at High or Medium confidence levels, the script performs a less stringent search through all the instructions of the methods that it previously analyzed. As an example, considering the smali code in Figure 9, the byte array output from the BLE read is stored in register v0 (Line 4). This taints register v3 via a format conversion function (Lines 10 and 11), which in turn taints v2 via a java.lang.StringBuilder function (Lines 12 and 13). This research has been partially sponsored by the Engineering and Physical Sciences Research Council (EPSRC) and the UK government as part of the Centre for Doctoral Training in Cyber Security at Royal Holloway, University of London (EP/P009301/1). cWe describe here the basic tracing mechanism employed by BLECryptracer in order to identify the presence of application-layer security for BLE data. If the BLE data had come from a local register, rather than a parameter register, BLECryptracer would trace back within method a's instructions, to determine the origin of the data. Note that calls to any method within the crypto-libraries mentioned in Section 4.2 are accepted as evidence of the use of cryptography with BLE data. BLECryptracer identifies all calls to these methods, and then traces the origins of the data held in the registers that are passed as input to the methods.Considering the smali 4 code in Figure 8 as an example, setValue is invoked at Line 13 and is passed two registers as input. Note that calls to any method within the crypto-libraries mentioned in Section 4.2 are accepted as evidence of the use of cryptography with BLE data. However, the script does not analyze the order in which the field is assigned values, as this would require activity life-cycle awareness.Where a register is assigned a value that is output from a method invocation via move-result, if the method is not an external method, then the instructions within that method are analysed, beginning with the return value and tracing backwards.