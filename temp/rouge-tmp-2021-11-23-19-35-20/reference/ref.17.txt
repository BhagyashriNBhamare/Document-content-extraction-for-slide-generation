Our extensive evaluation shows that our mitigation (i) can stop available real-world rowhammer attacks, (ii) imposes virtually no run-time overhead for common user and kernel benchmarks as well as commonly used applications, and (iii) does not affect the stability of the overall system. However, the infamous rowhammer attack [11] undermines this access control model by exploiting a hardware fault (triggered through software) to flip targeted bits in memory. Rowhammer attacks repetitively read (hammer) from the same physical memory address in very short time intervals which eventually leads to a bit flip in a physically co-located memory cell.Rowhammer Attack Diversity. For this, a malicious user-mode application locates vulnerable memory cells and forces the operating system to fill the physical memory with page-table entries (PTEs), i.e., entries that define access policies to memory pages. As such, rowhammer has become a versatile attack technique allowing compromise of co-located virtual machines [18,26], and enabling sophisticated control-flow hijacking attacks [6,19,22] without requiring memory corruption bugs [4,7,20]. The goal of this paper is to develop the first practical software-based defense against rowhammer attacks that can instantly protect existing vulnerable legacy systems without suffering from any performance overhead and false positives. Hence, we focus in this paper on practical kernel-based rowhammer attacks.We present the design and implementation of a practical mitigation scheme, called CATT, that does not aim to prevent bit flips but rather remove the dangerous effects (i.e., exploitation) of bit flips. For this, we extend the operating system kernel to enforce a strong physical isolation of user and kernel space.In detail, our main contributions are:â€¢ We present a practical software-based defense against rowhammer. In particular, our performance measurements indicate no computational overhead for common user and kernel benchmarks.For a more comprehensive version of this paper with other rowhammer defense solutions, options and more technical details we refer to our full technical report available online [5]. The hardware module is called Dual Inline Memory Module (DIMM), which is physically connected through a channel to the memory controller. A read operation always reads out the bits from a whole row, and the result is first saved in the row buffer before it is then transferred to the memory controller. The row buffer is also used to write back the content into the row of memory cells to restore their content.It is noteworthy to mention that there exists the mapping between physical memory address and the rank-, bank-and row-index on the hardware module is nonlinear. As mentioned before, memory access control is an essential building block of modern computer security, e.g., to achieve process isolation, isolation of kernel code and data, and manage read-write-execute permission on memory pages. Since a rowhammer attack induces bit flips in co-located memory cells, it provides a subtle way to launch a remote attack to undermine memory isolation.Recently, various rowhammer-based attacks have been presented [4,7,17,18,20,24,26]. Kim et al. [11] demonstrate that repeatedly activating two rows separated by only one row, called aggressor rows ( 1 and 3 in Fig- ure 2), lead to a bit flip in the enclosed row 2 , called victim row. 1 To do so, the attacker has to overcome the following challenges: (i) undermine memory caches to directly perform repetitive reads on physical DRAM memory, and (ii) gain access to memory co-located to data critical to memory isolation.Overcoming challenge (i) is complicated because modern CPUs feature different levels of memory caches which mediate read and write access to physical memory. If the operating system maps the attacker's allocated memory to the physical memory containing the aggressor rows, the attacker has satisfied the first condition. Once control over the aggressor rows is achieved, the attacker releases all allocated memory except the parts which contain the aggressor rows. If not, the second step is repeated until the rowhammer successfully executes.Seaborn et al. [20] successfully implemented this approach to compromise the kernel from an unprivileged user process. Our defense, called CATT, 2 tackles the malicious effect of rowhammer-induced bit flips by instrumenting the operating system's memory allocator to constrain bit flips to the boundary where the attacker's malicious code executes. In particular, CATT prevents bit flips from affecting memory belonging to higher-privileged security domains, e.g., the operating system kernel or co-located virtual machines. Without CATT, the attacker is able to craft a memory layout, where two ag-gressor rows enclose a victim row of a higher-privileged domain such as row 2 in Figure 2. With CATT in place, the rows which are controlled by the attacker are grouped into the security domain A, whereas memory belonging to higher-privileged entities resides with their own security domain (e.g., the security domain B). We define and maintain two security domains: a security domain for kernel memory allocations, and one security domain for user-mode memory allocations (see also Figure 3). For CATT, we use this methodology to discover the physical addresses of rows.We need to ensure that the physical memory management component is aware of the isolation policy. To tackle this challenge, we instrumented the memory allocator to keep track of the domain association of physical memory and serve memory requests by selecting free memory from different pools depending on the security domain of the requested memory. However, our concept can be applied to other architectures, as well.The basic idea underlying our software-based rowhammer defense is to physically separate rows that belong to different security domains. Hence, our implementation of CATT changes low-level components of the kernel to make the operating system aware of the concept of memory rows.In the following, we describe how we map individual memory pages to domains, keep track of different domains, modify the physical memory allocator, and define partitioning policies for the system's DRAM hardware. To be able to decide whether two pages belong to the same security domain we need to keep track of the security domain for each page frame. Since our prototype implementation targets rowhammer attacks that aim at violating the separation of kernel and user-space, we encode security domain 0 for kernel-space, and 1 for user-space. Therefore, we reset the security domain upon freeing a page.Upon memory allocation, CATT needs to correctly set the security domain of the new page. We leverage this information and separate the two domains by setting the domain field of the respective page frame.When processes request memory, the kernel initially only creates a virtual mapping without providing actual physical page frames for the process. We modified the page fault handler, which initiates the allocation of a new page, to pass information about the security domain to the page allocator. Next, the page is allocated according to our policy and sets the domain field of the page frame's meta data object to the security domain of the interrupted process. This enables CATT to separate kernel from user pages according to the security domain of the origin of the allocation request. We additionally instrument a range of maintenance checks to make them aware of our partitioning policy before the allocator returns a physical page. 5 Due to this design memory allocated to the kernel during early boot is allocated from a memory region which is part of the kernel's security domain, hence, the isolation covers all kernel memory. However, this would likely result in a severe increase of memory latency, since reads and writes to a specific memory bank are served by the bank's row buffer.The benefit of our partitioning policy stems from the fact that we distribute memory belonging to the kernel security domain over multiple banks thereby not negatively impacting performance. Since the row size is the same for all Intel architectures prior to Skylake [7], our implementation for this policy is applicable to a wide range of system setups, and can be adjusted without introducing major changes to fit other configurations as well. We tested 6 The default values for DDR3 on x86 are 4K for the page size, 2 pages per row, 8 banks per rank, 2 ranks per DIMM and between 1 and 4 DIMMs per machine. For the first scenario, we systematically search for reproducible bit flips based on a tool published by Gruss et al. 7 Our second attack scenario leverages a realworld rowhammer exploit published by Google's Project Zero. Specifically, we extended the tool to also report the aggressor physical addresses, and adjusted the default size of the fraction of physical memory that is allocated for the test. As a result, most of the systems physical memory is allocated to the rowhammering tool.Afterwards, the tool analyzes the memory in order to identify potential victim and aggressor pages in the physical memory. As the test uses the double-sided rowhammering approach two aggressor pages must be identified for every potential victim page. The test outputs a list of addresses for which bit flips have been observed, i.e., a list of victim addresses.Preliminary Tests for Vulnerable Systems. Since the attacker cannot force the system to allocate page tables at a certain physical position in RAM, the attacker has to repeatedly spray the memory with page tables to increase the chances of hitting the desired memory location. Additionally, we tested the bit flips across reboots through random sampling.The three systems mentioned in Table 1 and Table 2 are highly susceptible to reproducible bit flips. Executing the rowhammer test on these three times and rebooting the system after each test run, we found 133 pages with exploitable bit flips for S1, 31 pages for S2, and 23 pages for S3.To install CATT, we patched the Linux kernel of each system to use our modified memory allocator. 10 To launch the exploit, two conditions need to be satisfied: (1) a page table entry must be present in a vulnerable row, and (2) the enclosing aggressor pages must be allocated in attacker-controlled memory.Since both conditions are not directly controllable by the attacker, the attack proceeds as follows: the attacker allocates large memory areas. Hence, as expected, CATT effectively prevents rowhammer-based exploits.As we have demonstrated, CATT successfully prevents the original attack developed on x86 by physically isolating pages belonging to the kernel from the userspace domain. We use the Linux Test Project, which aims at stress testing the Linux kernel, to evaluate the stability of our test system after deploying CATT. In particular, we selected a subset of benchmarks 11 that, on one hand, aim to measure memory performance (IOZone and Stream), and, on the other hand, test the performance of common server applications which usually rely on good memory performance.To summarize, our rigorous performance evaluation with the help of different benchmarking suites did not yield any measurable overhead. However, we attribute such results to measuring inaccuracy.SPEC2006 CATT perlbench 0.29% bzip2 0.00% gcc -0.71% mcf -1.12% gobmk 0.00% hmmer 0.23% sjeng 0.19% libquantum -1.63% h264ref 0.00% omnetpp -0.28% astar -0.45% xalan -0.14% milc -1.79% namd -1.82% dealll 0.00% soplex 0.00% povray -0.46% lbm -1.12% sphinx3 -0.58% Mean -0.49% Phoronix CATT IOZone 0.05% Unpack Kernel -0.50% PostMark 0.92% 7-Zip 1.18% OpenSSL -0.22% PyBench -0.59% Apache -0.21% PHPBench 0.35% stream 1.96% ramspeed 0.00% cachebench 0.05% Mean 0.27% LMBench3 CATT Context Switching: 2p/0K -2.44% 2p/16K 0.00% 2p/64K 2.00% 8p/16K -1.73% 8p/64K 0.00% 16p/16K -1.33% 16p/64K 0.99% Mean -0, CATT prevents the operating system from allocating certain physical memory. We first run these tests on a vanilla Debian 8.2 installation to receive a baseline for the evaluation of CATT. In contrast to double-sided rowhammer attacks (see Figure 2), single-sided rowhammer attacks relax the adversary's capabilities by requiring that the attacker has control over only one row adjacent to the victim memory row. This means that the single-sided rowhammer adversary can only flip bits in own memory (that it already controls), or flip bits in buffer rows. More specifically, they attributed potential aggressor rows with a greater row distance to the re-mapping of faulty rows: DRAM manufacturers typically equip their modules with around 2% of spare rows, which can be used to physically replace failing rows by re-mapping them to a spare row [23]. Seaborn and Dullien [20] published the first practical rowhammer-based privilege-escalation attacks using the x86 clflush instruction. Since the physical memory is filled with page-table entries, there is a high probability that an individual page-table entry is modified by the bit flip in a way that enables the attacker to access other page-table entries, modify arbitrary (kernel) memory, and eventually completely compromise the system. Later, Bosman et al. [4] extended this work by exploiting the memory deduplication feature of Windows 10 to create counterfeit JavaScript objects, and corrupting these objects through rowhammer to gain arbitrary read/write access within the browser. The idea behind refreshing the rows more frequently (every 32ms instead of 64ms) is that the attacker needs to hammer rows many times to destabilize an adjacent memory cell which eventually causes the bit flip. Thus, PARA is not suited to protect legacy systems.To the best of our knowledge Aweke et al. [3] proposed the only other software-based mitigation against rowhammer. CATT is a practical mitigation that tolerates rowhammer attacks by dividing the physical memory into security domains, and limiting rowhammer-induced bit flips to the attacker-controlled security domain. The authors thank Simon Schmitt for sacrificing his personal laptop to the cause of science, and Victor van der Veen, Daniel Gruss and Kevin Borgolte for their feedback.This work was supported in part by the German Science Foundation (project P3, CRC 1119 CROSSING), the European Union's Horizon 2020 Research and Innovation Programme under grant agreement No. 643964 (SUPERCLOUD), the Intel Collaborative Research Institute for Secure Computing (ICRI-SC), and the German Federal Ministry of Education and Research within CRISP.