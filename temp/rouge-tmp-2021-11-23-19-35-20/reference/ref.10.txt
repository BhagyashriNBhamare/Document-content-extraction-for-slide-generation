Most existing uses of cut-and-choose fix in advance the number of objects to be checked and in optimizing this parameter they fail to recognize the fact that checking and evaluating may have dramatically different costs. Source code of our game solvers is available to download at https://github.com/cut-n-choose. The second party, who will serve as the circuit evaluator, obtains garbled values for its own inputs using oblivious transfer, and then evaluates the garbled circuit to obtain the result.The primary challenge in handling malicious adversaries is to ensure that the garbled circuit sent by the first party is constructed correctly. Since its formal treatment by Lindell and Pinkas [16], numerous works have improved various aspects of the cut-and-choose methodology and used it to design secure protocols [28,18,24,25,26,17,14,6,15,10,27,4,2,19,11,1,20]. Although SingleCut is asymptotically better than MajorityCut, some SingleCut protocols [15] require using MajorityCut on a smaller circuit as a sub-routine, and therefore optimizations to MajorityCut can result in efficiency improvements to SingleCut. In addition, MajorityCut works better for applications with long outputs as its cost does not grow with output length.When setting parameters for cut-and-choose protocols, in order to optimize efficiency for some target level of security, state-of-the-art approaches treat circuit checking roughly as expensive as circuit evaluation, and hence strive to optimize the total number of garbled cir- To be conservative in estimating r, figures assume 128-bit labels. Although some researchers [15,7,2] observed the asymmetry in the cost of checking and evaluation, they did not explore the cost asymmetry further, and did not investigate the possibility of optimizing cutand-choose parameters based on this asymmetry.As evidenced by many recent prototypes [21,29,20,5,9,26,25,14,13], network communication has become the most prominent bottleneck of garbled-circuit protocols, especially when exploiting dedicated hardware [3,8] or parallelism [5,23,13] for faster garbling/evaluation. Table 1 presents, in the context of a few example applications, the bandwidth costs for sending an entire circuit (i.e. the costs for an evaluated circuit) versus the cost for committing to the circuit (which, for simplicity, requires only one SHA256 hash), and thus a sample ratio r that we use in this paper as a variable.Based on these observations, we propose a new approach to optimizing parameters in cut-and-choose protocols. Shen and Shelat [26] slightly improved the bound to 2 −0.32s by opening roughly 60% (instead of one half) of the circuits; this reduces the number of garbled circuits needed to 125 for 2 −40 security. These works show that cut-and-choose can be very efficient in an amortized sense, requiring fewer than 8 circuits per execution to achieve 2 −40 security when amortizing over 1000 executions. The simplest version of cut-and-choose can be treated as a zero-sum game (where the utilities are 0/1 for the loser/winner) between the evaluator and the generator in which the generator wins if it can produce enough incorrect circuits to skew the protocol without being detected. For example, we are able to reduce the network traffic by up to an orderof-magnitude in comparison with the state-of-the-art SingleCut (see Figure 5) and MajorityCut (see Figure 2) protocols, and savings of 20% ∼ 80% for state-of-the-art (already highly optimized) BatchedCut protocols (see Fig- ure 8). In the case when the parameters e, k are set deterministically and public, the cut-and-choose parameter optimization problem can be expressed as the following non-linear programming problem:arg min e,k r · e + k subject to max b Pr a (e, k, b) ≤ ε,where ε, r are known input constants; Pr a (e, k, b) is the probability of a successful attack; and b is the total number of bad circuits generated by the malicious generator.In the case when at least one of the two parameters (e and k) is randomly picked by the circuit evaluator from some public distributions (but sampled values remain secret to the circuit generator at the time of circuit generation), the optimization problem takes a more general form arg minS E E[cost(r, S E )] subject to E [Pr a (S E , S G )] ≤ ε, ∀ S Gwhere S E and S G are the circuit evaluator's and the circuit generator's strategies, respectively; cost is the cut-andchoose cost function, and E[·] denotes the expectation function. We stress that, in contrast to the common belief used in the state-of-the-art cost analysis of cut-and-choose protocols, the cost of cut-and-choose is usually not best represented by n-the total number of circuits generated, but rather by a cost ratio r between checking and evaluation which depends on many factors such as (1) the kind of cost (e.g., bandwidth or computation); (2) the deployment environment (e.g., network condition, distribution of computation power on the players, buffering, etc.) (3) the specific cryptographic primitives and optimization techniques (e.g., the garbling scheme) used in a protocol. The main thesis of this work is, Cut-and-choose protocols should be appropriately configured based on the security requirement (ε) and the cost ratio (r) benchmarked at run-time. MajorityCut strategy stems from an intuitive folklore idea: the circuit evaluator randomly selects k (out of a total n circuits) to check for correctness, evaluates the remaining e = n−k circuits, and outputs the majority of the e evaluation results. The expected cost of MajorityCut isn ∑ i=0 [x i · (i · r + (n − i))] = n + (r − 1) n ∑ i=0 x i · iIf the generator produces b incorrect circuits and the evaluator evaluates i circuits, the probability that the evaluator's check passes is񮽙 n−b n−i n n−i񮽙 . In other words, the goal of picking optimal cut-and-choose parameters can be achieved by solving the following linear program:min x x x n + (r − 1) n ∑ i=0 x i · isubject tox i ≥ 0 n ∑ i=0 x i = 1, min(n,2b) ∑ i=b x i · 񮽙 n − b i − b n i 񮽙 < ε, ∀b ∈ {1,. We note that when r > t r (step 2), it suffices to search all e less than e 0 (recall (e 0 , n 0 , c 0 ) is the starting point of our search, simply derived from the traditional setup with MajorityCut) instead of the infinite range because any strategy with e = e 0 + 1 that is more efficient than one with e = e 0 has to use at least r − 1 fewer check circuits. In comparison, the best protocols that use BatchedCut need to amortize 1000s of protocol executions to achieve security when sending roughly 10 circuits.In Figure 2, the cross-marked solid curve delineates the optimal cost of mixed strategies (among all strategies with public fixed n), while the dot-marked dashed curve delineates pure-strategy approximation of the optimal mixed strategies (efficiently computed as a result of step 2 of Figure 1 search algorithm). We leave the formal proof of this intuition as an interesting future work.To examine the characteristic of our solution more closely for 1 ≤ r ≤ 128, we have plotted the comparison of overall cost of the optimal strategy with respect to best prior works (Figure 3a), the standard deviation of the overall cost (Figure 3b, recall the optimal strategy is a randomized strategy), and the best n used in every optimal strategy (Figure 3c). (b) For n := n 0 to c * − (r − 1)(1 − ε), i. Solve the MajorityCut linear programming problem for (n, ε, r) to obtain (c, x x x) where c is the minimal cost of LP(n, ε, r) and x x x represents the corresponding strategy to achieve c. ii. For every specific ε and r, our solver outputs a particular n and a distribution x x x for picking e. Roughly speaking, the only changes needed in the protocol are straightforward: the evaluator announces this n beforehand and the result of the coin-tossing protocol ρ is used to sample e according to x x x using standard methods (instead of the 1/2 or 3/5 fractions as before). Similarly, the first protocol of Lindell and Pinkas [16] can be modified to adopt this idea: step (3) should send commitments to garbled circuits, modify step (4) to use the random tape from coin-tossing to sample e, modify step (8) so that the garbler sends the entire garbled circuits for the evaluation specimens as well as openings to the commitments so that the evaluator can check consistency.The idea seems applicable to many protocols which have the property that the set of checked circuits becomes publicly verifiable. In the latter case, the evaluator uses the two different authenticated output labels to recover the garbler's input, and then evaluate the function itself.The state-of-the-art SingleCut protocols implicitly assume r = 1, in which case an honest evaluator's best strategy is to evaluate each garbled circuit with probability 1/2, as there is only a single way for the malicious generator to win the cut-and-choose game. For n := n 0 to c * − (r − 1)(1 − ε), (a) Solve the SingleCut linear programming problem for (n, ε, r) to obtain (c, x x x) where c is the minimal cost of LP(n, ε, r) and x x x represents the corresponding strategy to achieve c.(b) If (c, x x x) 񮽙 = ⊥ and c * > c, then (c * , x x x * , n * ) := (c, x x x, n). c is the minimal cost, n is the fixed total number of circuits and x x x = (x 0 ,. In order to minimize ∑ n i=0 x i · i, we aim to maximize x i (which is upper-bounded by ε · 񮽙 n i 񮽙 and collectively constrained by ∑ n i=0 x i = 1) for all small i's. The savings due to our approach rise steadily for r < 10 4 and can get to about 10X for reasonably large r (e.g., r = 7 × 10 7 , which roughly corresponds to the bandwidth-based costratio for privately computing the edit distance between two 1000-character strings). This is because for any fixed ε, it does not make sense to trade in a larger n for a smaller e, • Add a step 0 to [15, Protocol 2], where an n is fixed in advance based on ε and r.• Change step 2(b) of [15, Protocol 2] to: P 2 picks the check-set J at random so that |J| = k, where k is randomly sampled from the distribution computable (from n, r, ε) by the 2-step algorithm given above.Afshar et al.[2] present a conceptually simple and elegant non-interactive secure computation protocol; it uses a cut-and-choose technique and achieves security 2 −40 by sending 40 garbled circuits. The basic idea of BatchedCut is to amortize the cost of cut-and-choose across either many protocol executions (of the same circuit) [11,19] or many basic gates [12,6,24] of a big circuit. Let N be the number of times a particular functionality will be executed, T be the total number of circuits generated to realize the N executions, and let B denote the bucket size.With any positive r, we want to identify parameters (T, B) such that cost(T, B) is minimized over all (T, B) configurations that satisfy the security constraint. The next term, Pr e reflects the probability that conditioned on the first phase passing, the evaluator randomly assigns the remaining circuits to buckets, and one bucket of size B contains all corrupted circuits.Pr e (N, B, b) = 0, ∀0 ≤ b ≤ B(1)Pr e (N, B, b) = 񮽙 b B BN B 񮽙 + b−1 ∑ i=0 Pr e (N − 1, B, b − i) · 񮽙 b B−i 񮽙񮽙 BN−b i 񮽙 񮽙 BN B 񮽙(2)The first equation holds because a garbler who corrupts fewer than B circuits never succeeds. For every B, the cost cost(T, B) strictly increases with T while the failure rate Pr fail strictly decreases with T . ,T } (where b is the number of corrupted circuits generated by the attacker), which, if naively implemented, would require computing Pr fail T · T times for every B. The idea is to use generating functions to efficiently calculate Pr e as the ratio between the number of ways to group garbled circuits into buckets that will result a failure (i.e., at least one bucket is filled with all B bad circuits) and the total number of ways to group the garbled circuits. For every ε, c 0 =(T − BN)/T, τ > 0, if N > i 0 񮽙񮽙 B 1−c 0 − B 1−(1−τ)c 0 񮽙 and b > −(񮽙log ε񮽙 + 1) 񮽙 log 񮽙 (1 − τ)c 0 + B B/(1−c 0 )−i 0 /N 񮽙 , then Pr fail (N, B, T, τ, b) < ε.Last, we also considered employing mixed strategies for BatchedCut protocols (i.e., fixing T to some public value up-front while randomizing the selection of B) to further reduce the cost. Our test implementation utilizes Intel AES-NI instructions and the half-gate garbling technique [30] to minimize bandwidth usage, and SHA256 implementation provided by Libgcrypt for circuit hashing. Note that our approach yields no noticeable time savings for the settings of running SingleCut or BatchedCut protocols in a 1 Gbps LAN with single-core processors (compared to the their state-of-the-art couterparts), because the cost ratio r is already very close to 1. Similarly, we have, there exists N 1 such that if N > N 1 , 񮽙 T −b T −BN−i 񮽙 񮽙 T T −BN 񮽙 ≥ 񮽙 T − BN − i + 1 T − i + 1 񮽙 i 񮽙 BN − b + i + 1 T − b + 1 񮽙 b−i 񮽙 L.So, we know that, for sufficiently large N, U 񮽙 񮽙 T −b T −BN−i 񮽙 񮽙 T T −BN 񮽙 ≤ U L = 񮽙 T − BN T − BN − i + 1 · T − i + 1 T 񮽙 i 񮽙 BN BN − b + i + 1 · T − b + 1 T − i 񮽙 b−i = 񮽙 (≤ 񮽙 1 + i − 1 T − BN − i + 1 񮽙 i 񮽙 1 + b − i − 1 BN − b + i + 1 񮽙 b−i (3) ≤ 񮽙 1 + i − 1 T − BN − i + 1 񮽙 i 񮽙 1 + b − 1 BN − b + 1 񮽙 b (4)Note that the inequality (3) , then Pr fail (N, B, T, τ, b) < ε.Proof Let 0 < τ ≤ 1 be the probability that P 2 detects the abnormality in checking garbled gate g conditioned on g is indeed bad. Work of Ruiyu Zhu and Yan Huang was supported by NSF award #1464113.