Internet of Things (IoT) platforms often require users to grant permissions to third-party apps, such as the ability to control a lock. Our technique, called SmartAuth, automatically collects security-relevant information from an IoT app's description , code and annotations, and generates an authorization user interface to bridge the gap between the functionalities explained to the user and the operations the app actually performs. To address the unique challenges in IoT app authorization, where states of multiple devices are used to determine the operations that can happen on other devices, we devise new technologies that link a device's context (e.g., a humidity sensor in a bath room) to an activity's semantics (e.g., taking a bath) using natural language processing and program analysis. The rapid progress of Internet of Things (IoT) technologies has led to a new era of home automation, with numerous smart-home systems appearing on the market. Each SmartApp asks for a set of capabilities (the device functionality the app needs), and the user must choose the IoT devices to perform respective functions for the app (for example, see Figure 1). In mapping capabilities to devices, the user allows the IoT app to perform the set of operations defined by those capabilities (e.g., turn on a light, unlock the door) based on event triggers (e.g., the room becomes dark, a valid token is detected near the door). Even worse, unlike the Android permission model, which asks the user for permission to access specific resources on a single device (e.g., location, audio, camera), access control in a smart home system is much more Figure 1: The installation interface of SmartApp SAFETY WATCH lists configuration options without connecting to higherlevel app functionality. Explaining such complicated policies to users is challenging, and effective authorization assistance should certainly go beyond what is provided by SmartThings (illustrated in Figure 1). Because the natural-language description developers write to advertise an app in the app store is the key source of users' expectations for what the app will do, we use natural language processing (NLP) to automatically extract capabilities from this description.SmartAuth then compares the app's actual functionality (determined through program analysis) to the functionality developers represent (determined through NLP). We use further NLP to analyze the app description provided by the developer to extract higher-level information about the stated functionality, including entities (e.g., "a coffee machine"), actions (e.g., "taking a shower"), and their relationships (e.g., "turn on the coffee machine after taking a shower"). For example, an annotation indicating a "bathroom" and the activity "take a shower" are used to identify the location of the humidity sensor of interest.To minimize user burden, SmartAuth automatically allows functionality that is consistent between the app's natural-language description and code, yet points out discrepancies between the description and code since these are potentially unexpected behaviors. SmartAuth successfully recovered authorization-related information (with 3.8% false positive rate and no false negatives) within 10 seconds. For instance, given two similar apps, one of which was overprivileged, using the current Samsung SmartThings interface, 48% of participants chose to install the overprivileged app in each of five tasks. Given our observations of the effectiveness of the technique, the low performance cost, and the high compatibility with existing apps and platforms, we believe that SmartAuth can be utilized by IoT app marketplaces to vet submitted apps and enhance authorization mechanisms, thereby providing better user protection.Our key contributions in this paper are as follows:• We propose the SmartAuth authorization mechanism for protecting users under current and future smart home platforms, using insights from code analysis and NLP of app descriptions. Figure 2: Users install IoT apps through mobile devices, allowing the vendor's IoT cloud to interact with the user's locally deployed devices. Figure 2 depicts cloud-based IoT apps BEACON CONTROL and SIMPLE CONTROL installed by a user from their mobile device and with access to the user's relevant IoT devices.Current IoT platforms use capabilities [36] to describe app functionality and request access control and authorization decisions from users. Word2Vec has many advantages over previous approaches, including catching syntactic and semantic information better than WordNet [39] and achieving lower false positive rates than ESA [21]. We also rely on the typed dependencies analysis [27] to understand the grammatical structures of sentences, grouping words together to recognize phrases and pair subjects or objects with verbs. We observe that several IoT apps exhibit capability-enabled functional behaviors that are not disclosed to the user, causing a discrepancy between the user's mental model and the actual privilege of the app. An example of this type is an IoT app that describes the ability to control lights while requesting capabilities to read and control a door lock. • Least-privilege: The system should grant only the minimum privileges to an IoT app, just enough to support the desired functionality. • Compatible: The authorization approach should be compatible with existing smart home platforms and applications without breaking app functionality.Since authorization decisions are made by humans, providing a human-centric design to help users to make wellinformed decisions is critical. Toward this goal, we design an intelligent authorization system that recovers adequate semantic information from IoT apps and presents it to users in an understandable way. We analyze the semantic meaning of these components to discovery inconsistency, then automatically generate an authorization interface explaining the findings to the user.Based on these design principles, our SmartAuth system includes five components: a program analyzer, a content inspector, a consistency checker, an authorization creator and a policy enforcer, as illustrated in Figure 3. To extract an app's security-critical behaviors, we perform static analysis on the app's source code and use NLP techniques on code annotations and API documents.We collected the source code for 180 Samsung SmartThings apps from an source-level market in May 2016 [48]. Second, SmartThings apps are written in Groovy, which transfers method calls into reflective ones and creates challenges for existing binary analysis tools to deal with reflections. Therefore, binary analysis is not suitable.We first extract capabilities, which are directly associated with security behaviors, by searching for the term "capability" in the preference block. We consider two types of remote access: whether the app sends data to the remote server and whether the app works as a web service to take commands from the remote server. We search the AST to match patterns including OAuth, createAccessToken, and groovyx.net.http.We also examine clues from code annotations (e.g., comments and text strings) to gain further information about context and device state. For example, we can extract that the humidity sensor is associated with bathroom from understanding the annotation in the following code snippet.Listing 1: Code Snippet about Device Selection section("Bathroom humidity sensor") { input "bathroom", "capability. relativeHumidityMeasurement", title: "Which humidity sensor?" } Most cases are more complex than this example, and our more comprehensive analysis follows.Specifically, we use the Stanford POS Tagger to identify parts of speech and the Stanford Parser to analyze sentence structure, including typed dependencies, as illustrated in Figure 5. Similarly, our technique relates "coffee machine" in the description to the switch device (capability.switch) recovered from the code.However, simply connecting an entity in the description to a device in the code is insufficient to determine whether only expected behaviors (as specified in the description) happen. 3) We use typed-dependency analysis and causal relationship model to correlate the policies generated from the description and program analysis.For example, in Figure 6, we have identified that "coffee machine" is an entity related to the phrase "turn on". For example, two IoT apps may both ask for access to a door lock, motion sensor on the door, and presence sensor. App functionality (66% strongly care and 24% care) and privacy (57% strongly care and 28% care) were the factors participants stated they cared about most in their decision.To understand participants' perspectives on smart home capabilities, we asked them to rate the sensitivity of different IoT device functions and to compare the sensitivity of SmartThings capabilities and Android/iOS permissions. These sharp distinctions highlight the importance of increasing the transparency to users about what precise behaviors an app will perform in the home, rather than considering all behaviors for a particular device monolithically. Because many users rely on app descriptions, rather than permissions screens, to evaluate smartphone apps [32], one way of reducing user burden is to assume that a user would implicitly grant an app the permission to perform actions stated in the app description. We define three indicator categories: verified behaviors that match the claimed functionality, unexpected behaviors that are not sensitive, and dangerous behaviors that are unexpected and risky. Once a user sets his or her policy settings through the user interface, we enforce the policy end-to-end by blocking unauthorized command and attribute access.Our proof-of-concept implementation of the policy enforcement mechanism operates locally on the device through the use of REST APIs, mimicking the ideal integration directly into the SmartThings Cloud. After the module processes the request, a return value is sent back to the patched app and handed to the code that invokes this command or attribute, which is transparent to the original app. We evaluate SmartAuth in several dimensions, finding SmartAuth is effective at automatically extracting security policies, significantly helps users avoid overprivileged apps, and adds minimal performance overhead when enforcing users' desired policies. We first evaluate SmartAuth's ability to accurately identify unexpected behaviors. In this process, we do not observe any false negatives, though we identify seven false positives (3.9%) in which SmartAuth flagged a behavior as unexpected though manual analysis of these cases suggests otherwise.In two of these cases, the app uses a product name to represent a device, but the product name is not relevant to its functionality; for example, the MINI HUE CONTROLLER app uses the Aeon Minimote 2 device. We first describe our user study to evaluate how SmartAuth impacted users' app-installation decisions, followed by additional data on the usability of SmartAuth itself.We performed a between-subjects user study with 100 participants recruited from across our institutions. For example, participants choose between "Lights Off with No Motion and Presence (by Bruce Adelsman)" that will "Turn lights off when no motion and presence is detected for a set period of time" and "Darken Behind Me (by Michael Struck)" that will "Turn your lights off after a period of no motion being observed. Note that for two of the tasks (A and B in Figure 7), the overprivilege was a potentially dangerous behavior (e.g., unlock a door), whereas the overprivilege for tasks C-E was potentially less risky (e.g., learn the temperature). Even when they still chose the overprivileged app, we found that many SmartAuth participants were aware of the overprivilege, yet said they either did not care about the unexpected behaviors or thought the app might benefit from these behaviors in the future.In addition to evaluating SmartAuth's impact on user behavior, we also measure the usability of SmartAuth itself. To evaluate the performance impact and ease of deployability for SmartAuth, we collected all 180 open-source SmartApps in the Samsung SmartThings marketplace at the time of research. In order to demonstrate that SmartAuth is both lightweight and backward compatible, we performed two performance tests: (1) pre-processing performance comprising program analysis, description analysis, behavior correlations, and policy description generation and (2) run-time performance comprising authorization interface generation and policy enforcement.For testing the pre-processing performance, we timed the generation of the policy description for each of the 180 apps, averaging over 10 trial runs. On a 3.1 Ghz Intel Core i7 CPU with 16 GB memory, the pre-processing overhead for an app is 10.42 seconds on average. We designed our experiments to test the technique in the worst-case scenarios. To enable large-scale testing without requiring the purchase of every physical SmartThings device, we used Samsung's online SmartApp simulator platform 3 . We trigger events at least five times and insert debug messages into the modified apps' source code to observe apps' behaviors while they gather data from the cloud or when events have been triggered. After scanning the source file, this app requests access to motionSensor, contactSensor, and alarm capabilities, satisfying the description, but also requests sensitive commands including turning on/off a switch, which is not mentioned in its description. Specifically, apps with coarse capability overprivilege and device-app binding overprivilege are also constrained to ensure least privilege.In our compatibility tests, none of the 180 apps crash after patching, even with overprivilege security rules enforced. Although SmartAuth advances user-centered IoT app authorization, our design has limitations. External services like IFTTT could be the future work for our project. We did observe in the lab study that most users payed attention to the app description, but it would be better to verify the assumption formally. In contrast, reasoning about implications in the IoT is much more context-sensitive, necessitating our further use of NLP. Almuhimedi et al. propose information visualization to improve user awareness of risks [3], Harbach et al. suggest using personal examples to better explain permission requests [28], and Tan et al. suggest using developer-specified explanations for understanding [52]. To enhance security and privacy goals in IoT and home automation systems, FlowFence [20] uses information flow control and explicitly isolates sensitive data inside sandboxes. However, in-context prompts cannot satisfy the real-time automation of IoT apps (e.g., users need to be awake to approve a permission when an emergency happens). Kim et al. study the challenges in access control management in smarthome and present usable access control policies [34,35]. A toy example for a patched app TURN IT ON FOR 5 MINUTES is given in Listing 2. The script builds an internal structure called DL, maintaining a pair of information (input label, device capability), for later code substitution for command or attribute statements.The script then parses event handler subscription and unsubscription statements by scanning the keywords. THE FLASHER is an app that claimed to flash a set of lights to notify user when motion, open/close event, or switch event is detected. We show the participants five group of apps in the SmartAuth and SmartThing interface, as shown in Table 1. In particular, we have two security experts and 100 Mturkers to look into the apps' unexpected behaviors and evaluate how sensitive the unexpected behavior is given the context of the app.