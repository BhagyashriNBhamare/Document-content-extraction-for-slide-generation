Software-based MMU emulation lies at the heart of out-of-VM live memory introspection, an important technique in the cloud setting that applications such as live forensics and intrusion detection depend on. The experiment results show that ImEE-based introspection enjoys a remarkable speed up, performing several hundred times faster than the legacy method. For instance, the VMI tool in the monitor VM extracts all running processes' identifiers in an untrusted guest VM by traversing the guest kernel's task struct list. Such an outof-VM introspection then faces the problem of replicating the guest's virtual address (VA) to host physical address (HPA) translation.Existing out-of-VM introspection systems [18,19,33,35] tackle the problem using a software-based address translation whereby the MMU's function is replaced by software. al [25], hardware-assisted monitor systems such as Copilot [30] and KI-mon [26] are circumvented by using address translation redirection attacks which deceive the monitor into using a faked mapping.In this paper, we propose a novel mechanism to allow the introspection code in the monitor VM to access a target guest kernel's virtual address space at native speed and with mapping consistency, despite the kernel-level attacks from the target. During a guest access, the ImEE's MMU walks the present paging structures same as the guest's, pointed to by the CR3 registers both in the ImEE and in the guest.We have implemented a prototype of the ImEE on Linux KVM. As compared to the existing software-based guest access method, the ImEE is several hundred times faster to traverse kernel objects. Hence, the ImEE is more attractive to applications desiring strong security, faster response and high speed, for instance, critical data monitoring, virtual machine scanning, and live forensics.CAVEAT. Given a virtual address X, the introspection code walks through all levels of the paging structures, including the Extended Page Tables (EPTs 1 ) in the memory to find out the corresponding HPA. The introspection program using LibVMI keeps reading a guest process's task->cred pointer, while a guest kernel thread periodically modifies the pointer and the new value stays for 20,000 CPU cycles before being restored. It is ill-suited for scenarios demanding quick responses such as live forensics and real-time I/O monitoring.The slow speed also affects the mapping consistency as the guest malware in the kernel may make transient changes to the page tables, rather than the data. Since walking the paging structures appears instant to the malware using the MMU, but not to the introspection software, the malware's attack on the page tables causes the VMI tool to use inconsistent information obtained from the paging structures.Caching techniques have been used in order to reduce the latency of guest accesses. Since the guest kernel is untrusted, the introspection cannot presume that all guest threads share the same kernel address space. To change the introspection target from one VM to another requires a new setup. The platform administrator runs VMI applications inside the monitor VM to introspect the live kernel states in the targets without modifying or suspending them.To avoid ambiguity, we use the "target" to refer to the virtual machine under introspection, and use "guest" with its hardware virtualization notion as in a "guest physical address" (GPA) which refers to the physical address a kernel uses inside a hardware-assisted virtual machine.Trust Model. Its goal is to stage a fake kernel address space view to the VMI application. Our idea is to create a special computing environment called Immersive Execution Environment (ImEE) with a twisted address mapping setting (as in Figure 1). The GPAs for the intended introspection are translated with the same mappings as in the target VM; the GPAs for the local usage (indicated by the dotted box in Figure 1) are mapped to the local physical pages via separated GPA-to-HPA mappings. The ImEE agent's virtual address space comprises of the executable code, data buffers to read and write, and the target kernel's address space. Since the agent code and data are logically different from the target kernel, we need a way to properly split the GPA domain so that VAs for the local uses are not mapped to the target and VAs for introspection are not mapped to the agent memory.This challenge to divide the GPA domain is further complicated by two issues. For example, it is difficult to detect whether a VA for introspection is wrongly mapped to the local data (which could be induced by the target kernel inadvertently or willfully) because it does not violate the access permissions on the page table.Security Challenge. Although access permissions can be enforced via the GPA-to-HPA translation, the adversary can still redirect the memory reference at one page to another with the same permissions.A more subtle, yet important issue, is that the introspection blind spot, namely the set of virtual addresses in the target which are not reachable by the ImEE agent. Note that it is time-consuming to find out all VAs in the blind spot, because the guest page tables have to be traversed to obtain the GPA corresponding to a suspicious VA. Although the ImEE agent accesses the target memory at native speed, we aim to minimize the time for setting it up in order to maximize its capability of quickly responding to real-time events and/or adapting to a new introspection target (e.g., another thread in the target VM or even another target VM). Like a normal VM, the ImEE hardware consists of a vCPU core and a segment of physical memory, both (de)allocated by the hypervisor when needed. To kick off a session, the hypervisor either induces a VM exit or intercepting CR3 changes in the target. Lastly, we describe the lifecycle of ImEE, focusing on the runtime issues such as transitions between sessions.The approach is to carefully concert system design, e.g., setting the ImEE's EPTs and software design (i.e. crafting the agent) so that the ImEE agent execution straddles between two virtual address spaces: one for the local usage and the other for accessing the target VM. To differentiate them from the target VM's physical memory, we name them as the ImEE frames.According to the CR3 content, the agent runs either in the local address space or the target address space, as depicted in Figure 4. Moreover, the GPAs of the ImEE frames are not within the GPA range the target VM uses, which avoids conflict mappings used in the target address space. table directory point to the same page table page which has one PTE points to the data frame and all other to the code frame.Target Address Space. Specifically, EPT T is populated with the GPA-to-HPA mappings from the target VM's EPT, except that all target frames are guarded by read-only and non-executable permissions. Namely, it cannot be read or written from the target address space.Note that the ImEE data frame is not mapped in the target address space for two reasons. The GPA-to-HPA mappings used in one address space are cached in the ImEE TLBs and are not automatically invalidated during switches. It is granted with Ring 0 privilege so that it has the privilege to read the target kernel memory and to manage its own system settings, such as updating the CR3 register. Since the data frame is out of the target address space, all needed introspection parameters (e.g., the destination VA and the number of bytes to read) are loaded into the general-purpose registers (Line 6). For the same reason, the agent loads the target memory data into the ImEE floating-point registers as a cache (Line 12), before switching to the local address space to write to the data frame (Line 17).1: while TRUE do poll the interface lock; until the lock is off 6:Read the request from the data frame to general-purpose registers; Set interface lock; 22: end while The agent is loaded at P c in the local address space by the hypervisor. When the agent runs in the target address space, the only VAs involved are for the instructions (P c ) and the target addresses (P t ). The same reasoning also applies to the cached mappings in the target address space.Note that the adversary gains no advantage from a TLB hit on a cached local address space translation. The EPT settings of the ImEE and of the target ensure that the adversary can only launch sidechannel attacks, which is beyond the scope of our study.The only attack vectors exposed by the ImEE to the adversary are the shared GPT and the target physical memory which are fully controlled by the adversary. Depending on the specific manipulation, either we can detect such attempts by the EPT violation triggered, or the attack does not adversely affect the introspection.Detecting Blind Spot. Nonetheless, our EPT C maps the agent code frame non-readable. In this case, the ImEE's MMU walks the target VM's GPT and fetches the data in the same way as in the target VM. The attack has no harm to the execution as it is equivalent to feeding poisonous contents to the VMI application, in the hope to exploit a programming vulnerability. This attack does not give the adversary any advantage over mapping P t to an inrange GPA whose physical frame stores the same contents prepared by the adversary. In other words, when the agent's target memory access encounters a missing GPA-to-HPA mapping, the hypervisor then copies the EPT page from the target's EPT. Based on the VMI application's request, the hypervisor launches the ImEE wherein the agent runs in the local address space with an arbitrarily chosen virtual address. If the agent is currently running in the target address space, its CR3 in the VMCS is immediately replaced. Since the agent code lies within one page, preserving the offset allows it to smoothly continue the interrupted execution.If the agent is in the local address space, the CR3 for the new target address space is saved in a register. From the exception, the hypervisor reads the faulting GPA, changes the corresponding EPT permissions, and restores the previous one to read-only. In this case, since the mapping inside ImEE is consistent with the one in the target VM, introspection on the swappedout page results in a page fault inside ImEE. We describe our prototype based on KVM and the introspection tools we implemented on top of our prototype. According to the commonly seen memory reading patterns, we have implemented three types of ImEE agents as listed in Table 2. Block-read 38 2Traversal-read 22 3Traversal-read-dereference 40 The interface between the VMI application and the ImEE agent are two fixed-size buffers residing on the agent's data frame and being mapped into the VMI application's space. For common introspection tasks that focus on kernel data structures, the development requires a selection of the agent type, and a set of memory reading parameters including the starting virtual address, the number of bytes to read, and the offset(s) used for traversal. • pidlist It lists all process identifiers in the guest.It traverses the task struct list pointed to by the kernel symbol init task, and records the PID value of every visited structure in the list. • credlist It lists all tasks' credential structures referenced by the task struct's cred pointer. Hence it takes more time than pidlist and pslist.Because of their different memory access patterns, they run with different types of agents. These tools are linked with a small wrapper code to interact with the ImEE-enabled KVM module via the customized ioctl handler. Lastly, we compare ImEE with LibVMI in a setting with multiple guest VMs.The hardware platform used to evaluate our implementation is a Dell OptiPlex 990 desktop computer with an Intel Core i7-2600 3.4GHz processor (supporting VTx) and 4GB DRAM. It takes a one-time cost of 97 µs to prepare the ImEE environment where the main tasks are to make a copy of the target guest EPT as EPT T , to set up GPT L and EPT L , and to allocate and setup the ImEE vCPU context. ImEE LibVMI Launch time 97 µs 100 ms Activation time 3.2 µs -Agent reloading time 6.5 µs - consistency with the target during a session, the hypervisor intercepts the CR3 updates. In total, it takes about 2000 CPU cycles which amounts 0.58 µs in our experiment platform. To understand this phenomena, we run experiments to measure the intervals between context switches. LibVMI has a large memory footprint as it uses up to 14MB to perform a system call table dump. To assess the efficiency of the ImEE's interface with the VMI application, we measure the turnaround time with the ImEE agent performing no task but returning immediately. The result is approximately 265 CPU cycles (or 77 ns) in our setting.To evaluate the memory-reading performance of the ImEE, we run experiments to evaluate the turnaround time with normal read requests. On KVM, The LibVMI based introspection is around 50 times slower than the ImEE with all caches and 300 times slower without cache. On Xen, LibVMI is around 15 times and 70 times slower, respectively. Secondly, it should also maintain swift response for introspection requests on VMs already launched.We compared the time taken for LibVMI and ImEE to perform a syscall table dump by our tool in two scenarios. The performance of LibVMI mainly due to the initialization needed for each newly encountered VM.Secondly, we measure the time taken for each solution for switching the introspection target among the four VMs that are already scanned. The experiment shows that it takes 19 ms for LibVMI to perform such work while 4.4 µs for ImEE. In contrast, ImEE only needs to fetch the current CR3 on the target VM's vCPU and replace the ImEE CR3, IP and the EPT root pointer of the ImEE vCPU. The ImEE serves as the guest access engine for the VMI applications without involving kernel semantics. If so, the code fetches the data from the guest memory by traversing the guest VM's page table in the same way as LibVMI. When a read redirection is generated by the XED library, the code simply issues a memory read request to the ImEE and waits for the reply. Since Process-Implant [23] and SYRINGE [14] rely on a trusted guest kernel, we compare the ImEE with SIM [34] from the perspective of accessing the target VM memory. In comparison, any update on the target VM page table takes immediate effect on the ImEE and CR3 consistency is ensured by the hypervisor.Performance and Usability. Both SIM and ImEE make native speed accesses to the memory without emulating the MMU. In fact, the ImEE performs better on a 64-bit platform, because there are more general purpose registers available, reducing the number of address space switches, and the PCID can be used to prevent the needed TLB entries from being flushed. Like the x86 platform, ARM multicore processors also feature a per-core MMU, thus each core's translation can be performed independently. The fundamental problem of VMI is to acquire the kernel's semantic by reconstructing the kernel objects. It can be based on expert knowledge (e.g., Memparser [12], GREPEXEC [13], Draugr [17], and others [2,4,5,6,8,9,22,32]) and automatic tools (e.g, SigGraph [28], KOP [15], and MAS [16]). SYRINGE [14] runs the VMI application in the monitor VM and allows the introspection code to call the guest kernel functions under a guest thread's context. To run the monitoring code inside the untrusted guest, it creates a SIM virtual address space isolated from the guest kernel. The execution trace is replayed in a trusted VM when performing introspection, whose data accesses are redirected to the guest VM's memory. A taint analysis runs in the monitor VM and relevant data accesses are redirected to the guest's live memory. In order to make the VMI code see the same mapping with the guest VM's kernel, the L4 entries of kernel addresses in its page table directly point to the L3 page entries existing in the guest VM's memory. ImEE's native access speed allows consistent memory view with that of the target VM.Since the hardware does not automatically maintain the consistency between the TLB entries and the PTEs in the memory, the target VM's adversary can leverage this hardware behavior to defeat introspection. Obviously, this method is intrusive as it changes the target states and may affect the execution of other target's threads involving the modified memory or mappings.A non-intrusive way is to run the agent in an external address space. It remains as a challenging problem to detect those entries.