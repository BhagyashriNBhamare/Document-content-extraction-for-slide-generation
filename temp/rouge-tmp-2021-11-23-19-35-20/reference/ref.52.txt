To solve these problems, we design TrustBase, an architecture that provides certificate-based authentication as an operating system service, with system administrator control over authentication policy. We describe a research prototype of TrustBase for Linux, which uses a loadable kernel module to intercept traffic in the socket layer, then consults a userspace policy engine to evaluate certificate validity using a variety of plugins. This is caused by failure to use validation functions, incorrect usage of libraries, and also developers who disable validation during development and forget to enable it upon release. This weakness was exploited in the 2011 DigiNotar hack [25], and is exacerbated by CAs that do not follow best practices [31,10] and by governmental ownership and access to CAs [13,40]. Due to these problems, there are a number of recent proposals to improve or replace the current CA trust model. Several projects have tried to address these issues, fixing broken authentication in existing applications, while providing a means to deploy improved authentication services. Fahl takes a different approach that rewrites the library used for authentication by Android applications [18], while also including pluggable authentication modules. TrustBase provides universal coverage of existing applications, supports both direct and opportunistic TLS 1 , is hardened against unprivileged local adversaries, is supported on both mobile and desktop operating systems, and has negligible overhead.To centralize authentication as an operating system service, TrustBase uses a combination of traffic interception to harden certificate validation for existing applications and a validation API to simplify authentication for new or modified applications. An OS vendor could ship TrustBase with strong default protections against broken applications, such as enforcing best practices for validating a certificate chain, requiring hostname validation, and pinning certificates for the most popular web sites and applications. All of these improvements can be made without requiring user interaction or configuration.Our contributions include:• An architecture for certificate validation that prioritizes operating system centralization and system administrator control: TrustBase offers standard certificate validation procedures and optionally adds additional authentication services, both of which are enforced by the operating system and controlled by the administrator or OS vendor. Fahl et al. proposed a new framework for Android applications that would help developers correctly use TLS [18]. Fahl's approach is well-suited to mobile operating systems such as Android, where all applications are written in Java, but it is difficult to extend this approach to operating systems that provide more general programming language support.Another Android system, MITHYS, was developed to protect Android applications from MITM attacks [6]. For example, applications using custom or unsupported security libraries (e.g., BoringSSL, NSS, MatrixSSL, morerecent GnuTLS, etc.), applications statically linked with any security library, and applications spawned without being passed CertShim's path in the LD PRELOAD environment variable (e.g., spawned by execv or spawned by a user without that environment setting) will not have their certificates validated by CertShim. TrustBase ensures that only system administrators can load, unload, bypass, or modify its functionality, so that every secure application is subject to its configured policies. TrustBase protects against this case by using a protected Netlink protocol, privileged policy engine, protected files, and kernel module that cannot be removed by a nonprivileged user. In this section, we discuss the threat model, design goals, and architecture of the system. • The attacker or malware managed to place a rogue certificate authority into the user's root store (or another trust store used by the application) so that he has become a trusted certificate authority. In addition, we consider only certificates from TLS connections directly made from the local system to a designated host, and not those that may be present in streams higher up in the OSI stack or indirectly from other hosts or proxies via protocols like onion routing. TrustBase should provide simple deployment of authentication services that strengthen the validation provided by the CA system. All incoming certificates should be validated by TrustBase, including those provided to both existing applications and future applications. If a developer is willing to modify her application to call TrustBase directly for certificate validation, then she can use the validation API. Administrators can con-figure TrustBase to not intercept traffic from applications using this API. The handler will allow or abort the connection, based on the policy engine's response.TrustBase currently has both a TLS handler and an opportunistic TLS handler (e.g., STARTTLS), and due to the design of the traffic interceptor it is easy to add support for new secure transport protocols as they become popular (e.g., QUIC, DTLS). Abstain and error responses are mapped to the valid or invalid responses, as defined in a configuration file.To render a decision, the policy engine classifies plugins as either "necessary" or "voting", as defined in the configuration file. We provide both an asynchronous plugin API and a synchronous plugin API to facilitate the needs of different designs.The synchronous plugin API is intended for use by simple authentication methodologies. The certificate chain is provided to the plugin DER encoded and in openssl's STACK OF(X509) format for convenience. The query function returns the result of the plugin's validation of the query data (valid, invalid, abstain, or error) back to the policy engine.The asynchronous plugin API allows for easier integration with more advanced designs, such as multithreaded and event-driven architectures. Applications can use the API to validate certificates or request pinning for a self-signed certificate. The API also allows the application to receive validation error messages from TrustBase, allowing it to display errors directly in the application (TrustBase displays notifications through the operating system). Second, in some cases a system administrator may want to distrust the CA system entirely and rely solely on alternative authentication services. For example, the administrator may want to force applications currently using CA validation to accept self-signed certificates that have been validated using a notary system such as Convergence [31], or she may want to use DANE [21] with trust anchors that differ from those shipped with the system. We also have a working prototype of TrustBase for Windows, which uses the Windows Filtering Platform API.Mac OSX provides a native interface for traffic interception between the TCP and socket levels of the operating system. The App Proxy Provider API allows developers to create a custom transparent proxy that captures application network data. Also available is the Filter Data Provider API that allows examination of network data with built-in "pass/block" functionality.Because Android uses a variant of the Linux kernel, we believe our Linux implementation could be ported to Android with relative ease. When the TrustBase LKM is loaded, it hooks into the native TCP kernel functions whose pointers are stored in the global kernel structures tcp prot (for IPv4) and tcpv6 prot (for IPv6). When a user program invokes a system call to create a socket, the function pointers within the corresponding protocol structure are copied into the newly-created kernel socket structure, allowing different protocols (TCP, UDP, TCP over IPv6, etc.) to be invoked by the same common socket API. Note that within the kernel, all socket-reading system calls (read, recv, recvmsg, and recvmmsg) eventually call the recvmsg function provided by the protocol structure. First, a call to connect informs the handler that a new connection has been created, and the handler can choose to intercept its traffic.Second, when an application makes a system call to send data on the socket, the interceptor checks with the handler to determine if it is tracking that connection. The interceptor then queries the handler for the return values it wishes to report to the application (such as how many bytes were successfully sent or an error value) and these values are returned to the application.Third, a similar, reversed process is followed for the reception of data from the network. As another example, if a handler wishes to append data to a message successfully transferred to the OS by an application using the send system call, it should enforce that the return value of this function be the number of bytes the application expects to have been sent, rather than a higher number that includes the added bytes.Finally, a call to close (on the last remaining socket descriptor for a connection) or shutdown informs the handler that the connection is closed. Note that the handler may also choose to abandon tracking of connections before this point.Handlers for various network observation and modification can be constructed by implementing a small number of functions, which will be invoked by the traffic interceptor at runtime. This could be done either by implementing significant portions of TCP, in- cluding out-of-order handling and associated buffers, or passing traffic through the network stack twice, once to parse the IP packets for TrustBase and once for forwarding the traffic to the application. If SNI is not used, a log of applications' DNS lookups can be used to infer the intended host, 4 similar to work by Bates et al. [4] When data is received on the socket, the TLS handler waits until it has received the full certificate chain, then it sends this chain and other data to the policy engine for parsing and validation.Note, the TLS handler understands the TLS record and handshake protocols but does not perform interpretations of contained data. This minimizes additions to kernellevel code and allows ASN.1 and other parsing to be done in userspace by the policy engine. However, in addition to the plugin API, TrustBase supports an addon API that allows plugins to be written in additional languages. Addons provide the code needed to interface between the native C of the policy engine and the target language it supports. The TrustBase architecture, prototype implementation, and sample plugins have many implications for system security. Applications that utilize their own custom TCP/IP stack must utilize raw sockets, which require administrator privileges and are therefore implicitly trusted by TrustBase.To obtain complete coverage of TLS, our handlers need only monitor initial TLS handshakes (standard TLS) and the brief data preceding them (STARTTLS). For each, we verified our solution utilizing an "attacker" machine acting as a MITM using sslsplit [38], and a target "victim" machine running TrustBase. • Hacked or coerced certificate authorities: Attackers who have received a valid certificate through coercion, deception, or compromise of CAs are able to subvert even proper CA validation. For example, the OSCP plugin can be used to check certificates received by the Chrome browser, which does not do this natively. TrustBase mitigates this attack by an option to enforce START-TLS use. Third, plugins can only be installed and configured by an administrator, which prohibits unprivileged adversaries and malware from installing malicious authentication services. The protocol definition takes advantage of the Generic Netlink flag GENL ADMIN PERM, which enforces that selected operations associated with the custom protocol can only be invoked by processes that have administrative privileges for networking (the capability mapped to CAP NET ADMIN in Linux systems). (3) The policy engine runs as a nonroot, CAP NET ADMIN process that can be invoked only by a privileged user. This protects against weakening of the configuration, disabling of plugins, shutting down or replacing the policy engine, or enabling of bogus plugins.TrustBase stops traffic interception for a given flow as soon as it is identified as a non-TLS connection. We evaluated the prototype of TrustBase to measure its performance, ensure compatibility with applications, and test its utility for deploying authentication services that can harden certificate validation. We tested TrustBase with two plugins, CA Validation and Certificate Pinning (see Section 6.5). The target host for these connections was a computer on the same local network as the client machine, to reduce the effect of latency and network noise. This is also expected, as the brevity of TLS handling code, its place in the kernel, the use of efficient Netlink transport and other design choices were made with performance in mind.Our experimentation with varying file sizes also exhibited no difference between native and TrustBase cases. (3) In the case where validation with TrustBase fails, but the application would have allowed the connection to proceed, the policy engine blocks the connection by forwarding an intentionally invalid certificate to the application, which triggers any SSL application validation errors an application supports, and then subsequently terminates the connection.We tested TrustBase with 34 popular applications and libraries and tools, shown in Table 1. For each library tested, and where applicable, we created sample applications that performed no validation and improper validation (bad checking of signatures, hostnames, and validity dates). Source code can be found at owntrust.org.Our Android implementation uses the VPNService so that it can be installed on an unaltered OS and without root permissions. Source code can be found at owntrust.org.The traffic interceptor component of TrustBase on Windows is implemented utilizing the native Windows Filtering Platform (WFP) API, acting as a kernel-mode driver. Reliance on the WFP reduced the code necessary to provide traffic interception capabilities and also made them easy to maintain, given that the Windows kernel code is not open source. The policy engine is patterned after its Linux counterpart, supports both Python and C plugins, and uses native Windows libraries where possible (e.g., Microsoft's CryptoAPI and native threading APIs). Finally, our cipher suite auditor service allows system administrators to pre- Enforces standard certificate validation using openssl functions and standard practices for validating hostnames, Basic Constraints, dates, etc. Checks Google's CRLSet to determine whether the certificate has been blocked, extending Chrome's protection to all apps. Based on ideas presented by Perspectives [41] and Convergence [31], it connects securely to one or more notary servers to validate the certificate received by the client is the same one that is seen by the notaries. TrustBase explores the benefits and drawbacks of providing authentication as an operating system service and giving administrators control over how all authentication decisions on their machines are made. These issues are caused by applications dictating the security of the machine's connections, using their own (or third party) security features and keys, reducing operating system and administrator control. By creating a socket using a new IPPROTO TLS parameter (as opposed to IPPROTO TCP), developers can use the bind, connect, send, recv, and other socket API calls with which thy are already familiar, focusing solely on application data and letting the OS handle all TLS functionality. Following these two principles, we designed the TrustBase architecture for certificate authentication, meeting our design goals of securing existing applications, strengthening the CA system, providing full application coverage, enabling universal deployment, and imposing negligible overhead.