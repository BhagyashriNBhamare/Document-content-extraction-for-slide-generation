Built atop a virtualization monitor we designed, Digtool successfully captures various dynamic behaviors of kernel execution, such as kernel object allocation, kernel memory access, thread scheduling, and function invoking. For instance, improper use of parameters or memory data can lead to program bugs, some of which can become vulnerabilities, such as time-of-check-to-time-of-use (TOCTTOU), use-afterfree (UAF), and out-of-bounds (OOB) vulnerabilities. While we could have also investigated path exploration, the main focus of Digtool is vulnerability detection.Depending on the detection targets, vulnerability identification tools can be classified into two categories: (1) tools for checking applications in user mode, and (2) tools for detecting programs in kernel mode. Thus, there is still a need for effective detection of kernel vulnerabilities.Several Linux kernel vulnerability identification tools, such as Kmemcheck [32], Kmemleak [6], and KEDR [35], have been developed. However, since they rely on the implementation details and the source code of the OS, it is difficult to port these tools to other OSes, especially to a closed-source OS such as Windows.In Windows OS, a notable tool for checking kernel vulnerabilities is Driver Verifier [28], which is used to detect illegal function calls or actions that might corrupt the system. Under these constraints, we adopt virtualization to hide the internal details of the Windows OS, and carry out the detection at a lower level, i.e., at the hypervisor. In short, we make the following contributions in this paper:• A virtualization-based vulnerability identification framework, Digtool, is proposed to detect different types of kernel-level vulnerabilities in the Windows OS. • Based on the framework, virtualization-based detection algorithms are designed to discover four types of vulnerabilities, including UNPROBE (no probe, i.e., no checking on the user pointer to the input buffer), TOCTTOU, UAF, and OOB. UNPROBE, TOCTTOU, UAF, and OOB vulnerabilities have widely appeared in various programs including OS kernels. According to the historical data of common vulnerabilities and exposures (CVEs), there have been many UNPROBE vulnerabilities in the Windows kernels, and there are also many such vulnerabilities in third-party drivers (e.g., the vulnerabilities in the experiment described herein). Therefore, detection of UNPROBE is necessary. While fuzzing based on path exploration can help solve some problems, it is difficult to test all pointer arguments nested in complicated structures.A TOCTTOU vulnerability stems from fetching a value from user memory more than once. Digtool adopts virtualization technology to detect the above four types of vulnerabilities in Windows kernels and device drivers with better detection results. As a framework, it could also be used to detect some other types of vulnerabilities, such as double-free and information leakage, by expanding its detection algorithms. The subsystems and logic modules of the Digtool are distributed across user space, kernel space, and the hypervisor. Without source code, we cannot monitor memory access through patching source code like Driver Verifier [28], or through configuring compile-time instrumentation like AddressSanitizer [36]. As an alternative, QEMU [11] or the recent extension PEMU [42] could be used to implement kernel program instrumentation for the Windows OS, but it is complicated and has a heavier effect on performance even without monitoring memory access.Therefore, there is a clear need to develop an efficient alternative mechanism for tracing memory access outside a guest OS. In order to build a practical framework that focuses on the virtual address space, a shadow page table (SPT) based on hardware virtualization technology is employed to monitor virtual memory access, which is very different from Xenpwn and Bochspwn in both design and implementation.In kernel space, the major work includes setting the monitored memory area, communicating with the hypervisor, and intercepting specified kernel functions. Digtool does not rely on any current hypervisor such as Xen or KVM, and we implemented our own hypervisor that contains three important components, including VMM infrastructure (VMM, i.e., virtual machine monitor, which is equivalent to a hypervisor), interface detection, and memory detection.To begin with, VMM infrastructure checks the hardware environment and the OS version to ensure compatibility. The initialization of the hypervisor mainly consists of the following tasks: (1) building SPTs to monitor virtual memory access in the guest OS, (2) initializing modules for tracing thread scheduling, and (3) establishing communication between the OS kernel and the hypervisor. The SPTs are needed to monitor the user memory space during the system-call execution. To detect some specified types of vulnerabilities in different detection targets (e.g., the multi-user Win32 driver: Win32k), memory detection is able to set monitored memory area and configure detection targets. Then, the middleware transfers the configuration information and the fuzzer process information from the loader to the hypervisor. Thus, the hypervisor can detect vulnerabilities in the environment of the fuzzer process.For interface detection, the middleware records all behavior events in log files through a work thread. The loader is used for loading the target process, after which Digtool provides a process environment for detecting vulnerabilities. The loader can also limit the detection scope of system calls and set the virtual addresses of the boundary for ProbeAccess events (which will be described in Section 4.2) through the configuration file.The fuzzer is responsible for discovering code branches. The log analyzer's vulnerability detection algorithm needs to be changed depending on the types of vulnerabilities (e.g., UNPROBE or TOCTTOU) to be detected, since we use different policy to detect them. The main task of VMM infrastructure is to initialize the hypervisor and provide some basic facilities. Finally, it sets the state of guest CPUs according to the state of the original OS. These modules include the virtual page monitor, thread scheduling monitor, CPU emulator, communication between kernel and hypervisor, and the events monitor. If a bit is set to 1, the corresponding page needs to be monitored, and the P flag in its page table entry (PTE) of the SPT should be clear [note that the SPT is constructed according to the guest page table (GPT)]. Thus, access to the monitored virtual page will trigger a #PF (i.e., page fault) exception that will be captured by the hypervisor.When the #PF exception is captured, the page-fault handler in the hypervisor will search for the BitMap. The private interrupt handler stores some information (e.g., the memory address that is accessed, and the instruction that causes the #PF) about the #PF exception, and then it connects to a debug tool by triggering another exception, such as software interruption, in the guest OS. Thus, the handler of MTF or TF in the hypervisor has a chance to clear the P flag, and the page will be monitored once again. It needs to trace thread scheduling to enable detection for monitored threads and disable detection for non-monitored threads. The KPRCB is referenced by the KPCR structure whose address can be obtained through the FS register (for x64 architecture, the GS register). If the new thread is a monitored thread, the virtual page monitor will be activated to detect vulnerabilities. One is that the kernel component makes a request to the hypervisor, and the hypervisor provides service. It also records characteristic information into log files.The following stream of instructions is shown by the thin arrows in Figure 3: (1) When the target module (which is being detected) triggers an event monitored by the hypervisor, a VMEXIT will be captured by the hypervisor. The code will notify the work thread to handle the data in shared memory (i.e., read them from shared memory and write them into log files). (3) After notifying the work thread, the injected code will return to the target module and re-execute the instruction that causes the VMEXIT. These behavior events and their interception methods make up the events monitor.Ten types of behavior events are defined in the event monitor: Syscall, Trap2b, Trap2e, RetUser, MemAccess, ProbeAccess, ProbeRead, ProbeWrite, GetPebTeb, and AllocVirtualMemory events. The M i and M j under the boxes represent the user memory addresses accessed by the event.In the Windows OS, fast system call, interruption of 0x2b, and interruption of 0x2e are the three entry points that allow user-mode code to invoke kernel functions. In Digtool, the three entry points are traced by intercepting corresponding entries in the interrupt descriptor table (IDT) or MSR register. It is noticed that, the user-mode pages are monitored only if the processor runs in kernel mode, and this will significantly reduce the performance cost.To improve the efficiency of discovering and analyzing vulnerabilities, interface detection also defines and intercepts some other behavior events, including ProbeAccess, ProbeRead, ProbeWrite, GetPebTeb, and AllocVirtualMemory. For example, kernel code sometimes accesses a user memory region returned by a PsGetProcessPeb function or allocated by a NtAllocateVirtualMemory function during a system call. These events inform the log analyzer that the access to user memory is legal and that no bug exists.In addition to invoking the ProbeForRead (i.e., ProbeRead event) or ProbeForWrite (i.e., ProbeWrite event) function, kernel code can also adopt direct comparison to check the legitimacy of the user memory address; for example, "cmp esi, dword ptr [nt!MmUserProbeAddress (83fa271c)]" where the esi register stores the user memory address to be checked, and the exported variable nt!MmUserProbeAddress stores the boundary of the user memory space. We cannot intercept it by hooking a kernel function as this event is not handled by any kernel function. The address of target memory can be set by the configuration file of the loader, and then the hypervisor obtains the target memory through the middleware and monitor the memory access through DR registers. Since the debug exception is a trap event, the start address for the CPU emulator is the instruction directly before the guest EIP register.As the ProbeAccess event adopts direct comparison to check pointer parameters for a system call, the CPU emulator should focus on cmp instructions when it interprets and executes the code of the guest OS. After finishing N cmp instructions or a fixed number of instructions, the hypervisor will stop interpreting and executing, and return to the guest OS to continue executing the following instructions. If there is no such type of checking event before a MemAccess event, there may be an UN-PROBE vulnerability in the kernel code.To detect an UNPROBE vulnerability, we focus on whether there is a checking event before a MemAccess event, and whether the virtual addresses in the two events are the same. We therefore propose the use of CPU emulator to detect UNPROBE vulnerabilities.Take Figure 4 as an example, at the event time of "n + 3", the kernel code triggers a MemAccess event by accessing user memory. In contrast, if there is a ProbeAccess/ProbeRead/ProbeWrite event or GetPebTeb/AllocVirtualMemory event to suggest that the user address is legal, and the event is trig-gered in the same system call as the MemAccess event, the code is safe.To detect an UNPROBE vulnerability, the fuzzer invokes the test system calls and tries to discover as many branches as possible by adjusting their parameters. The other is that the systemcall handler fetches the parameter from user memory more than once. Memory-footprint-based detection is used to detect illegal use of kernel memory by tracing the behavior of memory allocation, release, and access. Thus, the exact context of kernel execution can be provided for the vulnerability detection.In order to obtain more relevant data and reduce performance overhead, the monitored memory pages can be restricted. The middleware helps to limit the scope of monitored pages, and passes the scope to the memory detection by invoking our exported service interfaces of Digtool. These functions are used to allocate or free kernel memory in the guest OS. As the size of freed memory cannot be directly obtained through the arguments of the free functions, Digtool records the memory address and the memory size via the parameters of allocation functions. To detect it, memory detection needs to trace the freed memory pages until they are allocated again. Digtool hooks the corresponding functions, including InterlockedPushEntrySList and InterlockedPopEntrySList, to monitor the freed memory blocks in the lookaside lists.Any instruction operating on the freed memory (or blocks) is regarded as the "use" instruction of a UAF vulnerability. An OOB vulnerability can be caused by accessing memory that is beyond the bounds of allocated heaps. Any access to the unallocated memory areas will prompt an OOB vulnerability.Digtool calibrates the unallocated memory areas through the help of the middleware. Thus, when a monitored page (not a memory area) is accessed (note that the monitoring granularity of memory virtualization is a page, but the size of a memory area may be less than a page; the monitored pages are recorded via the BitMap, while the monitored memory areas are stored in the AVL tree.) If no related node is found, an OOB vulnerability may exist.Note that, as unallocated memory contains freed memory in the detection, an "OOB" may be caused by accessing a freed memory area. Thus, instead of block B, the brittle program will access the extra memory area, and an OOB vulnerability will be then captured by Digtool. Taking a vulnerability in Avast 11.2.2262 as an example, through the log analyzer, the following data were obtained from the Digtool's log file for Avast 11.2.2262: N t A l l o c a t e V i r t u a l M e m o r y : Eip : 89993 f3d , Address : 0023 f304 , rw : R Eip : 84082 ed9 , Address : 0023 f304 , PROBE ! For security reasons, we only give the system calls for which vulnerabilities exist.When the log analyzer points out a potential UN-PROBE vulnerability, and the tested driver only uses the ProbeForRead and ProbeForWrite functions to check a user pointer (this is a common scenario in third-party drivers), no human effort is needed for further confirmation as the detection is precise due to the facts that the start address and length information of the input buffer can be obtained through the corresponding kernel function. Taking a vulnerability in Dr. Web 11.0 as an example, through the log analyzer the following dynamic characteristics were distilled from Digtool's log file for Dr. Web 11.0:N tC re at e Se ct io n : Count :3 ======= ======= Eip : 83 f0907f Address :3 b963c Sequence :398 rw : R Eip : 89370 d54 Address :3 b963c Sequence :399 rw : R Eip : 89370 d7b Address :3 b963c Sequence :401 rw : R K i F a s t S y s t e m C a l l R e tThe user address 0x3b963c was accessed by the kernel instructions more than once, so there may be a TOCT-TOU vulnerability. Instead of logging, the middleware was set to interrupt the guest OS and connect to Windbg when a program error was captured. The following content is shown by Windbg when the UAF vulnerability (MS16-123/CVE-2016-7211 [3]) is captured in win32kfull.sys; this vulnerability was first discovered through Digtool:Single step exception -code 80000004 win32k ! Taking MS16-090/CVE-2016-3252 as an example to illustrate the detection result, the following content was shown when the vulnerability was captured in win32kbase:Single step exception -code 80000004 win32kbase ! RGNMEMOBJ :: bFastFill +0 x385 : 93e34bf9 895304 mov dword ptr [ ebx +4] , edx This is similar to the content of the above UAF, and 0x93e34bf9 is the address of the next instruction to be executed. The performance cost is shown in Figure 6 (the result may be affected by some factors, such as the parameters of system calls and the WinRAR input file). "Unrecorded" means that the system calls are not included in the configuration file, and thus no page is monitored and no log is recorded for them. Next, we illustrate Digtool's advantages by comparison with Driver Verifier [28], which is a notable tool for checking Windows kernels.Crash resilient. As the analysis process only requires the recorded data containing accessed memory address, event type, and event time, there is no need for triggering a BSOD to locate a program error. Without a BSOD, it keeps recording, which will help find more vulnerabilities. For example, when we test Avast with Driver Verifier, the cause of a BSOD is always the same:Arg1 : f6 , Referencing user handle as KernelMode . Much more human effort is needed to locate the error.Taking MS16-090/CVE-2016-3252 [2] as an example, Digtool exactly locates the instruction (just before 0x93e34bf9) that causes the vulnerability: However, from Driver Verifier, the captured context is as follows: Driver Verifier only points out a "bad pool" (OOB) error, but does not provide an exact context for the vulnerability. The above UAF vulnerability (MS16-123/CVE-2016-7211) discovered by Digtool is an example. However, the vulnerability can be captured by Digtool due to the fact that it delays the release of freed memory. Thus, Digtool is more powerful in this regard.To summarize, Digtool discovers 45 zero-day kernel vulnerabilities, and effectively detects the four types of program errors: UNPROBE, TOCTTOU, UAF, and OOB. The main work of supporting various platforms (e.g., MacOS) is adapting the middleware.Third, there is still room for extension in the detection algorithms. As it can almost monitor any memory page, it could be used to detect some other types of vulnerabilities, such as race conditions, by extending the detection algorithms. Grosso et al. [19] also presented a method of detecting buffer overflows for C code that does not need human intervention to define and tune genetic algorithm weights, and therefore it becomes completely automated.Static analysis achieves a high rate of code coverage, but its precision may be insufficient when dealing with difficult language constructs and concepts. Compared to other methods, it can detect errors not only in heaps, but also in stacks and global variables.Source instrumentation has higher precision, but its code coverage may be less comprehensive than static analysis. Dr. Memory [14] is a memory-checking tool that operates on applications under both Windows and Linux environments.These tools do not rely on source code, and exhibit an ability to effectively detect program errors. Kmemcheck [32] and Kmemleak [6] are memory-checking tools for the Linux kernel. Driver Verifier is an integrated system for detecting illegal actions that might corrupt the OS, but not a dedicated tool for detecting vulnerabilities (see Section 5.3 for a discussion of Driver Verifier's ability to detect vulnerabilities). Moreover, the implementation details for some of them are not exhaustive, and the detection effects have not been illustrated through detection of vulnerabilities in the real world. It can detect different types of kernel vulnerabilities including UNPROBE, TOCTTOU, UAF, and OOB in the Windows OS.