We further developed a static analysis, based on the Coccinelle matching engine, that detects double-fetch situations which can cause kernel vulnerabilities. When applied to the Linux, FreeBSD, and Android kernels, our approach found six previously unknown double-fetch bugs, four of them in drivers, three of which are exploitable double-fetch vul-nerabilities. Serna [32] was the first to use the term "double fetch" to describe a Windows kernel vulnerability due to a race condition in which the kernel fetches the same user space data twice. A double-fetch bug occurs when the kernel reads and uses the same value that resides in the user space twice (expecting it to be identical both times), while a concurrently running user thread can modify the value in the time window between the two kernel reads. Double-fetch bugs introduce data inconsistencies in the kernel code, leading to exploitable vulnerabilities such as buffer overflows [1,32,14,37]. Thus, auditing kernels, in particular drivers, for doublefetch vulnerabilities has become urgent.Device drivers are critical kernel-level programs that bridge hardware and software by providing interfaces between the operating system and the devices attached to the system. Drivers are a large part of current operat-ing systems, e.g., 44% of the Linux 4.5 source files belong to drivers. Therefore, we developed a static pattern-based approach to identify double fetches in the Linux kernel, including the complete space of drivers. We therefore refined the static pattern-based approach to detect actual double-fetch bugs and vulnerabilities, and analyzed Linux, Android and FreeBSD with it.We found that most of the double fetches in Linux 4.5 occur in drivers (57/90) and so do most of the identified double-fetch bugs (4/5). We categorize the identified double fetches into three typical scenarios (type selection, size checking, shallow copy) in which double fetches are prone to occur, and illustrate each scenario with a detailed double fetch case analysis. Moreover, all four driver-related double-fetch bugs belong to the same size checking scenario. One double-fetch vulnerability has been found in the Android 6.0.1 kernel, which was already fixed in newer Linux kernels. Based on our study, we propose five solutions to anticipate double-fetch bugs and we implemented one of the strategies in a tool that automatically patches double-fetch bugs.The rest of the paper is organized as follows: Section 2 presents relevant background on memory access in Linux, specifically in Linux drivers, and on how doublefetch bugs occur. Section 3 introduces our approach to double fetch detection, including our analysis process, the categorization of the identified double fetches into three scenarios, and what we learned from the identified double-fetch bugs. In Linux and FreeBSD, functions are provided to safely transfer data between kernel space and user space which we call transfer functions. For instance, Linux has four often used transfer functions, copy_from_user(), copy_to_user(), get_user(), and put_user(), that copy single values or an arbitrary amount of data to and from user space in a safe way. Finally, drivers often have to copy messages of variable type or variable length from the user space to the hardware, and, as we will see later, this often leads to double-fetch situations that cause vulnerabilities.In Linux, all devices have a file representation which can be accessed from user space to interact with the hardware's driver. As illustrated in Figure 1, the kernel function fetches a value twice from the same memory location in the user space, the first time to check and verify it and the second time to use it (note that the events are on a timeline from left to right, but the user data is the same object all the time). Then, when the kernel function fetches the value a second time to use, it gets a different value, which will not only result in a different computation outcome, but may cause a buffer overflow, a null-pointer crash or even worse consequences.To avoid confusion, we use the term double fetch or double-fetch situation in this paper to represent all the situations in which the kernel fetches the same user data more than once, and a so-called double fetch can be further divided into the following cases:Benign double fetch: A benign double fetch is a case that will not cause harm, owing to additional protection schemes or because the double-fetched value is not used twice (details will be discussed in Section 5.3). Harmful double fetch: A harmful double fetch or a double-fetch bug is a double fetch that could actually cause failures in the kernel in specific situations, e.g., a race condition that could be triggered by a user process.Double-fetch vulnerability: A double-fetch bug can also turn into a double-fetch vulnerability once the consequence caused by the race condition is exploitable, such 140 as through a buffer overflow, causing privilege escalation, information leakage or kernel crash.In this paper, we investigate both harmful double fetches and benign double fetches. Unfortunately, none of the existing data race detection approaches (whether static or dynamic) can be applied to double-fetch bug detection directly, for the following reasons:(1) A double-fetch bug is caused by a race condition between kernel and user space, which is different from a common data race because the race condition is separated by the kernel and user space. Moreover, the double-fetch bug exists if there is a possibility that the kernel fetches and uses the same memory location twice, as a malicious user process can specifically be designed to write between the first and second fetch. In Linux, fetching data from user space to kernel space relies on the specific parameters passed to transfer functions (e.g., copy_from_user() and get_user()) rather than dereferencing the user pointer directly, which means the regular data race detection approaches based on pointer dereference are not applicable anymore. As shown in Figure 3, a double-fetch bug in Linux requires a first fetch that copies the data, usually followed by a first check or use of the copied data, then a second fetch that copies the same data again, and a second use of the same data. Coccinelle was initially targeted for collateral evolution in Linux drivers, but now is widely used for finding and fixing bugs in systems code.Coccinelle's strategy for traversing control-flow graphs is based on temporal logic CTL (Computational Tree Logic) [3], and the pattern matching implemented on Coccinelle is path-sensitive, which achieves better code coverage. Moreover, the patternbased analysis is applied directly to the source code, therefore operations that are defined as macros, such as get_user() or __get_user(), will not be expanded during the matching, which facilitates the detection of double fetches based on the identification of transfer functions. As shown in Figure 4, we implemented the basic pattern matching in the Coccinelle engine.Our approach examines all source code files of the Linux kernel and checks whether a kernel function contains two or more invocations of transfer functions that fetch data from the same user pointer. We manually analyzed the matched kernel functions to infer knowledge on the characteristics of double fetches, i.e., how the user data is transferred to and used in the kernel, which helped us to carry out a categorization of double-fetch situations, as we discuss in Section 3.2. All these cases are false positives caused by the basic pattern matching, and 226 cases of our initial reports were identified as false positives, which have been automatically removed in our refined phase since they are not considered as double-fetch situations and cannot cause a double-fetch bug because every single piece of the message is only fetched once.The first phase of our study concentrates on the understanding of the contexts in which double fetches are prone to happen, rather than on exhaustively finding potential double-fetch bugs. As we manually inspected the double fetch candidates, we noticed that there are three common scenarios in which double fetches are prone to happen, which we categorized as type selection, size checking and shallow copy. The double-fetch situation turns into a double-fetch bug when the size or type information from the second fetch is used as the user may have changed the size or type information between the two fetches. If, for example, the size information is used to control buffer access, the double-fetch bug turns into a vulnerability.The double-fetch situations where a message header is copied twice could easily be avoided by only copying the message body in the second fetch and then joining the header with the body. We have observed that it is very common in the Linux kernel that one single function in a driver is designed to handle multiple types of messages by using a switch statement structure, in which each particular message type is fetched and then processed. Figure 6 shows an example of a double-fetch situation due to type selection in the file cxgb3_main.c, part of a network driver. The message header is copied to the kernel first to get the message size (first fetch), check it for validity, and Figure 6: A Double-Fetch Situation Belonging to the Type Selection Category in cxgb3 main.c allocate a local buffer of the necessary size, then a second fetch follows to copy the whole message, which also includes the header, into the allocated buffer. However, if the size is retrieved from the header of the second fetch and used, the kernel becomes vulnerable as a malicious user could have changed the size element of the header.One such double-fetch bug (CVE-2016-6480) was found in file commctrl.c in the Adaptec RAID controller driver of the Linux 4.5. The function also uses the size element of the header a second time in line 130, causing a double-fetch vulnerability as a malicious user could have changed the Size field of the header between the two fetches.We observed 30 occurrences of such size checking double-fetch situations, 22 of which occur in drivers, and four of them (all in drivers) are vulnerable. A shallow copy between user and kernel space happens when a buffer (the first buffer) in the user space is copied to the kernel space, and the buffer contains a pointer to another 55 Figure 8: A Double-Fetch Bug in sclp ctl.c (CVE- 2016-6130) buffer in user space (the second buffer). We observed 31 of such situations, 19 of them in drivers.The complexity of performing a deep copy with transfer functions that only do shallow copies can cause programmers to introduce bugs, and we found one such bug in file sclp_ctl.c of the IBM S/390 SCLP console driver, where the bug is caused by a shallow copy issue (CVE-2016-6130). However, the size of the , msg.len) ... trans_func(dst2, &msg) Figure 9: Refined Coccinelle-Based Double-Fetch Bug Detection data structure is variable, causing a size checking scenario. While the first phase of our study was to identify and categorize scenarios in which double fetches occur, the second phase exploited the gained knowledge from the first phase to design an improved analysis targeted at specifically identifying double-fetch bugs and vulnerabilities.As shown in Figure 9, in addition to the basic doublefetch pattern matching rule (Rule 0), which is triggered when two reads fetch data from the same source location, we added the following five additional rules to improve precision as well as discover corner cases. A double-fetch bug could involve different transfer functions, therefore, we have to take the four transfer functions that copy data from user space (get_user(), __get_user(), copy_from_user(), __copy_from_user()) into consideration. For instance, in the size checking scenario, a user pointer is first used to fetch the message length by get_user(len, ptr->len), then to copy the whole message in the second fetch by copy_from_user(msg, ptr, len), which means the two fetches are not using exactly the same pointer as the transfer function arguments, but they cover the same value semantically. In this section, we present the evaluation of our study, which includes two parts: the statistics of the manual analysis, and the results of the refined approach when applied to three open source kernels: Linux, Android, and FreeBSD. 18 candidates did not fit into one of the three scenarios.Furthermore, 57 out of the 90 candidates were part of Linux drivers and among them, 22 were size checking related, 9 were type selection related and 19 were shallow copy related. 57 out of 90 (63%) of the candidates were driver related and 22 out of 30 (73%) of the size checking cases, 9 out of 11 (82%) of the type selection cases and 19 out of 31 (61%) of the shallow copy cases occur in drivers.2. Among the reported files, 23 were size checking related, and 6 were type selection related.For Android, even though it uses Linux as its kernel as well, we analyzed version 6.0.1 which is based on Linux 3.18. Five of them are previously unknown bugs that have not been reported before (CVE-2016-5728, -6130, - 6136, -6156, -6480), and the sixth one (CVE-2015(CVE- -1420) is a double-fetch bug present in the newest Android (version 6.0.1) which is based on an older Linux kernel (version 3.18) containing the bug, which has been fixed in the mainline Linux kernel since Linux 4.1. However, even though the cases we call benign double-fetch situations are not currently faulty, they could easily turn into a double-fetch bug or vulnerability when the code is updated without paying special attention to the doublefetch situation. cros_ec_dev.c Chrome OS Embedded Controller driver Linux 4.5Race condition in the ec_device_ioctl_xcmd function allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a "double fetch" vulnerability.Belongs to the size checking scenario.CVE- 2016- 6480* commctrl.c Adaptec RAID controller driver Linux 4.5Race condition in the ioctl_send_fib function allows local users to cause a denial of service (out-of-bounds access or system crash) by changing a certain size value, aka a "double fetch" vulnerability. For instance, their simulator needs 15 hours to boot the Windows kernel.While it only took a few days to investigate the 90 double-fetch situations, Jurczyk and Coldwind did not report the time they needed to investigate the 200KB of double fetch logs generated by their simulator. However, this approach will incur performance penalties for the kernel, as synchronization is introduced on a critical section.Since the Compare Data approach does not need to modify very much of the source code, most of the identified double-fetch bugs we found have been patched in this way by the Linux developers (CVE-2016-5728, - 6130, -6156, -6480). However, comparing the data has two advantages: it not only allow detecting attacks by malicious users but also protects from situation in which the data is changed without malicious intent (e.g., by some bug in user space code). Four out of the five new bugs belong to size checking scenarios, indicating that variable length message processing needs vetting for double-fetch bugs.In the Linux kernel, double-fetch bugs are more complex than in Windows because transfer functions separate the fetches from the uses in a double-fetch bug, making it harder to separate benign from vulnerable double fetches. Moreover, another discovered vulnerability in the source code is usually not exploitable because the compiler optimizes the code in a way that the second fetch is replaced with a reuse of the value of the first fetch.Double-fetch race conditions are very similar to TimeOf-Check to Time-Of-Use (TOCTOU) race conditions caused by changes occurring between checking a condition and the use of the check's result (by which the condition no longer holds). Moreover, they found that previous TOCTOU detection and prevention techniques are too specific and cannot detect or prevent general concurrency attacks.Coccinelle [17], the program matching and transformation engine we use in our approach, was initially targeted for collateral evolution in Linux drivers, but now is widely used for finding and fixing bugs in systems code. One solution is used to automatically patch double-fetch bugs, which is able to automatically patch all discovered bugs occurring in the size-checking scenario.Where a known dynamic analysis of the Linux, FreeBSD, and OpenBSD kernels found no double-fetch bug, our static analysis discovered six real double-fetch bugs, five of which are previously unknown bugs, and three of which are exploitable double-fetch vulnerabilities. This work is partially supported by the The National Key Research and Development Program of China (2016YFB0200401), by the program for New Century Excellent Talents in University, by the National Science Foundation (NSF) China 61402492, 61402486, 61379146, 61472437,and by the laboratory pre-research fund (9140C810106150C81001).