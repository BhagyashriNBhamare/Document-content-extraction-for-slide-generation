Software applications typically use IPC for communication between frontend and backend components, which run in different processes on the same computer. The attacks are closely related to impersonation and man-in-the-middle attacks on computer networks but take place inside one computer. The vulnera-bilities can be exploited in enterprise environments with centralized access control that gives multiple users remote or local login access to the same host. These computers and the software running on them is designed to be personal, and the focus of security engineering has therefore been on external threats from unauthorized users and from the Internet. They may be coworkers, family members, or guest users with console access.Our focus is on the security of inter-process communication (IPC), i.e. communication channels that are internal to the computer. Computer software often comprises multiple components, such as a frontend application and a backend database, which obviously need to exchange information. We therefore use the name man in the machine (MitMa) to describe these attackers.During the analysis of case-study applications, we observed that application developers have an ambiguous attitude towards local attackers and the security of IPC channels. On the other hand, the application implementations often make some attempt to authenticate or encrypt the communication, but rarely with the same prudence as seen in communication over physical networks.Our main contribution is to highlight the importance of the adversary model where a nonprivileged user intercepts communication inside the computer. We also discuss potential Figure 1: MitMa attack mitigation techniques. The attacker is a nonprivileged user who tries to steal sensitive information from or interfere with another user. The attack is similar to impersonation or man in the middle in computer networks, but since the communication takes place inside one computer, we call it man in the machine (MitMa). In a Windows domain, users are centrally registered at the Active Directory (AD) and they are typically able to log into each other's workstations. Linux and macOS workstations are commonly integrated into AD or other centralized directory services.In addition to having its own user account, the MitMa attacker needs to be able to run a process in the background when the victim user is working on the computer. On macOS and Linux, it is also possible to leave processes running when the user logs out (e.g., with the nohup command). We implemented the attacks described in this paper with macOS High Sierra, Windows 7, and Windows 8.1. In enterprise Windows domains, the availability of the guest account depends on the group policy.The attacks can also be carried out remotely, for example, if SSH [56] has been enabled. The user might not realize this because earlier Windows versions required third-party SSH servers.Another remote access method is remote desktop. The MitMa attack is technically possible also between remote desktop sessions on a Windows Server. The vulnerabilities presented in this paper were found in IPC methods where a server process or device listens for connections from client processes. Specifically, we consider network sockets, named pipes, and Universal Serial Bus (USB) communication. While network sockets were originally intended for communication across a network, they are also used for IPC within one host. It is the responsibility of the client and server processes to authenticate each other on the application layer, as if the client was on the other side on the Internet. However, a separate connection is created for each client, and the OS prevents unauthorized processes from sniffing the communication. Some servers might accept only one client connection, and in that case the malicious process needs to connect before the legitimate client.The network-socket server typically listens for TCP connections on one or more predefined ports. The attacker can then receive any connections that clients open to the port, enabling server impersonation.The MitMa attacker naturally wants to combine server and client impersonation to a full man-in-the-middle attack where the attacker passes messages between the legitimate client and server. This is not always easy to do on the localhost because the legitimate server and attacker cannot both bind to the same port number. We describe Windows named pipes here because they were found to create more actual vulnerabilities.On Windows, the named pipes are placed in the root directory of the named pipe filesystem. The named pipe can have multiple instances to support multiple simultaneous connections from clients. Some important details are that, if an instance of the named pipe with the same name already exists, only processes with the FILE CREATE PIPE INSTANCE access to the pipe object can create a new instance, and that a process can set the FILE FLAG FIRST PIPE INSTANCE flag to ensure that it is creating the first instance.Attack vectors. It helps to know that Windows connects new clients to the server instances in round-robin order.To summarize, it is easy to overlook the necessary security controls for named pipes, thus creating vulnerabilities, but on the other hand, careful configuration can avoid most of the issues. Universal Serial Bus (USB) allows peripheral devices to communicate with a computer. USB human interface devices (HID) include keyboards and pointing devices, but also hardware security tokens.In Linux, HIDs are character devices and mapped to special files under /dev/hidraw*. Windows lacks such mechanisms for dynamic access-rights assignment, and more than one user at a time could have access to a HID device including hardware security tokens.Attack vectors. Thus, it is attractive to use the more client-server oriented but less safe methods described above.On macOS, apart from the same IPC methods that are available on Windows and Linux, there are also Mach IPC methods that are based on the Mach kernel, such as CFMessagePort. We focus on password managers that consist of two discrete components: a stand-alone app for managing the password vault and a browser extension for the web-browser integration, as in Figure 2. Many password managers use network sockets as the IPC method because of its portability across operating systems and browsers and compatibility with web APIs. The RoboForm [7] password manager (S) and its browser extension (E) communicate via the loopback network interface with HTTP without any authentication. E ← S: item iThe extension first requests a list of all items stored in the password vault by sending an HTTP POST request to http://127.0.0.1:54512. Since there is no authentication between the browser extension and the native app, a MitMa attacker can impersonate the browser extension by simply connecting to the above URL. Dashlane [3] has two modes of operation: in one, the browser extension retrieves passwords directly from a cloud storage and, in the other, from a desktop app. Third, the server verifies the client process by checking its code-signing signature using APIs provided by the operating system. The process must be a whitelisted web browser and the signature must be generated by a whitelisted software publisher. Fourth, the server checks that the client process is owned by the same user as the server.A peculiar feature of Dashlane is that the browser extension collects all DOM elements from the web pages that the user visits and sends them to the app for analysis. The very first time when the browser extension communicates with the WebSocket server, the server verifies the client binary and user in the same way as Dashlane does. They then run the following protocol to agree on a shared encryption key.1. E ← S: "welcome" Finally, both sides derive the encryption key K = HMAC(hmac key, m S ||m E ||"encryption"), which will be used to protect all future communication.Attacks. The above protocol is clearly not a secure key exchange. By analyzing the JavaScript code of the 1Password browser extension, we found commands that the app can issue to the extension, such as collectDocuments, which tells the browser extension to collect data on the page the user is visiting including the URL and data entered into web forms. For example:{ "items": [{ "title":"<encrypted_title>", "username": "<encrypted_username>", "password": "<encrypted_password>" }]} F-Secure Key requires the user to create passwords in the app, and thus confidential data mainly flows from the app to the extension. The attacker then responds to requests from the browser extension by replaying the responses that it received earlier, but with the mismatched passwords. More seriously, the attacker could collude with one of the websites, identify its encrypted URL at the MitMa process by correlating the timing of the encrypted message with the user's login on the colluding site, and then leak the user's passwords to that site one by one. Native messaging [25] is intended to provide a more secure alternative to network sockets or named pipes for communicating between a browser extension and native code. The web browser starts the NMH in a child process and lets the browser extension communicate with it.Native messaging can be used to implement a password manager that is only accessed through the web browser and the browser extension. The attacker then creates another instance of the named pipe, which is possible thanks to the unnecessarily high maximum number of instances. The attacker can thus sit between the two pipe instances forwarding messages and reading their content, including passwords.The above attack does not work if the attacker only has guest access to the victim's system because the named pipe's security attributes allow only authenticated users to create and access instances. Sticky Password [8] also makes use of both native messaging and WebSocket, but in a configuration that is slightly different from Figure 3. When the browser extension starts up, it uses native messaging to obtain an AccessKey from the NMH, which gets it from the standalone Sticky Password app with the CFMessagePort IPC method. That is, after capturing the AccessKey, the MitMa attacker closes the server socket at port 10011 and waits for the user to restart the Sticky Password app. FIDO U2F [23] is an open authentication standard that enables strong two-factor authentication to online services with public-key cryptography and a USB hardware device called security key. The device generates a service-specific key pair and stores it together with a key handle (i.e. identifier) and the origin URL of the service. At this point, the user needs to activate the device by touching a button on the device. The browser then delivers the signed object back to the web server for verification.The button press is meant to prevent unauthorized use of the hardware device. The user may notice that the first button press had no effect, but such minor glitches are normal in computers and typically ignored.In experiments with FIDO U2F Security Key, our malicious Python client in the background was 100% suc- Figure 5: MitMa attack on DigiSign smart card reader through SCS interface cessful in snatching the first button press and spoofing the second authentication factor to services such as Facebook and GitHub. This attack is not possible in Linux or macOS because they would prevent the malicious background process form accessing the USB device.Another approach to strengthening the security of critical login sessions is the TLS Channel ID [13,21]. We analyze the currently implemented protocol version 1.01. The card-reader app with the SCS interface has an HTTP server running on port 53951 and HTTPS server on port 53952 (during installation, the card reader app creates a self-signed certificate for the local HTTPS server and adds it to the trusted certificates). The MitMa attack against the SCS protocol, illustrated in in Figure 5(b), is similar to those against password managers. When the user enters the PIN, the card signs the attacker's data.SCS specification version 1.1 [43] will fix some of the problems. A common application software architecture separates the application into a front-end component, which only handles user interaction, and a back-end server with an HTTP API, which often follows the REST design paradigm. Blizzard [2], a computer game publisher, provides the Battle.net desktop app for installing and updating games.The app comes with a background service called Blizzard update agent, which receives commands from the app and does the actual software installation. Transmission [9] is an open-source BitTorrent client. Moreover, the MitMa attacker can hijack the server port and capture the username and password from the client, before releasing the port and waiting for the legitimate server to start. This section will analyze two more client-server applications that make use of named pipes for the IPC. Next, the MySQL server will create a new instance to wait for a new client. Thus, the background process will not start if the named pipe already exists.To use Keybase on a new device, the user must first sign in to the Keybase background process with his Keybase credential and then approve the new device from a previously registered device. The goal is to present a taxonomy that brings order to the concepts, rather than to cover all technical details.Spatial and temporal separation of user sessions. On Linux and macOS, this requires disabling fast user switching and remote access and killing any rogue processes that might have been left behind. They can manually verify that there are no other active login sessions in the background, e.g. with the Windows command query user. For example, when creating a named pipe on Windows, the server needs to specify the FILE FLAG FIRST PIPE INSTANCE flag or check after the creation who is the owner of the securable pipe object. The critical trick here to perform the checks both at the server for the client and at the client for the server.JavaScript clients running in a web browser, including browser extensions, pose special challenges for such attack detection. These protocols require distribution of shared or public keys to the IPC clients and servers. For example, F-Secure Key authorizes access to the password database by transferring a secret token to the client through a user-assisted out-of-band channel (in this case, Windows clipboard, which has its own weaknesses). In any case, cryptographic protection requires careful design and, as we have seen once again in this paper, ad-hoc implementations tend to have weaknesses.Architectural changes to software. The safe IPC methods (unnamed pipes and socket pairs, see Section 3.4) can still be used between related processes without exposing the applications to MitMa attacks.Such architectural solutions work well when they are a good match for the goals of the application developer. Named pipes provide more such control and seem easier to secure than network sockets. The advantage of network sockets is that the same web APIs work without code changes locally and across the Internet, but the cost is that the available web security mechanisms do not take advantage of the locality and are usually considered too heavy for local IPC.The explanation why the problems with IPC are so widespread is probably twofold. Fully automated vulnerability scanning, however, does not seem possible because the automated tools cannot not evaluate the security of application-level cryptographic protection.In some sense, the idea of protecting the users of a multi-user computer system from each other takes us back to the early days of computer security. This trend started in mobile devices, but desktop operating systems are beginning to provide similar protections (UWP AppContainers in Windows 10 [40] or application sandboxing in macOS [11]). Windows named pipes have been an attractive target for security analysts. This attack requires the server and client processes to run as the same user or for the server to run as the superuser, which is a stronger assumption than our threat model. These attacks are akin to our client impersonation, but the attack is launched from a supposedly sandboxed code running in the web browser rather from another user's session.Automated detection and firewall-like defenses may help to prevent attacks between users and applications inside the same computer. Li et al. [37], on the other hand, found that password managers suffer from traditional web vulnerabilities (e.g. XSS, CSRF), poor userinterface design, and problems related to poorly understood threat model. We expect the importance of IPC security to increase as operating system strive to isolate not only users but also applications from each other.Following responsible disclosure, we have reported the vulnerabilities discovered in the research project to the respective vendors and believe that they have taken steps to prevent the attacks. The research was partially funded by the CyberTrust program of DIMECC and Tekes (Business Finland) and by Academy of Finland (project 296693).