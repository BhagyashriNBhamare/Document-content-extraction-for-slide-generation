However, it is particularly challenging for kernel developers to correctly apply new permission checks and to scalably verify the soundness of existing checks due to the large code base and complexity of the kernel. PeX uses KIRIN (Kernel InteRface based Indirect call aNalysis), a novel, precise, and scalable indirect call analysis technique, leveraging the common programming paradigm used in kernel abstraction interfaces. Correspondingly, each file has properties including the owner, the group, the rwx (read, write, and execute) permission bits for the owner, the group, and all other users. For example in Linux, inode_permission (as listed in Table 1) is often used to check the permissions of the current process on a given inode. 2 (1999), enable a finegrained access control by dividing the root privilege into small sets. As an example, for users with the CAP_NET_ADMIN capability, kernel allows them to use ping, without the need to grant the full root privilege. One common use of LSM is to implement Mandatory Access Control (MAC) [8] in Linux (e.g., SELinux [40, 41], AppArmor [3]). For example, when a process tries to read the file path of a symbolic link, security_inode_readlink is invoked to check whether the process has read permission to the symlink file. This section illustrates different kinds of permission check errors, found by PeX and confirmed by the Linux kernel developers. We refer to those functions, that validate whether a process (a user or a group) has proper permission to do certain operations, as permission checks. Considering all together, scsi_ioctl checks CAP_SYS_ADMIN once but CAP_SYS_RAWIO "twice", leading to a redundant permission check. In particular, PeX detects this bug as an inconsistent permission check because the two paths disagree with each other, and further investigation shows that one is redundant and the other is missing. The first challenge lies in the frequent use of indirect calls in Linux kernel and the difficulties in statically analyzing them in a scalable and precise manner. For example, Virtual File System (VFS) [12] abstracts a file system, thereby providing a unified and transparent way to access local (e.g., ext4) and network (e.g., nfs) storage devices. For example, as shown in Figure 3a, VFS abstracts all file system operations in a ker-nel interface struct file_operations that contains a set of function pointers for different file operations. For instance, Figure 3b shows that ext4 file system sets the write_iter function pointer to ext4_file_write_iter, while nfs sets the pointer to nfs_file_write.However, kernel's large code base challenges the resolution of these numerous function pointers within kernel interfaces. Type based pointer analysis will even link write_iter to ext4_file_read_iter falsely, which may lead to false permission check warnings.PeX addresses this problem with a new kernel-interface aware indirect call analysis technique, detailed in §5. The second challenge lies in soundly enumerating a set of permission checks and inferring correct mappings between permission checks and privileged functions in Linux kernel.Though some commonly used permission checks for DAC, Capabilities, and LSM are known (Table 1), kernel developers often devise custom permission checks (wrappers) that internally use basic permission checks. Many other tools require heavy manual efforts such as user-provided security rules [20,56], authorization constraints [33], annotation on sensitive objects [21]. Since the huge Linux kernel code base makes it practically impossible to review them all manually, reasoning about the mapping is considered to be a daunting challenge.In light of this, PeX presents a novel static analysis technique that takes as input a small set of known permission checks to identify their basic permission checks and leverages them as a basis for finding other permission check wrappers ( §6.2). KIRIN is inspired by two key observations: (1) almost all (95%) indirect calls in the Linux kernel are originated from kernel interfaces ( §4.1) and (2) the type of a kernel interface is preserved both at its initialization site (where a function pointer is defined) and at the indirect callsite (where a function pointer is used) in LLVM IR. For example in Figure 3b, the kernel interface object ext4_file_operations of the type struct file_operations is statically initialized where ext4_file_write_iter is assigned to the field of write_iter infer that ext4_file_write_iter is one of potential call targets. KIRIN finds that the kernel interface type is struct file_operations (Line 1), and ext4_file_write_iter is assigned to the 5th field write_iter (Line 7). Therefore, KIRIN figures out that write_iter may point to ext4_file_write_iter, not ext4_file_read_iter (even though they have the same function type). For example, Figure 4b shows the LLVM IR snippet in which an indirect call file→f_op→write_iter is made inside of vfs_write. When an indirect call is made (Line 4), KIRIN finds that the kernel interface type is struct file_operations (Line 1) and the offset is 5 (Line 2). This adds back the kernel interface type struct.usb_driver in the LLVM IR (Line 6), thereby enabling KIRIN to infer the correct type of driver and resolve the targets for unlocked_ioctl.Our experiment ( §7.2) shows that KIRIN resolves 92% of total indirect callsites for allyesconfig. Based on the partitioned call graph, PeX then generates the interprocedural control flow graph (ICFG) where each callsite is connected to the entry and the exit of the callee [17]. PeX generates the call graph leveraging the result of KIRIN ( §5), and then partitions it into two groups.User Space Reachable Functions: Starting from functions with the common prefix SyS_ (indicating system call entry points), PeX traverses the call graph, marks all visited functions, and treats them as user space reachable functions. The partitioned call graph serves as a basis for building an interprocedural control flow graph (ICFG) [31] used in the inference of the mapping between permission checks and privileged functions ( §6.3). Figure 7 shows an example of the permission check wrapper detection. Given a known permission check ns_capable (Lines 10-13), PeX first finds security_capable (Line 4) as a basic permission check, and then based on it, PeX detects another permission check wrapper has_ns_capability (Lines [14][15][16][17][18][19][20]. Our evaluation ( §7.3) shows that based on 196 permission checks in Table 1, PeX detects 88 wrappers. The rationale behind the dominator analysis is based on the following observation: since there is no single path that allows the dominated call instruction to be reached without visiting the dominator (i.e., the permission check), pc f uncs -all permission checking functions OUTPUT:pv f uncs -privileged functions 1: procedure PRIVILEGED FUNCTION DETECTION 2:for f ← pc f uncs do for u ← User( f ) do CallInst ← CallInstDominatedBy(u) Inter-procedural analysis, for full program path callee ← getCallee(CallInst) pv f uncs.insert(callee) end for 8: end for return pv f uncs 10: end procedure the callee is likely to be the one that should be protected by the check on all paths 2 . Note that the call graph generated by KIRIN ( §5) has resolved most of the indirect calls, which allows PeX to perform-on top of the resulting ICFG-more sound privileged function detection. For example, our experiment ( §7.3) shows that KIRIN can identify ecryptfs_setxattr (reachable via indirect calls over the ICFG) as a privileged function and detect its missing permission check bug (Table 6, LSM-17). Note that PeX validates every possible path to each privileged function of interest.Algorithm 2 shows PeX's permission check error detection algorithm. We also automated the generation of the single-file whole vmlinux LLVM bitcode vmlinux.bc using wllvm [13]. PeX reported 36 permission check errors warnings to the Linux community, 14 of which have been confirmed as real bugs. For comparison, we took K-Miner's implementation from the github [6] and added the logic to count the number of resolved indirect callsites and the average number of targets per callsite. After further inves-tigation, we noticed that SVF runs on each partition whose code base is smaller than the whole kernel, its analysis scope is significantly limited and unable to resolve function pointers in other partitions, leading to the poor resolution rate.Besides, we found out that K-Miner does not work for allyesconfig which contains a much larger code base than defconfig. Note that K-Miner evaluated its approach only for defconfig in the original paper [22]. For a given system call, we measured K-Miner's running time from the beginning until it produces the SVF point-to result, which does not include the later bug detection time. Given the small number of input DAC, CAP, and LSM permission checks (3, 3, and 190 each), PeX's permission check detection ( §6.2) was able to identify 19, 16 and 53 permission check wrappers. Kernel developers ignored some bugs and decided not to make changes because they believe that the bugs are not exploitable. To highlight the effectiveness of KIRIN, we repeated the end-to-end PeX analysis using type-based (PeX+TYPE) and K-Miner-style (PeX+KM) indirect call analyses. Though PeX+TYPE can capture them all (as type-based analysis is sound yet imprecise), it generates up to 3x more warnings, placing a high burden on the users side for their manual review. As long as one can confirm that a function is indeed privileged, reported warnings regarding its missing, inconsistent, and redundant permission checks should be true positives from PeX's point of view.Though kernel developers with domain knowledge may be able to discern them with no complication, we (as a thirdparty) try to understand whether a given function can be used to access critical resources (e.g., device, file system, etc.). This security bug allows attackers to manipulate entropy pool, which can potentially corrupt many applications using cryptography libraries. Specifically, a problematic path starts from evdev_write and reaches the privileged function credit_entropy_bits, which can control the entropy in the entropy pool, while bypassing the required CAP_SYS_ADMIN permission check.The LSM-21 missing check in xfs_file_ioctl led to another interesting discussion among kernel developers [9]. Nonetheless, we have one complaint to share.For the LSM-19 and LSM-20 cases, PeX found that the LSM hooks security_kernel_read_file and security_kernel_post_read_file were used to protect the privileged functions kernel_read_file and kernel_post_read_file in some program paths. However, the kernel developers responded that those hooks are used to monitor loading firmware/kernel modules only (not other files), and thus no patch is required. For the same privileged function prctl_set_mm_exe_file, which is used to set an executable file, PeX discovered one case requiring CAP_SYS_RESOURCE in user namespace, and another case checking CAP_SYS_ADMIN in init namespace. PeX does not consider the precise context in which prctl_set_mm_exe_file is used (similar to aforementioned security_kernel_read_file used for loading kernel modules), leading to an imprecise report, but we believe that both CAP-14 and CAP-15 are worthwhile for further investigation. Edwards et al. [18] proposed to use dynamic analysis to detect LSM hook inconsistencies. Third, AutoISES uses typebased pointer analysis to resolve indirect calls, while PeX uses KIRIN to resolve indirect calls in a more precise manner.There are also works [21,32,33] that extend authorization hook analysis to user space programs, including X server and postgresql. Note that to resolve indirect call targets, all these works leverage a type-based approach, which is not as accurate as KIRIN, thus suffering from false positives.MECA [54] is an annotation based static analysis framework, and it can detect security rule violations in Linux.APISan [55] aims at finding API misuse. It is designed for analyzing userspace programs, cannot be applied to kernel directly.JUXTA [30] is a tool designed for detecting semantic bugs in filesystem while PScout [15] is a static analysis tool for validating Android permission checking mechanisms. This paper presents PeX, a static permission check analysis framework for Linux kernel, which can automatically infer mappings between permission checks and privileged functions as well as detect missing, inconsistent, and redundant permission checks for any privileged functions.