The true dependencies between security-sensitive files, network endpoints, or memory objects from different hosts can be easily concealed by dependency explosion or undefined program behavior (e.g., memory corruption). Advanced attacks tend to involve multiple hosts to conceal real attackers and attack methods by using command-andcontrol (C&C) channels or proxy servers. Gibler and Beddome demonstrated GitPwnd [32], an attack that takes advantage of the git [11] synchronization mechanism to exfiltrate victim's private data through a public git server. More seriously, existing cross-host DIFT mechanisms piggyback metadata (i.e., tags) on network packets and associate them during runtime [50,67], which is another source of huge performance degradation.To perform efficient and accurate information flow analysis in the investigation of cross-host attacks, we propose a record-and-replay-based data flow tagging and tracking system, called RTAG. §3, §4, and §5 present the challenges, an overview and the threat model of RTAG; §6 presents the design of RTAG; More specifically, §6.1 describes the data structure of RTAG, §6.3 explains how RTAG facilitates the independent DIFT; §6.4 describes how RTAG conducts tag switch for DIFT, and §6.6 presents the tag association module and how RTAG tracks the traffic of IPC. This technique does so by: (1) marking with tags the "interesting" values of a program, (2) propagating tags by processing instructions, and (3) checking tags associated with values at specific points of the execution. Figure 1: Comparison of the serialized DIFTs and RTAG parallel DIFTs. 1) The git first forks an ssh process, handling the ssh session with the remote host, and then 2) spawns another git pack process packing the related objects of the push.3) The pack process uses pipe to transfer the packed data to the ssh process. This is because the interactive two-way communication (for the purpose of network or application-level protocol) demands the replays to be paused and waiting iteratively for enforcing the same tag dependency as the recording, which further lengthens the waiting time (i.e., analysis time consumption), and increases the complexity of replay orchestration.Let us look into one example of replay from the Gitpwnd attack [32] (detailed in §3.1) for the communication between the client-side ssh and the server-side sshd in Figure 1(a). Second, to ensure no tag as well as their propagation to other tags is lost when the tag of a piece of data is updated more than once, RTAG keeps track of each change (version) of the data according to system-wide write operations. Figure 1(b) depicts how RTAG facilitates the independent replay and DIFT for the cross-host ssh daemon and client example with the tag overlay and a set of techniques (i.e., tag switch, allocation, and association). With accurate interference information, the replay and DIFT are fast forwarded to the beginning of the interference (e.g., a read syscall) and early terminated at the end (e.g., a write syscall). The non-determinism includes the file, network, and IPC inputs which are saved and maintained with a B-tree [25]. Such symbolization needs to distinguish the change of a tag before and after the write operation on it, and synchronize the change to other related tags as well. According to the sequential system-call trace, the version is incremented at every event in which there is a write operation against this certain byte (e.g., write(), writev()). In the case of memory mapped file operation (e.g., mmap()), the version is incremented at the mmap() if the prot argument is set to be PROT_WRITE. For example, if the program reads only 10 bytes from a file marked as a source in DIFT, in fact as low as four bits are sufficient to represent each of these bytes. Before DIFT, RTAG computes the optimal local tag needed to mark the source and substitute the global tag for the local one when a source is loaded to the memory space of the process (e.g., via read() syscall). When the propagation arrives at a sink (e.g., via a write() syscall), RTAG replaces the local tag with the original global one, and updates the tag value of the sink. For example, the sender may perform five writev() system calls to send 10,000 bytes of data (2,000 bytes each call), while the receiver may conduct 10 read() calls (1,000 bytes each call) to retrieve the complete data. As we will show in §8, the communication cost for TCP case is 0, while the cost for UDP is also marginal in the benchmark measurement.The cross-host tag represents the byte-level data in the socket communication between two processes across hosts. When a process uses pipe to send data to the child process, RTAG monitors the read and write system calls to track the transferred data in bytes. Specifically, our implementation adds 830 lines of C code to the Linux kernel for the tag association module, 2,500 lines of C++ code to the DIFT engine for the tag switch mechanism, 1,100 lines of C++ code for the maintenance of tags, 900 lines of C++ code for the query handler, and 500 lines of Python code for the reachability analysis for tag allocation. If the type of socket is SOCK_STREAM (i.e., TCP), we use a counter counting the total number of bytes sent or received by tracking the return value of send or write system calls. ( §8.1) • How well does RTAG improve the efficiency of DIFTbased analysis in terms of time and memory consumption? RTAG helps determine the data flow between the user's loaded file and one of the payroll record that is considered to have been tampered.Cross-site scripting.The reflection-based crossscripting relies on dependency of an html element to user input to append a script that reads the sensitive data from the DOM tree of a page, packs some of the data, and sends an email to the attacker's external host. Setting Bandwidth% RTT% TCP Window: 128KB 0% +0.03% 256KB 0% +0.01% 512KB 0% +0.012% UDP Buffer: 512B -0.8% +0.02% 8KB -0.05% +0.01% 128KB -0.01% +0.012% We use iperf3 [13] to test the bandwidth impact of applying RTAG to typical network protocol settings.