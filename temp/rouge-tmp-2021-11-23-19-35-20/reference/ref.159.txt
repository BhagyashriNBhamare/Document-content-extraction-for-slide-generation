However , the way these countermeasures are evaluated does not properly assess their impact on user privacy, in particular regarding the quantity of information they may indirectly leak by revealing their presence. Nonetheless, this strategy tends to generate inconsistent combinations of attributes called inconsistencies, which are used by commercial fingerprinters, like AUGUR 1 , or open source libraries, such as FINGERPRINTJS2 [21], to detect countermeasures.In this paper, we extend the work of Nikiforakis et al. [16], which focused on revealing inconsistencies to detect user agent spoofers, to consider a much wider range of browser fingerprinting countermeasures. Before addressing the consistency properties of fingerprint attributes (cf. Section 2.3), we introduce the principles of browser fingerprint (cf. Section 2.1) and existing countermeasures in this domain (cf. Section 2.2). With the appearance of new JavaScript APIs, Mowery et al. [14] showed how the HTML 5 canvas API could be used to generate a 2D image whose exact rendering depends on the device. Besides blocking, it also provides another mode, similar to CANVAS DEFENDER, 7 that randomizes the value of a canvas every time it is retrieved. RANDOM AGENT SPOOFER 10 is a FIREFOX extension that protects against fingerprinting by switching between different device profiles composed of several attributes, such as the user agent, the platform, and the screen resolution. For example, one way to implement canvas poisoners is to override the native function toDataURL, used to generate a Base64 string representation of a canvas, which may however be detected by dumping the internal representation of the function.Privacy Implications. 1 We discovered that this script computes an attribute called spoofed, which is the result of multiple tests to evaluate the consistency between the user agent, the platform, navigator.oscpu, navigator.productSub, as well as the value returned by eval.toString.length used to detect a browser. While we cannot know the motivations of fingerprinters when it comes to detecting browsers with countermeasures-i.e., this could be used to identify bots, to block fraudulent activities, or to apply additional tracking heuristics-we argue that countermeasures should avoid revealing their presence as this can be used to better target the browser. The first attribute reports the name of the GPU, for example ANGLE (VMware SVGA 3D Direct3D11 vs 4 0 ps 4 0). The most common use case is the implementation of responsive web design, which adjusts the stylesheet depending on the size of the device, so that users have a different interface depending on whether they are using a smartphone or a computer. In the case of a stack overflow, FIREFOX throws an InternalError and CHROME throws a RangeError. Even for properties such as message and name, which are implemented in all major browsers, their values may differ for a given error.For example, executing null[0] on CHROME will generate the following error message "Cannot read property '0' of null", while FIREFOX generates "null has no properties", and SAFARI "null is not an object (evaluating 'null [0]')". It is possible to obtain a string representation of any object or function in JavaScript by using the toString method. However, such representations-e.g., eval.toString()-may differ depending on the browser, with a length that characterizes it. In the case of a genuine fingerprint whose attributes have not been overridden in JavaScript, it should contain the substring native code. The value of the acceleration will always slightly deviate from 0 for a real mobile device, even when lying on a table. Number of isolated pixels, which are pixels whose rgba value is different than (0, 0, 0, 0) and are only surrounded by transparent pixels. For the purpose of our evaluation, this fingerprinter extends state-of-the-art fingerprinters, like FINGERPRINTJS2, with the list of attributes covered by FP-SCANNER (e.g., WebGL fingerprint). If more than N f = 1 fonts are associated to another OS than OSRef, or if no font is associated to OSRef, then FP-SCANNER reports an OS inconsistency. With regards to JavaScript errors, we check if the fingerprint has a prototype, an error message, as well as a type consistent with browserRef. Concerning the screen resolution, we first check if the screen height and width have been overridden. We first count the number of pixels whose rgba value is (0, 0, 0, 0). Finally, the third metric tests the presence of the orange color (255, 102, 0, 100) by counting the number of pixels having this exact value, and also the number of pixels whose color is slightly differenti.e., pixels whose color vector v c satisfies the following equation (255, 102, 0, 100) − v c < 4. Thus, we chose a value of 17200 transparent pixels since it provides both a false positive rate of 0 while maximizing the accuracy.Concerning the number of wrong fonts N f , we obtained an accuracy of 0.646 with a threshold of one font, but this resulted in a false positive rate of 0.197. Thus, we chose a value of N f = 2 fonts, which makes the accuracy of the test decrease to 0.42 but provides a false positive rate of 0. Thus, we chose a value of N e = 1Even if the detection accuracy of the tests may seem low-0.42 for the fonts and 0.51 for the browser features-these are only two tests among multiple tests, such as the media queries, WebGL or toDataURL that can also be used to verify the authenticity of the information provided in the user agent or in the canvas. On the globality of the dataset, FP-SCANNER reaches an accuracy 1.0 against 0.45 for FINGERPRINTJS2 and AUGUR, which perform equally on this dataset. In this section, we execute FP-SCANNER in depth mode-i.e., for each fingerprint, FP-SCANNER executes all of the steps, even if an inconsistency is detected. Thus, when FP-SCANNER analyzes BRAVE's navigator prototype to check if any properties have been overridden, it observes the following output for plugins and mimeTypes getters string representation: () => { return handler }. Firefox fingerprinting protection standardizes the user agent when the protection is activated and replaces it with Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0, thus lying about the browser version and the operating system for users not on Windows 7 (Windows NT 6.1). For the first two, as they are browser extensions that override canvas-related functions using JavaScript, we always detect that the function toDataURL has been altered. Concerning the browser family, we rely on function's internal representation (eval.toString(). Finally, we keep a list of versions with the maximum number of features in common. Indeed, while 83 % of the fingerprints are processed in less than 0.21 ms, the remaining 17 % need more than 440 ms. This is caused by the fact that most of the fingerprints we tested had installed countermeasures that could be detected using straightforward tests, such as media queries or testing for overridden functions, whereas the other fingerprints having either no countermeasures or FPRANDOM (17 fingerprints), require to run all the tests. Also, since the canvas attribute has been shown to have high entropy, and that RAS does not randomize it nor block it by default, the combination of few attributes of a fingerprint may be enough to identify a RAS user. In particular, the formula hereafter represents the probability that two or more users of CANVAS DEFENDER among k share the same noise vector, which is similar to the birthday para-dox: 1 − ∏ k i=1 (1 − 1 40 4 −i). Moreover, in the case of widely-used open source projects, this may lead to a code base being audited more regularly than less adopted proprietary extensions. Nevertheless, it is possible to develop code to target specific countermeasures as we showed in the case of CANVAS DEFENDER. Thus, we consider our study as a lower bound on the vulnerability of current browser fingerprinting countermeasures.