Broadly defined as the Internet of Things (IoT), the growth of commodity devices that integrate physical processes with digital connectivity has had profound effects on society-smart homes, personal monitoring devices, enhanced manufacturing and other IoT applications have changed the way we live, play, and work. SAINT operates in three phases; (a) translation of platform-specific IoT source code into an intermediate representation (IR), (b) identifying sensitive sources and sinks, and (c) performing static analysis to identify sensitive data flows. What is needed is a suite of analysis tools and techniques targeted to IoT platforms that can identify privacy concerns in IoT apps. SAINT finds sensitive data flows in IoT apps by tracking information flow from sensitive sources, e.g., device state (door locked/unlocked) and user info (away/at home) to external sinks, e.g., Internet connections, and SMS. SAINT correctly flagged 92 out of 168 official and 46 out of 62 third-party apps exposing at least one piece of sensitive data via the Internet or messaging services. Further, the study showed that half of the analyzed apps transmit out at least three different sensitive data sources (e.g., device info, device state, user input) via messaging or Internet.Similarly, approximately two-thirds of the apps define at most two separate sensitive sink interfaces and recipients (e.g., remote hostname or URL for Internet and contact information for messaging). Additionally, the two missed code sites contained side-channel leaks and therefore were outside the scope of SAINT analysis.It is important to note that the code analysis identifies potential flows of sensitive data. If the data flow is deemed malicious or dangerous for the domain or environment, the app can be rejected (from the market) or modified (by the developer) as needs dictate.We make the following contributions:• We introduce the SAINT system that automates information-flow tracking using inter-and intra-data flow analysis on an IoT app. SAINT analyzes the source code of an IoT app, identifies sensitive data from a taint source, and attaches taint labels that describe sensitive data's sources and types. SAINT does not determine whether the data leaks are malicious or dangerous; however, the output of SAINT can be further analyzed to verify whether an app conforms to its functionality and notify users to make informed decisions about potential privacy risks, e.g., when a camera image is transmitted.We focus on home automation platforms, which have the largest number of applications and consumer products [19]. As we will detail in Sec. 4.1, SAINT exploits the highly-structured nature of the IoT programming platforms and extracts an abstract intermediate representation from the source code of an IoT app. This would allow the algorithms developed in SAINT to be easily integrated into other programming platforms written in different programming or domain-specific languages. Lastly, we define each potential type of taint sources, the mechanisms for taint propagation, and taint sinks by studying their API documentation. Apps are developed with Groovy (a dynamic, object-oriented language) in a Kohsuke sandboxed environment [10]. The cloud backend creates software wrappers for physical devices and runs the apps.The permission system in SmartThings allows a developer to specify devices and user inputs required for an app at install time. They subscribe to device events or other pre-defined events such as clicking an icon; when an event is activated, the corresponding event handler is invoked to take actions.Users can install SmartThings apps in two different ways using a smartphone companion app called SmartThings Mobile. Users can also develop or install the source code of a third-party app and make it accessible to only themselves using the Web IDE. Actions are defined to send commands to specific devices and triggers can be defined to execute actions based on location, device, and time events. Second, while all taint tracking systems have to be configured with a set of taint sources and sinks, identifying taint sources and sinks in IoT apps is quite subtle, since they access a diverse set of devices, each of which has a different set of internal states. Lastly, each IoT platform has its idiosyncrasies that can pose challenges to taint tracking. In this subsection, we describe these common taint sources and taint sinks to understand why they pose privacy risks and how sensitive information gets propagated in their app structure (see Fig. 1). We present the taint sources and sinks of the SmartThings platform in Appendix C.Taint Sources. In contrast, device states introduced earlier may change during app execution; for instance, an action of an app may change a device's state.3) Location. 4) User Inputs. User inputs are also often used to form predicates that control device actions; for instance, an app may turn off the switch of a device at a particular time entered by the user. For instance, a SmartThing app may persist a "counter" that keeps track of how many times a door is unlocked; during every execution of the app, the counter is retrieved from external storage and incremented when a door is unlocked. As we detail in Sec. 4.2.2, state variables store sensitive data and needs to be tracked during taint propagation.Taint Propagation. For the second kind, a web-service IoT app may expose a URL that allows external entities to make requests to the app. We present SAINT, a static taint analysis tool designed and implemented for SmartThings apps. Finally, based on static taint analysis, it reports sensitive data flows from sources to sinks; for each data flow, the type of the sensitive information, as well as information about sinks, are reported (Sec. 4.3). A broad investigation of existing IoT environments showed three types of common building blocks: (1) Permissions grant capabilities to devices used in an app; (2) Events/Actions reflect the association between events and actions (when an event is triggered, an associated action is performed); and (3) Call graphs represent the relationship between entry points and functions in an app. When she leaves, it turns off the lights, locks the front door, and sends to a security service a short message that she is away based on the time window specified by her. This is where various types of devices // Events/Actions block subscribe(p, "present", h1) subscribe(p, "not present", h2) and user inputs are described and granted access. Turning to the IR example in Fig. 4, the permission block (Lines 1-7) defines: (1) the devices: a presence sensor, a switch, and a door; and (2) user inputs: security-service "contact" information for sending notification messages, and "fromTime" and "toTime" values that are used to determine whether notification messages should be sent. As noted in Sec. 3.3, we consider user inputs sensitive. // Entry point h1(){ x() } // Entry point h2(){ s.off() d.lock() def between= y() if (between){ z() } } x(){ s.on() d.unlock() } y(){ return timeOfDayIsBetween(fromTime, toTime, new Date(), location.timeZone) } z(){ sendSms(c, "...")We also include in the permission block a set of common interfaces designed for all apps that may leak sensitive data. Turning to our example, the event of state changing to "present" is associated with an event handler method named h1() and the event of changing to "not present" with the h2() method.We also found that events are not limited to device events, and can be generated in many other ways: (1) Timer events; event handlers are scheduled to take actions within a particular time or at pre-defined times (e.g., an event handler is invoked to take actions after a given number of minutes has elapsed or at specific times such as sunset); (2) Web service events; IoT programming platforms may allow an app to be accessible over the web. The SAINT analyzer analyzes all event subscriptions and finds their corresponding event handler methods; it creates a dummy main method for each entry point. Turning to IR depicted in Fig. 4, we have two entry points h1() and h2() Input: ICFG : Inter-procedural control flow graph Output: Dependence relation dep 1: worklist ← / 0; done ← / 0; dep ← / 0 2: for an id in a sink call's arguments at node n do 3:worklist ← worklist ∪ {(n, id)} 4: end for 5: while worklist is not empty do 6:(n, id) ← worklist.pop() 7:done ← done ∪ {(n, id)} 8:for node n with id def. in assignment id = e do 9:ids ← {(n , id ) | id is an identifier in e} 10:worklist ← worklist ∪ (ids \ done) 11:dep ← dep ∪ {(n : id, n : ids)} 12:end for 13: end while (Lines 12 and 16). We then present algorithms to address platform-and languagespecific taint-tracking challenges like state variables, call by reflection, web-service IoT apps, and Groovy-specific properties (Sec. 4.2.2). From the inter-procedural control flow graph (ICFG) of an app, SAINT's backward taint tracking consists of two steps: (1) it first performs taint tracking backward from taint sinks to construct possible data-leak paths from sources to sinks; (2) using path-and context-sensitivity, it then prunes infeasible paths to construct a set of feasible paths, which are the output of SAINT's static taint tracking.In the first step, SAINT starts at the sinks of the ICFG and propagates taint backward. The algorithm then takes an entry (n, id) from preferences { section("Select thermostat device") { input "ther", "capability.thermostat"} section("threshold value"){ input "thld", "number"} } def initialize() { subscribe(app, appHandler) } def appHandler(evt) { f() } def f(){ temp=ther.latestValue("temperature") temp_cel=convert (temp) + thld bar(temp_cel) } def convert(t){ return((t-32)*5)/9) } def bar(t){ ther.setHeatingSetpoint(t) sendSMS(phone, "set to ${t}") } the worklist and finds a definition for id on the ICFG; it adds identifiers on the right-hand side of the definition to the worklist; furthermore, the dependence between id and the right-hand side identifiers are recorded in dep. For the example, since the threshold value thld is a user-input value (Lines 4 and 5 in Fig. 5), we get the following possible data-leak path: 5:thld to 16:temp cel to 23:t.In the next step, SAINT prunes infeasible data-leak paths using path-and context-sensitivity. We found that the predicates used in IoT apps are extremely simple in the form of comparisons between variables and constants (such as x == c and x > c); thus, SAINT implemented its simple custom checker for path conditions. Furthermore, SAINT throws away paths that do not match function calls and returns (using depth-one call-site sensitivity). For example, a method foo() can be invoked by declaring a string name="foo" and thereafter called by reflection through $name; Figure 6: Our SAINT data flow analysis tool designed for IoT apps. While SmartThings does not recommend using reflective calls, our study found that ten apps in our corpus use this feature (see Sec. 5 An implicit flow occurs if the invocation of a sink interface is control dependent on a sensitive test used in a conditional branch. In our analysis, approximately two-thirds of analyzed apps implement device actions (such as unlocking a door) in branches whose tests are based on tainted values (such as a user's presence). We leave the detection of implicit flows optional in SAINT, and evaluate the impact of implicit flow tracking on false positives in Sec. 5.2. SAINT then uses Groovy visitors to traverse IR's ICFG and performs taint tracking on it. This section reports our experience of applying SAINT on SmartThings apps to analyze how 230 IoT apps use privacy-sensitive data. In late 2017, we obtained 168 official apps from the SmartThings GitHub repository [39] and 62 community-contributed third-party apps from the official SmartThings community forum [37]. Out of 168 official apps, SAINT flags nine apps using call by reflection, 74 declaring state variables, 37 implementing closures, and 23 using the OAuth2 protocol; out of 62 third-party apps, the results are one, 34, nine, and six, respectively. It flagged 92 out of 168 official, and 46 out of 62 third-party apps have data flows from taint sources to taint sinks. Finally, although user inputs and state variables may over-approximate sources of sensitive information, during manual checking, we made sure the reported data flows do include sensitive data.SAINT labels each piece of flow information with the sink interface, the remote hostname, the URL if the sink is the Internet, and contact information if the sink is a messaging service. To better characterize the taint sources, we present the types of taint sources flagged by SAINT for apps that sends data in Table 3. Out of 92 official apps, 28 apps (O1-O28) send one single kind of sensitive data, 16 apps (O29-O44) send two kinds of sensitive data, and the remaining 48 apps (O45-O92) send more than two and at most four kinds of sensitive data. For instance, a security and safety app managing few devices may send more types of sensitive data than an app designed for convenience that manages many devices.In general, we found that there is no close relationship between the number of devices an app manages and the number of sensitive data flows. Fig. 9a presents the CDF of the different sinks defined in official and third-party apps. We also study the recipients at each taint sink reported in an app by SAINT. We then collect different contact addresses and URL paths to determine the recipients. We extended SAINT to output whether the recipient and the content of a sink-interface call are specified by a user at install time, by a developer via some hard-coded string in an app's source code, or by an external entity such as a remote server (in this case, a remote server sends the recipient information, and then the app sends sensitive data to the recipient). The messaging rows of the table tell that, in official apps, users specify recipients 154 times, while contents are specified by users five times and 149 times by developers; for third-party apps, users define recipients 67 times, while message contents are specified by users five times, and 63 times by developers. As detailed in Sec. 4 Messaging Official 154 0 0 5 149 0 Third-party 67 0 0 4 63 0 Internet Official 2 48 44 0 54 40 Third-party 0 13 12 0 13 12 Table 4: Recipient and content analysis of data flows.endpoints and respond to requests from external services. Moreover, we extended our analysis to identify whether the recipient and the content of a sinkinterface call are specified by a user, a developer, or an external entity. We introduce an IoT-specific test suite, IOTBENCH [20], an open repository for evaluating information leakage in IoT apps. They include data leaks whose accurate identification through program analysis would require solving problems including multiple entry points, state variables, call by reflection, and field sensitivity. We made IOTBENCH publicly available:https://github.com/IoTBench.SAINT results on IOTBENCH. SAINT leaves detecting implicit flows optional. Another limitation is SAINT's treatment of call by reflection. We plan to explore string analysis to statically identify possible values of strings and refine the target sets of calls by reflection. SAINT treats all user inputs and state variables as taint sources even though some of those may not contain sensitive information. In another paper, Xu et al. [45] surveyed the security problems on IoT hardware design. These works have found that apps can be easily exploited to gain unauthorized access to control devices and leak sensitive information of users and devices.Many of previous efforts on taint analysis focus on the mobile-phone platform [9,48,15,7,5,12]. In contrast, to our best knowledge, SAINT is the first system that precisely detects sensitive data flows in IoT apps by carefully identifying a complete set of taint sources and sinks, adequately modeling IoT-specific challenges, and addressing platform-and language-specific problems. One of the central challenges of existing IoT is the lack of visibility into the use of data by applications. In particular, we are studying the space of privacy violations reported in academic papers, community forums, and from security reports, and will reproduce unique flow vectors in sample applications. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation here on.SAINT is available at http://saint-project.appspot.com. Table 3: Description of IOTBENCH test suite apps and SAINT's results. Listing 1: An example home-automation app48 } 49 50 def initialize() { 51 log.debug "initialize configured" 52 subscribe(presenceSensor, "present", h1) 53 subscribe(presenceSensor, "not present", h2) 54 } 55 56 def h1(evt) { 57 log.debug "presence active called: $evt" 58x ( def latestValue = theDoor.latestValue("door") 97 log.debug "message sent, the door status is $latestValue" 98 } Our first app "Implicit Permission 1" (ID: 11) sends a short message to household members when everyone is away. B IoTBench Apps Listing 4: Leak via a reflective call1 def attack(){ 2 httpGet("http://maliciousServer.com"){ 3 resp -> 4 if(resp.status == 200){ 5 state.method = resp.data.toString() 6 } 7 "$state.method"() // reflective call 8 } 9 updateApp() { 10 unsubscribe() // revoke smoke detector events 11 sendSms(attacker phone,"$detector is revoked") 12 } C Taint Source and Taint Sink APIsWe present SmartThings APIs that are taint sinks in Table 1 and APIs that are taint sources in Table 2. A code block is added to an existing app to send the battery level (implicit permission) and hub id (explicit permission) to a third-party's phone number via sendSms() when the sms send variable is true (see Listing 3). Because SAINT adds all methods in an app as possible call targets, it detects a data leak in updateApp(), which disables alarm by unsubscribing the "smoke-detected" event and sends this information to a hardcoded phone number.