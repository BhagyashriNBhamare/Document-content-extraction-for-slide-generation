Although miners benefit from low payout variance in pooled mining , centralized mining pools require members to trust that pool operators will remunerate them fairly. Furthermore , centralized pools pose the risk of transaction censorship from pool operators, and open up possibilities for collusion between pools for perpetrating severe attacks. To date, our deployed pools have handled a peak hashrate of 30 GHs from Ethereum miners, resulting in 105 blocks, costing miners a mere 0.6% of block rewards in transaction fees. These cryptocurrency networks maintain a distributed ledger of all transactions, agreed upon by a large number of computation nodes (or miners). The most widely used protocol for agreement is Nakamoto consensus, which rewards one miner every epoch (lasting, say, 10 minutes as in Bitcoin) who exhibits a solution to a probabilistic computation puzzle called a "proof-of-work" (or PoW) puzzle [1]. The reward is substantial (e.g. 12.5 BTC in Bitcoin, or 30, 000 USD at present), incentivizing participation.Nakamoto-based cryptocurrencies, such as Bitcoin and Ethereum, utilize massive computational resources for their mining. The reward is expected to be fairly divided among all pool members proportional to their contributed solutions.Problem. At the time of this writing, Bitcoin derives at least 95% of its mining power from only 10 mining pools; the Ethereum network similarly has 80% of its mining power emanating from 6 pools. Recent work by Apostolaki et al. has demonstrated largescale network attacks on cryptocurrencies, such as double spending and network partitioning, which exploit centralized mining status quo [5]. Furthermore, pools currently dictate which transactions get included in the blockchain, thus increasing the threat of transaction censorship significantly [6]. While some Bitcoin pools currently offer limited control to miners of transaction selection via the getblocktemplate protocol [7], this protocol only permits a choice between mining with a transaction set chosen by the pool or mining an empty block. For example, users recently publicly speculated that a large Ethereum pool favored its own transactions in its blocks to gain an advantage in a public crowdsale 3 . We also introduce a new data structure, the augmented Merkle tree, for secure and efficient verification. Finally, SMARTPOOL does not charge any fees 4 , unlike centralized pools, and disburses all block rewards to pool participants entirely.SMARTPOOL can be used to run mining pools for several different cryptocurrencies. As of 18 June 2017, SMARTPOOLbased pools have mined in total 105 blocks on both Ethereum and Ethereum Classic networks and have successfully handled a peak hashrate of 30 GHs from 2 substantial miners. SMARTPOOL costs miners as little as 0.6% for operational transaction fees, which is much less than 3% fees taken in centralized pools like F2Pool 5 . Finally, although being decentralized, SMARTPOOL still offers the advantage of low variance payouts like centralized pools.As a final remark, SMARTPOOL does not make centralized pooled mining in cryptocurrencies impossible, nor does it incentivize against centralized mining or alter the underlying proof-of-work protocol (as done in work by Miller et al. [13]). By leveraging smart contracts in existing cryptocurrencies, a novel data structure, and an efficient verification mechanism, SMARTPOOL provides security and efficiency to miners. We consider the problem of building a decentralized protocol which allows a large open network to collectively solve a computational PoW puzzle, and distribute the earned reward between the participants proportional to their computational contributions. The protocol running costs should be low and offer participants comparable reward and low variance guarantees as centralized operations. Typically, Bitcoin miners competitively search for a nonce value satisfyingH(BlockHeader || nonce) ≤ D (1)where H is some preimage-resistant cryptographic hash function (e.g. SHA-256), BlockHeader includes new set of transactions that the miner wants to append to the ledger and D is a global parameter which determines the puzzle hardness. of messages Figure 1: The effect of share's difficulty on i) the probability of a miner with 1 GHs finding a share within a day as per [2]; ii) resource (i.e. number of messages) consumed by a miner; in a decentralized mining pool for Bitcoin (e.g. P2POOL). Here we are interested in a decentralized approach that allows miners to collectively run and manage the pool without inherent trust in any centralized operator.Threat model and security assumptions. In the widely adopted centralized pooled mining protocol, there is a pool operator who asks pool miners to solve pool sub-puzzles by finding nonce so that the hash satisfies some smaller difficulty d (d D). Once a miner in the pool finds a valid block, the reward, i.e., new crypto-coins, is split among all pool miners in proportion to the number of their valid submitted shares [2]. To guarantee that each share is submitted and credited exactly once, P2POOL leverages coinbase transactions, which are special transactions that pay block reward to miners (see details in Section 3.3). P2POOL satisfies almost all ideal properties of a decentralized pool (defined in Section 2) except the efficiency and security properties. As of this writing, P2POOL accounts for less than 0.1% of Bitcoin mining power, thus P2POOL's share chain is vulnerable to 51% attacks from adversaries who control only 0.1% of Bitcoin mining power. Our solution for a decentralized pooled mining leverages Ethereum smart contracts which are decentralized autonomous agents running on the blockchain itself [17,18]. The contract code executes correctly on the blockchain as long as a majority of Ethereum miners faithfully follow the Ethereum protocol.At a high level, SMARTPOOL replaces the mining pool operator with a smart contract. The smart contract acts as a trustless bookkeeper for the pool by storing all shares submitted by miners. We allow miners to locally generate the block template of the pool (discussed more in Section 3.3). A share is valid if it uses the contract address as the coinbase address (i.e., the address that the block reward is sent to) and satisfies the predefined difficulty (e.g. Line 6). On each share submission, the pool verifies the share and updates the contribution statistics of the pool members (Line 13). On the other hand, reducing the number of shares per block by increasing the share difficulty will increase the variance in reward for miners, thus negating the sole advantage of pooled mining (see [2] for more analysis on the effects of share difficulty). Similarly, the pool should prevent miners from over-claiming their contribution by either re-submitting previous shares or submitting invalid shares. Centralized pools can efficiently guarantee this since the pool manager can check every submission from miners. Like any smart contract, SMARTPOOL is operated by all miners in the Ethereum network, yet it can secure other cryptocurrency networks including Bitcoin as well as the underlying Ethereum network itself. The security of SMARTPOOL depends exclusively on the underlying network (i.e. Ethereum) which runs smart contracts, not on how many users adopt the pool. • SMARTPOOL's efficiency comes from allowing miners to claim their shares in batches, e.g. one transaction to the SMARTPOOL contract can claim, say, 1 million shares. Furthermore, miners do not have to submit data of all shares but only a few for verification purposes, hence the transaction fee per share is negligible. • For the case of running an external SMARTPOOLbased Bitcoin mining pool on top of Ethereum, SMARTPOOL leverages the Bitcoin coinbase transaction to guarantee that miners can mine directly in their target currency (i.e. Bitcoin) without trusting a third party to proxy the payment (e.g. between Ethereum and Bitcoin). Nevertheless, miners still need to acquire Ether to pay for the gas when interacting with the SMARTPOOL smart contract. SMARTPOOL is a smart contract which implements a decentralized mining pool for Ethereum and runs on the Ethereum network. Each claim specifies the number of shares the miner claims to have found, and it has a particular structure that aids verification in a subsequent step. Each claim allows miners to submit a batch of (say, 1 million) shares. Thus, miners receive payouts for their shares one or more blocks after SMARTPOOL receives reward from the target network; and, the mechanism ensures that the cryptographic commitment strictly preceeds the verification step (the cryptographic reveal phase). In Section 3.4 we will discuss our verification protocol, a key contribution of this work which enables Table 1: Some important fields of a block header in Ethereum. The goal of the verification process is to prevent miners from both submitting invalid shares and over-claiming the number of shares they have found. SMARTPOOL maintains the verClaimList array in the contract which records the contributed shares by different miners to date. To enable efficient verification checks, SMARTPOOL forces miners to search for blocks with a particular structure and dictates a particular template for claim submissions, which we discuss in Section 3.3. The Merkle root of this data structure is a single cryptographic hash representing all the shares claimed and is included in the Claim as a field called ShareAugMT.After a miner claims several shares in a batch, SMART-POOL requires the miner to submit proofs to demonstrate that the shares included in the claim are valid. Furthermore, SMARTPOOL ensures that if a miner finds a share that is a valid Ethereum block, then the corresponding block reward is distributed among the pool members. SMARTPOOL asks the miners to fix their coinbase address before starting to find shares. Once a share is found, it is not possible to change or eliminate the coinbase address. Ideally, before accepting any claim of n shares submitted by the miner, we want to verify that (i) all shares submitted are valid;(ii) no share is repeated twice in a claim; (iii) each share appears in at most one claim.Probabilistic verification. We provide a way to sample shares to verify, outline a detailed procedure for checking validity in Section 3.5, and a full proof in Section 4. If SMARTPOOL were able to randomly sample one share from the miner's committed set, and verify its validity, then the odds of having detected the cheating is 500/1000 (or 1/2). By sampling k ≥ 1 times, SMARTPOOL can reduce the probability of a cheater remaining undetected exponentially small in k, as we show in Section 4. Specifically, when a miner claims shares S = {s 1 , s 2 , . . . , s n }, SMARTPOOL extracts a unique counter from each share, e.g., taking the first k (say 20) bits, and requires that the counters of all s i ∈ S to be strictly increasing. In SMARTPOOL implementation as an Ethereum contract, as discussed in Section 3.5, we use the share's timestamp and the used nonce to act as the counter value of a share.SMARTPOOL guarantees that miners produce distinct shares by providing a unique value in the "extra data" field in each miner's share template. SMARTPOOL validates the following:(i) the hash of the share meets the difficulty criterion; (ii) the share is constructed correctly, i.e., uses the SMARTPOOL's address as the beneficiary address of the block reward. In SMARTPOOL, we devise a new data structure called augmented Merkle tree to help us verify inclusion and ordering of shares efficiently. In general, the leaves of a Merkle tree will collectively contain some data of interest, and the root is a single hash value which acts as a certificate commitment for the leaf values in the following sense. An augmented Merkle tree for a set of objects S = {s 1 , s 2 , . . . , s n } is a tree whose nodes x have the form (min(x), hash(x), max(x)) where:(I) min(x) is the minimum of the children's min (or ctr(s i ), if x is a leaf corresponding to the object s i ), (II) hash(x) is the cryptographic hash of the concatenation of the children nodes (or hash(s i ) if x is a leaf corresponding to the object s i ), and (III) max(x) is the maximum of the children's max (or ctr(s i ), if x is a leaf corresponding to the object s i ). Figure 3 gives an example of an augmented Merkle tree based on four submitted shares with timestamps as 1, 2, 3, 4 respectively. SMARTPOOL can reconstruct other nodes on the path from c to the root (i.e. b and a sequentially) and accepts the proof if the computed root is the same as the committed one. For example, the miner in Figure 3 submits the node a as the cryptographic commitment, which has min and max as 1 and 4 respectively. Thus, by sampling the tree in a constant number of leaves and checking their corresponding paths, with high probability we will detect a sorting error in the augmented Merkle tree if there is one.Prevent over-claiming shares across claims. At the same time, timestamps monotonically order shares across claims, since the block timestamp monotonically increases over time.Thus for any two distinct claims, the maximum share counter among an earlier claim is always smaller than the minimum counter of the shares in a later one. The penalty scheme in Definition 2 is simple and suffices to disincentivize cheating, assuming rational miners.Definition 2 (Penalty Scheme). In SMARTPOOL, the penalty scheme for a claim of n shares is as follow:Pay all n shares if invalid share was not detected; Pay 0 otherwise.In Section 4, we prove that our penalty scheme disincentivizes rational miners from submitting wrong or duplicated shares. To reduce the amount of bias that any adversary can introduce to the block hash, one can take several samples based on several consecutive block hashes. We begin by informally reviewing the properties of our Merkle tree test and then formally establishing its correctness in Corollary 9 below. The intuition is if a claim has n valid shares and m invalid or duplicated ones, by randomly sampling a share from the claim, we can detect invalid shares with probability m/(n + m). We will relax these conditions in Section 4.2. It suffices for the SMARTPOOL contract to check a single, randomly chosen path through a submitted augmented Merkle tree in order to pay fairly for shares, on average (Corollary 9). For any node x in a augmented Merkle tree, (I) min(x) is the minimum of all nodes below x, and (II) max(x) is the maximum of all nodes below x.Proof. The min of x's immediate children along this path is, by definition of augmented Merkle tree, no greater than min(x). By the inductive hypothesis, the max of x's left child is less than the min of the next right child down, which is less than the min of the next right child down and so on, all the way down to some leaf y. By a symmetrical argument, the min of x's left child is greater than some leaf z which happens to be to the right of y. Next assume (II), and let y and z be any two leaves. An element x in an array is out of order if there exists a corresponding witness, namely an element to the left of x which is greater than or equal to x, or an element to the right of x which is less than or equal to x. A leaf in a Merkle tree contains a sorting error if its label value is out of order when viewing the leaves' labels as an array. Every Merkle tree has at least as many invalid paths as sorting errors among the leaves. Under the payment scheme in Definition 2, if SMARTPOOL checks one random path in the augmented Merkle tree of a claim, the expected reward when submit invalid or duplicated shares is the same as the expected reward when submit only valid shares.Proof. Thus, on average, it is not profitable to submit invalid shares to SMARTPOOL if we employ the payment scheme in Definition 2 and check one random path from the augmented Merkle tree.In summary, SMARTPOOL can efficiently probabilistically check that an augmented Merkle tree is sorted. Observe that, given a list of integers L which may include repeats, a non-decreasing arrangement of L's members in the leaves of a Merkle tree minimizes sorting errors. If the range is made smaller so as to exclude a sorting error, then the path leading to that sorting error is still invalid, and therefore injection from Theorem 7 still applies. We show that, even in the extreme case where the adversary controls up to 50% of Ethereum mining power (i.e. can drop 50% of the blocks), it suffices to check only two randomly chosen paths through a submitted augmented Merkle tree in order to discourage the adversary from cheating.Theorem 10. We aim to compute this latter probability.Let us assume that the choices of the two sample shares are drawn based on the hash of a single block hash, and that attacker controls p fraction of the network's mining power. Since the right-hand side is a geometric series in which the magnitude of the common ratio is less than 1, we obtain∞ ∑ k=1 f (k) = 1 1 − (1 − (1 − γ) 2 ) · p = 1 1 + (γ 2 − 2γ)p . In the first case it follows that p ≥ 1/2, since this threshold is always at least 1/2 when 0 < γ ≤ 1, and if γ = 0 then the attacker has no incentive for dropping blocks. The overall protocol is still similar to what have been discussed in previous sections, but here we present the detail changes to make SMARTPOOL work with Bitcoin while the contract is running on the Ethereum blockchain.Generating a block template. Thus, if a miner finds a fraction f of the shares in SMARTPOOL, he gets paid proportional to f in the reward that SMARTPOOL's miners get every time they mine a valid block.Verifying a claim. Second, the ShareProof contains an indication of the verClaimList based on which the payouts to miners were determined by the claimant. Our smart contract implementation consists of two main modules, namely, claim submission, claim verification.Claim submission. A miner submits a batch of shares by calling submitClaim() with the parameters: (i) the root of the corresponding augmented Merkle tree for the shares; (ii) number of shares in the tree; (iii) counter interval of the shares. Ethash was designed to be ASIC resistant, which is achieved by forcing miners to extract 64 values from pseudo-random positions of a 1 GB dataset. Thus, to explicitly compute Ethash, one would have to store 1 GB data in a contract, which costs roughly 33,554 Ether (storing 32 bytes of data costs 50,000 gas). Hence, one would require a budget of approximately $3, 000, 000 per day as of June 2017 to maintain the dataset, which is impractical. Intuitively, to verify the witness for dataset elements, the contract will keep the Merkle-root of the dataset and a witness for a single element is its Merkle-branch. Storing the Merkle roots of one year dataset requires storing 122 Merkle hashes, and would cost only 0.122 Ether.We note that technically, our approach does not provide a mathematical guarantee for the correct computation of Ethash. As per Figure 4, SMARTPOOL allows miners to fetch the verClaimList and build the coinbase transaction locally. Recall that the block reward consists of the block subsidy (12.5 Bitcoin) and the transaction fees. Our approach significantly reduces both the gas fees paid for verifyClaim() and also the amount of bandwidth that miners have to send for verification.Block submission. In SMARTPOOL-based pool for Bitcoin, there exists the block submission module which allows any user to submit a witness for a new valid block in the Bitcoin blockchain so that SMARTPOOL can have the latest state of the blockchain. We deployed SMARTPOOL on Ethereum [25] (and Ethereum classic [26]) live networks and mined with them with 30GH/s (4GH/s) hash power for 7 days (1 week). To reduce verification costs, we have submitted 1024 Merkle nodes for each 1GB dataset, namely, all the nodes in depth 10 of the Merkle tree. This operation was done is 11 transactions, which consumed in total around 6, 000, 000 gas (around 15 USD) [30]. A number of previous works have studied the problem of addressing centralization in cryptocurrencies, and addressing flaws in pool mining protocols. In [2] Rosenfeld et al. discussed (i) "pool hopping" in which miners hop across different pools to exploit a weakness of an old payoff scheme, and (ii) "lie in wait" attacks that allows miner to strategically calculate the time to submit his blocks. For example, in [35], Juels et al. study how smart contracts support criminal activities, e.g. money laundering, illicit marketplaces, and ransomware due to the anonymity and the elimination of trust in the platform. However, in Bitcoin network (like in any blockchain based network), some of the mined blocks could be orphan, namely, they could be transmitted to the network a short period before or after an uncle block (a block that extends the a previous block but does not reach the blockchain) was found. As new blocks might be reported with some delay, a payment request for a bulk that is verified in time n is added to the payment list of time n + 20. If the new block becomes orphan, the miner should switch back to list n. Otherwise, after six blocks he should submit a witness for block n.We note that in this approach the miner might do some stale unrewarded work in case the new block ends as an orphan block. Apart from requiring low costs, guaranteeing low variance in rewards to miners than the only related solution P2POOL, SMARTPOOL is also more secure. On the other hand, the adversary only needs to acquire 51% of P2POOL's mining power in order to build the longest share-chain in P2POOL and rule out other miners' contributions.The second application is a new cryptocurrency based on SMARTPOOL in which mining is fully decentralized. Typically, we enforce the consensus rules such that only blocks generated by SMARTPOOL are accepted valid blocks. For example, in [9][10][11] the authors demonstrate that if a malicious miner withholds blocks from a victim pool and mines privately in other pool, the miner can earn more profits from the loss of miners in the victim pool.