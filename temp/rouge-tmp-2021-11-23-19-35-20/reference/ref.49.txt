Detecting differences between two binary executables (binary diffing), first derived from patch analysis, have been widely employed in various software security analysis tasks, such as software plagiarism detection and malware lineage inference. Existing ways rely on either comparing runtime behaviors or modeling code snippet semantics with symbolic execution. Our approach improves existing semantics-based binary diffing by 1) inferring whether two executable bi-naries' behaviors are conditionally equivalent; 2) detecting the similarities or differences, whose effects spread across multiple basic blocks. For example, the difference between a pre-batched binary and its updated version reveals the fixed vulnerability [23,54], and such information can be exploited by attackers to quickly generate "1-day" exploit [9,50]. Relentless malware developers typically apply various obfuscation schemes (e.g., packer, polymorphism, metamorphism, and code virtualization) [51,57] to camouflage arresting features, circumvent malware detection, and impede reverse engineering attempts. Therefore, an obfuscation-resilient binary diffing method is of great necessity.Pervasive code obfuscation schemes have driven binary diffing methods towards detecting semantic similarity despite syntactical difference (e.g., different instruction sequences or byte N-grams). Furthermore, dynamic-only methods neglect subtle differences that do not reflect on the behavior change. At a high level, it represents the input-output relations of a basic block as a set of symbolic formulas, which are later proved by either a constraint solver [41,15,25,43], random sampling [54] or hashing [37] for equivalence. Although these tools are effective against moderate obfuscation within a basic block, such as register swapping, instruction reordering, instruction substitution, and junk code insertion [51], they exhibit a common "block-centric" limitation [13,37]; that is, it is insufficient to capture the similarities or differences that go beyond a single basic block boundary. This issue stems from the fact that the effect of code transformations spreads across basic blocks, such as return-oriented programming encoding [40,55], virtualization obfuscation's decode-dispatch loop [61], covert computation [59], and different implementation algorithms [56]. Note that the behaviorrelated instruction segments typically bypass the boundary of a basic block so that we are more likely to detect similarities or differences that spread across basic blocks.More precisely, we run two executables in tandem under the same input and environment to record their detailed execution data. Then, we rely on an advanced bioinformatics-inspired approach [34] to perform system call sequence alignment. Our enhanced backward slicing considers many tricky issues and deals with obfuscation schemes that cause undesired slice explosion. determining whether two matched system calls are truly equivalent under current path conditions boils down to a query of equivalence checking.We have developed a prototype of BinSim on top of the BitBlaze [66] binary analysis platform. The results show that BinSim can successfully identify fine-grained relations between obfuscated malware variants. • BinSim presents a novel concept, System Call Sliced Segment Equivalence Checking, that relies on system or API calls to slice out corresponding code segments and then checks their equivalence with symbolic execution and constraint solving. Therefore, BinSim overcomes the "block-centric" limitation (Existing Method 2) to a great extent. We will show C code for understanding motivating examples even though BinSim works on binary code. Binary diffing methods based on behavior features (e.g., system call sequence or dependency graph) are prevalent in comparing obfuscated programs, in which the accurate static analysis is typically not feasible [48]. That means the input value y for NtWriteFile in Figure 1(a) and Figure 1(b) differs when x < 0. Another type of semantics-aware binary diffing utilizes symbolic execution to measure the semantics of the binary code. In contrast, symbolic execution on a larger scope, such as a function, has two challenges: 1) recognizing function boundary in stripped binaries [5]; 2) performance bottleneck even on the moderate size of binary code [46]. Figure 3 presents such an example, which contains three different implementations to count the number of bits in an unsigned integer (BitCount). When a basic block produces multiple output variables, existing block-centric binary diffing approaches try all possible permutations [54,41,25] to find a bijective mapping between the output variables. The chain of ROP gadgets will result in a set of small basic blocks. Virtualization obfuscation decode-dispatch loop [61,79] generates a sequence of basic blocks to interpret one x86 instruction. To walk around this obstacle, we identify the possible cryptographic functions from the sliced segments and decom- out (a, b) in (a, b) out (c) = (i+1) -(j << 2) BB1:BB2:a = i + 1 b = j << 2 c = a -b (b) in (i', j') out (a', b') in (b', a') out (c') = (j' << 2) -(i' + 1) BB1':BB2':a' = i' + 1 b' = j' << 2 c' = b' -a'Semantically different pose them from equivalence checking (step 3). The results of the three programs are shown as follows.ψ 1a : x + x ψ 1b : 2 × ((x ∧ (x >> 31)) − (x >> 31)) ψ 1c : x << 1To verify whether ψ 1a = ψ 1b , we check the equivalence of the following formula:x + x = 2 × ((x ∧ (x >> 31)) − (x >> 31)) (1)Similarly, we check whether ψ 1a = ψ 1c by verifying the formula:x + x = x << 1 (2)The constraint solver will prove that Formula 2 is always true but Formula 1 is not. Therefore, we have ground truth that the NtWriteFile in Figure 1 Figure 3 have been unrolled. Figure 5: System call sliced segment equivalence checking steps: (1) system call alignment; (2) dynamic slicing and weakest precondition calculation; (3) cryptographic function detection; (4) equivalence checking; (5) cryptographic function approximate matching. Syscall2 (arg1) Syscall2' (arg1) . . . . . . (1) (1) (3) (2) (2) (4)(5) BinSim's online logging stage records the needed information for the subsequent steps. The logged trace data consist of three parts: 1) instruction log contains each executed instruction's x86 opcode and values of operands; 2) memory log stores memory access addresses, which facilitate binary code slicing; 3) system calls invoked and their data flow dependencies. For example, a common optimization adopted by the offline symbolic execution is "function summary" [10]. To remove system call noises, we leverage Temu's customizable multi-tag taint tracking feature to track data flow dependencies between system calls. For example, although NtClose takes an integer as input, the source of the parameter should point to an already opened device rather than an instruction operand (see Figure 1). Therefore, the fake dependency such as "xor eax, eax; NtClose(eax);" will be removed. It explicitly represents the setting of the eflags register bits, which favors us to identify instructions with implicit control flow and track ROP code. The latest work, MalGene [34], tailors Smith-Waterman local alignment algorithm [65] to the unique properties of system call sequence, such as limited alphabet and sequence branching caused by thread scheduling. The output for each processing: (1) unpacked code, instruction log, memory log, and system call sequences; (2) IL traces and initial matched system call pairs; (3) weakest preconditions of system call sliced segments; (4) identified cryptographic functions.morphism [14] and tree automata inference [3] are orthogonal to our approach. However, compared to the source code slicing, dynamic slicing on the obfuscated binaries is never a textbook problem. Furthermore, the decode-dispatch loop of virtualization obfuscation will also introduce many fake control dependencies. Our solution is to split data dependencies and control dependencies tracking into three steps: 1) index and value based slicing that only consider data flow; 2) tracking control dependencies; 3) remove the fake control dependencies caused by virtualization obfuscation code dispatcher.BinSim shares the similar idea as Coogan et al. [19] in that we both decouple tracing control flow from data flow when handling virtualization obfuscation. The index based slicing, like the conventional approach, follows the ud-chain related the memory index. For the example of mov edx [4*eax+4], the instructions affecting the index eax will be added. In addition to explicit conditional jump instructions (e.g., je and jne), obfuscators may hide control flow into indirect jumps by using encoding function to calculate the real branch [78]. For example, cmovne ebx,edx moves the value of edx to ebx according to zf flag. We also notice a case that the conditional logic is implemented without eflags: jecxz jumps if register ecx is zero. Virtualization obfuscation, a great challenge to binary code slicing [61,79], replaces the original binary code with new type of bytecode, and a specific interpreter is attached to interpret each bytecode. However, cryptographic functions have been known to be a barrier to SMT-based security analysis in general [11,72] because of the complicated input-output dependencies. We observer that cryptographic function execution has almost no interaction with system calls except the ones are used for input and output. Inspired by Caballero et al.'s work [11], we do a "stitched symbolic execution" to walk around this challenge. Inductively, we first calculate wp(i n , P) = P n−1 , then wp(i n−1 , P n−1 ) = P n−2 and until wp(i 1 , P 1 ) = P 0 . We remove the identified opaque predicate to reduce the size of the WP formula. Therefore, we maintain a HashMap structure to cache the results of the previous comparisons for better performance.To quantitatively represent different levels of similarity and facilitate our comparative evaluation, we assign different scores (0.5 ∼ 1.0) based on the already aligned system call sequences. The precision is to measure how well BinSim identifies different malware samples; while recall indicates how well BinSim recognizes the same malware samples but with various obfuscation schemes. The value of Sim(a, b) ranges from 0.0 to 1.0. 4 Different implementations BitCount (Figure 3) isPowerOfTwo (Appendix Figure 12) flp2 (Appendix Figure 13) 5 Covert computation [59] Synthetic benchmarks 6 Single-level virtualization VMProtect [69] 7 Multi-level virtualization Synthetic benchmarks collected from the reference [79] 5 We conduct our experiments with several objectives. We integrate FakeNet [63] into Temu to simulate the real network connections, including DNS, HTTP, SSL, Email, FTP etc. Intra-basic-block obfuscation methods (Type 1) have been well handled by semantics-based binary diffing tools. We investigate the source code to make sure they are different, and each sample can fully exhibit its malicious behavior in the runtime. We first test how their similar scores change from right pairs to wrong pairs. The comparison results reveal a similar pattern for all these seven binary diffing tools: a large absolute difference value between the right pair score and the wrong pair score. CoP and iBinHunt use symbolic execution and theorem proving techniques to match basic blocks, and therefore are resilient to intra-basic-block obfuscation (Type 1). This disadvantage is further manifested by our large-scale malware comparisons, in which we find out 11% variants are conditionally equivalent. CryptoWall is a representative ransomware family, and it is also continuously evolving. After investigating BinSim's output, we find out that CryptoWall.d reveals three distinct behaviors: 1) "query-then-infect": it will terminate execution if the infected machine's UI languages are Russian, Ukrainian or other former Soviet Union country languages (via GetSystemDefaultUILanguage). The dataset is retrieved from VirusShare 6 and analyzed at February 2017. Because BinDiff, DarunGrim, and CoP cannot directly work on the packed binary, we provide the unpacker binaries preprocessed by BinSim's generic unpacking.In most cases, dynamic-only methods and BinSim are able to find small distances among intra-family samples. Actually, we successfully identify that about 11% of malware samples have so-called "query-then-infect" behaviors [77], and BinSim is able to find whether two malware variants are conditionally equivalent. Win32.Zbot variants. Performing the intra-family comparisons on 1, 050 malware samples required approximately 3 CPU days. Like other malware dynamic analysis approaches, BinSim bears with the similar limitations: 1) incomplete path coverage; 2) environment-sensitive malware [34,35] which can detect sandbox environment. One possible solution is to design a layered architecture to capture alternative events that achieve the same high-level functionality. BinSim's enhanced slicing algorithm handles the obfuscations that could break the block-centric binary comparisons. An attacker can also customize an unknown cryptographic algorithm to evade our cryptographic function approximate matching. To evaluate the accuracy of backward slicing, they compare the x86 instruction slicing pairs by the syntax of the opcode (e.g., mov, add, and lea). Hunting binary code difference have been widely applied in software security. iBinHunt [43] is an inter-procedural path diffing tool and relies on multi-tag taint analysis to reduce possible basic block matches. As we have demonstrated, these tools suffer from the so called "block-centric" limitation. We present a hybrid method combining dynamic analysis and symbolic execution to compare two binary execution traces for the purpose of detecting their fine-grained relations. Our comparative evaluation demonstrates BinSim is a compelling complement to software security analysis tasks. The grey basic blocks represent the main loop bodies, which are not matched by "block-centric" binary diffing tools.