Our attack only requires a device connected to the Internet via a wireless router, and be reachable from an attack server (e.g., indirectly so by ac-cessing to a malicious website). One of the most noteworthy cases is CVE-2016-5696 [18] where a completely blind off-path attacker can infer whether two arbitrary hosts on the Internet are communicating using a TCP connection. Fundamentally, like any side channel vulnerabilities, these vulnerabilities are introduced by shared resources between the attacker and victim.In the case of TCP, for example, a server has many kinds of shared resources implemented by operating systems such as a global IP ID counter [1,25,23], SYN cache and RST limit [24], SYN-backlog [33], and challenge ACK rate limit [18]. These resources are shared on a host between a connection established with the attacker and a connection with the victim.When the attacker sends spoofed packets to the server that appear to come from the victim, these shared resources are used differently, depending on the validity of the spoofed packets (e.g., in-window vs out-of-window sequence number). We also open sourced the attack implementation at [5] to assist the reproduction and further research of the work.The contributions of the paper are the following:• We report the timing side channel inherent in all generations of IEEE 802.11 or Wi-Fi technology. • We show that the side channel affects macOS, Windows, and Linux by studying the overlaps and differences in their TCP stack implementations. The off-path attacker, Mallory, is capable of sending spoofed packets with the IP address of the legitimate server. In contrast to Man-inthe-middle attack, Mallory cannot eavesdrop the traffic transferred between a client C and a server S. Depending on the nature of the side channel, an unprivileged application or a sandboxed script may be required to run on the client side [40,27] to observe the results of the shared state change and determine the outcome of the spoofed packets (e.g., whether guessed sequence numbers are inwindow). After multiple rounds of inferences, starting from whether a connection is established (four tuple inference) to the expected sequence number and ACK number inference, the attacker can then inject a malicious payload that becomes acceptable to the client at the TCP layer. Two necessary building blocks are needed in a TCP off-path side channel attack: (1) existence of vulnerable packet validation logic; (2) the shared state has to be observable by an attacker (i.e., the sandboxed script, unprivileged app, or the off-path attacker). It involves primarily three types of checks, and each of them has some form of vulnerable logic -different actions are taken depending on the outcome of the check (e.g., a response packet is sent vs. not). Upon receipt of this challenge ACK, a legitimate remote peer who truly lost its connection, after a restart, sends a RST packet back with the sequence number derived from the ACK field of the challenge ACK, which can terminate the connection at that point. The challenge ACK is hence a defense against blind off-path attacks that attempt to terminate a connection forcefully through spoofed SYN packets. Thus, an attacker only needs to guess two ACK numbers for every guessed sequence number to successfully inject data into a connection, resulting in a guaranteed successful data injection with up to 2 ⇤ 2 32 /RCV.WND 2 spoofed data packets. This creates a side channel that allows an attacker to count how many outgoing 1 SND.UNA: the sequence number of the first byte of data that has been sent but not yet acknowledged; SND.NXT: the sequence number of the next byte of data to be sent 2 RCV.WND: size of receive window 3 The window can be as small as a few thousand bytes, which makes the guess much more difficult Table 1: Summary of Different Off-Path TCP Side Channel Attacks including the one we propose in this paper packets have been sent during a time interval, through diffing the queried IPIDs of a Windows machine. Using IP spoofing, an off-path attacker can tell whether the guess is correct based on whether a response is triggered.However, at the time of writing, we experimentally verify that Windows 10 has finally eliminated this side channel by adopting a safer IPID generation algorithm similar to that used in Linux [33], where connections destined for different IP addresses will no longer share the same IPID counter. (3) HTTP pipeline is required so that a response arrives ahead of time will be deemed valid.This attack no longer works because the first culprit is eliminated by most modern operating systems (including Windows, Linux, Android), which adopted a more stringent check on ACK numbers as defined in RFC 5961 where only a much smaller window is considered valid. • Global challenge ACK rate limit. For instance, to infer if an ongoing connection exists, an off-path attacker can initially send a spoofed packet with one guessed port number and SYN bit set; after the attacker sends another 100 4 non-spoofed in-window RST packets to exhaust the challenge ACK count, it can then observe the number of responses to tell whether its initial spoofed packet matches the four tuples of an ongoing connection and hence triggers a challenge ACK.Since the shared rate limit is a simple software artifact, shortly after the vulnerability was reported, it was eliminated in a patch introduced in Linux 4.6 [8,42] where a per-socket rate limit is used instead. These attacks require a piece of unprivileged malware to run on the client machine that can access these packet counters and use them as feedback for spoofed packets sent by the off-path attacker. For macOS, the side channel vulnerability has recently been assigned CVE-2017-13810 and patches have been pushed out to zero the sensitive counters [9,10]. By sharing the same set of frequency bands with both directions, Wi-Fi relies on carrier-sense multiple access (i.e., CSMA) to share/-divide the channel over time. This effectively creates a timing channel that delays the local transmission if the opposite direction is transmitting at the same time.Even worse, this timing difference becomes more visible due to retransmissions caused by contention (collision). As we can see in Fig. 3a, we simulate an off-path TCP attack where the attacker sends a spoofed probing packet, along with a pre-probe query and postprobe query to measure the RTT before and after. In addition to the RTT difference (RT T 2 > RT T 1), we can also measure the gap between the replies of the first query and the second, which should capture the delay effects similarly.In Fig. 3b, we also illustrate the amplifiable nature of the timing channel where the attacker sends two spoofed probing packets, causing more contention which delays post-probe query even further.In summary, this side channel allows an attacker to determine if the spoofed probing packets have triggered any response or not, coincidentally achieving the same purpose as the global IPID counter on Windows (which is no longer available). We used 4 different wireless routers (from Linksys, Huawei, Xiaomi, and Gee): all latest generations that support 802.11ac and 802.11b/g/n. On average, we can see that the timing difference for RTT is about 1 to 3ms when the number of probing packets is 30 or more. Half-duplex vs. Full-duplex To better understand that the significant part of the RTT difference is due to the half-duplex nature of wireless rather than the processing time to generate an ACK response on the client, we also conducted an experiment with the setup where both the victim and attacker machine connect to a Huawei router via ethernet. The experiment demonstrates that contention caused by half-duplex is the root cause of the timing channel. Based on this threat model, we consider a number of related attack goals:(1) inferring the presence of a connection from the client to a server (connection inference);(2) counting the number of bytes exchanged on the connection, or forcefully terminating the connection (sequence/ACK number inference); (3) injecting malicious payload into a connection (ACK number inference). It relies on the basic design principle that browsers reuse TCP connections for requests sent to the same server IP address. Afterwards, the puppet can embed a target web object in the page, e.g., <iframe src = "www.bank.com/index.html" /> This triggers an HTTP request over the same old TCP connection; the off-path attacker can now simply inject a fake HTTP response that will be cached for arbitrarily long, because the HTTP response header can ask the browser not to re-check the freshness of the object, leading to a persistent cache poisoning 5 . First, clients connected through Wi-Fi are almost always behind NAT and/or firewall (the wireless router itself often acts as NAT). This actually simplifies the connection inference, as the attacker can simply choose to send spoofed packets that always trigger responses (e.g., incoming SYN packets); if there is no response, it must be the case that no connection exists and packet is dropped by a NAT.For the second problem of real operating system implementations, we survey the latest Linux, macOS, and Windows in terms of their packet validation logic. MacOS is similar to Linux except that it does not implement rate limit and is in general weaker in its validation logic. Based on the concrete testing results, we conclude that all three operating systems have packet validation logic that can be exploited via the Wi-Fi timing channel. As with previous off-path TCP exploits [25,18], the first step is to infer whether an ongoing connection with a particular target (server IP and server port are given) exists. Indeed, from the table, an incoming ACK matching an ongoing connection with an out-of-window sequence number is guaranteed to trigger an ACK on all operating systems (row no. 1, 10, and 17)). For Linux, if 10 incoming ACK packets with just one-byte payload are received, depending on their sequence numbers, 10 responses are triggered (out-of-window), or at most 1 (in-window) due to rate limiting (row no. 1, 2, and 3). For macOS, if an incoming packet with no flags is received, a response is triggered for the out-of-window case; otherwise no response is triggered (row no. 10 and 11 Windows ACK In-window In-window 0 0 ⇤ : Due to rate limit in Linux, we can get at most 1 response per half a second. As shown in Table 2, instead of always triggering an ACK packet for out-of-window ACK numbers, when the ACK number is too old (smaller than SND.UNA -MAX.SND.WND), Linux responds with an ACK (with rate limit); when the ACK number is too new (larger than SND.NXT), Linux incorrectly drops the packet without any reply (row no. 2 and 3). In addition, if a packet with in-window ACK number has no payload, Linux also ignores the packet with no response (row no. 6), which leaves no opportunity to differentiate the in-window and out-of-window cases (result similar to row no. 2 and 3). Therefore, in-window ACK numbers with the specific sequence number (i.e., RCV.NXT-1) still trigger responses (row no. 9) and yet no actual data are buffered at the client, while out-of-window ACK numbers can trigger at most one reply (line 7 and 8 in Table 2). Based on the source code and experiments, macOS explicitly handles keep-alive packets and always responds with an ACK regardless of the ACK number so the strategy against Linux does not apply to macOS. The implementation of macOS is likely to be misled by the old statement in RFC 793 that states packets with ACK numbers smaller than SND.UNA can be ignored, which is reinterpreted in RFC 5961 (quote): "All incoming segments whose ACK value doesn't satisfy the above condition MUST be discarded and an ACK sent back", where the "above condition" is the acceptable window of [SND.UNA -MAX.SND.WND, SND.NXT]. In summary, this non-compliant behavior of macOS allows an attacker to infer if a guessed ACK number is too large or too small, resulting in a binary search. This makes our attack in §5.3 more complicated but still possible by taking advantage of the behaviors in row no. 18 and 24. Now that we know the Wi-Fi timing side channel applies universally to all operating systems, we want to test them in real-world attack scenarios. They use a global and sequential port allocation strategy to select ephemeral port number for their TCP connections. To avoid bruteforcing all possible port numbers, we develop an optimized strategy based on the observation that local port numbers allocated for the same remote server and port pair are sequential; therefore, the puppet can potentially create n connections to the target server and only needs to test the port number every n increments.At this point, we can conduct the side channel attack on the connection of which we guessed the correct port number. In our experience with Wi-Fi routers, we find that they typically are port preserving. This is based on our testing of 4 different home routers and the university network. Upon the receipt of enough full segments, the receiver would significantly increase its receive window size according to TCP flow control. In our experiments, we found that the window size could be typically scaled up to around x = 500, 000, in striking contrast to the original size (e.g., 65, 535). In principle, the attacker can hijack any connection initiated by the client; it is simply more difficult to control the timing and predict what fake response to inject.Since all three systems do not comply with the specifications in terms of ACK validation, we have to cope with each variant differently: MacOS incorrectly interpreted the standard, allowing us to perform a binary search (see §4). Chrome will close the connection, stopping the attack; in contrast, Firefox will simply accept the first response, ignoring the second one, resulting in desynchronization between the client and server (i.e., the client believes it has received more data than the server has actually sent). Note that this strategy requires two rounds of bruteforcing of every possible ACK number, and each round takes only a couple of seconds as there is no waiting. When the browser executes the injected script, it will send the guessed ACK number via websocket, providing a valid in-window ACK number. Latency may vary under different network conditions, thus it is a bad idea to manually set a threshold to differentiate a quiet probe round (without triggering ACKs) versus a responsive probe round (triggering ACKs). Since we have full control of the connection established between the client and attacker, we can send non-spoofed packets to measure RTTs for quiet probe rounds and responsive probe rounds. Since most of the rounds we're testing do trigger ACKs (so larger RTTs should be observed), setting a lower threshold will ensure that we correctly classify such cases to avoid double checking the results. During the procedure, we also simultaneously measure additional RTTs (using out-of-window sequence numbers) and their relative difference to the RTTs (using in-window sequence numbers). Pipeline In order to significantly reduce the time the attack costs, instead of simply probing a single SEQ/ACK number at a time, we also use a pipelined process aiming at maximizing network utilization by scheduling probing packets for multiple targets at appropriate times. However, due to the fact that packet loss may happen from time to time, we suspend the procedure every few tests to wait until we get all the results or restart in a fixed time interval.Moving SEQ/ACK window and unknown window size Since the victim connection is controlled by the puppet, it's idle most of the time unless the puppet triggers a request. We empirically evaluated different techniques with Chrome 64.0 and Firefox 58.0.1. Second, as 2.4GHz networks tend to influence each other, we have also conducted the measurement in the lab where there were 43 accessible Wi-Fi in total, 22 of which were 2.4GHz network and 6 used the same channel that our test router used; there were also more than 10 students actively using the network. Although Google Chrome marks some non-HTTPS sites as "not secure", we still found some sensitive bank websites (e.g., www.icbc.com.cn) that haven't deployed HTTPS on all of its pages, rendering them vulnerable to our attack. Furthermore, even if HTTPS is deployed on all pages, attackers could still mount the attack, as long as HTTP Strict Transport Security (HSTS) is absent; this is because the initial request to the website will still use HTTP and it is the server that subsequently redirects the browser to its HTTPS site. Fig. 10 presents the results of measurements at two different locations in the same city. Besides longer RTTs compared to that of a local setup, the significant time cost is attributed to the following factors: (1) Regarding sequence number inference upon MacOS, though an attacker can send probing packets without any flags as shown in table 2, we found those packets are likely to be discarded in a real-world network environment. As discussed in §3, the timing side channel results from the half-duplex nature of wireless networks. Finally, as confirmed in our test routers, modern wireless routers all support CSMA/CA and RTS/CTS as it is part of the 802.11 standards [31], and the principle is unlikely to change any time soon.Although we only discuss the threat model where connections originated from a victim client are targeted, the attack actually also applies to connections originated from other clients connected through the same wireless router. After we discovered the time side channel issue, we have disclosed it to the working group in February 2018. However, due to the expected challenges in changing the half-duplex design, we are yet to see an appropriate solution at the 802.11 level. For instance, with frequency-division duplexing, different frequency sub-bands can be used for uplink and downlink traffic. At this point though, it is unclear when the technology will be widely deployed in practice, according to our conversation with the 802.11 working group.Defenses in the TCP stacks. Other TCPlevel attacks (e.g., inferring presence of connection [18], byte counting [20], connection reset [18]) could still be mounted by exploiting the vulnerability. HSTS and HTTPS can prevent only web cache poisoning attack (application-layer attacks) but not the TCP-level attacks.Some versions of our attack also exploit features of browser implementations, and thus we believe some mitigations can be made in the browser (i.e., make parsing of responses stricter) to complicate the ACK number inference step. The idea is that whenever the browser observes anything abnormal regarding the responses, e.g., malformed or longer than expected, it should immediately drop the connection and restart. Finally, connection inference (privacy breach) and sequence number inference (byte counting and reset) attacks remain potent as they only rely on the TCP stack.For the purpose of supporting further research to reproduce and mitigate the attack, we open sourced our implementation of the attack against different OSes, now publicly available at [5]. For instance, static taint analysis has been applied to look for TCP packet counter side channels [19]. To conclude, we have discovered a subtle yet fundamental side channel inherent in all generations of Wi-Fi or IEEE 802.11 technology because they are half-duplex. Our study reveals that this novel attack affects all three most popular operating systems: macOS, Windows, and Linux.