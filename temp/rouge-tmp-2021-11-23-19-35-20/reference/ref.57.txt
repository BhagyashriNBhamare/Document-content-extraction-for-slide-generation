We present Loopix, a low-latency anonymous communication system that provides bi-directional 'third-party' sender and receiver anonymity and unobservability. Service providers mediate access in and out of the network to facilitate accounting and off-line message reception. We show that mix nodes in Loopix can handle upwards of 300 messages per second , at a small delay overhead of less than 1.5 ms on top of the delays introduced into messages to provide security. As illustrated by recent leaks of extensive mass surveillance programs 1 , exposing such meta-data leads to significant privacy risks.Since 2004, Tor [20], a practical manifestation of circuit-based onion routing, has become the most popular anonymous communication tool, with systems such as Herd [33], Riposte [11], HORNET [10] and Vuvuzela [46] extending and strengthening this paradigm. Moreover, the system needs to be scalable to a large number of clients, which makes classical approaches based on synchronized rounds infeasible.For this reason we reexamine and reinvent mix-based architectures, in the form of the Loopix anonymity system. Message delay and the ratio of cover to real traffic can all be flexibly traded-off against each other to offer resistance to traffic analysis. Loopix is a mix network [8] based architecture allowing users, distinguished as senders and receivers, to route messages anonymously to each other using an infrastructure of mix servers, acting as relays. This means that incoming messages can be retrieved at any time, hence users do not have to worry about lost messages when they are offline. This approach does not require the synchronization of client-provider rounds and does not degrade the usability of the system for temporarily off-line clients. This adversary is able to observe the entire network infrastructure, launch network attacks such as BGP re-routing [4], or conduct indirect observa- Corrupt provider Insider Sender-Recipient Third-Party Unobservability Sender online unobservability • Sender anonymity Receiver unobservability• Receiver anonymity • Table 1: The summary of security properties of the Loopix system in face of different threats. In Loopix, we assume that a fraction of mix/provider relays can be corrupted or are operated by the adversary.Finally, the adversary has the ability to participate in the Loopix system as a compromised user, who may also deviate from the protocol. We assume that the adversary can control a limited number of such userseffectively excluding Sybil attacks [22] from the Loopix threat model-since we assume that honest providers are able to ensure that at least a large fraction of their users base are genuine users faithfully following all Loopix protocols. The Loopix system aims to provide the following security properties against both passive and active attacksincluding end-to-end correlation and (n − 1) attacks. We define sender-receiver third party unlinkability as the inability of the adversary to distinguish whether {S 1 → R 1 , S 2 → R 2 } or {S 1 → R 2 , S 2 → R 1 } for any online honest senders S 1 , S 2 and honest receivers R 1 , R 2 of the adversary's choice.Loopix provides strong sender-receiver third-party unlinkability against the GPA even in collaboration with corrupt mix nodes. We refer to Section 4.1.3 for our analysis of the unlinkability provided by individual mix nodes, Section 4.3 for a quantitative analysis of the sender-receiver third-party unlinkability of Loopix against the GPA and honest-but-curious mix nodes, and Section 4.2 for our discussion on malicious mixes performing active attacks.Sender online unobservability. Loopix provides sender anonymity even in light of a conversation insider, i.e., against a corrupt receiver.Receiver unobservability. We define receiver unobservability as the inability of an adversary to decide whether any sender is communicating with a specific receiver R {→ R} or not {{ → R}, for any online or offline honest receiver R of the adversary's choice.Loopix provides strong receiver unobservability against the GPA, under the condition of an honest provider. On the downside, higher-level applications using Loopix need to take care of reliable end-to-end transmission and session management. We leave the detailed study of those mechanisms as future work.The provider-based architecture supported by Loopix aims to enable managed access to the network, anonymous blacklisting to combat abuse [27], and payments for differential access to the network [2]. In this section we describe the Loopix system in detail- Figure 1 provides an overview. We consider a population of U users 3 If the receiver's provider is honest, Loopix provides a form of receiver anonymity even in light of a conversation insider: a corrupt sender that only knows the pseudonym of a receiver cannot learn which honest client of a provider is behind the pseudonym. In order for a sender S i , with a key pair (sk S i , pk S i ), to send a message to a receiver R j , with a key pair (sk R j , pk R j ), the sender needs to know the receiver's Loopix network location, i.e., the IP address of the user's provider and an identifier of the user, as well as the public encryption key pk R j . All messages are padded to the same length, which hides the path length and the relay position and guarantees unlinkability at each hop of the messages' journey over the network. The structure of the header consists of (I) a single element of a cyclic group that is re-randomized at each hop, (II) an onion-encrypted vector, with each layer containing the routing information for one hop, and (III) the message authentication code MAC i , which allows header integrity checking. Thanks to the message authentication code in the header and the LI-ONESS encryption the Sphinx packet format thus allows for detection of tagging attacks. Sphinx packet generation: The sender, given the public keys of the recipient and the nodes in the path, computes the sequence of shared secrets and blinded group elements. The sender concatenates the computed header and onion-encrypted payload encapsulating confidential message to send to the recipient. For each hop in the path the sender samples a delay from an exponential distribution with parameter µ, and includes it in the vector of routing commends, together with any other auxiliary information, to the corresponding relay. Our design guarantees that all outgoing traffic sent by users can by modeled by a Poisson process.To send a message, a user packages their message into a mix packet and places it into their buffer-a first-infirst-out (FIFO) queue that stores all the messages scheduled to be sent.Each sender periodically checks, following the exponential distribution with parameter 1 λ P , whether there is any scheduled message to be sent in their buffer. These are routed through the network and looped back to the senders (the upper four red arrows in Figure 1), by specifying the sending user as the recipient. The mail client, besides sending the messages, generates constant streams of loop and drop cover traffic, independently of the user activity. Mix servers inject mix packets that are looped through a path, made up of a subset of other mix servers and one randomly selected provider, back to the sending mix server, creating a second type of "loop". This loop originates and ends in a mix server (shown as the lower four green arrows in Figure 1). Otherwise, the unwrapping function returns the replay detection tag and the vector of routing commands, as well the new packet. Users, when online, poll providers or register their online status to download a fixed subset of stored messages, allowing for the reception of the off-line messages. Loopix leverages cover traffic to resist traffic analysis while still achieving low-to mid-latency. Decoded mix packets are not forwarded immediately, but each of them is delayed according to a source predetermined delay d i . Honest clients and mixes generate drop cover traffic, loop traffic, and messaging traffic following a Poisson process. It has a rate λ n depending on the number of clients and the number of mix nodes.Since this input process is a Poisson process and each message is independently delayed using an exponential distribution with parameter µ, the Poisson Mix may be modeled as an M/M/∞ queuing system -for which we have a number of well known theorems [5]. By the steady state we mean the state of the system in which all entities have already generated and processed messages for some reasonable period of time. Conceptually, every message sent or received leads to a pool within which messages are indistinguishable due to the memoryless property of the exponential delay distribution.Lemma 2 (Memoryless property [34]). For an exponential random variable X with parameter µ holdsPr[X > s + t|X > t] = Pr[X > s]. As illustrated in Figure 3, the receiving event i − 1 leads to a pool of messages i − 1, until the sending event i. From the perspective of the adversary observing all inputs and outputs, all messages in the pool i−1 are indistinguishable from each other. While Loopix operates asynchronously by design, we now consider a synchronous Loopix variant that operates in discrete rounds and thus cannot use the exponential mixing strategy, where delays attached to the packets are drawn from a continuous distribution. In this section we present the analytical and experimental evaluation of the security of Loopix and argue its resistance to traffic analysis and active attacks. Loopix relies on the Sphinx packet format [16] to provide bitwise unlinkability of incoming and outgoing messages from a mix server; it does not leak information about the number of hops a single message has traversed or the total path length; and it is resistant to tagging attacks.For Loopix, we make minor modifications to Sphinx to allow auxiliary meta-information to be passed to different mix servers. Since clients send also streams of cover traffic messages with rates λ L for loops and λ D for drop cover messages, the traffic sent by the client follows Pois (λ P + λ L + λ D ). Thus, we achieve perfect sender unobservability, since the adversary cannot tell whether a genuine message or a drop cover message is sent.When clients query providers for received messages, the providers always send a constant number of messages to the client. Note that, as long as the providers are hon- est, the protection and receiver unobservability is perfect and the adversary cannot learn any information about the inbox and outbox of any client.Corrupt providers: We distinguish the sender's and recipient's providers by calling them the ingress and egress providers respectively. From the properties of Poisson mix, we know that the number of messages in the mix server at a steady state depends on the ratio of the incoming traffic (λ ) and the delay parameter (µ) (from Section 3.3). Next, l additional messages arrive at the mix before any message leaves, and the pool now mixes k + l messages. Let m 1 be any of the initial n messages in the mix node in scenario o n,k,l , and let m 2 be any of the l messages that arrive later. We leverage those results for a single Poisson Mix to simulate the information propagated withing a the whole network observed by the adversary (c.f. Section 4.3). We simulate the dependency between entropy and traffic rate for different mix delay parameter µ by recording the traffic flow and changing state of the mix node's pool. Higher delay also results in an increase in entropy, denoting a larger potential anonymity set, since more messages are mixed together.In case the mix node emits loop cover traffic, the adversary with observation o n,k,l , tries to estimate the probability that the observed outgoing message is a particular target message she observed coming into the mix node. We conclude that the loops generated by the mix node obfuscate the adversary's view and decrease the probability of successfully linking input and output of the mix node. However, once the volume of real communication traffic λ P increases, users can tune down the rate of cover traffic in comparison to the real traffic, while maintaining a small delay and be confident their messages are mixed with a sufficient number of messages.In the previous section, we analyze the security properties of Loopix when the adversary observes the state of a single mix node and the traffic flowing through it. Therefore, an adversary that wants to perform a stealthy attack has to be judicious when blocking messages, to ensure that a fraction r of loops return to the mix node, i.e. the adversary must distinguish loop cover traffic from other types of traffic. Among them are two challenge senders S 0 and S 1 that send payload messages at a constant rate, i.e, they add one messages to their sending buffer every time unit.Whenever a challenge sender S 0 or S 1 sends a payload message from its buffer, we tag the message with a label S 0 or S 1 , respectively. In a burn-in phase of 2500 time units, the 98 senders without S 0 or S 1 communicate. 4 However, when we calculate our anonymity metric at a mix node we assume this mix node to be honest. We implement the Loopix system prototype in 4000 lines of Python 2.7 code for mix nodes, providers and clients, including unit-tests, deployment, and orchestration code. Thus, we implement Loopix as a multi-thread system, with cryptographic processing happening in a thread pool separated from the rest of the operations in the main thread loop. We believe that our empirical analysis is a more accurate assessment of real-world performance than those reported by other works, e.g. [45,46], which depend on simplish extrapolation. We have 500 clients actively sending messages at rate λ each, which is the sum of payload, loop and drop rates, i.e., Pois(λ ) = Pois(λ L + λ D + λ P ). Each packet sent through the network has a size of a few kilobytes only, but this size is a parameter that can, of course, be increased to fit the needs of a particular application.In order to measure the overall bandwidth, i.e. the number of all messages processed by a single mix node, we use the network packet analyzer tcpdump. Thus, depending on the size of the honest user population in Loopix, we can increase the rate of goodput.Latency Overhead & Scalability. End-to-end latency overhead is the cost of routing and decoding relayed messages, without any additional artificial delays. Figure 10 shows that increasing the number of online clients, from 50 to 500, raises the latency overhead by only 0.37 ms. The variance of the processing delay increases with the amount of traffic in the network, but more clients do not significantly influence the average latency overhead. Fig- ure 11 illustrates that when the mean delay 1/µ sec. is higher than the processing time (∼ 1 ms − 2 ms), the endto-end latency is determined by this delay, and follows the Gamma distribution with parameter being the sum of the exponential distribution parameter over the number of servers on the path. Simultaneously minimizing latency and communication overhead while still providing high anonymity is challenging. Designs based on Chaum's mixes [8] can support both high and low latency communication; all sharing the basic principles of mixing and layered encryption. Tor [20], the most popular low-latency anonymity system, is an overlay network of onion routers. Tor protects against senderreceiver message linking against a partially global adversary and ensures perfect forward secrecy, integrity of the messages, and congestion control. Moreover, Loopix allows off-line users to receive messages and uses parallel mix nodes to improve the scalability of the network.Stadium [45] and AnonPop [24] refine Vuvuzela; both operating in rounds making the routing of messages dependent on the dynamics of others. Stadium is scalable, but it lacks offline storage, whereas AnonPop does provide offline message storage. Riposte enjoys low communication-overhead and protects against traffic analysis and denial of service attacks, but requires long epochs and a small number of clients writing into the database simultaneously. In contrast to Loopix, it is suitable for high-latency applications.Dissent [9], based on DC-networks [9], offers resilience against a GPA and some active attacks, but at significantly higher delays and scales to only several thousand clients.Riffle [31] introduces a new verifiable shuffle technique to achieve sender anonymity. Riffle is not designed for Internet-scale anonymous communication, like Loopix, but for supporting intra-group communication.Finally, Atom [30] combines a number of novel techniques to provide mid-latency communication, strong protection against passive adversaries and uses zero knowledge proofs between servers to resist active attacks. We balance cover traffic and message delays to achieve a tunable trade-off between real traffic and cover traffic, and between latency and good anonymity. By *, we mean if the design intentionally incorporates provisions for delivery of messages when a user is offline, perhaps for a long period of time. By †, we mean that the system operates continuously and does not depend on synchronized rounds for its security properties and users do not need to coordinate to communicate together.performance. = 1 − Pr [X < d 1 ∧ X < d 2 ∧ . . . ∧ X < d n ] = 1 − Pr [X < min{d 1 , d 2 , . . . d n }](7)We know, that d i ∼ Exp(µ) for all i ∈ {1, . . . , n } and X ∼ Exp(λ M ). x A.1 Incremental Computation of the Entropy MetricLet X be a discrete random variable over the finite set X with probability mass function p(x) = Pr(X = x). Let X be a discrete random variable over the finite set X with probability mass function p(x) = Pr(X = x). The Shannon entropy H(X) [43] of a discrete random variable X is defined asLet o n,k,l be an observation as defined in Section 4.1.3 for a pool at time t.