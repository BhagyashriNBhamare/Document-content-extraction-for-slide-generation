GUARDER ensures the desired randomization entropy, and provides an unprecedented level of security guarantee by combining all security features of existing allocators, with overhead that is comparable to performance-oriented allocators. GUARDER also provides an additional feature that allows users to customize security based on their performance budget, without changing code or even recompil-ing. However, existing secure allocators, including the OpenBSD allocator [28] (which we will simply refer to as "OpenBSD"), DieHarder [30], Cling [2], and FreeGuard [33], possess their own strong deficiencies.First, these allocators provide either low randomization entropy, or cannot support a stable randomization guarantee, which indicates they may not effectively defend against heap overflows and use-after-free attacks. Although OpenBSD and DieHarder supply higher entropy levels, their entropies are not stable, and vary across different size classes, execution phases, inputs, and applications. For instance, their randomization entropy is primarily limited by bag size (e.g. DieHarder and OpenBSD), or the number of free lists (e.g. FreeGuard). In addition, GUARDER is also the first secure allocator to allow users to specify their desired security guarantee, which is inspired by tiered Internet services [8]. Existing allocators provide unstable randomization entropies because they randomly select an object from those that remain available within a bag (e.g. OpenBSD), or among multiple bags belonging to the same size class (e.g. DieHarder). The allocation buffer will simultaneously satisfy the following properties: (1) The buffer size can be easily adjusted, where a larger size will provide a higher randomization entropy; (2) The buffer size is defined independently from any size class in order to provide stable entropy for objects of different size classes; (3) It is very efficient to locate an item inside the buffer, even when given an index randomly; (4) It is more efficient to search for an available object by separating available objects from the large amount of in-use ones.However, although it is possible to place deallocated objects into the allocation buffer directly, it can be very expensive to search for an empty slot in which to do so. It will skip all objects tied to randomly-selected guard pages (and set them as non-accessible), and randomly skip objects in proportion to the user-defined over-provisioning factor. Third, it manages pointers to available objects directly within the allocation buffer, removing a level of indirection compared to existing bitmapbased (e.g. DieHarder or OpenBSD) or free-list-based (e.g. FreeGuard) approaches. It is the first allocator to support customizable security guarantees on randomization entropy, guard pages, and over-provisioning, which allows users to choose the appropriate security level based on their performance or memory budget. GUARDER implements all necessary security features of existing secure allocators, and provides around 9.89 bits of entropy, while only imposing less than 3% performance overhead and 27% memory overhead when compared to the default Linux allocator. These memory vulnerabilities can result in information leakage, denial-of-service, illegitimate privilege elevation, or execution of arbitrary code.A buffer overflow occurs when a program reads or writes outside the boundaries of an allocated object, which further includes buffer underflows. For BIBOP-style allocators, one or multiple continuous pages are treated as a "bag" that holds objects of the same size class. Further, they do not perform object splitting or coalescing, which is different from general purpose allocators, such as the default Linux allocator.These allocators also have their own unique designs, which are discussed briefly as follows.OpenBSD. OpenBSD utilizes a bitmap to maintain the status of heap objects, with each bag having a size of 4 kilobytes that is directly allocated from the kernel via an mmap system call. For large objects, defined as those larger than 2 kilobytes, OpenBSD maintains a cache of at most 64 pages in order to reduce mmap system calls.DieHarder. To our understanding, this design may hurt performance (compared to OpenBSD), as it may unnecessarily load bitmap words from different cache lines.DieHarder utilizes the over-provisional mechanism to help tolerate buffer overflows. (1) These allocators either have very limited randomization entropy (such as 2.01 bits for FreeGuard), or have unstable entropies that can vary greatly across different size classes, execution phases, executions, and applications. For example, DieHarder's entropy for 1 kilobyte objects falls between 4.8 bits (e.g. bodytrack) and 13.3 bits (e.g. fluidanimate). Since its cache only maintains a maximum of 64 pages, its entropy should be less than 6 bits if an object can be allocated from the cache.Performance and Scalability Issues. OpenBSD and DieHarder also have significant performance and scalability issues: (1) Their runtime overhead is too heavy for performance-sensitive applications, with 31% for OpenBSD and 74% for DieHarder (see Section 5.1). GUARDER further assumes the attackers have no knowledge related to the status of the heap, and cannot take control of the allocator. GUARDER will defend against a wide range of heap vulnerabilities, such as heap overflows, use-after-frees, double and invalid frees, as well as reduce heap spraying attacks.GUARDER implements almost all security features of existing secure allocators, as listed in Table 2. Compared to the state-of-the-art, GUARDER significantly increases randomization (entropy is increased by 7.8 bits, over 200 : weak implementation * : actual results of entropies can be seen in Figure 4 times), adopts the over-provisional mechanism (first proposed by DieHarder), and discards its deterministic layout. Additionally, GUARDER supports customizable security guarantees, without changing code or recompiling, which allows users to specify their desired level of security by setting the corresponding environment variables. Due to the vast address space of 64-bit machines [26,2], the address space should accommodate all types of applications.Per-thread design: GUARDER employs a per-thread heap design such that each thread has its own heap segment, and always returns freed objects to the heap belonging to the current thread. Further, metadata are randomly allocated using mmap system calls, rather than using a pre-allocated block, as in FreeGuard.More importantly, GUARDER introduces separate allocation and deallocation buffers for each size class of each thread, which is a key difference between GUARDER and other secure allocators. The idea of the allocation buffer is inspired by Stabilizer [11], but with a different design to reduce unnecessary allocations and deallocations, and support customizable securities.GUARDER designs the allocation buffer as follows: its capacity will be set to 2 E+1 (not 2 E ), and ensures it will never fall below half-full. Because there is no need to search for an available slot, the deallocation step will be completed in constant time.The allocation buffer will be filled after each allocation if at least one free object exists in the corresponding deallocation buffer. The empty slot created by the allocation will be filled immediately, which helps reduce the number of trials needed to find an available object during allocations. The allocation buffer will also be filled when the number of available objects falls below 2 E , in order to ensure the randomization guarantee. First, GUARDER separates the metadata from the actual heap, making it impossible to issue use-afterfree attacks on freelist pointers. Second, its strong randomization makes meaningful attacks extremely difficult, with only a 0.11% success rate per try due to its 9.8 bits of entropy, as evaluated in Section 5.4. Currently, 9 bits of entropy are chosen by default, and GUARDER guarantees that the number of available objects will never be less than 512 (2 9 ), where each buffer has 1024 entries.Object selection is performed as follows: upon every allocation, a random index into the allocation buffer is generated. The required number of searches is expected to be around two on average, given the fact that the allocation buffer is never less than half-full. Over-provisioning is a technique in which a certain number of heap objects are designated as never-to-be-used. For instance, the over-provisioning factor is set to 1/8 by default, resulting in 1/8 of objects from each bag being skipped. Then, the specified proportion (e.g., 1/8) of these objects will be deleted from this buffer randomly, and will never participate in future allocations or deallocations. OpenBSD designs each bag to occupy a single page, which practically places guard pages between bags.Different from FreeGuard, GUARDER supports a flexible ratio of guard pages, obtained from an environment variable. If a size class exceeds one page, then multiple pages (equaling the size class) will be protected in order to not change the mapping between objects and their metadata. Due to complexities brought by memalign, GUARDER treats any address within a valid object as a valid free, and consequently frees the object, which is similar to DieHarder.Note that GUARDER may miss a special kind of double free, similar to existing work [23,32], when a de-allocated object has been subsequently reutilized for other purposes. GUARDER will additionally check the canary values of an object's four adjacent neighbors at the same time, which provides additional protection for long-lived objects that may never be freed by the application. GUARDER must access its per-thread heap upon every allocation and deallocation. In order to support a specified randomization entropy, GUARDER needs to initialize each allocation buffer with 2 E+1 objects, then place the specified ratio of guard pages within. To reduce memory consumption, GUARDER returns memory to the underlying OS when the size of a freed object is larger than 64 kilobytes, by invoking madvise with the MADV DONTNEED flag.GUARDER designs a global deallocation buffer to reduce the memory blowup caused by returning freed objects to the current thread's sub-heap. By default, GUARDER uses 9 bits of randomization entropy, a 10% proportion of random guard pages, and a 1/8 over-provisioning factor. OpenBSD's object junking feature was disabled in order to provide a fair comparison.In order to evaluate the performance and memory overhead of these allocators, we performed experiments on a total of 21 applications, including 13 PAR-SEC applications, as well as Apache httpd-2.4.25, Firefox-52.0, MySQL-5.6.10, Memcached-1.4.25, SQLite-3.12.0, Aget, Pfscan, and Pbzip2. To evaluate performance, we utilized the average results of 10 executions, as shown in Figure 3. On average, the performance overhead of these secure allocators are: DieHarder-74%, OpenBSD-31%, FreeGuard-1%, and GUARDER-3%, by comparing to the Linux allocator, while a known performance oriented allocator-TCMalloc-is slightly faster than it, with 1.6% performance improvement. Although they impose more mprotect calls, our evaluation indicates that mprotect requires only about 1/20 the time needed to perform an mmap system call.Heap allocation overhead. Similarly, if the number of synchronizations (mostly lock acquisitions) is larger, the allocator will also impose more overhead.The average number of trials for each secure allocator is shown in Table 3, where the Linux allocator and TCMalloc typically only require a single trial upon each allocation and deallocation. Both OpenBSD and DieHarder exceed this value, with 3.79 and 1.99 times respectively. This indicates that GUARDER actually imposes less synchronization overhead than FreeGuard, which is part of reason why GUARDER has a similar overhead to FreeGuard, while providing a much higher security guarantee. The average results of all applications were shown in Table 4, where the data is normalized to that of the default setting: 9 bits of randomization entropy, 10% guard pages, and 1/8 of over-provisioning factor.Randomization Entropy. EB = Entropy Bits, GPR = Guard Page Ratio, OPF = Over-Provisioning Factor pages, including 2%, 5%, 10%, 20%, and 50%, were similarly evaluated. Different heap overprovisioning factors, including 1/32, 1/16, 1/8, 1/4, and 1/2, were evaluated. To ensure a fair comparison, we disabled the canary checking functionality for both FreeGuard and GUARDER (and is disabled by default in OpenBSD), since adding even a single-byte canary may cause an object to be allocated from the next largest size class.In total, the memory overhead (shown in Table 5) of FreeGuard is around 37%, while DieHarder and OpenBSD feature slightly less memory consumption than the Linux allocator, with -3% and -6%, respectively. For any given size class, GUARDER will place more than 2 n objects into its allocation buffer, then randomly allocate an object from among them. Second, GUARDER's over-provisional mechanism will introduce more memory consumption, since some objects will be randomly skipped and thus never utilized. Because the bag size for OpenBSD is just one page, we do not show its entropies for objects larger than 4 kilobytes.Both DieHarder and OpenBSD were seen to exhibit unstable entropy, and FreeGuard shows a constant low entropy (approximately 2 bits). However, our evaluation also shows that GUARDER guarantees virtually the same high entropy across different size classes, execution phases, applications, or inputs, making it the first secure allocator of this kind. We evaluate the effectiveness of GUARDER and other allocators using a collection of real-world vulnerabilities, including buffer over-writes, buffer over-reads, use-afterfrees, and double/invalid frees. Arbitrary-precision numeric processing language interpreter The affected copy of this program was obtained from BugBench [25], and includes a buffer overflow as the result of an off-by-one array indexing error, caused by a specific bad input, which will produce a program crash. This bug would normally corrupt the adjacent metadata, however, when testing each se- Libtiff-4.0.1. When verifying this bug with GUARDER, this will always result in (1) an immediate halt due to illegal access on an adjacent random guard page, or (2) a report to the user indicating the discovery of a modified canary value. The affected version of polymorph suffers from a stackbased buffer overflow that was adapted to the heap for testing purposes, and results in a program crash due to corrupted object metadata. For all evaluated bugs, GUARDER was capable of either probabilistically detecting the attack -such as through the use of random guard pages to thwart buffer overflow -or immediately provided a report to the user when the error condition occurred (e.g., double-free). Based on our investigation, these evaluated bugs (mostly static) cannot show the benefit of the improved security of GUARDER, as described in Section 6.2, such as higher entropy and overprovisioning. For instance, GUARDER's memory overhead using 7 bits of entropy is around 0% (not shown due to space limitations), while its memory overhead with 9 bits is around 27%. If there are 128 threads in total, with a heap space of 128 terabytes, every bag will be 64 gigabytes, which can sup-Rather than protecting against a single type of memory error, GUARDER defends against many common errors, achieving this with very little overhead on average. The GUARDER heap combines protections similar to those provided by the mechanisms introduced by these works, including fully-segregated metadata, randomized object reuse, and detection of double/invalid free vulnerabilities, among others.The Low Fragmentation Heap (LFH) is a widely deployed heap policy for Windows-based platforms, introduced in Windows XP [27]. GUARDER proposes the combination of allocation and deallocation buffers to support different customizable security guarantees, including randomization entropy, guard pages, and over-provisioning. However, GUARDER supports more security features and a higher level of entropy, due to its unique and novel design as described in Section 4: (1) GUARDER supports heap over-provisioning, which FreeGuard does not. dnmalloc dedicates a separately allocated area to house object metadata, and also utilizes a table to maintain mappings between these chunks and their metadata, an approach that is not unlike that of DieHarder or OpenBSD [40]. DangNULL similarly targets use-after-free and double-free vulnerabilities by tracking each pointer, nullifying it when the object it references is deallocated [20]. (4) More importantly, GUARDER allows users to configure their desired security through entropy, guard page ratio, and over-provisional factors, which FreeGuard cannot support. Lastly, its design could be significantly hardened; for example, its rudimentary detection of double/invalid frees, and free list pointers that occupy deallocated slots [16]. Kharbutli further describes securing the sequence in which freed objects are reused, in an effort to introduce non-determinism to allocation functions [19]. DangSan utilizes a new lock-free design to reduce performance overhead, only introducing half the overhead of FreeSentry and DangNULL [36].