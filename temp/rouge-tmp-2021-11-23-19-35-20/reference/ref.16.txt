Using these tools, we verify the correctness, safety, and security of implementations of SHA-256 on x86 and ARM, Poly1305 on x64, and hardware-accelerated AES-CBC on x86. Because this cryptographic code is critical to TLS performance, implementations often use hand-tuned assembly, or even a mix of assembly, C preprocessor macros, and Perl scripts. For example, the Perl subroutine in Figure 1 generates optimized ARM code for OpenSSL's SHA-256 inner loop.Unfortunately, while the flexibility of script-generated assembly leads to excellent performance ( §5.1) and helps support dozens of different platforms, it makes the cryptographic code difficult to read, understand, or analyze. Such solvers can potentially blast their way through large blocks of assembly and tricky bitwise reasoning, making verification faster and easier.In this paper, we present Vale, a new language for expressing and verifying high-performance assembly code that strives to combine the advantages of both approaches; i.e., it combines flexible generation of high-performance assembly with automated, rigorous, machine-checked verification. As a powerful example of this post-analysis, we have developed a verified analyzer that checks Vale ASTs for potential information leakage through timing and memoryaccess channels.Although we trust our crypto specs, Dafny, and the assembly language semantics to be correct, as shown in Figure 2, neither Vale nor the information leakage analyzer is part of the trusted computing base. • A machine-verified analyzer that checks verified Vale programs for side channels based on a novel combination of dataflow analysis and Hoare-style proofs ( §3). • An evaluation demonstrating that, because Vale can match the expressiveness of OpenSSL's codegeneration techniques, the verified assembly code generated by Vale can match the performance of highly-optimized implementations like OpenSSL ( §5). For example, even when using Dafny as a logical framework, Vale procedures are not executable Dafny methods, Vale while loops are not executable Dafny while loops, and executable Vale code is not compiled with Dafny's compiler, which compiles Dafny's own control constructs to C#. Instead, Vale relies on the logical framework mainly for mathematical reasoning in proofs, and uses executable Dafny code only for specialized tasks like printing assembly language code and static analysis of Vale code.The Vale language does not contain anything specific to a particular architecture such as x86 or ARM or to a particular assembler such as the GNU assembler or MASM. §2.2 and §2.3 then present Vale code, demonstrating the flexibility and expressiveness of the Vale language. Furthermore, properties of programs are proven directly in terms of the method Main() { var code := Block( cons(Add(op_reg(R7), op_reg(R7), op_const(1)) ,cons(Add(op_reg(R7), op_reg(R7), op_const(1)) ,cons(Add(op_reg(R7), op_reg(R7), op_const (1) semantics of assembly language, so the Vale language and tool need not be trusted. Since Dafny is a general-purpose high-level language that knows nothing about assembly language instructions, operands, and registers, Vale provides domain-specific language support for declaring instructions, declaring and instantiating input and output operands, declaring which registers an instruction reads and modifies, and so on. The Add3ToR7 procedure, for example, promises to add three to register r7 under the condition that the initial value or r7 isn't so big that adding three would cause overflow. var{:state ok()} ok:bool; var{:state reg(R0)} r0:uint32; var{:state reg(R1)} r1:uint32; ... var{:state reg(R12)} r12:uint32; var{:state reg(LR)} lr:uint32; var{:state mem()} mem:map(int, uint32); procedure AddOne(inout operand r:uint32) requires r < 0xffffffff; ensures r == old(r) + 1; { ADD(r, r, 1); } procedure Add3ToR7() modifies r7; requires r7 < 0xfffffffd; ensures r7 == old(r7) + 3; { AddOne(r7); AddOne(r7); AddOne(r7); } FIGURE 5-Examples of state declarations and inline procedure declarations in Vale.In addition to preconditions and postconditions, Vale also requires loop invariants for loops:while (r7 <= 100) // example loop in Vale invariant r7 <= 103; // loop invariant { Add3ToR7(); } For each procedure, the Vale tool generates a Dafny function that produces an AST value of type code. procedure{:instruction Ins(Add(dst,src1,src2))} ADDW(out operand dst:uint32, operand src1:uint32, operand src2:uint32) ensures dst == (src1 + src2) % 0x100000000; procedure{:instruction Ins(Add(dst,src1,src2))} ADD(out operand dst:uint32, operand src1:uint32, operand src2:uint32) requires 0 <= src1 + src2 < 0x100000000; ensures dst == src1 + src2; procedure{:instruction Ins(Ldr(dst,base,offset))} LDR(out operand dst:uint32, operand base:uint32, operand offset:uint32) reads mem; The leaves of the AST are the individual instructions declared in Figure 3. For example, the ADDW (wrapping add) and ADD (non-wrapping add) procedures in Figure 6 both have the same body, a single Add instruction. §3 pushes this flexibility even further, implementing an entire verified information leakage analysis with no modifications to Vale. b ==> r1 == a[1] + 1; { inline if (b) { LDR(r1, r0, 0); //load memory [r0+0] into r1 AddOne(r1); } else { LDR(r1, r0, 4); //load memory [r0+4] into r1AddOne(r1); } } procedure{:recursive} AddNToR7(inline n:nat) modifies r7; requires r7 + n <= 0xffffffff; ensures r7 == old(r7) + n; { inline if (n > 0) { AddOne(r7); AddNToR7(n -1); } } FIGURE 7-Ghost and inline parameters in Vale. The AddNToR7 procedure uses an inline natural number n to repeat the AddOne instruction n times, generating a completely unrolled loop.From these, Vale generates functions parameterized over the inline b and n variables, so that each b and n produces a possibly different AST (see Figure 8). function method{:opaque} code_ReadA(b:bool):code { Block(cons(( if b then Block(cons(code_LDR( op_reg(R1), op_reg(R0), op_const(0)) ... else ... ))) } function method{:opaque} code_AddNToR7(n:nat):code { Block(cons(( if (n > 0) then Block(cons( code_AddOne(sp_op_reg(R7)) ... else ...))) } Although Vale ultimately proves properties in terms of the underlying machine semantics, it still structures its proofs to take advantage of the automated SMT-based reasoning provided by Dafny and Z3. In its simplest form, a Vale proof looks much like the assertion in Figure 4; i.e., it consists of a Dafny lemma• taking an initial state s1 and a final state s2 as parameters, • requiring evalCode(p.code, s1, s2), • requiring s1.ok, • requiring that all of p's preconditions hold for s1,• ensuring that all of p's postconditions hold for s2, and • ensuring that any state not mentioned in a modifies clause remains the same from s1 to s2. The lemma's proof (i.e., the body of the lemma) consists largely of calls to the lemmas for other procedures; for example, the proof of Figure 5's lemma for Add3ToR7 consists mainly of three calls to the lemma for AddOne, whose proof consists mainly of one call to the lemma for ADD. They never need to examine the Vale-generated code objects and proofs, since all error messages are presented to the user in terms of user-generated Vale code and Dafny specifications.While Vale error messages do not assign blame to Valegenerated Dafny code, Vale does leverage Dafny's error handling. Since cryptographic code typically operates on secrets, proving it secure requires more than functional correctness; it requires proving the absence of leakage. Leakage via side channels occurs when an adversary learns secrets by observing aspects of the program's behavior. To prove the absence of digital leakage in Vale programs, we developed a novel approach that combines functional verification with a taint-based analyzer proven correct against a simple specification ( §3.1). Compared with prior approaches to formally proving the absence of side channels (e.g., [9]), we invest a one-time effort in verifying our analyzer, which we can then run on an arbitrary number of Vale programs, rather than formally reasoning about side channels for every Vale program we write. To be conservative, we have the programmer specify the opposite: the set of locations PubStartLocs she is sure contain non-secret information. As shown by Barthe et al., a program is free of cache-based side channels if it does not branch on secrets, and if it performs no secretdependent memory accesses [12]. Thus, to prove freedom from cache-based side channels, it suffices to show that an execution trace, which records all branches and memoryaccess locations, does not depend on secret inputs.To enable machine-checked verification of cache-based side-channel freedom in Vale, we expand the architectural model of the state with an additional ghost field trace that represents the execution trace defined above. In summary, we model a strong attacker capable of fully observing detailed digital side channel information. We also assume the attacker sees all architectural state resulting from running our code, except for locations where our specification explicitly says we store secrets (e.g., decrypted messages). Rather than directly proving that each Vale program satisfies our leakage specification, we invest in a one-time effort to write and prove correct a leakage analyzer that can run on any Vale program. Our analyzer takes as input:• a Vale code value ( §2) Code,• a set of locations (e.g., register names) PubStartLocs assumed to be free of secrets when the code begins, and • a set of locations PubEndLocs that must be free of secrets when the code ends. The main novelties are that we formally verify the implementation relative to a succinct correctness condition, and that we leverage the knowledge of aliasing present in the functional verification of the Vale programs, as described further in §3.3. Taint values are chosen from a lattice of two elements (Public and Secret, with the partial order Secret > Public), which helps in conservatively merging taints. However, given our focus on proving functional correctness of cryptographic code, we observe that we can carefully leverage the work already done to prove functional correctness, to drastically simplify memory taint analysis.Memory taint analysis is challenging because typically one cannot simply look at an instruction and determine which memory address it will read or write: the effective address depends on the particular dynamic values in the registers used as the base and/or offset of the access. Our approach to memory taint analysis carefully leverages the work already done to prove functional correctness, since some of that work requires reasoning about the flow of information to and from memory. For example, the developer cannot prove SHA-256 correct without proving that the output hash buffer does not overlap the unprocessed input.We can push some of the work of memory taint analysis to the developer by relying on her to provide lightweight annotations in the code. The analyzer also checks, for each store annotated as public, that the value being stored is actually public.To ensure that annotation errors will be caught during functional correctness verification, we expand the architectural model of the state with an additional ghost field pubaddrs, representing the set of addresses currently containing public information. She must also prove that any intervening store of secret information does not overwrite the public information; in other words, she must perform her own alias analysis. This lets OpenSSL improve performance by calling the subroutine 16 times to unroll the loop: for($i=0;$i<16;$i++) { &BODY_00_15($i,@V); unshift(@V,pop(@V)); } Furthermore, each unrolled loop iteration is customized with a different mapping from SHA variables a. . Finally, a combination of Perl-based run-time checks (if ($i < 16)) and C preprocessor macros are used to select the most efficient available instructions on various versions of the ARM platform, as well as to further customize the last loop iteration (i = 15). As Figure 1 shows, the code comments are minimalist and often cryptic, e.g.,eor $t3,$B,$C @ magic ldr $t1,[sp,#'($i+2)%16'*4] @ from future BODY_16_xxIn the second line, the odd syntax with the backticks is used when the Perl code makes a second pass over the string representing the assembly code, this time acting as an interpreter to perform various mathematical operations, like ($i+2)%16. We also take advantage of Z3's bit-vector theory to automatically discharge relations like:(x&y) ⊕ (∼ x&z) == ((y ⊕ z)&x) ⊕ zwhich allow OpenSSL's code to optimize various SHA steps; e.g., the relation above saves an instruction by computing the right-hand side.To demonstrate that our implementation is not only correct but side-channel and leakage free, we run our verified analysis tool ( §3) on the Vale-generated AST. This required writing a trusted semantics for a subset of Intel's architecture, a trusted printer to translate instructions into assembly code, and a verified proof library (which in many cases differs very little from our corresponding ARM library). We then verify the OpenSSL assembly language code for the Poly1305 main loop and add our own initialization and finalization code in assembly language to replace the C code, resulting in a complete Vale implementation of Poly1305. As we quantify in §5.1, implementations that take advantage of this hardware support are easily 3.5-4.0× faster than traditional hand-tuned assembly that does not.For this case study, we extended our x86 model from §4.2 by adding support for 128-bit XMM registers, definitions for Intel's six AES-support instructions [35], and four generic XMM instructions [39]. In our evaluation, we aim to answer two questions: (1) Can our verified code meet or exceed the performance of state-of-the-art unverified cryptographic libraries? We see that OpenSSL's assembly code for SHA-256 on ARM gets up to 67% more throughput than its C code, and its assembly code for AES-CBC-128 on x86 gets 247-300% more throughput than its C code due to the use of SSE and AES-NI instructions.To accurately compare our performance with OpenSSL's, we make use of its built-in benchmarking tool openssl speed and its support for extensible cryptographic engines. Indeed, our Poly1305 implementation slightly outperforms OpenSSL, largely due to using a complete assembly implementation rather than a mix of C and assembly. Proof lines count all annotations added to help the verifier check our code, e.g., pre-and post-conditions, loop invariants, assertions, and lemmas. The three lines show:• the cost of verifying an unrolled loop consisting entirely of x86 add eax, 1 instructions, ranging from 10 to 100 total instructions; • the cost of verifying an unrolled loop of x86 AES key inversions, up to the maximum 9 iterations performed by AES, where each iteration consists of 3 instructions; and • the cost of verifying an unrolled loop of x86 AES key expansions, up to the maximum 10 iterations performed by AES, where each iteration consists of 10 instructions. Other projects have verified correctness and security properties of cryptographic implementations written in C or other high-level languages, either using Coq [11] or SMT solvers [28,80]. We hope to connect verified assembly language code to verified high-level language code in the future.Vale, like other cryptography verification efforts, relies on formal specifications to define the correctness of implementations. Dam et al. [24] do address timing, but they approximate by assuming each instruction takes one machine cycle.Other assembly language verifiers like BoogieX86 [77], used by Ironclad [37], and VCC's assembly language [56] have built on SMT solvers, but do not expose ASTs and assembly language semantics as first-class constructs. Vale is our programming language and tool for writing and proving properties of high-performance cryptographic assembly code. This analyzer uses taint tracking with a unique approach to alias analysis: instead of settling for a conservative, unsound, or slow analysis, it leverages the address-tracking proofs that the developer already writes to prove her code functionally correct.Vale uses Dafny as a target verification language but only as an off-the-shelf tool with no customization, suggesting that we can also support other back ends. In most places, vertical bars divide grammar alternatives and square brackets surround optional grammatical components, but in a few places where we think their usage is clear, we abuse this notation and use vertical bars and square brackets to stand for themselves in the grammar. Lowercase letters stand for identifiers and are suggestive of what kind of identifiers they represent.At the top level, a Vale program consists of some number of declarations.