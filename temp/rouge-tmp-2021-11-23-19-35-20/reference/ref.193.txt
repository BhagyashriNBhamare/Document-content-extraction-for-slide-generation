Our work examines the generation of this field in Windows (versions 8 and higher), Linux and Android, and shows that the IP ID field enables remote servers to assign a unique ID to each device and thus be able to identify subsequent transmissions sent from that device. In modern Linux and Android versions, this field leaks a kernel address, thus we also break KASLR. It can either be done by sites that are visited by users, or by third-party companies which track users across multiple web sites and applications. [2] specifically lists motivations for web-based fingerprinting as "fraud detection, protection against account hijacking, anti-bot and anti-scraping services, enterprise security management, protection against DDOS attacks, real-time targeted marketing, campaign measurement, reaching customers across devices, and limiting number of access to services". It is the first tracking technique that is able to simultaneously (a) cross the private browsing boundary (i.e. compute the same tracking ID for a private mode tab/window of a browser as for a regular tab/window of the browser); (b) work across different browsers; (c) address the "golden image" problem; and (d) work across multiple networks; all this while maintaining a very good coverage of the platforms involved. The IP protocol assembles fragments into a datagram based on the fragment source IP, destination IP, protocol (e.g. TCP or UDP) and IP ID. IP ID is generated by choosing the counter pointed to by the hash function, possibly adding to it an offset (which may depend on the IP endpoints, key, etc.), and finally incrementing the counter. The non-repetition period in this family is 65536 global packets, and at the same time knowing IP ID values for one pair of source and destination IP addresses does not reveal anything about the IP IDs of pairs in other buckets. KASLR (Kernel Address Space Layout Randomization) is a security mechanism designed to defeat attack techniques such as ROP (Return-Oriented Programming [27]) that rely on the predictability of kernel code addresses. The IP ID generation mechanisms in Windows and in Linux (UDP only) both compute the IP ID as a function of the source IP address, the destination IP address, and a key K which is generated when the source machine is restarted and is never changed afterwards. Moreover, after we reconstruct K, we can reconstruct the current counter values (in full or in part) by sending traffic to specially chosen IP addresses, obtaining their IP ID values and with the knowledge of K, work back the counter values that were used to generate them. Linux/Android KASLR bypass Support for network namespaces (part of container technology) was introduced in Linux kernel 4.1. Thus the probability of a single device not to have a unique ID is very low.It should be noted that in the Linux/Android case, due to the use of 300-400 IP addresses, the need to "dwell" on the page for 8-9 seconds, and (in newer Android devices) the excessive attack time, there are use cases in which the technique may be considered invasive and/or inapplicable.Additional Contributions: In addition to the crossbrowser tracking technique for Windows and Linux, and the KASLR bypass with respect to Linux, we also provide the first full public documentation of the IP ID generation algorithm in Windows 8 and later versions, obtained via reverse-engineering of the relevant parts of Windows kernel tcpip.sys driver, and a cryptanalysis of said algorithm. Microsoft fixed the issue in Windows April 2019 Security Update (CVE-2019-0688). 3 Linux fixed the kernel address disclosure (CVE-2019-10639 5 we developed, that extends the key to 64 bits. The key-based tracking technique (CVE-2019-10638) is fully addressed in a patch, 6 part of kernel version 5.2-rc1, and will be back-ported to kernel versions 5.1.7, 5.0.21, 4.19.48 and 4.14.124. We use the terminology defined in [31]:• A fingerprinting technique measures properties already existing in the browser or operating system, collecting a combination of data that ideally uniquely identifies the browser/device without altering its state. Device tracking via IP ID: Using IP ID is proposed in [5] (2002) to detect multiple devices behind a NAT, assuming an IP ID implementation using a global counter. However, this technique does not scale beyond a few dozen devices, due to IP ID collisions (the IP ID field provides at most 2 16 values), and requires ongoing access to the traffic arriving at the DNS resolver. Fragmentation attacks: While not directly related to the properties of the IP ID field, it should be noted that attack techniques abusing fragmentation are known. The analysis of this algorithm is based on two assumptions: (1) that the technique is applied shortly after restart, when the relevant memory buffer contains zeroes in a large part of its cells; and (2) that the attacker controls or monitors traffic to pairs of IP addresses which differ in single, specific bit position (including positions in the left half of the address). Based on these extreme assumptions, the attacker can extract the key easily, and use it to expose kernel 31-bit data quantities (though without learning where in the array this data resides). (5) It should also be noted that unlike our attack, Menscher's technique could not be used for tracking, since as the cell arrays become non-zero when they are incremented, the attack becomes ineffective. [14] broke the Javascript Math.Random() PRNG of several browsers, obtained the seed and used it as a browser instance tracking ID. That is, for each outgoing IP packet, a global counter would be incremented by 1 and the result (truncated to 16 bits) would be used [25]. Let us first define the Toeplitz hash, T (K, I), which is a bilinear transformation from a binary vector K in GF(2) 320 , and an input which is a binary string I (where |I| ≤ 289) to the output space GF(2) 32 . The i-th bit of T (K, I) (0 ≤ i ≤ 31) is defined as the inner product between I and a substring of K starting in location i. NamelyT (K, I) i = |I|−1 j=0 I j · K i+ j (1)IP ID generation The IP ID generation algorithm itself uses keys K (tcpip!TcpToeplitzHashKey) which is a 320 bit vector, and K1 and K2 which are 32 bits each. The algorithm uses the keys, and the source and destination IP addresses, to pick a random index i for a counter in β , and an offset. I.e., the device's source IP address, IP SRC , is fixed (though possibly unknown). A second set of measurements directs the client device to G pairs of IP addresses, each pair in the same class B network, with G different class B network pairs in the set.Once the device is measured, the attack proceeds in two phases. If these packets are sent in rapid succession (i.e. when no other packet is sent in-between with i = i g ), then β [i g ] g, j = β g + j mod 2 32 , and therefore the output in line 5 of the 2 32 4:i ← Num(K2 ⊕ T (K, (IP DST ) 0,..., |IP DST | 2 −1 ) ⊕ T (K, IP SRC )) mod M 3: v ← β [i] + Num(K1 ⊕ T (K, IP DST ||IP SRC ||0 32 )) modβ [i] ← (β [i] + 1) mod 2 32 5:return v mod 2 15 v mod 2 16 for Windows 10 RedStone 5 algorithm is calculated with β [i g ] g, j = β g + j mod 2 15 (for simplicity, in Windows 10 RedStone 5, we discard the most significant bit of the IP ID). Note that the offset that is calculated in line 3 is the difference between the IPID and the counter β [i 0 ] prior to its increment.The attack enumerates over the values of the β 0 mod 2 15 counter. This results in the following expression (where we denote by Vec a representation of a number in [0, 2 32 ) as a vector in GF(2) 32 ):(Vec(IPID j − (β 0 + j) mod 2 15 )⊕ Vec(IPID j − (β 0 + j ) mod 2 15 )) 17,...,31 = T (K, IP j ⊕ IP j ) 17,...,31This yields 15 linear equations (i = 17, . . . , 31) on K since (from eq. (1)):T (K, IP j ⊕ IP j ) i = 31 m=0 (IP j ⊕ IP j ) m · K i+mSince all IP j belong to the same class B network, IP j ⊕ IP j always has 0 for its first 16 bits, and therefore m can start at 16. That is, for j = 1, . . . , J − 1 and i = 17, . . . , 31, the equations are:31 m=16 (IP j ⊕ IP 0 ) m · K i+m = (Vec(IPID j − (β 0 + j) mod 2 15 ) ⊕ Vec(IPID 0 − (β 0 ) mod 2 15 )) i (4)Speeding up the computation using preprocessing The coefficients of K in eq. (4) are controlled by the server and are known at setup time. D j ( j = 1, . . . , J − 1), where D j = (Vec(IPID j − (β 0 + j) mod 2 15 ) ⊕ Vec(IPID 0 − (β 0 )modThe attack takes 2 14 · (15(J − 1)) 2 bit operations (for enumeration over the possible key values and for the matrix-byvector and (15(J − 1)) 2 memory bits (for Z). The offset for IPID 0 computed in line 3 of Algorithm 1 is:Num(K1 ⊕ T (K, IP 0 ) ⊕ T (K, 0 32 ||IP SRC )) mod 2 15 = (IPID 0 − β 0 ) mod 2 15The following equation follows from the previous one:(K1 ⊕ T (K, 0 32 ||IP SRC )) 17,...,31 = T (K, IP 0 ) 17,...,31 ⊕ Vec(IPID 0 − β 0 mod 2 15 ) 17,...,31The tracker looks at pairs of IP addresses in the remaining B classes (b 1 , . . . , b G ), each pair in a different class B network. Substituting the above into the definition of IPID yields:IPID g, j = β g + j + Num( T (K, IP 0 ) 17,...,31 ⊕ Vec(IPID 0 − β 0 mod 2 15 ) 17,...,31 ⊕ T (K, IP g, j ) 17,...,31 ) mod 2 15Using the linearity of T , this is simplified into: 14 . In theory, each IP pair should yield a 2 15 elimination power for identifying the right key, but see the extended paper for a more accurate analysis. At the end of Phase 2, the tracker obtains:• A partial key vector (or some candidates) K 18 , . . . , K 62 (45 bits), which is specific to the device since it was set during kernel initialization, and does not depend on IP SRC . • The value(K1 ⊕ T (K, 0 32 ||IP SRC )) 18,...,31 = T (K, IP 0 ) 18,...,31 ⊕ Vec(IPID 0 − β 0 mod 2 14 ) 18,...,31This value allows the tracker to calculate (assuming K 18 , . . . K 62 are known) the value of the counter β [i] mod 2 14 for any destination IP address whose IP ID is known (provided the source IP is IP SRC ). 9 For Windows, we assume budget-oriented constraints, namely L available IP addresses and T CPU time per measurement. Given these constraints, we want to minimize the leading term in false positives, 2 · 2 − G+J−1 2 (Appendix A.2), i.e. we need to maximize G + J. A typical user needs to restart his/her Windows machine only for some Windows updates, i.e. with a frequency of less than once per month.The attack is scalable: with 41 bits, the probability of a device to have a unique ID is very high, even for a billion device population; false positives are also rare (2.1 × 10 −6 - Table 3), and false negatives can be made negligible (Appendix A.1.4). (5), using mod 2 n where n is the number of β 0 bits guessed so far. We demonstrate here that the tracking attack can be deployed in almost every setting that can be reasonably expected.HTTPS: In essence, there should be no problem in having the snippet use WebSocket over HTTPS (wss:// URL scheme) for TCP packets.NAT: Typically NAT (Network Address Translator) devices do not alter IP IDs, and thus do not affect the attack.Transparent HTTP Proxy / Web Gateway: Such devices may terminate the TCP connection and establish their own connections (with IP ID from their own network stack) and thus render our technique completely ineffective. However, it may still be the case that UDP traffic (which is not handled by HTTP forward proxies) can be used by the technique.Tor-based browsers and similar browsers: Browsers that forward TCP traffic to proxy servers (and disallow or forward UDP requests) are incompatible with the tracking technique as they do not expose IP header data generated on the device. It should be noted that WDAG is only available for Edge browser in Windows 10 Enterprise/Pro edition, and requires high-end hardware.IP-Level VPN: We experimented with F-Secure FreeDome (www.f-secure.com/en/web/home_global/ freedome) and PureVPN (www.purevpn.com/). • Changing T into a cryptographically strong keyed-hash function -while this change eliminates the original attack, it is still possible to mount a weaker attack that only tracks a device while its IP SRC does not change. As explained in Appendix A.1.3, in order to avoid false positives (which almost always happen due to false keys that differ from the true key in a few most significant bits), we need to trim the most significant bits from the key -i.e. use the key's tail. Due to logistic and budgetary constraints, in our experiment we used only 15 IP addresses (rather than 30) for the key extraction (and 2 more IPs for verification), with J = 5, G = 5, Q = 1. We then used WebSocket traffic to the additional pair of IP addresses (from a class B network that is different than those in the initial set of 15 IPs) to verify the correctness of the key bits extracted. We collected data on 75 different class B networks. We asked the users who connected to our demo site to use multiple regular browsers and networks, and connect at different times, and verified that the device ID remained the same in all these connections. For the rest 65 networks, our algorithm extracted a single 40-bit key, and correctly predicted the least significant 9 bits of the IPID of the second IP in the last pair (i.e. the correct value was one of the two candidates computed by the algorithm). The tracking snippet forces the browser to rapidly emit UDP packets to each such IP (using WebRTC and specifically the STUN protocol, which enables sending bursts of packets closely spaced in time to controlled destination addresses). It also collects the device's source IP address (using WebRTC as well or a different approach described in the extended paper.) The implementation of IP ID for stateless over-IP protocols (e.g. UDP) has gone through an interesting evolution process. The algorithm also uses the following parameters• key -a 32-bit key (ip_idents_hashrnd) which is initialized upon first IP transmission with random data. • protocol -the IP "next level" protocol number (for UDP, this value is 17). The modification is for step 2, which now reads:i ← h(IP DST , IP SRC , protocol ⊕ g(net), key) mod M where g(x)is a right-shift (by ρ bits) and a truncation function that returns 32 bits from x. To summarize, there are four flavors of IP ID generation (for short stateless protocol datagrams) in Linux:1. Newer Android Linux kernels (4.4 and above) use 300 or 100 (or rarely, 250). 12 In general, for tracking purposes, a lower value of f is better.Note that key and net are generated during the operating system initialization, which, unlike Windows, happens during restart and during (shutdown+)start. The browser then sends STUN "Binding Request" (UDP short datagram) to the destination host and port.To send STUN requests to multiple servers (in Javascript), create an array A of strings in the form stun:host:port, then invoke the constructor RTCPeerConnection({iceServers: A}, ...) in a regular WebRTC flow e.g. [13] (applying the fix from [8]). Adding Firefox (even though its STUN traffic is less bursty, Firefox can still be tracked at least for f = 100) gets this figure up to 92%. We measured 1014 bursts (to L = 400 destination IP addresses) emitted by a Google Pixel 2 mobile phone (Android 8.1.0, kernel 4.4.88), running Google Chrome 67 browser. On May 1 st -6 th 2018, we measured the latency of connections to a server in Microsoft Azure "East-US" location (in Virgina, USA) from 8 different networks located in Israel, almost 10,000km away. These are quite rare (in the STUN traffic measurement experiment we got 29 such cases out of 1014 -2.9%, though they are more common in Androids whose kernel is 4.x and have f = 100) and easily identified. The tracker should be able to monitor the traffic to these IP addresses with time synchronization resolution of about 10 milliseconds (or less) -e.g. by having all the IPs bound to a single host.With L different destination IP addresses and M buckets (M = 2048 in Algorithm 2), there are ( L 2 ) /M expected collisions, assuming no packet loss. The goal is to reduce those false negatives and false positives to levels which allow assigning meaningful tracking IDs.The basic property that enables the attacker to construct the approximate list is that in an IP ID generation the counter is updated by a random number which is smaller than 1 plus the multiplication of the timer frequency f and the time that passed since the last usage of that counter. Therefore for a true pair (IP i , IP j ) where the IP ID generation for IP i and IP j used the same bucket (counter), the following inequality almost always holds:0 < (IPID j − IPID i ) mod 2 16 < f ∆t + 10(We use f ∆t + 10 instead of f ∆t + 1 to support up to 10 IPs colliding into the same bucket, as each collision may increment the counter by ≤ 1 + f ∆t where ∆t is from the previous collision. Since we are looking at datagrams from the same burst we have an upper bound δ L such that ∆t < δ L , and therefore:0 < (IPID j − IPID i ) mod 2 16 < f δ L + 10For two IP addresses which are not mapped to the same counter, the likelihood of this inequality to hold is only( f δ L +10)−1 2 16which is 1 when f δ L 2 16 . If there are too many missing requests in a burst, the Tracking Server communicates with the Tracking Snippet, instructing it to retest the device.Assuming no (or few) missing requests in B 4 and B 5 , the Tracking Server starts analyzing the data per burst (in B 4 and B 5 ). In the second phase the tracking server runs an exhaustive search on the key space W where the key is 32 bits long for algorithms A 1 and A 2 , 41 bits long for algorithm A 3 (Linux) and 48 bits for A 3 (Android). As explained in Section 6.11, false positives (|X| > 1) are very rare -they can be handled but as this complicates the analysis logic, it is left out of the paper.Attack run time Where |U| = P pairs, the run time of Algorithm 3 is proportional to |W |P. P's distribution depends on f ; Table 1 summarizes the expectancy and standard deviAlgorithm 3 Exhaustive key search 1: procedure GENERATE-ID(U, IP src ) U is defined in Section 6.5 2:if |U| < ν then 3:return ERROR 4:X ← / 0 5:for all 0 ≤ k < W do 6: Y ← {(IP i , IP j ) ∈ U | h (IP i , IP SRC , k) = h (IP j , IP SRC , k)} 7:if |Y | ≥ ν then 8:X ← X ∪ {k} 9:if |X| > 0 then 10: return X Needs special treatment if |X| > 1 11:else 12:return ERROR Table 1: Time/memory optimization When the number of devices to measure is much smaller than |W | it is possible to optimize the technique for repeat visits. The dwell time in this case drops to near-zero.6.7 The Effective Key Space in Attacking Algorithm A 3In Algorithm A 3 , 32 bits of the net namespace are extracted by a function we denote as g(), and are added to the calculation of the hash value. We analyzed the source code of Linux kernel versions 4.8 and above on x64, and 4.6 and above on ARM64, and found that if KASLR is turned off then the effective key space size is 32 bits in both x64 and ARM64. This suffices to reconstruct the kernel image load address and thus fully bypass KASLR. For false negatives, we use the Poisson approximation of birthday collisions [3] with λ = L 2 /M. Therefore:Prob(FN) ≈ ν−1 ∑ i=0 λ i e −λ i!For false positives, we also assume that a burst contains the average number of false pairs and true pairs A =f δ L +10 f ∆t L 2 f δ L +10 2 16 + ( L 2 ) M . The probability of |W | − 1 false keys to generate at least one false positive key is therefore:Prob(FP) ≈ 1 − ν−1 ∑ i=0 A i ( 1 M ) i (1 − 1 M ) A−i |W |−1Assuming |W | = 2 48 (worst case -Android), we enumerated over all ν values for each L in {200, 250, . . . , 500} to find the optimal ν (per L). Device ID collisions The expected number of pairs of devices with colliding IDs, due to the birthday paradox, and given R devices and a key space of size |W |, is ( R 2 ) /|W|. For Algorithms A 1 and A 2 the key space size is |W | = 2 32 , and will cause device ID collisions once there are several tens of thousands of devices. A 3 , the key space size (with KASLR) is ≥ 2 41 , so collisions start showing up with R in the millions. Even for R = 128 · 10 6 , collisions affect only 0.00006 of the population.Dwell time In order to record B 5 , the snippet page needs to be loaded in the browser for 8-9 seconds. The expected number of collisions is ( L 2 ) /M, and therefore increasing M by a factor of c requires the attacker to increase L by only a factor of √ c. On the other hand, δ L also grows (probably linearly in L), and when f δ L ≥ 2 16 no information is practically revealed to the tracker. Increasing the key size (W) This can be an effective counter-measure for the exhaustive search phase, though the pair collection phase is unaffected by it. For KASLR-enabled devices, we also provided the algorithm with the offset (relative to the kernel image) of init_net, which we extracted from the kernel image file given the build ID (can be inferred e.g. from the User-Agent HTTP request header). We tested 2 Linux laptops and 6 Android devices, together covering the vast majority of operating system and hardware parameters that regulate the IP ID generation. Our work demonstrates that using non-cryptographic random number generation of attacker-observable values (even if the values themselves are not security sensitive), may be a security vulnerability in itself, due to an attacker's ability to extract the key/seed used by the algorithm, and use it as a fingerprint of the system. The downside of using TCP-based protocols is the TCP-level retransmission, which can introduce loss of synchronization between the device and the server side, regarding how many packets were sent. Table 3 demonstrates that with an optimal choice of 30 IP addresses, if the tracker keeps only 41 bits of the key tail, he/she will get multiple keys with probability 2.1 × 10 −6 , which is sufficiently small even for a large scale deployment.In the case where multiple keys are emitted by the algorithm (even after truncation, e.g. to 41 bits), two strategies can be applied: either (a) determining that this particular device cannot be assigned an ID (at the price of losing 2.1 × 10 −6 of the devices); or (b) assigning multiple IDs to the device (which makes tracking the device more complicated and more prone to ID collisions). First, the interfering packet must fall into the same counter bucket as that of the measurement packets -this happens with probability of 1 /8192 for a given bucket. Addressing "gaps": The analysis logic can compensate for up to l lost packets in the first class B network (g = 0) by enumerating over all possible ∑ l d=0 J−2+d J−2 gap configurations (each addendum counts all weak compositions of d into J − 1 parts). This work was supported by the BIU Center for Research in Applied Cryptography and Cyber Security in conjunction with the Israel National Cyber Directorate in the Prime Minister's Office.We would like to thank the anonymous reviewers for their feedback, Assi Barak for his help to the project, as well as Avi Rosen, Sharon Oz, Oshri Asher and the Kaymera Team for their help with obtaining a rooted Android device.