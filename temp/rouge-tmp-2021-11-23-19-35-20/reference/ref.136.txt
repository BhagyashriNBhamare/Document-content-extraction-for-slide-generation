Furthermore , it synthesizes and deploys filters to block subsequent attacks, and it adaptively updates them to minimize any potentially negative impact on legitimate users. To evaluate Rampart's effectiveness and efficiency, we demonstrate that it protects two of the most popular web applications, WordPress and Drupal, from real-world and synthetic CPU-exhaustion DoS attacks, and we also show that Rampart preserves web server performance with low false positive rate and low false negative rate. They prevent the system from handling some or even all requests from legitimate users, by overwhelming its available resources, e.g., network bandwidth, disk space, memory, or CPU time. Different from traditional DDoS attacks that rely on flooding a victim system with an extensive amount of traffic, sophisticated DoS attacks require less resources and utilize a lower volume of intensive requests to attack the victim system's availability. Particularly problematic is that sophisticated DoS attacks are difficult to detect by state-of-the-art defenses, such as source address filtering or traceback mechanisms, because they were designed to mitigate large-scale network-layer DDoS attacks [18, 23- 25, 30, 31, 36, 37]. Since a legitimate request can be mistakenly labeled as suspicious, the defense system has to quickly detect and revoke any false positive filter that blocks legitimate requests, to not reduce the application's availability unnecessarily.To address these challenges, we leverage statistical methods and fine-grained context-sensitive program profiling, which allows us to accurately detect and attribute CPU-exhaustion DoS attacks. To prevent pollution attacks against the statistical models, Rampart collects only profiling measurements of normal requests that do not cause a CPU-exhaustion DoS and that do not deviate much from the norm observed in the past. It also enforces a rate limit by network address.Rampart can deploy filters to prevent future suspicious requests from over-consuming the server's CPU time. For example, when launching known attacks without Rampart's protection, then the average CPU usage increases from 32.21% to 95.05% for attacks on Drupal and from 42.21% to 94.14% for attacks on WordPress. Last, we demonstrate Rampart's ability to protect the two applications from unknown vulnerabilities.We make the following technical contributions:• We present Rampart, which is a defense that detects and mitigates sophisticated CPU-exhaustion DoS attacks against web applications by using statistical models and function-level program profiling. • We thoroughly evaluate Rampart with both realworld and synthetic vulnerabilities in two popular web applications, and we demonstrate that it effectively mitigates the impact of low-rate CPUexhaustion DoS attacks and preserves application availability and server performance. Rampart employs a probabilistic algorithm to limit the false positive rate when stopping attacks (Section 2.4) and it constructs filtering rules to adaptively block future attacks using an exploratory algorithm (Section 2.5). Therefore, remote attackers who flood the web server with numerous requests at a time are outside the scope of our threat model. To detect and stop low-rate CPU-exhaustion DoS attacks efficiently, we have to address five core challenges: Different from conventional DDoS attacks, low-rate application-layer DoS attacks are difficult to detect because they do not overwhelm a web server with large number of concurrent requests. For example, simplistic URL-based requests filtering techniques are ill-suited because attackers send requests to endpoints that normal users may also visit. Naturally, any defense mechanism relying on statistical properties may have false positives, i.e., legitimate requests that are blocked by a filter, or requests that might incorrectly be identified as attack requests, and, hence, might cause a false positive filter to be deployed. Therefore, a profile at the application-level or request-level is not suitable to differentiate attack requests from normal requests.To precisely model the resource usage of a web application in different states, Rampart employs contextsensitive function-level program profiling. Specifically, Rampart records the CPU time spent in a function (including time spent by the operating system's kernel on behalf of the function) instead of its wall clock time, because an application instance can be interrupted and rescheduled by the operating system before the function returns. We compute the state when a function c is invoked by its parent function p as follows: state(c) = hash(state(p), c). We employ the name of an endpoint (e.g., /login) as the initial state to differentiate functions with the same name (e.g., main) for different endpoints.When calculating the ID, we do not consider sibling functions, because a varying numbers of sibling functions may have returned, and they represent a similar state in the program. For example, a user may upload a large file that could take a long time to transfer or process.Instead of such a straw-man approach, Rampart monitors the CPU usage of a web server to detect CPUexhaustion DoS attacks, which works because attackers want to occupy as many CPU cores as possible, so that the victim server is less responsive. If r S is greater than a pre-defined threshold R CPU (e.g., 90%), Rampart raises an alarm, thus, indicating that the server is overloaded, and likely victim to a CPU-exhaustion DoS attack.Intuitively, the requests that consumed the most CPU time can be identified as the culprits that caused the CPUexhaustion. If the upload requests consumed slightly more CPU time than the attack requests, then these legitimate requests would be incorrectly detected as the responsible request (false positives) and the real attack requests would evade detection (false negative), although they might always take this long to process.Instead, Rampart leverages the function execution models it learned (Section 2.2) to detect suspicious requests that are statistically different from the historical profile. T C is the CPU time of a function f in the stack; µ and σ are the mean and standard deviation of T C with the ID state( f ) in the database; k is a parameter that represents the distance from the mean. Although Rampart might have not collected execution profiles for all states (function calls) of a web application, it knows the execution profile of each endpoint and it can start detecting attack requests.Another limitation is that an attacker could pollute the profiling records of an application state she selects by gradually increasing the CPU time. To further increase the difficulty for an attacker to pollute or drift profiling records, one can consider strategies that assign higher importance (weight) to older measurement records when computing the mean and standard deviation (Equation 2). Such requests, together with real attack requests, would then be terminated by Rampart until the CPU usage is reduced below R CPU . The observation is that suspicious user requests usually do not consume as much CPU time as attack requests. T o ← 10 ms, s ← 5 ms, ˆ R CPU ← 75% 4. c ← c + 1 9. Rampart suspends the allowed suspicious requests temporarily to free CPU time for other requests, i.e., allowed suspicious requests have lower priority.Rampart's algorithm to decide whether a request should be aborted or suspended is shown in Algorithm 1. ˆ R CPU is the (upper) CPU usage threshold. A CPU timer that expires at every interval i is set in line 6. If the web server's average CPU usage r is greater thanˆRthanˆ thanˆR CPU , then we calculate the probability p (in percent), and abort the request probabilistically (if it is larger than a random value, line 12). For example, we demonstrate in Section 4.1.1 that attackers can still occupy the web server's CPU and cause CPUexhaustion DoS by continuously sending such requests. Therefore, Rampart builds filtering policies using the source IP (network) address, the requested URI, and the request parameters (e.g., the query string and post data, i.e., keys and values of PHP's GET and POST arrays) of an attack request. On the other hand, if the lifespan of a filter is too short, then an attacker can wait and launch another round of attacks.To address the above challenge, we design an exploratory algorithm to adaptively adjust the lifespan of a filter, instead of setting a fixed lifespan. During the secondary lifespan, Rampart lets the application serve one matched request at a time to explore the result of removing the filter. Rampart aborts this request if a CPU-exhaustion DoS attack attempt is detected, and it renews the filter with a longer primary lifespan to penalize the attacker. Rampart drops all incoming requests (line 10) that match the rule (line 8) if it is still active (line 9). Rampart decides if it should explore a request (line 12-15) with a probability depending on the current average server CPU usage r, and the parametersˆRparametersˆ parametersˆR CPU , ˇ R CPU , α, and β (line 5-6). The counter c is incremented by one to set a larger new primary lifespan (line [18][19]. Rampart is unlikely to detect a false positive user request it explores as suspicious again, because the server load is expected to be lower than the upper CPU usage threshold that is used to detect attacks. Rampart is an in-line dynamic analysis system and, hence, may incur significant performance overhead. The execution time of some functions, e.g., string manipulation, however, does strictly depend on its input and we need to take them into account. Fortunately, their execution time is included when Rampart profiles their parent functions, thus, we do not measure them separately.We also introduce a parameter Max_Prof_Depth to control the overall profiling granularity. Practically, Rampart still blocks CPU-exhaustion DoS effectively with low overhead when trading some profiling precision for performance (Section 3 and Section 4). Thus, Rampart can wait until then or until the request was processed, whichever comes first.Finally, Rampart can optionally sample one measurement every X requests, and, in turn, avoid the system calls to write out measurements for X − 1 requests. For our evaluation, we protect two open-source web applications: Drupal 7.13 and WordPress 3.9.0. Following, we first describe our experiment settings and the baseline performance of the two applications (Section 3.1), then we evaluate the performance overhead introduced by Rampart (Section 3.2), and, last, we look at the performance degradation caused by sophisticated DoS attacks with and without Rampart (Section 3.3). Both machines are running Debian Stretch (Linux Kernel 4.9.0). The web server runs Apache 2.4.25 with PHP 7.0.19-1 on an Intel Xeon X3450 quad-core CPU with 2.67 GHz and 16 GB RAM. Importantly, the traffic generator sends two consecutive requests with a 0.1 s pause in-between to simulate a large number of concurrent connections. For each request, we record the timestamps when it was sent (T start ) and when the corresponding response was received (T end ), and we compute the request processing time (RPT = T end − T start ). For WordPress, the server performance remains close to its baseline performance (Table 1) while Max_Prof_Depth was less than five, but performance degrades when more function frames are profiled.To investigate how Max_Prof_Depth might influence server performance, we recorded the number of profiled function frames and the time spent processing the measurement results by our analysis daemon. For WordPress, the CPU overhead is 5.65% and Rampart introduces an additional 0.2 ms (0.83%) for the request processing time on average. The bottom of the figure shows the 5 th percentile, mean, and 95 th percentile of the RPTs for requests sent for each one second interval. Specifically, we evaluate two kinds attacks for both web applications: XML-RPC for both Drupal and WordPress (CVE-2014-5266 [4]), PHPass for Drupal (CVE-2014-9016 [2]) and Wordpress (CVE-2014-9034 [3]). Assuming that the RPT for an attack request is 25 seconds, then the attack traffic rate with 30 attacker sessions is one attack request per second. Indeed, such sophisticated application-layer DoS attacks require significantly fewer resources to be successful.In our experiments, we configure the user traffic generator to run 32 user sessions (Section 3.2), and the attack traffic generator to operate 8 or 16 attacker sessions. In fact, the results show that an attacker sending only 0.17 requests per second (8 / (42 + 5)) can already exhaust CPU resources of a vulnerable server. For 16 attackers, the required attack rate is 0.18 requests per second (16 / (82 + 5)). For Drupal, the two attacks consume between 52.4% and 62.84% additional CPU time and they cause a 36% slowdown in processing user requests. The ARPT of WordPress is more sensitive to both attacks, causing an increase of 40% to 118% in ARPT and consuming between 41.65% and 51.93% additional CPU time. To answer these questions, we perform the following experiments: First, we evaluate Rampart's ability to detect attack requests in the stop-only experiments (Section 4.1.1). In the stop-and-filter experiments (Section 4.1.2), Rampart additionally uses the exploratory algorithm (Algorithm 2) to synthesize and deploy filters to block future attack requests. We assign a unique local IP address to each user/attacker session, so that Rampart can distinguish the different instances.We evaluate two threshold values (50% and 75%) for the CPU usage thresholdˆRthresholdˆ thresholdˆR CPU , which Rampart uses to determine if a server is under attack. Upon closer investigation of the logs and traffic traces of Drupal, some requests took the server more than several seconds to process, even when it was not under attack (black spikes in Figure 1). The ARPT for user requests (ARPT-U) during the PHPass attacks on Drupal and WordPress are close to their baseline counterparts (Table 1). On the other hand, the ARPT for attack requests (ARPT-A) is long, with attack requests being processed for up to 2,294 ms (Drupal) and 787 ms (WordPress) before Rampart aborted them. Finally, we look at 8 attacker sessions launching the PHPass attack against Drupal withˆRwithˆ withˆR CPU set to 50% (Fig- ure 6). In fact, these events are evident in the Drupal PHPass experiment with 8 attacker sessions andˆRandˆ andˆR CPU = 50% (orange dashed line in Figure 7, which represents the number of requests that were dropped because of a filter). Rampart's FPR in stop-and-filter mode is still negligible at less than 0.69%. In fact, 8 of the aborted requests were the initial requests sent by the 8 attackers, i.e., the earliest that any defense could have detected them as suspicious. The results for the remaining three experiments withˆR withˆ withˆR CPU = 50%, namely, XML-RPC on Drupal, PHPass on WordPress, and XML-RPC on WordPress, are shown in Fig Compared to static vulnerability analysis tools that look for specific features in the source code, Rampart does not require an application's source code, nor does it require any knowledge about specific CPU-exhaustion DoS vulnerabilities. The vulnerable code calculates the hash value of a variable $v by repeatedly invoking the md5 function (line 11). In our experiment, attacker requests set $exp to 24 to cause CPU-exhaustion DoS (i.e., 2 24 md5 invocations). Overall, the synthetic attacks experiments demonstrate that Rampart can detect and mitigate CPU-exhaustion DoS attacks regardless of the location of the vulnerable code, i.e., it can detect and mitigate attacks not only for front-facing code, but it can also detect and mitigate attacks for (third-party) library functions. Our prototype is implemented as an extension to the PHP engine (and can be similarly implemented for other languages), and, thus, it can adapt to any change of an application's source code without requiring any manual interaction or reconfiguration. CPU-exhaustion DoS attacks received significant attention from researchers over the past years. Xiao et al. proposed ∆Infer, which is an approach to detect workload-dependent performance bottleneck loops by inferring iteration counts of the loops using complexity models [35]. The program profiling implementation of Rampart is inspired by prior work related to flowsensitive and context-sensitive profiling [6,7,13,15,16]. Sophisticated Denial-of-Service (DoS) attacks targeting application-layer vulnerabilities can cause significant harm by severely degrading the performance and availability of a victim server over a prolonged period with only few carefully crafted requests.In this paper, we present Rampart, which is a system that protects web applications from sophisticated DoS attacks that would otherwise overwhelm the server's available CPU resources through carefully crafted attack requests. This material is based on research supported by DARPA under agreement FA8750-15-2-0084, NSF under agreement CNS-1704253, ONR under grants N00014-09-1-1042, N00014-15-1-2162 and N00014-17-1-2895, and the DARPA Transparent Computing program under contract DARPA-15-15-TCFP-006.