Unfortunately, this open nature also causes security risks, as evidenced by recent incidents of single packages that broke or attacked software running on millions of computers. Studying the potential for running vulnerable or malicious code due to third-party dependencies, we find that individual packages could impact large parts of the entire ecosystem. As the primary source of third-party JavaScript packages for the client-side, server-side, and other platforms, npm is the centerpiece of a large and important software ecosystem.The npm ecosystem is open by design, allowing arbitrary users to freely share and reuse code. 1 In July 2018, compromising the credentials of the maintainer of the popular eslint-scope package enabled an attacker to release a malicious version of the package, which tried to send local files to a remote server. In this paper, we systematically study security risks in the npm ecosystem by analyzing package dependencies, maintainers of packages, and publicly reported security issues. Specifically, our results include:• Installing an average npm package introduces an implicit trust on 79 third-party packages and 39 maintainers, creating a surprisingly large attack surface. • Highly popular packages directly or indirectly influence many other packages (often more than 100,000) and are thus potential targets for injecting malware. • A significant percentage (up to 40%) of all packages depend on code with at least one publicly known vulnerability.Overall, these findings are a call-to-arms for mitigating security risks on the npm ecosystem. While achieving this property for all the packages in the ecosystem is infeasible, packages that are very often downloaded or that have several dependents should aim to achieve it. Locked Dependencies In npm, dependencies are declared in a configuration file called package.json, which specifies the name of the dependent package and a version constraint. Often they choose the later, which leads to a technical lag [12] between the latest available version of a package and the one used by dependents.Heavy Reuse Recent work [11,18] provides preliminary evidence that code reuse in npm differs significantly from other ecosystems. This excessive fragmentation of the npm codebase can thus lead to very high number of dependencies.No Privilege Separation In contrast to, e.g., the Java security model in which a SecurityManager 3 can restrict the access to sensitive APIs, JavaScript does not provide any kind of privilege separation between code loaded from different packages. Publishing Model In order to publish a package, a developer needs to first create an account on the npm website. Strongly related to malicious packages are packages that violate the user's privacy by sending usage data to third parties, e.g., insight 5 or analytics-node 6 . Even though the creators of these packages clearly document the tracking functionality, transitive dependents may not be aware that one of their dependencies deploys tracking code.Exploiting Unmaintained Legacy Code (TM-leg) As with any larger code base, npm contains vulnerable code, some of which is documented in public vulnerability databases such as npm security advisories 7 or Snyk vulnerability DB 8 . Even worse, the common practice of locking dependencies may prevent applications from using fixed versions even when they are available.Package Takeover (TM-pkg) An adversary may convince the current maintainers of a package to add her as a maintainer. Such a collusion attack may happen when multiple maintainers decide to conspire and to cause intentional harm, or when multiple packages or maintainers are taken over by an attacker.To analyze how realistic the above threats are, we systematically study package dependencies, maintainers, and known security vulnerabilities in npm. Definition 3.2 For every p ∈ P t , the set of maintainers M(p) contains all users that have publishing rights for p.Note that a specific user may appear as the maintainer of multiple packages and that the union of all maintainers in the ecosystem is denoted with M . We extract the data from the publicly available npm advisories 10 .10 https://www.npmjs.com/advisories We introduce a set of metrics for studying the risk of attacks on the npm ecosystem. The inverse of package reach is a metric to quantify how many packages are implicitly trusted when installing a particular package.Definition 3.5 For every p ∈ P t , the set of implicitly trusted packages ITP(p) contains all the packages p i for which p ∈ PR(p i ). Therefore, we define maintainer reach MR t (m) and implicitly trusted maintainers ITM t (p) for showing the influence of maintainers. Once again, the distinction between the package and the maintainer-level metrics is for shedding light on the security relevance of human actors in the ecosystem.Furthermore, to approximate the maximum damage that colluding maintainers can incur on the ecosystem (TM-coll), we define an order in which the colluding maintainers are selected:Definition 3.8 We call an ordered set of main- tainers L ⊂ M a desirable collusion strat- egy iff ∀m i ∈ L there is no m k = m i for which ∪ j<i MR(m j ) ∪ MR(m i ) < ∪ j<i MR(m j ) ∪ MR(m k ). Since its inception in 2010, the npm ecosystem has grown from a small collection of packages maintained by a few people to the world's largest software ecosystem. However, the availability of many packages may also cause developers to depend on more and more third-party code, which increases the attack surface for TM-pkg by giving individual packages the ability to impact the security of many other packages. In order to confirm that this is not simply due to removal of more than a hundred packages belonging to the left-pad's owner, we remove all the packages owned by this maintainer. For example, the red line shows that in 2018, about 24,500 packages have reached at least 10 other packages, whereas only about 9,500 packages were so influential in 2015. As of April 1, 2018 (the end of our measurement period), event-stream has a reach of 5,466. Therefore the modified version of package reach considers both transitive regular dependencies and direct dev dependencies.We observe that eslint-scope has a modified reach of more than 100,000 packages at the last observation point in the data set. This incident is a warning for how vulnerable the ecosystem is to targeted attacks and how maintainers influence can be used to deploy malware at scale. The average number of packages controlled by a maintainer raises from 2.5 in 2012 to 3.5 in 2013 and almost 4.5 in 2018. That is, on average every package tends to transitively rely on more and more maintainers over time.In Figure 8 we show the evolution of IT M t , the average number of implicitly trusted maintainers. Out of these, though, there are 643 packages influenced by more than a hundred maintainers.More than 600 highly popular npm packages rely on code published by at least 100 maintainers. The speed of growth for MR t is worrisome, showing that more and more developers have control over thousands of packages. If an attacker manages to compromise the account of any of the 391 most influential maintainers, the community will experience a serious security incident, reaching twice as many packages as in the eventstream attack.391 highly influential maintainers affect more than 10,000 packages, making them prime targets for attacks. When manually inspecting some of the unpatched advisories we notice that a large percentage of unpatched vulnerabilities are actually advisories against malicious typosquatting packages for which no fix can be available.To better understand the real impact of the unpatched vulnerabilities we analyze how much of the ecosystem they impact, i.e., vulnerability reach as introduced in Section 3.2. That is, a vulnerability published in 2015 affects multiple versions of a package released prior to that date, hence influencing the data points corresponding to the years 2011-2014 in Figure 12. Independent of the downwards trend, the fact that for the majority of the time the reach of vulnerable unpatched code is between 30% and 40% is alarming.Up to 40% of all packages rely on code known to be vulnerable. To warn developers about unpatched vulnerabilities in their dependencies, the npm audit tool has been introduced. To estimate the cost of vetting new releases, Figure 17 shows the average number of lines of code [25], Node.cure [10], and from industry practitioners, e.g., Semmle 11 , r2c 12 , and DeepScan 13 . For example, vetting around 140 maintainers cuts down the ITM in half, and vetting around 600 could even reduce ITM to less than five. Moreover, two-factor authentication has its own risks, e.g., when developers handle authentication tokens in an insecure way 14 or when attackers attempt to steal such tokens, as in the eslint-scope incident. They find that developers think that these packages are well implemented and tested and that they increase productivity as the developer does not need to implement such small features herself. Another empirical study on micropackages by Kula et al. [19] has similar results. One way to mitigate these attacks is implemented by Vasilakis et al. [32] in BreakApp, a tool that creates automatic compartments for each dependency to enforce security policies. In another study, Staicu et al. [30] find several injection vulnerabilities due to the child_process module or the eval function. However, we show that the problem is even more serious because for more than half of the npm packages there is no available patch.Client-Side (JavaScript) Security Client-side security is a vast and mature research area and it is out scope to extensively survey it here. Libert et al. [22] perform a HTTP-level analysis of third-party resource inclusions, i.e., dependencies. Overall, the research field is rising with a lot of studied software ecosystems in addition to the very popular ones such as JavaScript which is the focus of our study.Ecosystem Evolution Studying the evolution of an ecosystem shows how fast it grows and whether developers still contribute to it. A similar study that includes the JavaScript ecosystem by Kikas et al. [18] collects data until May 2016 and focuses on the evolution of dependencies and the vulnerability of the dependency network. German et al. [15] study the dependency network of the R language and the community around its user-contributed packages. The overall conclusion is that npm is a small world with high risks. The security risk are "high" in the sense that vulnerable or malicious code in a single package may affect thousands of others, and that a single misbehaving maintainer, e.g., due to a compromised account, may have a huge negative impact.