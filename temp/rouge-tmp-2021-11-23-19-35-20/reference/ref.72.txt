Among all well-known side channels, cache-based timing channels are notoriously severe, leading to practical attacks against certain implementations of theoretically secure crypto algorithms , such as RSA, ElGamal and AES. Our modeling and analysis are based on the formulation of cache access at different program locations along execution traces. Moreover, we have successfully discovered previously unknown issues in two widely used cryptosystems, OpenSSL and Botan. Most software-based solutions only consider cache-based timing channels due to secret-dependent control flow [4,25,38,7,17,44] and hence, cannot prevent subtle leakage found in source code without any secret-dependent control flow (see §2.2.2). More advanced program analyses [6,19,20,60] can detect the subtle leakage missed by those solutions, but they only provide an upper-bound on timing-based information leakage; it is unclear what/where the vulnerability is when those tools report a non-zero upper bound. In contrast, access-driven attacks [24,53] and tracedriven attacks [2] exploit more fine-grained cache behavior and require fewer measurement samples, but they are based on more sophisticated threat models and require deep knowledge about the hardware and software system under attack [53,39,45]. Once confirmed, such cache access variations can be leveraged, with various threat models, for cache-based side-channel attacks.We have implemented the proposed technique as a practical tool named CacheD (Cache Difference), and evaluated CacheD towards multiple real-world cryptosystems. Moreover, we have successfully discovered previously unknown issues in two widely used cryptosystems, OpenSSL (version 0.9.7c and 1.0.2f) and Botan (version 1.10.13). Within 17 CPU hours, CacheD identified 156 vulnerable program points along the analyzed execution traces of over 120 million instructions. • By monitoring cache traffic of the test cases using a hardware simulator, we have confirmed the identified vulnerabilities as true positives: different secrets provided by CacheD lead to observable cache behavior difference, which further reveals potential timing channels. In most 0 L C-S N Line Offset Set Index Tag Figure 1: Cache indexing of S-way set-associative caches with the line size of 2 L bytes the capacity of 2 C bytes for a 2 N -byte address space. For set-associative caches, the organization is fully decided by three factors, i.e., the cache size, the line size, and the set size, where the set size is usually referred to as the number of ways the cache is associated in.For a 2 K -way associative cache with the line size of 2 L bytes and a total capacity of 2 C bytes, it will be divided into 2 C−K sets. If the tag matches, the line offset is used to locate the data inside the cache line; otherwise, accessing memory at that address leads to a cache miss, and the processor will have to retrieve the data from the lower layers of the memory hierarchy.The low L bits of the address used to access the cache is irrelevant to timing, since the CPU always retrieve a whole cache line at a time. Such leakage is best illustrated in the square-andmultiply implementation (shown below) of modular exponentiation, the core computation of cyphers such as RSA and ElGamal.The pseudo-code computes b e mod m, where we assume the n-bit secret exponent e is in its binary representation and e [i] is the i-th bit of e. Note that in this implementation, the branch condition at line 4 depends on one bit of e. Moreover, the real implementation of r = r * b mod m involves memory reads since b and e consist of multiple words in RSA and ElGamal. Consequently, an attacker that probes the cache usage of this victim program can recover the exponent, and hence, reveals the private key of RSA [1,59] and ElGamal [63,34].1 r = 1; 2 for i from n−1 to 0 { 3 r = r * r mod m;4 if (e[i] == 1) { 5 r = r * b mod m; 6 } 7 }Previous work shows that secret-dependent control flow can be identified via information flow analysis, and be mitigated by removing secret-dependent branches or balancing branches conditioned on confidential data [4,25,38,7,17]. Hence, a cache-probing attack (e.g., prime-and-probe attack [42,53,11,63,34]) may peek which cache line is accessed, and consequently, infer at least some bits of the secret in this example.We emphasize that although we use this contrived running example in this paper for its simplicity, variants of the vulnerability illustrated in this example are found and exploited in real-world implementations of crypto systems, such as the AES implementation in OpenSSL, exploited in [24,42,53], the RSA and ElGamal implementations in Libgcrypt, exploited in [59,34]. This strong threat model captures most cache-based timing attacks in the literature, such as an attacker who observes cache accesses by measuring the latency of the victim program (e.g., cache reuse attacks [43,11,10,24] and evict-and-time attack [42]), or the latency of the attacker's program (e.g., prime-andprobe attacks [42,53,11,63,34]). Firstly, our threat model is stronger than those based on cache hit/miss, since in most architectures, a trace of cache lines being accessed uniquely determines cache hit/miss at any program point. With the help of constraint solvers, we can logically deduce whether sensitive data would affect the cache behavior of the program and hence, reveal potential timing channels.Operationally, given a program point where a memory access occurs, we can model the memory address being accessed as a symbolic formula F( k), where k, as the only free variables in F, stands for program secrets. Therefore, instead of trying to solve F( k) = F( k ), we construct F as a bit vector and solve F( k) L = F( k ) L, where is the right shift operation on bit vectors. To find two secrets that result in different cache behaviors, we further replace symbol k in formula F(k) with a fresh symbol, and check the satisfiability of F(k) 6 = F(k ) 6 using a theory prover; a reasonable solver will answer yes, meaning the constraint is satisfiable, with a solution such as[k = 1, k = 30]Hence, we have successfully identified that different secrets (e.g., 1 and 30) can lead to the access of different cache lines at line 9 of the sample code. Actually, by feeding different secrets (1 or 30) to this function, memory access in the above case hits cache line 0 or 1, which enables attackers to launch cache probing attacks (e.g., prime-and-probe attacks [42,53,11,63,34]) to infer the value of the secret.Another obvious secret dependent memory access is at line 10, which holds the memory access formula (also for the first iteration of the loop) as:G(k) ≡ 10 + 4 · (k mod 128) mod 4According to constraint solving, G(k) 6 = G(k ) 6 is unsatisfiable at this time. In addition, since the inputs to CacheD are execution traces generated from program executables, CacheD is also capable of identifying vulnerabilities introduced by compiler optimizations or even commonly used obfuscations without additional efforts. Previously, finding such vulnerabilities are challenging-if possible at all-towards industrial-strength cryptosystems.The trace-based analysis is usually unable to cover all program points; in other words, to produce execution traces that can cover the vulnerable code, it might require deliberate selection of proper program inputs to trigger the vulnerability. Symbolic execution is considerably more precise than traditional data-flow analysis, and when constraint solver finds a solution for memory accessing formula, it naturally provides counter examples that lead to the variant cache accesses, making it easier for developers to reveal underling issues in their software.Soundness vs. Precision. Constraint solving will not introduce false positives as a positive solution is really satisfiable for the formula, but it might miss positives. The trace is then fed into CacheD to perform taint analysis; we mark the secret as the taint seed ( §4.2) and propagate the taint information along the trace to identify instructions related to the usage of the secret.CacheD then symbolizes the secret into one or several symbols (each symbol represents one word), and performs symbolic execution along the tainted instructions on the trace ( §4.3). As aforementioned, we check the satisfiability of (F( k) L = F( k ) L) ∧ C; if satisfiable, the solution to k and k represent different secret values that can lead to different cache behavior of this program point. We assume the instrumentation tools also dump the context information (including the value of every register) of every executed instruction as well.Locating Secrets in the Trace. This information serves as the seed for the taint analysis and symbolic execution in later stages.While the secrets (e.g., the private key or a random number) are usually obvious in the source code, it may not be straightforward to identify the location of the secret in an execution trace, since variable names are absent in the assembly code. With further reverse engineering effort in small regions, we can eventually recognize the location of the secret in the assembly code, as a register, or a sequence of memory cells in the memory.Although currently this step is largely manual, it is likely that it can be automated by a secret-aware compiler, which tracks the location of secrets throughout the compilation; however, we leave this as future work. After the taint analysis, we keep the instructions whose operands are tainted.Taint propagation rules define how tainted information flows through instructions, memories and CPU flags, as well as what operations introduce new taint or remove existing taint. More specifically, the taint module of CacheD keeps a set, where each element is the address of tainted memory cell. For each memory access, we compute the address through the concrete register values recorded in the context information. Our tainting rule defines that whenever the registers representing either the base address or the offset are tainted, we would propagate the taint to the contents of the accessed memory cells. To precisely track the secret information flow, CacheD record taint propagations towards CPU flags.In general, CPU flags could be modified according to the computation results of certain instructions, for example, flag ZF will be set to one if the result of an SUB (subtraction) operation is zero. CacheD generates a fresh symbol (for simplicity's sake, we name such symbol as key symbol) each time when the memory read has a different offset (since it indicates a different part of the secret memory region is visited). As aforementioned ( §3.1), we collect all the conditions (i.e., some formulas evolving CPU flags) of the branches along the trace and conjunct them into the path condition. Consistent with our taint propagation rules which captures information flow through memory accesses ( §4.2), for a memory load operation whose addressing formula containing key symbols (i.e., either the base address or the memory offset is computed from secrets), we would symbolize the memory cell with a fresh key symbol if it is visited for the first time. Symbolic execution interprets programs with logical formulas instead of concrete values so that the semantics captured are not specific to a single input. In general, for a memory load operationload reg, [F( k)]where F( k) is the memory addressing formula through the secret k, and reg stores the loaded content from the memory. There exist three different cases regarding the solution of our constraint solver:• To test whether the array index, and hence the fetched content, may differ in two executions with different keys, CacheD checks the formula (F( k) = F( k )) ∧ C. Hence, we create a fresh key symbol and use it to update the memory load output.In general, we consider independent vulnerabilities are highly informative to attackers; independent vulnerabilities probably indicate the most-likely attack surface of the victim, because stealing secret through "dependent" vulnerabilities need additional efforts to learn the program memory layout. While this rule reasonably captures the information flow through memory accesses, we terminate the taint propagation for one specific case, given the domain knowledge of cryptosystems being analyzed.To speed up processing, the sliding-window based modular exponentiation algorithm leverages a two-level "precomputed table" to store the modular exponentiation values of the base regarding some predefined windowsized value. While our current implementation (including CacheD and the Pin plugin) analyzes binaries on the 32-bit Linux platforms (i.e., binaries with the ELF format), we emphasize that the proposed technique is mostly independent with the underlying architecture details, and hence not difficult to port to other platforms (e.g., Windows or 64-bit Linux). We present a detailed study of two independent vulnerable program points found in RSA implementation of Libgcrypt 1.6.1 in §7.3, and also compare our findings of RSA and ElGamal with existing literatures in §7.4.1. Although trace-based analysis is in general not sufficient to "prove" a cryptosystem as free of information leakage, considering related research as less scalable ( [19]), CacheD presents a scalable and practical way to study such industrial strength cryptosystems. To study whether the positives can lead to real cache difference during execution, we employ a commonly-used computer architecture simulator-gem5 [9]-to check the identified vulnerable program points. We have also confirmed that cache statuses are different at the vulnerable program points for most of the test cases.There are two test cases (row 5 and 7 in Table 4) that show identical cache status at the vulnerable program points. When analyzing the execution trace, CacheD successfully identified two secret-dependent memory accesses (line 4-5 in Fig. 4b), and by inquiring the constraint solver, CacheD finds two pairs of e that can lead to the access of different cache lines for the first and second memory accesses, respectively (the "solutions" in gcry mpi t base, 3 gcry mpi t expo, gcry mpi t mod) { 4... 1 0x44156a: 0x7fffffffe440 hit 2 0x441572: 0x7fffffffe3c8 hit 3 0x44156a: 0x7fffffffe438 hit 4 0x441572: 0x7fffffffe3c4 hit 5 0x44156a: 0x7fffffffe3d8 hit 6 0x441572: 0x7fffffffe394 hit 7 0x44156a: 0x7fffffffe408 hit 8 0x441572: 0x7fffffffe3ac hit 1 0x44156a: 0x7fffffffe3f0 hit 2 0x441572: 0x7fffffffe3a0 hit 3 0x44156a: 0x7fffffffe438 hit 4 0x441572: 0x7fffffffe3c4 hit 5 0x44156a: 0x7fffffffe3d8 miss 6 0x441572: 0x7fffffffe394 miss 7 0x44156a: 0x7fffffffe408 miss 8 0x441572: 0x7fffffffe3ac hit (c) Hardware simulation results for the first memory access (e is 0x10000016 and e' is 0x1000003e). Comparing these two results, we can observe that different cache lines are accessed (corresponding memory addresses are marked as red at line 1-2), which further leads to timing difference of three cache hit vs. miss (corresponding cache statuses are marked as red at line 5-7). Moreover, this modular exponentiation function is used by both RSA and ElGamal decryption procedures; two independent vulnerable program points found in the ElGamal implementation (row 4 in Table 2) are also due to these table queries. Analysis of another OpenSSL (1.0.2f) gave similar results: CacheD identifies 32 vulnerable program points of secret-dependent lookup table queries (Table 2). Since the key length by bit may not be a multiple of the key length by byte, the code uses a lookup table in BN num bits word to determine the exact number of bits in the last entry of a->d. CacheD points out that accessing this lookup table will lead to a cache difference, thus leaking information about the most significant several bits of the secrete key which are stored in a->d [a->top -1]. Besides the implementations evaluated in this work (version 1.10.13), we notice that this vulnerability affects several other versions of Botan, including 1.10.12, 1.10.11, and 1.11.33. Recently, advanced program analyses are proposed to identify those subtle cachebased timing channels [6,19,20,60], but they only provide an upper-bound on timing-based information leakage; it is unclear what/where the vulnerability is when those tools report a non-zero upper bound.At the system level, Düppel [64] clears L1 and L2 cache before context switching; but it cannot mitigate the last-level cache-based attack, such as [34]. With the help of symbolic execution techniques, CacheD models the memory addresses at each program point as logical formulas so that constraint solvers can check whether sensitive program data affects cache behavior, thus revealing potential timing channels. [16] CHEN, S., WANG, R., WANG, X., AND ZHANG, K. Sidechannel leaks in web applications: A reality today, a challenge tomorrow.