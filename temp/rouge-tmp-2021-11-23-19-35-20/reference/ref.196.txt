This paper proposes JEDI (Joining Encryption and Delegation for IoT), a many-to-many end-to-end encryption protocol for IoT. Through careful protocol design and implementation, JEDI can run across the spectrum of IoT devices, including ultra low-power deeply embedded sensors severely constrained in CPU, memory, and energy consumption. A natural step to secure privacy-sensitive data is to use end-to-end encryption to protect it during transit.Existing protocols for end-to-end encryption, such as SSL/TLS and TextSecure [44], focus on one-to-one communication between two principals: for example, Alice sends a message to Bob over an insecure channel. Such IoT systems demand many-to-many communication among decoupled senders and receivers, and require decentralized delegation of access to enforce which devices can communicate with which others.We investigate existing IoT systems, which currently do not encrypt data end-to-end, to understand the requirements on an end-to-end encryption protocol like JEDI. Recipients subscribe to a resource by asking the router to send them messages addressed to that resource.Many systems for smart buildings/cities, like sMAP [35], SensorAct [7], bw2 [5], VOLTTRON [82], and BAS [56], organize resources as a hierarchy. For example, a sensor that measures temperature and humidity might send its readings to the two URIs buildingA/floor2/roomLHall/sensor0/temp and buildingA/floor2/roomLHall/sensor0/hum. Generally, a principal with access to a set of resources can give another principal access to a subset of those resources.Vanadium [77] and bw2 [5] introduced decentralized delegation (SPKI/SDSI [31] and Macaroons [13]) in the smart buildings space. Since then, decentralized delegation has become the state-of-the-art for access control in smart buildings, especially those geared toward large-scale commercial buildings or organizations [42,52]. Sensors that measure temperature, humidity, or occupancy may be deployed in a building; such sensors are battery-powered and transmit readings using a low-power wireless network. JEDI encrypts messages end-to-end for confidentiality, signs them for integrity while preserving anonymity, and supports delegation with caveats, all while allowing senders and receivers to be decoupled via a resource hierarchy. JEDI differs from existing encryption protocols like SSL/TLS, requiring us to overcome a number of challenges: Figure 2: JEDI keys can be qualified and delegated, supporting decentralized, cryptographically-enforced access control via key delegation. Realizing this expressive model while working within the resource constraints of IoT devices ( §1.1.2) 3. Only principals permitted to subscribe to a URI are given keys that can decrypt messages published to that URI.IoT systems that support decentralized delegation (Vanadium, bw2), as well as related non-IoT authorization systems (e.g., SPKI/SDSI [31] and Macaroons [13]) provide principals with tokens (e.g., certificate chains) that they can present to prove they have access to a certain resource. In the past, the campus facilities manager, who is the authority for the hierarchy, granted a key for buildingA/* to the building manager, who granted a key for buildingA/floor2/* to the lab director. A number of IoT systems [70,74] use only simple cryptography like AES, SHA2, and ECDSA, but these primitives are not expressive enough to encode JEDI's rendezvous point, which must support hierarchically-structured resources, non-interactive expiry, and decentralized delegation.Existing systems [83][84][85] with similar expressivity to JEDI use Attribute-Based Encryption (ABE) [12,48]. Unfortunately, ABE is not suitable for JEDI because it is too expensive, especially in the context of resource constraints of IoT devices. Thus, JEDI achieves expressivity commensurate to IoT systems that do not encrypt data-significantly more expressive than AESonly solutions-while allowing several years of battery life for low-power low-cost IoT devices. For example, consider an office space with an occupancy sensor in each office, each publishing to the same URI buildingA/occupancy. To address this challenge, we adapt the WKD-IBE scheme that we use for end-to-end encryption to achieve an anonymous signature scheme that can encode the URI and expiry and support decentralized delegation. As we discuss in §5, any cryptographically-enforced scheme that provides immediate revocation (i.e., keys can be revoked without waiting for them to expire) is subject to the fundamental limitation that the sender of a message must know which recipients are revoked when it encrypts the message. For our evaluation, we use JEDI to encrypt messages transmitted over bw2 [5,27], a deployed open-source messaging system for smart buildings, and demonstrate that JEDI's overhead is small in the critical path. We also evaluate JEDI for a commercially available sensor platform called "Hamilton" [49], and show that a Hamilton-based sensor sending one sensor reading every 30 seconds would see several years of battery lifetime when sending sensor readings encrypted with JEDI. In Fig. 2, the campus facilities manager, when granting access to buildingA/* to the building manager, need not be concerned with the structure of the subtree rooted at buildingA. In the example in Fig. 2, Alice might also receive JEDI keys from her landlord granting access to resources in her apartment building, in a separate hierarchy where her landlord is the authority. A common design used by such systems is to have a central broker (or router) forward messages; however, an adversary who compromises the broker can read all messages. Publishers encrypt their messages with JEDI before passing them to the underlying communication system (without knowledge of who the subscribers are), and subscribers decrypt them with JEDI after receiving them from the underlying communication system (without knowledge of who the publishers are). A subscriber requests this key from the trusted key server, which must first check if the subscriber is authorized to receive it. The subscriber can decrypt messages for a URI using this key, and contact the key server for a new key when the key expires. In the campus IoT example above, if a building admin receives access to all sensors and all their different readings for a building, the admin must obtain a potentially very large number of keys, instead of one key for the entire building. JEDI accepts that gateways may be necessary for Internet connectivity, but does not rely on them for security-JEDI's cryptography is lightweight enough to run directly on the low-power sensor nodes. Since JEDI decouples senders from receivers, it has no requirements on what happens at any intermediaries (e.g., does not require messages to be forwarded from publishers to subscribers in any particular way). JEDI does not attempt to hide metadata relating to the actual transfer of messages (e.g., the URIs on which messages are published, which principals are publishing or subscribing to which resources, and timing). As explained in §1.1.2, although ABE, the obvious choice, is too heavy for low-power devices, we identify WKD-IBE, a more lightweight identitybased encryption scheme, as sufficient to achieve JEDI's properties. A pattern P 1 matches a pattern P 2 if, for all i ∈ [1, ], either P 1 (i) = ⊥ or P 1 (i) = P 2 (i). • Setup(1 κ , 1 ) → Params, MasterKey;• KeyDer(Params, Key Pattern A , Pattern B ) → Key Pattern B ,derives a key for Pattern B , where either Key Pattern A is the MasterKey, or Pattern A matches Pattern B ;• Encrypt(Params, Pattern, m) → Ciphertext Pattern,m ;• Decrypt(Key Pattern , Ciphertext Pattern,m ) → m.We use the WKD-IBE construction in §3.2 of [1], based on BBG HIBE [17]. For example, the original suggested use case of WKD-IBE was to generate secret keys for a user's email addresses in all valid subdomains, such as sysadmin@*.univ.edu [1]. We think of the components of a WKD-IBE pattern as "slots" that are initially empty, and are progressively filled in with calls to KeyDer. To combine a hierarchy of maximum depth 1 (e.g., the URI hierarchy) and a hierarchy of maximum depth 2 (e.g., the expiry hierarchy), one can Setup WKD-IBE with the number of slots equal to = 1 + 2 . When a principal receives a message, it searches its key store, using the URI and time included with the ciphertext, for a key to decrypt it.In summary, JEDI provides the following API:Encrypt(Message, URI, Time) → Ciphertext Decrypt(Ciphertext, URI, Time, KeyStore) → Message Delegate(KeyStore, URIPrefix, TimeRange) → KeySet AcceptDelegation(KeyStore, KeySet) → KeyStoreNote that the WKD-IBE public parameters are an implicit argument to each of these functions. We use the first 1 slots to encode the URI, and the last 2 slots to encode the time.Given a URI of length d, such as a/b/c (d = 3 in this example), we split it up into individual components, and append a special terminator symbol $: ("a", "b", "c", $). Given the private key for S, one can use WKD-IBE's KeyDer to fill in slots 3 . . . 1 . This allows one to generate the private key for a/b, a/b/c, etc.-any URI for which a/b is a prefix. The hierarchical structure for time makes it possible to succinctly grant permission for an entire day, month, or year. , change the granularity of expiry (e.g., minutes instead of hours), trade off encryption time for key size (e.g., deeper/shallower tree), or use a more regular structure (e.g., binary encoding with logarithmic split). To encrypt a message m in JEDI, one samples a symmetric key k, and encrypts k with JEDI to produce ciphertext c 1 . Therefore, most messages only incur cheap symmetric-key encryption.This also reduces the load on subscribers. Even with hybrid encryption and key reuse to perform WKD-IBE encryption rarely, WKD-IBE contributes significantly to the overall power consumption on low-power devices. Additional exponentiations are needed at the end of each day, month, and year, but they can be eliminated by maintaining additional precomputed values corresponding to the start of the current day, current month, and current year. Suppose JEDI is instantiated with a Selective-ID CPA-secure [1,16], history-independent (defined in our extended paper [57]) WKD-IBE scheme. It is sufficient for JEDI to use a CPAsecure (rather than CCA-secure) encryption scheme because JEDI messages are signed, as detailed below in §4. To prevent an attacker from flooding the system with messages, spoofing fake data, or actuating devices without permission, JEDI must ensure that a principal can only send a message on a URI if it has permission. For example, an application subscribed to buildingA/floor2/roomLHall/ sensor0/temp should be able to verify that the readings it is receiving are produced by sensor0, not an attacker. In addition to subscribers, an intermediate party (e.g., the router in a publish-subscribe system) may use this mechanism to filter out malicious traffic, without being trusted to read messages. Abdalla et al. [1] observe that WKD-IBE can be extended to a signature scheme in the same vein as has been done for IBE [18] and HIBE [46]. Just as consumers receive decryption keys via a chain of delegations ( §3), publishers of data receive these signing keys via chains of delegations. The technique in §4.2.1 transforms an encryption scheme into a signature scheme, but the resulting signature scheme is not necessarily anonymous. Because signatures, as described in §4.2.1, are private keys generated with KeyDer, they are also history-independent; a signature for a pattern has the same distribution regardless of the key used to generate it. We can circumvent this by instead (1) choosing a symmetric key k every hour, (2) signing k at the start of each hour (using WKD-IBE for anonymity), and (3) using k in an authenticated broadcast protocol to authenticate messages sent during the hour. However, for the sense-and-send use case typical of smart buildings, sensors anyway publish messages on a fixed schedule (e.g., one sample every x seconds), allowing the key to depend only on the message index. Re-randomization can be accelerated using the same precomputed value Q S that JEDI uses for encryption ( §3.6.2), which can be efficiently adjusted from one pattern to the next. Finally, WKD-IBE signatures as originally proposed ( §4.2.1) are verified by encrypting a random message under the pattern corresponding to the signature, and then attempting to decrypt it using the key acting as a signature. This implies that even a powerful adversary who observes the private keys held by all principals cannot distinguish signatures produced by different principals, for a fixed message and pattern. Some disadvantages of the solution in §5.1 are that (1) principals must periodically come online to refresh delegations, and (2) revocation only takes effect when the delegated key expires. Neither solution is ideal: (1) makes assumptions about how messages are delivered, which we have avoided thus far ( §2), and requires trust in an intermediary to modify ciphertexts, and (2) weakens the decoupling of senders and receivers ( §1.1). To encrypt a message that is decryptable by a subset of users, one finds a collection of subtrees that include all leaves except those corresponding to revoked users and encrypts the message multiple times using the public keys corresponding to the root of each subtree. Then, they encrypt new messages using the CS method, choosing subtrees that cover all leaves except those corresponding to revoked leaves. Thus, if Alice has k leaves, she must store secret keys for O(k + log n) nodes, where n is the total number of leaves (so the depth of the tree is log n). We give each node v i an identifier id(v i ) ∈ {0, 1} * that describes the path from the root of the tree to that node. As discussed in §3.2, JEDI uses WKD-IBE in a way that provides multiple concurrent hierarchies, each in the vein of HIBE. The size of secret keys is O(log k + log n) after our modifications to the CS method, so JEDI keys grow by this factor, to a total of O((log k + log n) · log T ) WKD-IBE keys, where T is the length of the time range for expiry.The construction in this section works to revoke decryption keys, but cannot be used with anonymous signatures ( §4.2). To keep the revocation list private, one can use JEDI's encryption to ensure that only principals with permission to publish to a particular resource can see which keys are revoked for that resource (since publishers too have signing keys, as described in §4). A single JEDI ciphertext, with revocation enabled, consists of O(r log n r ) WKD-IBE ciphertexts. First, to extend JEDI's hybrid encryption to work with revocation, it is sufficient to additionally rotate keys whenever the revocation list changes, in addition to the end of each hour (as in §3.6.1). This not only makes the broadcast encryption more efficient (smaller r), but also causes the effective revocation list for a stream of data to change even more rarely, allowing JEDI to benefit more from hybrid encryption. We expect JEDI's key delegation to be computed on relatively powerful devices, like laptops, smartphones, or Raspberry Pis; less powerful devices (e.g., right half of Fig. 1) will primarily send and receive messages, rather than generate keys for delegation. State-of-the-art cryptography libraries implement BLS12-381, but none of them, to our knowledge, optimize for microarchitectures typical of low-power embedded platforms. We focus on ARM Cortex-M, an IoT-focused family of 32-bit microprocessors typical of contemporary low-power embedded sensor platforms [28,49,53]. Cortex-M3 and Cortex-M4, which are more commonly used than Cortex-M0+, have instructions for 32-bit multiply-accumulate which produce the entire 64-bit result; we expect JEDI to be more efficient on those processors.We also wrote assembly to optimize BLS12-381 for x86-64 and ARM64, representative of server/laptop and smartphone/Raspberry Pi, respectively (first two tiers in Fig. 1). Thus, our Go library, which runs on these non-low-power platforms, also benefits from low-level assembly optimizations. Principals must present DOT chains when publishing/subscribing to resources, and the router verifies them. Note that a compromised router can read messages.We use JEDI to enforce bw2's authorization semantics with end-to-end encryption. Benchmarks labeled "Sensor" were produced on a commercially available ultra low-power environmental sensor platform called "Hamilton" with an ARM Cortex-M0+ @ 48 MHz. As expected from Fig. 1, the Raspberry Pi performance is an order of magnitude slower than Laptop performance, and performance on the Hamilton sensor is an additional two-to-three orders of magnitude slower. Fig. 6 does not include the sensor platform; §7.3 thoroughly treats performance of JEDI on low-power sensors.In Figure 6a, we used a pattern of length 20 for all operations, which would correspond to, e.g., a URI of length 14 and an Expiry hierarchy of depth 6. On a laptop, all WKD-IBE operations take less than 10 ms with up to 20 attributes. In general, encryption is O(r log n r ), where r is the number of revoked leaves. Decryption time remains almost the same, since only one WKD-IBE decryption is needed.To benchmark revocation, we use a complete binary tree of depth 16 (n = 65536). In bw2, the two critical-path operations are publishing a message to a URI, and receiving a message as part of a subscrip- We measure the overhead of JEDI for these operations because they are core to bw2's functionality and would be used by any messaging application built on bw2. We also include measurements from a strawman system with pre-shared AES keys-this represents the critical-path overhead of an approach based on the Trusted Key Server discussed in §2. For large messages, the cost of symmetric key encryption dominates. For a DOT to be usable, it must be inserted into bw2's We use a commercially available sensor platform called "Hamilton" [4,49] built around the Atmel SAMR21 systemon-chip (SoC). For battery lifetime calculations, we assume that the platform is powered using a CR123A Lithium battery that provides 1400 mAh at 3.0 V (252 J of energy). Our goal is to validate that JEDI is practical for an ultra low-power sensor platform like Hamilton, in the context of a "sense-and-send" application in a smart building. We estimate JEDI's average current based on the current, duration, and frequency (once per hour, for these estimates) of JEDI operations, and add it to the average current of the "AES Only" setup. Battery life is several years even with JEDI, acceptable for IoT sensor platforms. Performing WKD-IBE operations requires only 6.5 KiB of data memory, which fits comfortably within the 32 KiB of data memory (RAM) available on the SAMR21. At the start of an hour, one computes the entire chain, storing 10 hashes equally spaced along the chain, each separated by 5 hashes. Our assembly optimizations ( §6) provide an additional 4-5x improvement. Table 4 contains quantitative comparisons to the cryptography used by these systems; for those schemes based on bilinear groups, we re-implemented them using our JEDI crypto library ( §6.1) for a fair comparison. Note that, although Trusted Key Server ( §2) and PICADOR [23] encrypt data in flight, granting or revoking access to a principal requires participation of an online trusted party to generate new keys. In ABE-based schemes, however, attributes/policies attached to keys can describe more complex sets of resources than JEDI. Based Table 3, the power cost of a WKD-IBE operation even when only invoked once per hour contributes significantly to the overall energy consumption on the low-power IoT device; using KP-ABE instead of WKD-IBE would increase this power consumption by an order of magnitude, reducing battery life significantly. (1) The Trusted Key Server allows access to resources to be managed by arbitrary policies, but relies on a central trusted party who must be online whenever a user is granted access or is revoked. JEDI does not require this, allowing different subtrees of the hierarchy to be managed separately ( §1.1, "Delegation"). Although + Only symmetric crypto in common case -60 ms encrypt for first time after key rotation (20x slower than JEDI: 3 ms) -Impractical for low-power sense-and-send This paper: WKD-IBE [1] with Optimizations, as used in JEDI + Delegation is multi-hop + Succinct delegation of subtrees of resources (or more complex sets, §3.7) + Non-interactive expiry + After key rotation (e.g., once per hour), 3 ms encrypt, 4 ms decrypt (Fig. 6a) + Only symmetric crypto in common case + Practical for ultra low-power "sense-andsend" without crypto accelerator seemingly a good match for resource hierarchies, HIBE cannot be used as a black box to efficiently instantiate JEDI. However, PICADOR requires a central Policy Authority to specify access control, by creating a re-encryption key for every permitted pair of publisher and subscriber. JEDI is complementary to authorization services for IoT, such as bw2 [5], Vanadium [77], WAVE [6], and AoT [68], which focus on expressing authorization policies and enabling principals to prove they are authorized, rather than on encrypting data. The JEDI cryptography library is available at https:// github.com/ucbrise/jedi-pairing and our implementation of the JEDI protocol for bw2 is available at https: //github.com/ucbrise/jedi-protocol.