We present REM (Resource-Efficient Mining), a new blockchain mining framework that uses trusted hardware (Intel SGX). To address the risk of compromised SGX CPUs, we develop a statistics-based formal security framework, also relevant to other trusted-hardware-based approaches such as Intel's Proof of Elapsed Time (PoET). We experiment with four example applications as useful workloads for our implementation of REM, and report a computational overhead of 5 − 15%. Despite their imperfections [21,31,33,61,66], blockchains [34,60,62] have attracted the interest of the financial and technology industries [11,20,30,41,64,69] as a way to build a transaction systems with distributed trust. One fundamental impediments to the widespread adoption of decentralized or "permissionless" blockchains is that Proofs-of-Work (PoWs) in blockchains are wasteful.PoWs are nonetheless the most robust solution today to two fundamental problems in decentralized cryptocurrency design: How to select consensus leaders and how to apportion rewards fairly among participants. Existing schemes rely on esoteric resources [49], have low recycling rates [58], or are centralized [36]. Other consensus approaches, e.g., BFT or Proof of Stake, are in principle waste-free, but restrict consensus participation or have notable security limitations.Intel recently introduced a new approach [41] to eliminating waste in distributed consensus protocols that relies instead on trusted hardware, specifically a new instruction set architecture extension in Intel CPUs called Software Guard Extensions (SGX). SGX permits the execution of trustworthy code in an isolated, tamper-free environment, and can prove remotely that outputs represent the result of such execution. First, in the basic version of PoET, an attacker that can corrupt a single SGX-enabled node can win every consensus round and break the system completely. REM, however, avoids PoET's stale chip problem by substituting PoUWs for idle CPU time, disincentivizing the use of outmoded chips for mining. Moreover, we describe how small changes to the SGX feature set could enable even more efficient solutions.Unlike PoET, REM addresses the broken chip problem. For REM, we set forth a rigorous statistical testing framework for mitigating the damage of broken chips, provide analytic security bounds, and empirically assess its performance given the volatility of mining populations in real-world cryptocurrencies. Our techniques, which combine static and dynamic program analysis techniques, are of independent interest.We have implemented a complete version of REM, encompassing the toolchain that instruments tasks to produce PoUWs, compliance checking code, and a REM blockchain client. As examples, we experiment with four REM workloads, including a commonly-used proteinfolding application and a machine learning application. The resulting overhead is about 5 − 15%, confirming the practicality of REM's methodology and implementation. • A methodology for trustworthy performance instrumentation of SGX applications using a combination of static and dynamic program analysis and SGXbacked trusted compilation ( §5). Occasionally, two or more miners might nearly simultaneously generate blocks that have the same parent, forming two branches in the blockchain and breaking its single-chain structure. To prevent such an attack, a block is regarded as valid only if it contains proof that its creator has performed a certain amount of work, a proof known as a Proof of Work (PoW). The expected amount of work to solve a cryptopuzzle, known as its difficulty, is set per a deterministic algorithm that seeks to enforce a static expected rate of block production by miners (e.g., 10 minute block intervals in Bitcoin). Compensation to miners is granted per block generated, leading to an expected miner revenue that is proportional to the miner's hashrate.As the mining power that is invested in a cryptocurrency grows, the cryptocurrency's cryptopuzzle difficulty rises to keep the block generation rate stable. It should also be possible to perform by any entity with access to the blockchain -If the proofs or data needed for validation are made selectively available by a single entity, for instance, that entity becomes a central point of control and failure. Thus the isolated execution in SGX may be viewed in terms of an ideal model in which a process is guaranteed to execute correctly and with perfect confidentiality, but relies on a (potentially malicious) operating system for supporting services such as I/O, etc. Our basic security model assumes ideal isolated execution, but as we detail in Section 4, we have baked a defense against compromised SGX CPUs into REM.Attestation SGX allows a remote system to verify the software running in an enclave and communicate securely with it. SGX signs quotes in attestations using a group signature scheme called Enhanced Privacy ID or EPID [67]. The basic idea of PoUW, and thus REM, is to replace the wasteful computation of PoW with arbitrary useful computation. A miner proves that a certain amount of useful work has been dedicated to a specific branch of the blockchain. It is only partially decentralized, though, in that it relies for security on two key assumptions about the hardware manufacturer's behavior.First, we must assume that Intel correctly manages identities, specifically that it assigns a signing key (used for attestations) only to a valid CPU. Such misbehavior would be publicly visible and similarly damaging to Intel if unjustified.Even assuming trustworthy manufacturer behavior, though, a limited number of individual CPUs might be physically or otherwise compromised by a highly resourced adversary (or adversaries). In SGX, the EPID signature scheme for attestations has a linkable (pseudonymous) mode [44,8,67], which permits anyone to determine whether two signatures were generated by the same CPU. There are three types of entities in the ecosystem of REM: A blockchain agent, one or more REM miners, and one or more useful work clients.The useful work clients supply useful workloads to REM miners in the form of PoUW tasks, each of which encompass a PoUW enclave and some input. We refer readers to §5.2 and §5.3 for details.The blockchain agent collects transactions and generates a block template, a block lacking the proof of useful work (PoUW). The PoUW enclave meters work performed by the miner and declares whether the mining effort is successful and results in a block. Intuitively, REM may be viewed as simulating the distribution of block-mining intervals associated with PoW, but REM does so with PoUW, and thus eliminates wasted CPU effort.When a PoUW enclave determines that a block has been successfully mined, it produces a PoUW, which consists of two parts: an SGX-generated attestation demonstrating the PoUW enclave's compliance with REM and another attestation that a block was successfully mined by the PoUW enclave at a given difficulty parameter. The blockchain agent concatenates the PoUW to the block template, forming a full block, and publishes it to the network.When a blockchain participant verifies a fresh block received on the blockchain network, in addition to verifying higher-layer properties (e.g., in a cryptocurrency such as Bitcoin, that transactions, previous block references, etc., are valid), the participant verifies the attestations in the associated PoUW.Intel's PoET scheme looks similar to REM in that its enclave randomly determines block intervals and attests to block production. While she could not spend other people's money, which would require access to their private keys, she could perform denial-of-service attacks, selectively drop transactions, or charge excessive transaction fees.In principle, a broken attestation key can be revoked through the Intel Attestation Service (IAS), but this can only happen if the break is detected to begin with. As we show, defining and analyzing policies rigorously is challenging, but we provide strong analytical and empirical evidence that a relatively simple statistical-testing policy (which we denote P stat ) can achieve good results. Let C be the space of all possible blockchains C. Let C m denote blockchain C restricted to blocks mined by miner m ∈ M.In REM, a blockchain-acceptance policy is used to determine whether a block appears to come from a legitimate miner (CPU that hasn't been compromised). (Blockchain-Acceptance Policy) A blockchain-acceptance policy (or simply policy) P : C × B → {reject, accept} is a function that takes as input a blockchain and a proposed block, and outputs whether the proposed block is legitimate. Normalizing the revenue from mining a block to 1, we define the payoff for a miner m for a given blockchain C as π m (C) = |C m |. A policy that rejects too many policies incurs high waste, meaning that it rejects many blocks from honest miners. Our exploration of policies focuses critically on the trade-offs between low Adv S A (τ) and low Waste S (τ). As τ → ∞, it achieves the optimal Adv S A (τ) = 1, but at the cost of Waste S (τ) = 1, i.e., 100% waste.P α,rate best stat (C, B): parse B → (τ, m, d) if |C m | > F −1 (1 − α, dτ(rate best )):output reject else output accept REM makes use of a statistical-testing-based policy that we denote by P stat . Given an estimate of rate best , P stat tests submitted blocks statistically to determine whether a miner is mining blocks too quickly and may thus be compromised. The false rejection rate for a single test is therefore at most α. Indeed, as we show, we can represent waste in P stat using a discrete-time Markov chain that is periodically identical to the process it models, meaning that its expected waste is identical at any time nτ, for n ∈ Z + and τ a model parameter specified below. This Markov chain has a stationary distribution that yields an expression upper-bounding waste in P stat . We represent the state of an honest miner at timestep n by a random variableX n = ∑ n i=1 (Y i − E[Y i ]) = (∑ n i=1 Y i ) − n.Thus X n ∈ Z is simply difference between the miner's actually mined blocks and the expected number.Our Markov chain consists of a set of states C = Z representing possible values of X n (we use the notation C here, as states represent |C m | for an honest miner m). (1)The transition probabilities in our Markov chain are:P[i → j | i ∈ C \C rej [α]] = P( j − i + 1) if j ≥ i − 1 0 otherwise (2) P[i → j | i ∈ C rej [α]] = P( j + 1) if j ≤ −1 0 otherwise. Finally, an upper bound on the false rejection rate can be derived from the stationary probabilities of the Markov chain. (4)We compare our analytic bounds with simulation results in below.Adversarial Advantage We denote by Σ stat the strategy of an adversary that publishes blocks as soon as they will be accepted by P stat . The attacker's advantage is, of course, the ratio of the two values. We explain how we implemented secure instruction counting ( §5.2), and our hierarchical attestation framework ( §5.3) that allows for arbitrary tasks to be used for work. We explain how to reduce the overhead of attestation due to SGX-specific requirements ( §5.4). In a given iteration, it first takes a block template from the agent and calculates the previous block's hash and difficulty. Note that the enclave code has no network stack, therefore it receives its inputs from the miner untrusted code and returns its outputs to the miner untrusted code. Instead, we batch instructions by dividing useful work into subtasks of short duration compared to the inter-block interval (e.g. 10 second tasks for 10 minute average block intervals). The operating system may set their values arbitrarily, allowing a rational operator, who controls her own OS, to improve her chances of finding a block by faking a high cycle count. We employ a customized toolchain that can instrument any SGX-compliant code with dynamic runtime checks implementing secure instruction counting. First, it completes in a single cycle, and second, it doesn't change flags and therefore does not affect con- 4 PoUW := ⊥ /* simulating n Bernoulli tests */ 5 l ← U[0, 1] /* query SGX RNG */ 6 if l ≥ 1 − (1 − diff) n then 7 PoUW = Σ intel [ hash | diff | 1 ] 8return outcome, PoUW ditional jumps. First, code pages must be nonwritable; second, the useful work program must be single threaded.Enforcing Non-Writable Code Pages Writable code pages allow a program to rewrite itself at runtime. A general memory protection policy would be to require code pages to have W⊕X permission, namely to be either writable or executable, but not both. This is straightforward to verify, as with the current implementation of the SGX loader, code page permissions are taken directly from the ELF program headers [4]. Enforcing Single Threading Another limitation of SGX is that the memory layout is largely predefined and known to the untrusted application. The address of SSA frames for an enclave is determined at the time of initialization, as the Thread Control Structure (TCS) is loaded by the untrusted application through an EADD instruction. This ensures that the program can only execute the instruction stream parsed by the compliance checker, and not jump to the middle of an instruction to create its own alternate execution that falsifies the instruction count. The alternative of having an entity that verifies program compliance is also unacceptable, as it puts absolute blockchain control in the hands of this entity: it can authorize programs that deterministically win every execution.To resolve this predicament, we form PoUW attestations with what we call two-layer hierarchical attestations. Then it validates the work program's compliance by disassembling it and confirming that the dedicated register is reserved for instruction counting and that counts are correct and appear where they should. As a general approach, one hard-codes the fingerprint of a root compliance checker that verifies its children's compliance. Currently there is no way to verify attestations locally. Moreover, a simple modification to the IAS protocol, which is being tested by Intel [3], could get rid of the reliance on IAS completely on verifiers' side.Recall that the IAS is a public web service that receives SGX attestations and responds with verification results. Requests are submitted to the IAS over HTTPS; a response is a signed "report" indicating the validation status of the queried platform [44]. We evaluate each benchmark in three modes:Native We compile with the standard toolchain.SGX We port to SGX by removing system calls and replacing system libraries with SGX-compliant ones.Then we compile in SGX-prerelease mode and run with the SGX driver v1.7 [43]. Because the code is instrumented at control flow transfers, workloads with more jumps will incur more counting overhead. Based on the revenue from useful work and mining, and the capital and operational costs, we compute the equilibrium point of the system. We calculate the waste in this context as the ratio of the total resource cost (in U.S. dollars) spent per unit of useful work on a mining node compared with the cost when mining is not possible and all operators do useful work. Modern decentralized cryptocurrencies have stimulated strong interest in Proof-of-Work (PoW) systems [12,29,46] as well as techniques to reduce their associated waste. 3 An approach similar to PoET [41], possibly originating with Dryja [27], is to limit power waste by so-called Proof-of-Idle. FoldingCoin [65] rewards participants for work on a protein folding problem, but as a layer atop, not integrated with, Bitcoin.Proof-of-Stake [71,14,48,16] is a distinct approach in which miners gain the right to generate blocks by committing cryptocurrency funds. Due to the complexity of the x86-64 architecture, several works [24,70,73] have exposed security problems in SGX, such as side-channel attacks [73]. In contrast, in REM, the useful-workload code is instrumented in an untrusted environment, and an attestation of its validity is produced within a trusted environment.Haven [13] runs non-SGX applications by incorporating a library OS into the enclave. In principle, Haven could allow for non-SGX code to be adapted for PoUW.Zhang et al.[75] and Juels et al. [47] are the first works we are aware of to pair SGX with cryptocurrencies. They allow REM to accommodate essentially any desired workloads, permitting flexible adaptation in a variety of settings.Our framework for economic analysis offers a general means for assessing the true utility of mining schemes, including PoW and partially-decentralized alternatives. In summary, our results show that REM is practically deployable and promising path to fair and environmentally friendly blockchains in partially-decentralized blockchains.A Tolerating Compromised SGX Nodes: Details We start by discussing how to statistically infer the power of a CPU from its blocks in the blockchain. Without loss of generality, we write the difficulty as a function of time, d(t). If the cryptocurrency launches with a large number of miners, an even simpler approach is possible before switching to rate best estimation: We can cap the total number of blocks that any one node can mine, a policy we illustrate below. Timestamps can technically be forged at block generation, but in practice miners reject blocks with large skews [18], limiting the impact of timestamp forgery.Informally, prog chain maintains and broadcasts and authoritative blockchain C. An adversarial strategy is a probabilistic algorithm Σ A that takes in a set of identities, the current blockchain and the policy, and outputs a time-stamp and identity for block submission. As we don't know M A a priori, though, the only policies we consider operate on individual miner block-generation history.As a wrapper expressing implementation by A of Σ A , we model A as a program prog A , specified in Figure 12. For any non-degenerate security game S, therefore, the advantage Adv S(P simple ) A (τ) = 1 as τ → ∞. This policy is optimal in that an adversary cannot do better than an honest miner unconditionally. But though a CPU is still valuable in other contexts even if it is is blacklisted forever in this particular system, repurposing it incurs operational cost. The confidence interval is wide at this point, allowing the adversary to perform frequent generation without triggering detection.