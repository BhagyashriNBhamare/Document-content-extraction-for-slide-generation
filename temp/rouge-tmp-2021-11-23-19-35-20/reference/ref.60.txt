As a consequence, extensions have been abused in the past for malicious tasks such as private information gathering, browsing history retrieval, or passwords theft-leading to a number of severe targeted attacks. In this paper, we present two attacks that bypass these control techniques in every major browser family, enabling enumeration attacks against the list of installed extensions. In fact, due to their close relationship to the browser environment, they can be abused by an adversary in order to gather a wide range of private information -such as cookies, browsing history, system-level data, or even user passwords [7]. As a consequence, malicious actors started to use that freelyaccessible data to enumerate the extensions a user has installed in her system, or even to exploit vulnerabilities within installed extensions [23]. In addition, XHOUND [34] was also recently proposed to enumerate extensions and perform fingerprinting, by measuring the changes in the DOM of the website.In this paper we present the first in-depth security study of all the extensions resource control policies used by modern browsers. In particular, while the two design choices (i.e., access control settings or URI randomization) are both secure from a theoretical point of view, their practical implementation suffers from many different problems.We discuss two offensive techniques to subvert these control policies, one based on a timing side-channel attack and one based on an involuntary leakage of the random URI token that affects many extensions. We also discuss a set of attacks based on these techniques, which allow third-parties to perform precise user fingerprinting, or to perform various types of targeted attacks, performing proof-of-concept tests of some of them.We already reported the discovered problems to the involved browsers and extensions developers and we are currently discussing with them about possible fixes.In summary, this paper makes the following contributions:• We propose the first time-based extension enumeration attack that can retrieve the complete list of extensions installed in browsers that use access control settings. • We design a static analysis tool for Safari extensions, and use it to flag hundreds of potentially vulnerable cases in which the developers leaked the random extension URI. After an extensive survey of several traditional and mobile browser families, we identified two main classes of protection mechanisms currently in use: access control settings ( §2.1), and URI randomization ( §2.2). The most popular approach to protect extension resources from unauthorized accesses consists in letting the extensions themselves specify which resources they need to be kept private and which can be made publicly available. This extension uses a parameter (web accessible resources) to specify the paths of packaged resources that can be used in the context of a website. Resources are available through the URL chrome-extension://[extID]/ [path]. Each extension contains a chrome.manifest file that specifies options related to three main categories -content, locale, and skin -as exemplified in the following snippet:content ext src/content/ skin ext classic src/skin/ locale ext en-US src/locale/en-US/ content pck chrome/ext/pck contentaccessible=yesAs it was the case for Chromium extensions, originally there was no control performed to prevent external websites from accessing the different resources of an extension. However, resources have a restricted access by default, unless contentaccessible=yes is specified in the manifest.Firefox is now developing a new way of handling Addons called WebExtensions [29]. In order to access the different resources of the extension, Firefox will use the moz-extension:// schema.As WebExtensions are currently in an early stage we are not including them in our tests, but we notified their developers and we will discuss more about them in §5. *" "update_url": "https://foo/bar" } } ... Chrome extension developers will require minimal effort.Beside the general web APIs, a special extension API will provide a deeper integration with the browser, making possible to access features such as tab and window manipulation. In this solution there is no distinction between private or public resources, but instead the base URI of the extension is randomly re-generated in each session.Safari extensions are coded using a combination of HTML, CSS, and JavaScript. To develop an extension, a developer has to provide: (i) the global HTML page code, (ii) the content (HTML, CSS, JavaScript media), (iii) the menu items (label and images), (iv) the code of the injected scripts, (v) the stylesheets, and (vi) the required icons.These components are grouped into two categories: the first including the global page and the menu items, and the second including the content, and the injected scripts and stylesheets. The first solution relies on a public resource URI, whose access is protected by a centralized code in the browser according to settings specified by the extension developers in a manifest file. The second solution replaces the centralized check by randomizing the base URI at every execution. Despite the fact that, from a design point of view, this solution may seem secure, we discovered that all their implementations suffer from a serious problem that derives from the fact that these browsers are required to perform two different checks: (i) to verify if a certain extension is installed and (ii) to access their control settings to identify if the requested resource is publicly available (see Figure 4 for a simple logic workflow for the enforcement process). For instance, in Chromium the requested URI could look like this:chrome-extension://[fakeExtID]/[fakePath]Then, the attacker can generate a second request to measure the response time when requesting an extension that actually exists, but using a non-existent resource path (case B in Figure 4):chrome-extension://[realExtID]/[fakePath]By comparing the two timestamps, the attacker can easily determine whether an extension is installed or not in the browser. In this way, we performed: 2 calls × 10 iteration configurations × 500 times × 5 CPU usages, resulting in a total number of 275,000 calls.We observed that, when the execution paths were different, the response times differed by more than 5%. We tested our timing side-channel attack on the two browser families (Chromium-based and Firefox-based) that use extensions access control settings. However, as they follow the same extension control mechanism as Chromium, they are also likely to be vulnerable to our timing side-channel attack.Surprisingly, non-WebExtensions in Firefox suffer from a different bug that makes even easier to detect the installed extensions. While the exception does not cause any visible effect in the page, an attacker can simply encapsulate the invocation in a try-catch block to distinguish between the two execution paths and reliably test for the presence of a given extension. Therefore, we selected the 10,620 most popular Firefox extensions to keep our complete dataset equally balanced between the two browsers.To measure the coverage of previous bypassing methods and compare it with the full coverage of our bypass technique, we combined the methods described in [6,20]. Even if URI randomization control is completely centralized, it strongly depends on developers to keep resources away from any third-party access. This newly generated content can unintentionally leak the random extension URI, thus bypassing the security control measures and opening access to all the extension resources to any other code running in the same page. The Web-of-Trust example discussed above consists of a single function of 30 lines of code, but not all the cases are so obvious to identify without a complex static analysis of the extension.To estimate how prevalent the problem is, we implemented a prototype analyzer that reports candidate cases of URI leakage in all Safari extensions. Source and sinks are located by just looking for the specific code in the nodes of the tree, while the information flow is computed by following the different pieces of code that actually have access to the data along the different execution paths. If there is a connection between the baseURI access and the injection of an element in the website, the extension is flagged as suspicious and reported for further analysis.The schema in Figure 7 shows a simplified example of an extension that leaks the baseURI using function A of file A to obtain the value, function B of file B as an intermediate phase, and function D of file D to finally make the injection on the website.This technique is designed to act as a screening filter and NOT as a precise detection method. The 718 extensions belonged to 15 different categories (e.g., security, shopping, news, social networking, and search tools). Since the security category is among the ones with the highest percentage of extensions with a potential leak and it is also particularly sensitive due to the type of information these extensions usually deal with (such as user passwords), we decided to manually verify all the results for the extensions in this category.With a considerable effort, we performed an exhaustive manual code review of all the security extensions, selecting those that were completely functional, excluding the ones that required payment for their services. The list also includes password managers, such as LastPass 9 , Dashline 10 , Keeper 11 , and TeedyID 12 and combinations of the two functionalities (e.g., Blur from Abine 13 ). In the previous section we discussed the security of access control settings and URI randomization, and we showed how every mechanism adopted by current browsers can be easily bypassed in practice. The techniques proposed in this paper can also be used to perform a completely accurate browser finger-printing without checking the User-Agent. Therefore, if we configure our techniques to check one of these built-in extensions that does not exist in other browsers, a website can precisely identify the browser family with 100% accuracy.The installed extensions enumeration combined with the aforementioned browser identification can be used to determine users' demographics. By using our enumeration technique, an attacker can create completely functional malicious extensions by knowing all installed victim's extensions in beforehand.Due to the variability of possible extensions, the information of a particular user can be exploited in different social-driven attacks (automated or not). Hence, even a careful user who decides to analyze the website source cannot easily understand if a certain window or frame is created by an installed extension or by the site reusing the extension resources.While the URI randomization control bypass does not provide a complete enumeration capability, when an extension leaks its random token it opens all its internal resources to the attacker. This is potentially very harmful as it increases the attack surface, allowing the attacker to access and exploit any vulnerability in one of the internal extension components. In the case of the analytics capability of extensions, we have computed the popularity of the different categories established in the Chrome Web Store for each of the extensions that we previously analyzed in §3.1. In order to understand and measure the capability of extensions for device fingerprinting, we implemented a page that checks the users' installed extensions among the top 1,000 most popular from the Chrome Web Store and the Add-ons Firefox websites, using the timing sidechannel extension enumeration attack described in §3.1. In fact, this analysis is simply designed to determine the viability of our technique for device fingerprinting, either as a method by itself or by complementing other existing fingerprinting techniques.Following the standard adopted in previous works [12,24], we analyzed the extension anonymity sets of the fingerprinted users, which is defined as the number of users with the same fingerprint i.e., same extension set (the distribution of anonymity sets is shown in Figure 8). As already mentioned, the coverage of our enumeration attack is complete in the case of the timing sidechannel attack to access-control-based browser families (i.e., Chromium and Firefox Families) while approximately around 40% in URL randomization browsers (Safari). The first class of attacks is the consequence of a poor implementation of the browser access control settings: Firefox-family browsers usage of extensions can be exploited to recognize the reason behind a failed resolution, and Chromium family timing-side channel allows an attacker to precisely tell apart the two individual checks performed by the browser engine.The consequence, in both cases, is a perfect technique to enumerate all the extensions installed by the user. At the time of writing, as it is a design-related problem, it is still not fixed.In addition, as the new Firefox WebExtensions and Microsoft Edge (both currently in their early stages) use the same extension control mechanisms proposed by Chromium, we also notified their developers to make them aware of the issue described in this paper. Reaching out and training all the extension developers is a difficult task but Apple should provide more information on the proper way to handle the baseURI and about the security implications of this process.In addition, we believe that Safari could benefit from adopting a lightweight static analysis solution (similar to the one we discuss in §3) to analyze the extensions in their market and flag those that leak the random token. Browsers should also implement an access control (such as web accessible resource) to avoid any undesirable access to all extensions resources even when the random value is unintentionally leaked.3. VEX [3] is instead a static analyzer for Firefox JavaScript extensions that applies information flow analysis to identify browser extension vulnerabilities.Dynamic extensions analysis includes the work of Djeric et al. [11], in which the authors proposed the use of dynamic analysis to track data inside the browser and detect malicious extensions. Our analysis has lead to the most complete set of attacks against resource accessibility control and baseURI randomization, allowing in both cases extension enumeration attacks that can be used as part of larger threats.Similar to our own work, XHOUND [34] recently showed that the changes extensions perform on the DOM are enough to enumerate extensions. In addition, Kotcher et al. [22] discovered that besides from the attacks previous discussed, the usage of CSS filters made possible the revelation of sensitive information such as text tokens exploiting time differences to render various DOM trees.Two recent studies show that these attacks are far from being solved. Firefox WebExtensions and Microsoft Edge (early states) follow the same API and design, indicating that they may be prone to be vulnerable to the attack.We also discuss a URI leakage technique that subverts the URI randomization mechanism implemented in Safari, that emerges from inappropriate extension implementations that leak the value of a random token. SchemeIs ( k E x t e n s i o n S c h e m e ) ) ; 3 const Extension * extension = R e n d e r e r E x t e n s i o n R e g i s t r y :: Get () -> G e t E x t e n s i o n O r A p p B y U R L ( resource_url ) ; 1 bool R e s o u r c e R e q u e s t P o l i c y :: C a n R e q u e s t R e s o u r c e ( const GURL & resource_url , blink :: WebFrame * frame , ui :: PageTran sition tr an si t io n_ ty p e ) { 2 CHECK ( resource_url .