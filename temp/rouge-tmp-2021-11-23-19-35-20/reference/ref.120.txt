Our approach searches for the inputs required to place the source of a heap-based buffer overflow or underflow next to heap-allocated objects that an exploit developer, or automatic exploit generation system, wishes to read or corrupt. We present a framework for benchmarking heap layout manipulation algorithms, and use it to evaluate our approach on several real-world allocators, showing that pseudo-random black box search can be highly effective. For heap-based corruption, it is the physical layout of dynamically allocated buffers in memory that determines what gets corrupt:ed. In [26], exploits for heap-based vulnerabilities are considered, but the foundational problem of producing inputs that guarantee a particular heap layout is not addressed.To leverage OOB memory access as part of an exploit, an attacker will usually want to position some dynamically allocated buffer D, the OOB access destination, relative to some other dynamically allocated buffer S, the OOB access source. In fact, the ANSI C specification [2] The order and contiguity of storage allocated by successive calls to the calloc, malloc, and realloc functions is unspecified.Furthermore, applications that use dynamic memory allocation do not expose an API allowing an attacker to directly interact with the allocator in an arbitrary manner. The User structure contains a function pointer as its first field and an attacker in control of this field can redirect the control flow of the target to a destination of their choice by then calling the display function.As the attacker cannot directly interact with the allocator, the desired heap layout must be achieved indirectly utilising those functions in the target's API which perform allocations and deallocations. The allocator uses the hole of size 18 to satisfy the allocation request for the 12-byte User structure, leaving 6 free bytes. The request for the 8-byte name buffer is satisfied using the 24-byte hole, leaving a hole of 16 bytes. The 16-byte hole is used for the User object, leaving 4 bytes into which the name buffer is then placed. An analysis of the heap layout manipulation (HLM) problem as a standalone task within the context of automatic exploit generation, outlining its essential aspects and describing the factors which influence its complexity. The implementation, SHRIKE, automatically solves heap layout constraints that arise when constructing exploits for the PHP interpreter. SHRIKE takes this partial exploit as input and completes it by solving these problems.The source code for SHRIKE and SIEVE can be found at https://sean.heelan.io/heaplayout. This process is documented in the literature of the hacking and computer Figure 2: The challenges in achieving a particular layout vary depending on whether the allocator behaves deterministically or non-deterministically and whether or not the starting state of the heap is known. security communities, with a variety of papers on the internals of individual allocators [1,4,20,22], as well as the manipulation and exploitation of those allocators when embedded in applications [3,19,27]. The majority of allocators are deterministic, but some, such as the Windows system allocator, jemalloc and the DIEHARD family of allocators [6,24], do utilise non-determinism to make exploitation more difficult. However, for some such targets it is possible to force the creation of a new heap in a predictable state.When unknown starting states and non-determinism must be dealt with, approaches such as allocating a large number of objects on the heap in the hope of corrupting one when the vulnerability is triggered are often used. The destroy function also provides an interaction sequence of length three, in this case consisting of three calls to free.For a given interaction sequence there can be interactions that are beneficial, and assist with manipulation of the heap into a layout that is desirable, and also interactions that are either not beneficial (but benign), or in fact are detrimental to the heap state in terms of the layout one is attempting to achieve. We deem those interactions that are not actively manipulating the heap into a desirable state to be noise.For example, the create function from Listing 1 provides the ability to allocate buffers between 2 and 8 bytes in size by varying the length of the name parameter. The open ended nature of allocator design and implementation means any approach that involves the production of a formal model of a particular allocator is going to be costly and likely limited to a single allocator, and perhaps even a specific version of that allocator. There are two strong motivations for initially avoiding complexity.Firstly, there is no existing prior work on automatic HLM and a straightforward algorithm provides a baseline that future, more sophisticated, implementations can be compared against if necessary.Secondly, despite the potential size of the problem measured by the number of possible combinations of available interactions, there is significant symmetry in the solution space for many problem instances. Due to these solution space symmetries, we propose that a pseudo-random black box search could be a solution for a sufficiently large number of problem instances as to be worthwhile.To test this hypothesis, and demonstrate its feasibility on real targets, we constructed two systems. It allows for flexible and scalable evaluation of new search algorithms, or testing existing algorithms on new allocators, new interaction sequences or new heap starting states. Allocations and deallocations are specified via directives of the following forms:(a) <malloc size ID> (b) <calloc nmemb size ID> (c) <free ID> (d) <realloc oldID size ID> (e) <fst size> (f) <snd size>Each of the first four directives are translated into an invocation of their corresponding memory management function, with the ID parameters providing an identifier which can be used to refer to the returned pointers from malloc, calloc and realloc, when they are passed to free or realloc. 1: function SEARCH(g, d, m, r)2:for i ← 0, g − 1 do 3:cand ← ConstructCandidate(m, r) dist ← Execute(cand)5:if dist = d then 6: return cand 7:return None8: function CONSTRUCTCANDIDATE(m, r) 9:cand ← InitCandidate(GetStartingState())10:len ← Random(1, m) 11:fstIdx ← Random(0, len − 1)12:for i ← 0, len − 1 do 13: if i = fstIdx then 14:AppendFstSequence(cand) else if Random(1, 100) ≤ r then AppendAllocSequence(cand)17:else 18:AppendFreeSequence(cand) AppendSndSequence(cand) return cand addrSnd, respectively. This functionality allows one to focus on creating search algorithms for HLM.We implemented a pseudo-random search algorithm for HLM on top of SIEVE, and it is shown as Algorithm 1. • The available interaction sequences impact the difficulty of HLM, i.e. if an attacker can trigger individual allocations of arbitrary sizes they will have more precise control of the heap layout than if they can only make allocations of a single size. The experimental setup used to evaluate pseudorandom search as a means for solving HLM problems on synthetic benchmarks is described in section 4.1. To evaluate the feasibility of end-to-end automation of HLM we constructed SHRIKE, a HLM system for the PHP interpreter. PHP combines a large, modern application containing complex functionality, with a language that is relatively stable and easy to work with in an automated fashion. If successful, the output of the search is a new PHP program that manipulates the heap to ensure that when the specified vulnerability is triggered the source and destination buffers are adjacent.To support the functionality required by SHRIKE we implemented an extension for PHP. This extension provides functions that can be invoked from a PHP script to enable a variety of features including recording the allocations that result from invoking a fragment of PHP code, monitoring allocations for the presence of interesting data, and checking the distance between two allocations. For example, fuzzers will often replace integers with values that may lead to edge cases, such as 0, 2 32 − 1, 2 31 − 1 and so on. • Our measure of fitness for a generated test is not based on code coverage, as is often the case with vulnerability detection, but is instead based on whether a new allocator interaction sequence is produced, and the length of that interaction sequence. The output of this stage is a mapping from fragments of PHP code to a summary of the allocator interaction sequences that occur as a result of executing that code. To avoid hard-coding vulnerability-specific information in the candidate creation process, we allow for the creation of candidate templates that define the structure of a candidate. A template is a normal PHP program with the addition of directives starting with #X-SHRIKE 4 . In section 4.3 we explain how this template was used in the construction of a control-flow hijacking exploit for PHP.Algorithm 2 Solve the HLM problem described in the provided template t. The integer g is the number of candidates to try, d the required distance, m the maximum number of fragments that can be inserted in place of each HEAP-MANIP directive, and r the ratio of allocations to deallocation fragments used in place of each HEAP-MANIP directive.1: function SEARCH(t, g, m, r) spec ← ParseTemplate(t)3:for i ← 0, g − 1 do 4:cand ← Instantiate(spec, m, r) if Execute(cand) then cand ← NewPHPProgram() while n ← Iterate(spec) do if IsHeapManip(n) then code ← GetHeapManipCode(n, m, r) else if IsRecordAlloc(c) then code ← GetRecordAllocCode(n) else if IsRequireDistance(n) then code ← GetRequireDistanceCode(n) 17:else 18:code ← GetVerbatim(n) AppendCode(cand, code) return cand The search in SHRIKE is outlined in Algorithm 2. The database, constructed as described in section 3.2.1, is queried for a series of PHP fragments, where each fragment allocates or frees one of the sizes specified in the sizes argument to the directive in the template. The research questions we address are as follows:• RQ1: What factors most significantly impact the difficulty of the heap layout manipulation problem in a deterministic setting? Firstly, to investigate the fundamentals of the problem we utilised the system discussed in section 3.1 to construct a set of synthetic benchmarks involving differing combinations of heap starting states, interaction sequences, source and destination sizes, and allocators. We chose the tcmalloc (v2.6.1), dlmalloc (v2.8.6) and avrlibc (v2.0) allocators for experimentation. In short, for small allocation sizes (e.g. less than a 4KB) segregated storage pre-segments runs of pages into chunks of the same size and will then only place allocations of that size within those pages. To avoid these drawbacks we captured Figure 4: For an allocator that splits chunks from the start of free blocks, the natural order, shown on the left, of allocating the source and then the destination produces the desired layout, while the reversed order, shown on the right, results in an incorrect layout.the initialisation sequences of PHP 5 , Python and Ruby to use in our benchmarks. The sizes we selected are 8, 64, 512, 4096, 16384 and 65536. A larger value would provide more opportunities for the search algorithm to find solutions, but with 2592 total benchmarks to run, and 500,000 executions taking in the range of 5-15 minutes depending on the number of interactions in the starting state, this was the maximum viable value given our computational resources. The results of the benchmarks averaged across all starting states can be found in Table 1, with the full results in the appendices in Table 4. From the benchmarks a number of points emerge:• When segregated storage is not in use, as with dlmalloc and avrlibc, and when there is no noise, 98% to 100% of the benchmarks are solved. • With the addition of a single noisy allocation, the overall success rate drops to close to 50% across all allocators. • We ran each experiment 9 times, and if all 9 * 500, 000 executions are taken together then 78% of the benchmarks are solved at least once. This saves an exploit developer a significant amount of effort, allowing them to focus on how to leverage the resulting OOB memory access.Our evaluation utilised the following vulnerabilities:• CVE-2015-8865. An out-of-bounds write vulnerability in PHP up to version 7.0.10, related to image processing.The ten target structures are described in the appendix in Table 3 and the full details of all 30 experiments can be found in Table 5. The following summarises the results:• SHRIKE succeeds in producing a PHP program achieving the required layout in 21 of the 30 experiments run and fails in 9 (a 70% success rate). Exploit for PHP To show that SHRIKE can be integrated into the development of a full exploit we selected another vulnerability in PHP. CVE-2013-2110 allows an attacker to write a NULL byte immediately after the end of a heap-allocated buffer. By corrupting this pointer via the NULL byte write, and then allocating a buffer we control at the location it points to post-corruption, an attacker can control the locations that are read and written from when pixels are read and written.Listing 4 shows the template provided to SHRIKE. The end result is a PHP script that hijacks the control flow of the interpreter and executes native code controlled by the attacker. In the evaluation on PHP noise again played a significant role, with SHRIKE solving 100% of noise-free instances and 40% of noisy instances. RQ2: Is pseudo-random search an effective approach to heap-layout manipulation?Without segregated storage, when there is no noise then 100-99% of problems were solved, with most experiments taking 15 seconds or less. However, as noted in section 4.1, if all 10 runs of each experiment are considered together then 78% of the benchmarks are solved at least once.On the synthetic benchmarks it is clear that the effectiveness of pseudo-random search varies depending on whether segregated storage is in use, the amount of noise, the allocation order to corruption direction relationship and the available computational resources. SHRIKE demonstrates that it is possible to automate the process in an end-to-end manner, with automatic discovery of a mapping from the target program's API to interaction sequences, discovery of interesting corruption targets, and search for the required layout. However, we believe that the presented search algorithm and architecture for SHRIKE are likely to work similarly well with other language interpreters. The approach used in SHRIKE to solve the first problem is based on previous work on vulnerability detection that has been shown to work on interpreters for Javascript and Ruby, as well as PHP [17,18]. More recently, as part of the DARPA Cyber Grand Challenge [10] (CGC), a number automated systems [13,14,29,30] were developed which combine symbolic execution and high performance fuzzing to identify, exploit and patch software vulnerabilities in an autonomous fashion. In this paper we have demonstrated an approach to producing inputs that satisfy heap layout constraints, and thus could be used to process vulnerability triggers into inputs that meet the requirements of their system.Vanegue [33] defines a calculus for a simple heap allocator and also provides a formal definition [32] of the related problem of automatically producing inputs which maximise the likelihood of reaching a particular program state given a non-deterministic heap allocator. Further research is necessary to expand on the concept, but we believe such human-machine hybrid approaches are likely to be an effective means of producing exploits for real systems.Listing 5: Part of the solution discovered for using CVE- 2013CVE- -2110 to corrupt the gdImage structure, which is the 1 st allocation made by imagecreate on line 11. Start Table 5: Results of heap layout manipulation for vulnerabilities in PHP. 'Time to best' is the number of seconds required to find the best result. Dist.Time to Best This research was supported by ERC project 280053 (CPROVER) and the H2020 FET OPEN 712689 SC 2 .