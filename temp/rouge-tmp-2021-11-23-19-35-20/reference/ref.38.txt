We demonstrate a practical exploitation technique, called Dark-ROP, which can completely disarm the security guarantees of SGX. Dark-ROP exploits a memory corruption vulnerability in the enclave software through return-oriented programming (ROP). This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave's SGX crypto keys. This result strongly suggests that SGX research should focus more on traditional security mitigations rather than on making enclave development more convenient by expanding the trusted computing base and the attack surface (e.g., Graphene, Haven). We demonstrate a practical exploitation technique, called Dark-ROP, which can completely disarm the security guarantees of SGX. Dark-ROP exploits a memory corruption vulnerability in the enclave software through return-oriented programming (ROP). This shadow application emulates the enclave under the complete control of the attacker, using the enclave (through ROP calls) only to perform SGX operations such as reading the enclave's SGX crypto keys.The consequences of Dark-ROP are alarming; the attacker can completely breach the enclave's memory protections and trick the SGX hardware into disclosing the enclave's encryption keys and producing measurement reports that defeat remote attestation. However, the adoption of these systems has been limited, as they were either closed or required trusted hypervisors or operating systems that have not materialized in the mass market.Intel Software Guard Extensions (SGX) [16] is a new processor feature that isolates security-critical applications from system software such as hypervisors, operating systems, or the BIOS. Several authors [26,33,38] have identified side channels that can leak large amounts of sensitive information out of the application's isolated execution environment (enclave). However, a fundamental question about the security of SGX remains unanswered: What is the effect of having a memory-corruption vulnerability in an enclave and how dangerous is it?This question is important, as such vulnerabilities have been found in a wide range of applications, including security applications [4,12,13]. Since SGX prevents all access to enclave code and data from outside the enclave, we cannot directly apply typical ROP attacks.To overcome these challenges, we construct a novel method for finding a vulnerability and useful ROP gadgets in fully encrypted binaries (unknown code) running under SGX. Dark-ROP can chain the gadgets found in this way and utilize them to invoke security-critical functions such as data sealing and generating measurement reports for remote attestation.In addition, we construct a shadow application (i.e., SGX Malware) that runs outside an enclave but fully emulates the environment of an SGX enclave. At the same time, the remote party cannot detect the attack through the remote attestation because the shadow application can use the real enclave to generate the correct measurement report.We summarize the contributions of the Dark-ROP attack as follows:1. This includes 1) exfiltrating secret code and data from enclave memory, 2) bypassing local and remote attestation, and 3) decrypting and generating the correctly sealed data. We devise a new way to launch a code-reuse attack by 1) blindly finding a vulnerability and useful gadgets from an encrypted program in the enclave and 2) constructing a shadow enclave that poses as a man-in-the-middle to masquerade the entire application of the enclave. There is a temptation to focus on convenience (e.g., running unmodified programs on SGX via library OSes [3,6,36]) rather than security (e.g., verification of enclave programs [34,35]). SGX protects programs running in enclaves from attacks that undermine the integrity and the confidentiality of code and data of the program. For example, SGX prevents enclaves from being tampered with by privileged software (e.g., kernel), and from many physical attacks such as the cold-boot attacks. Specifically, page miss handler (PMH) [23] checks an access permission of the EPC pages when any software requests read or write access to the enclave memory.In addition, a memory encryption engine (MEE) [11,15] that is a extension of the memory controller encrypts enclave code and data before they are being written to main memory. The purpose of attestation in SGX is twofold: ensuring that an enclave is running an expected program on a certified SGX platform with a correct configuration and securely sharing a secret to build a secure communication channel between an enclave and a remote entity (e.g., the owner of the enclave). The one step that is relevant to Dark-ROP is that an enclave needs to obtain a cryptographic message authentication code (MAC) from the processor as part of the attestation. Enclave code can use these keys to implement data sealing: It can cryptographically protect (e.g., encrypt, MAC) data before asking untrusted code to store them persistently. Optionally, the loader code can be erased from enclave memory to deprive attackers of known gadget building material.This process requires memory that is at some time writable and at another time executable. That would allow the deployment of encrypted binaries without requiring pages to be both executable and writable.In summary, SGX makes it possible to deploy encrypted binaries, which means that attackers may never be able to see the code running inside the enclave they are Figure 1: ENCLU instruction and its leaf functions. Figure 1 shows how a user-level process can invoke each leaf function through an ENCLU gate. For example, EEXIT, one of the leaf functions of ENCLU, requires two parameters: 1) a target address outside the enclave and 2) the address of the current Asynchronous Exit Pointer (AEP). After setting the required parameters, the developer can now set rax to the index of the leaf function (in this case, 0x4). The untrusted program can call an exported function import_data_to_enclave() in the enclave through the EENTER leaf function. To call the function in the enclave, the untrusted program can set the rbx register as the address of the Thread Control Structure (TCS), which is a data structure that contains the entry point of the enclave (e.g., the import_data_to_enclave() function in this case) and its argument (i.e., the attack buffer as out_of_enclave_memory) as a pointer of the untrusted memory. To launch the ROP attack on the vulnerability, the attacker can fill the attack buffer to more than the size of the buffer in the enclave, which is 0x100, to overwrite the return address and then build the stack with ROP gadgets and function arguments to control the program execution at the attacker's will.However, the ROP attack against enclaves will not simply work in the typical way because the information for the execution environment as well as the program itself is encrypted, so it is hidden to attackers.Challenge: encrypted binary makes the ROP attack difficult. In other words, the attacker has to find gadgets for their execution and chain them together under the blindness condition.Although a recent work on Blind ROP [7] demonstrates an ROP attack against unknown code, the attack relies critically on properties of certain server applications that are based on the fork() system call, which does not hold for SGX enclaves. To find a buffer overflow vulnerability in an encrypted enclave program, the Dark-ROP attack exploits the exception handling mechanism of SGX as follows.For an enclave program, it has a fixed number of (exported) entry points (i.e., functions of enclave program) specified in the enclave configuration. If we detect any AEX caused by a page fault on fuzzing, this means that there was a memory corruption so that we set the function and the argument that currently fuzzed as a candidate for the buffer overflow vulnerability.Next, to detect vulnerability triggering conditions such as the size of the buffer and the location of the return address, we exploit the value of the CR2 register at the AEX handler, the register that stores the source address of a page fault. Without having the instruction, the enclave cannot enjoy the features provided by SGX.Second, the code should have the ROP gadgets that consist of one or multiple "pop a register" (i.e., pop rbx) instructions before the return instruction, especially for the rax, rbx, rcx, rdx, rdi, and rsi registers. The assumption still targets a typical condition because the isolated architecture of SGX memory requires frequent copying of memory between the trusted in-enclave area and the untrusted area.We believe the assumptions we made for the gadgets targets a typical condition of enclave programs because without such gadgets, the programs will be broken or run unconventionally.Based on the assumption of gadgets, we attempt to find the useful ROP gadgets without having any knowledge of the code in the binary, so we called this attack "Dark-" ROP. To this end, we construct three oracles that give the attackers a hint of the binary code to find the useful gadgets: 1) a page-fault-based oracle to find a gadget that can set the general purpose register values; 2) the EEXIT oracle can verify which registers are overwritten by the gadgets found by 1); and 3) the memory oracle that can find the gadget has a memory copy functionality to inject data from untrusted space to the enclave or to exfiltrate the data vice versa. Additionally, we also exclude the case that requires physical access to the machine because the Dark-ROP attack is a pure software-based attack. That is, the application that runs in the enclave is distributed in an encrypted format and removing the loader program after launching the payload, which makes it completely hidden to the attacker, and the application uses data sealing for protecting application data as well as remote attestation to verify the running status of the enclave. The attacker has full control of all software of the system, including the operating system and the untrusted application that interacts with the enclave, etc., except the software that runs inside the enclave. To find gadgets from the completely hidden binary in an enclave, we devised three techniques that can turn an enclave into an oracle for finding a gadget: 1) Reading the cr2 register at the page fault handler to find the gadget with multiple register pops to control the value of registers.2) Leaking the register values at the page fault handler by calling the EEXIT leaf function to identify which registers are changed by 1. The workflow for identifying pop gadgets by using the page fault oracle is as follows: (1) The attacker sets an arbitrary address in the code section on the stack to probe if the address is for a pop gadget (e.g. 0xF7501200 in the figure) and then set several non-executable addresses in PF_region. For instance, a pop gadget like pop rbx; pop rcx; pop rdx; retq; can change the value of the rbx, rcx, and rdx registers at once if values are set at the attack stack by exploiting a buffer overflow vulnerability.To find such gadgets, we turn the Asynchronous Enclave Exit (AEX) and page fault handler into an oracle for detecting the gadgets. At the same time, we put several non-executable addresses, all of which reside in the address space of the enclave, on the stack.Because the untrusted operating system manages all the memory allocations, the attacker knows the coarsegrained memory map of the enclave (on the left side of the Figure 3) so that the attacker can easily identify the non-executable enclave memory pages (e.g., enclave stack or heap pages). We call this memory region as PF_region and, PF_R array in the code contains the list of non-executable page addresses.For instance, we put 0xf7741000, 0xf7742000, 0xf7743000, and 0xf7744000, etc. on the enclave stack to set the register values if it is a pop gadget (see at the bottom of the Figure 3. Moreover, the gadget found by this method could not be a pop gadget because the page fault can be triggered in other cases such as pop rax; mov rbx,QWORD PTR [rax+0x4] (fault by mov instruction). This helps the attacker to identify the pop gadgets among the candidates and the registers that are popped by the gadgets.To build this oracle, we need to find the ENCLU instruction first because the EEXIT leaf function can only be invoked by the instruction by supplying the index at the rax register as 0x4. Finally, we put the 0x80000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x80000018 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00Application address space 0xF7500000: 7f 45 4c 46 02 01 01 00 0xF7500008: 00 00 00 00 00 00 00 00 0xF7500010: 03 00 3e 00 01 00 00 00 0xF7500018: d0 ad 00 00 00 00 00 00Enclave address space ④ ② ③ ④ Figure 5: An overview of finding memcpy() gadget. (2) The gadgets in the chain sets the arguments (rdi, rsi, rdx) as the destination address (0x80000000) in rdi, the source address (0x75000000) in rsi, and the size (0x8) in rdx to discover the memcpy() gadget. If the handler is invoked and the value of rax is 0x4, then the return address placed at the end of the attack stack points to the ENCLU instruction.After we find the method to invoke EEXIT, we exploit the EEXIT gadget to identify which registers are popped by the pop gadget. Thus, if we put a pop gadget, and put some distinguishable values as its items to be popped, for instance, 0x1, 0x2, and 0x3, and then run the EEXIT at the end, we can identify the popped registers by the values.For example, if the pop gadget is pop rdi; pop rsi; pop rdx; ret, then at the handler, we can see the value of 0x1 at rdi, value of 0x2 at rsi, value of 0x3 at rdx. After finding all gadgets, including the register pop gadget, ENCLU, and memcpy(), an attacker can control the enclave in two ways. In particular, for the proofof-concept demonstration, we execute EGETKEY, a leaf function for encryption key derivation, and extract the generated key from the enclave Note that EGETKEY must be executed in the enclave because the return value, which is an encryption key, is unique to the enclave and tied to the hardware.Leaking the encryption key for data sealing. Third, the rcx register should point to a writable address in the enclave because the processor will store the generated key into that address.To call EGETKEY through ROP gadgets correctly, we do use the following steps. In the SGX security model, the attacker already knows the region of the memory that is used by the enclave because all the memory allocation is handled by the untrusted operating system. Finally, we put the memcpy() gadget again by chaining the pop gadgets to set rdi to a writable untrusted memory address and rsi to the address of the generated key in the enclave, which is the value of rcx on the second step.The chain of gadgets will first call memcpy() to copy the KEYREQUEST data from the untrusted space to the in-enclave memory, execute EGETKEY with the prepared KEYREQUEST as a parameter, and then call memcpy() again to copy the generated key from the enclave to the untrusted space. This can be achieved by hijacking remote attestation by calling the EREPORT leaf function and constructing the correct measurement data outside the enclave.In the following, we illustrate how we construct the SGX malware with preserving such requirements so that the SGX malware can run at the attacker's discretion while bypassing attack detection using the remote attestation.Extracting the hidden binary/data from the enclave. Since the attestation requires generating the report in the enclave, primarily, we call the EREPORT leaf function by the Dark-ROP attack to generate the measurement report, and we emulate the entire process of the remote attestation in the binary outside the enclave to reply the correct measurement report to the remote server.Before describing the emulation step, we present the background on how remote attestation typically works, as in Intel SGX SDK.Remote attestation in Intel SGX SDK. Second, on receiving the "hello" message from isv_enclave, (2) the remote server generates its own ECDH key pair that the server will use.Third, (3) the server sends a quote request to the isv_app, to verify if the public key that the server received is from isv_enclave. On generating the REPORT, we prepare a REPORTDATA at the untrusted space using the chosen ECDH public key, and then chain the ROP gadgets to copy the REPORTDATA to the enclave space. After that, SGX malware launches the Dark-ROP attack (3-1, 3-2 and 3-3) to copy prepared parameters (TARGETINFO and REPORTDATA) from the untrusted app to the enclave and generate REPORT with the ECDH public key that the SGX malware generated at the first step. Additionally, we use the standard Intel SGX SDK and compiler (gcc-5) to compile the code for the enclave for both attacks.To launch the Dark-ROP attack on the real SGX hardware, we use the RemoteAttestation example binary in the Intel SGX SDK, which is a minimal program that only runs the remote attestation protocol, with slight modification, to inject an entry point that has a buffer overflow vulnerability, as mentioned in Figure 2. To set the registers for calling the memcpy function, we chained three gadgets, pop rsi; pop r15; ret and pop rdi; ret to set the destination and source address of memory copy, and pop rdx; pop rcx; pop rbx; ret to set the length of the data to be copied. For the transition between the host program and the enclave, at least one ENCLU instruction (for EEXIT leaf function) is required for the enclave, the requirement that makes it hard to completely remove the gadgets. More specifically, SGX allows multiple synchronous entrances (EENTER) depending on the value configured in the NSSA field, even after the AEX happens (if ERESUME is executed instead of EEN-TER, the enclave crashes and thus the attacker needs to reconstruct the enclave). As described in [18,24,30], an enclave binary can be distributed as a cipher text to preserve the confidentiality of the code and data deployed in the enclave. To this end, it depends on two primary gadgets, which are called the trap gadget and the stop gadget, both of which incur the program to be crashed or stopped when they are consumed (popped) as part of the input payload that is crafted by an attacker to specify the potential (and currently probed) gadget.On the contrary, the Dark-ROP attack takes an orthogonal approach, which exploits the three oracles that allow the attacker to obtain hints of the gadgets by the features of SGX (i.e., page fault, EEXIT, and the memory) to identify required gadgets from a completely hidden environment. We hope that our work can encourage the community to explore the SGX characteristic-aware defense mechanisms as well as an efficient way to reduce the TCB in the enclave.