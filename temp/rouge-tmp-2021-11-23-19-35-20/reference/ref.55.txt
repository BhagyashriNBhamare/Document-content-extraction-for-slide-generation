We evaluate the effectiveness of AWare in: (1) a laboratory-based user study, finding that at most 7% of the users were tricked by examples of four types of attacks when using AWare, instead of 85% on average for prior approaches; (2) a field study, showing that the user authorization effort increases by only 2.28 decisions on average per application; (3) a compatibility study with 1,000 of the most-downloaded Android applications , demonstrating that such applications can operate effectively under AWare. Also, web search engines now embed buttons to call the businesses linked to the results directly.Unfortunately, once an application is granted access to perform such sensitive operations (e.g., on installation or first use), the application may use the operation at will, opening opportunities for abuse. Indeed, cybercriminals have built malware applications available online for purchase, called Remote Access Trojans (RATs), that abuse authorized access to such sensors to exfiltrate audio, video, screen content, and more, from desktop and mobile platforms. Some cases leading to legal actions, including the case of the NBA Golden State Warriors' free application that covertly turns on smartphones' microphones to listen to and record conversations [17], school laptops that were found to use their cameras to spy on students to whom they were given [13], and others [14,15]. UserDriven [39,41] access control requires that applications use system-defined gadgets associated with particular operations to enable the system to infer operations for user input events unambiguously, but does not enable a user to verify the operation that she has requested by providing input. To achieve our objective, AWare binds each operation request to a user input event and obtains explicit authorization for the combination of operation request, user input event, and the user interface configuration used to elicit the event, which we call an operation binding. In addition, AWare is designed to be completely transparent to applications, so applications require no modification run under AWare control, encouraging adoption for contemporary operating systems.We implement a prototype of the AWare authorization framework by modifying a recent version of the An-4 null-byte.wonderhowto.com droid operating system and found, through a study of 1,000 of the most-downloaded Android applications, that such applications can operate effectively under AWare while incurring less than 4% performance overhead on microbenchmarks. We found that the study participants only had to make 2.28 additional decisions on average per application for the entire study period.In summary, the contributions of our research are:â€¢ We identify four types of attacks that malicious applications may still use to obtain access to privacysensitive sensors despite proposed research defenses. These studies report that more than 78% Figure 1: In mobile platforms, once the system authorizes an application to perform a operation, the application may perform that operation at any time, enabling adversaries to stealthily access privacy-sensitive sensors, e.g., record speech using the microphone, at any time.of users could be potentially subject to such attacks. Furthermore, security companies, such as Check Point, have reported several malware apps that performs stealthy and fraudulent auto-clicking [4], such as Judy, FalseGuide, and Skinner that reached between 4.5 million and 18.5 million devices worldwide. Second, User-Driven Access Control [39,41] (UDAC) further restricts applications to use trusted access control gadgets provided by the operating system, where each access control gadget is associated with a specific operation for such sensors. Previous research [6,12,30] and our user study (see Section 8.1.1) show that users frequently fail to identify the application requesting sensor access, the user input widget eliciting the request, and/or the actual operation being requested by an application. Such errors may be caused by several factors, such as users failing to detect phishing [12], failing to recognize subtle changes in the interface [20], and/or failing to understand the operations granted by a particular interface [38]. Figure 2: The user's perception of the operation that is going to be performed differs from the actual operation requested by the application, which abuses a previous granted permission.Operation Switching: A malicious application may try to trick a user into authorizing an unintended operation by changing the mapping between a widget and the associated operation, as shown in Figure 2. Bait-and-Widget-Switch: A malicious application may present the same widget for the same operation to the user several times in succession, but then substitute another widget for another operation, hoping that the user will not notice the widget change. Application Spoofing: A malicious application replicates the look-and-feel of another application's interface and replaces the foreground activity of that application with one of its own to gain access to a sensor as shown in Figure 5, similar to a phishing attack. Since IDAC and UDAC [33,39,41] both treat user input as authorization, both will be prone to this attack 6 . As a result, current mobile platforms only request user authorization once (e.g., on first use or installation), and proposed research solutions aim to infer whether users authorize access to particular sensors from user actions implicitly. Proposed approaches still demand users to keep track of which application is in control, the operations associated with widgets, which widget is being displayed, and whether the widget or application changes.Finally, application compatibility is a critical factor in adopting the proposed approaches. We assume that trusted paths are protected by mandatory access control [49,50] as well, which ensures that only trusted software can receive input events from trusted system input devices to guarantee the authenticity (i.e., prevent forgery) of user input events.Trusted path communication from the system to the user uses a trusted display area of the user interface, which we assume is available to display messages for users and applications do not have any control of the content displayed in this area; thus they cannot interfere with system communications to or overlay content over the trusted display area.These assumptions are in line with existing research that addresses the problem of designing and building trusted paths and trusted user interfaces for browsers [55], X window systems [47,56], and mobile operating systems [26,27]. Our objective is to develop an authorization mechanism that eliminates ambiguity between user input events and the operations granted to untrusted applications via those events, while satisfying the following security, usability, and compatibility properties:User Initiation Every operation on privacy-sensitive sensors must be initiated by an authentic user input event.User Authorization Each operation on privacysensitive sensors requested by each application must be authorized by the user explicitly prior to that operation being performed.Limited User Effort Ideally, only one explicit user authorization request should be necessary for any benign application to perform an operation targeting privacysensitive sensors while satisfying the properties above.Application Compatibility No application code should require modification to satisfy the properties above.We aim to control access to privacy-sensitive sensors that operate in discrete time intervals initiated by the user, such as the cameras, microphone, and screen buffers. Figure 6 summarizes the steps taken by the AWare to authorize applications' operation requests targeting privacy-sensitive sensors.In a typical workflow, an application starts by specifying a set of user interface configuration, such as widgets and window features, to the trusted software (step 1 ) in charge of rendering such widgets with windows to elicit user input (step 2 ). Upon the user's authorization, the operation binding is then cached (Section 6.5) for reuse in authorizing future requests using the same operation binding automatically (step 10 ). The sequence of events in Figure 6 shows that AWare relies on a one-time, explicit user authorization that binds the user input event, the application identity, the widget, the widget's user interface configuration, the operation, and the set of target sensors; then, it reuses this authorization for future operation requests.6 AWare Design As described above, AWare performs authorization using a concept called the operation binding.Definition 1: An operation binding is a tuple b = (app, S, op, e, w, c), where: (1) app is the application associated with both the user interface widget and the operation request; (2) S is the set of sensors (i.e., resources) targeted by the request; (3) op is the operation being requested on the sensors; (4) e is the user input event; (5) w is a user interface widget associated with the user input event; (6) c is the user interface configuration containing the widget.The user interface configuration describes the structure of the user interface when a user input event is produced, which includdes both features of the window in which the widget is displayed and application's activity window call graph, which relates the windows used by the application. AWare reuses that authorization to permit subsequent operation requests by the same application when user input events are obtained in the same manner.A user's authorization of an operation binding implies that the application will be allowed to perform the requested operation on the set of sensors whenever the user produces the same input event using the same widget within the same user interface configuration.We explain the reasoning behind the operation binding design by describing how AWare prevents the attacks described in Section 3.1 in the following subsections. AWare prevents operation switching attacks by producing an operation binding that associates a user input event and widget with an application's operation request.Upon a user input event e, AWare collects the widget w, the user interface configuration c in which it is presented, and the application associated with the user interface app. Applications control their user interfaces, so they may exploit this freedom to perform bait-and-switch attacks by either presenting the widget in a misleading window (Bait-And-Context-Switch) or by replacing the widget associated with a particular window (Bait-And-WidgetSwitch). To prevent such attacks, AWare binds the operation request with the user interface configuration used to display the widget, in addition to the widget and user input event.One aspect of the user interface configuration of the operation binding describes features of the window enclosing the widget.Definition 2: A display context is a set of structural features of the most enclosing activity window a w containing the widget w.Structural features describe how the window is presented, excepting the content (e.g., text and figures inside web pages), which includes the position, background, borders, title information, and widgets' position within the window. However, since the display context also measures the window's UI elements and their positions, little space is left to the adversary for attacks.Therefore, such an approach prevents bait-and-switch attacks possible in both IDAC [33] and UDAC [39,41], where users must continuously check for subtle changes to the widgets or their display contexts rendered on the platform's screen. To launch such an attack an application must succeed in replacing the foreground activity window of one application with its own activity window and adopt the same look-and-feel of the replaced application.We can prevent applications from presenting their activity windows arbitrarily by enforcing the application's authorized activity window call sequences.Definition 3: An activity window call graph G:= (N, E) is a graph, where each node in N represents an activity window and each edge in E represents an interactivity window transition enabled either via user input events (i.e., click of a button) or system events (i.e., incoming phone call). Both IDAC and UDAC allow such hijacking and rely on the user to detect these subtle attacks.A malicious application may try to circumvent the activity call graph checking by creating a more fully connected graph that allows more attack paths. Authorized operation bindings are cached to minimize the user's effort in making explicit authorizations of binding requests to improve usability. Thus, we require that an operation binding must be removed from the cache whenever a new operation binding is created for the same application that partially matches the existing binding, except for the application field. In fact, AWare does not require any new external libraries, application code annotation or rewriting, which would require significant development effort/burden and impede backward compatibility for existing applications.AWare can be integrated with existing off-the-shelf operating systems, as we show with our AWare prototype discussed in Section 7. The integration with existing off-the-shelf operating systems facilitates adoption and deployability.We discuss how AWare addresses special cases of applications accessing privacy-sensitive sensors via alternative methods, such as via background processes and remote commands, in Appendix A . We tested the AWare prototype on Nexus 5 and Nexus 5X smartphones.In the following paragraphs, we describe how we implemented the components required for AWare authorization mechanism 9 . AWare collects the developers' signatures and the apps identity marks (names and logos) from the Google Play store.Widget and Display Context Authentication: AWare identifies application-defined widgets and display contexts at runtime before rendering the app's user interface to the user on the platform's screen. In the Appendix, Tables 4 and Table 5 show comprehensive sets of widgets and windows' features used by AWare to authenticate the widgets and their display contexts.Activity Window Call Graph Construction: At runtime, AWare detects inter-activity transitions necessary to construct the per-application activity window call graph by instrumenting the Android Activity Manager and Window Manager components. Thus, AWare leverages the complete mediation guaranteed at the system services layer to identify operation requests generated by apps at runtime, using ten hooks inside the stock Android Audio System, Media Server, and Media Projection.Operation Binding Management: The AWare prototype implements the AWare MONITOR to handle callbacks from the AWare hooks inside the Input Manager and other system services. Each security message includes the app identifier (e.g., application name and identity mark) and a text message specifying the ongoing operation and the set of privacy-sensitive sensors being accessed. Also, the AWare prototype leverages the Android screen overlay mechanism to detect when applications or background services draw over the application currently in the foreground, to prevent GUI overlay.Further, security messages are made visible to the user even if the application runs in full-screen mode. We performed a laboratory-based user study and found that the operation binding enforced by AWare significantly raised the bar for malicious apps trying to trick the users in authorizing unintended operations, going from an average attack success rate of 85% down to 7%, on average, with AWare.What is the decision overhead imposed to users due to per-configuration access control? We used a well-known compatibility test suite to evaluate the compatibility of AWare with existing apps and found that, out of 1,000 apps analyzed, only five of them malfunctioned due to attempted operations that AWare blocked as potentially malicious. Lastly, participants in Group6 interacted with a modified version of the Android OS integrating the AWare authorization framework.Experimental Procedures: Before starting the experiment, all participants were informed that attacks targeting sensitive audio and video data were possible during the interaction with apps involved in the experimental tasks, but none of the participants were aware of the attack source. Group1 (Install-Time): Group2 (First-Use): Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare):100% 93% 100% 100% 0% 0%TASK 2 : Take a picture with the front camera by using the SimpleFilters app.Bait-and-Context-Switch: We make the video camera widget appear in the photo capture window, with a camera preview, to trick the user into allowing SimpleFilters to record audio instead of just take a picture. Group1 (Install-Time): Group2 (First-Use): Group3 (Input-Driven): Group4 (Developer ID): Group5 (AC Gadgets): Group6 (AWare):93% 93% 93% 47% 93% 0% Table 1: Experimental tasks for the laboratory-based user study to evaluate the effectiveness of AWare in preventing four types of user interface attacks. Thus, the binding request clearly identifying the operation requested by the app aided them in avoiding to be tricked into granting an unintended operation.The analysis of the subjects' responses to TASK2 and TASK3 revealed that the users were successfully tricked by either switching the user interface configuration within which a widget is presented, or by changing the widget presented within the same configuration, thus, leading them into making mistakes. Furthermore, one subject from Group6 (AWare) had mistakenly authorized SimpleFilters to carry out an unintended operation Hands-Free ControlGoogle Voice Search HappyShutter SnapClap Table 2: Applications tested during the field-based user study, selected among the most popular apps from the Google Play store. We also measured the total number of authorizations handled by AWare via the operation binding cache mechanism that, transparently to users, granted previously authorized operations.Experimental Procedures: Participants were asked to use, for a period of one week, a Nexus 5X smartphone running a modified version of the Android OS integrating the AWare authorization framework. Over the 21 apps, an average of 2.28 additional explicit user authorizations are required per app.Also, as expected, the number of explicit authorizations made by the users remained a constant factor compared to the number of operation authorization requests, automatically granted by AWare (last column of Table 2), which instead grew linearly during the experiment period. From our experiments, we found that only 1 of the 24 users granted persistent access to the front camera for the HappyShutter app, whereas, only 2 other users granted persistent access to the microphone for the SnapClap app.The other two failures were due to remote access to the smartphone's camera attempted by two apps, namely Lockwatch and Prey Anti-Theft, which can capture pictures with the front camera when someone tries to unlock the smartphone's screen with a wrong passcode. The experimental results reported in the first row of Ta- ble 3 show that the average recorded system-wide performance overhead is 0.33% when measuring the additional time required by AWare to handle the operation binding construction, authorization and caching.We also performed a microbenchmark to measure the overhead introduced by AWare while specifically handling access requests for operations targeting privacy-sensitive sensors, such as the camera to take photos and videos, the microphone to record audio, and the screen to capture screenshots; and to measured the overhead introduced for the authentication of app-specific widgets and their display contexts. However, if another application's request occurs first after a user input event and within the given temporal threshold, then the user input is directly used to authorize the other applications request, no matter what operation the application is requesting.In What You See is What They Get [23] the authors propose the concept of a sensor-access widget. However, the delay introduced for the waiting time (necessary to allow explicit denial) may cause issues for time-constrained applications and may frustrate users.User-Driven Access Control (UDAC) [39,41] proposes the use of access control gadgets to prevent malicious operations from applications trying to access privacysensitive sensors without a user-initiated input. We evaluated the effectiveness of AWare for eliminating ambiguity in a laboratory-based user study, finding that users avoided mistakenly authorizing unwanted operations 93% of the time on average, compared to 19% on average when using proposed research methods and only 9% on average when using first-use or install-time authorizations. We rendered a widget and its activity window 50 times under different system settings and configurations to cause the a widget or its activity window to be rendered in different ways (i.e., screen orientation, concurrent activity windows, etc. Therefore, AWare does not limit the use of nested activity windows or prohibit activity window reuse but rather ensures that the context is defined by the entire hierarchy of nested activity windows. Our Here, we discuss how AWare addresses special cases of applications' accesses to privacy-sensitive sensors.Background Access: To enable background access, AWare still uses the explicit authorization mechanism via the creation of a binding request.