While a core dump carries a large amount of information , it barely serves as informative debugging aids in locating software faults because it carries information that indicates only a partial chronology of how program reached a crash site. To demonstrate its effectiveness in pinpointing program statements truly pertaining to a program crash, we have implemented POMP for Linux system on x86-32 platform, and tested it against various program crashes resulting from 31 distinct real-world security vulnerabilities. Of all techniques on postmortem program analysis, recordand-replay (e.g., [10,12,14]) and core dump analysis (e.g., [16,26,36]) are most common.Record-and-replay is a technique that typically instruments a program so that one can automatically log nondeterministic events (i. e., the input to a program as well as the memory access interleavings of the threads) and later utilize the log to replay the program deterministically. In practice, it however is not widely adopted due to the requirement of program instrumentation and the high overhead it introduces during normal operations.In comparison with record-and-reply, core dump analysis is a lightweight technique for the diagnosis of program crashes. However, a core dump provides only a snapshot of the failure, from which core dump analysis techniques can infer only partial control and data flows pertaining to program crashes. Since this post-crash artifact contains both the state of crashing memory and the execution history, software developers not only can inspect the program state at the time of the crash, but also fully reconstruct the control flow that led to the crash, making software debugging more informative and efficient.While Intel PT augments software developers with the ability of obtaining more informative clues as to a software crash, to use it for the root cause diagnosis of software failures, it is still time consuming and requires a lot of manual efforts. Given that the technique proposed in [22] needs to track data flow using hardware watchpoints in a collaborative manner, this technique is also less suitable to the situation where program crashes cannot be easily collected in a crowd-sourcing manner.In this work, we design and develop POMP, a new automated tool that analyzes a post-crash artifact and pinpoints statements pertaining to the crash. In this work, considering a software vulnerability might incur memory corruption and object recording imposes overhead on normal operations, we relax this assumption and the ability of data object recording, and introduce a recursive algorithm. • We implemented POMP on 32-bit Linux for facilitating software developers (or security analysts) to pinpoint software defects, particularly memory corruption vulnerabilities. • We demonstrated the effectiveness of POMP in facilitating software debugging by using various postcrash artifacts attributable to 31 distinct real world security vulnerabilities.The rest of this paper is organized as follows. Table 1: A toy example with a stack overflow defect. Then, we discuss why failure diagnosis can be tedious and tough even though a post-crash artifact carries information that allows software developers to fully reconstruct the control flow that a program followed prior to its crash. Up to and including Linux 2.2, the default action for CPU time limit exceeded, for example, is to terminate the process without a post-crash artifact [3]. Since security analysts may not have the access to source code of crashing programs and they can only pinpoint software defects using execution traces left behind crashes, it should be noted that we do not assume the source code of the crashing program is available. As such, it is tedious and arduous for a software developer to plow through an execution trace to diagnose the root cause of a software failure.In fact, even though an execution trace is short and concise, it is still challenging for commonly-adopted manual diagnosis strategies (like backward analysis). To diagnose the root cause with backward analysis for the program crash shown in Figure 1, a software developer or security analyst typically follows through the execution trace reversely and examines how the bad value in register eax was passed to the crash site (i. e., instruction A20 shown in Figure 1). In that instruction mov overwrote register eax and an inverse operation against this instruction lacks information to restore its previous value.To address this problem, one straightforward solution is to perform forward analysis when backward analysis reaches a non-invertible instruction. As a result, we can restore the value in register eax and thus complete the inverse operation for instruction A19.While the backward and forward analysis provides security analysts with an effective method to construct data Register eax 0x0002 0x0002 0x0000 0x0000 0x0000 0x0000 0xff1c 0xff1c 0xff18 ebp 0xff28 0xff28 0xff28 0xff28 0xff28 0xff08 0xff08 0xff08 0xff08 esp 0xff14 0xff14 0xff14 0xff10 0xff0c 0xff08 0xff08 0xff08 0xff08Memory Address 0xff1c 0x0002 0x0002 0x0002 0x0002 0x0002 0x0002 0x0002 test test 0xff18 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0x0001 0xff14 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0x0000 0xff10 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff18 0xff180xff0c A18 A18 A18 A18 A18 A18 A18 A18 A18 0xff080xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28 0xff28Execution trace flows, this is not sufficient for completing program failure diagnosis. Given a post-crash artifact containing an execution trace carrying a large amount of instructions that a program has executed prior to its crash, however, any instructions in the trace can be potentially attributable to the crash. Here, our hypothesis is that the achievement of this goal can significantly reduce the manual efforts of finding out the root cause of a software failure. Without having POMP tie to a set of programs written in a particular programming language, our design principle first allows software developers to employ a single tool to analyze the crashes of programs written in various language (e.g., assembly code, C/C++ or JavaScript). PT is a low-overhead hardware feature in recent Intel processors (e.g., Skylake series). Since a post-crash artifact has already carried the control flow that a crashing program followed, the main focus is to reconstruct the data flow from the post-crash artifact that a crashing program left behind.To reconstruct the data flow pertaining to a program failure, POMP introduces a reverse execution mechanism to restore the memory footprints of a crashing program. Since instruction A17 can be treated as mov eip, [esp] and then add esp, 0x4, and instruction A16 is equivalent to mov ebp, [esp] and then add esp, 0x4, reverse execution can further restore memory footprints prior to their execution by following the scheme of how it handles mov and arithmetical instructions above. In Figure 1, we illustrate the memory footprints prior to the execution of both instructions.Recall that performing an inverse operation for instruction A15, forward and backward analysis cannot determine whether the use of [ebp+0x8] specified in instruction A12 can reach the site prior to the execution of instruction A15 because [eax] in A14 and [ebp+0x8] in A12 might just be different symbolic names that access data in the same memory location.To address this issue, one instinctive reaction is to use the value-set analysis algorithm proposed in [11]. Then, it tests each of these hypotheses by emulating inverse operations for instructions.Let's continue the example shown in Figure 1. By looking at the memory footprint at T 14 and examining these two constraint sets, reverse execution can easily reject the first hypothesis and accept the second because constraint eax = ebp + 0x8 for the first hypothesis does not hold. For example, given an initial use-define chain derived from instructions A20 and A19 shown in Figure 1, POMP extracts the use and definition from instruction A18 and links them to the head of the chain (see Figure 2). In addition, we can observe that a use-define relation includes not only the relations between operands but also those between operands and those base and index registers enclosed (see the use and definition for instruction A19 shown in Figure 2). By resolving, we mean the variable satisfies one of the following conditions -x the definition (or use) of that variable could reach the end of the chain without any other intervening definitions; y it could reach its consecutive use in which the value of the corresponding variable is available; z a corresponding resolved definition at the front can reach the use of that variable; { the value of that variable can be directly derived from the semantics of that instruction (e.g., variable eax is equal to 0x00 for instruction mov eax, 0x00). Slightly different from the process for definition def:esp=esp+4, for this use, variable esp is not resolvable through the aforementioned reachability examination. The reason behind the maintenance of these constraints is to be able to perform memory alias verification discussed in the following section.In the process of resolving variables and propagating definitions (or uses), our algorithm typically encounters a situation where an instruction attempts to assign a value to a variable represented by a memory region but the address of that region cannot be resolved by using the information on the chain. From the use-define chain pertaining to this example shown in Figure 3, we can easily observe the node with A13 def:eax does not carry any value though its impact can be propagated to the node with A14 def: [eax] without any other intervening definitions.As we can observe from the example shown in Fig- ure 3, when this situation appears, a definition like A14 def: [eax] may potentially interrupt the reachability of the definitions and uses of other variables represented by memory accesses. For example, given that memory indicated by [ebp+0x08] and [eax] might be an alias of each other, definition A14 def: [eax] may block the reachability of A12 use: [ebp+0x08]. As such, in the step of use-define chain construction, our algorithm treats those unknown memory writes as an intervening tag and blocks previous definitions and uses accordingly. As a result, the second step of our algorithm is to minimize the side effect introduced by the aforementioned strategy.Since the conservative design above roots in "undecidable" memory alias, the way we tackle the problem is to introduce a hypothesis test mechanism that examines if a pair of symbolic names points to the same memory location. For example, given a use-define chain established under a certain hypothesis, the walk-through discovers that a register carries an invalid address and that invalid value should have the crashing program terminate at a site ahead of its actual crash site. The reason is that a new hypothesis test may help remove an additional intervening tag conservatively placed at the first step, and thus provides the holding test with more informative evidence to reject hypotheses accordingly.To illustrate this, we take a simple example shown in Figure 4. Following the procedure discussed above, we reversely analyze the trace and make a hypothesis, i. e., [R 4 ] and [R 5 ] are not alias. It should be noted that if any of the hypotheses fail to reject, our algorithm preserves the intervening tags conservatively placed at the first step.It is not difficult to spot that our hypothesis test can be easily extended as a recursive procedure which makes more hypotheses until they can be rejected. However, a recursive hypothesis test introduces computation complexity exponentially. Thus, our reverse execution can simply ignore the inverse operations for those system calls.For system calls that potentially influence the memory footprints of a crashing program, our reverse execution handles them as follows.In general, a system call can only influence memory footprints if it manipulates register values stored by the crashing program or touches the memory region in user space. Regarding the system calls that manipulate the memory content in user space (e.g., write and recv), our algorithm checks the memory regions influenced by that call. The reason behind this is that a non-deterministic memory region can potentially overlap with any memory regions in user space. POMP treats register eax as a sink in that the program crash results from retrieving an invalid instruction from the address held by register eax.With a sink identified, POMP taints the sink and performs taint propagation backward. With sink eax serving as the initial taint variable, POMP selects A19 def:eax=[ebp-0xc] on the chain because this definition can reach taint variable eax without intervention.From the definition identified, POMP parses that definition and passes the taint to new variables. For example, given a taint variable [R 0 ] and a definition def: [R 1 ] with R 1 unknown, POMP cannot determine whether R 0 and R 1 share the same value and POMP should pass the taint to variable [R 1 ]. In the ToPA, we introduced an additional entry to refer this buffer.At the hardware level, Intel PT lacks the capability of distinguishing threads within each process. In addition, we configured Intel PT to exclude packets irrelevant to control flow switching (e.g., timing information) and paused its tracing when execution traps into kernel space. The remaining 18 PoCs are created to simply trigger the defects, such as overflowing a stack buffer with a large amount of random characters (e.g., BinUtils-2.15) or causing the execution to use a null pointer (e.g., gdb-7.5.1). The focuses of this comparison include x examining whether the root cause of that crash is enclosed in the instruction set POMP automatically identified, y investigating whether the output of POMP covers the minimum instruction set that we manually tracked down, and z exploring if POMP could significantly prune the execution trace that software developers (or security analysts) have to manually examine.In order to evaluate the efficiency of POMP, we recorded the time it took when spotting the instructions that truly pertain to each program crash. Given that backward taint analysis mimics how a software developer (or security analyst) typically diagnoses the root cause of a program failure, this observation indicates that POMP has a great potential to reduce manual efforts in failure diagnosis.Except for test case coreutils, an instruction set produced by POMP generally carries a certain amount of instructions that do not actually contribute to crashes. As such, we generally observe more instructions over-tainted for those test cases, where POMP needs to reversely execute more instructions in order to cover the root causes of their failures.As we discuss in Section 4, ideally, POMP can employ a recursive hypothesis test to perform inverse operations for instructions that carry unknown memory access. Since both the size of the data chunk and the address of the memory are specified in registers, which reverse execution fails to restore, POMP treats sys_read as a "super" intervening tag that blocks the propagation of many definitions, making the output of POMP less informative to failure diagnosis.Different from aireplay-ng, the failure for 0verkill results from an insufficient PT log. Reverse execution is a conventional debugging technique that allows developers to restore the execution state of a program to a previous point. Depending on how the solver performs on constraint sets corresponding to multiple test runs, the technique proposed automatically determines where to instrument the code to save intermediate values and facilitate reverse execution.Given that state saving requires extra memory space and program instrumentation results in a slower forward execution, recent research proposes to employ a core dump to facilitate reverse execution. Rather, our approach identifies the root cause of software failures by reversely executing program and reconstructing memory footprints prior to the crash.Considering the low cost of capturing core dumps, prior studies also proposed to use core dumps to analyze the root cause of software failures. Different from these techniques, Kasikci et al. introduced Gist [22], an automated debugging technique that utilizes off-the-shelf hardware to enhance core dump and then employs a cooperative debugging technique to perform root cause diagnosis. In practice, this assumption however may not hold, and the information held in a post-crash artifact may not be sufficient and even misleading for root cause diagnosis.While this multi-thread issue indeed limits the capability of a security analyst using POMP to pinpoint the root cause of a program crash, this does not mean the failure of POMP nor significantly downgrades the utility of POMP because of the following. We show that POMP can significantly reduce the manual efforts on the diagnosis of program failures, making software debugging more informative and efficient. This work was supported by ARO W911NF-13-1-0421 (MURI), NSF CNS-1422594, NSF CNS-1505664, ONR N00014-16-1-2265, ARO W911NF-15-1-0576, and Chinese National Natural Science Foundation 61272078.