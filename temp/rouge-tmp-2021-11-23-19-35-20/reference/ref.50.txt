In this work, we propose CHAINIAC, a decentralized software-update framework that eliminates single points of failure , enforces transparency, and provides efficient verifi-ability of integrity and authenticity for software-release processes. Independent witness servers collectively verify conformance of software updates to release policies, build verifiers validate the source-to-binary correspondence , and a tamper-proof release log stores collectively signed updates, thus ensuring that no release is accepted by clients before being widely disclosed and validated. Hence, modern software-update systems should provide efficient and secure means to evolve signing keys and should enable client notification in a timely manner.To address these challenges, we propose CHAINIAC, a decentralized software-update framework that removes single points of failure, increases transparency, ensures integrity and authenticity, and retains efficient verifiability of the software-release process. First, CHAINIAC introduces a decentralized release sign-off model for developers which retains efficient signature verifiability by using a multi-signature scheme. An additional advantage of this approach is that companies, in order to provide the source-to-binary guarantee to customers, can reveal source code only to third-party build verifiers who sign appropriate non-disclosure agreements.Third, CHAINIAC increases transparency and ensures the accountability of the update process by implementing a public update-timeline that comprises a release log, freshness proofs, and key records. Even if an attacker manages to slip a backdoor into the source code, the corresponding signed binary stays publicly available for scrutiny, thereby preventing secret deployment against targeted users.Finally, to achieve tamper evidence, consistency, and search efficiency of the timeline, and to enable a secure rotation of signing keys, CHAINIAC employs skipchains, novel authenticated data structures inspired by skip lists [55,61] and blockchains [41,56]. Although blockchains are well-known tools, to our knowledge the skipchain structure is novel and can be useful in other contexts, besides software updates.The evaluation of our prototype implementation of CHAINIAC on reproducible Debian packages shows that, in a group of more than a hundred verifiers, the endto-end cost per witness of release attestation is on average five minutes per package, with the verified builds dominating this overhead. In summary, our main contributions are as follows: • We propose CHAINIAC (Sections 3 and 5), a softwareupdate framework that enhances security and transparency of the update process via system-wide decentralization and efficiently verifiable logging. • We implement CHAINIAC (Section 7) and evaluate (Section 8) a prototype on real-world data from the Debian and PyPI package repositories.In this section, we give an overview of the concepts and notions CHAINIAC builds on, this includes scalable collective signing, reproducible builds, software-update systems, blockchains, and decentralized consensus. CoSi assumes that signature verifiers know the public keys of the witnesses, all of which are combined to form an aggregate public key of the cothority. Reproducible builds are software development techniques that enable users to compile deterministically a given source code into one same binary, independent of factors such as system time or build machines. However, we decentralize all these roles, use a larger number of keys, and log their usage and evolution to further enhance security and add transparency. CHAINIAC's skipchain structure is partly inspired by blockchains [41]: Whereas ByzCoin also uses collective signatures to enable lightclient verification, skipchains extend this functionality with skiplinks to enable clients to efficiently track and validate update timelines, instead of downloading and validating every signature. Source-to-binary affirmation: The software-update system should provide a high assurance-level to its clients that the deployed binaries have been built from trustworthy and untampered source code. Linear immutable public release history: The software-update system should provide a globally consistent tamper-evident public log where each software release corresponds to a unique log entry that, once created, cannot be modified or deleted. Evolution of signing keys: The software-update system should enable the rotation of authoritative keys, even when a (non-majority) subset of the keys is compromised. Each release includes source code, binaries (potentially, for multiple target architectures), and metadata such as release description.A snapshot refers to a set of releases of different software projects at a certain point in time. Build verifiers are a subset of the witnesses who execute, in addition to their regular witness tasks, reproducible building of new software releases and compare them to the release binaries. Furthermore, a threshold t v of n v build verifiers is honest and uses a trustworthy compiler [71] such that malicious and legitimate versions of a given source-code release are compiled into different binaries. Finally, we assume that users of CHAINIAC are able to securely bootstrap, i.e., receive the first version of a software package with a hard-coded initial public key of the system via some secure means, e.g., pre-installed on a hard drive, on a read-only media, or via a secure connection. • Get a client to load and run a release binary that is not approved by the developers or validated by the update cothority. To distribute software, one of the developers builds the source code and pushes the binary to a trusted software-update center from where users can download and install it. Moreover, without special measures, it is hard to verify that the binaries were built from the given (unmodified) source code, as the compilation process is often influenced by variations in the building-environment, hence non-deterministic. To protect against a single compromised developer, CHAINIAC requires that developers have individual signing keys and that a threshold of the developers sign each release, see step 1 ⃝ in Figure 1. To further unburden users and developers, we use a cothority to validate software releases (check developer signatures and reproducible binaries) and collectively sign them, once validated: steps 2 ⃝ and 3 ⃝ in Figure 1. To protect against release-history tampering or stealthy developer-equivocation, we adopt a public log for software releases in the form of collectively signed decentralized hash chains, see step 4 ⃝ in Figure 1. Forward links are cryptographic signatures of future blocks, which are added retroactively when the target block appears.We distinguish randomized and deterministic skipchains, which differ in the way the lengths of multi-hop links are determined. Both B t and F t can store exactly h t links and a reference at index 0 ≤ i ≤ h t − 1 in B t (F t ) points to the last (next) block in the timeline having at least height i + 1. For these reasons, forward links are created as digital (multi-)signatures. For a forward link from B t to B t+j , we store the cryptographic signature ⟨id t+j ⟩ Et at index i in F t where E t denotes the entity (possibly a decentralized collective such as a BFTCoSi cothority [41,42,69]) that represents the head of trust of the system during time step t. To create the required signatures for the forward links until all slots in F t are full, in particular, E t must "stay alive" and watch the head of the skipchain. Skipchains provide a framework for timeline tracking, which can be useful in other domains such as cryptocurrencies [42,43,56], key-management [41,51], certificate tracking [1,45] or, in general, for membership evolution in decentralized systems [68,69]. If the client has the correct hash of an existing block and wants to obtain a future or past block in the timeline from an untrusted source (such as a software-update server or a nearby peer), to cryptographically validate the target block (and all links leading to it), the client needs to download only a logarithmic number of additional, intermediate blocks.Secondly, suppose two resource-constrained clients have two reference points on a skipchain, but have no access to a database containing the full skipchain, e.g., clients exchanging peer-to-peer software updates while disconnected from any central update server. At the beginning of a project, the developers collect all their public keys in a policy file, together with a threshold value that specifies the minimal number of valid developer signatures required to make a release valid. Upon the announcement of a software release, which can be done by a subset or all developers depending on the project structure, all the developers check the source code and, if they approve, they sign the hash of it with their individual keys, e.g., using PGP [14], and they add the signatures to an append-only list. Therefore in our second step towards CHAINIAC, we transfer the responsibility of building binaries from users to developers.When a new software release is announced, it includes not only the source code but also a corresponding binary (or a set of binaries for multiple platforms) that users will obtain via an update center. Although decentralized developer approval and reproducible builds improve software-update security, running reproducible builds for each binary places a high burden on developers (e.g., building the Tor Browser Bundle takes 32 hours on an average modern laptop [60]). Hence to maintain decentralization, we implement the intermediary as a collective authority or cothority.To announce a new software release, the package developers combine the hashes of the associated source-code and binaries in a Merkle tree [52]. Clients can download and validate the release's source and/or any associated binary by verifying only a single collective signature and Merkle inclusion proofs for the components of interest.To validate a release, each cothority server checks the developer signatures against the public keys and the threshold defined in the policy file. The latter verification enables the transition from reproducible builds to verified builds: a deployment improvement over reproducible builds, which we introduce. The verified builds enable clients to obtain the guarantee of source-to-binary correspondence without USENIX Association 26th USENIX Security Symposium 1277 the need to accomplish the resource-consuming building work, due to the broad independent validation. Because the hash chain is cothority controlled, we can distribute the witnessing of its consistency across a larger group: for example, not just across a few servers chosen by the developers of a particular package, but rather across all the servers chosen by numerous developers who contribute to a large software distribution, such as Debian. Even if an attacker controls a threshold of developer keys for a package and creates a seemingly valid release, the only way to convince any client to accept this malicious update is to submit it to the cothority for approval and public logging. To enable a rotation of developer keys, a policy file needs to be a part of the Merkle tree of the release, hence examined by the developers. To update their keys, the developers first specify a new policy file that includes an updated set of keys, then, as usual during a new release, they sign it with a threshold of their current keys, thus delegating trust from the old to the new policy. With this approach, developers can rotate their keys regularly and, if needed, securely revoke a sub-threshold number of compromised keys. Using one set of keys for signing new releases and for timestamping introduces tradeoffs between security and usability, as online keys are easier compromisable than offline keys, whereas the latter cannot be used frequently. As a result, the ROOT skipchain has a height of one, with only singlestep forward and backward links.The CONFIG role represents the online keys of the update cothority and models CHAINIAC's control plane. This is equivalent to a downward link from the ROOT skipchain to the CONFIG skipchain.The RELEASE role wraps the functionality of the release log, as specified previously, and adds upward links to ROOT and CONFIG skipchains, enabling clients to efficiently look up the latest trusted ROOT and CONFIG configurations required for verifying software releases.Finally, the TIME role provides a timestamp service that informs clients of the latest version of a package, within a coarse-grained time interval. Each of these packages can be maintained by a separate group of developers, hence can deploy its own release log. Finally, the cothority forms a Merkle tree that summarizes all package versions in the snapshot, then collectively signs it.This architecture facilitates the gradual upgrade of large open-source projects, as packages that do not yet have their own skipchains can still be included in the aggregate layer as hash values of the latest release files. If there are such packages, the client accesses their individual release logs, knowing the hash values of the latest blocks.A multi-package project can potentially have several aggregate layers, each representing a certain distribution , e.g., based on the development phase of packages, as stable, testing, and unstable in Debian. An attacker might try to sneak a vulnerability into the source code, compromise the developers' signing keys, or intercept a release proposal that the developers send to the update cothority, and replace it with a backdoored version. If developers carefully review sourcecode changes and releases, and fewer than the threshold t d of developers or their keys are compromised, the attacker alone cannot forge a release proposal that the update cothority would accept. As with developer keys, the regular rotation of cothority keys further impedes a gradual compromise.If a threshold of online cothority keys are compromised, then, once this compromise is detected, the developers can use the offline ROOT keys to establish a new cothority configuration (see Section 5.6). If the cothority is configured with a two-thirds supermajority witness-threshold (t w ≥ 2n w + 1), forks are prevented by the BFT-CoSi consensus mechanism.Forward links are signatures that can be created only once the (future) target blocks have been appended to the skipchain. An adversary might also compromise the software-update center to disseminate malicious binaries, to mount freeze attacks that prevent clients from updating, or to replay old packages with known security vulnerabilities and force clients to downgrade.Clients can detect that they have received a tampered binary by verifying the associated signature using the public key of the update cothority; the key can be retrieved securely through CHAINIAC's update timeline. In Section 8.5, we simulated four collectively signing servers on a computer with a 3.1 GHz Intel Core i7 processor and 16 GB of RAM and did not include any network-latencies, as we measured only CPU-time and bandwidth.To evaluate the witness cost of the long-term maintenance of an update timeline, we used data from the Debian reproducible builds project [22] and the Debian snapshot archive [19]. Using Docker containers, we generated a reproducible build environment for USENIX Association 26th USENIX Security Symposium 1281 each package, measured the CPU time required to build a binary and verified the obtained hash against a precalculated hash from Debian. The CPU time is higher than wall-clock time for some metrics, due to the use of a multi-core pro- Skipchain S 4 Figure 7: Communication cost for different frameworks cessor. The verification and build times are constant per node, whereas the time to sign and to generate the timestamp increases with the number of nodes, mostly due to higher communication latency in a larger cothority tree. We took the list of all the packages from the snapshot archive of the Debian-testing repository and created Figure 9: Communication cost to get new repository state one skipchain per package over 1.5-year history, such that each skipblock is one snapshot every five days. In order to maintain the security guarantees of CHAINIAC, the client downloads all package hashes and builds a full Merkle tree to verify them, thereby not revealing packages of interest and preserving her privacy. EthIKS [12] provides stronger auditability to CONIKS [51], an end-user key verification service based on a verifiable transparency log, by creating a Smart Ethereum Contract [75] that guarantees that a hash chain is not forked, as long as the ethereum system is stable and correct. The distinct layers of skipchains provide, while introducing minimal overhead for the client, multiple functionalities such as (1) tamperevident and equivocation-resistant logging of the new updates and (2) the secure evolution of signing keys for both developers and the set of online witnesses. Furthermore, we have replayed 30 days of actual client requests to the PyPI repository and shown that the use of skipchains limits the verification overhead.