In recent years, ride-hailing services (RHSs) have become increasingly popular, serving millions of users per day. In this paper, we propose ORide (Oblivious Ride), a privacy-preserving RHS based on somewhat-homomorphic en-cryption with optimizations such as ciphertext packing and transformed processing. In addition, ORide supports key RHS features such as easy payment, reputation scores, accountability, and retrieval of lost items. Their advantage over traditional taxi services is due to the convenience of their services, e.g., ride requests at the touch of a button, fare estimation, automatic payments, and reputation ratings. As a result, the SP, or any entity with access to this data, can infer sensitive information about riders' activities (such as one-night stands [35]), monitor the locations of riders in real-time for entertainment [18], track the whereabouts of their exlovers [42], look up trip information of celebrities [25], and even mount revenge attacks against journalists critical of such services [46]. For this purpose, ORide relies on state-of-the-art somewhathomomorphic encryption system [16] (SHE), to which we apply optimizations for ciphertext packing and transformed processing [38], hence enabling a notable boost in performance and a reduction in overhead w.r.t. naive cryptographic solutions.Accountability and usability are often considered as important as privacy in RHSs [11,15]; this introduces challenges in resolving the uneasy tension between privacy, accountability and usability. To achieve accountable privacy, ORide enables the SP to revoke, when needed, the anonymity of misbehaving riders or drivers. ORide also preserves the reputation-rating operations of current RHSs.The evaluation of ORide by using real data-sets from NYC taxi cabs [44] shows that, even with strong bitsecurity of more than 112 bits, ORide introduces acceptable computational and bandwidth costs for riders, drivers and the SP. ORide also provides large anonymity sets for riders at the cost of acceptable bandwidth requirements for the drivers: e.g., for rides in the boroughs of Queens and Bronx, a ride would have an anonymity set of about 26,000, and the drivers are only required to have a data-connection speed of less than 2 Mbps. In summary, we make the following contributions:• A novel, oblivious, and efficient ride-matching mechanism. In particular, ORide supports functionalities that are often considered also as important as privacy, such as credit-card payment, reputation rating, contacting drivers in case of lost items and traceability in case of criminal activity during a ride. In addition, the computational and network overhead introduced by ORide is practical for riders, drivers and SP. Researchers have proposed different privacy-enhancing solutions for ride sharing (i.e., car pooling) services [6,14,21,22,40] and public transportation ticketing systems [8,26,31]. Third, PrivateRide provides limited accountability features to deal with relatively common scenarios such as drivers and riders physically attacking each other (i.e., safety concerns) or items being lost during a ride; for many users, such features can be as important as their privacy. Fourth, PrivateRide's usability is reduced w.r.t. current RHSs because the supported payment mechanism is less convenient (i.e., PrivateRide requires payments with e-cash bought in advance before a ride). Our goal is to design a RHS that provides stronger privacy guarantees to both riders and drivers, as well as better or equivalent usability and accountability compared with PrivateRide [39] and current RHSs (e.g., Uber, Lyft, and Easy Taxi). This is a reasonable assumption, because such attacks can be detected by third-parties via reverseengineering or black-box analyses; the risk of public exposure and reputation loss is a strong deterrent against such attacks.Given that they have been observed in current RHSs (i.e., higher chance of occurring), we focus on the following attacks:• (A1) The riders and drivers might attempt to assault each other [48]; in extreme cases, a driver might attempt to kidnap and/or kill the rider, or vice versa [37,49]. • (A2) The SP uses its knowledge about side information about riders and drivers, including their home/work addresses, together with protocol transcripts, to perform large-scale inference attacks to profile riders' and drivers' activities [35]. • The system preserves the convenience and usability properties offered by current RHSs, such as payment through credit cards and reputation rating. In addition, once a rider is matched with a driver, she can track the location of the driver approaching the pick-up location, and they can contact each other to coordinate the pickup. A polynomial of degree (d − 1) will be interchangeably denoted as a = ∑ d−1 i=0 a i X i or in its vector form a a a when there is no ambiguity. One of the challenges in privacy-preserving RHSs is how to efficiently match ride requests to ride offers without revealing the riders' and drivers' locations to each other and to the SP. Let ∆ = q/t and χ k , χ n be two short noise random distributions in R q , the FV encryption of a message m ∈ R t with secret key k s = s ∼ χ k and public keyk k k p = [p 0 , p 1 ] = [(−a · s + e), a] ∈ R 2q , with e drawn from χ n and a randomly chosen in R q , generated by FV.GenKeys, results in a vector expressed asc c c = FV.Enc(k k k p , m) = [p 0 ·u+e 1 +∆·m, p 1 ·u+e 2 ], (1)where u is drawn from χ k , and e 1 , e 2 are short random polynomials from the error distribution χ n . tions to obtain the encryption of the added, subtracted, and multiplied plaintexts respectively; multiplications consider the encryptions as polynomials in v:[c 0 , c 1 ] → c o + c 1 · v,such that the product between c c c and c c c is evaluated as:[c 0 , c 1 ] · [c 0 , c 1 ] → c 0 · c 0 + (c 0 · c 1 + c 1 · c 0 )v + c 1 · c 1 · v 2 → [c 0 , c 1 , c 2 ], which results in a ciphertext in R 3q , with one extra polynomial. The SP computes, based on their encrypted coordinates, the encrypted distances between the rider and the drivers, and it returns the encrypted distances to the rider, from which the rider can decrypt and select the best match, e.g., the driver who is the closest to her pick-up location.However, due to the high ciphertext expansion, a naive use of SHE would incur impractical computational and bandwidth costs for the riders and the SP. This would incur an unfeasible overhead in terms of computations for the SP, consequently delaying the ride-matching for the rider and a considerable bandwidth overhead at the rider-SP link, e.g., hundreds of MBs if the system has several thousand drivers (see Section 9.3). From here on, we assume that d ≥ n, which will usually be the case due to the security bounds on d (see Section 8); in other cases, n/d encryptions can be used to pack the whole set of distances analogously.First, ciphertext packing enables the SP to pack n ciphertext distances into one ciphertext, hence reducing the bandwidth overhead, but this is not enough for our goal. While polynomial additions and subtractions are naturally coefficient-wise, polynomial multiplication in R t (and its homomorphic counterpart in R q ) is a convolution product of the coefficients. As a result, we improve on both the bandwidth and the computation overhead.Moreover, due to the low degree of the evaluated operations (squared Euclidean distances), we avoid the use of re-linearizations at the SP, which (a) reduces the need to generate and to send the relinearization key from the rider to the SP, (b) reduces the noise inside the encryptions, and (c) enables more efficient operations at the SP, at the cost of one extra polynomial to represent the encrypted distance returned to the rider. ORide provides strong location privacy and anonymity for riders and drivers while still guaranteeing service accountability, secure payment and reputation rating operations. When a rider initiates a ride request, the SP, the rider and drivers are involved in a ride set-up procedure (Section 5.4) that matches the rider to a driver. We assume each rider and driver has a digital certificate denoted as cert R or cert D , issued by the SP at registration time. They are used by the riders and drivers to identify each other during the ride as part of ORide's accountability mechanism (Section 6). To differentiate between riders and drivers in the system, an AC also contains a role attribute role X , i.e., role X = 1 if X = D, and role X = 0 if X = R.Note that to prevent the SP from de-anonymizing users by correlating the time an AC is issued with the time it is used, or by relying on the AC's expiration date, the user's app could automatically request ACs from the SP at a certain time (e.g., at midnight), and the expiration date is coarse-grained, e.g., all ACs issued in a day expire at the end of that day. Each rider is required to possess a deposit token and give it to the SP at the beginning of a ride. To use the service, the rider and the driver need to create anonymous sessions to the SP: to do so, they use their anonymous credentials AC R and AC D , respectively.Rider. Similarly to the rider, by using her AC D , the driver follows the same aforementioned procedure to anonymously log in to the service.The SP assigns a one-time session ID to each anonymous session, to keep track of that session for coordination. For the sake of simple exposition, hereafter, we exclude this one-time session ID from messages exchanged between the rider/driver and the SP. The SP confirms with the rider and the driver that they have been assigned to each other.Rider: anonymous session s R SP Driver: anonymous session s D Generate (k k k p , k s ) p x R = ∑ d−1 i=0 x R X i p y R = ∑ d−1 i=0 y R X i c c c x R = FV.Enc(k k k p , NTT −1 (p x R )) c c c y R = FV.Enc(k k k p , NTT −1 (p y R )) q i x D = x D i X i q i y D = y D i X i c c c i x D = FV.Enc(k k k p , NTT −1 (q i x D )) c c c i y D = FV.Enc(k k k p , NTT −1 (q i y D )) c c c x D = ∑ n−1 i=0 c c c i x D c c c y D = ∑ n−1 i=0 c c c i y D c c c dist = (c c c x R − c c c x D ) 2 + (c c c y R − c c c y D ) 2 d d di i is s st t t = NTT(FV.Dec(k k k s , c c c dist )) Select driver, denoted ibest (1) z, dt, c c c x R , c c c y R , k k k p (2) k k k p , i(7a. The rider and the driver establish a secure channel via the SP, e.g., using the unauthenticated Diffie-Hellman protocol, to exchange data that should not be observed by the SP. 1 From the information used to derive the secret key of the secure channel, the rider and the driver compute a shared secret pairing PIN. Also, at this point, the rider and the driver can call or message each other through their ride-hailing apps, if needed.8. When the rider and the driver are in proximity, the driver performs a proximity check to verify the physical presence of the rider before releasing her identifying information: they use a short-range wireless technology (e.g., Bluetooth or WiFi Direct) to set up a proximity channel using the pairing PIN. The rider and driver then sign a message consisting of the day of the ride, the fare and their certificates, i.e., fare report = sig R−D {day, fare, cert R , cert D }, using the private keys associated with their cert R and cert D . Also, some random time after the fare-report agreement, they terminate their anonymous sessions.Intuitively, because the distances between the rider and drivers are computed based on their (encrypted) precise locations, expanding the size of the zone will not result in negative effects on the performance of the ridematching and fare-calculation operations. When the car arrives at the drop-off location, the driver creates a new anonymous session to the SP. Note that the driver does not report to the SP that the ride is completed.At the end of the day, the driver sends to the SP the fare report sig R−D {day, fare, cert R , cert D } she received during the ride set-up operation (step 10, Section 5.4). The SP then notifies the rider about the payment and that a new deposit token is available. However, it is important to note that, in order to prevent the SP from de-anonymizing the rider and the driver by correlating the time that a fare report is deposited with the drop-off event of the ride, the payment operation should not occur immediately after the ride, e.g., the drivers deposit the fare reports to the SP at the end of the day. In ORide, when a rider cancels a ride, the SP can offer her two options: to lose her deposit token (i.e., pay a penalty) or to reveal her cert R and have her reputation score lowered. ORide enables the rider and the driver to exchange, during the ride set-up procedure, their digital certificates, i.e., cert R and cert D , respectively, and the fare report. Likewise, the affected party cannot obtain the real identity of the attacker without support from the SP, because the certificates cert R and cert D contain only the pseudonyms and only the SP knows the mapping between the pseudonyms and the real identities of the certificate owners.ORide enables the rider to share with her trusted peers the driver's certificate cert D and the fare report, via outof-band channels such as messaging apps, or a plug-in in her rider app. A rider cannot avoid paying the fare of a ride, because the fare report contains her digital certificate cert R and the day of the ride. Yet in this case, ORide offers the same guarantees as current RHSs, because riders can already request a small ride through the application and then pay in cash for a longer ride once they have met the driver. From an economic perspective, ridehailing service SPs would have incentives to deploy ORide because it provides privacy and security for the riders and still preserves their business models (i.e., the SP can still charge a commission for each ride). Our protocol can cope with this malicious behavior by adding one extra step in which the SP homomorphically multiplies each driver ciphertext by a mask m i = NTT −1 (X i ) for the driver's index i (see notations from Section 5.4), which preserves only the contents in the allocated slot. Here, m i can be thought of as its own noiseless and unscaled encryption (Equation (1) on page 4, evaluated for u, e 1 , e 2 = 0, and no scale ∆), being a vector in R 2 q with only one non-zero component([m i , 0] ∈ R 2 q ). The operation consists of two polynomial multiplications, it avoids encryption of m i , halves the number of products w.r.t. an encrypted homomorphic multiplication, and keeps the cipher size from growing after the product, thus considerably improving the performance of this operation.In any case, this precaution is only needed in case the drivers are malicious; and random checks on their locations can be implemented instead if the drivers are just covertly active (i.e., they refrain from cheating if there is a negligible chance of being caught in the act). If the SP is an active attacker, it might attempt to perform a man-in-the-middle (MITM) attack at Step 2 of the ride set-up protocol (Section 5.4) by replacing the public key k k k p . A PoR is a random number rand generated by the rider, signed by the driver by using the secret key associated with her cert D , and then blindly signed by the SP by using blind-signature schemes such as [13], i.e., PoR = Bsig SP {sig D {rand}}. Similarly, to prevent a rider from double-spending a PoR, and the SP from reusing a valid PoR to perform the aforementioned active attack, the SP maintains and publishes an append-only logs of PoRs that have been spent, or cancelled (due to ride cancellation). Note that the zone in ORide is larger than the zone in PrivateRide without affecting the ride-matching optimality (see Section 9.4). • Ride DB, in which each entry contains the role and expiration date of the AC, the pick-up zone and obfuscated pick-up time. • Payment DB, in which each entry contains a rider's ID, a driver's ID, a fare, and the day the fare report is deposited to the SP. Since RHS drivers are often licensed to operate in a city or state, knowing that a rider took a ride with a specific driver, the SP might be able to know the city where the rider took a ride, but it does not know the specific location in the city. For improved anonymity, anonymouspayment methods, such as e-cash or regular cash, could be used to decouple the riders' identities from the fares, thus preventing the SP from learning about rides between home and work of the riders.By using the Ride DB, the SP might be able to guess the identities of the riders, only if the pick-up zone has a limited number of ride activities and riders, e.g., a zone where only one rider lives. Note that the SP would be detected if it lied about the activity densities in the zones, because these densities are public knowledge [43], and the drivers would notice if they received very few ride requests from a certain zone.In the case where the SP knows that a rider makes ride requests from a specific zone (e.g., the zone that contains her home/work addresses) and it wants to know the pickup times of these rides, the anonymity set of a ride is the number of rides that occurred on the same day from that zone. Knowing the fare from the Payment DB, the SP might be able to guess whether the target went home or to work, but it could not know about other destinations. ORide mitigates this attack by applying two measures:(1) requiring a deposit token from each rider per request, thus making the attack more financially expensive and enabling the SP to identify riders who make many requests and cancel (as discussed in Section 5.6), and (2) permuting the list of drivers' indices for each ride request (Step 2 in Section 5.4). The GPS traces of the rides are not given; however, the precise pickup and drop-off locations and times, and pseudo-IDs of the taxi drivers associated with the rides are provided.In addition, the data-set provides mapping between latitude/longitude coordinates to NYC census tracts (CTs), neighborhood tabulation areas (NTAs) and boroughs in NYC.We make the following assumptions. Table 3: Per-ride bandwidth requirements of ORide, with d = 4096, log 2 (q) = 124, and there are 4096 drivers available for a ride request (n = 4096). Compared to the naive SHE approach S1, optimized approaches (S2 and S3) significantly reduce the bandwidth requirements for the riders Our ORide prototype features the main cryptographic operations for the ride matching in the ride set-up procedure (Section 5.4). Also, the amount of data exchanged between the rider and the SP, and the SP and the drivers, is small (as discussed in Section 9.4). In this section, we describe our experimental setup, and presents the bandwidth and computational overhead per ride request for a rider and a driver.We used ORide's prototype to estimate the overhead added for ride-matching operations in three settings: (S1) the naive SHE approach (Section 4.2) without using re-linearizations at the SP, (S2) ciphertext-packing optimizations and honest-but-curious drivers (i.e., drivers Table 4: Per-ride computational overhead of ORide (without AVX/SSE optimizations), for d = 4096, log 2 (q) = 124, and there are 4096 drivers available for a request. To measure the performance of our system, we used a computer (Intel i5-4200U CPU, 2.6 GHz, 6 GB RAM) with Debian Jessie (Linux kernel 3.16). With this security target, and a plaintext size of 20 bits the needed polynomial dimension is d = 4096, with coefficients of size 124 bits (each polynomial has a size of 62 KB). It is worth noting that we have considered pessimistic bounds in order to cope with recently published attacks that reevaluate the security of lattice-based cryptosystems [7]. Due to masking, setting S3 introduces a small computational overhead for the SP in homomorphic squared-Euclidean-distance computation, compared to setting S2 (745 ms vs. 208.9 ms). Due to the high demand of taxi rides in Manhattan w.r.t. lower activity in other boroughs in NYC (from our data-set, Manhattan accounts for 90% of ride requests), we define two zone settings as follows. The boroughs of Queens and Bronx are merged into one zone, and the boroughs of Brooklyn and Staten Island are merged into one zone. This means that with the security parameter chosen (as presented in Section 9.3) and when proposed optimized packing approaches are used, a rider needs to download only one ciphertext distance, i.e., 186 KB, which is negligible.Bandwidth requirements for drivers. Also, note that the results presented also show that ORide can scale, because current RHSs (e.g., Uber) accounts for only 15% of the ride pick-up requests in NYC [43]. To reduce the number of requests made to the Google APIs 3 , from the set of available drivers, we selected 100 drivers who were closest to the pick-up location as the potential candidates for the ideal matching.It can be observed that the median extra costs are 3 The number of requests per day is limited.small: when Z1 is used, in more than 45% of the cases, the driver selected by ORide and the ideal solution is the same, and, in nearly 80% of the cases, the extra driving distance is less than 0.5 km. In addition, the size of the zone has only negligible effects on the optimality of the matching algorithm: If the set of all the drivers available in NYC was used for the ORide matching algorithm, compared to the ideal solution, 78.7% of the cases would have an extra distance of less than 0.5 km, compared to 76.2 % and 76.8 % of the cases when Z1 and Z2 were used, respectively. In this paper, we have proposed ORide, a practical solution that efficiently matches riders and drivers in a privacy-preserving way while still offering key RHS features such as easy payment, reputation scores, accountability, and retrieval of lost items. A.2 Plaintext SpaceAssume a geographical area of size s × s and a plaintext space of b bits to represent the squared-Euclidean distances between points in the area. The area can be quantized into a grid with cells of size s/2 (b−1)/2 ×s/2 (b−1)/2 , with the explanation as follows. An anonymous credential (AC) is a cryptographic token with which the credential owner can prove to another party that she satisfies certain properties without revealing her real identity. ORide relies on the Anonymous Credentials Light (ACL) [9]. Assume a geographical area of size s × s and a plaintext space of b bits to represent the squared-Euclidean distances between points in the area. The area can be quantized into a grid with cells of size s/2 (b−1)/2 ×s/2 (b−1)/2 , with the explanation as follows. Therefore, the area can be represented by a grid with cells of sizeFor example, with 20-bit plaintext space, a geographical area of size 60 km 2 , such as the borough of Manhattan in NYC, would be quantized into a grid of resolution approximately 10 m × 10 m. ORide relies on the Anonymous Credentials Light (ACL) [9].