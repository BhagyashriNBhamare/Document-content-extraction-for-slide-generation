Everspaugh et al. (Usenix Security '15) provided the first comprehensive treatment of such a service and proposed the Pythia PRF-Service as a cryptographically secure solution. We thus suggest stronger security definitions that cover these kinds of real-world attacks, and an even more efficient construction, Phoenix, to achieve them. In spite of the research and development in authentication mechanisms such as public-key infrastructure or secure hardware tokens, the reality has shown that password-based authentication remains the most widespread means, especially on the Internet. The security of the Alice, 123456 Alice, salt H(salt,123456)Figure 1: Password-based Authentication passwords relies crucially on the assumption that the databases are kept secret from external attackers, and the internal administrators are trusted for not disclosing the databases or guessing the passwords themselves. It is not hard to see that any solution in which the web service can verify a given password alone is not viable, as a compromised service provider has all the knowledge (e.g., secret keys) to carry out a brute-force guessing attack (e.g., decrypting by the secret key of the web service) as in a normal validation. Its general advantage is that it abstracts crypto away from developers, freeing them from the selection and implementation of suitable algorithms and the involved issue of key management.Cryptographic PRF services are used in practice by Facebook [16] for password-based authentication. The service provider no longer stores salted hash values, but only pseudorandom values which can only be computed with the help of the external PRF server, i.e., the service provider acts as a client of the PRF service. For incident response after key compromise, or to update the key proactively as a prudent practice, both the web server and the crypto service should be able to rotate their keys, without the end users noticing anything. Very recently, Schneider et al. [21] claimed that all the properties expected by Pythia can be achieved by a weaker cryptographic primitive called partially-oblivious commitments (PO-COM). Using PO-COM, the PRF values are replaced with "enrollment records" which can be jointly computed by the client and the server via an enrollment protocol. In this work, we revisit the security notions of Everspaugh et al. [9] and Schneider et al. [21]. We argue that both fail to cover key rotation and rate limiting, while the latter even leaves room for practicallyrelevant attacks.In response, we propose strengthened security definitions for password hardening schemes. To fill the gap, we formalize forward security of password hardening services, which captures the security guarantee in the presence of key rotation mechanisms.Modeling Online Attacks. We argue that the definition of obliviousness (renamed to hiding in our work) given by Schneider et al. [21] is too weak. Below we only show part of the scheme which matters in the attack.In their scheme, an enrollment record, stored by the client C using the crypto service provided by S, can be seen as an ElGamal encryption under a secret key s x of S, in the form of (T 1 , T 2 ) = (g y , g ys x · pw sk C ) ∈ G 2 , where G is a (multiplicative) finite cyclic group. This opens the door for the following generic offline dictionary attack, without exploiting the structure of the zero-knowledge proof: An adversary A who compromised C (and hence obtained sk C and (T 1 , T 2 )) sends (g y , un, h) to S where h is a random group element independent of any passwords. We conclude that one must not use the scheme of Schneider et al., as our attack defeats its purpose of using an external crypto service.Reviving the Broken Scheme. Our scheme can, in fact, handle roughly 50% more request per second than that of Schneider et al. [21], and three times more than Pythia [9]. Our formalization of PH is closely related to the definition of partially-oblivious commitments (PO-COM) defined by Schneider et al. [21], with the main difference being that we consider key rotation in all security definitions. Each phase after the first is either an enrollment, a validation, or a key rotation phase, in an arbitrary order.In an enrollment phase, the client and the server cooperate to generate an enrollment record T for a username un, and a password pw, where un is an input available for both and pw is a private input from the client. We note that in the original syntax [21], while un is not an input of the server, it is supposed to be revealed to the server during the interactions in the protocol for rate limiting.Suppose an adversary, who may have knowledge of some enrollment records, compromises either the client or the server secret key. In addition to an updated client secret key, the client also obtains some auxiliary information, using which it is able to update each enrollment record locally, without further communicating with the server, nor knowing the underlying password of the record. A cryptographic password hardening service PH consists of the efficient algorithms (Setup, KGen C , KGen S , C, S enrl , C, S val , C, S rot , Udt), to be executed in four phases:Setup Phase. On input the public parameter pp, the client runs KGen C (pp) to generate a client public key pk C , and a client secret sk C , while the server runs KGen S (pp) to generate a server public key pk S , a server secret sk S . In the enrollment protocol C(sk C , un, pw, aux), S(sk S , un, aux) enrl , the client inputs its secret key sk C , a username un ∈ U, a password pw ∈ P, and some auxiliary information aux. In the validation protocol C(sk C , T, un, pw), S(sk S , un) val , the client inputs its secret key sk C , an enrollment record T , a username un ∈ U, and a password pw ∈ P. In the key rotation protocol C(sk C ), S(sk S ) rot , the client and the server input their secret keys sk C and sk S respectively. Formally, a cryptographic password hardening service scheme PH is correct if for all security parameter λ ∈ N, public parameters pp ∈ Setup(1 λ ), key pairs (pk C , sk C ) ∈ KGen C (pp) and (pk S , sk S ) ∈ KGen S (pp), username un ∈ U, password pw ∈ P, enrollment records T ∈ C(sk C , un, pw, ), S(sk S , un, ) enrl , it holds that C(sk C , T, un, pw), S(sk S , un) val = 1. Roughly speaking, partial oblivious means that it is infeasible, even for a malicious server, to tell which password pw is used by the client in the enrollment and validation protocols. We therefore simply let un be a common input for both parties in the enrollment and the validation protocols.Hiding means that, given the client secret key sk C , a username un, and an enrollment record T of (un, pw) for some hidden password pw, the best strategy of any adversary to guess pw is by launching an online dictionary attack which requires interaction with the server via the validation protocol.Binding requires that it is computationally infeasible, even for a malicious server, to convince the client that an enrollment record T is valid for two distinct pairs (un, pw) and (un , pw ). Partial obliviousness protects against a malicious server that wishes to learn the password pw behind an enrollment record after observing its creation and several validations. In fact, in the syntax defined above, we let the client reveal the username un to the server explicitly by regarding un as a common input.Technically, we consider a security experiment played between a challenger acting as the client and an adversary acting as the malicious server. Definition 2 (Partial Obliviousness) A cryptographic password hardening service PH is partially oblivious if, for any three-stage PPT adversaryObl b Π,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk C , sk C ) ←$ KGen C (pp) 2 : O := {{C(sk C , . . .), ·· X : X ∈ {enrl, val, rot}} 3 : (un * , pw * 0 , pw * 1 , state) ←$ A O 1 (pp, pk C ) 4: / / All client outputs are given to adversary, 5 :/ / except for sk C output by C(skC), ··rot.6 : / / C(skC), ··rot updates skC embedded in all oracles to skC . 7 : (T * , state) ←$ C(sk C , un * , pw * b , ), A 2 (st) enrl 8 : O := O ∪ {{C(sk C , ·, un * , pw * b ), ·· val } 9 : b ←$ A O 3 (state, T * ) 10 : / / C(skC, . . .), ··enrl and C(skC, . . .), ··val return ⊥ 11 : / / on input containing (un * , pw * b ) for b ∈ {0, 1}.12 : return b Figure 3: Partial Obliviousness ExperimentA = (A 1 , A 2 , A 3 ), there exists a negligible function negl (λ) such that Pr Obl 0 Π,A (1 λ ) = 1 − Pr Obl 1 Π,A (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiments and the adversary. Since the adversary can use the server as the magical oracle by interacting with it in the validation protocol, the best we can hope for is that the adversary cannot perform significantly better than the above strategy.Technically, we consider a security experiment (see Figure 4) played between a challenger acting as the server and an adversary acting as the malicious client. The challenger generates the server secret key honestly and keeps it secret (Line 1). The distribution models the real-world situations where the passwords to be protected are not uniformly random in {0, 1} λ but instead follow a certain distribution possibly with low entropy, which might be known by the adversary. The challenger then chooses a random password pw * (Line 7) from the distribution χ and computes a fresh challenge enrollment record T * for the tuple (un * , pw * ) using the honest client and server code (Line 8). hardening service PH is hiding if, for any two-stage PPT adversary A = (A 1 , A 2 ), there exists a negligible function negl (λ) such that HidingΠ,A (1 λ ) = 1 ≤ Q+1 i=1 p i + negl (λ)where the randomness is taken over the random coins of the experiment and the adversary, p i is the probability of the i-th most probable event in the distribution χ specified by A 1 in the experiment, and Q is the number of times ·, S(sk S , ·) val is queried by A 2 on server input un * . Similar to commitments, binding guarantees it is infeasible to open an enrollment record into two dis-Hiding Π,A (1 λ ) 1 : pp ←$ Setup(1 λ ), (pk S , sk S ) ←$ KGen S (pp) 2 : O := {{·, S(sk S , . . .) X : X ∈ {enrl, val, rot}}3 : / / All server outputs are given to adversary, 4 : / / except for sk S output by ·, S(skS )rot.5 : / / ·, S(skS )rot updates skS embedded in all oracles to skS . Figure 5 defines the binding experiment.Binding Π,A (1 λ ) 1 : (pk S , sk C , T * , un * 0 , pw * 0 , state) ←$ A 1 (1 λ ) 2 : (b 0 , state) ←$ C(sk C , T * , un * 0 , pw * 0 ), A 2 (state) val 3 : (un * 1 , pw * 1 , state) ←$ A 3 (state) 4 : (b 1 , state) ←$ C(sk C , T * , un * 1 , pw * 1 ), A 4 (state) val 5 : b 2 ← ((un * 0 , pw * 0 ) = (un * 1 , pw * 1 )) 6 : return b 0 ∧ b 1 ∧ b 2Figure 5: Binding Experiment Intuitively, the key rotation should render an old client or server key useless to the adversary. Rot b Π,A,L (1 λ ) 1 : pp ←$ Setup(1 λ ) 2 : (sk C , sk S , T, un, pw, state) ←$ A 1 (pp) 3 : b 0 ← C(sk C , T, un, pw), S(sk S , un) val 4 : if b = 0 then 5 : ((pk C , sk C , τ ), (pk S , sk S )) ←$ C(sk C ), S(sk S )rot 6 :T ←$ Udt(τ, T, un)7 : else 8 : (pk C , sk C ) ←$ KGen C (pp), (pk S , sk S ) ←$ KGen S (pp) 9 : aux ← L(T ) 10 : T ←$ C(sk C , un, pw, aux), S(sk S , un, aux) enrl 11 : endif 12 : b 1 ←$ A 2 (state, sk C , sk S , T ) 13 : return b 0 ∧ b 1 Figure 6: L-Forward Security Experiment Pr Rot 0 Π,A,L (1 λ ) = 1 − Pr Rot 1 Π,A,L (1 λ ) = 1 ≤ negl (λ)where the randomness is taken over the random coins of the experiments and the adversary. The idea is that, even given the client secret key sk C and the enrollment record T for some username un, the adversary can only guess the underlying password pw one at a time with the aid of the server. The resistance against offline dictionary attacks is then modeled by the success probability of the adversary: We require that the adversary must only be able to rule out at most one possible password from each query to the validation oracle. S should also delete all its intermediate values.To validate a candidate password pw , C computes the pseudorandom value h C ← PRF k C (un, pw , n C ), and performs a homomorphic operation on the ciphertext such that it now encrypts the product h S · h C /h C . Interestingly, with such an instantiation, an enrollment record is an encryption of H S (un, n S ) k S · H C (un, pw, n C ) k C , from which we can draw connection to Pythia [9], in which the record is computedSetup(1 λ ) crs ←$ Π.Gen(1 λ ), g ←$ G return (crs, g) KGen C (pp) pk C ← ⊥, sk C ← k C ←$ Zq return (pk C , sk C ) KGen S (pp) s, x, y, k S ←$ Zq h ← g s z ← g x h y pk S ← (h, z) sk S ← (s, x, y, k S )return (pk S , sk S ) Figure 7: Setup Phase of Phoenix as e(H S (un), H C (pw)) k S . Next, the server sends the server PRF value h S = H S (un, n S ) k S and the server nonce n S to the client, who computes the client PRF value h C = H C (un, n S ) k C locally, and encrypts the value h S · h C using an ElGamal-like encryption scheme as (g r , h r · h S · h C , z r ). If the proof passes verification, then the client is convinced that the candidate username and password satisfy h S = H S (un, n S ) k S and h C = H C (un, n S ) k C , and concludes that the enrollment record T is valid.Key Rotation Phase. Denote r := r + v. For consistency, T 2 is updated asT 2 = (T 2 · h v ) α · (T 1 · g v ) β · g γ S = g αs(r+v) g αk S S g αk C C · g β(r+v) · g γ S = g (αs+β)(r+v) g αk S +γ S g αk C C = g s r g k S S g k C C. To update T 3 , the client obtains from the server the value ζ = δ + α · η · s + β · (y + η), and computesT 3 = (T 3 · z v ) α · (T 1 · g v ) ζ = g α(x+sy)(r+v) · g (δ+α·η·s+β·(y+η))(r+v) = g ((αx+δ)+(αs+β)(y+η))(r+v) = g (x +s y )r . Since H C is modeled as a random oracle, bothH C (un * , pw * 0 , n * C ) and H C (un * , pw * 1 , n * C )can be programmed to random values independent of the passwords, which perfectly hide the bit b from the server. This property follows straightforwardly from the DL assumption, which states that finding the discrete logarithm of g 2 base g 1 is hard for random Client C(sk C , un, pw, aux) Server S(sk S , un, aux)parse pk S as (h = g s , z = g x h y ), sk C as k C parse sk S as (s, x, y, k S )if aux = then parse aux as (n S , n C ) if aux = then parse aux as (n S , n C ) To see why, note that if the enrollment recordelse n C ← {0, 1} λ else n S ← {0, 1} λ r ←$ Zq, h C ← H C (un, pw, n C ) k C h S , n S h S ← H S (un, n S ) k S return T ← (g r , h r · h S · h C , z r , n S , n C ) Figure 8: Enrollment Protocol of Phoenix Validation Protocol Client C(sk C , T, un, pw) Server S(sk S , un) parse pk S as (h, z), sk C as k C parse sk S as (s, x, y, k S ) parse T as (T 1 , T 2 , T 3 , n S , n C ) u ←$ Zq, b ← 0 c 1 c 2 c 3 ←   T 1 · g u T 2 · h u /H C (un, pw, n C ) k C T 3 · z u   (c 1 , c 2 , c 3 , n S ) if c 2 c 3 = c s 1 · H S (un, n S ) k S c x 1 (c 2 /H S (un, n S ) k S ) y then b ← Π.Vf((g, h, c 1 , c 2 , H S (un, n S )), π) π π ←$ Π.PoK{(s, k S ) : c 2 = c s 1 · H S (un, n S ) k S ∧ h = g s } return b endifT * = (T * 1 , T * 2 , T * 3 , n * S , n * C ) stores both tuples (un * b , pw * b ), b ∈ {0, 1}, then T * 2 is of the form T * 2 = h r H S (un * b , n * S ) k S H C (un * b , pw * b , n * C ) k C . Client C(sk C ) Server S(sk S )parse pk S as (h, z) parse sk S as (s, x, y, k S )parse sk C as k C α, β, γ, δ, η ←$ Zq ζ := δ + α · η · s + β · (y + η) k C ← α · k C α, β, γ, ζ k 1 ← α · k S + γ, s ← α · s + β pk C ← ⊥ x ← α · x + δ, y ← y + η sk C ← k C pk S ← (h α · g β , z α · g ζ ) τ ← (α, β, γ, ζ) sk S ← (s , x , y , k S ) return (pk C , sk C , τ ) return (pk S , sk S )Udt(τ, T, un)/ / Use the old server public key.parse pk S as (h, z)parse τ as (α, β, γ, ζ) We used the Nginx web server configured with ECDHE-ECDSA-AES128-GCM-SHA256 for TLS and uWSGI for the Python applications.parse T as (T 1 , T 2 , T 3 , n S , n C ) g S ← H S (un, n S ) v ←$ Zq T 1 ← T 1 · g v T 2 ← (T 2 · h v ) α · (T 1 · g v ) β · g γ S T 3 ← (T 3 · z v ) α · (T 1 · g v ) ζ return T ← (T 1 , T 2 , T 3 , n S , n C )Latency. If the crypto service is hosted by a different datacenter from the web application, network round-trip time quickly dominates the overall execution time of Phoenix: There is only one round-trip inherently needed for either Phoenix protocol execution and the difference between the one-datacenter and same-continent setting is almost exactly this one round-trip using keep-alive. The attack is simple yet of high practical relevance since it allows an offline password dictionary attack, which is supposedly avoided by the password hardening service.We propose the Phoenix password hardening service which greatly improves efficiency while satisfies all desirable security properties. One may also consider our primitive to be similar to other proof-of-knowledge protocols such as PSignatures [2] since both share a mechanism to verify if two commitments are committing to the same value. We will show that Phoenix is partially oblivious, hiding, binding, and forward secure, relying mainly on the DDH assumption.Note that the instantiation of Π in Figure 11 is a well-known extension of the Schnorr proofs [5], which is complete, sound, and zero-knowledge, assuming the DL assumption holds in G (implied by the DDH assumption) and the two hash functions are modeled as random oracles. H ←$ H = {H : {0, 1} * → Zq} return crs := H Π.Vf((g, h, c 1 , c 2 , g S ), π) parse π as ( ¯ h, ¯ c 1 , ¯ g S , ¯ s, ¯ k S ) c := H(g, h, c 1 , c 2 , g S , ¯ h, ¯ c 1 , ¯ g S ) b 1 := (c ¯ s 1 g ¯ k S S = ¯ c 1 · ¯ g S · c c 2 ) b 2 := (g ¯ s = ¯ h · h c ) return b := (b 1 ∧ b 2 ) Π.PoK{(s, k S ) : c 2 = c s 1 · g k S S ∧ h = g s } r 1 , r 2 ←$ Zq ¯ h := g r1 ¯ c 1 := c r1 1 ¯ g S := g r2 S c := H(g, h, c 1 , c 2 , g S , ¯ h, ¯ c 1 , ¯ g S ) ¯ s := r 1 + c · s ¯ k S := r 2 + c · k S return π := ( ¯ h, ¯ c 1 , ¯ g S , ¯ s, ¯ k S )Figure 11: Instantiation of Π sequence of hybrid experiments for b ∈ {0, 1}, each differs slightly from the previous:EXP b,0 : is identical to Obl b Π,A . We prove formally by defining a sequence of hybrid experiments, each differs slightly from the previous:H C (un, pw, n C ) k C as (g k C ) a . Furthermore, when executing C(sk C , un * , pw * , ), S(sk S , un * , ) enrl , since aux = , the challenger picks fresh client and server nonces n * C and n * S respectively randomly and programs the random oracle H S on (un * , n * S ). unless it is successful in one of the Q queries to the validation oracle on un * . It generates crs honestly and sends pp := (crs, g 1 ) to A. B maintains dictionaries D 1 and D 2 mapping (un, n S ) and (un, pw, n C ) respectively to random exponents. Phoenix is L-forward secure.Proof: We prove by showing that each pair of client and server secret keys output by the key generation algorithms can also be obtained via rotation from any old pair of secret keys, and vice versa.Consider the Rot b Π,A,L experiment. This research is based upon work supported by the German research foundation (DFG) through the collaborative research center 1223, by the German Federal Ministry of Education and Research (BMBF) through the project PROMISE, and by the state of Bavaria at the Nuremberg Campus of Technology (NCT).