In this work we investigate the problem of automating the development of adaptive chosen ciphertext attacks on systems that contain vulnerable format oracles. Unlike previous attempts, which simply automate the execution of known attacks, we consider a more challenging problem: to programmatically derive a novel attack strategy, given only a machine-readable description of the plaintext verification function and the malleability characteristics of the encryption scheme. * These authors contributed equally to the work. While the research community has long noted the threat of adaptive-chosen ciphertext attacks on malleable encryption schemes [17,18,56], these concerns gained practical salience with the discovery of padding oracle attacks on a number of standard encryption protocols [6,7,13,22,30,40,51,52,73]. This is particularly true for non-standard format oracles which require en- Figure 1: Output of a format oracle attack that our algorithms developed against a bitwise padding check oracle F bitpad (see §5.2 for a full description). We stress that our goal is not simply to automate the execution of known attacks, as in previous works [45]. This removes the expensive human element from attack development.To emphasize the ambitious nature of our problem, we summarize our motivating research question as follows:Given a machine-readable description of a format checking function F along with a description of the encryption scheme's malleation properties, can we programatically derive a chosen-ciphertext attack that allows us to efficiently decrypt arbitrary ciphertexts?Our primary requirement is that the software responsible for developing this attack should require no further assistance from human beings. Moreover, the developed attack must be efficient: ideally it should not require substantially more work (as measured by number of oracle queries and wall-clock execution time) than the equivalent attack developed through manual human optimization.To our knowledge, this work represents the first attempt to automate the discovery of novel adaptive chosen ciphertext attacks against symmetric format oracles. Beyond presenting our techniques, our practical contribution of this work is a toolset that we name Delphinium, which produces highly-efficient attacks across several such functions.Relationship to previous automated attack work. It is an open question to determine whether the experimental results in the cited works can be scaled using our techniques.Our contributions. • We show how to implement our technique practically with existing tools such as SAT and SMT solvers; and propose a number of efficiency optimizations designed to improve performance for specific encryption schemes and attack conditions. • We develop a working implementation of our techniques using "off-the-shelf" SAT/SMT packages, and provide the resulting software package (which we call Delphinium), an artifact accompanying this submission, as an open source tool for use and further development by the research community. She has access to a decryption oracle that, on input any chosen ciphertext C, returns F(Decrypt K (C)) ∈ {0, 1} for some known predicate F. The attacker may have various goals, including plaintext recovery and forgery of new ciphertexts. The function Maul Π ciph (C, S) → C takes as input a valid ciphertext and some opaque malleation instruction string S (henceforth "malleation string"), and produces a new, mauled ciphertext C . SAT solvers apply a variety of tactics to identify or rule out a satisfying assignment to a boolean constraint formula, while SMT adds a broader range of theories and tactics such as integer arithmetic and string logic. Given the result of a concrete experiment, we can then update our constraint formula using the new information, and continue the attack procedure until no further candidates can be eliminated.In the section that follows, we use M 0 , M 1 to represent the partition of messages induced by a malleation string. Our goal is to identify an assignment for (S, M 0 , M 1 ) that induces the following specific properties on M 0 , M 1 : namely, that each message in the pair, when mauled using S and then evaluated using the format checking function, results in a distinct output from F. Expressed more concretely, we require the solver to identify an assignment that satisfies the following constraint formula:G i−1 (M 0 ) = G i−1 (M 1 ) = 1 ∧ (1) ∀b ∈ {0, 1} : F(Maul plain (M b , S)) = bIf the solver is unable to derive a satisfying assignment to this formula, we conclude the attack and proceed to Step (3). Given a concrete malleation string S, we now apply the ciphertext malleation function to compute an experiment ciphertext C ← Maul ciph (C * , S), and submit C to the decryption oracle. When the oracle produces a concrete result r ∈ {0, 1}, we compute an updated constraint formula G i such that for each input M, it holds that:G i (M) ← (G i−1 (M) ∧ F(Maul plain (M, S)) = r)If possible, we can now ask the solver to simplify the formula G i by eliminating redundant constraints in the underlying representation. A key feature of the attack described above is that it is guaranteed to make progress at each round in which the solver is able to find a satisfying assignment to Equation (1). As a result, there exist worst-case attack scenarios where the algorithm requires as many queries as there are candidates for M * , making the approach completely unworkable for practical message sizes. The main limitation of our first attack strategy is that it does not seek to optimize each experiment to maximize query profitability.To address this concern, let us consider a more general description of our attack strategy, which we illustrate in Figure 2. Of course, since we do not know the value r prior to issuing a decryption oracle query, the obvious strategy is to find S such that both M 0 , M 1 are as large as possible. The result of this optimization is a greedy algorithm that will seek to eliminate the largest number of candidates with each query.Technical challenge: model count optimization. Indeed, merely counting the number of satisfying assignments to a constraint formula is known to be asymptotically harder than SAT [69,70], and practical counting algorithms solutions [14,20] tend to perform poorly when the combinatorial space is large and the satisfying assignments are sparsely distributed throughout the space, a condition that is likely in our setting. One powerful class of approximate counting techniques, inspired by the theoretical work of Valiant and Vazirani [71] and Stockmeyer [67], uses a SAT oracle as follows: given a constraint formula F over some bitvector T , add to F a series of s random parity constraints, each computed over the bits of T . Subsequently, researchers in the model counting community showed that with some refinement, these approximate counting strategies can be used to approximate Max#SAT [35], although with an efficiency that is substantially below what we require for an efficient attack.To apply this technique efficiently to our attack, we develop a custom count-optimization procedure, and apply it to the attack strategy given in the previous section. In our approach, this falsenegative will cause the algorithm to reduce the size of s, potentially resulting in the selection of a less-profitable experiment S. Following Gomes et al. [37], we are able to substantially improve our certainty by conducting t trials within each query, accepting iff at least ( 1 2 + δ)t trials are satisfied, where δ is an adjustable tolerance parameter.Putting it all together. Using our techniques we were able to re-discover both well known and entirely novel chosen ciphertext attacks, all at a query efficiency nearly identical to the (optimal in expectation) human-implemented attacks. We now provide definitions for these terms.Definition 1 (Symmetric encryption) A symmetric encryption scheme Π is a tuple of algorithms (KeyGen, Encrypt, Decrypt) where KeyGen(1 λ ) generates a key, the probabilistic algorithm Encrypt K (M) encrypts a plaintext M under key K to produce a ciphertext C, and the deterministic algorithm Decrypt K (C) decrypts C to produce a plaintext or the distinguished error symbol ⊥. The first takes as input a ciphertext along with an opaque data structure that we refer to as a malleation instruction string, and outputs a mauled ciphertext. In practice, this is implemented using SMT with a SAT solver as a back-end. The response from this call provides one of three possible results: (1) sat, as well as a concrete satisfying solution (A 1 . . . , A N ), (2) the distinguished response unsat, or (3) the error unknown.Model counting and Max#SAT. Specifically, we define our main attack algorithm in terms of a generic Max#SAT oracle that has the following interface:Max#SAT(φ, X,Y ) → X Our attacks assume a decryption oracle that, on input a ciphertext C, computes and returns F(Decrypt K (C)). Requiring format checking functions to be usable within SAT/SMT solvers raises additional implementation considerations. At each iteration, it derives a concrete malleation string S using the Max#SAT oracle in order to find an assignment that maximizes the number of solutions to the abstract bitvector M 0 M 1 . 7 Theorem 3.1 Given an exact Max#SAT oracle, Algorithm 1 maximizes in expectation the number of candidate plaintext messages ruled out at each iteration.A proof of Theorem 3.1 appears in the full version of this paper [15]. It is hypothetically possible to modify the algorithm, allowing it to reason over multiple oracle queries simultaneously (in fact, Phan et al. discuss such a generalization in their side channel work [58]). In practice, this will likely be realized with a probably approximately correct instantiation, causing the resulting attack to be a probably approximately greedy attack. First, to achieve the discussed bounds requires parameter selections which induce infeasible queries to the underlying SAT solver. Even conducting a single approximate count of solutions to the constraint systems in our experiments could take hours to days, and such counts might occur several times in a single execution of A more efficient realization. downwards) until it has found the maximal value of s that produces a satisfying assignment, or else is unable to find an assignment even at s = 0. Unlike Fremont et al. (at least, when implemented at full parameters) our algorithm does not constitute a sound realization of a Max#SAT solver. Input: Machine-readable description of F, Maul plain ; target ciphertext C * ; initial constraints G 0 ; Output: M * or a model of the remaining plaintext candidates Procedure:i ← 1; do Define φ(S, M 0 M 1 ) as G i−1 (M 0 ) = 1 ∧ G i−1 (M 1 ) = 1 ∧ F(Maul plain (M 0 , S)) = 0 ∧ F(Maul plain (M 1 , S)) = 1 ; S ← Max#SAT (φ, S, M 0 M 1 ); if S = ⊥ then r ← O dec (Maul ciph (C * , S)); Define G i (M) as G i−1 (M) ∧ (F(Maul plain (M, S)) = r) ; i ← i + 1; while S = ⊥; return SolveForPlaintext(G i ); Input: φ a constraint system over abstract bitvectors S, M 0 M 1 ; n the maximum length of (each of) M 0 , M 1 ; m the maximum length of S; t number of trials; δ fraction of trials that must succeed Output: S ∈ {0, 1} m Procedure: (b continue , s, Z) ← AdjustSize(FALSE, n, ⊥, ε); // define t symbolic copies of the abstract bitvectors M 0 ,M 1 , and a new constraint system φ t{M 1,0 , . . . , M t,0 } ← M 0 ; {M 1,1 , . . . , M t,1 } ← M 1 ; Define φ t (S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 }) as φ(S, M 1,0 M 1,1 ) ∧ · · · ∧ φ(S, M t,0 M t,1 ); while b continue do // Construct 2t s-bit parity constraints for i ← 1 to t do H i,0 ← ParityConstraint (n, s); H i,1 ← ParityConstraint (n, s) // Query the solver S ← SATSolve{(S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 }) : ∃R 0 ⊆ [1,t] : |R 0 | ≥ (0.5 + δ)t, ∀ j ∈ R 0 : H j,0 (M j,0 ) = 1 ∧ ∃R 1 ⊆ [1,t] : |R 1 | ≥ (0.5 + δ)t, ∀ j ∈ R 1 : H j,1 (M j,1 ) = 1 ∧ φ t (S, {M 1,0 , . . . , M t,0 }, {M 1,1 , . . . , M t,1 })}; if S == unsat then b success = FALSE; (b continue , s, Z) ← AdjustSize(b success , n, s, Z); return S We now describe our prototype implementation, which we call Delphinium. Our implementation supports multiple SMT solver frameworks (STP [1] and Z3 [49]) via a custom compatibility layer that we developed for our tool. 8 Target interface (shim). It is designed as a user-supplied module in recognition of the fact that this portion will need to be customized for specific target systems and communication channels.As part of our prototype implementation, we provide working examples for each of these modules, as well as a test harness to evaluate attacks locally. Each parity constraint comprises an average of n 2 exclusiveORs (where n is the maximum length of M * ), resulting in a complexity increase of tens to hundreds of gates in our SAT queries. Because SAT/SMT queries are computationally expensive, we evaluate a few strategies for implementing AdjustSize which minimize time spent solving. These include simple stream ciphers, stream ciphers that support truncation (from either the left or the right side), and CBC mode encryption. Since the block C i is given directly to a block cipher, any implementation must account for the the fact that modification of the block C i creates an unpredictable effect on the output P i , effectively randomizing it via the block cipher.For a solver to reason over such an effect on the plaintext output, we would need to include constraint clauses corresponding to encryption and decryption, i.e. boolean operations implementing symmetric schemes like AES. With CBC mode decryption, manipulating a preceding ciphertext block C i−1 produces a predictable exclusive-OR in the plaintext block P i . This includes the attack orchestrator, example format check implementations, the test harness, and our generic solver Python API which allows for modular swapping of backing SMT solvers, with implementations for Z3 and STP provided. It is possible that circuit synthesis algorithms designed to decrease circuit size (used for applications such as FPGA synthesis) or other logic optimizers could reduce circuit complexity, but we leave exploring this to future work.We additionally provide a translation tool from the output format of CMBC-GC [34] to Python (entirely comprised of circuit operations) to enable use of the Python front-end to Delphinium. 11 Several additional tests were run a 72-core Intel Xeon E5 CPU with 500GB of memory running on Ubuntu 16.04, and a 96-core Intel Xeon E7 CPU with 1TB of memory running Ubuntu 18.04. For each experimental run, we collected statistics including the total number of decryption oracle queries performed; the wall-clock time required to construct each query; the number of plaintext bits recovered following each query; and the value of s used to construct a given malleation string. This padding is similar to the standard TLS CBC-mode padding [7] considered by Vaudenay [73]. As points of comparison, attacks with t = 3 resulted in a similar number of queries (modulo expected variability over different randomly sampled messages) but took roughly 2 to 3 times as long to complete, and attacks with t = 1 reached over 5000 queries having only discovered half of the target plaintext message.Bitwise Padding. This contrived scheme encodes the bit length of the padding P into the rightmost log 2 (n) bits of the plaintext string, and then places up to P padding bits directly to the left of this length field, with each padding bit set to 1. The format function F crc8 computes the CRC over the message bytes, and verifies that the CRC in the message matches the computed CRC. To evaluate how truncation affects the ability of Delphinium to find attacks, we conducted a second attack using the function F crc8 , this time using an implementation of AES-CTR supporting truncation. This illustrates the utility of Delphinium since such variation's effect on the underlying scheme does not need to be fully understood by a user, outside of encoding the format's basic operation.Thumb Embedded ISA. To exercise Delphinium against a novel format oracle of notably different structure than those traditionally analyzed (such as padding), we implemented a minimal instruction interpreter for the 16-bit Thumb instruction set architecture (ISA), defined as part of the ARM specification [3], capable of emitting illegal instruction signals. This initial result serves both as validation of Delphinium and as creation of an avenue for future work, including the development of a model for a more complex but widespread ISA such as 32-bit ARM [3], perhaps exploiting additional signals such as segmentation faults or side channels in order to capture the capabilities of a sophisticated adversary.S2N with Exclusive-OR and Truncation. To evaluate a realistic attack on a practical format function, we developed a format checking function for the Amazon s2n [2] TLS session ticket format. This malleation function supports an arbitrary number of blocks, and admits truncation of plaintexts from either side of the plaintext. 15 In practice, truncation in CBC simply removes blocks from either end of the ciphertext. Figure 4 gives a brief snapshot of this pattern of malleations discovered by Delphinium. CCA-2 and format oracle attacks. Soos et al. [66] developed CryptoMiniSAT to recover state from weak stream ciphers, an application also considered in [27]. Our ideas may also be extensible in many ways: for example, developing automated attacks on protocols with side-channel leakage; on public-key encryption; and on "leaky" searchable encryption schemes, e.g., [38].