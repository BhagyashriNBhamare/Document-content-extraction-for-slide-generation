We discuss concrete examples of attacks which can be prevented by WPSE on OAuth 2.0 and SAML 2.0, including a novel attack on the Google implementation of SAML 2.0 which we discovered by formalizing the protocol specification in WPSE. Popular examples of web protocols include OAuth 2.0, OpenID Connect, SAML 2.0 and Shibboleth, which are routinely used by millions of users to access security-sensitive functionalities on their personal accounts.Unfortunately, designing and implementing web protocols is a particular error-prone task even for security experts, as witnessed by the large number of vulnerabilities reported in the literature [43,6,5,50,28,27,48,46]. For example, in the context of OAuth 2.0, Bansal et al. [6] discussed token redirection attacks enabled by the presence of open redirectors, while Fett et al. [19] presented state leak attacks enabled by the communication of the Referer header; these attacks are not apparent from the protocol specification alone, but come from the subtleties of the browser behaviour.Major service providers try to aid software developers to correctly integrate web protocols in their websites by means of JavaScript APIs; however, web developers are not forced to use them, can still use them incorrectly [47], and the APIs themselves do not necessarily implement the best security practices [43]. we propose the Web Protocol Security Enforcer, or WPSE for short, a browser-side security monitor designed to enforce the aforementioned security properties, which we implement as a publicly available Google Chrome extension;4. In our analysis, we identified security flaws in 55 websites (61.1%), including new critical vulnerabilities caused by tracking libraries such as Facebook Pixel, all of which fixable by WPSE. to show the generality of our approach, we also considered SAML 2.0, a popular web authorization protocol: while formalizing its specification, we found a new attack on the Google implementation of SAML 2.0 that has been awarded a bug bounty according to the Google Vulnerability Reward Program. This request contains the RP's identity at IdP, the URI that IdP should redirect to after successful login and an optional state parameter for CSRF protection that should be bound to U's state;3 IdP answers to the authorization request with a login form and the user provides her credentials; IdP redirects U to the URI of RP specified at step 2 , including the previously received state parameter and an authorization code; 2 The OAuth 2.0 specification distinguishes between resource servers and authorization servers instead of considering one identity provider that stores the user's identity as well as its resources [25], but it is common practice to unify resource and authorization servers as one party [19,43,27]. RP makes a request to IdP with the authorization code, including its identity, the redirect URI and optionally a shared secret with the IdP; IdP answers with an access token to RP;7 RP makes a request for the user's resource to IdP, including the access token;8 IdP answers RP with the user's resource at IdP.The implicit mode differs from the authorization code mode in steps 4 -6 . When OAuth is used to implement SSO and RP does not provide the state parameter in its authorization request to IdP at step 2 , it is possible to force the honest user's browser to authenticate as the attacker. A web attacker A initiates SSO at RP with an identity provider IdP, performs steps 1 -3 of the protocol and learns a valid authorization code for her session. Protocol participants are typically expected to perform a number of runtime checks to prove the integrity of the messages they receive and ensure the integrity of the messages they send, but the browser cannot perform these checks unless they are explicitly carried out in a JavaScript implementation of the web protocol.Example in OAuth 2.0. In this case, an attacker controlling a malicious identity provider AIdP can confuse the RP about which provider is being used and force the user's browser to login as the attacker.To this end, the attacker starts a SSO login at RP with an honest identity provider HIdP to obtain a valid authorization code for her account. The Web Protocol Security Enforcer (WPSE) is the first browser-side security monitor addressing the peculiar challenges of web protocols. 3 We illustrate WPSE on the authorization code mode of OAuth 2.0, where Google is used as identity provider and the state parameter is not used (since it is not mandatory at Google). Afterwards, the automaton moves back to the initial state and a new protocol run can start.The edges of the automaton are labeled with message patterns, describing the expected shape of the protocol messages at each state. We represent HTTP(S) requests as ea, where e is the remote endpoint to which the message is sent and a is a list of parameters, while HTTP(S) responses are noted e(h), where e is the remote endpoint from which the message is received and h is a list of headers. Also, the same protocol may be run on different websites, which need to fetch different resources as part of their protocol-unrelated functionalities, and we would like to ensure that the same protocol specification can be enforced uniformly on all these websites. To incorporate secrecy and integrity policies in the automaton, we allow for binding parts of message patternsinit start auth access end φ 1 ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 2 :: π S ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 3 ∧ π I ¬(φ 1 ∨ φ 2 ∨ φ 3 ) φ 1 Gresponse type:code, redirect uri:^( origin (https? *) uri2 code:([^\s]{40,})π S authcode → {https://accounts.google.com, origin} π I uri1 = uri2 to identifiers. 5 The scope of an identifier includes the state where it is first introduced and all its successor states, where the notion of successor is induced by the tree structure of the automaton. For instance, the scope of the identifier origin introduced in φ 1 includes the states auth, access, end.The secrecy policy defines which parts of the HTTP(S) responses included in the protocol specification must be confidential among a set of web origins. Since the substitution of confidential message components with placeholders changes the content of the messages, potentially introducing deviations with respect to the transition labels, the automaton processes HTTP(S) responses before stripping confidential values and HTTP(S) requests after replacing the placeholders with the original values. if WPSE is enforcing a protocol P i , it must block any message which may be part of another protocol P j , otherwise it would be trivial to sidestep the security policy of P i by first making the browser process the first message of P j . Both problems are solved by replacing the protocol specifications P 1 , . . . , P n with a single specification P with n branches, one for each P i . Notice that the semantics of WPSE depends on the order of P 1 , . . . , P n , due to the way we enforce determinism on the compiled automaton: if P i starts with a request to u including two parameters a and b, while P j starts with a request to u including just the parameter a, then P i should occur before P j to ensure it is actually taken into account. As a result, our finite state automata are significantly simpler than the request graphs proposed by Guha et al. [24] to represent legitimate browser behaviors (from the server perspective). The current design of WPSE only supports a limited use of secrets by browser-side scripts, i.e., scripts can only forward secrets unchanged to the web origins entitled to learn them. We empirically show that this is enough to support existing protocols like OAuth 2.0 and SAML, but other protocols may require more flexibility.Dynamic information flow control deals with the problem of letting programs compute over secret values while avoiding confidentiality breaches and it has been applied in the context of web browsers [21,26,8,36,7]. The security of both protocols has already been studied in depth, so they are an excellent benchmark to assess the effectiveness of WPSE: we refer to [6,19,43] for security analyses of OAuth 2.0 and to [3,4] for research studies on SAML. Protocol flow deviation Session swapping [43] Social login CSRF on stateless clients [6] IdP mix-up attack (web attacker) [19] Secrecy violation Unauthorized login by authentication code redirection [6] Resource theft by access token redirection [6] 307 redirect attack [19] State leak attack [19] Integrity violation Cross social-network request forgery [6] Na¨ıveNa¨ıve RP session integrity attack [19] Table 1: Overview of the attacks against OAuth 2.0. WPSE can prevent this class of attacks since the secrecy policy allows one to specify the origins that are entitled to receive a secret.We illustrate how the monitor prevents these attacks in case of the state leak attack discussed in Section 2.3, focusing on the authorization code. In the attack, the authorization code is leaked via the Referer header of the request fetching a resource from the attacker website which is embedded in the page located at the redirect URI of RP (step 4 of the protocol). WPSE can prevent these attacks by enforcing browser-side integrity checks.Consider the na¨ıvena¨ıve RP session integrity attack presented in Section 2.4. In this attack, the malicious identity provider AIdP redirects the user's browser to the redirect URI of the honest identity provider HIdP at RP during step 4 of the protocol. SAML is based on XML messages called assertions and defines different profiles to account for a variety of use cases and , C requests from SP the resource located at URI; in 2 the SP redirects the browser to the IdP sending an AuthnRequest XML message in deflated, base64-encoded form and a RelayState parameter; C provides his credentials to the IdP in step 3 where they are verified; in step 4 the IdP causes the browser to issue a POST request to the Assertion Consumer Service at the SP containing the base64-encoded SamlResponse and the RelayState parameters; in 5 the SP processes the response, creates a security context at the service provider and redirects C to the target resource at URI; given that a security context is in place, the SP provider returns the resource to C.The RelayState is a mechanism for preserving some state information at the SP, such as the resource URI requested by the user [20]. The malicious service provider replies to C by providing a redirection address containing a different resource URI, thus causing the browser to send URI i instead of instead of URI as the value of RelayState at steps 2 , 4 . Indeed, we managed to mount an attack against Google that allows a web attacker to authenticate any user on Google's suite applications under the attacker's account, with effects similar to a Login CSRF attack. We have implemented the attack by constructing a malicious webpage that silently performs a login on Google's suite applications using one of our personal accounts. WPSE identifies the outgoing request to the IdP as a protocol flow deviation, thereby preventing the attack. An example of such an attack against OAuth 2.0 is the automatic login CSRF attack presented in [6], which exploits the lack of CSRF protection on the login form of the relying party to force an authentication to the identity provider. Another example is the DuoSec vulnerability found on several SAML implementations [30] that exploits a bug in the XML libraries used by SPs to parse SAML messages. Our analysis is not meant to provide a comprehensive coverage of the deployment of OAuth 2.0 on the web, but just to identify a few popular identity providers and their relying parties to carry out a first experimental evaluation of WPSE.We started from a comprehensive list of OAuth 2.0 identity providers 6 and we collected for each of them the list of the HTTP(S) endpoints used in their implementation of the protocol. Inspired by [45], our crawler looks for login pages on websites to find syntactic occurrences of these endpoints: after accessing a homepage, the crawler extracts a list of (at most) 10 links which may likely point to a login page, using a simple heuristic. By running our crawler on the Alexa 100k top websites, we found that Facebook (1,666 websites), Google (1,071 websites) and VK (403 websites) are the most popular identity providers in the wild.We then developed a faithful XML representation of the OAuth 2.0 implementations available at the selected identity providers. We can detect these cases by checking which protocol specification is enforced by WPSE and by making the state parameter secret, so that all the values bound to it are collected by WPSE when they are substituted by the placeholders used to enforce the secrecy policy.We observed that our extension prevented the leakage of sensitive data on 4 different relying parties. Interestingly, we found that the security violation exposed by the tool are in all cases due to the presence of tracking or advertisements libraries such as Facebook Pixel, 7 Google AdSense, 8 Heap 9 and others. 10 For what concerns the second class of vulnerabilities, 55 out of 90 websites have been found affected by the lack or misuse of the state parameter. For instance, according to the Google documentation, 11 the state parameter can be used "for several purposes, such as directing the user to the correct resource in your application, sending nonces, and mitigating cross-site request forgery": we believe that this description is too vague and opens the door to misunderstandings. We were able to navigate 81 websites flawlessly, but we also found 9 websites where we did not manage to successfully complete the protocol run.In all the cases, the reason for the compatibility issues was the same, i.e., the presence of an HTTP(S) request with a parameter called code after the execution of the protocol run. We manually investigated all these cases: 2 of them were related to the use of the Gigya social login provider, which offers a unified access interface to many identity providers including Facebook and Google; the other 7, instead, were due to a second exchange of the authorization code at the end of the protocol run. Here we provide an intuitive description of the formal result, referring the interested reader to [15] for a complete account.The formal result states that given a web protocol that is proven secure for a set of network participants and an uncorrupted client, by our monitoring approach we can achieve the same security guarantees given a corrupted client (e.g., due to XSS attacks). Intuitively, our theorem says that security carries over to a setting (S new ) where the browser-side application is totally under the control of the attacker (e.g., because of XSS attacks or a simple bug in the code) but the communication between the browser and the other protocol parties is mediated by our monitor.Specifically, S orig includes a browser B and an uncompromised application App, which exchange messages via private (green) communication channels ba in , ba out . Second, the theorem demonstrates that enforcing the three security properties identified in Section 2 does indeed suffice to protect web protocols from a large class of bugs and vulnerabilities on the browser side: (H2) captures the compliance with the intended protocol flow as well as data integrity, while (H3) characterizes the secrecy of messages.Finally, the three hypotheses of the theorem are usually extremely easy to check. The paper presented a model of web browsers, based on a formalism reminiscent of input/output automata, and applied it to the analysis of passwordbased authentication, a key ingredient of most browserbased protocols. Protocol analysis techniques are useful to verify the security of protocols, but they assume websites are correctly implemented and do not depart from the specification, hence many security researchers performed empirical security assessments of existing web protocol implementations, finding dangerous attacks in the wild. The focus of their paper, however, is not on web protocols and is only limited to JavaScript, because input/output operations which are not JavaScript-initiated are not exposed to their security monitor.Guha et al. also used finite state automata to encode web security policies [24]. We presented WPSE, the first browser-side security monitor designed to address the security challenges of web protocols, and we showed that the security policies enforceable by WPSE suffice to prevent a large number of real-world attacks. In the end, we conclude that the browser-side security monitoring of web protocols is both useful for security and feasible in practice.As to future work, we observe that our current assessment of WPSE in the wild only covers two specific classes of vulnerabilities, which can be discovered just by navigating the tested websites: extending the analysis to cover active attacks (in an ethical manner) is an interesting direction to get a better picture of the current state of the OAuth 2.0 deployment. The syntax ${id} can be used to refer to the value bound to the identifier id.Security policies are defined within <Secrecy> and <Integrity> tags.