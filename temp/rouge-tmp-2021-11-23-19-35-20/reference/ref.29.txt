ARM TrustZone, a security extension that provides a secure world, a trusted execution environment (TEE), to run security-sensitive code, has been widely adopted in mobile platforms. vTZ leverages the idea of separating function-ality from protection by maintaining a secure co-running VM to serve as a guest TEE, while using the hardware TrustZone to enforce strong isolation among guest TEEs and the untrusted hypervisor. Generally, TrustZone provides hardware-based access control of hardware resources, by enabling a processor to run in two asymmetrically-isolated execution environments: a secure world, which is a trusted execution environment (TEE), can be configured to access all resources of a normal world but not vice versa. For example, in ARMv7 architecture, a special CPU mode called hyp mode is added for hosting a hypervisor; two-stage address translation together with System Memory Management Unit (SMMU) are also provided to support address translation and secure DMA for virtualization. Hence, once a hypervisor is compromised, all guest TEEs (in the following paper, the guest TEE presents the virtual secure world for each guest and the secure world presents the hardware secure world) are also under attackers' control.To address these issues, this paper introduces vTZ that provides transparent virtualization of TrustZone while still maintaining strong isolation among guest TEEs with minimal software TCB. Based on the interposition, vTZ further provides multiple Constrained Isolated Execution Environments (CIEEs) that protect self-contained code snippets running inside them by leveraging TrustZone-enabled sameprivilege isolation [30,21,31] such that the hypervisor cannot tamper with the CIEE or break their execution integrity. Building atop vTZ, we also provide various VM management operations including VM suspending and resuming while preserving the security properties.We have implemented vTZ based on Xen-ARM 4.8 on both LeMaker Hikey ARMv8 development board as well as a Samsung's Exynos Cortex development board, and run two common TEE-kernels: seL4 [40,39] and OP-TEE [6] about 3% compared with Xen. TrustZone [20] is a hardware security mechanism since ARMv6 architecture, which includes security extensions to ARM System-On-Chip (SoC) covering the processor, memory and peripherals. Typically, a special instruction called "secure monitor call" (smc) is used for worlds switching.TrustZone divides all memory into two parts: normal part and secure part, which are distributed into normal world and secure world accordingly. Besides, the memory partition can be dynamically controlled by the secure world, which gives secure services running in the secure world the ability to dynamically protect certain memory.For I/O devices and interrupts, TrustZone also splits them into two worlds. It is used in the hyp mode (using a hyp-mode translation table) and the secure world (using a stage-1 translation table). TrustZone is getting increasing popularity and has been used in various scenarios to protect security-critical data and enhance the security of the normal world.Secure Storage and Credential Protection: The isolation property of TrustZone makes it an ideal choice to store user's secret data, e.g., private keys, passwords, credit card numbers, etc. For example, a web server could put the private key and all the code accessing it into the secure world [55] so that the private key will never be accessed by the normal world, which can effectively defend against memory exposure attacks such as Heartbleed attack [16] or buffer overread attack [58]. All these systems and technologies can be applied to the server platform in a seamless way.Enforcing REE Security: TEE can be used to enhance the security of REE because the secure world has higher privilege than the normal world. A new TA needs to be signed by the root key before running in the TEE of corresponding device.Since trustZone is not designed to be virtualizable, currently on a virtualized environment, e.g., cloud, all VMs on the same host have to share one TEE-kernel. These motivate us to design vTZ to virtualize TrustZone to be seamlessly used by multiple virtual machines, while preserving the security properties offered by the hardwarebased TrustZone, so that each virtual machine can run its own TEE-kernel in a secure and isolated environment. To enforce these properties, vTZ needs to address the following challenges:â€¢ Challenge 1: A compromised hypervisor may violate the booting sequence or booting a compromised or even a malicious guest TEE-kernel. Like the hypervisor in the normal world, the TEE hypervisor is in charge of multiplexing the secure world and offers a virtualized interface of TrustZone to the normal world. A TEE hypervisor needs to virtualize a full-featured execution environment as the physical TrustZone provides, which requires nontrivial implementation complexity due to the lack of virtualization support in the secure world. Otherwise, a malicious REE hypervisor may let one guest VM in the normal world switch to another guest's TEE.The second issue is the poor compatibility with existing TEE-kernels. An smc (secure monitor call) will first be trapped in the REE hypervisor and then transferred to the TEE hypervisor, which in turn transfer the call to the designated guest TEE. This design fully simulates multiple guest TEEs by using the hypervisor running in the normal world to virtualize the guest TEEs along with the normal world guest VMs and to handle their interaction, as shown in Figure 2(b). vTZ also assumes that the whole system is loaded securely, including both the secure world's and the normal world's code, which is ensured by secure boot technology of TrustZone. We do not consider side channel attacks or physical attacks to the memory and SoC, like cold boot or bus snooping. To provide efficient memory protection, vTZ uses Secured Memory Mapping (SMM), a module in the secure world, to control all the stage-2 translation tables as well as hypervisor's translation table (Section 4.1). Based on that, vTZ can set security policies to, e.g., ensure that any of the guest TEE's secure memory will never be mapped to other VMs or the hypervisor, and the hypervisor cannot map any new executable pages in hyp mode after booting up.To protect the CPU states during context switching and guest TEE's execution, Secured World Switching (SWS) hooks and checks all the switches in the secure world, which alternatively saves and restores guest CPU states for each guest TEE (Section 4.3). It only provides one interface to some specific CIEEs which contain virtual partitioning controller emulator (introduced in Section 5.3) to configure security policies.Exclusive Control of Memory Mapping: To ensure that only the SMM can load or change memory mapping, vTZ enforces that the hypervisor does not contain any instruction to do so. There are three ways for a hypervisor to modify memory mapping: changing the base register to a new translation table 2 , changing the entries of translation table, or disabling the address translation 3 . The corresponding operations are replaced to invocations to SMM.SMM maps the code pages of the hypervisor as readonly so that the code will not be changed at runtime. CFLock can "lock" the control flow when any exception happens, which is used to ensure the non-bypassability of the SWS and CIEEs (described in following sections). The ARM architecture uses a special register to point to the base address of exception table, and each table entry will correspond to one exception handler. Secured World Switching (SWS) is a module running in the secure world enforcing the security properties of guest's world switching. Hence, CFLock can be used to enforce that the control flow will eventually be transferred to SWS.If the hypervisor needs to switch to a guest, it must change the current exception level from the hyp mode to kernel mode. There are three methods for the hypervisor to do so: by executing eret instruction, by executing movs pc, lr instruction, or directly setting the exception level (e.g., by executing CPS instruction); In order to enforce a single exit point, SWS requires the hypervisor to remove all these instructions and replace them with corresponding invocations to SWS. The code pages of CIEE are mapped as read-only by SMM to ensure the code integrity. After the first smc (on a different executable page) trapping to the secure world, vTZ will check the trapping address stored in LR mon 4 and to identify the specific CIEE by the address. There is no need for the hypervisor to access CIEE's code, secure objects or CIEE's stack page.To further enforce the control flow integrity, protecting the code page alone is not enough. The former is only mapped when CIEE is executed, and the latter is mapped as read-only in the hyp mode and can only be modified by invoking the secured modules. For example, the CIEE for VM suspending (Section 5.4) could directly return the encrypted snapshot of a V M s back to the hypervisor.Privilege Isolation: CIEE is not in the TCB of vTZ. This is enforced by SMM which ensures one CIEE's own secure object and stack page will never be mapped into other's address space. 2) The bootloader initializes the secure world and loads a TEE-kernel to memory.3) The TEE-kernel does a full initialization of the secure world, including the secure world translation table, vector table and so on. The hypervisor initializes the data structure and allocates memory for both guest V M n and its corresponding V M s , loads the TEE-kernel image and guest normal world OS image to the memory, respectively. Since SWS controls all the world switches between the hyp mode and a VM, it can ensure that only registered VM can be executed. During registration, SWS first asks the Secured Memory Mapping (SMM) module to remove all the mapping of memory pages allocated to the guest from the hypervisor's translation table and checks the integrity of a guest's TEE-kernel. â€¢ P-2.3: Protect S/W CPU states.SWS intercepts all the switching between a guest VM and the hypervisor, A switching includes saving states of the current VM, finding the next VM, and restoring its states. Three different resource partitions are provided, together with three different controllers which are used to configure the partition:â€¢ Memory partitioning, which is configured by TrustZone Address Space Controller (TZASC). A secure interrupt must be injected to the secure world and will lead to a world switching if it happens in the normal world. To support these requirements, vTZ provides the same semantic of resource partitioning as a real TrustZone, which includes the configuration of partitioning and the enforcement of partitioning.Virtualizing Partitioning Controllers: Following two properties should be satisfied:â€¢ P-3.2: Only S/W can configure memory partition. This property is enforced by the SMM module through the following policy: any guest's secure memory region can only be mapped in its V M s but not any other VMs or the hypervisor.Secure Device Partitioning: In secure device part, vTZ must enforce the following two properties:â€¢ P-4.2: N/W cannot access secure peripherals. The entire process is also protected by CFLock, so that all the operations on virtual secure device will eventually be handled by the emulator in CIEE, and P-4.3 is satisfied.Secure Interrupt Partitioning: For interrupts, vTZ needs to ensure the following property:â€¢ P-4.1: Secure interrupts must be injected into S/W. The suspend CIEE will first invoke the SWS to encrypt and hash guest's vTZ related data, including CPU states, memory partition, interrupt partition, device partition, etc. On the Hikey board, each guest, as well as Dom0, has one virtual CPU and each virtual CPU is pinned on one physical CPU. Same as world switching, secure configuration operations happen rarely, so the overhead will have limited effect on the whole system.Run-Time Integrity Checker: Besides virtualizing secure devices like vTZASC, vTZPC and virtual GIC (virtual devices used to perform resource partition), we also virtualize and use Run-Time Integrity Checker (RTIC) to evaluate the overhead of vTZ's virtual secure devices. Single Guest: We test four real applications (ccrypt, mcrypt, GnuPG and GoHttp) and compare them with original Xen on ARMv7 and ARMv8 platform. The overhead of virtualization becomes larger compared with the single case because that the GoHttp server transfers a big file (20 MB) for each request. We also evaluate two widely used server applications, MongoDB [5] and Apache [3] on Hikey board. Since SWS is responsible for saving and restoring each VM's CPU states and synchronizing general registers between guest's two worlds, it will check and refuse the tampering.Memory Protection: A compromised hypervisor may want to map one guest's secure memory to a compromised VM or the hypervisor itself. Secured Memory Mapping (SMM) prevents these malicious behaviors by controlling and checking all the mapping to the physical address and ensuring that one guest's secure memory can only be mapped to its guest TEE.vTZ allows a guest TEE to dynamically repartition its memory through a virtual memory configuration device, which invokes SMM to update the security policy. Meanwhile, the SMM ensures that only the code of the hypervisor can be mapped as executable in the hyp mode, thus return-to-guest attack also can be prevented.DMA Attack: An attacker may try to access guest secure memory or inject code into hypervisor's memory by leveraging Direct Memory Access (DMA). After exclusively controlling the SMMU, we can ensure that all DMAs cannot access guest's secure memory, hypervisor's text section or CIEE's memory.Debugging Attack: The attacker may also want to bypass the SWS or CFLock by setting debug checkpoint on the smc instruction. First, SWS can identify current guest TEE and SMM will forbid a CIEE to access any data belonging to other guests. vTZ paves the way for the use of TrustZone guarantees in similar environments.Virtualization of Security Hardware: Similar as TrustZone, Trusted Platform Module (TPM) is a hardware extension for security. Meanwhile, these technologies focus more on memory isolation while TrustZone can also support peripheral partitioning (e.g., random number generator, trust timer, secure co-processors, etc.) Further, currently on ARM platform there is no extension like SGX or SME/SEV while TrustZone has already been widely deployed and has various applications.Software-based TEE: There are many types of TEE that are based on hypervisor [68,56,26,67,44,41,46], or based on Linux kernel [31,22,27], or based on compiler [30,29], to name a few. vTZ uses a few modules running in the secure world to securely interpose memory mapping, world switching and device accesses. We thank the anonymous reviewers for their insightful comments.