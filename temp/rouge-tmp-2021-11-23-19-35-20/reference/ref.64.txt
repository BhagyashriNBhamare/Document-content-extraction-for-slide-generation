To determine an unavoidable condition one must rule out any feasible variant attack where this condition might not be necessary, otherwise adversaries aware of counter-cryptanalysis could easily bypass this improved collision detection with a carefully chosen variant attack. Industry's previous de facto choices MD5 and SHA-1 are both based on the Merkle-Damgård construction [18,6] that iterates a compression function that updates a fixed-size internal state called the chaining value (CV) with fixed-size pieces of the input message.In 2004, MD5 was completely broken and real collisions were presented by Wang et al.[33, 35]. With real collisions for full SHA-1 out of reach at that time, there were efforts at producing collisions for reduced versions of SHA-1: 64 steps [3] (with a cost of 2 35 SHA-1 calls), 70 steps [2] (cost 2 44 SHA-1), 73 steps [8] (cost 2 50.7 SHA-1), the last being 75 steps [9] (cost 2 57.7 SHA-1) in 2011. Our improved implementation is also being used by Google Drive, Gmail and Microsoft OneDrive.Based on the latest results for the complexity of finding a SHA-1 collision, the projected cost of such an attack ranges from US$ 75 K and US$ 120 K by renting low-cost computing resources on Amazon EC2 [22,26], which is significantly lower than Schneier's 2012 estimates. It thus remains in widespread use across the software industry for, e.g., digital signatures on software, documents, and many other applications, perhaps most notably in the widely used Git versioning system.It is very likely that SHA-1 is heading towards a similar fate as MD5, risking various security issues for many years to come. As one potentially scenario, consider an attacker that has committed one file of a colliding pair 2 to a Git repository under his control, in which case he could then selectively deliver either contents to targeted users, without the users noticing by looking at Git hashes or verifying signatures on the repository. Extensive studies for message block differences that allow high-probability differential paths for both MD5 and SHA-1 strongly confirm these properties.Collision detection detects near-collision attacks against MD5's or SHA-1's compression function for a given message by 'jumping' from the current compression function evaluation CV out = Compress(CV in , B) to a presumed related compression function evaluation CV out = Compress(CV in , B ). Otherwise, adversaries aware of counter-cryptanalysis could easily bypass this improved collision detection with a carefully chosen variant attack.We provide a formal framework of unavoidable conditions for collision attacks on MD5-like compression functions that can be used to show that indeed conditions are unavoidable, and we show how they can be used to speed up collision detection.Furthermore, we present a conjecture that SHA-1 collision attacks based on a disturbance vector may not deviate from the prescribed local collisions for steps 35 up to 65 to remain feasible. Unavoidable bit conditions allow a significant improvement to collision detection by very quickly checking the unavoidable bit conditions per DV and only performing a recompression when all unavoidable bit conditions for that DV are satisfied.We have implemented the improved SHA-1 collision detection using unavoidable conditions which checks 32 DVs (twice as many as previous work). We more formally define attack classes and such unavoidable conditions in a framework that we use to actually find unavoidable conditions for SHA-1 by showing these are necessary for all feasible attacks within an attack class.Our attack class definition in Thm. For N, M ∈ N + , let H : {0, 1} N × {0, 1} M → {0, 1}N be a compression function, then a class of attacks C against H is a set of (randomized) algorithms A that produce atuple (CV 1 , B 1 ,CV 2 , B 2 ) ∈ {0, 1} N × {0, 1} M × {0, 1} N × {0, 1} M as output.We model an unavoidable condition for an attack class as a predicate over pairs (CV, B) of a chaining value and message block. If the unavoidable conditions can be evaluated very quickly in comparison to the recompression, e.g., comparing whether two bits are equal/unequal in the internal state of the compression function, then a significant speed improvement can be achieved.4 Application to SHA-1 SHA-1 is defined using 32-bit words X = (x i ) 31 i=0 ∈ {0, 1} 32 that are identified with elements X = ∑ 31 i=0 x i 2 i of Z/2 32 Z (for addition and subtraction). For t = 0, 1, . . . , 79 in succession, Q t+1 is calculated as follows: F t = f t (Q t−1 , RL(Q t−2 , 30), RL(Q t−3 , 30)), Q t+1 = F t + AC t +W t + RL(Q t , 5) + RL(Q t−4 , 30). For more convenient analysis, they consider the disturbance vector which is a non-zero vector (DV t ) 79 t=0 conform to the message expansion where every '1'-bit DV t [b] marks the start of a local collision based on the disturbance δW t [b] = ±1. Even then it seems that out of 2 512 possible disturbance vectors there are only a few tens of disturbance vectors suitable for feasible cryptanalytic attacks.In the first number of steps and the last few steps attacks can deviate from the DV-prescribed local collisions without a significant impact in the overall attack complexity. These message bit relations are used in attacks to ensure that, e.g., adjacent active bits collapse to a single bit difference, or that two bits have opposing sign to cancel differences (the perturbation of each local collision). A differential path P over steps t ∈ [35, 65) is given asP = ((∆Q t ) 64+1 t=35−4 , (∆F t ) 64 t=35 , (δW t ) 64 t=35 ), with correct differential steps for t ∈ [35, 65):σ (∆Q t+1 ) = σ (RL(∆Q t , 5))+σ (RL(∆Q t−4 , 30)) + σ (∆F t ) + δW t . Then we can define a mapping that maps differential paths to a vector over F 2 of the message bits W t [i] that are known:• if c i = 1 then ∆W t [i] = 1 · DW t = 1 thus W t [i] = 0 and W t [i] = 1; • if c i = −1 then ∆W t [i] = −1 · DW t = −1 thus W t [i] = 1 and W t [i] = 0; Hence, given P ∈ Dµ : D [35,65) → F R 2 : P → (W t [i]|(t, i) = X[r]) R r=1And we can look at the smallest affine vector space V that encapsulates the image µ(D [35,65) ) of D [35,65) . So we use its 'row reduced form' which results entirely in equations over 2 message bits of the formW i [a] ⊕W j [b] = c.For our improved SHA-1 collision detection implementation we have selected the 32 disturbance vectors with lowest estimated cost as in [24]. As each UBC is a linear equation, the set of UBCs per DV can be further manipulated for our purposes using simple linear operation.In the previous section we analyzed 32 disturbance vectors and found 7 to 15 UBCs per DV with a total of 373 UBCs. Furthermore, in the directory 'tools' we provide the following:• the original listing of UBCs per DV (directory 'data/3565');• an example partial collision for SHA-1 (file 'test/sha1 reducedsha coll.bin');• the greedy selection algorithm from Sect. 4.7 that optimizes the UBC sets and outputs optimized code (directory 'parse bitrel'), see Sect. 5.1;• a program that verifies the optimized C code with optimized UBC sets against manually-verifiable C code (directory 'ubc check test'), see Sect. 5.2;The collision detecting SHA-1 implementation, including the SHA-1 compression function as well as the collision detection logic and UBC checks, has been heavily optimized to be competitive with the performance of the prior implementation of SHA-1 in Git. For example, the following clause is one of the clauses generated by the parse_bitrel:C &= ((((W[46]>>4)^(W[49]>>29))&1)-1) | ~( DV_I_46_0_bit | DV_I_48_0_bit | DV_I_50_0_bit | DV_I_52_0_bit | DV_II_50_0_bit | DV_II_55_0_bit );The ubc_check function thus consists of initializing the variable C and statements for each unique UBC to update C as described above. For this purpose we let parse_bitrel also output C-code for a function ubc_check_verify that will be equivalent to ubc_check but will be based on the original non-improved UBC-sets and use straightforward code that can be manually verified for correctness. This, as well as a few other basic tests, ensures that our greedy selection algorithm for improved UBC-sets and the produced optimized C-code ubc_check contains no errors. To measure performance on ARM architecture, the code was compiled with GCC 4.9.2 (gcc arm) and run on a Raspberry Pi 3 running Raspbian Jessie with a quad-core Broadcom BCM2837, which is an ARM Cortex-A53, running at 1.2Ghz. However, the total cost of collision detection includes the cost of SHA-1 as well as the cost of verifying the UBCs.We have measured the cost of ubc_check in comparison to SHA1Compress in function calls per millisecond in Tbl. Overall the relative timings of ubc check shows that we can expect drastic speedups from using unavoidable conditions.The analysis of the internal operations of the SHA-1 hash and collision detection ignores a great deal of overhead that the algorithm may incur. We timed the original SHA-1 without collision detection, SHA-1 with collision detection with the UBC optimizations, and finally SHA-1 with collision detection but without using UBCs. MD5 is significantly weaker than SHA-1 and there are 223 known at- tack classes that are based on a number of different approaches to construct a high probability differential path over the most important steps that contribute to the complexity. More protection against signature forgeries is greatly warranted and our improved SHA-1 collision detection enables protection against digital signature forgeries at a very low cost.As SHA-1 is practically broken, yet SHA-1-based signatures are still used at large and are also widely supported (at least for verification), our improved SHA-1 collision detection enables protection against digital signature forgeries at a very low cost.