In this paper, we revisit this assumption and show for the first time that hardware translation lookaside buffers (TLBs) can be abused to leak fine-grained information about a victim's activity even when CPU cache activity is guarded by state-of-the-art cache side-channel protections, such as CAT and TSX. Our analysis exploits high-resolution temporal features on the victim's memory activity to combat side-channel coarsening and leak information.Existing defenses against cache side channels The execution of a victim program changes the state of the shared CPU caches. Given that attackers can find many new sources of timing [17,34,49], CPU cache partitioning is currently the only known generic mechanism that stops existing attacks.Unfortunately, as we will show, protecting only the shared data and instruction caches is insufficient. Armed with this information, we build TLBleed, a side-channel attack over shared TLBs that can extract secret information from a victim program protected with existing cache defenses [9,21,31,37,52,62] Implementing TLBleed is challenging: due to the nature of TLB operations, we can only leak memory accesses in the coarse granularity of a memory page (4 KB on x86 systems) and due to the TLB architecture we cannot rely on the execution of instructions (and controlled page faults) to leak secret information similar to previous page-level side-channel attacks [58]. For instance, if the adversary first occupies all the n ways in a cache set and after some time observes that some of these cachelines are no longer in the cache (since accessing the data now takes much longer), it must mean that another programa victim process, VM, or the kernel-has accessed data at addresses that also map to this cache set. As the mapping from to a cache set involves the physical memory address, this can be done by the operating system by organizing physical memory into non-overlapping cache set groups, also called colors, and enforcing an isolation policy. All the existing cache side-channel attacks and defenses focus on exploitation and hardening of shared CPU caches, but ignore caching mechanisms used by the Memory Management Unit (MMU). The first level (i.e., L1), consists of two parts, one that caches translations for code pages, called L1 instruction TLB (L1 iTLB), and one that caches translations for data pages, called L1 data TLB (L1 dTLB). More specifically, how do virtual addresses map to multi-level TLBs found in modern processors?Q2 How do sibling hyperthreads share the TLB sets for translating their code and data addresses?Once the attacker knows how to access the same TLB set as a victim, the question is whether she has the ability to observe the victim's activity:Q3 How can an unprivileged process (without access to performance counters, TLB shootdown interrupts, etc.) monitor TLB activity reliably?Finally, once the attacker can reliably measure the TLB activity of the victim, the question is whether she can exploit this new channel for attractive targets:Q4 Can the attacker use the limited granularity of 4 kB "data" pages to mount a meaningful attack? As we shall see, we found that even on a single processor, the mapping algorithms in the different TLBs vary from very simple linear translations to complex functions that use a subset of the virtual address bits XORed together to determine the target TLB set.To understand the details of how the TLB operates, we need a way to reverse engineer such mapping functions on commodity platforms, recent Intel microarchitectures in particular. Thus, we assume that the TLB set number can be expressed as an XOR of a subset of bits of the virtual address, similar to the physical hash function for CPU caches.To reverse engineer the hash, we first collect minimal eviction sets, following the procedure from [42]. As shown in the table, most TLB levels/types on recent Intel microarchitectures use linear mappings, but the L2 sTLB on Skylake and Broadwell are exceptions with complex, XORbased hash functions. We observe whether we see L1 misses of either type, and also whether we observe L2 misses.4. To verify the reverse engineered TLB partitions, and to determine how hyperthreads are exposed to each others' activity (addressing Q2), we run the following experiment for each TLB level/type:1. The signal on the diagonal in the L2 sTLB shows that sets are shared but with a 64-entry offset-the highest set number bit is XORred with the hyperthread ID when computing the set number. In our TLBbased attack setting, a higher eviction set access latency indicates a likely TLB lookup performed by the victim on the corresponding TLB set.To implement an efficient monitor, we time the accesses using the rdtsc and rdtscp instructions and serialize each memory access with the previous one. We proceed as follows: asm volatile ( "lfence\n" "rdtsc\n" "mov %%eax, %%edi\n" "mov (%2), %2\n" "mov (%2), %2\n" "mov (%2), %2\n" "mov (%2), %2\n" "lfence\n" "rdtscp\n" "mov %%edi, %0\n" "mov %%eax, %1\n" : "=r" (time1), "=r" (time2) : "r" (probe) : "rax", "rbx", "rcx", "rdx", "rdi"); : Memory access latency determining TLB hit or misses. We can now rely on unprivileged memory access latency measurements to reliably distinguish TLB misses from TLB hits and hence monitor the activity of the victim over shared TLBs in practical settings. Hence, due to (page-level) sidechannel coarsening, TLB attacks cannot easily rely on traditional spatial access information to leak secrets in real-world attack settings.Looking more carefully at Figure 8, it is clear that some sets are accessed at different times within the execution of each side of the branch. We find that, due to the high resolution of our channel, a simple classification and feature extraction strategy is sufficient to leak our target functions' temporal traces with a high accuracy. The peak detection merges spurious peaks/-valleys into one as seen in the first valley, and turns the continuous classification into a discrete bitstream.Identifying the Target TLB Set For the libgcrypt target, we only need to use a single TLB set for training and testing. In this section we select a challenging case study, and evaluate the reliability of TLBleed.Testbed To gain insights on different recent microarchitectures, we evaluated TLBleed on three different systems: (i) a workstation with an Intel Skylake Core i7-6700K CPU and 16 GB of DDR4 memory, (ii) a server with an Intel Broadwell Xeon E5-2620 v4 and 16 GB of DDR4 memory, and (iii) a workstation with an Intel Coffeelake Core i7-8700 and 16 GB of DDR4 memory. On average, TLBleed can reconstruct the private key in 97% of the case using only a single signature generation capture and in only 17 seconds. After training a classifier on samples from each of the 16 L1 dTLB access patterns in libgcrypt, we are able to distinguish all TLB sets from each other with an F1-score of 0.54, as shown in a reliability matrix in Figure 11. There will always be a dup invocation for every bit position in the execution trace, plus an average of 128 add invocations somewhere for every '1' bit in the secret value. The end-to-end attack time is composed of: 2 ms of capture time; 17 seconds of signals analysis with the trained classifier; and a variable amount of brute-force guessing with a negligible median work factor of 2 3 at worst, taking a fraction of a second. Whenever these pointers fall in different TLB sets, TLBleed can detect whether or not this swapping operation has happened, by distinguishing the access activity in the swapped and unswapped cases, directly leaking information about the secret exponent. We summarize the accuracy of our key reconstruction results in Figure 14, a histogram of the edit distance of the reconstructed RSA keys showing that on average we recover more than 92% of RSA keys with a single capture. We now want to assess whether TLBleed can compromise strong, hardware-based cache defenses that protect the cache activity of the victim with hardware transactional memory features such as Intel TSX. To validate our hypothesis, our goal is to show that TLBleed can still detect the victim's activity with successful transactions and leak information even when Intel TSX is in effect.Porting libgcrypt's EdDSA algorithm to run inside a TSX transaction requires major source changes since its working set does not fit inside the CPU cache. We believe that, given the raw single TLB set probe rate of roughly 30 Â· 10 7 , with additional engineering effort the bandwidth of this channel could be significantly improved. The L2 TLB in our Broadwell system has 256 sets, allowing us to reduce up to 8 bits of entropy. Another option is to extend hardware transactional memory features such as Intel TSX to cause capacity aborts if a protected transaction observes unexpected TLB misses similar to CPU caches. With TLBleed, we introduce a machine learning-based analysis framework that exploits (only) high-resolution temporal features to leak information even in (page-level) side-channel coarsening scenarios. In this paper, we have shown that TLB activity monitoring not only offers a practical new side channel, but also that it bypasses all the state-ofthe-art cache side-channel defenses.