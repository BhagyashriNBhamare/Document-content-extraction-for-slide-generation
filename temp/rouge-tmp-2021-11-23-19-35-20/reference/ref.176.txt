Finally, we demonstrate how Erays can be used for reverse-engineering in four case studies: high-value multi-signature wallets, arbitrage bots, exchange accounts, and finally, a popular smart-contract game, Cryptokitties. We conclude with a discussion regarding the value of reverse engineering in the smart contract ecosystem, and how Erays can be leveraged to address the challenges that lie ahead. Many smart contracts do not have readily linkable public source code available, making them opaque to auditors.To better understand opaque smart contracts, we present Erays, a reverse engineering tool for Ethereum smart contracts. Notably, we transform EVM from a stack-based language to a register based machine to ease readability of the output for the end-user. We build a "fuzzy hash" mechanism that can compare two smart contracts and identify whether a function in one contract has similar syntactic structure to functions in another contract. Using this technique, we are able to map a median 50% of functions and 14.7% of instructions per opaque contract, giving immediate partial insight to opaque contracts in the ecosystem.Finally, we show how Erays works as a reverse engineering tool applied to four case studies -high-value multi-signature wallets, arbitrage bots, exchange accounts, and finally, a popular smart contract game, Cryptokitties. In light of this, we posit that smart contract developers may be expecting to achieve "security by obscurity" by withholding their high level code.We conclude with a discussion of the value of audits, reverse engineering, and where Erays can aid in solving the growing needs of the Ethereum community. Smart contracts make up approximately 5% of the total Ethereum accounts, account for 31.2% of the overall transactions, and hold 9.4% of total Ether in their balances.A smart contract is executed when a user submits a transaction with the contract as the recipient. To prevent resource exhaustion, users that create transactions must pay an amount of gas for every opcode executed, which translates to certain amount of Ether depending on a market rate.Contracts are executed in a virtual environment known as the Ethereum Virtual Machine (EVM). Unlike memory, storage persists across the execution history of a contract and is stored as a part of the global blockchain state.Developers typically write smart contract code in highlevel languages, which are then compiled into EVM bytecode. Solidity syntax is heavily influenced by Javascript and C++, and supports a number of complex language features, such as inheritance, libraries, and user-defined types.Ethereum-based Tokens.In addition to the built-in Ether currency, the Ethereum blockchain is also widely used as a host for "tokens", which are separate currencylike instruments built on top of a smart contract. 2 Tokens today are used to support a variety of functions, such as crowd-funding and exchanges. After removing duplicates, we find only 34,328 unique contracts, which is a 97% reduction in contracts from the original set. We scraped Etherscan for all verified contracts as of January 3rd, 2018, collecting a total of 10,387 Solidity files.We then compiled the Etherscan verified contracts to determine exact bytecode matches with blockchain contracts. To identify variants of contracts that were compiled with older versions of the Solidity compiler, we aggregated every major compiler version from v0.1.3 to v0.4.19 and compiled each contract with every version. Although opaque contracts make up most of the smart contracts in the ecosystem, we find that they are in the minority by both transaction volume and balance.Opaque contracts are transacted with 12.7 M times, compared with transparent contracts, which are transacted with 27.6 M times. In addition, opaque contracts only hold $3.1 B USD, while transparent contracts hold $7.3 B USD. Although it appears that transparency in the ecosystem prevails, the fact remains that 12.7 M interactions with contracts and a total of $3.1 B USD are held in contracts for which auditors and regulators have no insight into. Instructions that alter the control flow (i.e., exits or branches) mark block exit, while the special instruction JUMPDEST marks block entry. At its core, recovering a CFG from basic blocks requires identifying the successor(s) of each basic block.To determine the successor(s) for a basic block b, we need to examine the last instruction in the block. An instruction that branches (JUMP, JUMPI)In the first case, control simply flows to the next block in the sequence, making that block the successor of b. The algorithm follows a conventional pattern for CFG recovery [46]: we analyze a basic block, identify its successors, add them to the CFG, then recursively analyze the successors.When analyzing a block, we model the stack effects of instructions. If a stack image has already been recorded, the block would continue to a path that has already been explored, and so the recovery algorithm backtracks. In this stage, we lift EVM's stack-based instructions into a register-based instructions. These instructions allow us to collapse more verbose EVM instructions equences (e.g., sequence EQ, ISZERO) into one NEQ instruction.MOVE: This instruction copies a register value or a constant value to a register. The instructions SWAP (swap two stack items), DUP (duplicate a stack item) and PUSH (push a stack item) are all translated into MOVE instructions.To derive the registers on which the instructions operate, we map each stack word to a register, ranging from $s0 to $s1023 because the EVM stack is specified to have a maximum size of 1,024 words. The $t register is used as a temporary register for SWAP instructions.Each instruction is then assigned appropriate registers to replace its dependency on the stack. $s3 $s2 0x5 $s1 0x3 0x8 $s0 0x4 0x4 Figure 1: Lifting an ADD Instruction -We show both the stack image and the registers before and after an ADD is executed. The initial stack height is three, thus, ADD reads from $s1 and $s2, and writes back the result to $s1.Knowing the precise stack height is crucial to lifting. Given the stack heightPUSH1 0x1 MOVE $s3, 0x1 SLOAD SLOAD $s3, [$s3] DUP2 MOVE $s4, $s2 LT LT $s3, $s4, $s3 ISZERO ISZERO $s3, $s3 PUSH1 0x65 MOVE $s4, 0x65 JUMPI JUMPI $s4, $s3Code Block 3: Lifting A BLock -We show a block of stackbased instructions lifted to register-based instructions given initial stack height of three.SLOAD $s3, [0x1] GEQ $s3, $s2, $s3 JUMPI 0x65, $s3Code Block 4: Optimizing A Block -We show the optimized version of Code Block 3. As a result, the lifted code contains many MOVE instructions that simply copy data around. Aggregation aims to further simplify the produced intermediate representation by replacing many instructionsSLOAD $s3, [0x1] $s3 = S[0x1] GEQ $s3, $s2, $s3 $s3 = $s2 ≥ $s3 JUMPI 0x65, $s3 if ($s3) goto 0x65Code Block 5: Three-Address Form -We show the Code Block 4 in three-address form.with their analog, compact versions that we term "aggregated expressions." Each expression is a combination of an assignment and an operator, with the write_register to the left of the assignment and the operator along with the read_registers to the right of the assignment. Consider the example in Code Block 5, by aggregating the first expression into the second one, and then the second into the third, the block can be summarized into a single expression:if ($s2 ≥ S[0x1]) goto 0x65 We employ structural analysis [44] algorithms to recover high level control constructs (control flow structure recovery). Given specific contract inputs, we "execute" our representation andassert(0x0 == msg.value) $s2 = c[0x4] while (0x1) { if ($s2 >= s[0x0]) break if ($s2 <= 0xa) { $s2 = 0x2 + $s2 } $s2 = 0xc + $s2 } m[$m] = $s2 return($m, (0x20 + $m) -$m)Code Block 6: Structural Analysis -A simple example of the final output of Erays, where control flow structures are recovered from blocks of expressions. check if it produces the correct outputs.We use go-ethereum (Geth) to generate ground truth for the expected behavior. There are three classes of operations that need to be treated differently.In the first case, the operations retrieve some inputs for the contract. If an operation is missing in the trace (original trace never issued such call), we mark it as a failure.In the second case, the operations update the blockchain (world) state. If our machine encounters an exception during these operations, we mark it as a failure.We leverage historical transactions on the blockchain to construct a set of tests. We note this is only 46% of all unique contractsthe remaining were never transacted with.If Erays fails to generate the representation in the first place, we mark it as a "construction failure". In total we fail 510 (3.22%) of the test set, among which 196 are "construction failures" and 314 are 'validation failures". While the output is relatively straightforward when only common types are present (uint array, address), Erays cannot succinctly capture operations on complex types such as mapping (uint => string). We run Erays on the 34 K unique contracts found on the Ethereum blockchain. We fail to create CFGs for 445 (1.3%) unique binaries, which we exclude from our analysis. Cyclomatic complexity measures the number of linearly independent paths in a given control flow graph. We find that 79% of unique contracts do not contain a single function with complexity greater than 10, which indicates that in addition to being small, many contracts do not contain unnecessarily complex functionality. Erays groups basic blocks into its higher-level functions. From these groupings, we can further compare the structure and code of functions across contracts, giving us a useful metric for determining function similarity. We then take the hashes of the resultant blocks as the "set" of blocks in a function, and compare these sets in further analysis. For example, the most popular function by implementation is the public getter function for the uint256 data type.We next turn to investigate popular external functions included in contracts, and the number of implementations of each of those functions. A useful product of Erays is the ability to identify the functional similarity between two EVM contracts (Section 5.2). From each of these compiled binaries, we extract its functions, and then compare function implementations pairwise from the compiled binaries to binaries collected from the blockchain. An exact function match to a compiled function thus immediately gives us the source code for that function from its originating source file. We view this as similar to the technique of "binary clone detection" [15,39], a technique that overlays function symbols onto stripped binaries using a full binary. Using Erays, we find that many of these are multisignature wallets that require multiple individuals to approve any transactiona standard cryptocurrency security measure. 4 This address accesses two other high value, opaque wallets in our dataset, with $381 M and $164 M USD in balance, respectively.We use Erays to reverse engineer these contracts, and uncover their access control policies. The third Gemini contract contains a more complicated, time-based access control policy. When generating a unique identifier for a new withdrawal, the contract uses the hash of both a global counter as well as the hash of the previously mined block. We note that in the past, cryptocurrency exchanges have failed to handle related hazards, resulting in significant losses [21]. We find that many of these contracts are associated with large exchanges that create one contract instance for each user account.Poloniex Exchange Wallets The largest cluster of identical opaque contracts appears a total of 349,612 times on the Ethereum blockchain. Depending on which chain the transaction appears on, the Ether value of the message is sent to a different address.Opacity in communications with financial institutions over the Internet is expected practice -we do not see the code that runs the online banking services we use. We next leverage Erays to investigate the role of arbitrage bots on EtherDelta [2], a popular decentralized exchange. In order to reduce risk, many arbitrageurs have built Ethereum smart contracts that send batch trades through EtherDelta. To begin, we built a list of 30 suspected arbitrage contracts by scanning transactions within blocks 3,900,000 to block 4,416,600, and selected contracts that both make internal calls to EtherDelta and generate two trade events in a single transaction. If the contract finds there is sufficient balance on its open offer, it then calls the trade function in EtherDelta twice, thus executing the arbitrage trade. If either trade fails, the entire transaction is aborted using the REVERT opcode.Several arbitrage contracts we investigated exhibited different variations of this behavior. Although the high-level code is known to the developers, the developers have committed to a policy of not playing the game or utilizing this information. As a final case study, we apply Erays to the Cryptokitties contract.With 3 hours of reverse engineering work using Erays, we were able to create a Solidity contract whose output exactly matches the output of the mixGenes function on the blockchain. The new block number and its hash are concatenated with the parent's genes as input to the keccak256 hash function, whose output is used as the source of randomness for the rest of the execution. Finally, a particular gene is mutated with 25% probability if the larger of the two parents' corresponding gene is less than 23 and with 12.5% probability otherwise.Concurrent to our work in reverse engineering, at least three other teams also attempted to reverse engineer the mixGenes function [22,27,48]. First, we can identify kitties with genes valued 23 or greater which are less likely to encounter random mutation when breeding. Second, since randomness is chosen based on block hashes at the time giveBirth is called, we can wait to submit the giveBirth transaction until after a block hash that results in favorable breeding. We ran Porosity over the 34 K unique contracts in our dataset to evaluate how well it performs in comparison to Erays. Porosity produces high-level source code without error for only 1,818 (5.3%) unique contracts. Etherscan's verified source code is a step in the right direction, but more work must be done in order to improve transparency in the ecosystem.Why are so many contracts opaque, given the ease of publishing source code to Etherscan? In some cases, opacity may be a deliberate decision in order to achieve security through obscurity. We then applied Erays to four reverse-engineering case studies: high-value multisignature wallets, arbitrage bots, exchange accounts, and finally, a popular smart contract game. For an INTCALL, they can be interpreted as the number of arguments and return values.We note that a sequence of bytecode instructions can be viewed as a single operation, thus the delta and alpha value of the sequence computed in the manner shown in 7. We note that in most cases, the return address is the first argument (at the bottom of the initial stack) and will be popped off eventually, which allows us to fully exhaust the function arguments. The INTRET, when "executed", will transfer the control flow In our heuristic, an internal function is assumed to have a single entry and a single exit. During the CFG recovery, we keep track of where each constant is generated, which enables the correlation. The subgraph for the callee is first extracted using the CFG recovery algorithm.