Most fuzzing efforts-especially feedback fuzzing-are limited to user space components of an operating system (OS), although bugs in kernel components are more severe, because they allow an attacker to gain access to a system with full privileges. In this paper, we approach the problem of coverage-guided kernel fuzzing in an OS-independent and hardware-assisted way: We utilize a hypervisor and In-tel's Processor Trace (PT) technology. Among many crashes, we uncovered several flaws in the ext4 driver for Linux, the HFS and APFS file system of macOS, and the NTFS driver of Windows. Several vulnerability classes such as memory corruptions, race-conditional memory accesses, and use-afterfree vulnerabilities, are known threats for programs running in user mode as well as for the operating system (OS) core itself. This greatly improves efficiency and usability of fuzzers, especially by reducing the need for an oracle which generates semi-valid inputs or an extensive corpus that covers most paths in the target.Unfortunately, AFL is limited to user space applications and lacks kernel support. Fuzzing kernels has a set of additional challenges when compared to userland (or ring 3) fuzzing: First, crashes and timeouts mandate the use of virtualization to be able to catch faults and continue gracefully. In addition, the Windows kernel and many relevant drivers and core components (for Windows, macOS and even Linux) are closed source and cannot be instrumented by common techniques without a significant performance overhead.Previous approaches to kernel fuzzing were not portable because they relied on certain drivers or recompilation [10,34], were very slow due to emulation to gather feedback [7], or simply were not feedback-driven at all [11]. In this paper, we introduce a new technique that allows applying feedback fuzzing to arbitrary (even closed source) x86-64 based kernels, without any custom ring 0 target code or even OS-specific code at all. We have applied kAFL to Linux, macOS, and Windows and found multiple previously unknown bugs in kernel drivers in those OSs.In summary, our contributions in this paper are:• OS independence: We show that feedback-driven fuzzing of closed-source kernel mode components is possible in an (almost) OS-independent manner by harnessing the hypervisor (VMM) to produce coverage. • Hardware-assisted feedback: Our fuzzing approach utilizes Intel's Processor Trace (PT) technology, and thus has a very small performance overhead. We use the Intel Processor Trace (Intel PT) extension of IA-32 CPUs to obtain coverage information for ring 0 execution of arbitrary (even closed-source) OS code. To facilitate efficient and OS-independent fuzzing, we also make use of Intel's hardware virtualization features (Intel VT-x). Hence, we provide a brief overview of Intel's hardware virtualization technology, Intel VT-x. However, the execution of the different logical CPUs is interleaved by the hardware and therefore the available resources can be utilized more efficiently (e.g., one logical CPU uses the arithmetic logic unit while another logical CPU waits for a data fetch) and the operating system can reduce the scheduling overhead. The VM, also termed guest, is a piece of software that is transparently executed within the virtualized context provided by the VMM.To provide full hardware-assisted virtualization support, Intel VT-x adds two additional execution modes to the well-known protection ring based standard mode of execution. With the fifth generation of Intel Core processors (Broadwell architecture), Intel has introduced a new processor feature called Intel Processor Trace (Intel PT) to provide execution and branch tracing information. The decoder needs the traced software to interpret the packets that contain the addresses of conditional branches.Intel specifies five types of control flow affecting instructions called Change of Flow Instruction (CoFI). Taken-Not-Taken (TNT): If the processor executes any conditional jump, the decision whether this jump was taken or not is encoded in a TNT packet.2. Depending on the given processor, it might be possible to configure multiple ranges for instruction-pointer filtering (IP Filter). In accordance to the IP filtering mechanism, it is possible to filter traces by the current privilege level (CPL) of the protection ring model (e.g ring 0 or ring 3). kAFL focuses on the Table of Physical Addresses (ToPA) mechanism that enables us to specify multiple output regions: Every ToPA table contains multiple ToPA entries, which in turn contain the physical address of the associated memory chunk used to store trace data. We now provide a high-level overview of the design of an OS-independent and hardware-assisted feedback fuzzer before presenting the implementation details of our tool called kAFL in Section 4. Our system is split into three components: the fuzzing logic, the VM infrastructure (modified versions of QEMU and KVM denoted by QEMU-PT and KVM-PT), and the user mode agent. When the VM is started, the first part of the user mode agent (the loader) uses the hypercall HC_SUBMIT_PANIC to submit the address of the kernel panic handler (or the BugCheck kernel address in Windows) to QEMU-PT 1 . QEMU-PT then patches a hypercall calling routine at the address of the panic handler. The fuzzer setup is now finished and the main fuzzing loop starts.During the main loop, the agent requests a new input using the HC_GET_INPUT hypercall 4. While the kernel is being fuzzed, QEMU-PT decodes the trace data and updates the bitmap on demand. The resulting VM-Exit stops the tracing and QEMU-PT decodes the remaining trace data 7. We gather the AFL bitmap from the VMs through an interface to QEMU-PT and decide which inputs triggered interesting behaviour. One of the bigger design differences to AFL is that kAFL makes extensive use of multiprocessing and parallelism, where AFL simply spawns multiple independent fuzzers which synchronize their input queues sporadically 1 . Example agents are programs that try to mount inputs as file system images, pass specific files such as certificates to kernel parser or even execute a chain of various syscalls.In theory, we only need one such component. This component configures and enables Intel PT on the respective logical CPU before the CPU switches to guest execution and disables tracing during the VM-Exit transition. Moreover, QEMU-PT also filters the stream of executed addresses-based on previous knowledge of non-deterministic basic blocks-to prevent false-positive fuzzing results, and makes those available to the fuzzing logic as AFL-compatible bitmaps. We use our own custom Intel PT decoder to cache disassembly results, which leads to significant performance gains compared to the off-the-shelf solution provided by Intel. We use two techniques to deal with these challenges.The first one is to filter out interrupts and the transition caused while handling interrupts. This mechanism is necessary since the interrupt handler may itself be interrupted by another interrupt.The second mechanism is to blacklist any basic block that occurs non-deterministically. If any ring 3 process or the kernel in the VM executes a vmcall instruction, a VM-Exit event is triggered and the VMM can decide how to process the hypercall. We patched KVM-PT to pass through our own set of hypercalls to the fuzzing logic if a magic value is passed in rax and the appropriate hypercall-ID is set in rbx. Upon executing the vmcall instruction, a VM-Exit is triggered and QEMU-PT stores the buffer pointer that was passed. In order to do so, we overwrite the kernel crash handler of the OS with a simple hypercall routine. The source code of our reference implementation is available at https://github.com/RUB-SysSec/kAFL. To the best of our knowledge, no publicly available driver is able to trace only guest executions of a single vCPU using Intel PT for long periods of time. QEMU-PT utilizes this novel interface to interact with KVM-PT and to access the resulting trace data. The modification has to be done before the CPU switches from the host context to the VM operation; otherwise the CPU will execute guest code and is technically unable to modify any host MSRs. By enabling tracing via MSR autoloading, we only gather Intel PT trace data for one specific vCPU. Once we have enabled Intel PT, the CPU will write the resulting trace data into a memory buffer until it is full. To avoid the resulting data loss, we chose the second buffer to be about four times larger than the largest overflowing trace we have ever seen in our tests (4 KB). To make use of the KVM extension KVM-PT, an user space counterpart is required. KVM-PT is accessible from user mode via ioctl() commands and an mmap() interface.In addition to being a userland interface to KVM-PT, QEMU-PT includes a component that decodes trace data into a form more suitable for the fuzzing logic: We decode the Intel PT packets and turn them into an AFL-like bitmap. This is due to the nature of Intel PT decoding since the decoding process is sequential and is affected by previously decoded packets.To ease efforts to implement an Intel PT software decoder, Intel provides its own decoding engine called libipt [4]. Furthermore, libipt does not cache disassembled instructions and has performed poorly in our use cases.Since kAFL only relies on flow information and the fuzzing process is repeatedly applied to the same code, it is possible to optimize the decoding process. Unlike other Intel PT drivers, we do not need to store large amounts of trace data in memory or on storage devices for post-mortem decoding. Each basic block has a randomly assigned ID, and each transition from basic block A to another basic block B is assigned an offset into the bitmap according to the following formula:(id(A)/2 ⊕ id(B)) % SIZE_OF_BITMAPInstead of the compile-time random, kAFL uses the addresses of the basic blocks. If an input triggers an entirely new transition (as opposed to a change in the number of times the transition was taken), it will be favored and fuzzed with a higher priority. TriforceAFL is based on the emulation backend of QEMU instead of hardware-assisted virtualization and Intel PT. If not stated otherwise, the benchmarks were performed on a desktop system with an Intel i7-6700 processor and 32GB DDR4 RAM. While it does not allow code execution, it is still a denial-of-service vulnerability, as for example, a USB stick with that malicious NTFS volume plugged into a critical system will crash that system with a blue screen. Hence, we assume that the NTFS driver under Windows is a valuable target for coverage-based feedback fuzzing.Furthermore, we implemented a generic system call (syscall) fuzzing agent that simply passes a block of data to a syscall by setting all registers and the top stack region (55 lines of C and 46 lines of assembly code). We did not find any bugs in 13 hours of fuzzing with approx 6.3M executions since many syscalls cause the userspace agent to terminate: Due to the coverage-guided feedback, kAFL quickly learned how to generate payloads to execute valid syscalls, and this led to the unexpected execution of user mode callbacks via the kernel within the fuzzing agent. These crashes require rather expensive restarts of the agent and therefore we only achieved approx. 134 executions per second, while normally kAFL achieves a throughput of 1,000 to 4,000 tests per second (see Section 5.2). Similarly to Windows and Linux, we targeted multiple file systems for macOS. So far, we found approximately 150 crashes in the HFS driver and manually confirmed that at least three of them are unique bugs that lead to a kernel panic. During this experiment, kAFL generated over 34 million inputs, found 295 interesting inputs, and performed nearly 9,000 executions per second. We evaluated some manually and found multiple security vulnerabilities in all tested operating systems such as Linux, Windows, and macOS. So far, eight bugs were reported and three of them were confirmed by the maintainers:• Linux: keyctl Null Pointer Dereference 5 (CVE-2016-8650 6 )• Linux: ext4 Memory Corruption 7• Linux: ext4 Error Handling 8• Windows: NTFS Div-by-Zero 9• macOS: HFS Div-by-Zero 10• macOS: HFS Assertion Fail 10• macOS: HFS Use-After-Free 10• macOS: APFS Memory Corruption 10 Red Hat has assigned a CVE number for the first reported security flaw, which triggers a null pointer deference and a partial memory corruption in the kernel ASN.1 parser if an RSA certificate with a zero exponent is presented. The last reported Linux vulnerability, which calls in the ext4 error handling routine panic() and hence results in a kernel panic, was at the time of writing not investigated any further. One example for high variance is the fact that on Debian 8 (initramfs), the multiprocessing configuration on average needed more time to find the crash than one process.TriforceAFL We used the JSON driver to compare kAFL and TriforceAFL with respect to execution speed and code coverage. However, the results where biased heavily in two ways: TriforceAFL did not manage to find a path that triggers the crash within 30 minutes (usually it takes approximately 2 hours), making it very hard to compare the code coverage of kAFL and TriforceAFL. Therefore, the coverage value in Table 1 (stated as Paths/Min) is limited to the first 10 minutes of each 30-minute run. We also compare raw execution performance instead of overall fuzzing performance, which is biased because of the execution of different paths, the sampling process for the non-determinism-filter, and various synchronization mechanisms. kAFL provides up to 54 times better performance compared to TriforceAFL's QEMU CPU emulation. Therefore, the performance overhead was compared with several KVM-PT setups on an i5-6500@3.2Ghz desktop system with 8GB DDR4 RAM. For this benchmark, a 13MB kernel code range was configured via IP filtering ranges and traced with one of the aforementioned setups of KVM-PT. During KVM-PT execution only supervisor mode was traced.To generate Intel PT load, QEMU-2.6.0 was compiled within a traced VM using the . Intel describes a performance penalty of < 5 % compared to execution without enabled Intel PT [30]. In contrast to KVM-PT, the decoder has significant influence on the overall performance of the fuzzing process since the decoding process is-other than Intel PT and hence KVM-PT-not hardware-accelerated. To compare both decoder engines, a small Intel PT trace sample was generated by executing find / > /dev/null 2> /dev/null within a Linux VM (Linux debian 4.8.0-1-amd64) traced by KVM-PT. Figure 9 illustrates the measured speedup of our PT decoder compared to ptxed.The figure also shows that our PT decoder easily outperforms the Intel decoder implementation, even if the PT decoder processes data for the very first time. Somewhere in the middle are so called gray-box fuzzers that will typically use some kind of feedback from the target (such as coverage information) to guide their search, without analyzing the logic of the target program itself. Tools like TaintScope [39], BuzzFuzz [21] and Vuzzer [35] utilize taint tracing and similar dynamic analysis techniques to uncover new paths. This fuzzer runs inside the targeted OS; a crash terminates the fuzzing session.In 2016, Hertz and Newsham released a modified version of AFL called TriforceAFL [7]. In practice, the TriforceAFL fuzzer is limited to operating systems that are able to boot from read-only file systems, which narrows down the candidates to classic UNIX-like operating systems such as Linux, FreeBSD, NetBSD, or OpenBSD. Finally, we can always trace the whole kernel, taking a slight performance hit (mostly introduced by the increased amount of non-determinism). We tested our system on the following CPU models: Intel Core i5-6500, Intel Core i7-6700HQ, and Intel Core i5-6600. Since our approach has a very modest tracing overhead, we expect that this technique will outperform current dynamic binary instrumentation based techniques for feedback fuzzing of closed-source ring 3 programs such as winAFL [20]. While previous feedbackdriven kernel fuzzers were able to find a large amount of security flaws in certain operating systems, their benefit was either limited by poor performance due to CPU emulation or a lack of portability due to the need for compiletime instrumentations.In this paper, we presented a novel mechanism to utilize the latest CPU features for a feedback-driven kernel fuzzer.