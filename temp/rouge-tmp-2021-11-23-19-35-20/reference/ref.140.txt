To address this issue, we propose FlowCog, an automated , flow-level system to extract flow-specific semantics and correlate such semantics with given information flows. Particularly, FlowCog statically finds all the An-droid views that are related to the given flow via control or data dependencies, and then extracts semantics, such as texts and images, from these views and associated layouts. For example, a weather app may request a user's location to provide customized weather services; a call app may obtain or import a user's phone book to ease the dialing. For example, a weather app will clearly state that it provides local weather condition so that a user will understand its access to location information. For example, an app may have two data flows 1 [12,15,18,22,24,33] accessing private information, one providing a customized service with user's knowledge, e.g., a pop-up window, but the other hiding secretly in background and sending information to the Internet without user's knowledge. Apparently, the former is legitimate with sufficient semantics, which we call positive in the paper, but the later is not, hence defined as negative.In this paper, we propose an automated, flow-level system, called FlowCog, to extract and analyze semantics for each information flow of an Android app. Our evaluation on the prototype against 2,342 flows extracted by FlowDroid [12] shows that FlowCog has an overall precision of 90.1% and a recall of 93.1%. The S3 app sends a user-provided phone number to its own server after the user sees a registration page shown in Figure 1 and presses the "Submit" button. This flow, from the phone number to the Internet, is positive, because the app provides sufficient semantics, such as keywords "Phone Number" and "mobile number", so that the app user can acknowledge and authorize the flow.What FlowCog does is to extract contexts for each information flow found by existing static or dynamic analysis and classify the flow as either positive or negative based on the extracted contexts. Specifically, such process, shown in Figure 2, can be broken down into four steps: (i) finding information flows of an Android App, (ii) finding special statements called activation event and guarding condition via control dependency and associated views (called view dependency) for each information flow, (iii) finding and extracting contexts, e.g., texts and images, from the aforementioned two special statements via data dependency, and (iv) determining the correlation between the flow and the contexts via Natural Language Processing (NLP) technique. The phone number leak of the S3 app, shown in Figure 3, starts from TelephonyManager.getLine1Number(), i.e., the source, in Block 1, and flows to Htt pClient.execute(), i.e, the sink, in Block 4. The phone number is first stored in an EditText et_regist_phone (Block 1), read by the getText method (Block 2), and then loaded by S3ServerApi.per f ormRegistration as a parameter (Block 3). Block 5 shows an example of activation event, because the per f ormRegistration method in Block 6 is activated by an onClick event. Then, FlowCog finds additional special statement, e.g., another activation event in Block 5, based on corresponding views, e.g., Button bt_regist_submit, associated with the found activation event, e.g., per f ormRegistrationsuch process is defined as view dependency in this paper. From the second statement in Block 2, FlowCog performs a data flow analysis upon $2 and finds et_passwd, a text field, the surrounding texts, "Password". In this section, we present the details of each component of FlowCog's architecture in Figure 2. We first present the special statement discovery engine in Section 3.1, which finds both activation events and guarding statements, and view dependency explorer in Section 3.2. Then, we show how to extract semantics from views and other places in Section 3.3 and correlate extracted semantics, i.e., flow contexts, with flows in Section 3.4. The reason of finding these two special statements is that they have direct control over the given data flow: Activation events decide whether to trigger the data flow and guarding conditions determines whether the source flows to a sink or other places. For example, the activation event in Block 5 of Figure 3 is a submit button, which directly controls the phone number leak and gives users semantics. Next let us discuss these two special statements separately. Similarly, FlowCog finds lifecycle event callbacks by looking at subclasses of corresponding lifecycle related classes, such as Activity, and finding overridden lifecycle callbacks, such as onCreate.Then, FlowCog generates call paths for a given data flow, e.g., the call path in Figure 4 for the data flow in Figure 3, and performs Algorithm 1 to find its activation events. For example, if one branch of an i f statement allows the data flow but another terminates the flow, we consider such i f statement as guarding condition-both i f statements in Blocks 2 and 7 in Figure 3 are such examples. (Guarding Condition) Given a data flow n source··· n k··· n sink , for any n k , we define a conditional statement c e -at least one branch of which does not contain n k -as a guarding condition if either of the following is satisfied:(1) c e and n k are in the same basic block, or connected in the interprocedural Control Flow Graph (iCFG);(2) c e controls the activation events of the data flow via view dependency, i.e., c e and the activation event are in the same view.Based on the definition, there are naturally two phases to find all guarding condition statements. If none of the following are satisfied, i.e., the method of curStmt is a callback method, FlowCog searches the statements that can reach curStmt in the program's inter-procedure control flow 11:else if isInvokeStmt(prevStmt) and method == getInvokedMethod(prevStmt) then f indGCHel per(curStmt, method.getFirstStmt(), iC f g, rs)13:else 14:f indGCHel per(curStmt, null, iC f g, rs)15:end if end if 17: end for 18: return rs graph ( Line 13-14). After FlowCog finds two special statements for a given data flow, it finds Android views related to the data flow so as to extract semantics. If a view's attribute values (e.g., EditText.getText() or CheckBox.isChecked()) could change the conditional result in guarding conditions of the given data flow, we consider such dependency exists.The view dependency problem can be formalized into another data flow analysis. In addition, FlowCog adopts a manually created list about all possible View classes from the Android documentation and finds all the new statements that create an object with these classes-these statements are treated as source as well.Second, FlowCog obtains all the sinks based on the aforementioned dependency categories. Apart from descriptions in Google Play, if an app is provided without any descriptions, e.g., malicious apps collected by security researchers, FlowCog will treat texts from the app's string resource file as a substitute of descriptions. For example, in Figure 3, the Button view will control the program in deciding whether to send out the phone number, and its text, i.e., the "submit" word, is the semantics about sending behavior. For another example, an "alert" Dialog view asking for user's permission for sharing her location decides whether the location is sent to the server, and provides semantics in its text to users.The semantics extraction for such views has two steps. Again, in most cases, i.e., 94%, such values can be resolved statically; otherwise, FlowCog relies on the optional dynamic analysis to resolve values.Second, besides the depended view, semantics from other adjacent views in the same layout may also be flow contexts, because a user-visible screen may contain multiple views from the same layout. "Tip: Register with your mobile number" in Figure 1 is such an example. Now let us discuss how to extract semantics from each category.First, for text resource, FlowCog extracts the values of android:text and android:hint attributes in the layout file. We specify two pairs of fragment name and semantics, (e.g., <com.google.android.gms.maps.SupportMapFragment, map>, <com.google.android.maps.MapView, map> ) to represent a map object in the list, so that when FlowCog finds this fragment in a layout file or related code, a "map" semantics will be added. In this section, we give an overview about how FlowCog infers the correlation between a given data flow and the extracted semantics. Figure 5 illustrates an overview of the design of this inference engine, which takes the flow and the text-based semantics as input and outputs whether these two are correlated. After that, resource filter will filter those less-informative pairs generated from API doc and feed all the remaining ones into two classifiers, one learning-based and the other learning-free, and FlowCog will calculate a score based on the results from these two classifiers using logistic regression. The dynamic analysis works in three steps.First, the dynamic analysis instruments Android app by identifying all the text-setting statements and printing the values their parameters as well as the target text-setting statement's location immediately before each text-setting statement. Second, we adopt a customized version of AppsPlayground [29] to install the app on emulator and automatically explore the app dynamically. Each app is set to be explored for at most 20 mins.Lastly, during the dynamic app exploration, when any text-setting statement is encountered, its string argument value as well as the statement's location will be printed out. Dynamic Analysis Python, Java ∼1,000Misc Python ∼500Total Java, Python ∼16,500 Now we discuss the implementation of FlowCog in this section. The semantics extraction part, such as finding views, activation events and guarding conditions, contains ∼12,000 LoC, the part about correlating semantics and flows, i.e., multiple classifiers, contains ∼3,000 LoC, our dynamic analysis ∼1,000 and others ∼500. We then discuss details of each component.First, as discussed, we adopt FlowDroid, a precise and efficient Java-implemented static analysis system, to discover all information flows. Such data flow analysis component is also based on the taint analysis framework provided by FlowDroid.Second, we implement a crawler using BeautifulSoup [1] to crawl API documents for methods associated with each flow. For learningbased classifier, FlowCog uses Python's Scikit-learn library [6], which integrates all the machine learning modules we have used in our implementation and evaluation. For dynamic analysis, we write a Soot-based Java program in ∼400 lines of codes to automatically instrument apps and then manage and customize AppsPlayGround [29] with ∼600 lines of Python codes to dynamically explore the instrumented apps. In the end, 1,299 benign apps terminate successfully, and 361 of them generate 1,043 flows; 586 malicious apps terminate successfully, and 255 of them generate 1,299 flows. Because FlowDroid is the most popular and open-source static analysis tool, we rely on FlowDroid in our evaluation.Next, we present how to obtain the ground truth for the dataset. We instruct the student to install Android apps, look at app descriptions and each information flow in the context of the app, and then infer whether the information flow as positive or negative based on their own knowledge. Among the 1,043 flows from benign apps, 688 of them are positive and 355 are negative. The overall precision, recall and accuracy are 90.1%, 93.1% and 90.2% respectively. FlowCog's accuracy, i.e., 90.7%, on benign apps is slightly higher than one on malicious apps, i.e., 89.6%. This flow is counted in both Location and SMS permission categories. First, the general trend excluding some exceptions noted below is that the larger training data FlowCog has, the better accuracy results we can get for FlowCog. Take flows with a "Location" permission for example. The purpose is to show that contexts for the target flow can provide more information in correlating the flow with app's semantics, but other flow's contexts will have a negative impact.The right four columns in Table 4 show our evaluation results. A pure learning-free approach, i.e., the similarity model in Ta- ble 4, has a bad overall accuracy, i.e., 79.3%, and that is why we need a learning-based approach. The overall accuracy of a learning-based approach is high, i.e., 88.3%, but such approach performs badly when the training set, e.g., these flows that leaking out Calendar via SMS, is small. Among all the combinations that we evaluated, the combination of GB and SVM achieves the best results (93.1%). Next, we compute the similarity score of this word list and the keyword list, using the Word2Vec similarity model discussed in Section A.4, and then make a classification decision based on the score.We evaluate the keyword-based, keyword plus simple NLP, and FlowCog using the same testing set. Note that this is also better than our similarity classifier alone with 79.3% accuracy. In this experiment, we study the accuracy of FlowCog in extracting flow contexts. In particular, FlowCog can extract 94.5% of flow-related texts from benign apps, and 98.3% of flow-related texts from malicious apps. FlowCog does support multiple languages: before feeding texts to classifiers, if any texts are not recognized as English, FlowCog will use a Python library called mtranslate [2] to translate them into English.Second, the remaining 18 texts that FlowCog fails to extract are caused by the limitations of static value analysis: completely solving value analysis is still a funda- mental challenges suffered by all static analysis tools.FlowCog adopts a bunch of heuristic rules to try our best to resolve those non-constant string values, but there are still 7 cases that we cannot resolve. Static analysis cannot solve dynamically-loaded texts and the dynamic analysis tool that we use, i.e., AppsPlayground, does not trigger this specific code branch. Some ad library will send user's location to Internet for user targeting. In this section, we perform a case study on a variety of data flows in different types of apps and discuss whether the app provides enough semantics for the flow, i.e. classified as positive or negative by FlowCog. Note that existing app-level semantics correlation tools will not be able to differentiate such two flows, because they will ask for the same permissions. Home of Ocarina, shown in Figure 6b, is an official app of a company. FlowCog can successfully extract flow contexts, such as "location of Home of Ocarina" and a Google map fragment, thus classifying the flow as positive. Specifically, the app leaks out users' geo-location as well as the device ID to the Internet in an onCreate lifecycle callback. SMS Irritate, shown in Figure 6d, is a malicious app from Drebin dataset [11,25] with a positive flow leaking out userspecified information via short message. FlowCog will also mark the specific flow as positive, because FlowCog can successfully extract all the aforementioned texts, such as "Send to" and "Number of SMS to flood". Specifically, FlowCog successfully finds that all these flows are triggered by an onCreate() callback of an activity in the app and then extract semantics, which only include gaming tips, such as "Move the box to the target empty position ...", and app control information, such as "Are you sure you would like to exit?" Even if they are defined dynamically in a rare case, FlowCog also relies on an optional dynamic analysis component to resolve the values.Second, we discuss how clickjacking attacks, or in general UI redress attacks, influence our results. FlowDroid [12] is a static precise taint analysis systems based on Soot framework. To address this limitation, static analysis systems Amandroid [33], DroidSafe [18] and IccTA [24] are proposed to provide Android inter-component taint analysis. That said, FlowCog can work with any such systems to determine whether enough semantics is provided.Second, Android app's execution context is an important indicator to analyze app's behaviors. As a comparison, FlowCog goes beyond app's execution contexts, i.e., activation events and guarding conditions, to find Android views and extract semantics related to these views.Third, NLP techniques are also used in Android privacy. Zimmeck et al. [37] propose another NLP system that extracts the semantics from app's privacy requirements and predicts whether an app is compliant with its privacy requirement. We implement an open-source version of FlowCog with ∼16,500 lines of code available at https://github.com/ SocietyMaster/FlowCog. Our evaluation results show that FlowCog can achieve a precision of 90.1% and a recall of 93.1%. Let us use a real-world sentence seen commonly in Android apps as an example. Specifically, FlowCog extracts all the noun phrases in the leaf nodes of the hierarchical tree and records all the verb phrases from their ancestors-the verb and the noun phrases form into an action-resource pair. Examples are like "Android" and "App", because they are universal in the context of Android APIs. (ii) FlowCog relies on two machine learning models, namely support vector machine (SVM) and gradient boosting (GB), to classify the generated feature vector as a correlation score. Then, FlowCog converts each element, or called term, in the text vector to its TF-IDF value. Now let us discuss the details about how we use Word2Vec and calculate the similarity score.First, we give some backgrounds about the word embedding model used in Word2Vec, the state-of-the-art and arguably the most popular predictive model to learn word embedding from raw texts. For example, cosine function, which will be defined later in this section, is frequently used as a measure of similarity, so cos( v contact , v connection ) larger than cos( v contact , v rocket ) means the word "contact" is more related to "connection" than "rocket" in the specific model. Similarity(List a , List b ) = M ∑ i=1 N ∑ j=1 w i j · h(s i j ) · s i j(2)where M equals sizeo f (List a ), N equals sizeo f (List b ), and s i j is Similarity( v i , v j ), the similarity score of two vectors as defined in Equation 3. So the most related texts contribute the most to the overall similarity scores.w i j = w(s i j · h(s i j )) = µ k , (0 < µ < 1)where k is kth element in desc_sorted({x|s i j · h(s i j ), iεM, jεN}). The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of NSF.