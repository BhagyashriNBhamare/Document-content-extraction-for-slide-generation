We have systematically evaluated FIBER using 107 real-world security patches and 8 Android kernel images from 3 different mainstream vendors, the results show that FIBER can achieve an average accuracy of 94% with no false positives. Patch presence test, as its name suggests, checks whether a specific patch has been applied to an unknown target, assuming the knowledge of the affected function(s) and the patch itself, e.g., "whether the heartbleed vulnerability of an openssl library has been patched in the tls1 process heartbeat() function". However, since security patches are mostly small and subtle changes [30], similarity-based approaches cannot effectively distinguish patched and un-patched versions.In this paper, we propose FIBER, a complementary system that completes the missing link and takes the similarity-based bug search to the next level where we can perform precise and accurate patch presence test. Second, we generate the binary signatures that preserve as much source-level information as possible, including the patch and the corresponding function as a whole.We summarize our contributions as follows:(1) We formulate the problem of patch presence test under "source to binary", bridging the gap from the general bug search to precise and accurate patch presence test. To overcome the challenge of lack of source-level information, e.g., variable type and name, these solutions need to look for alternative features such as structure of the code [19,13,31]. BinHunt [14] and iBinHunt [24] use symbolic execution and theorem provers to formally verify basic block level semantic equivalence.FIBER is in a unique position that leverages the source-level information to answer a more specific question -whether the specific affected function is patched in the target binary.To our knowledge, Pewny et al.'s work [26] is the only one that claims source-level patch information can be leveraged to generate more fine-grained signatures for bug search (although no implementation and evaluation). 3 To test whether this patch exists in the target binary, naturally we will follow the steps below:Step 1: Pick a change site (i.e., sequence of changed statements). Fig 2 illustrates the system architecture, which is abstracted from human analysts' procedure.It has four primary inputs: (1) the source-level patch information; (2) the complete source code of a reference; (3) the affected function(s) in the compiled reference binary; (4) the affected functions in the target binary. Fortunately, these similarity-based approaches solve this very problem by identifying functions in the target binary that look similar to a reference one, thus the symbol table of the target binary can actually be inferred -in addition to research studies [13,31], BinDiff [2] also has a built-in functionality serving this purpose.We leave the integration of such functionality into FIBER as future work, since all kernel images as test subjects in our evaluation have embedded symbol tables.This shows that the similarity-based bug search and the more precise patch presence test are in fact not competing solutions; rather, they complement each other. Then the search is done by first matching the syntax represented by the topology of a localized CFG related to the patch (a much quicker process), and then the semantic formulas (slower because of the symbolic execution). We do require debug information to be generated (for our reference binary) by compilers that can map the binary instructions back to source level statements as will be discussed in §4.3. This means that the signature should not be overly complex (related to too many source lines), which is more likely to encounter benign changes in the target, creating false matches of the signature.As we can see, the above two seemingly conflicting requirements ask for a delicate balance in signature generation, which we will elaborate in this section. The binary signature simply need to carry this necessary information to recover the semantics present in the source.Informally, we define a binary signature to be a group of instructions, that not only structurally correspond to the source-level signature, but also are annotated with sufficient information (e.g., variable-level semantics) so that they can be unambiguously mapped to the original source-level change site.We will elaborate the translation process in §4.3. For instance, the example source signature in Fig 1 at line 11 encodes the fact that the first function parameter is compared against a field of the last parameter, and this semantic relationship is unique (which we need to preserve in binary signatures). Even if the pointer type matches as char* in the target, it is still inconclusive if it is a patched or un-patched version (we give some real examples in §6 as case studies). Short distance between statements in the source-level signature and the function entrance will accelerate the signature generation process because of its design which we will detail in §4.3. Unlike statements such as a function call, which may get inlined depending on the compiler options, structural changes in general are much more robust.We categorize the source changes into several general types: (1) function invocations (new function call or argument change to an existing call), (2) condition related (new conditional statement or condition change in an existing statement), (3) assignments (which may involve arithmetic operations). We first need to compile the reference source into the reference binary, from which the binary signatures will be generated according to the selected unique source change. However, this is not a good idea in practice as only a subset of instructions actually summarizes the key behavior (data flow semantic); we refer to such instructions as "root instructions". This is sufficient because if the target function indeed Note that from a function's perspective, any operand in an instruction can really be derived from only four sources:(1) a function parameter (external input), e.g., ebp+0x4 if it is x86, X0 or X1 if it is aarch64;(2) a local variable (defined within the function), e.g., ebp-0x8 in x86 or sp+0x4 in aarch64 (which use registers to pass arguments); (3) return values from function calls (external source), e.g., a register holding the return value of a function call; (4) an immediate number (constant), e.g., instruction/data address (including global variables), offset, other constants;These sources all have meaningful semantics at the source level. As an extension, we could use the type of the parameter (as mentioned in §4.2), or even its usage profile to ensure the uniqueness of the parameter. We need to conduct additional binary-level analysis to infer if a target address is pointing to the right basic block (e.g., by checking the similarity of the target basic block), or the offset is pointing to a specific field (e.g., by type inference [21,10]). In our experience, we find that even without having a precise knowledge of these basic elements in the signature, the semantic formula that describe them is typically already unique enough to annotate the operands; ultimately allow us to uniquely map the root instructions to source-level statements. Interestingly, even if we do not perform the above analysis, the fact that there is a root instruction storing a unique formula X0*X1+0x2 to a local variable (any) is already unique enough to be a signature that lead to a correct match in the target.Second, to show that isolated basic block level analysis is not sufficient, we note the mov instruction in the first basic block of the target binary which saves X0 to X3 to free up X0 for the return value of do sth(). Our previous effort in §4.2 to keep a small footprint of the unique source change can also help to improve the binary signature stability here, since the sizes of source change and binary signatures are related. This is a quick pass that intends to match the binary signature by some easy-to-collect features. In this paper, we choose a middle ground.Based on the observations that semantic formulas capture the dependency and therefore the order of instructions cannot be swapped, we know that the structure of formulas is unlikely to change (our evaluation confirms this), e.g., (a+b)*2 will not become a*2+b*2. We implement the prototype of FIBER with 5,097 LOC in Python on top of Angr [29], as it has a robust symbolic execution engine to generate semantic formulas. To generate semantic formulas for root instruction operands, it is necessary to analyze all the binary code from the function entrance to the root instruction. Un-constrained inputs may also lead the execution engine to include infeasible paths in real world execution, however, our goal for semantic formulas is to make them comparable between reference and target binaries, as long as we use the same procedure for both sides, the extracted formulas can still be compared for the purpose of patch presence test. We then crawl the Android security bulletin from June 2016 to May 2017 and collect all published vulnerabilities related security patches 6 for which we can locate the affected function(s) in the reference kernel image (e.g., it may use a different driver than the one gets patched, or the affected function itself may be inlined). To probe the compilation configuration used for the target binary, we first compile multiple reference binaries with all combinations of common compilers (we use gcc and clang) and optimization levels (we use levels O1 -O3 and Os 7 ), then use BinDiff [2] to test the similarity of each reference binary and the target binary, the most similar reference binary will finally be used for binary signature generation. Following this procedure (which is yet to be automated), we observed in our evaluation that kernel 6 and 7 as shown in table 2 use gcc with O2 optimization level, while all other 6 kernels use gcc with Os optimization level, which is confirmed by our inspection of the source code compilation configurations (e.g., Makefile). It is worth noting that our patch collection is oriented to "angler" kernel, which will run on the Qualcomm hardware platform, while kernel 6 and 7 intend to run on a different platform (i.e., Kirin), thus many device driver related patches do not apply for kernel 6 and 7 (we cannot even locate the same affected functions). Some of our signatures (e.g., the signature for CVE-2016-8463) model inline function calls based on the reference kernel image, if the target kernel has a different inline behavior, our signatures will fail to match. However, the contexts may be different across various kernel images due to code customization, although the patch change site remains the same. From the tables, we can see that a small fraction of patches needs much longer time to be matched than average, this is usually because the change sites in these patches are positioned in very large and complex functions (e.g., CVE-2017-0521), thus the matching engine may encounter root instructions deep inside the function. There are 5 patches in our collection that intend to change only the format strings as function arguments.Take the patch for CVE-2016-6752 in Fig 6 as an example, the specifier p is changed to pK. Thus, it will be extremely difficult to differentiate the patched and un-patched functions without the fine-grained signature.FIBER handles this case correctly because the conditional jump is part of the root instruction and we will check the comparison operator associated with it.Patch Backport. However, with the insights of the fine-grained change site, FIBER can correctly figure out that only the value of the 2nd function argument matters in the matching and it should be non-zero if patched, thus effectively handle such cases.Similar Basic Blocks. FIBER has been systematically evaluated with real-world security patches and a diverse set of Android kernel images, the results show that it can achieve an excellent accuracy with acceptable performance, thus highly practical for security analysts.