Unfortunately , the integrity of current systems may be compromised by a single vulnerability, as recently shown by Google's P0 team against Broadcom's WiFi SoC. We present ACES (Automatic Compartments for Embedded Systems) 1 , an LLVM-based compiler that automatically infers and enforces inter-component isolation on bare-metal systems, thus applying the principle of least privileges. Our results show that ACES' compartments can have low runtime overheads (13% on our largest test application), while using 59% less Flash, and 84% less RAM than the Mbed µVisor-the current state-of-the-art compartmentalization technique for bare-metal systems. Attacks against IoT devices have already unleashed massive Denial of Service attacks [30], invalidated traffic tickets [14], taken control of vehicles [23], and facilitated robbing hotel rooms [8]. They execute a single statically linked binary image providing both the (operating) system functionality and application logic without privilege separation between the two. These components can be compromised to gain access to higher level systems, as demonstrated by Google P0's disclosure of vulnerabilities in Broadcom's WiFi SoC that enable gaining control of a smartphone's application processor [6]. Due to the tight constraints, the dominant programming model shuns abstractions, allowing all code to access all data and peripherals without any active mitigations. Even if enabled, the entire address space is readable/writable by the executing program, thus a single bug can be used to trivially disable DEP by overwriting a flag in memory. It uses a fixed algorithm to determine the compartments, providing the developer no freedom in determining the best security boundaries for their application. This results in a daunting challenge for developers, while only achieving coarsegrained data/peripheral compartments.We present ACES (Automatic Compartments for Embedded Systems), an extension to the LLVM compiler that enables the exploration of strategies to apply the principle of least privileges to bare-metal systems. Using these, it automatically applies the policy to the application while satisfying the program's dependencies (i.e., ensuring code can access its required data) and the underlying hardware constraints. Likewise, the automated workflow of ACES frees the developer from challenging implementation issues of the security controls.Our work breaks the coupling between the application, hardware constraints, and the security policy, and enables the automatic enforcement of compartmentalization policies. The policies have modest runtime overhead, on average 15.7% for the strongest policy.In summary, our contributions are: (1) Integrity of code and data for unmodified applications running on bare-metal embedded devices. The created compartments separate code and data, on a sub-thread level, breaking up the monolithic memory space of bare-metal applications. This attacker model is in line with other control-flow hijack defenses or compartmentalization mechanisms.We assume the system is running a single statically linked bare-metal application with no protections. Lack of source code will cause a reduction in precision for the compartmentalization for ACES.ACES applies defenses to: (1) isolate memory corruption vulnerabilities from affecting the entire system; (2) protect the integrity of sensitive data and peripherals. For example, the Cortex-M4 (STM32F479I) [48] device we use in our evaluation has 2MB of Flash in the code area, 384KB of RAM, and uses only a small portion of the peripheral space-and this is a higher end Cortex-M4 micro-controller. The sparse layout requires each area to have its own protection scheme.Memory Figure 2: ARM's memory model for ARMv7-M devices ables setting permissions on regions of physical memory. Each region must be a power of two in size, greater than or equal to 32 bytes and start at a multiple of its size (e.g., if the size is 1KB then valid starting address are 0, 1K, 2K, 3K, etc). Throughout this paper, we use the term, "MPU region" to describe a contiguous area of memory whose permissions are controlled by one MPU register. The limited number of regions requires all code, global variables, stack data, heap data, and peripherals that need to be accessed within a compartment to fit in eight contiguous regions of memory. These regions must satisfy the size and alignment restrictions of the MPU. A compartment is defined as an isolated code region, along with its accessible data, peripherals, and allowed control-flow transfers. Figure 3 shows several compartments, in it Compartment A enables access to code region X and readwrite access to peripheral 1, data region 1, and data region 3. While precise PDGs are known to be infeasible to create-due to the intractable aliasing problem [43], over approximations can be created using known alias analysis techniques (e.g., type-based alias analysis [33]). Edges indicate that a function within the code vertex reads or writes a component in the connected data/peripheral vertices.The initial region graph is created by mapping all functions and data nodes in the PDG along with their associated edges directly to the region graph. The initial region graph does not consider hardware constraints and thus, applies no bounds on the total number of regions created. For example, it may require more data regions than there are available MPU regions, or the performance overhead caused by transitioning between compartments may be too high. Thus, ACES uses a device description to identify all peripherals accessible when the smallest MPU region that covers the two merged peripherals is used. To illustrate, consider two peripherals vertices that are to be merged and a device description containing four peripherals A, B, C, and D at addresses 0x000, 0x100, 0x200, and 0x300 all with size 0x100. Thus, the vertex resulting from merging peripherals B and D, will contain peripherals A, B, C, and D. From a security perspective, if two sets of global variables 񮽙 V 1 and 񮽙 V 2 are placed in the same compartment and in the original program code region C 1 accessed 񮽙 V 1 and C 2 accessed 񮽙 V 2 then unnecessary access is granted-now both code regions can access the entire set of variables. These adjustments may improve the security or the performance of the resulting compartmented binary. After the optimizations are applied, the resulting region graph is lowered to meet hardware constraints. The vertices to merge are determined by a cost function, with the lowest cost merge being taken. ACES generates the appropriate MPU configuration from the final region graph and inserts code during a compilation pass to perform compartment transitions.Ensuring that the proper MPU configuration is used for each compartment is done by encoding each compartment's MPU configuration into the program as read-only data and then on each compartment transition, the appropriate configuration is loaded into the MPU. If authorized, it saves the current MPU configuration and return address to a "compartment stack", and then configures the MPU for the new compartment. A white-list is used to restrict the areas each compartment is allowed to write.An MPU region is used to prevent writing all data above the stack pointer on the stack. Then the micro-emulator, using a white-list of allowed locations, enables selective writes to data above the stack pointer.To generate the white-list, static or dynamic analysis may be used. Whereas dynamic analysis may miss dependencies, potentially leading to broken applications. Runtime enforcement is provided in the form of a C runtime library. To create the PDG it must identify control flow, global variable usage, and peripheral dependencies for each function. We form compartments with this underapproximation and then use the micro-emulator to authenticate access to missed dependencies at runtime (Section 4.6). Using these analyses, ACES creates a PDG suitable for compartmentalization. Compartment creation uses the PDG, a compartmentalization policy, and the target device description to create a final region graph. We envision that the research community could develop these policies, and an application developer would select a policy much like they select compiler optimizations today.The region graph is created from the PDG as outlined in Section 4.1. Code regions dependent on these peripherals must execute in privileged mode; for security, the number and size of such regions should be limited by the policy.To start, we implement two compartmentalization policies, "Peripheral" and "Filename". Thus for an attack to start by exploiting one peripheral and affect another (e.g., compromising a WiFi SOC to get to the application processor) multiple compartments would have to be traversed. It groups all functions and global variables that are defined in the same file into the same compartment.Two optimizations to the region graph can be applied after applying the Filename policy. Merging all code regions with identical data and peripheral dependencies, this reduces compartment transitions at runtime without changing data accessible to any compartments. To instrument the program, all compartment transitions must be identified, each memory region must be placed so the MPU can enforce permissions on it, and the MPU configuration for each region must be added.Using the final region graph, any control edge with a source and destination in different compartments is identified as a compartment transition. The SVC instruction invokes the compartment switching routine, which changes compartments and then, depending on the type of SVC executed, completes the call or return.The compartment pseudo code for the compartment switching routine is shown in Algorithm 1, and is called by the SVC handler. We envision in the future libraries could be distributed as LLVM bitcode instead of machine code, enabling ACES to analyze and instrument the code to create compartments.After instrumenting the binary, ACES lays out the program in memory to enable the MPU to enforce permissions. To minimize this, we disable as many sub-regions of the MPU as possible, while still allowing the current compartment to write to all the unallocated portions of the stack. In addition, the micro-emulator handles all writes where our static analysis under approximates and enables access to areas smaller than the MPU's minimum region size.The micro-emulator can be implemented by modifying the memory permissions to allow access to the fault- ing location and re-executing the store instruction, or emulating the store instruction in software. However, on ARMv7-M devices, it can only be used by the internal software or an external debugger, not both. In record mode (used during training for benign runs), the addresses of all emulated writes are recorded on a per compartment basis. However, as peripherals often have memory mapped configuration register (e.g., setting clock sources) and other registers for performing is function (e.g., sending data). We also compare the ACES' policies to Mbed µVisor, the current state-ofthe-art in protecting bare-metal applications.For each policy, five representative IoT applications are used. They demonstrate the use of different peripherals (LCD Display, Serial port, Ethernet, and SD card) and processing steps that are typically found in IoT systems (compute based on peripheral input, security functions, data sent through peripheral to communicate). TCP-Echo implements a TCP echo server over Ethernet. To illustrate ACES' protections we use PinLock and examine ways an attacker could unlock the lock without entering the correct pin. We assume a write-what-where vulnerability in the function HAL UART Receive IT that can be used to perform any of these attacks. In the Na¨ıveNa¨ıve Filename and Optimized Filename policies the only global variable accessible to HAL UART Receive IT's compartment is a UART Handle, and thus the attacker cannot overwrite key. Directly writing the GPIO registers is similar to overwriting a global variable and requires write access to the GPIO-A peripheral. Which is not accessible to HAL UART Receive IT's compartment under any of the policies.Control-Flow Hijacking: Finally, the attacker can unlock the lock by hijacking control-flow. ACES' runtime support library is the same for all applications and accounts for 1,698 of the instructions added. As many compartments are formed, we find in all cases the number of instructions accessible at any given point in execution is less than the baseline. The Optimized Filename starts from the Na¨ıveNa¨ıve policy and then merges groups together, increasing the amount of privileged code, as privileged code is merged with unprivileged code. Generally, larger numbers of regions indicate better security.Instructions Per Compartment: This metric measures how many instructions are executable at any given point in time, and thus usable in a code reuse attack. The greatest (83.4%) occurs on TCP-Echo with the Na¨ıveNa¨ıve Filename policy, as the TCP stack and Ethernet driver span many files, resulting in many compartments. In all cases, the Na¨ıveNa¨ıve Filename policy has the worst connectivity because the applications make extensive use of abstraction libraries, (e.g., hardware, graphics, FatFs, and TCP). The Optimized Filename policy uses the Na¨ıveNa¨ıve policy as a starting point and relocates functions to reduce external compartment connectivity, but can only improve it so much. The Peripheral policy creates many small compartments with very little connectivity and one compartment with high connectivity.Global Variable Exposure: In addition to restricting control-flow in an application, ACES reduces the number of instructions that can access a global variable. As an example, we compiled Animation using the Optimized Filename policy and 16 MPU regions (lowering to 12 regions). FatFS-uSD formats its SD card, creates a file, writes 1,024 bytes to the file, and verifies the file's contents, at which point profiling stops. LCD-uSD reads and displays 3 of the 6 images provided with the application, as quickly as possible. This is particularly evident on PinLock which has no measurable increase in total execution time for any policy, yet executes over 12,000 compartment entries and exits with the Na¨ıveNa¨ıve and Optimized Filename policies. This is because the small percentage of the time it spends executing compartment switches is hidden by the time spent waiting to receive data on the relatively slow serial port. Consider TCP-Echo: it is written as an application on top of the Lightweight IP Library (LwIP) implementation of the TCP/IP stack [19] and the boards HAL. LwIP uses multiple files to implement each layer of the TCP stack and the HAL uses a separate file to abstract the Ethernet peripheral. In addition to runtime overhead, compartmentalization increases memory requirements by: including ACES's runtime library (compartment switcher, and microemulator), adding metadata, adding code to invoke compartment switches, and losing memory to fragmentation caused by the alignment requirements of the MPU. The compartment stack-ranges from 96 bytes (Peripheral PinLock) to 224 bytes (Optimized Filename Animation)-and the emulator stack uses 400 bytes on all applications. ACES enforces fine-grained compartmentalization by allowing code and data to be isolated within a thread, while Mbed µVisor requires a thread for each compartment with no isolation within a thread. With µVisor, we used two compartments, which logically follows the structure of the application-one compartment handles the IO communication with the serial port and the other handles the computation, i.e., the authentication of the pincode read from the serial port. Mbed µVisor requires specific APIs and a main thread for each compartment, thus there is significant porting effort to get this (and any other application) to execute with µVisor. Averaged across all policies, ACES reduces the Flash usage by 58.6% and RAM usage by 83.9%, primarily because it does not require an OS.ACES runtime is comparable (5.0% increase), thus ACES provides automated protection, increased compartmentalization, and reduced memory overhead with little impact on performance.We investigate the security implications of having code compartmentalization by analyzing the number of ROP gadgets using the ROPgadget compiler [46]. Micro-kernels: Micro-kernels [35,28] implement least privileges for kernels by reducing the kernel to the minimal set of functionality and then implement additional functions as user space "servers". In addition, the process of creating micro-kernels is manual while ACES' compartments are automatic. ACES works on micro-controllers and uses the MPU to ensure that code and data writes are constrained to a compartment without requiring pointer instrumentation. Privtrans [9] uses static analysis to partition an application into privileged and unprivileged processes, using the OS to enforce the separation of the processes. Robinov et al. [44] partition Android applications into compartments to protect data and utilize ARM's TrustZone environment to run sensitive compartments. TyTan [7] builds on Trustlite and develops a secure architecture for low-end embedded systems, isolating tasks with secure IPC between them. In contrast, ACES enables intraprocess compartmentalization on existing hardware and separates compartment creation from program implementation. For security, it is desirable to have long compartment chains, resulting in many compartments that must be compromised to reach the privileged compartment.In conclusion, ACES enables automatic application of compartments enforcing least privileges on bare-metal applications. Its primary contributions are (1) decoupling the compartmentalization policy from the program implementation, enabling exploration of the design space and changes to the policy after program development, e.g., depending on the context the application is run in. (3) Use of a micro-emulator to authorize access to data outside a compartment's memory regions, allowing imprecise analysis techniques to form compartments. Sandia National Laboratories is a multimission laboratory managed and operated by National Technology & Engineering Solutions of Sandia, LLC, a wholly owned subsidiary of Honeywell International Inc., for the U.S. Department of Energys National Nuclear Security Administration under contract DE-NA0003525.