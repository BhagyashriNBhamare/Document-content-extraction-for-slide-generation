This paper presents the first side channel attack approach that, without relying on the cache organization and/or timing, retrieves the secret exponent from a single de-cryption on arbitrary ciphertext in a modern (current version of OpenSSL) fixed-window constant-time implementation of RSA. The approach is demonstrated using electromagnetic (EM) emanations on two mobile phones and an embedded system, and after only one decryption in a fixed-window RSA implementation it recovers enough bits of the secret exponents to enable very efficient (within seconds) reconstruction of the full private RSA key. Finally, not all side channel attacks use analog signals: some use faults [11,25], caches [8,43,44], branch predictors [1], etc.Most of the research on physical side-channel attacks has focused on relatively simple devices, such as smartcards and simple embedded systems, where the sidechannel signals can be acquired with bandwidth much higher than the clock rates of the target processor and other relevant circuitry (e.g. hardware accelerators for encryption/decryption), and usually with highly intrusive access to the device, e.g. with small probes placed directly onto the chip's package [19,35]. The sub-sequences that correspond to large-integer operations produce long sub-sequences of samples, so they 1) are easier to identify in the overall sequence of samples that corresponds to the entire exponentiation, and 2) provide enough signal samples for successful classification even when using relatively low sampling rates.However, the operands in these large-integer operations are each very regular in terms of the sequence of instructions they perform, and the operands used in those instructions are ciphertext-dependent, so classification of signals according to exponent-related properties is difficult unless 1) the sequence of square and multiply operations is key-dependent or 2) the attacker can control the ciphertext that will be exponentiated, and chooses the ciphertext in a way that produces systematically different side channel signals for each of the possible exponentdependent choices of operands. Our results show that our attack approach correctly recovers between 95.7% and 99.6% (depending on the target system) of the secret exponents' bits from the signal that corresponds to a single instance of RSA decryption, and we further verify that the information from each instance of RSA encryption/signing in our experiments was sufficient to quickly (on average <1 second of execution time) fully reconstruct the private RSA key that was used.To further evaluate our attack approach, we apply it to a sliding-window implementation of modular exponentiation in OpenSSL -this was the default implementation in OpenSSL until Percival et al. [39] demonstrated that its key-dependent square/multiply sequence makes it vulnerable to side channel attacks. We show that in this implementation our approach also recovers nearly all of the secret-exponent bits from a single use (exponentiation) of that secret exponent.To mitigate the side-channel vulnerability exposed by our attack approach, we change the window value computation to obtain a full integer's worth of bits from the exponent, then mask that value to obtain the window value, rather than constructing the window value one bit at a time with large-number Montgomery multiplication between these one-bit window-value updates. Unlike many prior attacks on RSA, we do not assume that the adversary can choose (or even know) the message (ciphertext for RSA decryption) to which the private key will be applied, and we further assume that the RSA implementation under attack does utilize blinding to prevent such chosen-ciphertext attacks. This is a very realistic assumption because PKI is typically used only to set up a secure connection, typically to establish the authenticity of the communication parties and establish a symmetric-encryption session key, so in scenarios where the attacker's receiver can only be in close proximity to the target device for a limited time, very few uses of the private RSA key may be observed. The side-channel analysis thus seeks to recover either d or, in CRT-based implementations, d p and d q , using side-channel measurements obtained while exponentiation is performed.The exponentiation is implemented as either left-toright (starting with the most significant bits) or rightto-left (starting with the least significant bits) traversal of the bits of the exponents, using large-integer modular multiplication to update the result until the full exponentiation is complete. A simple implementation of exponentiation considers one exponent bit at a time, as shown in Figure 1, which is adapted from OpenSSL's source code.The BN prefix in Figure 1 stands for "Big Number" (i.e. large integer). A grade-school implementation of BN mod mul thus requires O(n 2 ) limb multiplications, but the Karatsuba multiplication algorithm [30] is typically used to reduces this to O(n log 2 3 ) â‰ˆ O(n 1.585 ), In most modern implementations a significant further performance improvement is achieved by converting the ciphertext to a Montgomery representation, using Montgomery multiplication for BN mod mul during exponentiation, and at the end converting the result r back to the standard representation.Even with Montgomery multiplication, however, the vast majority of execution time for large-number exponentiation is spent on large-number multiplications, so performance optimizations focus on reducing the number of these multiplications. In the naive implementation above, an occurrence of squaring tells the attacker that the next bit of the exponent is being used, and an occurrence of multiplication indicates that the value of that bit is 1, so an attack that correctly recovers the square-multiply sequence can trivially obtain all bits of the secret exponent.To improve performance, most modern implementations use window-based exponentiation, where squaring is needed for each bit of the exponent, but a multiplication is needed only once per a multi-bit group (called a window) of exponent bits. Additional techniques [10,28] have been shown to recover the full RSA private key once enough of the exponent bits are known, and for wmax = 4 this has allowed full key recovery for 28% of the keys [10]. Because this sliding-window implementation uses each bit of the exponent to make at least one control flow decision, highly accurate control flow reconstruction amounts to discovering the exponent's bits with some probability of error.Concerns about the exponent-dependent squaremultiply sequences have led to adoption of fixed window exponentiation in OpenSSL, which combines the performance advantages of window-based implementation with an exponent-independent square-multiply sequence. For example, Genkin et al. [23,24] construct a ciphertext that produces many zero limbs in any value produced by multiplication with the ciphertext, but when squaring such a many-zerolimbed value the result has fewer zero limbs, resulting in an easily-distinguishable side channel signals whenever a squaring operation (BN mod mul(r,r,r,m) in our examples) immediately follows a 1-valued window (i.e. when r is equal to r prev * c mod m). However, chosen-ciphertext attacks can be prevented in the current implementation of OpenSSL by enabling blinding, which combines the ciphertext with an encrypted (using the public key) random "ciphertext", performs secret-exponent modular exponentiation on this blinded version of the ciphertext, and then "unblinding" the decrypted result.Overall, because large-integer multiplication is where large-integer exponentiation spends most of its time, most of the side-channel measurements (e.g. signal samples for physical side channels) also correspond to this multiplication activity and thus both attacks and mitigation tend to focus on that part of the signal, leaving the (comparably brief) parts of the signal in-between the multiplications largely unexploited by attacks but also unprotected by countermeasures. Specifically, the 40 MHz bandwidth is well within the capabilities of Ettus USRP B200-mini receiver, which is very compact, costs less than $1,000, and can receive up to 56 MHz of bandwidth around a center frequency that can be set between 70 MHz and 6 GHz, and yet the 40 MHz bandwidth is sufficient to recover nearly all bits of the secret exponent from a single instance of exponentiation that uses that exponent.We then apply AM demodulation to the received signal, and finally upsample it by a factor of 4. Upsampling allows us to re-align these signals with higher precision, and we found that 4-fold upsampling yields sufficient precision for our purposes. It includes part of one large-number multiplication (Line 7 in Figure 3), which in OpenSSL uses the Montgomery algorithm and a constant-time implementation designed to avoid multiplicand-dependent timing variation that was exploited by prior side-channel attacks. Such signal matching works best when looking for a snippet that has prominent features, so they are unlikely to be obscured by the noise, and whose prominent features occur in a pattern which is unlikely to exist elsewhere in the signal. Because this method of identifying the relevant snippets of the signal is based on the signal that corresponds to the Montgomery multiplication that precedes each relevant snippet, the same method can be used for extracting relevant signal snippets for both fixed-window and sliding-window exponentiation -in both cases the relevant snippet is at the (same) fixed offset from the point at which a prominent-enough peak is detected in the derivative of the signal's moving median. Both control flow possibilities involve updating the window value to include another bit from the exponent (lines 8, 9, and 10), and at line 6 incrementing i and checking it against w, the maximum size of the window. In OpenSSL's implementation the ct is kept in a scattered format to minimize leakage of wval through the cache side channel while computing the Montgomery multiplication, so instead the value of wval is used to gather the scattered parts of ct[wval] into a preallocated array that is passed to Montgomery multiplication. Since this pre-allocated array is used for all resultupdate multiplications, memory and cache behavior during the Montgomery multiplication no longer depend on wval. In such cases, sole reliance on the known sequence of control flow possibilities would cause a "slip" between the observed sequence and the expected one, causing us to use incorrect reference signals to recover bits of the exponent and to put the recovered bits at incorrect positions within the recovered exponent.The classification into the four possibilities is much more reliable than recovery of exponent's bits. The S-S and U-S snippets both involve only a few instructions between Montgomery multiplications so they are harder to tell apart, but our signal matching still has a very high accuracy in distinguishing between them.After individual snippets are matched to the four possibilities, that matching is used to find the most likely mapping of the sequence of snippets onto the known valid sequence. A naive solution would be to assign a random value to that bit (with a 50% error rate among missing bits). However, for full RSA key recovery missing bits (erasures, i.e. the value of the bit is known to be unknown) are much less problematic than errors (the value of the bit is incorrect but not known a priori to be incorrect), we label these missing bits as erasures.Finally, for S-S and S-U snippets we perform additional analysis to recover the bit of the exponent that snippet corresponds to. We alleviate this problem by forming separate references for different bit-positions within the window, e.g. for window size w = 5 each value of bval would have 4 sets of S-S snippets and one set of S-U snippets, because the first for bits in the window correspond to S-S snippets and the last bit in the window to an S-U snippet. To account for other value-dependent in the signal, in each such set of snippets we cluster similar signals together and use the centroid of each cluster as the reference signal. Thus the final step of our analysis involves finding the closest match (using Euclidean distance as a metric) among these 20 reference snippets and taking the bval associated with that reference snippet. The other transitions are S-U, which consumes more time because it performs the ct [wval] computation; U-Z, which involves executing line 31, line 3, line 4 (where a bit of the exponent is examined), and finally entering Montgomery multiplication at line 7; U-S, which involves executing line 31, line 3, line 4, lines 11 and 12, and the entire window-scanning loop at lines 14-23, then line 25 and finally entering Montgomery multiplication at line 26; Z-Z where after line 7 the execution proceeds to line 8, line 9, line 3, line 4, and line 7 again; Z-S where after line 7 the execution proceeds to lines 8, 9, 3, 4, and then to lines 11 and 12, the loop at line 14-23, then line 25 and finally line 26; U-X where after the Montgomery multiplication at line 29 the execution proceeds to line 31 and then exits the loop at line 3; and finally S-X, where after Montgomery multiplication at line 7 the execution proceeds to lines 8 and 9 and then exits the loop at line 3. However, in contrast to work in [10] that could only distinguish between a squaring (line 7 or line 26, i.e. S or Z in our sequence notation) and an update (line 29, U in our sequence notation) using memory access patterns within each Montgomery multiplication (which implements both squaring and updates), our method uses the signal snippets between these Montgomery multiplica-tions to recover more detailed information, e.g., for each squaring our recovered sequence indicates whether it is an S or a Z, and this simplifies the rules for recovery of exponent's bits and allows us to extract more of them. Then, after S-U, we observe U-Z, which indicates that the bit after the window is 0-valued (which we have already deduced), then two occurrences of Z-Z indicate two more 0-valued bits (one of which we have already deduced), and finally Z-S indicates that a new non-zero window begins, i.e. the next bit is 1. In our experiments, when using wmax = 5 this analysis alone on average recovers 68% of the secret exponent's bits, and with using wmax = 6, another commonly used value for wmax, this analysis alone on average recovers 55% of the exponent's bits. Like Bernstein et al. [10], we recover from the side channel signal only the bits of the private exponents d p and d q , and the recovery of the full private key relies on exploiting the numerical relationships (Equations (1) in Bernstein et al. [10]) between these private exponents (d p and d q ), the public modulus N and exponent e, and p and q, the private factors of N:ed p = 1 + k p (p âˆ’ 1) mod 2 i ed q = 1 + k q (q âˆ’ 1) mod 2 i pq = N mod 2 iwhere k p and k q are positive integers smaller than the public exponent e and satisfy (k p âˆ’ 1)(k q âˆ’ 1) â‰¡ k p k q N mod e. Such branch-andprune search has been shown to be efficient when up to 50% of the bit-positions (chosen uniformly at random) in d p and d q are erasures, while its running time grows exponentially when the erasures significantly exceed 50% of the bit positions.Henecka's algorithm [27] can be applied with the above pruning equations to recover the private key when some of the bits are in error. This is similar to adjusting the value of Îµ in Henecka's algorithm and retrying, except that the work of previous tries is not repeated, and this low cost of relaxing the error tolerance allows us to start with a low error tolerance (large Îµ in Henecka et al.) and adjust it gradually until the solution is found.We further modify Henecka's algorithm to, rather than expand a partial key by multiple bits (parameter t in Henecka et al.) at a time, expand by one bit at a time and, among the newly created partial keys, only further expand the lowest-recent error-count ones until the desired expansion count (t) is reached. Overall, our actual implementation of this modified algorithm is very efficient -it considers (expands by one bit) about 300,000 partial keys per second using a single core on recent mobile hardware (4th generation Surface Pro with a Core i7 processor), and for low actual error 1000 10000 100000 1000000 0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% Errors Erasures 50% Mix Figure 6: Single-bit expansion steps needed to reconstruct the private RSA key (vertical axis, note the logarithmic scale) as a function of the rate at which errors and/or erasures are injected (horizontal axis). We evaluate its ability to reconstruct private RSA keys using d p and d q bits that contain errors and/or erasures by taking 1,000 RSA keys, introducing random errors, random erasures, and a halfand-half mix of errors and erasures, at different error/erasure rates, and counting how many partial keys had to be considered (expanded by a bit) before the correct private key was reconstructed. In this section we describe our measurement setup and obtained results for recovering keys from blinded RSA encryption runs on three different devices. We run the OpenSSL RSA application on Android smart phones Samsung Galaxy Centura SCH-S738C [40] and Alcatel Ideal [4], and on an embedded device (A13-OLinuXino board [37])) . OpenSSL uses a fixed window size w = 5 for exponentiation of this size.Note that RSA decryption involves another exponentiation, with d q , and uses the Chinese Remainder Theorem to combine their results. For each device, our training uses signals that correspond to 15 decryption instances, one for each of 15 randomly generated but known keys, and with ciphertext that is randomly generated for decryption. Thus for larger RSA keys we expect that even fewer decryptions would be needed for training.After training we perform the actual attack. This is an expected result, given that even the worst bit recovery rates (for the Alcatel phone) correspond to a an error rate of about 1.5%, combined with an erasure rate of typically 1.5% but sometimes as high as 3% (depending on how much system activity occurs while RSA encryption is execu- 1 The OLinuXino boards are much less expensive than the phones, so we could easily obtain a number of OLinuXino boards The maximum, median, and minimum success rate among decryption instances (each with a different randomly generated key) is shown for recovery that only uses the snippet-type sequence (S-M-Z Sequence), and for recovery that also recovers window bits from U-S and Z-S snippets (Overall). Since sliding-window recovery tries to extract several times more information from about the same amount of signal change, its recovery is more affected by noise and thus slightly less accurate. In this regard, the attack benefits significantly from 1) the limited space of possibilities for value returned by BN is bit setthere are only two possibilities: 0 or 1, and from 2) the fact that the computation that considers each such bit is surrounded by computation that operates on highly predictable values -this causes any signal variation caused by the return value of BN is bit set to stand out in a signal that otherwise exhibits very little variation.Based on these observations, our mitigation relies on obtaining all the bits that belong to one window at once, rather than extracting the bits one at a time. The approach is demonstrated using electromagnetic (EM) emanations on two mobile phones and an embedded system, and after only one decryption in a fixed-window RSA implementation it recovers enough bits of the secret exponents to enable very efficient (within seconds) reconstruction of the full private RSA key.Since the value of the ciphertext is irrelevant to our attack, the attack succeeds even when the ciphertext is unknown and/or when message randomization (blinding) is used. We thank the anonymous reviewers for their very helpful comments and recommendations on revising this paper, and the developers of OpenSSL for helping us merge our mitigation into OpenSSL's source code repository on GitHub.