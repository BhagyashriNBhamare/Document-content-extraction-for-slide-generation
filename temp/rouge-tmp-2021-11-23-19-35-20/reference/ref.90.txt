Intel recently introduced Software Guard Extensions (SGX), which aim at strongly isolating sensitive code and data from the operating system, hypervisor, BIOS, and other applications. SGX is especially useful in cloud scenarios as it ensures isolated execution of code and data within an untrusted computing environment.SGX was designed to allow developers to protect small parts of their application that handle sensitive data, e.g., cryptographic keys, inside SGX containers called enclaves. The enclave can subsequently perform sensitive computations, call pre-defined functions in the host, and return to the caller.In the ideal scenario, the enclave code only includes minimal carefully-inspected code, which could be formally proven to be free of vulnerabilities. The oracles inform the attacker about the internal status of the enclave execution, whereas ROP maliciously re-uses benign code snippets (called gadgets) to undermine non-executable memory protection. Hence, to address the Dark-ROP attack, Seo et al. demonstrated an implementation of SGX randomization called SGX-Shield [26], since this attack is not effective if the SGX code is randomized. Finally, architectural limitations in SGX 1 force randomized code to be executed from writable pages, thus allowing simpler code-injection. In summary, our main contributions are:• We propose two new code-reuse attacks against enclaves built on top of the Intel SGX SDK. • To demonstrate that our new attacks are powerful, we show that they are effective and practical against SGX-Shield [26], a state-of-the-art fine-grained randomization solution for SGX enclaves (Section 7). Lee et al. [20] abuse collisions within the branch predictor to infer whether a branch inside the enclave has been taken. In response, Van Bulck et al. [29] proposed an attack that can monitor memory accesses at page granularity without interrupting the enclave. Dark-ROP [19] is a code-reuse attack that makes return-oriented programming (ROP) [27] possible against encrypted SGX enclaves. Haven [1,2] and VC3 [24] deploy a symmetrically encrypted enclave along with a loader which will receive the key through remote attestation. However, in this paper, we present exploits that undermine these mitigation techniques under weak adversarial assumptions. As such, mechanisms are required to switch between untrusted and trusted execution modes, as shown in Figure 1. Just like EENTER, EEXIT does not clear CPU registers, thereby allowing trusted code to pass data to untrusted code. An enclave can also exit because of a hardware exception (such as an interrupt), which needs to be handled by the kernel in untrusted mode. Two SDK-provided libraries are vital for our attack and the correct execution of SGX code: the Trusted Runtime System (tRTS) and the Untrusted Runtime System (uRTS). The tRTS and uRTS interact with each other to handle the transitions between trusted and untrusted execution modes. Once the function returns, it performs a synchronous exit (EEXIT) to give control back to the uRTS. An enclave must expose at least an ECALL, otherwise there is no way to invoke enclave code: from the programmer's perspective, an enclave's code always executes in ECALL context. The tRTS first pushes an OCALL frame onto the trusted thread stack, which stores the current register state (step 2). Next, it performs a synchronous enclave exit to return from the current ECALL, passing the OCALL index back to the uRTS (step 3). Upon an exception (e.g., invalid memory access, division by zero) an asynchronous enclave exit (AEX) occurs, which saves the faulting state to the state save area (SSA). The resulting interrupt is handled by the kernel, which delivers an exception to the untrusted application by means of the usual exception mechanism of the OS (e.g., signals in Linux-based systems, structured exception handling in Windows). If a handler succeeds, the tRTS uses a function named continue execution to restore the CPU register context from the exception information, thus resuming enclave execution. Previous work on SGX [19,26] has considered a very strong adversarial model: the attacker has full control over the machine, e.g., through a malicious kernel. An attacker could also possibly achieve this via normal functionality, for example by steering the application or the enclave into allocating attacker-controlled data at predictable addresses. • Knowledge of coarse-grained memory layout.The attacker knows the victim enclave's external memory layout, i.e., its virtual address range. Recall that existing memory corruption attacks against SGX, e.g., Dark-ROP [19], are mitigated by SGX-Shield. This is along the lines of any other common code-reuse attack such as return-oriented programming. Controlling registers is essential in any code-reuse attack. In fact, our attacks allow the attacker to use whole functions as building blocks instead of small gadgets, allowing her to work on a higher level and making it easier to port the exploit between different versions of a binary.Our attacks abuse functionality in tRTS, a fundamental library of the Intel SGX SDK, which most enclaves use (Section 5). This primitive is based on abusing the function asm oret from the tRTS library in the Intel SGX SDK. The prerequisites for this primitive are control of the instruction pointer (to hijack execution to asm oret) and control of stack contents. The ORET primitive gives control of a subset of CPU registers, including the register that holds the first function argument (rdi) and the instruction pointer.CONT primitive. This primitive abuses the function continue execution from the tRTS, which is meant to restore the CPU context after an exception. Our attack supports classic ROP gadgets, i.e., code sequences ending with a return instruction, and any subroutine for function-reuse attacks. Note that, even if the main enclave code is randomized, it is very difficult to randomize all the enclave code (Section 8) and the nonrandomized code contains enough gadgets to successfully mount an attack (Section 7). In addition to the payload gadgets, the attacker has to determine the offsets of asm oret and continue execution (both in the tRTS) to apply our attack.Step 2: Fake structures preparation. Our primitives work by abusing functions intended to restore CPU contexts by tricking them into restoring fake contexts, thus gaining control of the registers. On the other hand, it contains fake contexts for the transition from the ORET primitive to the CONT primitive to continue the loop.Step 3: Attack execution. Since it can be used to set the first function argument register and the instruction pointer, the attacker now has the controlled function call needed for CONT and can trigger the loop.Gadget ORET CONT ORET+CONT loop · · · · · · · · · · · · · · · · · · · · · · · ·Fake stack Fake exc. info 3 Gadget 3. . . . . .2 Fake structures prep. Our ORET primitive abuses the asm oret function, used in the OCALL/ORET mechanism to restore the CPU context from the OCALL frame saved on the stack. This capability is important for the ORET+CONT loop, and additionally allows to bootstrap our attack from a stack overflow vulnerability, as will be shown towards the end of this section.The exact values of rsp and rip after asm oret depend on the SGX SDK version. Note that those addresses do not necessarily have to point to stack memory, nor to enclave memory, as enclaves can access untrusted memory.The first operation done by asm oret is shifting the stack pointer to the sp argument, i.e., the top of the OCALL frame. On SGX SDK versions earlier than 2.0, the stack pointer is shifted with a single instruction, mov rsp, rdi, at the beginning of asm oret. Starting with version 2.0 of the SDK, the code is more complex, as it also handles other tasks (such as restoring the extended processor state) before restoring the registers we are interested in. The CONT primitive is based on continue execution, a function used in the exception handling mechanism to restore a CPU context from an exception information structure, thus allowing exception handlers to change CPU register values. In comparison, continue execution provides more control than asm oret as the context it restores encompasses all general-purpose CPU registers.The prototype of this function is void continue execution(sgx exception info t *info), where info is a pointer to the exception information structure that contains the CPU context to restore. Notably, the stack pointer (rsp) and the instruction pointer (rip) are part of this context. Since rsi can be controlled anyway (through r15), and r8-r15 are temporary registers that are not typically of interest to an attacker, this issue does not reduce the power of continue execution reuse significantly.As an example, continue execution can be reused by corrupting a function pointer and hijacking it to point to continue execution. Given those preconditions, the attacker can call continue execution with a fake sgx exception info t structure and gain full CPU context control.In another scenario, the attacker only has stack control, for example because of a stack overflow vulnerability. Since that primitive grants control of rdi and of the instruction pointer, the attacker can chain continue execution to get full register control. The context is crafted to launch a CONT primitive for the next gadget to continue the loop.Using the ORET+CONT combination is necessary because the attacker might want to control rdi, or the gadget might corrupt it; therefore, chaining CONT to CONT directly might not be possible. Note that from SDK version 2.0, the ORET context has to set rbp properly as detailed in Section 6.2.1 to control the instruction pointer.Fake exception information. To do this, the attacker points rdi in the first CONT to the fake exception information for the second CONT, and returns to continue execution from the gadget via the fake stack, as shown in Figure 7. Note that, as explained in Section 6.2.1, ORET might or might not be able to pivot the stack depending on the SDK version. SGX-Shield is a hardening solution for SGX enclaves, which integrates multiple mitigation technologies:• Fine-grained randomization. The enclave code is split up in 32-or 64-byte chunks, called randomization units, and each randomization unit is placed at an independent, randomized memory position aligned to its size. • Coarse-grained Control Flow Integrity. Control transfers are instrumented to force them to target the beginning of a randomization unit, so that checks cannot be circumvented by jumping in the middle of a randomization unit.SGX does not support changing memory permissions for memory mappings after enclave initialization. Unfortunately, we identified significant differences between the SGX-Shield paper [26] and the open source implementation [25] (commit 04b09dd, 2017-09-27). However, in the current design, the loader supplies the tRTS for the guest enclave. As such, we assume that backwards-edge CFI is not present.Hence, for our exploits explained in the remainder of this section, we do not consider backward-edge CFI protection or the absence of the tRTS. We assume that the attacker has discovered a stack overflow vulnerability in the hardened enclave. The general idea is to use a multi-stage exploit, i.e., utilize our new code-reuse techniques to initiate a code-injection attack. As such, the exploit will be divided in two stages: the first stage, based on code reuse, injects the second-stage code, also known as shellcode. In the case of SGX-Shield, such a function might be randomized, or placed in SDK libraries that are not essential for the guest enclave and could be erased. Our chain repeatedly invokes this gadget to write the shellcode 4 bytes at a time, followed by invocation of the shellcode.Since the only gadget we use preserves rdi, we can use the simplification described in Section 6.2.4 to only chain CONTs. Hence, the shellcode can be simplified by omitting register initialization.Step 2: Fake structures preparation. A sgx exception info t structure is set up for the shellcode, with rip set to the shellcode's 1 mov dword ptr [ rcx ] , eax 2 mov eax , 1 3 ret Listing 4: Memory write ROP gadget from do rdrand in tRTS. • rdi points to the next sgx exception info t structure in the write sequence; if this is the last one, rdi points to the fake exception information for the shellcode. • rip points to the write gadget.Step 3: Attack execution. In our case, we extract the cryptographic keys used during the remote attestation process through the shellcode in Listing 5 in Appendix A. Once an attacker is in possession of those keys, she can impersonate the enclave when communicating with the remote server.The keys are obtained with the EGETKEY leaf function. Both the EREPORT and the EGETKEY leafs only operate on enclave memory, so the shellcode has to take care of copying data in and out of the enclave. The filled TARGETINFO and REPORTDATA structures are copied from attacker-controlled memory into enclave memory, along with a partially filled KEYREQUEST.2. Further, our attack is even able to undermine SGX-Shield, a strong hardening scheme for SGX enclaves. Consequently, we believe future mitigation schemes must take into serious consideration the implications of leaving SDK code easily accessible to attackers.Our attack also draws a parallel to Sigreturn Oriented Programming (SROP) [4] in the SGX world. However, at the callsite, rcx is set based on values that can be controlled via ORET.While analyzing the low-level internals of our primitives in the Linux SDK, we also noticed several differences between SDK versions that influence our exploits:• Setting the instruction pointer in asm oret differs before and after version 2.0. • In SDKs prior to 1.6, continue execution suffers from a bug that results in registers r8 to r15 not being set properly. We argue that simply randomizing the SDK is not a trivial task for several reasons: first, fine-grained randomization of the tRTS likely requires manual intervention. The tRTS in the SDK provides the entry point code, from which the enclave starts executing when entered through EENTER. We expect the runtime overhead of the extra entry point indirection to be completely negligible.Our attack also exploits the backwards-edge CFI issues in SGX-Shield to hijack the control flow. On the other hand, we discuss considerations for designing hardening schemes.The first avenue to mitigate our attack is hardening the SDK. This method is much stronger than just embedding a secret, and its overhead would be negligible in our case, as the structures we target are not accessed very often.The second mitigation avenue is taking the SDK code base into serious consideration when designing hardening schemes. Intel Software Guard Extensions (SGX) is a promising processor technology providing hardware-based support to strongly isolate security-critical code inside a trusted execution environment called enclave. e1 ; Initial r e g i s t e r state : 2 ; rax = 0 ( EREPORT leaf ) 3 ; rbx = EEXIT return address 4 ; rcx = 5 1 2 + 5 1 2 + 6 4 5 ;( total size of s t r u c t u r e s ) 6 ; rdx = w r i t a b l e 512 -byte aligned enclave 7 ;area for t e m p o r a r y data 8 ; rdi = w r i t a b l e 512 -byte aligned enclave 9 ; area to copy s t r u c t u r e s into 10 ; rsi = address of a t t a c k e r 's K E Y R E Q U E S T + 11 ;T 14 push rbx 15 push rdi 16 ; Copy KEYREQUEST , TARGETINFO , 17 ; R E P O R T D A T A to enclave memory 18 rep movsb 19 ; EREPORT 20 lea rcx 1 ; Initial r e g i s t e r state : 2 ; rax = 0 ( EREPORT leaf ) 3 ; rbx = EEXIT return address 4 ; rcx = 5 1 2 + 5 1 2 + 6 4 5 ;( total size of s t r u c t u r e s ) 6 ; rdx = w r i t a b l e 512 -byte aligned enclave 7 ;area for t e m p o r a r y data 8 ; rdi = w r i t a b l e 512 -byte aligned enclave 9 ; area to copy s t r u c t u r e s into 10 ; rsi = address of a t t a c k e r 's K E Y R E Q U E S T + 11 ;T 14 push rbx 15 push rdi 16 ; Copy KEYREQUEST , TARGETINFO , 17 ; R E P O R T D A T A to enclave memory 18 rep movsb 19 ; EREPORT 20 lea rcx