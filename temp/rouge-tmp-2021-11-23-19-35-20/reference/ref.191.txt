Concretely, we present novel precomputation techniques for correlated oblivious transfers (reducing the online communication by factor 2x), Cuckoo filter compression (with a compression ratio of ≈ 70 %), as well as 4.3x smaller Cuckoo filter updates. In a protocol performing oblivious PRF evaluations via garbled circuits, we replace AES as the evaluated PRF with a variant of LowMC (Albrecht et al., EUROCRYPT'15) for which we determine optimal parameters, thereby reducing the communication by factor 8.2x. Furthermore, we implement both protocols with security against malicious clients in C/C++ and utilize the ARM Cryptography Extensions available in most recent smartphones. The on-line phase of our fastest protocol takes only 2.92 s measured on a real WiFi connection (6.53 s on LTE) to check 1,024 client contacts against a large-scale database with 2 28 entries. As a proof-of-concept, we integrate our protocols in the client application of the open-source messenger Signal. In general, secure two-party computation allows parties P 1 and P 2 to jointly compute a publicly known function f on their respective inputs X 1 and X 2 s.t. the parties learn no information from the protocol execution but the result. This is because the online phase of these protocols (which depends on the actual inputs) has a computation and communication complexity that is linear in the size of the larger set.Therefore, other PSI protocols for the case of unbalanced set sizes were developed (e.g., [19,21,40,59]). For example, their fastest protocol that can easily be made secure against malicious clients requires more than 52 s on a smartphone with WiFi connection to check a single client contact against a database with only 2 20 entries.The developers of Signal, a mobile messaging service similar to WhatsApp but with focus on privacy, considered the use of PSI protocols for contact discovery. In contrast, fixes for flawed implementations of provably secure cryptographic protocols can be deployed quickly via software updates.Thus, we revisit state-of-the-art unbalanced PSI protocols which provide cryptographic security and show that using new optimizations and native implementations they turn out to be practical on modern smartphones. For this, we conduct a survey where we analyze privacy policies, source code, and network traffic. Our results show that in practice none of these applications protect the users' privacy during contact discovery.We optimize two protocols for unbalanced PSI that can easily be made secure against malicious clients and are suitable for private contact discovery: one that uses oblivious evaluations of the Naor-Reingold PRF (NR-PSI, cf. [31,40,47]) and one that uses Yao's garbled circuits (GC-PSI, cf. [40,52,56]) to run oblivious AES evaluations. We overcome further shortcomings of previous works w.r.t security and scalability by evaluating the implementations using recommended security parameters, reasonable false positive probabilities, and considering large-scale set sizes on the server side.Our fastest protocol takes only 2.92 s measured on a real WiFi connection (6.53 s on LTE) and 6.07 MiB of communication in the online phase to check 1,024 client contacts against a database with 2 28 entries (more than the number of monthly active users for popular messengers like Telegram [61]). To remain practical for even larger set sizes (the market leader WhatsApp currently has more than 1.6 billion users [61]), we suggest multiple extensions, e.g., combining our protocols with multi-server PIR s.t. the overall client-server communication complexity becomes logarithmic in the size of the server database.As a proof-of-concept, we integrate both of our protocols in the Signal Android client, thereby positioning our secure cryptographic approach as a practical alternative to vulnerable trusted execution environments like Intel SGX. Furthermore, even if the server cannot determine the actual contact data, it can still tell whether two users share a contact by comparing uploaded hash values.This can be somewhat mitigated by using salted hashing s.t. the hashes received by the server are different whenever a client triggers contact discovery. However, only one of the surveyed messengers employs this approach as it requires to Table 1: Results of our contact discovery survey on secure mobile messengers. Kiss et al. [40] discuss multiple unbalanced PSI protocols with precomputation (cf. §3.5) and security against semi-honest adversaries. In our work, we present C/C++ implementations that make use of the hardware-accelerated cryptography available in most recent smartphones.Resende and de Freitas Aranha [59] use techniques similar to [40], but replace Bloom filters [12] with the more efficient and versatile Cuckoo filters [27] to efficiently represent the encrypted server database (cf. §3.4) in a Diffie-Hellman style PSI protocol [7] with security against semi-honest adversaries. However, even if servers are malicious and/or collude, they cannot learn more about client inputs than in currently deployed naive hashing-based contact discovery methods.Chen et al. [19] give a PSI protocol based on fully homomorphic encryption. Their implementation managed to evaluate ≈ 100 AND gates per second, taking about 10 min to intersect two sets of 256 items each.Asokan et al. [6] implemented an RSA-based PSI protocol with security against semi-honest adversaries on smartphones for secure mobile resource sharing.Carter et al. [17] presented a maliciously secure system for secure outsourced garbled circuit evaluation on mobile devices. "PROUD" [49] is a decentralized approach for private contact discovery based on the DNS system. Oblivious transfer (OT) [57] is a cryptographic protocol that in its most basic form allows a sender P 1 to obliviously transfer one out of two messages (m 0 , m 1 ) to a receiver P 2 based on a selection bit b chosen by P 2 s.t. P 1 learns nothing about b and P 2 learns only m b but nothing about m 1−b . However, to ensure input privacy for the evaluator, the wire labels corresponding to the evalutor's input bits are retrieved via OTs. Several optimizations for Yao's original scheme have been presented s.t. today it is most efficient to combine the following techniques: Point-and-Permute [10], Free-XOR [42], fixed-key AES garbling [11], and Half-Gates [63]. Additionally, it is guaranteed that P 1 does not learn anything about x and P 2 does not learn anything about k.OPRF evaluations can be used to build PSI protocols as proposed in [28,30,40,52]: The server samples a key k uniformly at random, evaluates the PRF f k (x i ) on each of its items x i ∈ X, and sends the results to the client. The client then outputs the elements y j corresponding to the values in the intersection.In this work, we instantiate the PRF either using the NaorReingold PRF [47] (NR-PSI) or a garbled circuit-based evaluation of a block cipher (GC-PSI). Resende and de Freitas Aranha [59] first used Cuckoo filters in a PSI protocol. This is due to several advantages over Bloom filters when representing the server's database, namely they (i) support inserting and deleting items subsequently, whereas standard Bloom filters only support inserting items, and variants that do support deletion such as counting Bloom filters have much higher storage costs; (ii) have better lookup performance; and (iii) use less space in many scenarios while having the same false positive probability.Cuckoo filters consist of a table of buckets with fixed bucket size b. Inside the buckets, so-called tags are stored. For private contact discovery, the following properties are desired: (i) the server performs the computationally expensive tasks; (ii) all computationally expensive and communication intensive tasks are performed only once; and (iii) the actual intersection computation is very fast and also allows for efficient updates. (iii) During the online phase client and server jointly perform OPRF evaluations on all elements of the client. (iv) Changes in the server database trigger the update phase, where the Cuckoo filter on the client side is updated by sending a small delta for each inserted or deleted database entry.PSI protocols, enable security against malicious clients, and suggest multiple extensions to further increase practicality. We find this FPP not practical since it implies that about one in 10 clients performing PSI for 2 10 elements receives a false positive.Instead, we propose to use tagsize v = 32 to reach a FPP of ε max ≈ 2 −29 or tagsize v = 42 to reach a FPP of ε max ≈ 2 −39 while still maintaining a bucket size of b = 3. This is possible since the actual position of each tag within a bucket is not important.This compression technique is especially useful for very sparse Cuckoo filters, which appear in use cases where the set of items is expected to grow fast (e.g., during the release phase of a new messaging application). For example, if only 10 % of a Cuckoo filter storing a maximum of 2 20 items is occupied, it can be compressed by a factor of 8.3x.In concurrent and independent work, Breslow and Jayasena [15] proposed Morton filters, which combine these compression techniques with cache-optimized layouts and further optimizations. Several improvements for Yao's GC protocol [62] have appeared in recent years that changed the desired properties of the functions to be evaluated. Most notably is the Free-XOR [42] optimization, which allows XOR gates to be evaluated securely "for free", meaning all necessary operations can be performed locally without any communication between the parties. Using the optimized S-Box implementation of [13], an AES-128 circuit (without key schedule) has 5,120 AND gates [32], serving as a baseline for comparison.In this section, we focus on variants of LowMC [2], a highly parameterizable block cipher designed for use cases in multiparty computation (MPC) and fully-homomorphic encryption (FHE). We look at several instantiations of LowMC and present optimized parameter sets specifically for the use case of GC-PSI and mobile contact discovery. In many MPC applications using OPRF evaluations, one party knows the entire secret key and can, therefore, perform any key-scheduling algorithm (e.g., for AES or LowMC) offline. However, when performing OPRF evaluations using garbled circuits, the party holding the secret key needs to send wire labels for each input bit, increasing the communication. We can observe some interesting properties: LowMC instances (1) and (2) require the same number of rounds to be secure, but instance (1) [22], the large number of linear layer computations can be reduced, bringing the evaluation time of (3) close to (1) and (2). For use cases with small data complexity requirements, we recommend LowMC instance (4), which is a small improvement of 8.3 % in runtime and communication compared to (3). This is because in the online phase when using OT precomputation [8], the random messages r 0 and r 1 obtained by the sender in the base phase need to be swapped ( PRF i k , l 0 i,1 , . . . , l 0 i,α ) = GC.Build(PRF, k, r 0 i,1 , . . . , r 0 i,α , ∆) PRF i kInitialize Cuckoo filter CF with parameters N s , ε, v, b Setup Phasefor i = 1 to N S : CF.Insert(PRF k (x i )) CF for i = 1 to N C :Online Phase for i = 1 to N C :for j = 1 to α: for j = 1 to α: in case the random choice made by the receiver differs from its actual input. As one can easily verify for the four possible combinations of random choices c and correction bits b, the evaluator always retrieves the correct label.The security of the C-OT precomputation is based on the same arguments as standard OT precomputation [8] and since we use a fresh uniformly random δ for each wire label, the resulting wire label is also uniformly random. The NR-PRF for key k and element x i is defined asf k (x i ) = g a 0 ·∏ α j=1 a x i, j i mod p,(1)where, when using a plain finite field, p is a prime, q is a prime divisor of p − 1, g ∈ Z * p is a generator of order q, a 0 , a 1 , . . . , a α are random numbers in Z * q forming key k, and α is the bitlength of element x i . Among all protocols for mobile contact discovery evaluated in [40], NR-PSI is the only protocol besides GC-PSI that can easily be made secure against malicious clients by employing malicious secure OT extensions (cf. §4.5). As the OT extension contributes only a small percentage to the total runtime of the PSI protocols and today's maliciously secure OTe protocols are only slightly less efficient than the passively secure OT extension of [3], the total runtime of the PSI protocols does not increase by a noticeable amount when replacing the OTe protocols. However, even an ideal functionality for PSI (e.g., a trusted third party) and currently deployed non-private contact discovery methods cannot prevent this. Unfortunately, in most mobile messaging applications, the client sends information about the intersection (most likely even the entire intersection) to the server. For example, a compressed Cuckoo filter for 2 28 server items with false positive probability ε max ≈ 2 −29 has a size of ≈ 1 GiB, which is prohibitively large for transmission on mobile network speeds and data plans. The client then performs the OPRF evaluation for each of its items with the first server and then runs a multi-server PIR protocol to retrieve the fingerprints stored in the Cuckoo filter.The communication complexity for the multi-server PIR lookup is O(κ log n), where κ is the symmetric security parameter and n the size of the server database [14,21]. To demonstrate the feasibility of our optimized PSI protocols for performing private contact discovery on mobile devices, we provide implementations for smartphones running on Android. For example, the Java implementation of [40], which is based on the ObliVM framework [43], takes more than a second to evaluate a single garbled AES-128 circuit. Our OT implementation is based on libOTe by Rindal [60], which is heavily optimized for the x86 architecture. For the GC-PSI protocol, we implement Yao's GC protocol (cf. §3.2) with Free-XOR [42] and Half-Gates [63], resulting in no communication for XOR-gates and two wire labels of κ bits each per AND gate, where κ = 128 is the symmetric security parameter.For creating and evaluating the garbled tables, the most efficient choice today is fixed-key AES [11], mainly due to the hardware support for AES that is widespread in modern x86 CPUs. 7 Additionally, the ARMv8 architecture provides instructions for vector operations on 128-bit registers (the so-called NEON instruction set), which we use to efficiently work with 128-bit wire labels. The suggested fixes however are not expected to result in a significant negative performance impact [29].8 https://gmplib.org 9 https://github.com/miracl/MIRACL with elliptic curve P-256. We instantiate all primitives and protocols with 128-bit security.In all of our experiments, the sever is equipped with an Intel Core TM i7-4600U CPU @ 2.6 GHz and 16 GiB of RAM. We consider two network settings: (i) an IEEE 802.11ac WiFi connection with ≈ 230 Mbit/s down-/upload and 70 ms RTT and (ii) a mobile LTE connection with 42 Mbit/s download (S → C), 4 Mbit/s upload (S ← C), and 80 ms RTT.Note that the LTE network speeds are real-world parameters and exhibit a significant difference in the down-and upload rates. Note that the size of the client set does not influence the runtime of the setup phase and the client does not send any data during the setup phase in any protocol.method can reduce the runtime of the combined base and online phase to the runtime of the slower phase. We now highlight differences to other works in the literature and compare our optimized GC-and NR-PSI protocols and implementations to other unbalanced PSI implementations available for Android in Tab. The influence of the server set size on runtime and communication is negligible and therefore not listed.Chen et al. [18,19]. Assuming that each of the N s = 2 28 registered clients runs one update per day, this would require the service provider to pay for 2 28 · 12.1 · 32 ≈ 28.9 million core hours every day. Our native implementations of our optimized NR-and GC-PSI protocols are two almost equivalently outstanding solutions for large-scale mobile private contact discovery with security against malicious clients. Thus, we recommend the following hybrid use of contact discovery protocols: Directly after installation of a mobile messaging application, a FHEbased protocol (e.g., [18]) is used to perform the initial contact discovery. If a client then wants to compute the intersection between installed and malicious applications, it only communicates with the malware detection service provider to perform OPRF evaluations and then hands off the encrypted items to the trusted company server, which performs the set intersection on behalf of the clients and reports back the result. 7.System-on-a-Chip (SoC) Example Smartphones and Tablets CE Apple A4, A5, A6 iPhone 4, iPad, iPad 2, iPhone 5 Apple A7, A8, A9 iPhone (5s,6), iPad Air, iPad mini 2 Apple A10, A11, A12 iPhone (7,8,X,Xs), iPad (2018), iPad Pro Snapdragon 801 HTC One (E8), OnePlus One Snapdragon 805Galaxy S5+, Nexus 6 Snapdragon 808Nexus 5X, LG G4, Moto X Style Snapdragon 810OnePlus 2, Nexus 6P, Sony Xperia Z5 Snapdragon 820OnePlus 3, Galaxy S7, LG G5 Snapdragon 821Google Pixel (XL), LG G6 Snapdragon 835Google Pixel 2 (XL), Galaxy S8 Snapdragon 845OnePlus 6, Galaxy S9, Sony Xperia Z2 Table 7: Availability of ARM Cryptography Extensions (CE) in modern smartphone and tablet systems-on-a-chip (SoCs). This work was co-funded by the DFG as part of project E4 within the CRC 1119 CROSSING and project A.1 within the RTG 2050 "Privacy and Trust for Mobile Users", by the BMBF and the HMWK within CRISP, and by the European Union's Horizon 2020 research and innovation programme under grant agreement No 644052 (HECTOR).