An example is the recently added support for pointer authentication (PA) in the ARMv8-A processor architecture, commonly used in devices like smartphones. We present PARTS, an instrumentation framework that integrates our PA-based defenses into the LLVM compiler and the GNU/Linux operating system and show, via systematic evaluation, that PARTS provides better protection than current solutions at a reasonable performance overhead. corrupted control-data and pre-existing code sequences to construct powerful (Turing-complete) attacks without the need to inject code into the victim program. Such data-oriented programming (DOP) attacks [16] are difficult to defend against, and are an appealing attack technique for future run-time exploitation.Software defenses against run-time attacks can offer strong security guarantees, but their usefulness is limited by high performance overhead, or requiring significant changes to system software architecture. Various hardware-assisted defenses in the research literature [15,42,41,14,38,40,28,32] can drastically improve the efficiency of attack detection, but the majority of such defenses are unlikely to ever be deployed as they require invasive changes to the underlying processor architecture. PA uses cryptographic message authentication codes (MACs), referred to as pointer authentication codes (PACs), to protect the integrity of pointers. Practical PA-based defenses must minimize the scope of such substitution.Goals and Contributions In this work, we further the security analysis of ARMv8-A PA by categorizing pointer reuse attacks, and show that PA enables practical defenses against several classes of run-time attacks. • Evaluation: Systematic analysis of PARTS showing that it has a reasonable performance overhead (< 0.5% average overhead for code-pointer and return address signing, 19.5% average overhead for data-pointer signing in nbench-byte (Section 7)) and provides better security guarantees than fully-precise static CFI (9). We make the source code of PARTS publicly available at https://github.com/pointer-authentication. ARM processors, similar to other RISC processor designs, have a dedicated Link Register (LR) that stores the return address. While the return address is stored on the stack, an attacker can use a memory error to modify it to subsequently redirect the control flow on function return. In Chen et al.'s attack against the GHTTPD web server [11], a stack buffer overflow is used to corrupt a data pointer used in input string validation in order to bypass security checks on the input under the attacker's control. The DOP attacks in [16] also involve the corruption of pointers as a means to control which data is processed by vulnerable code. keyed-MAC P A -key Figure 1: The PAC is created using key-specific PA instructions (pacia) and is a keyed MAC calculated over the pointer address and a modifier. PA adds instructions for creating and authenticating pointer authentication codes (PACs). PA, on the other hand, uses either QARMA [5] or a manufacturer-specific MAC, and performs the MAC comparison in hardware.64-bit ARM processors only use part of the 64-bit address space for virtual addresses (Figure 2). The keys are stored in hardware registers configured to be accessible only from a higher privilege level: e.g., the kernel maintains the keys for a user space process, generating keys for each process at process exec. The modifier value is not necessarily confidential (see Section 4) but ideally such that it 1) precisely describes the context of use in which the pointer is valid, and 2) cannot be influenced by the attacker.PA is used by instrumenting code with PAC creation and authentication instructions. The corresponding PA authentication instruction (in this case, autia) removes the PAC from the pointer if authentication is successful, i.e., if the current pointer value, key and modifier for autia yields a PAC that matches the PAC embedded in the pointer. It thwarts attacks that manipulate function return addresses through stack corruption (see Section 2.1.1) by ensuring that the return address in LR always contains a PAC when written to or retrieved from memory. Listing 1 shows an example.The instrumentation adds paciasp () at beginning of the function prologue, before the LR value is stored on the stack. This effectively prevents any attack that relies on corrupting pointers, resisting even attackers with arbitrary access to program memory.The modifier value used in computing a PAC can depend on both static (e.g., a hard-coded value) and dynamic (e.g., the SP) information. We assume that the program code itself is not confidential and that the attacker can learn how dynamic modifiers are generated and may infer their values.PA also relies on the security of the underlying cryptographic primitives. However, the following concerns for the security of PA-based defenses remain: 1) an attacker controlling the creation of PAC values, or 2) an attacker reusing previously authenticated pointers.Malicious PAC generation. control the PA modifier value: get an authenticated pointer for a context with the same PA key, but with an attacker-chosen modifier. The attacker can read authenticated pointers (including PAC values), and later reuse them to either:• rollback an authenticated pointer to a previous value, or • substitute an authenticated pointer with another using the same PA modifier.For instance, in GCC's return address signing scheme (Section 2.2), the return address is bound to the location of the stack frame by using the current SP value as the PA modifier. Given that typical programs offer no guarantees on the uniqueness of SP values between different function invocations, this approach exposes a large attack surface for pointer reuse attacks. Intuitively, pointer integrity aims to prevent unintentional changes to pointers while they remain in program memory so that the value of a pointer at the time it is "used" (e.g., dereferenced or loaded from memory) is the same as when it was created or stored on memory. We identify the following requirements that our solution should satisfy: R1 Pointer Integrity: Detect/prevent the use of corrupted code and data pointers.R2 PA-attack resistance: Resist attempts to control PAC generation, and pointer reuse attacks.R3 Compatibility: Allow protection of existing programs without interfering with their normal operation.R4 Performance: Minimize run-time and memory overhead and gracefully scale in relation to the number of protected pointers and dereferences/calls. Code / Data Pointer Compartmentalization: Recall from Section 2.2, that PA provides separate key sets for data and code pointers making it possible to limit reuse attacks. To address this, PARTS adds run-time type safety for data and code pointers. PARTS assigns pointers a unique id, type-id, based on the pointer's LLVM ElementType which depends on the pointed-to data, structure, or function signature. Instead, PARTS uses a combination of the current stack pointer value, and a compile-time nonce (function-id) ensuring that the authenticated return address cannot be reused across invocations of different functions, while the stack pointer values effectively compartmentalizes return addresses to callers with different stack layouts. We refer to these as on-load and on-use authentication, respectively. When run-time type safety is applied to authenticated pointers, special care must be taken to not interfere with legitimate pointer conversions to meet requirement R3 . Because data pointer PAC creation and authentication is done at store/load, PARTS handles conversions by; (a) if loading the pointer from memory, validating and stripping the PAC using the type-id of the original object, and (b) on store, creating a new PAC using the destination object type-id. However, the behavior when calling a function pointer cast to a non-compatible type is undefined [18] The PARTS compiler is based on LLVM 6.0 but modifies and adds new passes to the optimizer and the AArch64 backend ( Figure 3). Where applicable, we use optimizer passes that operate on the high-level LLVM intermediate representation (IR). Nonetheless, much of the needed functionality is PA-specific and thus implemented in the backend that uses low-level LLVM machine IR (MIR), and a register-and instruction set specific to 64-bit ARM.Determining pointer type-id. Return address signing is implemented in the AArch64 backend during frame lowering (Figure 3, ). The PAC modifier is based on the 16 least-significant bits of the SP value and a 48-bit functionspecific function-id. When the type-id is not present, e.g., because the load and store is a register spill, the type-id is fetched from surrounding code. For instance, when instrumenting the store due to register spilling ENDM f u n c t i o n : mov Xd , SP ;  g e t SP m o v F u n c t i o n I d Xd ;  g e t i d p a c i b LR, Xd ;  PAC s t p FP , LR, [ SP , #0 ] ; s t o r e ; f u n c t i o n body l d p FP , LR, [ SP , #0 ] ; l o a d LR mov Xd , SP ;  g e t SP m o v F u n c t i o n I d Xd ;  g e t i d a u t i b LR, X ;  a u t h r e t Listing 2:The PARTS return address signing binds the PAC to the SP (,) and unique function id (,). The 48-bit func-id is split into three 16-bit parts, each moved individually to Xd by left-shifting. As discussed in Section 2.2, no explicit error handling is added by PARTS; instead, an authentication failure will set specific high-order bits in the pointer, thus triggering a memory translation fault on subsequent dereference or call using the pointer that failed authentication. Our code listings use two macros for setting up PA modifiers for return address signing and type-id based PACs, these are shown in Listing 2 and Listing 3. The function epilogues (i.e., any part that ends with a return or a tail-call) are similarly instrumented to generate the same PA modifier (,) and to verify the PAC in the restored LR (). Specifically, when a code pointer is initially created, PARTS will use the instruction A-key to create a PAC () based on the target type-id (). Instead, PARTS uses the combined authenticate and branch instructions -e.g., blraa -to perform the branch directly on an authenticated pointer ( ), again using the same PA modifier (). PARTS creates PACs for pointers immediately before store in the same manner, save for the pacda instruction. We develop our Proof-of-Concept implementation of PARTS on the ARMv8-A Base Platform Fixed Virtual Platform (FVP), based on Fast Models 11.4, which supports version 8.0 to 8.4 of the ARMv8-A architecture [4]. Compared to GCC, PARTS augments the PA modifier used for return address signing by combining a function-specific identifier with the SP value ( R2 ). This prevents a large class of attacks (e.g., typical ROP/JOP gadgets) that rely on redirecting the control flow to code in the middle of functions, i.e., addresses that never were valid targets of benign control-flow transfers.PARTS restricts forward-edge code pointer reuse by enforcing run-time type safety for signed pointers ( R2 ). PARTS data pointer signing protects all data pointers and prevents an attacker from loading a forged data pointer to program memory ( R1 ). This class of attacks includes all currently known DOP attacks [16]. This may expand the effective set of reusable pointers under our threat model; the attacker can record pointers of type A and reuse them at PAC conversion site A → B, thereby obtaining a pointer of type B to an object of type A. This converted pointer can then be used at de-reference sites that require pointers of type B. This could allow an attacker to brute force a PAC by targeting a sibling, if PAC failure on a sibling does not result in the termination (and hence PA key reset) of all threads/processes sharing the same PAC key. The ARM Fast Models documentation states that "all instructions execute in one processor master clock cycle". From [5, Table 8] we can deduce that on a (1.2GHz) mobile core, the PAC is computable with an approximate overhead of 4 cycles, without accounting for the potential speed benefits of opportunistic pipelining or the inclusion of several parallel PAC computing engines per core. e o r Xptr , Xptr , #0 x2 ; s p e n d c y c l e s e o r Xptr , Xptr , #0 x3 ; t o a p p r o x i m a t e e o r Xptr , Xptr , #0 x5 ; PA i n s t r u c t i o n e o r Xptr , Xptr , Xmod ; o v e r h e a dListing 5: PA-analogue simulating PA instructions For our performance evaluation we use the Linux nbenchbyte 2.2.3 synthetic benchmark 4 designed to measure CPU and memory subsystem performance, providing a reasonable prediction of real-world system performance 5 . This is a challenge for both researchers and industry practitioners who rely on hardware simulation for evaluation [30]. We adopt the same methodology as Brasser et al. [6] and run each test a constant number of iterations for the following cases: a) uninstrumented baseline b) each PARTS scheme (return address signing, forward-edge code pointer integrity, and data pointer integrity) enabled individually, and c) all schemes enabled simultaneously. In contrast, the Fourier and neural network benchmarks contain no data pointers and thus incur no discernible overhead. Because return address signing only affects the instrumented function, it can be safely applied without interfering with the operation of other parts of programs, or uninstrumented code.PARTS forward-edge code pointer integrity and data pointer integrity can be safely applied to complete code bases. Similarly to ARMv8-A PA, Cryptographic CFI (CCFI) [25] uses MACs to protect control-flow data, such as return addresses, function pointers, and vtable pointers. Here we describe mechanisms available in commercial off-the-shelf processor architectures.Only a few commercial processors, such as the SPARC M7 9 , support tagged memory, which can be used to realize variety of security models (including pointer integrity). Pointer tags use the existing address tagging feature in the ARM ISA that partly overlaps with the bits used to store PA PACs, meaning that enabling both features simultaneously reduces the available PAC size by eight bits.Hardware-assisted memory tagging is designed primarily as a statistical debug aid against use-after-free and other temporal memory errors. ASAN / HWASAN are complementary to PARTS, as they provide spatial and temporal safety for data accesses via pointers.Intel Memory Protection Extensions (MPX) is a hardware feature for detecting spatial memory errors that debuted in the Intel Skylake microarchitecture. For instance, in a stateless policy such as fully-precise static CFI, the best possible policy for return instructions (i.e., backward edges in the CFG) is to allow return instructions within a function F to target any instruction that follows a call to F. We adopt Kuznetsov et al.'s [21] definition of "based on" and say a pointer P is based on a target object X if, and only if, P is obtained at run-time by "(i) allocating X on the heap, (ii) explicitly taking the address of X, if X is allocated statically, such as a local or global variable, or is a control-flow target (including return locations, whose addresses are implicitly taken and stored on the stack when calling a function), (iii) taking the address of a subobject y of X (e.g., a field in the struct X), or (iv) computing a pointer expression (e.g., pointer arithmetic, array indexing, or simply copying a pointer) involving operands that are either themselves based on object X or are not pointers. However, CPI requires dedicated, integrity-protected storage for sensitive pointers.As discussed in Section 7.2, PARTS, and PA solutions in general, achieve an approximation of fully-precise pointer integrity. However, ensuring the uniqueness of PA modifiers is not possible in practice due to the following reasons: 1) program semantics may require a set of pointers to be substitutable with each other (e.g., pointers to callback functions) 2) the choice of allowed pointers may depend on run-time properties (e.g., which callback function was registered earlier). PARTS additionally requires matching SP values, and that the reused return address originates from a prior function invocation of the same function within the same process for an attack to succeed.PARTS forward-edge code pointer integrity provides similar guarantees (under reuse attacks) as LLVM's type-based protection (when subjected to any forged pointer). PARTS in addition requires that the injected pointer originates from the victim process.While shadow-stacks protected through randomization can be implemented with minimal performance overhead, our adversary model precludes this approach. Although ARMv8-A PA does not support bounds checking for pointer accesses with authenticated pointers, it has a general-purpose instruction, pacga, for producing and validating PACs computed over the contents of two 64-bit registers. In principle, pacga instructions can even be chained to validate arbitrary-sized blocks of data.Finally, effective ways of complementing PA with other emerging memory safety mechanisms like the forthcoming support for memory tagging in ARMv8.5-A is an important line of future work. For example, the Numeric Sort test will construct an array filled with random numbers, measure the time taken to sort the array. If sorting two arrays takes less time than the pre-determined minimum, the process repeats with more arrays.Since we want to determine the relative overhead in execution time caused by our instrumentation, we employ the methodology described by Brasser et al. [6] and modify nbench to instead run each test a constant number of iterations. We enabled both return address and forward-edge code pointer signing for the instrumented binaries. indicates the source of the address to be signed / authenticated (Xd indicates that the address is specified using a general purpose register). For example, the Numeric Sort test will construct an array filled with random numbers, measure the time taken to sort the array. We then extracted the bitcode -created by whole-program-llvm during compilation -and used it to instrument and compile the binaries we used for evaluation: one uninstrumented, one instrumented with PA instructions, and one instrumented with our PA-analogue. We run the PARTS-instrumented binaries on the FVP simulator to confirm correct functionality. indicates the modifier used by the instruction (Xm indicates that the modifier is specified by a general purpose register.)