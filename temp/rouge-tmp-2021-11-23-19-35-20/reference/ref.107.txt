Heap metadata attacks have become one of the primary ways in which attackers exploit memory corruption vulnerabilities. The hackers of a decade past employed simple tactics -stack-based buffer overflows were leveraged to jump to shellcode on the stack, the constructors, destructors, and Global Offset Tables of binaries were fruitful targets to achieve execution control, and an incorrect bounds-check most of the times guaranteed successful execution. Techniques were introduced to reduce the potential targets of vulnerable writes [30], and then they have been partially bypassed as well [14]. The cat-and-mouse game of binary warfare has gone on for a long time: The locations change, but the battle rages on [50]. For performance reasons, many modern heap implementations (including the most popular ones [1]) place dynamically allocated application data in the same memory regions where they store control information for heap operations. In turn, the corruption of heap metadata may cause heap handling functions to fail in an attackercontrollable way, leading to increased attacker capabilities, and, potentially, a complete application compromise.This weakness has not gone ignored: Heap implementation developers have introduced hardening mechanisms to detect the presence of heap metadata corruption, and abort the program if corruption is present. In 2017, a patch was proposed to and accepted by the GNU standard C library (glibc) heap implementation. However, it was almost immediately discovered that the check could be trivially bypassed using a slight modification of the attack [45]. If such a violation is found, our tool outputs proof-of-concept (PoC) code that can be used to both study the security violation of the heap implementation and test the effectiveness of potential mitigations.We applied HEAPHOPPER to five different versions of three different heap implementations, systematically identifying heap attacks: Chains of heap operations that can be triggered by an attacker to achieve more capability for memory corruption (such as arbitrarily targeted writes) in the program. Furthermore, with the help of the PoC generated by HEAPHOPPER against the 2017 glibc patch, we were able to develop a proper patch that our system (and our manual analysis) has not been able to bypass, which is currently being discussed by the glibc project.In summary, this paper makes the following contributions:• We develop a novel approach to performing bounded model checking of heap implementations to evaluate their security in the presence of metadata corruption. • We utilized the tool to analyze high-profile patches and changes in the glibc allocator, resulting in improved patches that are awaiting final sign-off and merge into glibc.Following our belief in open research, we provide the HEAPHOPPER prototype as open source [16]. Most of them were developed with the sole purpose of providing dynamic memory management with the best performance in terms of both minimal execution time and memory overhead.Memory-corruption issues (such as buffer overflows), have been shown to be exploitable by attackers to achieve, for instance, arbitrary code execution in vulnerable software. Conversely, for the heap, every implementation uses ad hoc and widely different protection mechanisms, which oftentimes have been shown to be bypassable by motivated attackers [44]. Examples of such allocators are: ptmalloc [22], used by glibc (the implementation of libc commonly used in Linux distributions), dlmalloc [31] (originally used in glibc, now superseded by ptmalloc), and the heap implementation used in musl [2] (a libc implementation typically used in embedded systems). This allows an attacker to execute, at will, instructions such as the following (allocating some memory, filling it with attacker-controlled data, and then freeing it): c = malloc(data size); read(stdin, c, data size); ... free(c);Additionally, an attacker may be able to exploit any vulnerabilities in the code, such as double free, use-after-free, buffer overflows, or off-by-one errors. By triggering controlled allocations, frees, and memory bugs, the attacker will try to achieve exploitation primitives, such as arbitrary memory writes or overlapping allocations. To exemplify how modern libc libraries contain checks to detect and mitigate memory corruptions and how these B.size=0x200To bypass the check, set to B.size & (~0xFF) (during Step 1) 0x100 0x80Overlapping Chunks ERRONEOUS C.prev_size Figure 1: Graphic representation of how to exploit a 1-byte NULL overflow in the current version of glibc (using ptmalloc). This check can be easily bypassed by writing, during Step 1, the value B.size & (∼0xff) in the right location within the chunk B (in the example, where the field in blue is). This example is traditionally called the poisoned NULL byte [20] and targets ptmalloc. This overflow will result in setting to 0 the least significant byte of the field size of the (now freed) chunk B. Given the fact that B1 has been freed and that C is being freed, the allocator will consolidate B1 and C (i.e., it will merge the two free chunks to create a single, bigger free chunk). This happens because the allocator lost track of the existence of the chunk B2, as explained in the previous steps.8. In 2017, a patch was proposed and accepted [18] for glibc (we will refer to this patch as Chris Evans' patch, after its author), introducing a comparison between the size and the previous size of two adjacent chunks, when they are consolidated together. prev size == X.size, where X is an arbitrary freed chunk and next chunk is a function returning the next chunk of a given chunk by computing next chunk = X + X.size.Interestingly, similar to other security checks present in glibc, Chris Evans' patch was added with some degree of uncertainty about its effectiveness, stated by the author himself in his blog post: "Did we finally nail off-by-one NULL byte overwrites in the glibc heap? Only time will tell!" However, their effectiveness is, in general, limited and, most importantly, not systematically tested.Our work aims exactly at targeting this third point, by creating HEAPHOPPER, a tool to perform bounded model checking of libc implementations to detect if and how memory corruption bugs can be exploited.As an example, in Section 7.7, we will show how our tool was able to automatically understand that the aforementioned glibc patch was bypassable. The input of HEAPHOPPER is a compiled binary library (in the format of a shared object file) implementing a heap and a configuration file specifying:List of transactions: A list of operations that an attacker is allowed to perform, such as malloc, free, buffer overflows, use-after-free, etc. Bound:The maximum number of transactions that an attacker can perform.List of security properties: A list of invalid states in which the attacker has reached the ability to perform specific exploitation primitives.HEAPHOPPER works by automatically finding sequences of transactions that make the model of the analyzed heap implementation reach states where specific security properties are violated.As output, HEAPHOPPER produces proof-of-concept (PoC) source code C files, exemplifying how different operations can be used to achieve different exploitation primitives. Internally, HEAPHOPPER first generates lists of transactions by enumerating permutations of the transactions provided in the configuration file (see Section 4.2 for details). Using symbolic execution HEAPHOPPER can, at the same time, verify such properties and determine the content that attackercontrollable data (e.g., the content of legitimately malloced buffers or the value of overflowing data) should have to achieve a detected security property violation.The use of symbolic execution obviously requires HEAPHOPPER to have access to the compiled binary code of the analyzed library. These interactions represent an application's usage or misusage of the heap. To make our analysis feasible, we need to limit the number of interactions that we consider, thereby bounding the state space of the heap as well. Indirect interactions are modifications of the allocated memory, such as buffer overflows, presumably caused by flaws in the program using the allocator.We define a transaction as an operation that modifies the heap's state directly or indirectly. For this reason, the symbolic execution unit will use symbolic-but-constrained values for the size parameter of malloc.To choose the range of that constrain values, we rely on the fact that most of the allocator implementations execute different code paths for certain ranges of sizes, typically called bins [35]. The boundary values of the identified ranges can afterward be plugged into the configuration file, to specify how to constrain the value of malloc's size parameter.free (F). In most cases, the memory overwritten is another chunk adjacent in memory. For allocators that make use of inline metadata, this can have severe consequences regarding the integrity of internal data, which often leads directly to exploitation primitives and further memory corruptions.There are two common paths that lead to a heap overflow. For instance, the poisoned NULL byte we described in Section 2.3 can be simulated restricting the overflow size to 1 and the possible values of the overflowing data to just NULL (0x00). The action becomes even more powerful if the reference to the freed chunk is used for a write access, because it lets an attacker manipulate data stored inside the freed chunk, and this modified data might be used later by the vulnerable program.We model a UAF transaction by writing symbolic memory into any freed chunk. Similar to the previous transactions, this requires the creation of different sequences for each previously freed chunk, and a bound on the number of bytes written into memory.double-free (DF). Nevertheless, in case of a successful double-free, the chunk is stored inside the allocator's internal structures for freed chunks twice, which can lead to further corruption of the heap structure.The double-free is modeled as a call to free with any formerly freed chunk, which entails a different sequence for each of them.fake-free (FF). This could potentially lead to future allocations returning the maliciously fake chunk.We model the fake-free action by adding a free invocation pointing to a fully symbolic memory region. Consequently, the main focus here is to minimize the amount of sequences, while simultaneously avoiding missing sequences of transactions that could lead to exploitation primitives.Therefore, we only consider permutations with at least one misuse of the heap (direct or indirect), as we assume that a completely benign usage of the heap will not lead to any malicious state. This is justified by the fact that the second transaction would just overwrite symbolic data with symbolic data, having no effect.After an initial generation of transaction permutations, we consider the semantics of each action. Similarly, for each UAF and DF action, we only generate a sequence for each possible previously freed chunk. We use the angr framework [46] as HEAPHOPPER's symbolic execution engine and perform the following analysis for every sequence of transactions. Formally, in order to detect an OA when a new memory chunk is allocated at address A, HEAPHOPPER uses an SMT solver to check if the following condition is true:∃B : ((A ≤ B) ∧ (A + sizeo f (A) > B)) ∨ ((A ≥ B) ∧ (B + sizeo f (B) > A))where B is the location of any already-allocated memory chunk.Non-Heap Allocation (NHA). A NHA can be further exploited by, for instance, obtaining a malloced region on the stack and use it to change a saved return pointer, taking control of the program counter.To detect this condition, first of all, we detect when the brk or mmap syscalls (used to ask the kernel to allocate memory) are called by the heap allocator. We distinguish the case in which an attacker has full control over where to write (AW) from the case in which the attacker can write only to memory locations where a specific content is present (AWC). This second scenario is common when it is possible to force the allocator to perform a write operation, but, in order to bypass the allocator's checks, the content of the memory where the write happens needs to satisfy certain constraints (e.g., it needs to contain data looking like a legitimate chunk's header). In case WT does not contain any constraint, we consider this arbitrary write as AW, otherwise we consider it as AWC. To mitigate this issue, we developed a three-step procedure, including a new approach designed specifically for the type of analysis that HEAPHOPPER performs.In the first step, we filter out symbolic memory accesses that are in fact well-bounded and need no specific treatment. In the final step, HEAPHOPPER generates a proof-of-concept program for each sequence that reached an exploitation primitive, based on the interaction sequence's source code (which contains placeholder, undefined variables) and the data from the symbolic execution.The generated PoC program serves two purposes: First, it provides a concrete execution example of how a specific exploitation primitive is reached, supporting the manual analysis of HEAPHOPPER's result. Then, it replaces the symbolic memory reads into memory, representing indirect interactions with the heap, with the values received from concretizing their symbolic bytes.The key challenge with this process is that the results of concretizing symbolic bytes are not just constants, but often represent pointers containing virtual addresses from the symbolic execution or specific offsets between two objects in memory. The model specifications for each experiment can be found in Table 1. Furthermore, we chose two different overflow sizes to simulate a full 64-bit overflow (which is the register's size of the architectures targeted by the analyzed allocators) and a one-byte overflow. Specifically, in this new version, M-FF-F achieves AW, instead of just AWC (see Section 7.8 for details). M-M-M-F-O-M (M,FF): FF-M (M,F,FF): M-FF-F (M,F,UAF): M-M-M-F-UAF-M-M (M,F,O): M-M-O-F-M (M,F,O): M-M-O-F (M,F,UAF): M-M-F-UAF-M-M (M,F,UAF): M-M-F-UAF-M dlmalloc 2.8.6 (M,F,O): M-M-M-F-O-M (M,F,O): M-M-M-F-O-O-F (M,F,UAF): M-M-M-F-UAF-M-M musl 1.1.9 (M,F,O): M-M-M-F-O-M (M,FF): FF-M (M,F,FF): M-FF-F (M,F,UAF): M-M-F-UAF-M (M,F,UAF): M-M-M-F-UAF-M-M (M,F,UAF): M-M-F-UAF-M-M (M,F,FF): M-M-F-FF-M-M ptmalloc 2.23 (M,F,O): M-M-M-F-O-M (M,FF): FF-M (M-F-FF): M-FF-F (M,F,UAF): M-M-F-UAF-M (M,F,UAF): M-M-M-F-UAF-M-M (M,F,O): M-M-M-O-F-M (M,F,O): M-M-O-F (M,F,UAF): M-M-F-UAF-M-M ptmalloc 2.26 (M,F,O): M-M-O-F-M (M,FF): FF-M (M,F,UAF): M-M-F-UAF-M (M,F,UAF): M-M-M-F-UAF-M-M (M,F,UAF): M-M-F-UAF-M-M (M-F-FF): M-FF-Ftheir set. Therefore, we analyzed two releases of dlmalloc, 2.7.2, the latest version without any security hardening and 2.8.6, the latest available version, released in 2012. In this allocator, the sequence M-M-O-F produces an AW. If we compare the results to the known attacks from Table 3 again, we only find two attacks that lead to an OA. Additionally, we find one new way of reaching an AWC.In order to better understand what causes this difference in the results with respect to version 2.7.2, we took a look at the code changes. However, the results look similar to dlmalloc version 2.7.2, with the only difference being that we did not find a path to reach a NHA through an overflow and a constraint was added to the new AW attack we found. ptmalloc 2.23. Version 2.26 of ptmalloc comes with new consistency checks, including Chris Evans' patch, discussed in Section 2.3, and uses a new layer for handling free chunks called tcache. fastbin dup NHA M-M-F-UAF-M-M 9.93s house of einherjar NHA M-M-O-F-M 51.10s house of spirit NHA FF-M 9.22s overlapping chunks OA M-M-M-F-O-M 14.05s unsafe unlink AWC M-M-O-F 13.80s unsorted bin AW M-M-F-UAF-M 9.54s poison null byte OA M-M-M-F-O-M-M-F-F-M 603.40s house of lore NHA M-M-F-M-UAF-M-M 18.72sIn the last column we give HEAPHOPPER's runtime to find a path that reaches the exploitation primitive based on an interaction model representing this technique. Afterwards, we ran HEAPHOP-PER with each these compositions against ptmalloc version 2.23. Therefore, we build a ptmalloc shared library from the commit introducing the new check, and used the transactions for the poison null byte from the previous evaluation. However, due the complexity caused by indirections that these checks face, it is hard to evaluate their effectiveness by hand. Specifically, it is possible to achieve an AW using a fake-free operation.After manually analyzing the implementation of tcache, we found that it completely omits all the security checks on the traditional list of free chunks, by establishing another layer of free-lists that is used before the original structures.With this result, HEAPHOPPER exposed the significance of this design change in ptmalloc. In addition to arbitrary values for some of the transactions' parameters, certain known attack techniques, such as the poisoned NULL byte, require a large amount of transactions until they reach a malicious state in the heap. These include the assumptions angr makes about the memory layout (leading to incorrect memory offsets in the PoC), and limitations that it suffers during the handling of complex symbolic memory accesses (leading in over-relaxed constraints in PoC generation). In this case, techniques to "cache" already-explored paths (or part of a path) within our model could be used to both speed-up the symbolic execution and lower the memory consumption. Furthermore, the detection of heap-based vulnerabilities and data leaks in applications has been targeted by research [3,52]. Bounded Model Checking (BMC) bounds the depth of paths that are checked during model checking, and leverages SAT solvers, instead of binary decision diagrams, in the verification process to ease the memory pressure and improve the scalability [6]. /* * List of transactions : M -M -M -F -O -M -M -F -F -M */ # include < malloc . h > typedef struct __attribute__ (( __packed__ ) ) { uint64_t * global_var ; } controlled_data ; The resulting PoC for the 1-byte NULL generated from the path in the symbolic execution that reached a NHA exploitation primitive. // ... size_t write_target [4]; size_t offset ; size_t header_size = 0 x20 ; size_t mem2chunk_offset = 0 x16 ; size_t malloc_sizes [6] = {0 x100 , 0 x200 , 0 x100 , 0← x100 , 0 x80 , 0 x200 }; size_t fill_sizes [6] = {0 x100 , 0 x200 , 0 x100 , 0← x100 , 0 x80 , 0 x200 }; size_t overflow_sizes [1] The sequence of transactions for the unsafe unlink technique (see Table 3), as it is passed to the symbolic execution engine.