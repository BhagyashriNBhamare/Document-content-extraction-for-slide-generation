Changes have been proposed to make kernel security mechanisms available to containers, but such changes are often adhoc and expose the challenges of trusting containers to make security decisions without compromising host system or other containers. To preserve security, we propose a routing mechanism that can dynamically dispatch an operation to a set of containers whose security might be affected by the operation, therefore ensuring the security decision made by one container cannot compromise the host or other containers. Containers cannot apply local security policies to govern integrity measurement, code execution, mandatory access control, etc. to prevent application specific security problems. For example, a kernel patch [24] to Integrity Measurement Architecture (IMA) [53] suggested that the IMA measurement list can be extended with a container ID, such that during integrity attestation the measurements will become separable based on containers. These changes, however, only made limited kernel security features available to containers, and they all rely on the system owner to specify a global policy, leaving containers no real freedom in enforcing an autonomous security.In this paper, we explore approaches to make kernel security frameworks available to containers. In studying the two popular kernel security frameworks, namely IMA [53] for integrity and AppArmor [41] for mandatory access control, we make the following observations: first, we find that the common challenge for containers to obtain autonomous security control is the implicit global and mandatory assumptions that kernel security frameworks often make. We do this by inferring from containers' security expectation towards an operation.Leveraging these insights, we propose the design of security namespaces, kernel abstractions that enable containers to utilize kernel security frameworks to apply autonomous security control. A Policy Engine is added to detect such conflicts and inform the container owners of potential conflicts before they load their security policies.We evaluate our design by developing two concrete instances of security namespace, one for IMA and one for AppArmor. For AppArmor namespace, we show that it enables containers to enforce two policy profiles simultaneously, one protects the host system and another protects the containerized application, which was not possible as discussed in Ubuntu LXC documentation [34]. Results show that security namespaces introduce less than 0.7% latency overhead to system calls in a typical container cloud use case (i.e., no nested namespaces) and an almost identical throughput for containerized applications.In summary, we make the following contributions. Changes to the global resource are visible to other processes that are members of Daemon continue running in the native system the namespace, but are invisible to other processes.We use mount namespace as an example. As a more principled approach, Linux kernel introduced the mount namespace abstraction to isolate mount points that can be seen by the processes. The daemon process forks itself (i.e., via clone), specifying that the newly forked process will run in different namespaces from the native for isolation. The forked process then properly sets up the namespaces that it runs in (e.g., mounting a different root, setting up its IP address, firewalls, etc.) and executes a target program (i.e., via execve). Some of these frameworks are upstreamed to the Linux kernel, such as Linux integrity subsystem [53,30], SELinux [42], and AppArmor [41]. Such security critical operations are passed to a security module where decisions (i.e., allow or deny) are made based on security policies. In the above example, a bank would benefit from IMA to maintain a tightly controlled environment of its servers and enforce that only approved code could be run.In this section, we discuss the need for containers to have autonomous security control, and the fundamental challenges of achieving it. As more critical applications are deployed in containers, container owners want to utilize kernel security frameworks to govern integrity measurement, code execution, mandatory access control, etc. to prevent application specific security problems. Since IMA only allows a single policy maker (in this case, the cloud vendor that controls the host system), individual containers cannot decide what files to measure nor what would be good measurements for those files.We argue that achieving the autonomous security control is fundamentally difficult because security frameworks in Linux kernel are designed to be global and mandatory. Security frameworks need to exercise their control over a limited scope of processes specified by the container owner and security states need to be maintained and accessed separately; this relaxes the global assumption of security frameworks. In this section, we first introduce a strawman design of security namespace that mimics the design of resource namespaces, and present two attack examples.Strawman design. Analogous to other resource namespaces, a security namespace has to make it appear to the processes within the namespace that they have their own isolated instances of kernel security framework. Assume the owner of the native system wants to prove the integrity of the native system by using NS native to measure and record all the code that has been executed on the system (Figure 3a). In this example, P managed to execute a malware without leaving a footprint on the system, due to that the native security namespace NS native no longer controls P 1 , and the security namespace NS 1 that controls P 1 is created and controlled by adversary. However, since NS 2 has security control over processes running in the second container, it can make f read-write to its processes. This example demonstrates that, in a security namespace design, if mandatory assumption of security framework is relaxed in a naive way (e.g., by allowing two or more principals to apply security policies freely), adversary may leverage that fact to launch attacks. Due to the diversity of kernel security frameworks and their different design perspectives and details, the design can hardly be generic. But we try to abstract the commonness by studying two commonly used kernel security frameworks, namely IMA and AppArmor, and hopefully it may provide useful guidance for other kernel security frameworks and eventually lead to a generic design.Autonomous Security Control. Each involved security namespace independently makes a security decision, and the operation is allowed if all involved security namespaces allow the operation.above attack examples show that how to relax the global and mandatory assumption of security frameworks represents a control point in the tussle. The kernel ensures the integrity of the policies being loaded by either attesting policy integrity to the policy maker or accepting only policies with valid maker signature. It is the design goal of security namespace abstraction to prevent one principal from abusing the abstraction to compromise security of another principal.In this paper, we do not aim to provide an unified abstraction for all kernel security frameworks. This boils down to two security invariant that we believe must be maintained when global and mandatory assumption are relaxed:• Given an operation from a process, all security namespaces that have an opinion about the operation (i.e., expressed via its security policy) should be made aware of the operation. However, only if all policies allow the operation will the operation be allowed by the system.Based on this insight, we propose a security namespace abstraction design that is secure, by augmenting the strawman design with a routing based mechanism, as shown in Figure 4. First, as in the strawman design, we virtualized a security framework into virtual instances. Each virtual instance becomes a security namespace and controls a group of processes associated with it (e.g., security namespace 1 to security namespace n in Figure 4). To decide which security namespace may have an opinion about an operation, we leverage a simple insight: a security namespace may have an opinion about an operation if by not routing the operation to the security namespace, the two security assumptions, global and mandatory, might be broken for the security namespace. Security framework makes an implicit assumption about its globalness: it controls all subjects on a system that are stemmed from the very first subject that it sees. For native system, this means all subjects forked from init (i.e., PID 1). As a result, the Operation Router needs to account for the subject's perspective by not only route an operation to the security namespace that the subject is associated with, but also all security namespaces that the direct ancestors of the subject are associated with. Therefore, when subjects from NS 1 access the file, security of NS 1 is compromised without NS 1 is being aware of.Due to the assumption of complete control over objects, a security namespace may have an opinion about an operation even if the subject of the operation is not under its control. As a result, theoretically, the Operation Router needs to account for the object's perspective by routing an operation to all security namespaces whose subjects may ever access the object of the operation to ensure that all their security expectations are met.To decide if an object may ever be accessed by subjects of a security namespace, the Operation Router leverages the resource visibility defined by the resource namespaces (e.g., mount, network and etc.). For example, the /proc and /sys filesystems and the objects on them are often shared among different containers on a host. In a security policy, if a security namespace declares authority over an object, its policy over the object becomes mandatory-all the operations over the object, either from subjects associated with the security namespace or other security namespaces, will be routed to the security namespace for mediation. In contrast, if a security namespace does not have authority declared for an object in its security policy, the policy over the object will only be locally effective, meaning that the security namespace will not be able to control how subjects from other security namespaces access the object. The goal of the authority decorator is to let security namespaces explicitly declare their mandatory assumption.The external decorator is used along with the authority decorator. Combining the two perspectives and the practical constraint, we can then define a routing algorithm for the Operation Router that meets our goal: given an operation, all security namespaces that may have an opinion about an operation are made aware of the operation. Between security namespace vertices, there is a directed edge, pointing Input: subject s and object o, security namespace graph G, object authority table T Output: set of security namespaces Φ 1: Φ ←native Native is the ancestor for any security namespace 2: n ←CURRENT(s, G) Get the namespace that s is associated with 3: while n = native do Recursively add all n's ancestors 4:Φ ← Φ ∪ n 5:n ←GET PARENT(n, G) 6: Φ ← Φ∪AUTHORITY(o, T ) Get namespaces that declared authority over o 7: return Φ Figure 6: An algorithm for routing an operation to security namespaces who may have an opinion about the operation.from the child to its direct parent 3 . The goal of Policy Engine is to detect policy conflicts at policy load time. Such denial often cannot be debugged at runtime, as security namespaces are isolated from each other. The conflicting party may revise her security policy to avoid conflicts, or continue using the system but be aware of the potential conflicts, or abort using the system as the system cannot meet her expectations. The first type is the ancestor-descendant conflict, where a descendant security namespace's policy violates its ancestors', as shown in Figure 7(a). At a high Input: set of existing security policies S, new security policy s Output: set of conflicting rules Φ 1: Φ ← / 0 2: S ←ROUTING ALG(S) Set of policies that need to be considered 3: P o ←PERMISSIONS(S ) Projected permissions of S 4: P n ←PERMISSIONS(s) Projected permissions of s 5: if P n ⊆ P o then 6:Φ ←CONFLICTING RULES(P o , P n ) 7: return Φ level, the algorithm takes as input the security policies of existing security namespaces and the new one, and try to identify if the newly loaded security policy would introduce additional access permissions for the subjects. The first type of expectation conflicts is shown in Figure 7(c), where in its security policy a security namespace declares authority over an object but it does not have the capability to declare the authority. This delivers an explicit message to the owner of the security namespace that the system cannot meet her security expectation, and she shall not run with the false impression of security (e.g., a security namespace believes a file is read-only file, but it is actually writable to other security namespaces). The modification to kernel is ∼1.1K and ∼1.5K LOC, respectively. IMA protects the integrity of a system by measuring and appraising what subjects on a system may read or execute. Instead, we re-used the measurement cache in our implementation and make it a global data structure shared by all the IMA namespaces. Instead, we only virtualized the data structures and interfaces that are exposed to userspace to make it appear that they have their own isolated instance of IMA.File Appraisal and Policy Engine. The idea is to allocate a keyring with a different name (randomly generated) in the kernel every time an IMA namespace is created. The certificates are essentially whitelist policies deciding which file can be read or executed by the namespace. AppArmor implements the targeted security MAC policy, which tries to confine privileged subjects on a system. tect any changes to the base profile so that the Operation Router can be notified to parse the base profile and update its object authority table accordingly.Pathname Collision. By creating a profile namespace per AppArmor namespace and assigning it an identifier, we therefore enable AppArmor namespaces to specify a policy using the combination of profile namespace identifier and the relative pathnames in the profile.Policy Engine. During this process, the Policy Engine will sort and merges rules from profiles, and detect conflicts if there are any. Taking clone system call for example, we added a new constant CLONE NEWIMA and CLONE NEWAPPARMOR that userspace program can specify along with other namespace constants 7 . To evaluate autonomous security control, we emulate a security setting identical to most commercial container clouds where container host applies a very lenient integrity policy (i.e., allow any immutable files to be run within the containers). We created three types of malicious code that an attacker may run within a container, i.e., code that was not signed, code signed with unknown key, and modified code with an invalid signature. This experiment demonstrates that IMA namespace enables containers to have their autonomous integrity control, independent from the integrity policy that host system applies.The second experiment evaluates security, by demonstrating that containers cannot leverage IMA namespace to violate the integrity policy of the host. In this experiment, we emulate a scenario where the host system wants to apply certain integrity control over its containers (e.g., prevent container from hosting malware by allowing only code signed by Ubuntu to run). We thus evaluate the security effectiveness of the AppArmor namespace by showing that container owners can leverage AppArmor namespace to further confine their applications (i.e., have autonomous security control), just like running applications within a VM or directly on the native system.We selected 20 programs that have default AppArmor profiles in Ubuntu and run them in a container 8 . As shown in the table, except 4 programs (Apache, ntp, firefox and chrome), the application profiles of the other 16 programs can be directly applied to the container on top of the host system profile. This demonstrates that 1) containers may not leverage AppArmor namespace to compromise the host, as these conflicting operation will eventually be denied by the system, and 2) our Policy Engine can inform the container at policy load time such that containers will not run into unexpected runtime resource access errors.Conflict Analysis. We found that policy conflicts often involve operations over filesystems that are shared across containers (e.g., /proc, /dev, /sys). For example, it seems not to make much sense for firefox to require read access to all files under /proc in order to files in Ubuntu. Ideally, we can design a better container host security policy by examining each and every file under these shared filesystems and fine tune it to fit the application 9 , but this can be an extremely challenging task given the large amount of information stored on those shared filesystems and the diversified requirements from the containerized applications. As an orthogonal work, we are also investigating if it is possible to use multi-layered filesystem to conceal sharing of /proc, or at least reduce the exposure of files under the shared filesystems. We measured common system calls that are mediated by IMA and AppArmor (e.g., mmap, read, execve, write), but due to space constraint, only mmap is shown. For execve and write, the slowdown is even less obvious due execve and write themselves take longer time to finish. However, for small number of security namespaces (e.g., one or two), our experience suggests that the added complexity of synchronization can often outweigh the mediation latency.We also evaluated the macro performance of AppArmor namespace by measuring the throughput of a containerized Apache with and without a default AppArmor profile(on top of a host profile). Such coarse granularity defeats the purpose of have an SELinux namespace in the first place, since now each SELinux namespace has to work with only one subject label and object label, preventing them from specifying any fine grained security policies.A more practical approach is to enable SELinux namespaces to independently label filesystems. As an example, an web server running in a container can be attached with two labels, native:svirt lxc net t | container:httpd t.The label svirt lxc net t is used by the host system during enforcement of the host's SELinux policy and the label httpd t is used by the container during enforcement of the container's SELinux policy.This approach requires dynamic manipulation of security attributes associated with files during runtime. One reason is that by allowing runtime manipulation of security attributes without reboot and multiple security attributes at the same time, it may add additional complexity that admins may fail to handle properly. Virtual machine [66,58] enables mutually distrusting parties to securely share the same hardware platform therefore becoming one primary success story of the cloud era. A system container [33,35,61] wraps an entire OS into a container, providing system admins and developers an environment similar to traditional virtualization. This paper complements above lines of research by providing kernel security features as a usable function to containers, allowing containers to address their internal threats, much like what a VM or host can do. But instead of time and device, the resource it tries to virtualize are kernel security frameworks.Virtualizing Linux Security Frameworks. However, they still need to properly handle conflicts when an application is under control of multiple principals on a system, and the policy interfaces are often less familiar and more complex (e.g., eBPF programs) than existing kernel security frameworks.In this paper, we presented security namespaces, a kernel abstraction that makes kernel security frameworks available to containers.