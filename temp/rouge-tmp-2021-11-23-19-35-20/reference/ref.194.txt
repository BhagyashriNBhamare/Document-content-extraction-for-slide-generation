To address this challenge, we design and implement CANvas, an automotive network map-per that identifies transmitting ECUs with a pairwise clock offset tracking algorithm and identifies receiving ECUs with a forced ECU isolation technique. Although CAN is the prevailing standard for intra-vehicular communication due to its low cost and robustness, its broadcast nature has enabled many exploits initially exposed by the early work of Koscher et al. [20]. Analogously, with such a tool for scanning a car's network, we could (1) discover potentially malicious ECUs inserted through an attacker, (2) attest to the network configuration of ECUs over time, and (3) identify potential ECUs that are vulnerable to a recent type of attack ( §2). To aid in these scenarios, an ideal network mapper would require three main outputs: (1) the transmitting ECU for each unique CAN message, (2) the set of receiving ECUs for each unique CAN message and (3) a list of all active ECUs in the vehicle. In this paper, we present CANvas, a system that demonstrates a fast and inexpensive automotive network mapper without resorting to vehicle disassembly ( §4). Rather than require physically isolating each ECU, our key insight is to extract message information by re-purposing two observations from prior work:• Identifying message source ( §5): Prior work by Cho et al. [11] state that clock skew is a unique characteristic to a given ECU and thus build an intrusion detection system (IDS) that measures this skew from the timestamps of periodic CAN messages. Contributions and roadmap: In summary, this paper makes the following contributions:• Designing an accurate message source identification algorithm that tracks a message's relative clock offset ( §5); • Engineering a reliable message destination identification method by isolating ECUs with a forced shutdown technique ( §6); • A real implementation that maps five real vehicles and extracted ECUs ( §7) along with two real examples of motivating use cases for mapping ( §2). After defining the automotive network mapping problem and describing typical CAN bus setups ( §3), we highlight the challenges of identifying message information via the CAN protocol and provide an overview of our approach ( §4). If the exploited telematics ECU is able to receive engine messages, then an attacker [10] could shutdown the engine ECU via the exploited telematics ECU.different features in an existing vehicle. If a user does not own the vehicle over its lifetime as in the malicious ECU discovery scenario, we could implement an online database where vehicle owners could upload the outputs of their network maps for comparison against maps generated from brand-new vehicles. We provide an example of this scenario in §7 where we discover lenient message-receive filters in a 2017 Ford Focus.Goals: In designing a useful automotive network mapper, we must consider a few requirements that we impose to ensure practicality in the context of our motivating scenarios: Fast: First, we want to limit the amount of time a vehicle (and its ECUs) are turned on. For our mapper to be practical, it must work on many makes and models of vehicles as well as rely on only standard CAN features.Minimally-intrusive and non-destructive: One extreme approach for mapping a vehicle requires physical disassembly, which is a very intrusive process and requires a great deal of access to the target vehicle. We preface with some necessary background on CAN to understand the overall problem and mapping challenges. In the event of three CAN buses, it is likely that the vehicle has one bus for powertrain components (engine, transmission, etc.), 28th USENIX Security Symposium 391S O F Arbitration ID R T R I D E r 0 D L C DATA C R C ACK E O F I F SAs ECUs lose arbitration, a single transmitter will win Single arbitration winner transmits its data ECUs that correctly receive this message will set the ACK bit Figure 4: Each CAN frame is transmitted on the bus bit-by-bit. An ECU will be responsible for a subset of the message IDs seen in the network, and each message ID will only be sent by a single ECU. Each message is queued by a software task, process or interrupt handler on the ECU, and each ECU will queue a message when the message's associated event occurs.CAN frame format: Each CAN message from an ECU uses its assigned message ID (interchangeably referred to as the ID or the arbitration ID), which determines its priority on the CAN bus and may serve as an identifier for the message's contents. Since a 0-bit is dominant, a message with a lower ID will get priority on the CAN bus and will be sent before a message with a higher ID that is queued at the same time. To develop a mapper that will aid in the motivating scenarios of §2, we formulate three required outputs for CANvas:ECU enumeration: The importance of enumerating ECUs is evident in all of our provided scenarios as seen in Table 1; enumeration highlights new or absent ECUs. Given a CAN traffic dump from a vehicle, CANvas' enumerator should determine the number of ECUs, n, and differentiate between them to determine the set of ECUs E 1:n for that particular vehicle.Message source identification ( §5): In the malicious ECU discovery and continuous network attestation scenarios, changes to the set of transmitted messages for each ECU can pinpoint a potentially malicious reconfiguration. This means that a goal for our mapper is to map each message ID to its source ECU.Formally, given a CAN traffic dump from which we extract the set of uniquely-ID'd messages where l is the number of total unique message/arbitration IDs and I 1:l is the set of unique IDs, we should be able to determine which ECU E i sent each unique message. However, to achieve these mapping goals, we encounter two major challenges to determining the source and destination ECUs for CAN messages: (a) CAN lacks identifying source information and (b) CAN implements a broadcast protocol, which naturally implies that all nodes receive all messages. Lack of source information: If a message sent from ECU E i has no identifying information, then it is non-trivial to determine that E i sent the message. CANvas mapping overview: We split CANvas into two main components: (1) a source mapper and (2) a destination mapper.As detailed in §3, we satisfy our ECU enumeration requirement by simply using the output of source mapping. CANvas systematically isolates each ECU, which will most likely cause the vehicle to enter a temporary error state that the user can reset.User capabilities: We assume that the user has access to the OBD-II port of the vehicle and can connect the CANvas mapper directly to the CAN bus with the ability to read and write to the bus. We further discuss adversarial evasion and other scenarios for bus configurations in §8. Source mapping: With the list of all unique message IDs, the source mapper will extract the timestamped CAN traffic for each ID and determine which IDs share the same source as detailed in §5. Following observations from prior work [11,29] and CAN documentation [2,14], we consider clock skew as a candidate fingerprinting mechanism. We first define the following terms considering two clocks, C 1 and C 2 :• Clock frequency: ered to be synchronized, and two clocks with a nonzero relative clock skew are said to "skew apart," or have an increasing relative offset over time [2]. Since the CAN protocol does not implement a global clock, it is considered to be unsynchronized as each ECU relies on its own local clock.Observation 1: The clock offset and skew of an ECU relative to any other ECU is distinct, thus providing us with a uniquely identifying characteristic for source mapping.High-level idea: To map each unique ID to its transmitting ECU, we break the module into two steps as Figure 6 illustrates: (1) computing either the skew skewf (I i ) or offset offsetf (I i ) of each ID I i and (2) then clustering IDs with the same skew or offset where each cluster denotes a distinct source ECU, E src . Specifically, this work uses timestamps of periodicallyreceived message IDs and posit that IDs with the same skew originate from the same ECU.To compute the clock skew of an ID I i over time, Cho et al. [11] perform the following steps: (1) skewf Cho i (N) = kO i kN = O i N(1)As an extension to this work, Sagong et al. [29] note that the skew of Equation 1 varies significantly based on N and use Sa mpl es 0x262 0x4C8 0x521Figure 7: E A transmits IDs 0x570, 0x571 and 0x572 at the same period and E B transmits IDs 0x262, 0x4C8 and 0x521 at different periods. Our analysis and experiments shed light on why these approaches fail-the skew value they compute is perioddependent.As such, we update Equations 1 and 2 w.r.t. period T and batch size N:skewf Cho i (N, T ) = kO i kT N = O i T N(3)skewf Sagong i (N, T ) = N · kO i kT N = O i T(4)To potentially fix this issue, we can attempt a strawman that is not dependent on period or batch size.skewf Straw i (N, T ) = T N · kO i kT N = O i(5)Ideally, accounting for both batch-size and message-period (essentially batch-period, NT ) using Equation 5 should give us a unique value that is common only among IDs from the same ECU. We also find that some I i produce S I i with more deviation than others and produce widely-varying skew values, thus making our straw-man solution an unlikely candidate for source mapping.Observation 2: We need a method of extracting the clock skew invariant that is: (a) independent of the period of I i and (b) robust to noise in the period. We must note that the clock offset measured from one ID, I 1 , of an E src may not be the same as the offset of another ID, I 2 , from E src . To address the issue of noise in the period of I i , p I i , we compute the relative offset between a pair Figure 8: Timeline of two message IDs, I 1 and I 2 , that have periods, p 1 = 7ms and p 2 = 9ms. Observation 3: Compute offset at the hyper-period of I 1 and I 2 , or the least common multiple of their periods.Measuring offset at the hyper-period: To guide our algorithm design for computing ∆O I 1 ,I 2 over time, we first model two periodically-transmitted IDs observed on the CAN bus. To accurately compute the relative offset of these two IDs, O I 1 ,I 2 , we must select a time instant when the expected offset should also be 0: the hyper-period of I 1 and I 2 , or the least common multiple of p 1 and p 2 . If this relative offset is a nonzero constant, then the two IDs originate from the same ECU.With an input of several minutes of timestamped CAN data to Algorithm 1, we can track relative offset over the timeline of two message IDs. By computing the difference between every n occurrences of I 1 and every m occurrences of I 2 , which occurs at the hyperperiod of I 1 and I 2 , we produce the following equation:O I 1 ,I 2 = (mp 2 + O I 2 + i 2 ) − (np 1 + O I 1 + i 1 )We find that when we average the result of the above equation across the entire data log, the expected value is 0 if I 1 and I 2 originate from the same ECU. Using this approach to revisit the setup described in Figure 7, we correctly conclude that IDs 0x262, 0x4C8 and 0x521 originate from the same ECU.Practical challenges: While the above approach is correct, there are a number of other practical challenges we need to address to ensure accurate mapping:1. Fortunately, with a pairwise approach, we can choose to not attempt a comparison when the hyper-period is large; for example, if we assume that the E src of I 1 also transmits another ID, I 3 , where the hyper-period of I 1 and I 3 is small, we can still determine that I 1 , I 3 ∈ E src . Therefore, CANvas will choose to test I i on the following cases when its σ p i is under a defined threshold, which we set to σ p i ≤ 0.08p i from our experiments. In the event we compare two I i that both occasionally stop and there is no overlap of active transmissions, we then rely on our pairwise approach to match the I i to another ID from the same E src . To interpolate a missed arrival time, we insert a psuedo-entry in the traffic log with a timestamp equal to the average of the preceding and the following timestamp.Factors for mapping time: For source mapping, we experimentally find that 30 minutes of data provides enough samples for larger hyper-periods to map accurately. The more message IDs that exist in the network, the longer the mapping time takes; vehicles with more message IDs take longer to complete mapping due to an increase in messagepairs. Consider the scenario in Figure 9 where there was only one active destination ECU, E dst , in the network other than the transmitting source ECU, E src . For each message sent by E src , a set ACK bit (performed only by E dst ) would indicate that only one ECU received the message: E dst . We describe the three CAN error-states and, under what conditions, the ECU will transition:• Error-active: When an error is detected by an ECU in error-active, it will transmit an active error flag, or 6 dominant bits, that destroy the bus traffic. When either the TEC or REC increments past 127, the ECU transitions to errorpassive. By exploiting the error-handling protocol in CAN, where bus-off effectively removes an ECU from the network, they choose to increment the error counter of a target by causing a bit error. The number of injection attempts needed to cause a single bit error, κ, is defined as the following where I is a confidence attack parameter (high parameter value means higher confidence in attack), σ p v is the jitter deviation of the victim's period, and S bus is the speed of the bus in Kbps:κ = 2 √ 2Iσ p v S bus 124 (6)The authors state that only one of these injections is needed to cause a bit error if setting I = 3 and at most 2 if setting I = 4, given that the period deviation is 0.025ms. Straw-man limitations: Suppose we used the above ap- proach to cause a bus-off in a real vehicle. Since the majority of messages have a period deviation greater than 0.205ms, it is highly unlikely to use this method for isolating an ECU.Observation 5: We need a method of transitioning an ECU into the bus-off state that is reliable and robust even when the period deviates by more than 0.025ms. High-level idea: To map each unique ID to its set of destination ECUs, we break the module into two steps. Observation 6: By reading the ID of the message in real-time, we can choose to attack any ID by simply driving a dominant bit to the CAN transceiver.Note that the bus-off method requires attacking a message ID every time it occurs until the ECU enters the bus-off state. As such, we can employ the result of CANvas' source mapping component by identifying the ID with the smallest period per ECU and attacking just that ID. Thus, this approach makes the destination mapping component of CANvas fast.Determining message receive filter: Now that we can isolate a single ECU in the network, we can simply inject all messages in the observed ID space and determine which messages are correctly received by the ECU. As such, if we transmit a message and see a continuous stream of the same ID from our transmitter, then we may conclude that the message ID is not received by the isolated ECU.Practical challenges of mapping a real vehicle: Since our approach to destination mapping involves shutting off multiple ECUs at a time, we encounter a couple of challenges in a real vehicle setting: (1) ECUs that auto-recover and (2) ECUs that are persistently active. We find that these ECUs would wait a predefined amount of time before re-transmitting again as these ECUs were critical to the vehicle's powertrain (engine, hybrid, etc.) [14]. In this situation, we must "hold" the bus open by constantly transmitting false messages from our device to trick the recovering ECU into thinking that the bus is still active.Factors for mapping time: For destination mapping, the run-time is dependent on the number of ECUs and increases with more ECUs. Also, for our two vehicles, all observed IDs were active when the vehicle was simply in ACC rather than ON so there may be no need to crank the engine per ECU. Below is a brief description of the CANvas hardware implementation, five real vehicles and our synthetic network of real ECUs:• Mapping device: To interface with a CAN bus, our mapping device consists of three components: an Arduino Due microcontroller with an 84 MHz clock and an on-board CAN controller, a TI VP232 CAN transceiver, and a 120Ω resistor. • '09 Toyota Prius and '17 Ford Focus: The Prius contains eight original ECUs that transmit on a single CAN bus at 500 kbps. We use a paid subscription to both Toyota and Ford's mechanics' manuals [3,6] for guidance on disassembly of vehicle components. Even after manually disconnecting all eight known ECUs, we still observed CAN traffic, specifically IDs I 570−572 , coming from a single ECU. The Prius had an additional battery installed to grant it all-electric capabilities, and with the use of the network mapper, we now know that a new CAN-enabled device was added. We now present results and observations from mapping both the Prius and Focus.Source mapping results: Using a threshold of 1ms and 30 minutes of traffic collection, we get a false positive rate of 0% for both vehicles, permitting us to get a sound source mapping output. The majority of our messages matched with multiple IDs from the same ECUs but due to the large period of I 57F and I 602 , they only had a single match. Destination mapping results: With a CAN bus running at 500 kbps, we discover that all of the ECUs in the Prius do not implement any filtering between the network and the CAN controller. We do observe two ECUs that recover quickly from the busoff method, specifically the engine control module and the skid control ECU. By collecting data from these three ECUs, we found that they shared the many of the same message IDs and conclude that they are based off of the same engine controller configuration. As they all auto-recover, they were prime candidates for testing our forced ECU isolation technique.We use CANvas on three other vehicles to look for data that seems logical to our findings from the test cars. CANvas instead could discover ECUs that do not actively inject messages but rather change the ID-ECU source mapping (a new ECU or existing ECU that sends different IDs). Additionally, as our destination mapping approach deals with the error-handling mechanism, it would also not be practical to change these basics of CAN.Avoiding permanent damage: We take care to avoid any damage to our test vehicles. Even with our active interaction with the bus in destination mapping, most dash lights that turn on are simply reset by power cycling the car; it may sometimes be necessary to drive the car for a few minutes so the ECUs can identify the absence of a real error. In the event of network communication failure (e.g. bus-off), manufacturers implement a "limp-home" mode where ECUs will default to secondary programming and allow the vehicle to operate with limited capabilities [7]. These CAN buses are often accessible at the OBD-II port but on different pins that are vendor optional: pins 3 and 11 and pins 1 and 8/9. When the receiving ECU gets behind on processing these messages, it will transmit an overload frame, indicating its acceptance filter allows the injected message ID; if the ID is dropped, then no overload frame will be present.Non-transmitting ECUs: CANvas expects ECUs to transmit their messages periodically, but it is possible for ECUs to only activate under certain conditions or simply read from the network. We discuss other related efforts here.Automotive attacks: There have been a number of efforts at demonstrating vulnerabilities of automotive networks, including work on injecting messages [20], attacking keyless entry systems [8,16,28], and specific components such as TPMS [17,18]. CANvas does not even need physical access to the bus for source mapping as we only require a hardware-timestamped traffic log, and we operate solely from the OBD-II port without an additional permanent device. This work is made available [1] to encourage the community to add richer functionality and use CANvas to further the creation of automotive security tools.