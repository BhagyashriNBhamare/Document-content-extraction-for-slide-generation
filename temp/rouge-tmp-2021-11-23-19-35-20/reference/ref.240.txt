Click-jacking protection on the modern Web is commonly enforced via client-side security mechanisms for framing control, like the X-Frame-Options header (XFO) and Content Security Policy (CSP). In particular, inconsistencies might arise due to the lack of support for CSP and the different implementations of the un-derspecified XFO header. In this paper, we formally study the problem of inconsistencies in framing control policies across different browsers and we implement an automated policy analyzer based on our theory, which we use to assess the state of click-jacking protection on the Web. In this paper, we are concerned about inconsistencies in framing control, a cornerstone of Web application security, which pioneered the adoption of client-side security mechanisms.Framing control constrains the inclusion of Web content inside iframes (sub-documents) opened by malicious pages and it is particularly useful to prevent click-jacking attacks [7]. Unfortunately, since XFO was not standardized a priori, different browser vendors provided different implementations, leading to differing support of its directives and attacks like double framing in some browsers [20]. We use this framework to formalize the notion of policy consistency and to observe that not every inconsistency is equally dangerous. we develop a policy analyzer (dubbed FRAMECHECK) based on the proposed theory, which enables an automated security assessment of the state of click-jacking protection on a given Web page. we run FRAMECHECK on policies collected from 10,000 popular websites from the Tranco list [18] and we assess their effectiveness. In the interest of open science, we make both our server-side proxy and the FRAMECHECK core available online. 1,2 In this section, we review framing-based attacks and the most popular client-side defense mechanisms against them. The nature of HTML and CSS allows the developers of a Web site fine-grained control over how elements are placed and shown in the browser. At that time, Firefox and Internet Explorer supported three different directives for the XFO header: SAMEORIGIN to allow framing only from pages with the same origin (i.e., protocol, host, and port), ALLOW-FROM origin to selectively allow framing from a single origin or DENY to block framing completely. Importantly, although an XFO specification exists in the form of RFC 7034 [9], that specification was written after various browsers had implemented XFO and notes that "not all browsers implement X-Frame-Options in exactly the same way, which can lead to unintended results". We dive deeper into the actual inconsistencies and their impact in Section 4.2. First, as the name suggests, the frame-ancestors directive performs the origin check for framing based on the whole chain of nested frames (ancestors) between the top-level browsing context and the framed page, which offers the strongest security guarantees by ruling out double framing. Hence, administrators have an easier job at maintaining a whitelist of sites through CSP; achieving the same through XFO is only possible by checking the Referer header of incoming HTTP requests. We refer to this mechanism as Referer sniffing.In this paper, we refer to browsers supporting framing control via CSP as modern browsers; we deem all the other browsers as legacy. To understand how the CoreCSP denotational semantics is defined, assume that http://www.foo.com deploys the following CSP:frame-ancestors *.foo.com https://* Since the protected page is served over HTTP, the semantics of the policy is formalized by the directive value {(http, * . We build on CoreCSP because directive values can be ordered by a relation such that v 1 v 2 if and only if the set of origins represented by v 1 is contained in the set of origins represented by v 2 [4]. The policy of the Web page w is consistent for the set of browsers B if and only if, for all b 1 , b 2 ∈ B, we have w b 1 w b 2 and w b 2 w b 1 . 3 To improve protection, the Web site might then additionally specify a CSP of the following form:frame-ancestors https://www.example.comThe revised framing control policy is consistent for Edge and Chrome since CSP takes precedence over XFO. Assume that https://www.example.com only relies on CSP for framing control, specifying the policy:frame-ancestors https://*.example.comThis policy is inconsistent, because it restricts framing in Chrome, but does not protect the users of legacy browsers without CSP support. Note that since the XFO policy is less permissive than the CSP policy, this might lead to compatibility issues in legacy browsers, e.g., if framing is required from https://mail.example.com, yet users of such browsers are protected against click-jacking. Formally, this is formulated by the following definition.Definition 2 (Security-Oriented Policy). The policy of the Web page w is security-oriented for the set of browsers B if and only if it is possible to partition B in two sets B l , B m such that all these properties hold true:• B l only includes legacy browsers and B m only includes modern browsers;• the policy of w is consistent for both B l and B m ;• for all b 1 ∈ B l and b 2 ∈ B m we havew b 1 w b 2 . The policy of the Web page w is compatibility-oriented for the set of browsers B if and only if it is possible to partition B in two sets B l , B m such that all these properties hold true:• B l only includes legacy browsers and B m only includes modern browsers;• the policy of w is consistent for both B l and B m ;• for all b 1 ∈ B l and b 2 ∈ B m we have w b 2 w b 1 . Instead, the original policy of Example 1 is not even compatibilityoriented, since two modern browsers like Chrome and Edge give different interpretations to the policy, due to Chrome's lack of support for ALLOW-FROM. Observe that a policy is consistent if and only if it is both security-oriented and compatibility-oriented. Inconsistent policies which are neither security-oriented nor compatibility-oriented are generally hard to justify as correct because they fall in one of the following cases:• two legacy browsers interpret the policy differently;• two modern browsers interpret the policy differently;• none of the above is true, yet legacy browsers and modern browsers give two incomparable interpretations of the same policy.We refer to such policies as unduly inconsistent. Our tool is parametric with respect to a set of browsers B.Each browser b ∈ B is characterized by two ingredients:1. The Table 2: Browsers considered in the present study set of browsers under study is shown in Table 2: only two browsers do not support framing control via CSP, i.e., Internet Explorer and Opera Mini, which we deem as legacy. This means that every Web page which adopts the ALLOW-FROM directive, but does not deploy a corresponding CSP, implements inconsistent protection against click-jacking and leaves (at least) 7 browsers unprotected.We also tested what happens when the ALLOW-FROM directive is not followed by a valid serialized origin (e.g., https://example.com), as mandated by the XFO specification. The HTTP protocol specification in RFC 7230 mandates that it must be possible to replace multiple headers with the same name with a single header that includes a comma-separated list of the header values [8]. However, there are still 3 browsers that are susceptible to double framing attacks: Edge, Internet Explorer, and UC Browser.In the rest of the paper, we do not consider inconsistencies arising from double framing, because otherwise even trivial XFO policies like SAMEORIGIN would be considered inconsistent and bias our study. Chrome Chrome for Android Edge Firefox Internet Explorer Opera Mini Safari Safari for iOS Samsung Internet UC Browser In this section, we report on a large-scale analysis performed in the wild with our policy analyzer. As we did not only want to check the start pages in a static manner, we instead used a Chrome-based crawler to visit the start pages, collect all links on them, and follow those links up to at most 500 items per site. We then retrieved the XFO and CSP headers of the collected URLs, sending each request to a URL once for each of the different user-agent strings considered in our study.For this step, we primarily relied on Python's Requests library to collect data. Of those, 369,606 URLs (37%) across 5,835 sites carried either an XFO or CSP header aimed at framing control. Overall, we identified 1,800 policies from 1,779 origins implementing inconsistent protection against click-jacking, i.e., where the enforced level of protection is dependent on the browser. Moreover, note that 805 out of the 1,484 pages (54%) which make use of both XFO and CSP together implement inconsistent protection against click-jacking, i.e., it is more likely to get the combination of the two defenses wrong than right.Another interesting insight from our analysis is that 84% of the inconsistent policies make use of CSP. Hence, one might think that inconsistencies are motivated by its presence alone, yet this is not the case: if we removed Opera Mini from the set of browsers, the number of inconsistent policies would drop from 1,800 to 1,749, which is roughly a 3% reduction. To have a more in-depth look into the set of inconsistent policies, we performed a further classification step: in particular, we identified 590 security-oriented policies (33%) and 795 compatibility-oriented policies (44%), while the other 415 inconsistent policies (23%) do not belong to any of these two classes, hence are unduly inconsistent. For example, the Web site https://www.icloud.com deploys an XFO header set to SAMEORIGIN and a CSP whitelisting every subdomain of icloud.com and apple.com. The other policies all take advantage of the additional expressive power of CSP over XFO for fine-grained whitelisting: specifically, we observed 99 cases (17%) where CSP was used to whitelist all the subdomains of the host whitelisted via XFO, while in all other cases CSP whitelisted at least two source expressions.To the best of our knowledge, these look like legitimate use cases, where policy inconsistency is not necessarily dangerous for security. Compatibility-oriented policies might be justified by the need to make Web applications accessible by legacy browsers, at the cost of (partially) sacrificing security in that case. In particular, we found 705 pages where an XFO header is entirely absent (89%) and 99 pages where the XFO headers contain an incorrect directive or are misinterpreted by some legacy browser (11%). This shows that most Web developers are not actually concerned about offering security to users of legacy browsers, or are just entirely unaware of the existence of this problem.To get a better understanding of the reasons underlying the existence of compatibility-oriented policies, we analyze the combination of XFO and CSP for the following scenario: if CSP is used to whitelist at most one origin, it is straightforward to write an XFO header which enforces exactly the same restrictions, hence the adoption of a compatibility-oriented policy is unjustified. As another example, https://whois.web.com sends two XFO headers, one set to SAMEORIGIN and one set to DENY, which allows same-origin framing in some browsers but not others.It is instructive to have a look at why these undue inconsistencies arise. It turns out that the total number of inconsistent policies would drop from 1,800 to 289, which is a major improvement. Though legacy browsers not supporting CSP are likely going to disappear in a few years, it is hard to predict a precise temporal horizon for this: for example, Internet Explorer 11 was launched in 2013, and it still has ∼ 2% of the market share based on publicly available data, while Opera Mini is still under active development and extremely popular with around 15% market share in Africa, where mobile traffic is still expensive. We discuss recommendations and countermeasures in the next section. However, we argue that it is fair to assume that site operators are deploying framing control for a reason. In our opinion, the widespread adoption of framing control policies (33% of all crawled URLs, spread across 58% of the sites we looked at) motivates that click-jacking is perceived as an important security threat. XFO alone is insufficient for security because sites might be prone to double framing attacks (also in modern browsers like UC Browser) or even not protected at all (most notably, in the presence of the largely unsupported ALLOW-FROM directive). Unfortunately, we found that only 8% of the collected policies use both XFO and CSP. These headers are parsed as multiple XFO headers in most browsers, while in other browsers, they are interpreted as non-existing directives that do not enforce any form of framing control. Though the frame-ancestors directive obsoleted XFO back in 2014, XFO is still very popular in the wild: 88% of the policies we collected are still based on XFO alone. We designed one such solution as part of our server-side proxy (see Section 6.3), which might be inspiring also for browser vendors since the same approach could be applied at the client. Though the auto-update feature of modern browsers certainly helps in mitigating the problem of inconsistencies, real-world market share data show that legacy browsers are hard to eradicate. It inspects the HTTP traffic to automatically fix the framing control headers so as to ensure policy consistency. To enable researchers to build on our work and website administrators to benefit from the tool, we have made the proxy available at https://github.com/cispa/framing-control-proxy.In particular, for any request r, let r stand for the corresponding HTTP response. This is straightforward, since CSP is more expressive than XFO, and does not conflict with other CSP headers possibly present in r, since, when multiple CSP headers are sent, their conjunction is enforced and no other frame-ancestors directive is present.If r contains CSP headers with a frame-ancestors directive, the proxy instead behaves as follows:1. Otherwise, the proxy checks if the Referer header of r contains a URL whitelisted by any of the source expressions identified at step 2: if this is the case, r is extended with an XFO header containing an ALLOW-FROM directive set to the origin of the Referer header; otherwise, the XFO header is set to DENY. This means that it is occasionally possible for the proxy to relax security restrictions beyond least privilege: for example, if a page sets XFO to DENY and CSP allows same-origin framing, then XFO will be relaxed to SAMEORIGIN. The increased importance of CSP for framing control was also documented by Roth et al. [19], who analyzed the evolution of CSP from 2012 to 2018, indicating that CSP has become more and more popular as a protection mechanism against click-jacking. In particular: (i) we formally define the problem of inconsistencies in framing control policies to provide a full account of this security problem, highlighting different classes of inconsistencies with different security implications; (ii) we focus on both desktop browsers and mobile browsers, exposing many new and unreported dangerous implementations of the underspecified XFO header; (iii) we perform an in-depth analysis of several root causes of inconsistencies in the wild, their security import, and some possible countermeasures, discussing the potential role of browser vendors on the way forward; and (iv) we implement and release a server-side proxy designed to retrofit security in existing Web applications by enforcing consistency for the set of browsers that we analyzed.Click-Jacking Protection and Attacks In 2010, Rydstedt et al. [20] studied the usage of frame busting scripts in the Alexa Top 500 sites, showing that the deployed mechanisms through JavaScript were trivial to bypass. Albeit only indirectly related to our paper, these works clearly document the dangers of inconsistent implementations on the Web. We based our investigation on a formal framework, which constituted the basis for the implementation of a real-world policy analyzer dubbed FRAMECHECK. Given the insights of the dangers caused through inconsistencies, we proposed different countermeasures in terms of recommendations for Web developers and browser vendors, as well as the implementation of a server-side proxy designed to retrofit security to existing Web applications.