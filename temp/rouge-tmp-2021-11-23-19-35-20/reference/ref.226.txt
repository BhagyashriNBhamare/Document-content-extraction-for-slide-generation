This paper exposes a new vulnerability and introduces a corresponding attack, the NoneXistent Name Server Attack (NXNSAttack), that disrupts and may paralyze the DNS system, making it difficult or impossible for Internet users to access websites, web e-mail, online video chats, or any other online resource. Following the discovery of the attack, a responsible disclosure procedure was carried out, and several DNS vendors and public providers have issued a CVE and patched their systems. Partial support provided by the Blavatnik Interdisciplinary Cyber Research Center, (ICRC). Finally, we suggest and analyze modifications to the recursive resolver algorithms, called MaxFetch(1) and Max-Breadth, which drastically reduce the effectiveness of this attack.At an abstract level, the DNS system has two parts, each of which is a large, highly distributed system: a hierarchical and dynamic database of authoritative name servers storing the DNS data, and a large number of client-facing resolvers, located either locally at the service providers and local organizations, or as cloud public services (e.g., CloudFlare 1.1.1.1, and Google 8.8.8.8) that walk through the hierarchical structure to retrieve the domain name resolutions to IP addresses. One of our main observations is that the information in the NS referral responses, at the different recursive steps, and the actions taken by the recursive resolvers as a result, may introduce huge communication and other resource overheads.These overheads occur mainly because the name servers in the NS referral response are not always provided with their corresponding IP addresses (known as glue records). The NXNSAttack simulations saturate the recursive resolver's cache (with NX & NS records) and reach a packet amplification factor (PAF) of more than 1600x (variant a). We then show how the BIND DNS resolver algorithm can be enhanced to remove unnecessary proactive fetches ( §5), thus alleviating the vulnerability, and measure the performance improvements. In particular, we show that our MaxFetch(1) enhancement has no negative impact on either the latency or throughput of the enhanced recursive resolver.Finally ( §6), we quantify the pervasiveness of domains with out-of-bailiwick name servers in: (i) the top million domain resolutions, and (ii) in a campus DNS traffic trace.Since the inefficiencies and vulnerabilities we uncover are associated mostly with referral responses that contain many name servers without an associated IP address, we study the prevalence of the phenomenon. It starts by issuing a query to one of the root servers (e.g., A.ROOT-SERVERS.NET, whose IP address is hard coded into the recursive resolver), asking for the address of www.microsoft.com (step 1 in Figure 1). com TLD server responds with another NS referral response (step 4) delegating the query to one of a few SLD (Secondary Level Domain) name servers responsible for the 'microsoft.com' zone. The red steps are the mandatory messages required to answer the client query.For example, microsoft.com resolution requires 54 IPv4 packets (actually 126, but we exclude TCP handshake and control packets that are used when the responses are too large due to additional records and EDNS), twitter.com resolution requires 388 packets and www.gov.uk requires 102. A detailed analysis of two data sets carried out in §5.3 shows for example that 61.56% of the 'A' queries for the top million domains result in considerably more messages than expected in theory.Name server referral response: In resolving a domain name, when the cache is empty, the resolver traverses the authoritative hierarchy starting from the root server. In such a referral message, an authoritative server tells the recursive resolver: "I do not have the answer, go and ask one of these name servers, e.g., ns1, ns2, etc., that should get you closer to the answer". By RFC 1034 [24] glue records are required only if the NS is lying within or below the zone or domain for which it acts as a name server. For example, if the recursive resolves www.example.com and the TLD returns a referral containing ns5.example.com as a delegated name server which resides within the example.com domain, but without its IP address, the recursive will then initiate another A query asking to resolve ns5.example.com. When responding to a query from a recursive resolver, such a malicious authoritative server can send an NS referral record that includes any domain name as a NS with a glue record mapping this domain name to any IP address, thus injecting or overriding a bogus A record for any domain into the recursive resolver cache. Generally, without getting into different variations and implementation details, the BIND [15] recursive implementation, which we analyze in this paper, as well as Unbound [19], PowerDNS [2] and Microsoft DNS, all discard out-of-bailiwick glue records. Other solutions to eliminate cache poisoning attacks as a result of out-of-bailiwick glue records include DNSSEC, which authenticates the authoritative responses by verifying their signature through a chain of authority. com authoritative responds with an NS referral (step 2) containing four out-of-bailiwick name servers (ns*.msft.net for the queried zone microsoft.com). This is because their corresponding requests' recursion state was already initiated independently with an indication that they are not cached.Note that we observe additional causes for the high number of messages in DNS resolutions: (i) too long NS responses that include multiple name servers and other options such as RRSIG and NSEC3 data in the additional records, leaving no place for all the glue records in a 512-byte UDP packet, forcing the recursive to resend the request using TCP, or by using the UDP EDNS0 4096-byte option. We claim that the resolution of the referred name servers should be distributed and amortized over several client requests (see §5), in contrast to the current practice where all the resolutions are performed in the first client request. Moreover, many domains outsource their authoritative name servers to cloud operators such as Cloudflare, Google.com, or domaincontrol.com, and these operators often choose short TTL values (30 or 60 seconds). The attacker uses an authoritative server that it owns to craft a response to a resolver with a referral that contains n new and nonexistent name server names without an associated IP address, thereby causing the resolver to start the process of F new resolutions. To mount a NXNSAttack on either a recursive resolver or an authoritative server, an attacker should:1. Authoritative name servers are easily and cheaply acquired by first buying and registering new domain names (for our experiments, we purchased several domain names for less than $1 each in less than 5 minutes). Alternatively, attackers today are able to compromise DNS operators' credentials and manipulate zone-files, sometimes even gaining access to their registrar records, as exemplified by recent DNS hijacking attacks [10,23]. The attacker's authoritative referral response issues n new and different delegated name server names each time it receives a query for a sub-domain from the recursive resolver.The Figure 5: NXNSAttack targeting the authoritative server (a) and the recursive resolver (b) three ingredients in a variety of ways:The bogus name server domains placed by the attacker authoritative in the referral response determine the target authoritative server, which could be at different levels of the DNS hierarchy.Multiplicity of clients and/or resolvers to target a single authoritative (Fig. 5a), or multiplicity of authoritatives to target a particular recursive resolver (Fig. 5b). The resolver then sends F 1 = 2n 1 new requests to the attacker authoritative, which then crafts and issues F 1 new referral responses (see Fig. 6), each of which contains n 2 delegations of the attacker's choosing. (Fig. 5b) Here the maximum packet amplification factor (PAF) is 1620x (both according to our model and empirically; see §4), achieved when the referral delegations are to different TLD name servers (e.g., fake1.com, fake2.com, ...,fake1.net, ...). The high victim cost is because the first referral response from the attacker contains delegations to 37 new and different sub-domains of the attacker (e.g., sd1.attacker.com, ..., sd37.attacker.com), which results in 74 more requests (IPv4 and IPv6 for each delegated ns) to the attacker from the recursive resolver. The attacker's authoritative name server then responds with 74 crafted referrals, each containing 135 delegations to the ROOT server (e.g., domain.fake or domain.tld, where the TLD name servers are not cached in the recursive resolver), which in turn receives 18, 980 concurrent requests; see §4.3 for the cost and amplification factor analysis. In this section we present the corresponding numbers that were measured in our testbed setup and an analysis that explains them.Recall that if the recursive resolver receives a referral response that delegates the original request to n name server names, without providing their IP address (no glue records), it then generates -in theory -2n requests to resolve IPv4 and IPv6, for each of these n names. Queries to look up top level domains such as '.com' and '.net' and the DNS root zone are exempt from this limitation. This is sufficient to resolve 37 names, requesting separately the IPv4 and IPv6 address of each, resulting in F = 74, unless the requests are sent to either the root or a TLD name server, in which case, n max is the only limiting factor, yielding F = 2n max = 270. In Subsection 4.1 we computed F , the amplifier firepower, which is the total number of DNS requests generated by the amplifier, which was 2(min(n, (M ax_rq − 1)/2)) if the attack is on an SLD domain, and 2n if the attack is on a TLD or on root servers (results in F = 74 and 270 respectively). We measure it in our setup and explain (calculate) the observed numbers by analyzing the BIND protocol.We claim that the cost to the victim in packets, denoted C pkt v , as a result of one client request, as a function of F , is:C pkt v = 2 · F · (1 + 5 · T C),(1)where T C, the value of the truncate bit in the DNS protocol, equals 1 if the F requests fall back to TCP, and 0 otherwise. Traditionally, in DDoS bandwidth attacks, the packets/bytes amplification factor is the number of packets/bytes that are sent to the victim divided by the number of packets/bytes the attacker has sent. Therefore, our analysis of the amplification factor considers the packets the victim (the recursive or the authoritative) receives and sends.Equation (1) provides C pkt v , the cost incurred by the victim (recursive resolver or authoritative server) when attacked by the amplifier. com and other TLD name servers are external to our setup, we initiated only a few requests for sd*.attacker.com, while monitoring the recursive resolver behavior.In our setup, n max turned out to be 135. com TLD name servers, asking 'who is ns1.fakens*.com?' However, all TLD responses also contain a SOA record, RRSIG and multiple NSEC3 signatures (DNSSEC signatures), thus exceeding the maximum response size of 512 bytes. Moreover, as described in Figure 5a, several resolvers may be used to mount a massive attack on any TLD or root server. (b) Authoritative SLD attack: To attack a particular SLD server, each attacker's referral is crafted to contain delegations to many new and different subdomains of the victim SLD (e.g., fakens1.victim.com, fakens2.victim.com, ...). To attack a TLD or root servers (a tough challenge since there are hundreds of them), one can try variant a, or try this variant with many fewer client requests, as described; see §3.2 and Fig. The attacker's first referral (step 3 in the figure) contains n 1 different sub-domains of itself (e.g., sd1.attacker.com, ... , sdF1.attacker.com), causing the resolver to send 2n 1 additional queries (step 4) to resolve the IPv4 and IPv6 addresses of these delegated name servers. This results in a total of 2 · F 1 · n 2 delegations, each of which is a name of a fake TLD server (e.g., ns.fake1, ns.fake2, .... , ns.fakeF1xF1x2). As shown in Table 2, F of this variant is 74; thus we include 37 name servers names in each NS referral response. As shown in Figure 7 (see the 'Original BIND' line), 10,000 0 1,000 2,000 3,000 4,000 5,000 6,000 7,000 8,000 9,000 10,000 attacker requests result in 1,500,319 packets involved in the recursive resolutions, producing a constant PAF of 75x. We used attack variation b, in which an SLD authoritative is the victim, and we used our own ns.victim.com as the victim. We could not test variants a and c because these require monitoring the recursive resolver or the TLD/ROOT servers. The NXNSAttack consumes memory and 'NS', 'NX' and even 'A' (in variant c) cache records, while the NXDomain attack consumes only 'NX' cache records at a much slower pace. In conclusion, since large recursive resolvers were knocked down by the NXDomain attacks [29,31], they are more likely to be knocked down by the NXNSAttack. As a reference, the max throughput that we measured under non-attack traffic (e.g., a campus DNS trace and top million domains) varies from 6,000 (in the case that most of the requests are not cached) to more than 100,000 Qps (where most of the requests are already in the cache). Several different approaches may be taken to mitigate and reduce the NXNSAttack effect. While MaxFetch(k) is the simplest to integrate and directly patches the problem, we briefly mention few approaches, before diving into the details of MaxFetch(k) in the following subsections:MaxFetch(k): Do not resolve all the name server domains in a received referral response at once, but rather, k per each original client request. This cannot happen in normal operation unless there is a configuration error. This can be combined with the above NX replies detection method.Max Breadth: The MaxFetch(k) proposal mitigates and significantly reduces the PAF (and BAF) of the attack; however, the attack still consumes large amounts of memory and cache (NX, NS records) per client request, in particular variant c. Then, on each subsequent client request that results in the same referral, make one (or more) additional name server name resolutions.We modified the BIND 9.12.3 resolver algorithm to implement MaxFetch(1). In Figure 7 ( §4.1) we compare the PAF of the original BIND to that of the MaxFetch(1) variant, during a long-lived simulated NXNSAttack against an SLD victim. We also repeated the stress tests as in §4.5 to measure the maximal number of client queries per second that the BIND resolver is able to sustain under the NXNSAttack with and without MaxFetch(1). The purpose is twofold: first, we wish to verify that the MaxFetch(1) modification does not incur query delays or resolution failures (i.e., the number of SERVFAIL and NOERROR responses is not higher than that observed in the original BIND). Out of the 1,027,359 queries to domains that do not reside within the campus zone, we took the 386,736 'A' queries, with 10,092 unique ones.Ethical Consideration: Dataset B is a sequence of DNS queries with their timestamps but without the IP addresses that originated them.With each dataset, we send its query stream (100,000 queries in Dataset A, and 386,736 queries in Dataset B) to both original BIND and BIND with MaxFetch(1). The response time is slightly faster using MaxFetch (1) The latency values for both datasets with and without MaxFetch(1) are between 0 and 5 seconds. Here, for each request for do- Latency (ms) Orig BIND Figure 10: Dataset A, 99 th percentile BIND latency with and without MaxFetch(1). We show that the majority of the domains out of the top 1M popular sites [21] have outof-bailiwick name servers. The first, strict definition describes a name server whose name is subordinate to the owner name of the NS resource record (e.g., ns.child.example.com as name server for the domain 'example.com'). The second, wider definition refers to a name server's name that is subordinate to the zone origin and not subordinate to the owner of the NS resource record (e.g., ns.another.com as name server for the domain 'example.com'). Additionally, according to the strict definition of in-bailiwick, we found that only 70,596 name server out of 2,394,475 (2.95%) are in-bailiwick, i.e., their name servers names are within the domain name (for example, 'ns.example.com' as a name server for the domain 'example.com'). Out of the 1 million we tested, 218,747 (21%) domains use ns.cloudflare.com and 129,789 use domaincontrol.com. Some measures have been taken by different DNS vendors such as BIND and UNBOUND following the disclosure of iDNS described in [22]; however these measures do not affect and do not weaken the NXNSAttack.Wang [35] focuses on the DNS security implications of glue records. He describes how recursive resolver implementations such as BIND and Unbound treat glue records, but the focus is on cache poisoning vulnerabilities rather than the impact on the recursive performance, which is the focus of the current paper.Muller et al. [28] perform a comprehensive measurement using the RIPE atlas to analyze how recursive resolvers select which name server to interact with, out of a set of multiple authoritative servers. We started off researching the efficiency of recursive resolvers and their behavior under different attacks, but we ended up finding a new, devastating vulnerability, the NXNSAttack.The key ingredients of the new attack are (i) the ease with which one can own or control an authoritative name server, (ii) the use of nonexistent domain names for name servers, and (iii) the extra redundancy placed in the DNS structure to achieve fault tolerance and fast response time.We note that some of the possible remedies, such as various rate limiters, are a double-edged sword; a sophisticated attacker may use them to deny service to legitimate clients, by hitting the limiter's thresholds with malicious requests.Notice that DoH (DNS over Http) is irrelevant to this paper because it deals with the communication channel between a client and its recursive resolver while we focus here on the communications between the recursive resolver and the authoritative structure.