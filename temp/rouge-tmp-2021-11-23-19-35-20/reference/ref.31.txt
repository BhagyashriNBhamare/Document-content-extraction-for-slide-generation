We model heap overflows as spatial inconsistencies between heap allocation and heap access operations, and perform an in-depth offline analysis on representative program execution traces to identify heap overflows. We implemented a prototype of HOTracer, evaluated it on 17 real world applications, and found 47 previously unknown heap vulnerabilities, showing its effectiveness. As effective defenses [3,12,15,19,24,35,46,47] against stack corruption are deployed gradually, nowadays heap overflow vulnerabilities become more popular. But attackers could utilize techniques like heap spray [16] and heap fengshui [43] to arrange the heap layout and reliably launch attacks, making heap overflow a realistic threat.Several solutions are proposed to protect heap overflow from being exploited, e.g., Diehard [4], Dieharder [34], Heaptherapy [52] and HeapSentry [33]. For example, AddressSanitizer [40] creates redzones around objects and tracks addressable bytes at run time, and detects heap overflows when unaddressable redzone bytes are accessed. Fuzzers (e.g., AFL [51]) test target programs with abundant inputs and report vulnerabilities when crashes are found during testing.These solutions are widely adopted by industry to find vulnerabilities in their products. However, neither of these solutions accurately model the root cause of heap overflow, and thus will miss many heap overflow vulnerabilities.We point out that the root cause of heap overflow vulnerabilities is not the controllability of either memory allocation or memory access, but the spatial inconsistency between heap allocation and heap access operations. For example, if a program first allocates a buffer of size x + 2, and then writes x + 1 bytes into it, a heap overflow will happen if attackers make x + 2 integer overflows but x + 1 not. If either one is controllable (i.e., tainted or affected by inputs), HOTracer reasons about the path conditions and spatial inconsistency to generate a PoC (i.e., proofof-concept) input for the potential vulnerability.In this way, our solution could discover potential vulnerabilities that may be missed by existing online and offline solutions. Our solution could work fine as long as the inputs could exercise any heap allocation and heap access operations.On the other hand, a combination of existing offline solutions, e.g., DIODE and Dowser, seems to be able to achieve the same goal as HOTracer. Even worse, many programs utilize custom memory allocators and custom memory accesses. HOTracer reduces the number of pairs by promoting lowlevel heap access instructions into high-level heap access operations, and prioritizes pairs to explore pairs that are more likely to be vulnerable.Finally, it is challenging to generate concrete inputs to trigger the potential vulnerability in a specific heap operation pair, especially in large real-world applications, due to the program trace size and constraint complexity. We also proposed a method to accurately model heap vulnerability conditions, with heap objects' spatial and taint attributes (i.e., affected by inputs or not). • We implemented a prototype system, which is able to handle large real world applications and generate concrete inputs to prove heap vulnerabilities. It is worth noting that, the offset and size may be derived from untrusted user input, either directly (e.g., the offset size at line 8) or indirectly (e.g., the size computed from the length of string p1->name at line 21). On the other hand, a heap access operation's target object is represented by a memory range, i.e., an allocation Figure 2: Two sample heap vulnerabilities: an off-by-one heap overflow and a use-after-free. Although this off-by-one vulnerability could only overwrite one extra byte of 0, it is still exploitable. More specifically, for a heap access via (ptr, o f f set ptr , size access ) and target object (ob j, size ob j ), similar to related work SoftBound [30], we conclude that there is an underflow vulnerability if:ptr + o f f set ptr + size access < ob j.Given that heap pointers ptr always refer to base objects' address obj, it equals to:o f f set ptr + size access < 0. If we use o f f set ptr as unsigned integer, and assume its bit-width is N, then Equation S1 becomes o f f set ptr + size access >= 2 N−1 . So, Equation S3 implies Equation S2. To achieve this goal, we analyze programs' execution traces offline, and explore potential vulnerable states along the binary traces.Furthermore, to make the solution efficient and practical, we select representative testcases to generate a limited number of traces, perform spot checks on a small number of heap <allocation, access> operation pairs that are more likely to be vulnerable, and concretize values in path constraints and vulnerability constraints to speed up the constraint resolving. Figure 4 shows an overview workflow of our solution HOTracer. Based on these attributes, it builds the vulnerability conditions using Equation S for each pair of heap <allocation, access> operations.Finally, it solves the vulnerability conditions, along with the path constraints, to check potential heap overflows, and generates concrete inputs to prove the existence of them.Following this process, we figure out there are many challenges when making it work for real world applications, especially the usability and efficiency of this solution. Then we parse the structure of these sample inputs, and utilize the file format information to select representatives from each sub-type (e.g., tags in MP4 files). Based on the trivial knowledge that different subtypes of inputs will exercise different program paths, we could get a set of representative execution traces.For unknown file types, we use fuzzers to generate a set of seed inputs, and distill the inputs to a minimum set which covers most code blocks. By analyzing heap allocation functions, we can get the size and address of heap objects, and update the spatial attributes of heap objects.However, it is challenging to recognize all heap allocation functions accurately. For example, Firefox uses a custom heap management implementation Jemalloc, to solve its memory fragmentation problems. It affects the memory allocation in several ways.B1 Custom allocators have to use standard allocation interfaces to get memory from system when the allocator is called for the first time, or when the internal reserved memory pool is drained.B2 Allocators usually keep different memory pools for different allocation sizes to improve allocation efficiency and ease the burden of boundary check.B3 Allocators usually pad extra bytes at the end of objects to make objects aligned (with 4 bytes, 8 bytes etc.). The allocator will return different values in different invocations in most cases, unless the underlying memory is released before allocation.C4 Some heap allocation functions will initialize the objects (e.g., set to 0) before returning, to avoid potential bugs (e.g., use of uninitialized variables). From our evaluation, the false positive ratio is very low. So it will not prevent us from discovering potential heap vulnerabilities.It is an open challenge to accurately identify all heap allocators in binary programs. As a result, it is crucial to reduce the number of candidate pairs.We first abstract low level heap access instructions to high level operations to reduce the number of heap access operations, and then prioritize candidate pairs based on the likelihood of vulnerability in each pair. For example, a buffer copy could be compiled into a simple loop, or a REPprefixed instruction, which is represented with a sequence of memory access instructions in the trace. We treat each occurrence of these loops in the trace as one heap access operation, but not any instruction within these loops.D2 We then treat each sequence of heap access instructions that corresponds to one REP instruction in the trace as a single heap access operation.D3 We finally treat every remaining instruction in the trace that accessed the heap as a heap access operation. As shown in Figure 3, attackers may have different abilities to control heap operations. It means attackers could change the element of heap pairs independently and make it inconsistent. For example, the program allocates X bytes and later tries to access only X bytes. So we only need to solve parts of the constraints.Moreover, HOTracer only collects instructions from the first related input point till the vulnerability points, and performs symbolic execution on them. The testcases could origin from different sources, e.g., fuzzers, existing benchmarks, or network crawlers, as shown in Figure 1. As discussed in Section 3.2.1, we will use parsers to parse testcases of known input format, and select representative testcases based on their sub-types. We also use fuzzers to generate testcases of unknown input format, and further distill the testcases based on their code coverage information. Our dynamic analysis framework implements a recordreplay mechanism similar to PANDA [18], based on the open-source whole-system hardware emulator QEMU, to improve the performance of recording.It takes a snapshot of the system before execution, and records changes to the CPU state and memory in a changelog file during the execution. A loop in the trace is a continuously repeated sequence of instructions ending with jump instructions, unlike its representation in the control flow graph (i.e., a backward edge) [8]. HOTracer takes the sequence of instruction addresses in the trace as a string, and identifies loops by searching for continuously repeated sub-strings. We also count the number of iterations in current trace to infer the access range of a loop.Our current prototype could find nested loops but not complicated overlapped loops [45,50]. In other words, we could not rely only on the values of heap pointers and addresses of objects.So we perform an analysis to track pointers' provenances, in order to build the accurate heap layout. In this way, we group specific heap access and heap allocation operation into a pair, and further evaluate their spatial attributes to discover potential heap overflows.Under-taint Issue: However, there is a corner case during the taint (i.e., provenance) propagation for pointers. For example, the SUB instruction in Figure 6a will usually clean the taint attribute of the pointer (i.e., EAX), since the result is constant and is not a pointer any more [6]. We use the same taint analysis solution as previous provenance analysis, to track values' taint attributes, i.e., which input bytes affect the target values. For example, programs may use strlen or other custom functions to infer some values (e.g., length) of the inputs, and use them as size to allocate memory. For example, the return value of strlen control-depends on the input string, i.e., whether the input character equals to '\0' or not.Classical dynamic taint analysis solutions usually will not propagate taint information for control dependencies [39], due to the concern of taint propagation efficiency. There are also three cases: (1) if only the object's size or the pointer's size is tainted (e.g., line 1 and line 3 in Figure 3), there may be a heap overflow; (2) if both the object's size and pointer's size are tainted (e.g., line 2 in Figure 3), there may be a heap overflow too. For example, if we allocate a heap buffer with size X from input, and access heap with size X, then there are no overflows. Inputs satisfying only the vulnerability conditions may not trigger vulnerabilities at all, since (1) it may not reach the vulnerable point that we analyzed, because a different program path is exercised, and (2) it may be blocked by some input validations deployed in the program.So, HOTracer will also collect the program path constraints, i.e., how the input bytes affect the branches in the trace. As discussed in Section 3.5, HOTracer will only collect path constraints related to bytes used in the vulnerability conditions, and use concrete values for other input bytes used in the path constraints, to simplify the path constraints.We also notice that, programs may read the same input bytes multiple times via multiple functions. So, HOTracer performs another step to filter the candidate PoC inputs, to find out inputs that could trigger crashes.The idea is that, we will compare the candidate PoC input with the seed input, to find out the input bytes that have changed. We leave it as a future work to analyze these candidate PoC inputs and whether they are exploitable. The target applications we tested are popular applications in Windows 7 operating system, including word document processing applications Microsoft Word and OpenOffice, video players KMPlayer and potplayer, and photo viewers IrfanView etc. We use two factors to distinguish vulnerabilities, i.e., the overflow instructions along with the call context, and the key input bytes' roles (i.e., structure fields) in the input structures. However, HOTracer could validate these two vulnerabilities if given the correct PoC samples.More interestingly, when analyzing the program path (with a benign input) of the vulnerability CVE-2014-1761 in Microsoft Word 2010, HOTracer found two new vulnerabilities, which even affect the latest version of Microsoft Word. During our experiments, we found that some tested programs (e.g., VLC, KMPlayer) have released new updates for the bugs we reported. It will not break the target applications' functionality, e.g., causing program timeout due to a heavy runtime monitoring or recording. It also takes much longer (e.g., 20 times longer) time to replay and generate the traces than recording only changelogs.HOTracer performs the offline analysis, including heap attributes tracking and vulnerability modeling, on the traces to discover heap vulnerabilities. The more instructions a trace has, the more time the analysis needs.After identifying potential heap vulnerabilities, HOTracer will extract instructions relevant to the candidate vulnerabilities and build the constraint files to query constraint solvers (e.g., Z3). As shown in the table, it requires 0.5 to 15 minutes to extract the related instructions and build constraints, depending on the number of relevant instructions.And for the vulnerability CVE-2015-0327 in Adobe Flash and CVE-2010-2553 in Media Player, our prototype fail to find out the vulnerability. Table 4 and 5 show some detail evaluations of our trace analysis. The number of heap operation pairs is thus critical to the efficiency of our solution. A larger trace usually consumes more time to identify heap allocators in it.When considering the feature A (i.e., returning a heap pointer) in Section 3.3.1, we could identify a set of candidate allocators, e.g., 43 allocators in Microsoft Word 2010. For example, after considering the group B features (i.e., use of allocation size), we only get 11 candidate allocators. In a trace, an allocator may be invoked several times, so there will be more allocation sites than heap allocator functions shown in Table 4. Finally, we sorted the remaining heap access operations according to their type, taint attributes, constraint complexity etc. as discussed in Section 3.4.2. WinAFL found no crashes during this time period, while Radamsa found 1144 crashes related to heap overflows.With a further analysis, we figured out there are only 11 crash points, and 3 vulnerability points. Similarly, type-A-B-C allocators satisfy one of C1/C2/C3/C4 in addition to previous heuristics. As discussed in the background, we merged the access offset with the access size. Instead, the sizes are controldependent on the inputs.A common case is that, developers use strlen or custom loops to identify the length of an input string, and allocate buffers. The program will compare the input against lfolevel, and set the access size accordingly.Traditional taint analysis will not cover this type of implicit data flow. For example, the access size in vulnerability CVE-2014-1761 is related to lfolevel, but its allocation size is related to another field listoverridecount.A more common case is that, the access size and allocation size are relevant to the same input bytes, but they mismatch due to several causes.First, the allocation size may get smaller than expected if there are integer overflows, e.g., two new vulnerabilities we found in QQPlayer and PotPlayer. For example, when analyzing the trace generated for the known vulnerability CVE-2014-1761 in Microsoft Word, we found several potential vulnerable points, and confirmed two of them are vulnerable. SIFT is a static analysis system to generate input filters that nullify integer overflow errors associated with critical program sites such as memory allocation or block copy sites [27]. Online dynamic analysis solutions usually first instrument target applications with metadata before execution, and then track the metadata and check security violations during the execution.Online detection: AddressSanitizer [40] is one of the most effective solutions to detect heap (and other) vulnerabilities at runtime. Moreover, it could only detect vulnerabilities when the given or generated input testcases could trigger security violations.SoftBound [30] tracks the size and base of every pointer, and checks each pointer dereference operation. Diehard [4] and Dieharder [34] randomly allocate memory larger than required, and thus mitigate heap overflow vulnerabilities.Online detection solutions rely on inputs to trigger vulnerabilities and help finding vulnerabilities in a passive way. SYM-FUZZ [10] combines both black-and white-box techniques to maximize the effectiveness of fuzzing. And VUzzer enhances the efficiency of general-purpose fuzzers with a smart mutation feedback loop based on applications' control-and data-flow features.Like other online detection solutions, fuzzers also rely on input testcases to trigger vulnerabilities at runtime. Traditional symbolic execution solutions mainly focus on how to explore new program paths and reduce the complexity of constraints.Concolic execution [22,29] is an alternative way for full symbolic execution. Comparing to online dynamic analysis, this type of solutions could perform in-depth analysis for a single dynamic execution, and explore potential vulnerabilities.DIODE [41] targets heap allocation sites in a trace, and extracts and solves integer overflow conditions for allocation sizes to discover potential IO2BO (a special kind of heap overflow) vulnerabilities. Moreover, it only considers integer overflow conditions, which is only a subset of heap overflow conditions. MemBrush [13] proposes several heuristics to identify custom memory allocators. We leave it as a future work.Aligot [8] proposes a solution to identify loops in execution traces, and uses it to identify cryptographic functions in obfuscated binary programs. A recent paper [50] improves Aligot in identifying loop bodies. It is challenging to recognize all custom heap management functions, especially when analyzing the trace directly. Heap overflows account for a big portion of real world memory corruption based exploits. We would like to thank our shepherd Stelios SidiroglouDouskos, and the anonymous reviewers for their insightful comments.