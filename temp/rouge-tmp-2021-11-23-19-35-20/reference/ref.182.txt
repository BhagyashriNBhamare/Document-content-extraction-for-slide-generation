This advancement in coverage is achieved by applying large-scale mutations in the application's input space. In this paper, we present the design and implementation of GRIMOIRE, a fully automated coverage-guided fuzzer which works without any form of human interaction or pre-configuration; yet, it is still able to efficiently test programs that expect highly structured inputs. We achieve this by performing large-scale mutations in the program input space using grammar-like combinations to synthesize new highly structured inputs without any pre-processing step. Using GRIMOIRE, we identified 19 distinct memory corruption bugs in real-world programs and obtained 11 new CVEs. As the amount of software impacting the (digital) life of nearly every citizen grows, effective and efficient testing mechanisms for software become increasingly important. Therefore, it is an important goal for fuzzing research to develop fuzzing techniques that require less user interaction and, in particular, less domain knowledge to enable more automated software testing.Structured Input Languages. A prominent example are browsers, as they parse a multitude of highly-structured inputs, ranging from XML or CSS to JavaScript and SQL queries.Previous approaches to address this problem are typically based on manually provided grammars or seed corpora [2,14,45,52]. An orthogonal line of work tries to utilize advanced program analysis techniques to automatically infer grammars 28th USENIX Security Symposium 1985 [4,5,25]. Our approach is based on two key observations: First, we can use code coverage feedback to automatically infer structural properties of the input language. We propose a set of generalizations and mutations that resemble the inner workings of a grammar-based fuzzer, without the need for an explicit grammar. GRIMOIRE does not need any specification of the input language and operates in an automated manner without requiring human assistance; in particular, without the need for a format specification or seed corpus. In a first step, we select a diverse set of programs for a comparative evaluation: we evaluate GRIMOIRE against other fuzzers on four scripting language interpreters (mruby, PHP, Lua and JavaScriptCore), a compiler (TCC), an assembler (NASM), a database (SQLite), a parser (libxml) and an SMT solver (Boolector). The evaluation results show that our approach outperforms all existing coverage-guided fuzzers; in the case of Boolector, GRIMOIRE finds up to 87% more coverage than the baseline (REDQUEEN). We observe that in situations where an input specification is available, it is advisable to use GRIMOIRE in addition to a grammar fuzzer to further increase the test coverage found by grammar fuzzers. We responsibly disclosed all of them to the vendors and obtained 11 CVEs. • We show that even though GRIMOIRE is a binary-only fuzzer that needs no seeds or grammar as input, it still outperforms many fuzzers that make significantly stronger assumptions (e. g., access to seeds, grammar specifications and source code). To this end, we provide an overview of different fuzzing approaches, while focusing on their shortcomings and open challenges. In an abstract view, one can consider fuzzing as randomly exploring the state space of the application. Typically, most totally random inputs are rejected early by the target application and do not visit interesting parts of the state space. Thus, in our abstract view, the state space has interesting and uninteresting regions. Based on this observation, we can divide fuzzers into three broad categories, namely: (a) blind, (b) coverage-guided and (c) hybrid fuzzers, as explained next. Examples for common mutators include bit flipping, splicing (i. e., recombining two inputs) and repetitions [14,29,32]. We call these mutations small-scale mutations, as they typically change small parts of the program input.Blind fuzzers suffer from one major drawback. (c) Programs with highly structured input formats typically have large gaps in the state space. (d) By introducing an input specification, fuzzers can generate inputs in interesting areas and perform largescale mutations that allow to jump between islands of interesting states. Following the overwhelming success of AFL, various more efficient coverage-guided fuzzers such as ANGORA [12], QSYM [64], T-FUZZ [47] or REDQUEEN [3] were proposed.From a high-level point of view, all these AFL-style fuzzers can be broken down into three different components: (i) the input queue stores and schedules all inputs found so far, (ii) the mutation operations produce new variants of scheduled inputs and (iii) the global coverage map is used to determine whether a new variant produced novel coverage (and thus should be stored in the queue). Then, it runs in a continuous fuzzing loop, composed of the following steps: (1) Pick an input from the input queue, then (2) apply multiple mutation operations on it. After the target program terminates, AFL compares the values in the shared map to all previous runs stored in the global coverage map. Assume that the fictive execution of an input causes a loop between B and C to be executed 10 times. Hence, the shared map is updated as shown in b , reflecting the fact that edges A → B and C → D were executed only once, while the edges B → C and C → B were encountered 10 (0b1010) times. These kind of situations occur if there is a significant gap between interesting areas in the state space and existing mutations are unlikely to cross the uninteresting gap. The program displayed in the Figure 1(b) illustrates a case with only one large gap in the program space. Still, as a consequence of the precise search technique, they struggle to explore large code regions due to significant overhead.By combining fuzzing and reasoning-based techniques, one can benefit from the strength of each individual technique, while avoiding the drawbacks. However, they lose the ability to explore behavior more globally.While hybrid fuzzers can solve constraints over individual values of the input, they are typically not efficient at solving constraints on the overall structure of the input. This leads to a large number of very large gaps in the state space as illustrated in Figure 1(c). Beside the problem of multi-byte magic values, there is another issue which leads to large gaps between interesting parts of the state space: programs with structured input languages. These specifications let the fuzzer spend more time exercising code paths deep in the target application. Due to the impact of grammars on software testing, various approaches have been developed that automatically can generate input grammars for target programs. Then, these regular expressions are turned into full grammars by trying to introduce recursive replacement rules. Additionally, this approach requires a pre-processing step before fuzzing starts in order to infer a grammar from the input corpus.Other approaches use the target application directly and thus avoid the need to create an oracle. This approach works well for hand-written, recursive descent parsers; however, it will have severe difficulties with parsers generated by parser generators. To summarize, current automated software testing approaches have the following disadvantages when used for fuzzing of programs that accept structured input languages:• Needs Human Assistance. Techniques based on formal reasoning such as symbolic/concolic execution as well as taint tracking require precise semantics of the underlying platform as well as semantics of all used Operating System (OS) features (e. g., syscalls). • Provides Only Small-scale Mutations. Furthermore, we present large-scale mutations that cross significant gaps in the program space. Instead, we learn an ad-hoc specification based on the program semantics and use it for coverage-guided fuzzing.We first provide a high-level overview of GRIMOIRE, followed by a detailed description. Consider the input "if(x>1) then x=3 end" and assume it was the first input to trigger the coverage for a syntactically correct if-statement as well as for "x>1". Therefore, we obtain the generalized input "if(x>1)then end". For example, starting with the input "if(x>1)then end", we can replace the second gap with the second input, obtaining "if(x>1)then x=y+end". Afterwards, we choose the slice "y+" from the second input and splice it into the fourth gap and obtain "if(x>1)then x=y+y+end". Data: input is the input to generalize, new_bytes are the new bytes of the input, splitting_rule defines how to split an input Result: A generalized version of input 1 start ← 0 2 while start < input.length() do Example 4. Then, we obtain the chunks "pp", "ri", "nt", " '", "aa", "aa" and "'". Therefore, we reduce the input to "pprint ''". First, we split the input into overlapping chunks of size 256, 128, 64, 32, 2 and 1 to remove large uninteresting parts as early as possible. We map the input "if(x>1) then x=3 end" to its generalization "if(x>1)then end". For the generalized input "x=y+", we remember the tokens "x=" and "y+". On a high level, we can divide our mutations into three standalone operations: input extension, recursive replacement and string replacement.Given the current input from the fuzzing queue, we add these mutations to the so-called havoc phase [3] as described in Algorithm 2. Algorithm 2: High-level overview of the mutations introduced in GRIMOIRE.Data: input is the current input in the queue, generalized is the set of all previously generalized inputs, tokens and strings from the dictionary, strings is the provided dictionary obtained from the binary1 content ← input.content() 2 n ← havoc_amount(input.performance()) 3 for i ← 0 to n do 4 if input.is_generalized() then 5 input_extension(input, generalized) 6 recursive_replacement(input, generalized) 7 string_replacement(content, strings)Before we describe our mutations in detail, we explain two functions that all mutations have in commonrandom_generalized and send_to_fuzzer. Thus, mutations working on generalized inputs first replace all remaining by an empty string.Algorithm 3: Random selection of a generalized input, slice, token or string.Data: generalized is the set of all previously generalized inputs, tokens and strings from the dictionary Result: rand is a random generalized input, slice token or string 1 if random_coin() then The input extension mutation is inspired by the observation that-in highly structured input languages-often inputs are chains of syntactically well-formed statements. Afterwards, we concatenate them and obtain "pprint '$$'x=y+" and "x=y+pprint '$$'". The recursive replacement mutator has a (comparatively) high likelihood of producing new structurally interesting inputs compared to more small-scale mutations used by current coverage-guided fuzzers.Example 7. Furthermore, assume that we already generalized the inputs "if(x>1)then end" and "x=y+". We extend the slice to "if(x>1)" and obtain "if(x>1)pprintAlgorithm 5: Overview of the recursive replacement mutation.Data: input is the current generalized input, generalized is the set of all previously generalized inputs, tokens and strings from the dictionary 1 input ← pad_with_gaps(input) 2 for i ← 0 to random_power_of_two() do ''". Afterwards, we choose to replace the third with "x=y+" and obtain "if(x>1)pprint 'x=y+'". Thus, the string replacement mutation can generate inputs such as "while(x>1)pprint 'x=y+'", "if(x>1)eval 'x+y+'" or "if(x>1)pprint 'x=y-'". Then, the string replacement mutation can replace all occurrences of the variable "x" in "if(x>1)pprint 'x=y+'" and obtain "if(key>1)pprint 'key=y+'". Since our technique is merely based on common techniques implemented in coverage-guided fuzzers-for instance, access to the execution bitmap-it would be a feasible engineering task to adapt our approach to other current fuzzers, such as AFL.More precisely, GRIMOIRE is implemented as a set of patches to REDQUEEN. Additionally, we extended the havoc stage by large-scale mutations as explained in Section 3. Finally, we use GRIMOIRE to uncover a set of vulnerabilities in real-world target applications. Tools other than GRIMOIRE and REDQUEEN require source-code access; we use the fast clang-based instrumentation in these cases. This is necessary since we observe more collisions in the global coverage map for large targets which causes the fuzzer to discard new coverage. This is motivated by the observation that these deterministic mutations are not suited to find new coverage considering the nature of highly structured inputs. We use four scripting language interpreters (mruby-1.4.1 [41], php-7.3.0 [57], lua-5.3.5 [36] and JavaScriptCore, commit "f1312" [1]) a compiler (tcc-0.9.27 [6]), an assembler (nasm-2.14.02 [56]), a database (sqlite-3.25 [31]), a parser (libxml-2.9.8 [59]) and an SMT solver (boolector-3.0.1 [44]). REDQUEEN uses Virtual Machine Introspection (VMI) to transfer the target binary-including all of its dependencies-into the Virtual Machine (VM). To answer RQ 1, we perform 12 runs on eight targets using GRIMOIRE and four state-of-the-art bug finding tools. Finally, we choose REDQUEEN as a state-ofthe-art coverage-guided fuzzer, which is also the baseline of GRIMOIRE. This can be explained by the fact that REDQUEEN and AN-GORA mostly aim to overcome certain "magic byte" fuzzing roadblocks. The results show that in all but two cases (Lua and NASM), GRIMOIRE offers relevant and significant improvements over all state-of-the-art alternatives. GRIMOIRE can only make effective mutations in the domain of language features and not the bytecode. It is worth mentioning that GRIMOIRE outperforms REDQUEEN, the baseline on top of which our approach is implemented.To partially answer RQ 1, we showed that in terms of code coverage, GRIMOIRE outperforms other state-of-the-art bug finding tools (in most cases). Generally, we expect grammar-based fuzzers to have an edge over grammar inference fuzzers like GRIMOIRE since they have access to a manually crafted grammar. To this end, we choose NAUTILUS (commit "dd3554a"), a state-of-the-art coverage-guided fuzzer, since it can fuzz a wide variety of targets if provided with a handwritten grammar. For these incremental runs, we reduce GRIMOIRE's upper bound for input generalization to 2, 048 bytes; otherwise, our fuzzer would mainly spend time in the generalization phase since NAU-TILUS produces very large inputs. Although these two fuzzers are not coverageguided-making a fair evaluation challenging-we consider the comparison of specialized JavaScript grammar-based fuzzers to general-purpose grammar-based fuzzers as interesting. On the other hand, CODEALCHEMIST requires an extensive seed corpus of up to 60, 000 valid JavaScript files-which were not released together with the source files. Therefore, we partially respond to RQ 1 and provide an answer to RQ 2 by stating that GRIMOIRE is a valuable addition to current fuzzing techniques. For comparison, we also include plots where we omit the training time. Given a program as black-box oracle as well as a corpus of valid input samples, it learns a grammar in the first stage. Note, we have to extend GLADE for each target that is not natively supported and must manually create a valid seed corpus. However, GLADE does not use the grammar directly but remembers how the grammar was produced from the provided test cases and uses the grammar only to apply local mutations to the input. The strategies include a havoc stage, REDQUEEN's Input-to-State-based mutation stage and our structural mutation stage. The times for our structural mutators include the generalization process (including the necessary minimization that also benefits the other mutators). As Table 5 shows, our structural mutators are competitive with other mutators, which answers RQ 5. Table 5: Statistics for each of GRIMOIRE's mutation strategies (i. e., our structured mutations, REDQUEEN's Input-to-State-based mutations and havoc). We conclude RQ 6 by finding that GRIMOIRE is indeed able to uncover novel bugs in real-world applications. For instance, while GRIMOIRE is able to produce nested inputs such as "<a><a><a>FOO</a></a></a>", it struggles to generalize "<a></a>" to the more unified representation "< A ></ B >" with the constraint A = B. For instance, consider that we replace a single occurrence of "a" by "b" in "<a><a><a>FOO</a></a></a>" and obtain "<b><a><a>FOO</a></a></a>". For example, we replace multiple occurrences of "a" with "b" and obtain "<b><a><a>FOO</a></a></b>". While this approach would most likely further reduce the gap between hand-written grammars and inferred grammars, well-designed hand-written grammars will always have an edge over fuzzers with no prior knowledge: any kind of inference algorithm first needs to uncover structures before the obtained knowledge can be used. An analyst can provide a partial grammar to make the grammar-fuzzer focus on a specific interesting area and avoid exploring paths that are unlikely to contain bugs. Therefore, GRIMOIRE is useful if the grammar is unknown or under-specified but cannot be considered a full replacement for grammar-based fuzzers. Early on, fuzzers typically did not observe the inner workings of the target application, yet different approaches were proposed to improve various aspects of fuzzers: different mutation strategies were evaluated [14,29], the process of selecting and scheduling of seed inputs was analyzed [11,51,61] and, in some cases, even learned language models were used to improve the effectiveness of fuzzing [22,27]. All of these approaches require a good format specification and-in some cases-good seed corpora. In contrast, our approach has no such preconditions and is thus easily integrable into most fuzzers.Finally, to alleviate some of the disadvantages that the mentioned grammar-based strategies have, multiple approaches were developed to automatically infer grammars for given programs. To learn the grammar, it needs an oracle that can answer whether a given input is valid or not as well as a small set of valid inputs. We developed and demonstrated the first fully automatic algorithm that integrates large-scale structural mutations into the fuzzing process. Furthermore, we would like to thank Moritz Contag, Thorsten Eisenhofer, Joel Frank, Philipp Görz and Maximilian Golla for their valuable feedback.