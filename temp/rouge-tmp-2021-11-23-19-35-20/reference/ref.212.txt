As smart contracts become more popular and carry more value, they become more of an interesting target for attackers. Instead, they try to lure their victims into traps by deploying seemingly vulnerable contracts that contain hidden traps. We identify 690 honeypot smart contracts as well as 240 victims in the wild, with an accumulated profit of more than $90,000 for the honeypot creators. Our manual validation shows that 87% of the reported contracts are indeed honeypots. Every block is linked to its previous block via a cryptographic hash, thus forming a chain of blocks or a so-called "blockchain". However, all of these implementations pursue a common goal, namely, the decentralisation of control over a particular asset. The EVM is a purely stack-based virtual machine that supports a Turing-complete instruction set of opcodes. At the time of writing, Solidity [47] is the most prevalent high-level language for developing smart contracts in Ethereum.In 2018, Ethereum reached a market capitalisation of over $133 billion [9]. This potentially enables attackers to follow a reactive approach by actively scanning the blockchain for vulnerable contracts.Alternatively, attackers could follow a more proactive approach by luring their victims into traps. In other words: Why should I spend time on looking for victims, if I can just let the victims come to me? Honeypots are smart contracts that appear to have an obvious flaw in their design, which allows an arbitrary user to drain ether (Ethereum's cryptocurrency) from the contract, given that the user transfers a priori a certain amount of ether to the contract. People are not always capable of quantifying risk against their own greed and presumptions.In this paper, we investigate the prevalence of such honeypot smart contracts in Ethereum. Moreover, we introduce HONEYBADGER -a tool that uses a combination of symbolic execution and precise heuristics to automatically detect various types of honeypots. Using HONEYBADGER, we are able to provide interesting insights on the plethora, anatomy and popularity of honeypots that are currently deployed on the Ethereum blockchain. • We run HONEYBADGER on 151,935 unique smart contracts and confirm the prevalence of at least 282 unique honeypots. However, this concept only became a reality with the release of Ethereum in 2015. It comes with a multitude of unique concepts that are specific to smart contracts, such as the transfer of funds or the capability to call other contracts. The EVM is a stack-based, register-less virtual machine, running low-level bytecode, that is represented by an instruction set of opcodes. Besides the world state σ , the EVM also holds a transaction execution environment I, which contains the address of the smart contract that is being executed I a , the transaction input data I d , the transaction sender I s and the transaction value I v . One of these services is the possibility for smart contract creators to publish their source code and confirm that the bytecode stored under a specific address is the result of compilation of the specified source code. A honeypot generally operates in three phases:1. The victim attempts to exploit the contract by transferring at least the required amount of funds and fails;1 https://etherscan.io/ 3. We were able to collect a total of 24 honeypots (see Table 5 in Appendix A) and distill 8 different honeypot techniques. We organise the different techniques in a taxonomy (see Table 1), whose purpose is twofold: (i) as a reference for users in order to avoid common honeypots in Ethereum; (ii) as a guide for researchers to foster the development of methods for the detection of fraudulent smart contracts. Etherscan is perhaps the most prominent Ethereum Figure 2: An example of a balance disorder honeypot.blockchain explorer and many users fully trust the data displayed therein. We also assume that: 1) the attacker has placed a bait in form of ether into the smart contract, as an incentive for users to try to exploit the contract; 2) the attacker has a way of retrieving the amount of ether contained in the honeypot. It is worth noting that: 1) the condition at line 4 can be satisfied if the current balance of the contract is zero, but then the user does not have an incentive to exploit the contract; 2) the addition this.balance+msg.value at line 5, solely serves the purpose of making the user further believe that the balance is updated only after the execution. When a contract inherits from multiple contracts, only a single contract is created on the blockchain, and the code from all the base contracts is copied into the created contract. The reason for this is that the variable owner, declared at line 9, is not the same as the variable that is declared at line 2. This has the effect that the encoding of all arguments following this argument are shifted to the left by 32 bytes and thus the function call argument Figure 4: An example of a skip empty string literal honeypot.1 contract D i v i d e n d D i1 contract For_Test { 2 ... 3 function Test () payable public { 4 if ( msg . value > 0.1 ether ) { 5 uint256 multi = 0; 6uint256 a m o u n t T o T r a n s f er = 0; 7 for ( var i = 0; i < 2* msg . value ; i ++) { 8 multi = i *2; 9 if ( multi < a m o u n tT o T r a n s f e r ) { 10 break ; 11 a m o u n t T o T r a n s fe r = multi ; 12 } 13 msg . transfer ( a mo u n t T o T r a n s f e r ) ; 14 } 15 } 16 } Figure 5: An example of a type deduction overflow honeypot.msg receives the value of target, whereas target is given the value of currentOwner, and finally currentOwner receives the default value zero. They combine several named variables under one variable and are the basic foundation for more complex data structures in Solidity. In order to withdraw the contract's balance, the contract requires a user to place a minimum bet and guess a random number that is stored in the contract. However, the struct Figure 7: An example of a hidden state update honeypot.is not properly initialised via the new keyword. As a result, the Solidity compiler maps the storage location of the first variable contained in the struct (player) to the storage location of the first variable contained in the contract (randomNumber), thereby overwriting the random number with the address of the caller and thus making the condition at line 14 fail. In addition to normal transactions, Etherscan also displays so-called internal messages, which are transactions that originate from other contracts and not from user accounts. The contract in Figure 7 is an example of a honeypot technique that we denote as hidden state update. Thus, by just looking at the internal messages displayed on Etherscan, unaware users will believe that the variable is set to false and confidently Figure 8: An example of a hidden transfer honeypot.transfer ether to the SetPass function.Hidden Transfer. Etherscan provides a web interface that displays the source code of a validated smart contract. Since the block numbers on the test networks are smaller, testing this contract on a such a network would transfer all the funds to the victim, making him or her believe that the contract is not a honeypot. At first sight, it seems that the contract's CashOut function is vulnerable to a reentrancy attack [2] (line 14). Thus, the attacker would simply swap the address of the user contained on the stack with his or her own address and when returning from the delegatecall, the balance would be transferred to the attacker instead of the user. Figure 10 depicts the overall architecture and analysis pipeline of HONEYBADGER. HON-EYBADGER consists of three main components: symbolic analysis, cash flow analysis and honeypot analysis. The symbolic analysis component constructs the control flow graph (CFG) and symbolically executes its different paths. The cash flow analysis component uses the result of the symbolic analysis to detect whether the contract is capable to receive as well as transfer funds. Each program path consists of a list of path conditions (a formula of symbolic expressions), that must be satisfied for execution to follow that path.We reused and modified the symbolic execution engine proposed by Luu et al. [21,20]. The engine consists of an interpreter loop that receives a basic block and symbolically executes every single instruction within that block. This information includes a list of storage writes, a list of execution paths P, a list of infeasible as well as feasible basic blocks, a list of performed multiplications and additions, and a list of calls C. Calls are extracted through the opcodes CALL and DELEGATECALL, and either represent a function call, a contract call or a transfer of Ether. A call consists of the tu- ple (c r , c v , c f , c a , c t , c g ), where c r is the recipient, c v is the call value, c f is the called contract function, c a is the list of function arguments, c t is the type of call (i.e. CALL or DEL-EGATECALL) and c g is the available gas for the call. Given our definition in Section 3.1, a honeypot must be able to receive funds (e.g. the investment of a victim) and transfer funds (e.g. the loot of the attacker). We verify the latter by iterating over all execution paths contained in P and checking whether there exists an execution path p that terminates in a SELFDESTRUCT. Finally, we know that funds can flow out of the contract, if we find at least one call c or execution path p, that satisfies the aforementioned conditions. Each sub-component is responsible for the detection of a particular honeypot technique. The honeypot analysis can easily be extended to detect future honeypots by simply implementing new sub-components. We iterate over all calls contained in C and report a balance disorder, if we find a call c within an infeasible basic block, wherec v = I v + σ [I a ] b . We use a regular expression to extract the storage location of structs, whose first element is pointing at storage location zero within a basic block. We report a hidden transfer, if two consecutive calls c and c exist along the same execution path p, wherec r ∈ σ [I a ] s ∧c v = σ [I a ] b and c r = I s ∧c v = σ [I a ] b . First, we verify if two consecutive calls c and c exist along the same execution path p, where c r = c r . We downloaded the bytecode of 2,019,434 smart contracts, by scanning the first 6,500,000 blocks of the Ethereum blockchain. It is worth mentioning that 24 out of the 460 honeypots were part of our initial dataset (see Table 5 in Appendix A) and that our tool thus managed to find 436 new honeypots. Thus, after correlating the results with the bytecode of the 2 million contracts currently deployed on the blockchain, a total of 690 contracts were identified as honeypots 5 skip empty string literal (SESL), 5 type deduction overflows (TDO), 80 uninitialised structs (US), 382 hidden state updates (HSU), 14 hidden transfers (HT) and finally 101 straw man contracts (SMC). While many contracts were found to be HSU, SMC and US honeypots, only a small number were found to be TDO honeypots. In order to confirm the correctness of HONEYBADGER, we performed a manual inspection of the source code of the contracts that have been flagged as honeypots. For the remaining 3 techniques, our tool achieves a decent false positive rate, where the highest false positive rate is roughly 18% for the detection of hidden state updates, followed by 15% false positive rate for the detection of inheritance disorder and finally 12% false positive rate for the detection of straw man contracts. In this section, we analyse the true positives obtained in Section 5, in order to acquire insights on the effectiveness, liveness, behaviour, diversity and profitability of honeypots. We crawled all the transactions of the 282 true positives using Etherchain's 6 API, in order to collect various information about the honeypots, such as the amount of spent and received ether per address, the deployment date and the balance. An address is labeled as an attacker if it either: 1) created the honeypot; 2) was the first address to send ether to the honeypot; or 3) received more ether than it actually spent on the honeypot. An address is labeled as a victim if it has not been labeled as an attacker and if it received less ether than it actually spent on the honeypot. February 2018 has been the peak in terms of honeypots being deployed, with a total of 66. In our analysis, the quickest first attempt of exploitation happened just 7 minutes and 37 seconds after a honeypot had been deployed, whereas the longest happened not until 142 days after deployment. We also analysed how long an attacker keeps the funds inside a honeypot, by measuring the period of time between the first attempt of exploitation by a victim and the withdrawal of all the funds by the attacker. In other words, 171 honeypots are in some kind of "zombie" state, where they are still alive (i.e. not destroyed), but not active (i.e. their balance is zero). Analysing the 37 destroyed honeypots, we found that 19 got destroyed after being successful and 18 after never having been successful.Behaviour. In 71% of the cases a honeypot managed to trap solely one victim. Surprisingly, 20 out of the 87 commented honeypots were successful. Finally, attackers took an average of 6 days and a median of 22 hours to abort their honeypot after a user had placed a comment.Diversity. The most profitable honeypots are straw man contract honeypots, with an average value of 1.76 ether, whereas the least profitable honeypots are uninitialised struct honeypots, with an average value of 0.46 ether. Applying this method across the 282 honeypots, results in a total profit of 90,118 USD. This suggests that the usage of signature-based detection methods would be rather ineffective. We also note that most honeypot creators withdraw their loot within 24 hours or abort their honeypots if they are not successful within the first 24 hours. The fact that certain information is solely available at the source code level and not at the bytecode level, obliges us to make use of other less precise information that is available in the bytecode in order to detect honeypot techniques such as inheritance disorder. Nevertheless, we designed HONEYBADGER with modularity in mind, such that one can easily extend the honeypot analysis component with new heuristics in order to detect more honeypot techniques. For instance, a honeypot creator might deploy a honeypot with the intention to scam users and make profit. In particular, smart contracts have been shown to contain security issues [2]. [37] requires Solidity code and therefore cannot be used to analyse the large majority of the smart contracts deployed on the Ethereum blockchain. Both of these reasons make formal verification unsuitable to be used on a large number of contracts, as it is required in this work.Symbolic execution has been used on smart contracts to detect common [28,25,21,38] vulnerabilities. Moreover, smart contract bytecode cannot grow arbitrarily large due to the gas limit enforced by the Ethereum blockchain.To the best of the authors' knowledge, this paper is the first to consider and discuss honeypot smart contracts, a new type of fraud, and to propose a taxonomy as well as an automated tool using symbolic execution for their detection. In a large-scale analysis of 151,935 unique Ethereum smart contracts, HONEYBADGER identified 460 honeypots. We also plan to extend our analysis with a larger subset and eventually detect new honeypots by looking at other contracts that are linked to the newly discovered honeypot contracts. The experiments presented in this paper were carried out using the HPC facilities of the University of Luxembourg [41] -see https://hpc.uni.lu.