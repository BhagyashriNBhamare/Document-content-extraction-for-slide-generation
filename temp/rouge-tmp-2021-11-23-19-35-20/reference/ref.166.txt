Technically, FUZE utilizes kernel fuzzing along with symbolic execution to identify, analyze and evaluate the system calls valuable and useful for kernel UAF exploitation. To demonstrate the utility of FUZE, we implement FUZE on a 64-bit Linux system by extending a binary analysis framework and a kernel fuzzer. Of all of those strategies, remediation prioritization with exploitability is the most common one, which evaluates a software bug based on ease of its exploitation. To ensure that the consecutive execution of the OS kernel could be influenced by the data sprayed, he also needs to leverage his expertise to manually adjust system calls and corresponding arguments based on the size of a freed object as well as the type of heap allocators. To facilitate exploitability evaluation, an instinctive reaction is to utilize the research works proposed for exploit generation, in which program analysis techniques are typically used to analyze program failures and produce exploits accordingly (e.g., [5,7,8,29]). On the other hand, this is because their technical approaches mostly focus on stack or heap overflow vulnerabilities, the exploitation of which could be possibly facilitated by simply varying the context of a PoC program, whereas the exploitation of a UAF vulnerability requires the spatial and temporal control over a vulnerable object, with the constraints of which a trivial context variation typically does not benefit exploitability exploration.In this work, we propose FUZE, an exploitation framework to evaluate the exploitability of kernel Use-AfterFree vulnerabilities. Last but not least, it provides security analysts with the ability to achieve security mitigation bypassing.As we will show in Section 6, with the facilitation from all the aforementioned aspects, we could not only escalate kernel UAF exploitability but also diversify working exploits from various kernel panics. In addition, we demonstrate FUZE could even help security an- Table 1: A PoC code fragment pertaining to the kernel UAF vulnerability (CVE-2017-15649). … syscall_M(…) … syscall_B(…) …site of dangling ptr occurrence Figure 1: The typical workflow of crafting a working exploit.  Identifying the time window between the occurrence of dangling pointer and its dereference;  selecting the proper system call syscall_M to perform heap spray;  adjusting the argument of the system call syscall_M; introducing the system call syscall_M and revising the original PoC program accordingly. From that program, he then typically needs to take the following steps in order to perform a successful exploitation.First, the security analyst needs to pinpoint the system call(s) resulting in the occurrence of a dangling pointer as well as the dereference of that pointer (see  in Fig- ure 1). In the past, research (e.g., [33]) has focused on how to augment a security analyst with the ability to select a system call and perform an effective heap spray (i. e., facilitating the step  shown in Figure 1). it is still challenging and oftentimes infeasible for a security analyst to craft a working exploit for a real-world UAF vulnerability. Because of the unexpected manipulation, the Linux kernel fails to overwrite the "next link" in the head node and thus leaves a dangling pointer pointing to a freed object (see Figure 2b). Given that the allocation of heap objects is under the control of Linux kernel, and an analyst could only have limited influence upon the allocation, we can safely conclude that the unexpected write primitive only gives the analyst the privilege to write an unmanageable data (i. e., the address of the new object) to an unmanageable heap address in Linux kernel. Since the system call sendmsg() has the capability of dereferencing the data in the object newly prepended in the doubly linked list, when an accidental free operation occurs and a dangling pointer appears, it has the ability to dereference the dangling pointer prior to the system call defined in the original PoC and thus changes the way how kernel experiences panic.As is illustrated in Figure 3, the new kernel panic (or in other words the new PoC program) represents a new running context, where the system call sendmsg() retrieves the data in the freed object, dereferences it as an invalid function pointer and thus drives the kernel to a new panic state. As we will demonstrate in Section 6, this context even provides a security analyst with the ability to bypass kernel security mitigation such as SMEP and SMAP.Motivated by this observation, we propose a technical approach to facilitate the context variation of a PoC program. As a result, we decide to design FUZE to facilitate exploit crafting from the following four aspects.First, FUZE must provide a security analyst with the ability to track down the vulnerable object, the occurrence of a dangling pointer and its dereference. This is because crafting data to take over the freed region and perform exploitation typically needs significant expertise as well as tremendous manpower. Technically speaking, we therefore design and develop an under-context fuzzing approach, which automatically explores the kernel code space in the time window identified and thus pinpoints the system calls (and corresponding arguments) that can drive the kernel panic in a new context.Similar to the context represented by that original PoC, a new context (i. e., new kernel panic) does not necessarily assist an analyst to craft a working exploit. In addition to the system call selected, the terminated kernel state (i. e., the site where a kernel experiences panic) is dependent upon the remanent content in the freed object. As is shown in Figure 4b, this allows FUZE to explore the exploitable machine states in a more complete fashion and thus thoroughly pinpoint the set of contexts useful for exploitation.It should be noted that, as is depicted in Figure 4b, symbolic execution under the context does not mean that symbolically executing kernel code at the site of kernel panic. Third, we specify how FUZE performs symbolic execution, pinpoints exploitable ma- chine states and thus accomplish context evaluation as well as the computation for the data sprayed. Then, it extracts information needed for consecutive exploitation by using an off-the-shelf kernel address sanitizer KASAN [19] along with a dynamic tracing mechanism. To be specific, these include (1) the base address and size of a vulnerable object, (2) the program statement pertaining to the free site left behind a dangling pointer and (3) the program statement corresponding to the site of dangling pointer dereference. This could allow us to obtain the information pertaining to the system calls invoked by the PoC program. To illustrate the new information obtained through this combination, we take for example the kernel trace and KASAN log shown in Figure 5. Using the information obtained through KASAN, we can easily identify the address of the vulnerable object (0xffff88003280e600) and tie it to the free operation indicated by kfree(). As is demonstrated above, this can be easily achieved by using the information extracted through KASAN and dynamic tracing.With the two critical sites identified, our next step is (b) Wrapped PoC program that encloses free and dangling pointer dereference in two separated system calls with race condition involvement. As is illustrated in Table 2a, for a single thread PoC program with a free operation and consecutive dereference occurring in two sepa- rated system calls, we instrument the PoC program by inserting a return statement in between the system calls because this could prevent the PoC itself entering the dangling pointer dereference site defined in the PoC program. To perform kernel fuzzing under the context initialized above, we borrow a state-of-the-art kernel fuzzing framework, which performs kernel fuzzing by using sequences of system calls and mutating their arguments based on At the fuzzing stage, our objective is to identify system calls for diversifying running contexts but not directly for generating exploitation. Considering an initial context could represent different environment for triggering an UAF vulnerability, we set up this kernel fuzzing framework in two different approaches.In our first approach, we start our kernel fuzzing right after the fuzzing context initialization. It is obvious that this would significantly downgrade the efficiency in finding the system calls that are truly useful for exploitation facilitation.To address this problem, we track down a vulnerable object using the information obtained through the aforementioned vulnerability analysis. For the modules that contain the usage of the object, we retrieve the sys-tem calls involved in the modules by looking up the SYSCALL_DEFINEx() macros under the directory pertaining to the modules. The random input fed into kernel fuzzing could potentially crash kernel execution without providing useful primitives for exploitation (e.g., writing arbitrary data to an arbitrary address). To do this, we need to pinpoint the site of dangling pointer dereference, pause kernel execution and pass the running context to symbolic execution.Different from kernel fuzzing, symbolic execution cannot leverage kernel instrumentation to facilitate this process. As is mentioned in Section 4.1, the information obtained carries the code statement pertaining to the dereference of a dangling pointer. Since this information represents in the source code level, we can easily map it to the plain Linux system, and set a breakpoint at that site.This approach could guarantee to catch the occurrence of a dangling pointer. Then, we look up these primitives and take them as candidate exploitable states while performing symbolic execution.Since primitives represent only the operations generally necessary for exploitation, but not reflect their capability in facilitating exploitation, we further evaluate the primitives guided by exploitation approaches commonly adopted, and deem those passing the evaluation as our exploitable states. To identify this primitive during symbolic execution, we pay attention to all the write instructions and check whether the destination address or the source register or both carry symbolic bytes (e.g., mov qword ptr [rdi], rsi where both rdi and rsi contain symbolic values). Given a control flow hijacking primitive, for example, it may be still challenging for one to exploit an UAF vulnerability because of the mitigation integrated in modern OSes (e.g., SMEP and SMAP). Then, he needs to pivot the stack to user space by setting the value of eax to an address in user space. 0x10000 represent the end of an unmapped memory region, and τ indicates the upper bound of the memory region in user space.Given SMEP enabled, another common approach [4] for bypassing SMEP and performing control flow hijacking is to leverage an invalid write to manipulate the metadata of the freed object. Since one could have the full control to the user space, he could modify the data in the new object (e.g., a function pointer) and thus hijack the consecutive execution of Linux kernel.To leverage this alternative approach to guide our evaluation, we retrieve the source and destination pertaining to each invalid write primitive. Since the function is responsible for setting register CR4 -the 21st bit of which controls the state of SMAP -and rdi is the argument of this function specifying the new value of CR4, he could disable SMAP and thus perform a control flow hijack attack.To use this approach to guide our primitive evaluation, we examine each control flow hijacking primitive and at the same time check the value in register rdi. This is because there have been already a rich collection of works that could easily facilitate the acquirement of the base address of kernel code segment (e.g., [12,16]) and the facilitation of information leak provided by FUZE is neither a necessary nor a sufficient condition for successful exploitation. Without a concretization to the symbolic value, the symbolic address could block the execution without providing us with primitives useful for exploitation. To address this issue, our design concretizes the symbolic value with a valid user-space address carrying the content to which we have the complete control.With this design, it is not difficult to note that, crafting an exploit with the symbolic address involved, one would have the difficulty in bypassing SMAP because an access to the user space is a clear violation to the protection of user-space read and write. To track down system calls as well as memory management operations in Linux kernel, we used ftrace to record information related to the memory allocation and free such as kmalloc(), kmem_cache_allocate(), kfree() and kmem_cache_free() etc.Since Linux kernel might utilize RCU, a synchronization mechanism, to free an object, which could potentially fail our dynamic tracing to pinpoint a dangling pointer at the right site, we also force our dynamic tracing component to invoke sleep(). For the PoC programs which trigger dangling pointers through a race condition (e.g., the PoC program shown in Table 1), we insert function sleep() at the end of each iteration. When performing kernel fuzzing, we expect the system calls used by syzkaller could dereference a dangling pointer and thus obtain a new running context for consecutive exploitation. We developed our symbolic execution component by using angr [1], a binary analysis framework. In this section, we demonstrate the utility of FUZE using real-world kernel UAF vulnerabilities. To demonstrate the utility of FUZE, we exhaustively searched Linux kernel UAF vulnerabilities archived across the past 5 years. For some vulnerabilities, we also migrate UAF vulnerabilities from the target version of a Linux kernel to a newer version by reversing the corresponding patch in the newer version of the Linux kernel. As is mentioned in Section 4.3, the address space layout randomization is out of the scope of this work. Table 4 specifies the amount of distinct exploits publicly available for each kernel UAF vulnerability as well as their capability of bypassing mitigation mechanisms commonly adopted (i. e., SMEP and SMAP). With regard to the ability to perform exploitation and bypass SMEP illustrated in Table 4, we first observe that there are only 5 publicly available exploits capable of bypassing SMEP whereas FUZE enables exploitation and SMEP-bypassing for 5 additional vulnerabilities. Using FUZE to facilitate exploit generation, we observe that FUZE could enable and diversify exploitation as well as SMAP-bypassing for 2 additional vulnerabilities (see CVE-2017-8824 andCVE-2017-15649 in Table 4). In addition, we notice that FUZE fails to facilitate SMAP-bypassing for CVE-2016-4557 even though a public exploit has already demonstrated its ability to perform exploitation and bypass SMAP. However, we observe that FUZE can still facilitate exploit generation particularly for the vulnerabilities tied to CVE-2017-17053 andCVE-2016-10150. For the case tied to CVE-2015-3636, the vulnerability can be triggered only in the 32-bit Linux system, in which the Linux kernel has to access a fixed address defined by marco LIST_POISON prior to an invalid free. For the case tied to CVE-2017-7374, the NVD website [10] categorizes it into a kernel UAF vulnerability. Up until the submission of this work, for the cases tied to CVE-2013-7446, CVE-2017-15265 and CVE-2016, both exhaustive search and FUZE have not yet discovered any exploits indicating their ability to perform exploitation. To perform kernel fuzzing in a more efficient manner, syzkaller customizes these system calls and extends their amount to 1,203. More specifically, the table shows the minimum, maximum and average length of the path from a dangling pointer dereference site to a control flow hijacking or an invalid write primitive. It should be noticed that we do not discuss techniques for circumventing other kernel security mechanisms (e.g., PaX / Grsecurity [27]) simply because -for the performance concern -they are typically not widely deployed in modern OSes.Regarding the approaches of bypassing KASLR, a majority of research works focus on leveraging side-channel to infer memory layout in OS kernel. For example, Hund et al. [15] demonstrate a timing side channel attack that infers kernel memory layout by exploiting the memory management system; Evtyushkin et al. [11] propose a side channel attack which identifies the locations of known branch instructions and thus infers kernel memory layout by creating branch target buffer collision; Gruss et al. [12] infer kernel address information by exploiting prefetch instructions; Lipp et al. [22] leak kernel memory layout by exploiting the speculative execution feature introduced by modern CPUs. To expedite the process of crafting an exploit to perform Data Oriented Programming (DOP) attacks, Hu et al. [14] introduce an automated technique to identify data oriented gadgets and chain those disjoint gadgets in an expected order.In addition to the aforementioned techniques, the past research explores fully automated exploit generation techniques. In this paper, we demonstrate that it is generally challenging to craft an exploit for a kernel UAF vulnerability. We thank our anonymous reviewers for their helpful feedback and valuable comments.