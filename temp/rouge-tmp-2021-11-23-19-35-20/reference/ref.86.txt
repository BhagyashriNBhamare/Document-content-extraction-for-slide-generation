Our approach is implemented and evaluated in NAVEX, a tool that can scale the process of automatic vulnerability analysis and exploit generation to large applications and to multiple classes of vulnerabilities. These features, however, increase the complexity of web applications and raise the difficulty bar of analyzing their security.Currently, several approaches exist for analyzing the security of modern web applications such as [9,15,18,29]. However, a drawback of these approaches is that they generate false alarms, therefore require manual efforts to check whether each one of the reported vulnerabilities is indeed exploitable.Other approaches take a further step and try to include methods for automatically verifying that vulnerabilities are true by generating concrete exploits [7,25,27,32]. In particular, static analysis is challenging in the context of the dynamic features of web applications, where content (e.g., forms, links, JavaScript code) is often generated on the fly, and the code is executed at different tiers, whose effects are difficult to model statically.In this paper, our main contribution is a precise approach for vulnerability analysis of multi-tier web applications with dynamic features. To address the scalability challenge, we prioritize only those modules that contain potentially vulnerable sinks where an attacker 'may' be successful in injecting malicious values or in exploiting other types of vulnerabilities, and analyze them further in the successive search.In the second step, we construct the actual exploits. To maximize the coverage of the code during dynamic analysis, the crawler and concolic executioner are aided by a constraint solver, which generates the (exploit) sequence of HTTP inputs.Our contributions in NAVEX include an exploit generation framework that can easily scale to large applications and many classes of vulnerabilities and a novel method that combines dynamic execution and static analysis to address scalability issues affecting previous works, mainly due to the dynamic features of web applications.We evaluate NAVEX on 26 applications having a total of 3.2M SLOC and 22.7K PHP files. Of these exploits, 195 are related to SQLI and XSS, while 9 are related to logic vulnerabilities, such as Execution After Redirect (EAR) vulnerabilities. Books can be selected through the web form in selectBooks.php module (lines 23-38 in Listing 1). Based on the query results, $ SESSION ['ISBN'] is initialized and an HTTP link to hold.php is printed on the browser.1 <?php 2 if(!isset($_SESSION['username'])) 3 header( "Location: index.php" ); 4 if (isset($_POST['book_name'])) 5 $book_name = mysql_real_escap_string($_POST['book_name']); //sanitization 6 else 7 $book_name =""; 8 if (isset($_POST['edition'])) 9 $edition = (int)$_POST['edition']; //user input is sanitized 10 else 11 error(); 12 if (isset($_POST['publisher']) && strlen($_POST['publisher'])<=35) 13$publisher = str_replace(""", "\"", $_POST ['publisher'] Listing 1: selectBooks.php, find books to borrow.Hold.php (Listing 2) performs additional checks and, if they are satisfied, an HTTP link guides the user to the next step (line 7). When the link is clicked the superglobal $ GET ['step'] is set and the module checkout.php is therefore included by hold.php and executed. Checkout.php completes the borrowing process by providing a link (line 19) to the user for confirmation. The link sets two superglobals ($ GET ['step'] and $ GET ['msg']), which will be checked by the module (line 6). Finally, a confirmation function (line 13) is called to notify the user that the book was successfully reserved.1 <?php 2 if(!isset($_SESSION['username'])) { 3header( "Location: index.php" );4 exit(); 5 } 6 if (isset($_SESSION['ISBN'])){ 7echo "<a href='".BASE_URL."hold.php?step=checkout'> Checkout</a>";8 if (isset($_GET['step']) && $_GET['step'] == "checkout") 9include_once( "checkout.php");10 } 11 ?> Finally, the sink at Listing 1 line 3 is vulnerable to an Execution After Redirect (EAR) logic attack because the execution after the header call (redirects the execution to another PHP module) does not halt since there is no call to an execution termination function afterward. An attacker may thus be able to run a SQLI exploit without needing to log in first.1 <?php 2 if(!isset($_SESSION['username'])) { 3 header( "Location: index.php" ); 4 exit(); 5 } 6 if (isset($_GET['msg']) && isset($_SESSION['ISBN'])){ 7 $sql = "SELECT name FROM USERS WHERE username='$_SESSION['username']'" ; 8 $result = mysql_query($sql); 9 $name = $db->sql_fetchrow($result); 10 $msg = $_GET['msg'] As illustrated by the example, typical web applications have client-side logic that consists of forms, links, and JavaScript code, which may be dynamically generated by the server-side code, as well as a complex serverside logic that frequently interacts with the client-side and with the database backend. For instance, a successful exploit for the vulnerable echo in Listing 3, must consider navigation and constraint satisfaction through the modules selectBooks.php, hold.php, index.php (not shown in the example), and checkout.php.More broadly, we must take into account several factors. However, sanitizations are available in many flavors, including builtin sanitizations (e.g., htmlspecialchars()), implicit sanitizations (e.g., cast operators as shown in the running example), custom sanitizations (e.g., custom use of str replace()), and sanitizations induced by database constraints (e.g., NOT NULL constraints). For instance, line 23 of Listing 1, where the action of the form is set by the result of running the embedded PHP code. For this simple application, to construct an exploit for the vulnerable sink in Listing 3, we have to process a total of 44 execution paths in the 3 modules (i.e., 32 paths in selectBooks.php, 4 in hold.php, and 8 in checkout.php) to find candidate exploitable paths to the sink.Another scalability challenge we need to tackle is related to the goal of generating exploits for multiple classes of vulnerabilities. Our goal is to build a precise, scalable, and efficient exploit generation framework that takes into account the dynamic features of web applications and the navigational complexities that stem from dependencies among the client-side, server-side and database backend.Our approach is implemented in a system called NAVEX, as shown in Figure 1. To address the scalability challenges, our approach is divided into two steps: (I) vulnerable sink identification and (II) concrete exploit generation.Given the application source code, the first step identifies vulnerable sinks in the application and the corresponding modules. Finally, for every module containing a vulnerable sink, as identified in the first step, NAVEX uses this navigation graph to find the paths from public modules to that module along which the exploit can be executed.The dynamic features challenge is addressed in NAVEX by combining dynamic analysis and symbolic execution of applications. Finally, it uses symbolic execution to generate a model of the execution as a formula and constraint solving to determine which of those paths are potentially exploitable. To address the challenge of discovering multiple classes of vulnerabilities, NAVEX was designed to be easily extensible to a wide range of vulnerabilities, such as SQLI, XSS as well as logic vulnerabilities such as EAR [18] and command injection. To this end, NAVEX builds an Attack Dictionary, which is used to instantiate analysis templates targeting each class of vulnerability. For instance, echo and print PHP functions are sinks for XSS attacks.Sanitizations. Specifically, our graph model is based on Code Property Graphs (CPGs) [9,33], which combine abstract syntax trees (AST), control flow graphs (CFG), call graph, and data dependence graphs (DDG) under a unique representation to discover vulnerabilities, which are modeled as graph queries. In particular, given a source and a sink instruction, CPGs can be used to find data dependency paths between their variables.However, our final goal is not merely that of finding vulnerable paths but also that of generating concrete exploits. The possible values of the tag are unsan-X, san-X where X represents the specific vulnerability. Note, we add sanitization tags that resolve the sanitization status of different types of PHP statements such as assignment, cast, binary, unary statements, built-in functions, etc.To demonstrate how NAVEX assigns sanitization tags, let us consider the statement at line 9 in Listing 1. This tag contains the collected information from the schema, and it is utilized later during the graph traversal and exploit generation (Sections 3.1.3 and 3.1.4). The goal of this step is to discover vulnerable paths from sources to sensitive sinks by inspecting the enhanced CPG. The algorithm starts by searching the graph for calls to sensitive sinks specified in the attack dictionary (line 4). Finally, getPathsTo (line 24) finds all traversed and unsanitized paths in the graph leading to source nodes.As an example, consider the vulnerable sink echo to XSS (line 15) in Listing 3. Note, $name is not a user input (holds values from the database) and therefore the algorithm only returns the inter-paths of $msg as vulnerable paths to XSS.The FilterSanNodes function uses the sanitization and DB tags to prune out unpromising paths for exploit generation. As another example, to detect EAR vulnerabilities, NAVEX performs a forward graph traversal from sources to sinks where the sources are redirection instructions (e.g., header) and the sinks are termination instructions (e.g., die). The last step of the static analysis is the generation of exploit strings over the vulnerable paths discovered during graph traversal. These values are retrieved from the Attack Dictionary based on the type of vulnerability under consideration.The augmented formula (i.e., F path ∧ F db ∧ F attack ) is next sent to a solver, which provides a solution (if it exists) over the values of the input variables, that is an exploit string. This step is responsible for building an application-wide navigation graph, which represents possible sequences of module executions together with associated constraints.Previous research [7] has recognized the importance of building such a graph. Having a mechanism that automatically generates valid form inputs greatly improves the crawling coverage of web applications since web forms are common constructs that influence the navigation structure.To address this problem, our crawler extracts the forms' input fields, buttons, and action and method attributes (i.e., GET or POST) using an HTML parser and generates a set of constraints over the form values implied by the form attributes. As an example, the constraints for the form in our running example (Listing 1) are:F html : (book name=="Intro to CS by author1" ∨ book name=="Intro to Math by author2")F js : edition > 0 F f orm : F html ∧ F jsFinally, the formula f f orm is sent to the solver to find a solution.NAVEX uses the solver solution, form method, and action fields to issue a new HTTP request to the application (i.e., Addressing Server-side Constraints. As an example, the above inference constructs the following constraints that yield to a successful form submission (book name=="intro to CS by author1" ∨ book name=="intro to Math by author2") ∧ length(publisher)<=35 ∧ edition >0Finally, for each accepted form, NAVEX stores the full HTTP request that led to the successful submission. The id property stores a unique identifier of the node, the URL property is the URL in the HTTP request, which is composed of the module name and HTTP parameters of the request, and the role property holds the login credentials used as input to the crawler as illustrated in Figure 4. The map is constructed by performing a traversal that searches the enhanced CPG for nodes that represent calls to file inclusion PHP functions (e.g., require, include, etc). Since the exploit string for msg is <script> alert("XSS");</script> (generated by the solver and stored in exploit), GetPathsTo explores the following navigation paths between the SeedURL and DestURL: (1) nodes of [id=2, id=3, id=4, id=5] and (2) nodes of [id=2, id=3, id=4, id=5, id=6]. The TAC formula analysis and Z3 translation engine code are approx-imately 3600 Java LOC.For Step II, we extended crawler4j [2] by adding support for collecting forms and JavaScript code, extracting constraints from the forms, and generating Z3 assertions. Our criteria for selecting the applications include: (i) evaluation on the latest versions of popular, complex and large PHP applications such as Joomla, HotCRP, and WordPress, and (ii) comparison of NAVEX on the same test applications used by state-of-the-art work in exploit generation (e.g., Chainsaw [7]) and vulnerability analysis (e.g., RIPS [15], [16]). The inclusion of client-side code analysis for building the navigation graph enhanced the precision of exploit generation by 54% on average. myBloggie 2m 2 SchoolMate 0 5 WebChess 1m 36sec 2 Eve 1m 5sec 1 geccbblite 57sec 1 Scarf 1m 44sec 2 FAQforge 47sec 1 WeBid 9m 29sec 2 DNscript 51sec 1 phpBB2 2m mssql query, mysql query, mysqli query, and sqlite query as sinks for SQLI vulnerability.14sec 2 HotCRP (2.60) 30m 13sec 4 osCommerce (2.3.3) 2hr 6m 32sec 2 CPG 24m 40sec 2 MediaWiki 15m 30sec 1 LimeSurvey 46sec 2 osCommerce (2.3.4) 2hr 19m 1sec 2 OpenConf 2m 1sec 2 Gallery3 5m 51sec 2 Collabtive 24m 2sec 3 Total time 6hr 27m 18sec Graph database size 104.44 MiBIt reported a total of 155 SQLI exploitable sinks with a running time of 37m and 45sec. Selected SQLI Exploit.One of the applications for which NAVEX generated a large number of SQLI exploits is WeBid. In the following, we demonstrate one of these exploits, which illustrates the precision of our analysis in capturing the effect of custom and built-in sanitization functions along different paths to sinks.Listing 6 shows the vulnerable sink (echo) where user input $HTTP GET VARS['page'] passes through 3 different functions and it is finally processed by either htmlspecialchars or strtr PHP func-tions. All the calls are not vulnerable, and therefore, NAVEX did report any exploitable code execution sinks, and no exploits were generated. NAVEX successfully constructed 105 exploits for 155 SQLI sinks, 90 exploits for 128 XSS sinks, and 9 exploits for 19 EAR vulnerabilities. Overall, the number of reported vulner- able sinks for each vulnerability type is reduced, on an average, by 87% due to enhancements implemented on CPGs to significantly cut-down false positives. In addition, NAVEX found 71 vulnerable sinks in HotCRP, osCommerce, and phpBB because it can handle object-oriented PHP code, which is not available in Chainsaw. NAVEX constructed 19 more exploits in WeBid, myBloggie, geccbblite, WebChess, and FAQforge, and achieved the same for Eve, scarf, and DNscript. For example, forms that have inputs of type file require the user to select and upload an actual file from Comparison on the number of generated (SQLI+XSS) exploits. For instance, there were 3 false positives reported for EAR vulnerability in Joomla, OpenConf, and MediaWiki. While our work uses the flexibility and efficiency that CPGs offer, our problem goes a step further to generate actual executable exploits. In this paper, we present NAVEX, an automatic exploit generation system that takes into account the dynamic features and the navigational complexities of modern web applications.