Specifically , patches in KARMA can be placed at multiple levels in the kernel to filter malicious inputs, and they can be automatically adapted to thousands of Android devices. Therefore, Android kernel vulnerabilities pose a serious threat to user privacy and security.Tremendous efforts have been put into finding (and exploiting) Android kernel vulnerabilities by both whitehat and black-hat researchers, as evidenced by the significant increase of kernel vulnerabilities disclosed in Android Security Bulletin [3] in recent years. Unfortunately, officially patching an Android device is a long process involving multiple parties with disparate interests: Google/the vendor verifies a reported vulnerability and creates a patch for it.The patch is then thoroughly tested and released to carriers; carriers test the update again for compatibility with their networks and release it to their users as an overthe-air (OTA) update. For example, Android Lollipop (Android 5.0) was released in November 2014; as of September 2016, 46.3% of Android devices still run an older version of Android with little hope of any future updates [2]. 2 KARMA is a part of the OASES (Open Adaptive Security Extensions, https://oases.io) project, an initiative founded by Baidu to enable fast and scalable live patching for mobile and IoT devices. The main contributions of our paper are four-fold:â€¢ We analyzed the fragmentation issue that hinders existing kernel live patching solutions to be ubiquitously applied on Android devices, and brought the need of an adaptive Android kernel patching solution to light. Based on these insights, we propose KARMA, a multi-level adaptive patching model that can be applied to the fragmented Android ecosystem. These observations can serve as a foundation for future systems tackling this problem.Observation A: most kernel functions are stable across devices and Android releases.Android (Linux) kernel is a piece of large and mature software. Specifically, we abstract the syntax of each function by the number of its arguments, the conditional branches it contains, the functions called by it, and nonstack memory writes. Vulnerabilities in shared functions should be given a higher priority for patching because they affect more devices.Observation B: many kernel vulnerabilities are triggered by malicious inputs. Most (exported) kernel functions follow the official coding style and return error codes -even kernel functions that return pointers often return out-of-range "error codes" using the ERR_PTR macro.Based on these observations, our approach is as follows: for each applicable vulnerability, we create a patch that can be placed on the vulnerable function to filter malicious inputs. The security is enforced by the following two technical constraints:Rule I, a patch can only be placed at designated locations, and its patched function must be able to return error codes or return void (i.e., no return value). Our experiment with 76 critical kernel vulnerabilities shows that level 1 can patch 49 (64%) vulnerabilities, level 2 can patch 22 (29%) vulnerabilities, and we have to fall back to level 3 in only 5 cases (7%). This rule is enforced by providing a set of restricted APIs as the only interface for the patches to access the kernel data.By combining these two rules with a careful vetting process and the memory-safety of the patches, we can strictly confine the run-time behaviors of patches to prevent them from potential misuse. Matching semantics with symbolic execution can abstract syntactic differences in function binaries (e.g., register allocation). In the unlikely event that a patch causes the device to malfunction, the user can reboot the device and skip the problematic patches 1 function kpatcher ( patchID , sp , cpsr , r , r1 , r2 , r3 , r4 , r5 , r6 , r7 , r8 , r9 , r1 , r11 , r12 , r14 ) 2 if patchID == xca5269db5f4 then 3 uaddr1 = r 4 uaddr2 = r2 5 if uaddr1 == uaddr2 then by holding a hardware key. In the rest of this section, we first illustrate KARMA's patches and then present these two phases in detail. They allow the patch to access function argu-1 s t a t i c i n t sock _diag _rcv_m sg ( s t r u c t sk_buff * skb , s t r u c t nlmsghdr * nlh ) 2 { 3... CVE-2013-1763: Figure 5 shows the original source code patch for CVE-2013-1763. This terminates the execution gracefully.CVE-2016-0802: this is a buffer overflow in the 1 s t a t i c l o n g msm_ioctl_server ( s t r u c t file * file , v o i d * fh , bool valid_prio , i n t cmd ,v o i d * arg ) 2 { 3 ... 4 i f ( copy_from_user (& u_isp_event , 5 ( v o i d __user *) ioctl_ptr -> ioctl_ptr , 6s i z e o f ( s t r u c t m sm_ is p_ ev en t_ ct rl ) ) ) { 7... 8 } 9. This is an example of KARMA's multi-invocation patches (also called stateful patches). It first identifies the vulnerable function in a target kernel through structural and semantic matching; then it uses the information from semantic matching to customize the patch for the target kernel. For example, CVE-2015-3636 [30], exploited by PingPong root, exists in function ping_unhash in the Google Nexus 5 kernel but ping_v4_unhash in some other kernels. For two Android kernels, the same source code could be compiled into different binaries -they may vary in register allocation, instruction selection, and instruction layout. We do not take stack writes into consideration because the same function may have different stack layouts in two kernels.To compare their semantics, we symbolically execute the basic blocks of F r and F t and generate constraints for memory writes and function calls. External inputs to these two functions, such as initial register values, non-local memory reads, and sub-function returns, are symbolized.KARMA supports two modes of operation: in the strict mode, we require that two matching constraints are exactly the same, except for constants. The app contacts the KARMA servers to retrieve patches for the device, while the kernel module verifies the integrity of these patches and applies ones that pass the verification. Free the allocated memory for live patching get_callee Locate a callee that can be hooked search_symbol Get the kernel symbol address current_thread Get the current thread context read_buf Read raw bytes from memory with the given size read_int_8Read 8 bits from memory as an integer read_int_16Read 16 bits from memory as an integer read_int_32Read 32 bits from memory as an integer read_int_64Read 64 bits from memory as an integer used by patches to read kernel data. In the interrupt context, the Lua engine is directly invoked through the engine's C interface, similar to a regular function call. The kernel is a concurrent execution environment, especially with multi-core CPUs, which most Android devices have. By keeping the states across invocations, KARMA can support multi-invocation patches, i.e., complex patches that need to combine the results of several executions to make a decision. Our symbolic execution engine was based on the angr framework [6,44]. Applicability quantifies how many existing kernel vulnerabilities can be patched by KARMA, and adaptability quantifies how many devices that KARMA can adapt a reference patch for. In the following, we describe how KARMA can prevent some interesting kernel vulnerabilities used in one-click rooting apps and recent malware incidents [5,17,18,21]. KARMA can patch this vulnerability by validating whether the memory to be mapped is within the user space.CVE-2013-2596 (MotoChopper): an integer overflow in the fb_mmap function allows a local user to create a read-write mapping of the entire kernel memory and consequently gain the kernel privileges. Specifically, the opcode-based clustering classifies kernel functions by types and frequencies of instruction opcodes; the syntax-based clustering classifies kernel functions by function calls and conditional branches; and the semantic-based clustering classifies kernel functions according to KARMA's semantic matching results. To evaluate the performance overhead of KARMA, we experimented with both a standard Android benchmark (CF-Bench [9]) and a syscall-based micro-benchmark. Considering the fact that most critical kernel vulnerabilities exist in less-hot code paths (e.g., device drivers' ioctl interfaces as shown in Table 6), we consider KARMA's performance is sufficient for real-world deployment.The first benchmark measures the whole system performance with CF-Bench. This measures the overhead of the Lua APIs provided by KARMA. In addition, Android O formalizes the interface between the Android framework and the vendor implementation so that, eventually, the Android framework can be updated independent of the vendor implementation (aka. We are investigating alternative designs that can achieve similar security guarantees, such as BPF [8] and sandboxed binary patches.Third, KARMA leverages the existing error handling code in the kernel to handle filtered malicious inputs, in order to keep the kernel as stable as possible. If KARMA's automated adaption cannot find a proper function to patch, we can fall back to the binary patch for this particular vulnerability.Lastly, KARMA is a third-party kernel live patching system. Kernel live patching: the first category of the related work consists of a number of kernel live patching systems, such as kpatch [23], kGraft [22], Ksplice [27], and KUP [37]. Third, binary patches are prone to misuse because they are hard to understand and vet, and these systems have no strong confinement of patches' run-time behaviors. In addition, it leverages the fact that most kernel functions remain semantically similar across different kernel versions to significantly speedup the comparison. It inserts SWRRs (Security Workarounds for Rapid Response) into the kernel source code in order to temporarily protect kernel vulnerabilities from being exploited. ASSURE introduces rescue points that can recover software from unknown exploits while maintaining system integrity and availability [45]. Yue Chen and Zhi Wang were supported in part by the US National Science Foundation (NSF) under Grant 1453020 and a grant from Baidu X-Lab. To fix this bug, Linux simply adds a check to ensure that these two futex addresses are different [13]. Case Studies A. 1 CVE-2014-3153 (Towelroot) this vulnerability is the second most-used one to root Android devices, known as "Towelroot". To fix this bug, Linux simply adds a check to ensure that these two futex addresses are different [13]. The Linux patch sets the pointer to NULL in the ping_unhash function [16].