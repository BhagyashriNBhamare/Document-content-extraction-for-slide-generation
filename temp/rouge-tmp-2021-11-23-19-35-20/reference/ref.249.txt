Once compromised, server firmware can surreptitiously and permanently take over a machine and any stack running thereon, with no hope for recovery, short of hardware-level intervention. To make things worse, modern firmware contains millions of lines of unnecessary code and hundreds of unnecessary modules as a result of a long firmware supply chain designed to optimize time-to-market and cost, but not security. DECAF has successfully pruned over 70% of unnecessary, redundant, reachable firmware in leading server-grade moth-erboards with no effect on the upper layers, and increased resulting system performance and boot times. A motherboard firmware company (American Megatrends, Phoenix Technologies, etc.) adds the necessary modules from Intel for a particular chipset along with any other modules needed for their base design. At each stage, modules are added to the firmware, but typically, for time and cost reasons, nothing is optimized or removed, including any generic modules that do not apply to the specific hardware being delivered.Furthermore, firmware fixes are often neglected even for motherboards only 6-12 months old. To make matters worse, in the case of firmware, exploits can completely compromise an entire system, including any trust chains and security mechanisms such as "secure boot" [11]. This results in a linear reduction of the overall vulnerability surface and availability of exploits.In this work we propose to automatically and dynamically prune significant amounts of unnecessary binary code from a large class of COTS firmware without impacting the functionality of the upper layer of the stack (OS, applications). Many common attack vectors on UEFI have modern mitigations that manufacturers fail to properly configure.In a survey of firmware vulnerabilities [29] covering 2015-2017, not only are the total numbers concerning, but there is also an increasing trend in the number of vulnerabilities due to lack of proper configurations of increasingly numerous security options.Firmware expert Nikolaj Schlej, perhaps best known as the author of the widely used and popular UEFITool [36], has been sounding the alarm for years through various of talks and presentations. For example, in [38] numerous vulnerabilities for off the shelf firmware are introduced. If done properly, as a result of the UEFI structure, it can be applied at module granularity to any motherboard, even without access to the source code.DECAF is an extensible platform for automatically pruning a wide class of commercial UEFI firmware. The resulting firmware boots significantly faster as well.At first, it may seem that code that does not affect functionality is unreachable, and thus its removal may be of little security benefit. Most firmware contains active, reachable code that is simply unused by the upper layers but poses significant vulnerability challenges (e.g. multiple network stacks, obsolete drivers for tens of peripherals/USB/VGA, entire GUIs, etc.). UEFI firmware can be easily customized to retain or remove only desired functionality. 2.1 UEFI UEFI (originally EFI) was developed to replace legacy BIOS with a more standardized solution in order to improve interoperability between vendors. UEFI splits the lifetime of platform initialization into 4 distinct phases: (1) Security (SEC), (2) Pre-EFI Initialization Environment (PEI), (3) Driver Execution Environment (DXE), (4) Boot Device Selection (BDS). Finally, the DXE stage passes control to the BDS where the OS boot loader takes over execution. This may include firmware for the Intel R Management Engine, or e.g. the network interfaces. Individual modules can be removed, with the BIOS region and firmware volumes rebuilt into a new, pruned image.In 2017, Intel made a statement that they would be ending support for legacy BIOS compatibility by 2020 [23]. For executable UEFI modules, one of the sections will contain a PE32 binary image. If the DEPEX expression evaluates to true (i.e., required modules and protocols have already been loaded), the module can be loaded, otherwise it is postponed.Unfortunately, the dependency section is not very helpful in determining which modules actually depend on one another. The selection of a pruning strategy should have two primary concerns: its runtime and the quality of the results it produces.The property of a particular pruning strategy that most affects runtime is the number of test iterations that must be performed. The time required to perform a single test of a particular pruned state is on the order of minutes, so exhaustive searches simply aren't feasible.As for quality, the number of modules removed is the metric most directly affected by choice of strategy; any strategy will remove one module at a time, and the order in which modules are removed determines how many modules are kept, due to the nature of inter-module dependencies. Delta debugging works best on well-structured inputs, and most approaches that utilize it rely on improving the coherency of the structure through high-level analysis [28] [40]. Hill-climbing can easily be used to incrementally improve the results of other strategies.Another approach that will be considered as a baseline is to incrementally build a removal set R, initially empty. q refers to a number of DAG edges to be selected randomly between the p removable modules. Assuming that roughly 60% of the firmware modules are removable, it can be observed that as expected, hill-climbing is able to fully prune the firmware regardless of the module connectivity, and the performance of the linear removal and delta debugging approaches is inversely proportional to q.In order to achieve similar levels of module removal, linear removal methods could take on one of two approaches. Another potentially interesting heuristic would be one that runs some form of static analysis on the modules prior to pruning, giving a high removal chance to modules that are likely to contain some kind of bug or exploitable code.One heuristic used to great effect in DECAF involves runtime UEFI module dependency. For example, a module with no dependencies may be assigned a high removal chance, while a module with many dependencies may receive a low one.DECAF also halves the chance of a module being removed if a removal set including that module fails to pass the validation targets. If, at any point, a failure is encountered, the corresponding module's chance of being removed again is decreased by half.After the modules are tried individually, the results are merged in the following fashion: if only one module set was removed successfully, return that set. DECAF is composed of multiple modules, each responsible for a subtask of the overall pruning process.DECAF needs to be capable of managing a physical board in order to control and monitor power, flash firmware images, and monitor overall hardware health. These images need to be booted and validated in order to iteratively converge to a minimal image. The Luigi [39] workflow engine (represented by A in Figure 4) was chosen for the high level management of the pruning process. It provides a high level task overview that can be used to monitor and manage the pipeline iterations. Luigi's native concept of workers and dependencies also makes parallelization easy when multiple identical boards are available. UEFITool is a mature UEFI firmware image editing application written in C++ with Qt. It works and is tested on a wide range of firmware across a variety of vendors.We implemented a scriptable Python layer that utilizes the C++ backend of UEFITool, allowing for headless traversal and pruning of firmware images. Given the structure of an EFI image, modules can not only be pruned, but also appended to the binary.DECAF appends two modules to the original image: (i) dependency probe, and (ii) dependency dump. Dependency probe is used to hijack several protocols that modules use frequently when interacting with each other (such as EFI_INSTALL_PROTOCOL_INTERFACE). Overwriting these pointers very early in the DXE phase will cause all modules executing after this to use the hijacked functions instead. The hijacked protocols are simply wrappers over the original functions that also log the GUID of the calling module.Collected data is stored in memory. Depending on the desired outcome, modules present in the graph can be excluded from the pruning process (this will result in a bigger final image, but it would attempt to preserve the original execution flow as recorded at runtime). In this particular case, the graph from Figure 5 is generated from the firmware of SuperMicro A1SAi-2550F. The original image contains 244 modules while the full graph has 147 nodes (modules) and 3881 edges (inter-module interaction). Out of the 147 recorded modules, 100 nodes have an in degree of 0 (i.e., no dependents), making them the second best removal candidates after the modules that have no data recorded. The guest can only see a memory map where accessing particular addresses will result in various side effects (such as manipulating hardware via registers). Taking this into account, the only way to test whether a pruned firmware image is functioning correctly is to flash it onto the motherboard and boot an operating system to validate that everything is still working as expected by running a test suite. This requires controlling the motherboard in an automated fashion to accomplish a few tasks: (1) power control, (2) power monitoring, (3) flashing firmware images, and (4) providing boot media. For convenience, motherboards with a BMC (Board Management Controller) that provides IPMI (Intelligent Platform Management Interface) were selected for DECAF since they offer all of the services required. When implemented behind the API, this would work seamlessly with the rest of the components.Because the aim of DECAF is to harden trusted code base residing at the firmware level, it is worth mentioning that the various IPMI implementations are not really secure, as emphasized by [9]. The whole pruning process tends to run over the course of a few days, so any time savings that can be obtained are valuable.The IPMI controller monitors the network and waits for the Linux boot media to bring the motherboard's network interfaces up and negotiate DHCP. For example, the PCI hardware configuration of the image is recorded so that on subsequent tests it can be determined if any of the hardware components on the board were not brought up properly. For example, in the dmidecode validation target discussed later in this section, we check only memory and CPU configuration types. Other System Management BIOS (SMBIOS)/Desktop Management Interface (DMI) information (OEM strings, system configuration options, etc.) are not strictly necessary to the functionality of the device, but of course can be easily included if a user desires.As will be discussed further in Section 5, the pruning pipeline was run with two profiles, "aggressive" and "data center." /proc/acpi is checked to ensure the operating system will be able to perform ACPI power management.4. Intel's CHIPSEC framework is used to monitor and validate the security integrity of these modified images [24]. CHIPSEC scans the system for known firmware level vulnerabilities and reports them; these reports are compared against the report from the original image to ensure that no additional vulnerabilities are introduced by the pruning process. Further, e.g., our HP server contains four critical errors: one stemming from Spectre-style vulnerabilities, and three from improperly configured protections that may allow an attacker to modify the bootflow, overwrite SMRAM via Direct Memory Access (DMA) attacks, or even overwrite the BIOS through the SPI chip.DECAF prunes modules but does not (yet) patch modules (i.e., to fix such vulnerabilities in remaining modules). The pruning process was run with two profiles: "aggressive" pruning, where only booting from physical media (or physical media emulated by the board's BMC) was required, and "data center" pruning, where the boards were pruned for the purpose of running in cloud data centers offering compute-asa-service, booting over iPXE.A visualization of the aggressive pruning process can be seen in Figures 6 and 7 on firmware from two different motherboards: the SuperMicro A1SAi-2550F and the Tyan 5533V101, respectively. The aggressive pipeline was able to remove a much larger portion of the firmware than the data center pipeline, removing over 70% of the firmware bytes from the SuperMicro motherboard and almost 40% from the Tyan and HP motherboards. The SuperMicro motherboard booted 13 seconds faster on average, and the Tyan motherboard booted 7 seconds faster on average with the pruned firmware.Data Center. The IPMI based communication is not necessarily standard (nor too well documented) for each vendor. Secondly, virtualization does not produce good results: the virtualized environment is highly different from a real board in terms of BIOS: the modules loaded are different and the hardware emulated is different (and not customizable enough for our purposes). It is important to note that all motherboards have inherently similar functionality, and their firmware is based on a common open source implementation. Second, we wanted to explore the usage of the same modules within 5 different EFI images that were created by the same vendor. Also there is a 100% match between several versions (this happens because the changes are below modular granularity). Benefits of code reduction include: reduced TCB -at the industry-average of 1.5-5% bugs per line of code [27], this can add up to thousands of (undiscovered) bugs and hundreds of exploits -reduced boot time, the ability to fit the firmware onto a smaller SPI chip etc, removal of physical attack vectors such as over peripherals (e.g., USB), and a reduction in the number of Return Oriented Programming (ROP) gadgets etc. Further, removing rarely used features (features likely to be removed by the DECAF pipeline) provides a proportionally higher benefit. If an attacker can cause the manufacturer module to fail to execute (perhaps because it contains a less significant defect), then the EDK II module will be loaded when another module looks up the DHCP protocol.Similarly, ROP gadgets can be used to load a normally unused module directly (Section 5.3). The goal of DECAF is to maximally reduce the vulnerability surface of the hundreds of bugs that are still unknown.In fact firmware vulnerabilities (some fatal [38]) do not receive anywhere near as much attention, publicity, and tracking when compared with OS and software vulnerabilities. Searches for specific models or product lines we pruned reveal a few more, but virtually all relate to the BMC and not the firmware itself.Nevertheless, in addition to reducing the overall vulnerability surface, DECAF also helps mitigate a number of common attack vectors including: Return Oriented Programming (ROP), USB attacks, SMM attacks, and network attacks. Gality [4] is a tool that seeks to analyze the entire set of gadgets available in a binary and determine how many of them are "high-quality." DECAF pruning reduces the total gadgets available by 12 to 64% and reduces the high-quality gadgets available by 11 to 62%. This presents two new attack vectors: 1) if an attacker can overwrite SMRAM, she can execute arbitrary code in a highly privileged state, and 2) if she can gain access to the SMM communication buffer, and there exists an exploit in an SMI handler, she can escalate an OS attack into a BIOS attack.Kallenberg et al. [20] construct an attack of the latter type. The firmware in question (Dell Latitude E6400, BIOS revision A29) provides an SMI routine that allows flashing of the BIOS from the OS. This has been demonstrated by Matt Weeks at Defcon 19 [42]. It is important to note that there is no guarantee the target feature can be disabled by removing a single module from the image; a set of modules might be removed in order to achieve the desired effect.Further, to disable the support for a given feature, other side effects may appear -e.g., DECAF may not be able to remove a single USB port; only all USB ports.As an example, consider the SuperMicro A1SAi-2550F motherboard. Pruning to eliminate USB support results in a removal of 6 modules out of a total of 244. Crucially, ROP gadgets are almost never eliminated entirely, and therefore the benefit of reducing their count is reduced by the fact that the remaining gadgets may still provide viable exploit paths. Since DECAF prunes entire, self-contained binaries, it does not rewrite code nor does it rearrange the existing control graph in binary blobs, and thus introduces zero new gadgets. Apart from driving highly esoteric motherboardspecific hardware (which would likely employ non-UEFI firmware anyway), most functionality is often taken over by OS drivers which are more powerful and up to date.In our experience of successfully running heavily pruned images in production data centers since 2017, having the OS successfully boot and pass basic sanity checks is sufficient for thousands of even the most demanding enterprise applications running on top. In their work, they present motivating examples wherein static analysis and dynamic analysis alone cannot remove all the dead code and security vulnerabilities in the code.Both program slicing and debloating software mechanisms can be used to improve our pruning mechanism, however there are two important aspects to be considered before one can adopt and adapt them. The EDK II project contains about 1.4M lines of C/C++/Header code and 19K lines of assembly, a small but not insignificant amount.Rastogi et al. use dynamic analysis techniques to automatically debloat and harden docker containers, removing unused resources and partitioning the executeables within the container based on the resources they access [33]. Their testing environment makes use of a generic and open source UEFI implementation, and replicating it on a closed source UEFI might not be possible, given the difficulty in emulating non-generic hardware.The article from [22] presents an extremely similar approach, but focused on debloating the Linux Kernel instead. According to this work the Linux Kernel has roughly 11,000 configuration options, which will be automatically tailored to minimize the code base while maintaining the functionality determined in the usage scenarios, removing up to 70% of it.RedDroid [18] is a project that targets software bloat in the Android world. On average the APK size can decrease by 42%. 38 new CVEs were also submitted, as the framework also attempts to extract and crack password hashes, private keys and certificates, find back doors and target various other common hot spots. This particular scenario shows how vulnerable software is reused in different applications, and a pruning framework (such as DECAF) can potentially remove such threats.Of particular interest to many security-conscious users is the Intel Management Engine (ME), which is co-processor integrated into almost all Intel-based motherboards since 2006.