Since these fingerprints provide the malware a chance to split its behavior depending on whether the analysis system is present or not, existing analysis systems are not sufficient to analyze the sophisticated malware. NINJA leverages a hardware-assisted isolated execution environment Trust-Zone to transparently trace and debug a target application with the help of Performance Monitor Unit and Embedded Trace Macrocell. However, sophisticated malware, which is also known as evasive malware, is able to evade the analysis by collecting the artifacts of the execution environment or the analysis tool, and refuses to perform any malicious behavior if an analysis system is detected.As most of the existing mobile malware analysis systems [18,45,52] are based on emulation or virtualization technology, a series of anti-emulation and antivirtualization techniques [29,36,48] have been developed to challenge them. To address this challenge, researchers study the malware on bare-metal devices via modifying the system software [22,37,44,55] or leveraging OS APIs [15,56] to monitor the runtime behavior of malware. How to build a transparent mobile malware analysis system is still a challenging problem.This transparency problem has been well studied in the traditional x86 architecture, and similar milestones have been made from emulation-based analysis systems [2,40] to hardware-assisted virtualization analysis systems [19,20,32], and then to bare-metal analysis systems [30,31,41,54]. However, this problem still challenges the state-of-the-art malware analysis systems.We consider that an analysis system consists of an Environment (e.g., operating system, emulator, hypervisor, or sandbox) and an Analyzer (e.g., instruction analyzer, API tracer, or application debugger). Secondly, the Environment exists on an off-the-shelf (OTS) bare-metal platform without modifying the software or hardware (e.g., emulation and virtualization are not). Finally, the Analyzer should not leave any detectable footprints (e.g., files, memory, registers, or code) to the outside of the Environment. An Analyzer violating this requirement can be detected.In light of the three requirements, we present NINJA 1 , a transparent malware analysis framework on ARM platform based on hardware features including TrustZone technology, Performance Monitoring Unit (PMU), and Embedded Trace Macrocell (ETM). We evaluate the performance of the trace subsystem with several popular benchmarks, and the result shows that the overheads of the instruction trace and system call trace are less than 1% and the Android API trace introduces 4 to 154 times slowdown.The main contributions of this work include:• We present a hardware-assisted analysis framework, named NINJA, on ARM platform with low artifacts. NINJA resides in a hardware isolation execution environment, and thus is transparent to the analyzed malware. ARM TrustZone technology [12] introduces a hardwareassisted security concept that divides the execution environment into two isolated domains, i.e., secure domain and non-secure domain. In ARMv8 architecture, the only way to switch from normal domain to secure domain is to trigger a secure exception [8], and the exception return instruction eret is used to switch back to the normal domain from the secure domain after the exception is handled. While entering the secure domain, the ATF saves the context of the normal domain and dispatches the secure exception to the corresponding exception handler. The Performance Monitors Unit (PMU) [8] is a feature widely implemented in both x86 and ARM architectures [42], which leverages a set of performance counter registers to calculate CPU events. The generated elements are encoded into a trace stream and sent to a pre-allocated buffer on the chip.According to Futuremark [23], 21 of the most popular 50 smartphones and tablets are equipped with ARM Cortex-A5x or Cortex-A7x series processors, in which the PMU and ETM components are included. LO-PHI [41] leverages additional hardware sensors to monitor the disk operation and periodically poll memory snapshots, and it achieves a higher transparency at the cost of incomplete view of system states.MalT [54] increases the transparency by involving System Manage Mode (SMM), a special CPU mode in x86 architecture. The instruction and system call tracing introduce negligible overhead, which is immune to timing attacks while MalT suffers from external timing attack.BareCloud [31] and MalGene [30] focus on detecting evasive malware by executing malware in different environments and comparing their behavior. Lastly, after these tools identify the evasive malware from the large-scale malware samples, they still need a transparent malware analysis tool which is able to analyze these evasive samples transparently. KVM/ARM [17] uses standard Linux components to improve the performance of the hypervisor. Although the hardware virtualization based solution is considered to be more transparent than the emulation or traditional virtualization based solution, it still leaves some detectable footprints on CPU semantics while executing specific instructions [39]. TZ-RKP [13] runs in the secure domain and protects the rich OS kernel by event-driven monitoring. SeCReT [28] is a framework that enables a secure communication channel between the normal domain and the secure domain, and provides a trust execution environment. Brasser et al. [14] use TrustZone to analyze and regulate guest devices in a restricted host spaces via remote memory operation to avoid misusage of sensors and peripherals. Zone provides hardware-based isolation between the normal and secure domains while the rich OS (e.g., Linux or Android) runs in the normal domain and NINJA runs in the secure domain. During the execution of an application, we use secure interrupts to switch into the secure domain and then resume to the normal domain by executing the exception return instruction eret. ARM Generic Interrupt Controller (GIC) [5] partitions all interrupts into secure group and non-secure group, and each interrupt is configured to be either secure or non-secure. The switch from secure domain to normal domain is achieved by executing the exception return instruction eret. The Trace Subsystem (TS) provides the analyst the ability to trace the execution of the target application in different granularities during automatic analysis including instruction tracing, system call tracing, and Android API tracing. It establishes a secure channel between the target executing platform and the remote debugging platform, and provides a user interface for human analysts to introspect the execution status of the target application.To interrupt the execution of the target, we configure the PMI to be secure and adjust the value of the PMU counter registers to trigger an overflow at a desired point. To ensure the PMI will be triggered again, the DS sets desirable values to the PMU registers before exiting the secure domain.Moreover, similar to the TS, we specify the granularity of the debugging by monitoring different PMU events. In the DS, NINJA uses PMI to trigger a trap to EL3. Since NINJA is implemented in the secure domain, it cannot understand the semantic information of the normal domain, and we have to fill the semantic gap to learn the current running process in the OS.In Linux, each process is represented by an instance of thread info data structure, and the one for the current running process could be obtained by SP & ∼(THREAD SIZE -1) , where SP indicates the current stack pointer and THREAD SIZE represents the size of the stack. However, as a result of Android upgrades, Dalvik is no longer available in recent Android versions, and the approach in DroidScope is not applicable for us.By manually analyzing the source code of ART, we learn that the bytecode interpreter uses ExecuteGotoImpl or ExecuteSwitchImpl function to execute the bytecode. In Android, the bytecode of a Java method is organized as a 16-bit array, and ART passes the bytecode array to the function ExecuteGotoImpl together with the current execution status such as the current thread, caller and callee methods, and the call frame stack that stores the call stack and parameters. In GIC, each interrupt is assigned to Group 0 (secure interrupts) or Group 1 (non-secure interrupts) by a group of 32-bit GICD IGROUPR registers. Each bit in each GICD IGROUPR register represents the group information of a single interrupt, and value 0 indicates Group 0 while value 1 means Group 1. As the secure interrupts are handled in Cortex-A57 core 0, we run the target application on the same core to reduce the overhead of the communication between cores. In our case, as we only need the trace result from the core 0 in the Cortex-A57 cluster, we set the EnS0 bit in CSTF Control Register of funnel 0 and funnel 2, and clear other slave bits. As the target application is always executed in non-secure EL0 or non-secure EL1, we make the ETM only trace these states by setting all EXLEVEL S bits and clearing all EXLEVEL NS bits of the TRCVICTLR register. Note that the trace result is an encoded trace stream, and we use an open source analyzer ptm2human [26] to convert the stream to a readable format. Also, the SELECT bits of the second trace resource selection control register TRCRSCTLR2 (TRCRSCTLR0 and TRCRSCTLR1 are reserved) is configured to 0 to select the external input 0 as tracing resource 2. Since a PMU event BR RETIRED is fired after execution of a branch instruction, we use PMU to trace the BR RETIRED event and reconstruct the semantic information following the approach described in Section 5.1.2 if these functions are invoked.There exist six PMU counters for each processor on Juno board, and we randomly select the last one to be used for the Android API trace and the DS. Next, we set PMEVTYPER5 EL0 register to 0x80000021 to make the counter 6 count the BR RETIRED event in non-secure EL0. There exists two serial port (i.e., UART0 and UART1) in Juno board, and the ATF uses UART0 as the debugging input/output of both normal domain and secure domain. To build a secure debugging bridge, NINJA uses UART1 as the debugging channel and marks it as a secure device by configuring NIC-400 [3]. However, this approach has two fundamental drawbacks: 1) the EL2 is normally prepared for the hardware virtualization systems, which does not satisfy our transparency requirements. Nonetheless, the modification brings the side effect that the self-checking malware may be aware of it.The PMU event INST RETIRED is fired after the execution of each instruction, and we use this event to implement instruction stepping by using similar approach mentioned in Section 5.3.3. The execution of brk instruction is considered as a software breakpoint while the breakpoint control registers DBGBCR EL1 and breakpoint value registers DBGBVR EL1 provide support for at most 16 hardware breakpoints. However, similar to the software step exception, the breakpoint exception generated in the normal domain could not be routed to EL3, which breaks the transparency requirement of NINJA. As an example, the at s12e0r addr instruction performs stage 1 and 2 (if available) translations as defined for EL0 to the 64-bit address addr, with permissions as if reading from addr. The [47:12] bits of the corresponding physical address are storing in the PA bits of the PAR EL1 register, and the [11:0] bits of the physical address are identical to the [11:0] bits of the virtual address addr. As shown in Figure 5, the current executing instruction is the ADD instruction instead of the MOV instruction when the interrupt arrives, and the instruction shadow region between the MOV and ADD instructions is considered as interrupt instruction skid. Although the skid problem cannot be completely eliminated, the side-effect of the skid does not affect our system significantly, and we provide a detailed analysis and evaluation in Section 7.5. The TPM bit of the MDCR EL3 register and the TTA bit of the CPTR EL3 register help to trap the access to PMU and ETM registers to EL3, respectively; then we achieve the transparency by providing artificial values to the normal domain. NINJA then analyzes the instruction that triggers the trap and learns that the return value of PMCR EL0 is stored to the general-purpose register X0. We protect both the registers that we modified (e.g., PMCR EL0, PMCNTENSET EL0) and the registers modified by the hardware as a result of our usage (e.g., PMINTENCLR EL1, PMOVSCLR EL0). Note that this hardware memory region is not initialized by the system firmware by default and the system software such as applications and OSes cannot access it because the memory region is not mapped into the virtual memory. The first parameter of the function, which is stored in the register X0, indicates the target physical address, and we modify the value stored at the register to the corresponding address in the artificial memory region. The target application may use the SoC or external timers to detect the time elapsed in the secure domain since the DS affects the performance of the processor and communicates with a human analyst. Thus, we record the value of the timer or counter while entering NINJA and restore it before existing NINJA. Thus, to make it more precise, we measure the average time consumption of the ATF during the secure exception handling (see Appendix B) and minus it while restoring the timer values. As the instruction tracing in NINJA is immune to the timing attack, we can use the TS to trace the execution of the target with DS enabled and disabled. To evaluate NINJA, we fist compare it with existing analysis and debugging tools on ARM. The status file contains 38 lines in total, and it takes about 0.22 ms to finish executing. To reduce the storage usage of the ETM, we can use real-time continuous export via either a dedicated trace port capable of sustaining the bandwidth of the trace or an existing interface on the SoC (e.g., a USB or other high-speed port) [11]. To get an overview of the sample, we first enable the Android API tracing feature to inspect the APIs that read sensitive information (source) and APIs that leak information (sink), and find a suspicious API call sequence. As we know the network packets are sent via the system call sys sendto, we attempt to intercept the system call and analyze the parameters of the system call. To evaluate the protection mechanism of the system instruction interface, we write an Android application that reads the PMCR EL0 and PMCNTENSET EL0 registers via MRS instruction. The last bit of the PMCR EL0 register and the value of the PMCNTENSET EL0 register are 0, which means that all the performance counters are disabled. This experiment shows that NINJA effectively eliminates the footprint on the system instruction interface. In the upper rectangle, the EN bit 0 shows that the ETM is disabled. To evaluate whether our mechanism that modifies the local timers works, we write a simple application that launches a dummy loop for 1 billion times, and calculate the execution time of the loop by the return values of the API call System.currentTimeMillis(). In this section, we evaluate the performance overhead of the trace subsystem due to its automation characteristic. Performance overhead of the debugging subsystem is not noticed by an analyst in front of the command console, and the debugging system is designed with human interaction.To learn the performance overhead on the Linux binaries, we build an executable that using an open source π calculation algorithm provided by the GNU Multiple Precision Arithmetic Library [46] to calculate 1 million digits of the π for 30 times with the tracing functions disabled and enabled, and the time consumption is shown in Table 2. The Android API tracing brings 4x slowdown on the native score and 154x slowdown on the Java score, and the overall slowdown is 8x. We evaluate the listed 218 bytecode opcode [24] on the Android official website, and it shows that the shadow region cannot cover the machine code for any of them. Then, the counter value after switching into EL3 is the time delay of the skid in CPU cycles. However, using the CPU cycle event may lead to multiple PMIs for a single instruction since the execution of a single instruction may need multiple CPU cycles, which introduces more performance overhead but with more fine-grained instruction-stepping. To address this problem, we need to fully virtualize the PMU and ETM, and this is left as our future work.Though NINJA protects the system-instruction interface access to the registers, the mechanism we used to protect the memory mapped interface access maybe vulnerable to advanced attacks such as directly manipulating the memory-mapping, disabling MMU to gain physical memory access, and using DMA to access memory. It embodies a series of analysis functionalities like tracing and debugging via hardware-assisted isolation execution environment TrustZone and hardware features PMU and ETM. mr a sOutput the content of the memory starting from 64-bit virtual address a with size s. Then we insert an SMC instruction between the two read instructions to trigger a domain switching with NINJA disabled, and the difference of the CPU cycles represents the round trip time of the domain switching in ATF.